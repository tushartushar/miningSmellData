Implementation smell,Namespace,Class,File,Method,Description
Long Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,Visit,The method has 438 lines of code.
Long Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitMethod,The method has 129 lines of code.
Long Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitTypeNode,The method has 124 lines of code.
Long Method,Microsoft.Cci,StandardDoubleVisitor,C:\repos\Reactive-Extensions_IL2JS\CCI\DoubleVisitor.cs,Visit,The method has 457 lines of code.
Long Method,Microsoft.Cci,Duplicator,C:\repos\Reactive-Extensions_IL2JS\CCI\Duplicator.cs,VisitTypeReference,The method has 286 lines of code.
Long Method,Microsoft.Cci,ReGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI\ILGenerator.cs,Visit,The method has 158 lines of code.
Long Method,Microsoft.Cci,ReGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI\ILGenerator.cs,VisitAssignmentStatement,The method has 138 lines of code.
Long Method,Microsoft.Cci,ReGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI\ILGenerator.cs,VisitBranch,The method has 137 lines of code.
Long Method,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetTemplateInstance,The method has 122 lines of code.
Long Method,Microsoft.Cci,NamespaceScope,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetType,The method has 113 lines of code.
Long Method,Microsoft.Cci,NamespaceScope,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetType,The method has 153 lines of code.
Long Method,Microsoft.Cci,Specializer,C:\repos\Reactive-Extensions_IL2JS\CCI\Specializer.cs,VisitTypeReference,The method has 299 lines of code.
Long Method,Microsoft.Cci,StandardVisitor,C:\repos\Reactive-Extensions_IL2JS\CCI\StandardVisitor.cs,Visit,The method has 579 lines of code.
Long Method,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The method has 318 lines of code.
Long Method,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,ClearStatics,The method has 286 lines of code.
Long Method,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The method has 422 lines of code.
Long Method,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,SetupMetadataWriter,The method has 120 lines of code.
Long Method,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,Visit,The method has 212 lines of code.
Long Method,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitAssignmentStatement,The method has 169 lines of code.
Long Method,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitBranch,The method has 149 lines of code.
Long Method,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitMethodBody,The method has 191 lines of code.
Long Method,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The method has 249 lines of code.
Long Method,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The method has 175 lines of code.
Long Method,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WritePE,The method has 138 lines of code.
Long Method,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WriteNTHeader,The method has 101 lines of code.
Long Method,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetCachedAssembly,The method has 115 lines of code.
Long Method,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetAssemblyFromReference,The method has 192 lines of code.
Long Method,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetMethodFromDef,The method has 220 lines of code.
Long Method,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetMemberFromRef,The method has 167 lines of code.
Long Method,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetTypeMembers,The method has 105 lines of code.
Long Method,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseTypeSignature,The method has 124 lines of code.
Long Method,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The method has 315 lines of code.
Long Method,Microsoft.Cci.Metadata,InstructionParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseInstruction,The method has 273 lines of code.
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,ValuesAreEqual,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,Cyclomatic complexity of the method is 19
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,Cyclomatic complexity of the method is 19
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,Cyclomatic complexity of the method is 19
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,Cyclomatic complexity of the method is 19
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,Cyclomatic complexity of the method is 19
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,Cyclomatic complexity of the method is 19
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,Cyclomatic complexity of the method is 19
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,Cyclomatic complexity of the method is 19
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,Cyclomatic complexity of the method is 19
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,Cyclomatic complexity of the method is 19
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,Cyclomatic complexity of the method is 19
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,Cyclomatic complexity of the method is 19
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,Cyclomatic complexity of the method is 19
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitAliasDefinitionList,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitAssembly,Cyclomatic complexity of the method is 16
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitAssemblyReference,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitAssemblyReferenceList,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitAttributeNode,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitAttributeList,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitBlockList,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitCatchList,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitCompilationUnitList,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitComprehensionBinding,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitConstructArray,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitDelegateNode,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitEnumNode,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitEvent,Cyclomatic complexity of the method is 17
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitExpressionList,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitFaultHandlerList,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitField,Cyclomatic complexity of the method is 19
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitFieldList,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitFilterList,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitFor,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitForEach,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitFunctionDeclaration,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitInterfaceReferenceList,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitLocal,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitLocalDeclarationList,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitLocalDeclarationsStatement,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitMemberBinding,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitMemberList,Cyclomatic complexity of the method is 21
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitMethod,Cyclomatic complexity of the method is 29
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitMethodList,Cyclomatic complexity of the method is 17
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitModule,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitModuleReferenceList,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitNamespace,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitNamespaceList,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitNodeList,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitParameter,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitParameterList,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitProperty,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitSecurityAttributeList,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitStatementList,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitSwitchCaseList,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitTypeswitchCaseList,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitTernaryExpression,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitTry,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitTypeNode,Cyclomatic complexity of the method is 24
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitTypeNodeList,Cyclomatic complexity of the method is 21
Complex Method,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitUsedNamespaceList,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.Cci,Duplicator,C:\repos\Reactive-Extensions_IL2JS\CCI\Duplicator.cs,VisitLiteral,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,Duplicator,C:\repos\Reactive-Extensions_IL2JS\CCI\Duplicator.cs,VisitMemberReference,Cyclomatic complexity of the method is 16
Complex Method,Microsoft.Cci,Duplicator,C:\repos\Reactive-Extensions_IL2JS\CCI\Duplicator.cs,VisitMethod,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.Cci,Duplicator,C:\repos\Reactive-Extensions_IL2JS\CCI\Duplicator.cs,VisitTypeNode,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.Cci,Duplicator,C:\repos\Reactive-Extensions_IL2JS\CCI\Duplicator.cs,VisitNestedTypes,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Cci,ReGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI\ILGenerator.cs,VisitMethodCall,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Cci,DocumentText,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,Equals,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci,DocumentText,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,Equals,Cyclomatic complexity of the method is 17
Complex Method,Microsoft.Cci,CompilerOptions,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,CompilerOptions,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,TrivialHashtableUsingWeakReferences,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,Expand,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,TrivialHashtableUsingWeakReferences,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,Contract,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,Node,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetVisitorFor,Cyclomatic complexity of the method is 16
Complex Method,Microsoft.Cci,AttributeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetUsageInformation,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Cci,AttributeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetRuntimeAttribute,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.Cci,Module,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetAttributes,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci,Module,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetType,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,Module,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetType,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.Cci,Module,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,HasReferenceTo,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci,AssemblyNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetModuleAttribute,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci,AssemblyNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetAssembly,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,AssemblyNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,MayAccessInternalTypesOf,Cyclomatic complexity of the method is 16
Complex Method,Microsoft.Cci,AssemblyNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetFriendAssemblies,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.Cci,AssemblyReference,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,AssemblyReference,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.Cci,AssemblyReference,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,Matches,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.Cci,Member,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetAttribute,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci,Member,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetParameterHelpText,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci,Member,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,AppendValue,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetUnmangledNameWithTypeParameters,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetSerializedTypeName,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetAbstractMethods,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,TryToFindExistingInstance,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetTypeNode,Cyclomatic complexity of the method is 17
Complex Method,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,IsAssignableTo,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,IsAssignableToInstanceOf,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,IsInheritedFrom,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,IsStructurallyEquivalentTo,Cyclomatic complexity of the method is 19
Complex Method,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,IsStructurallyEquivalentList,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,DeepStripModifiers,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,DeepStripModifiers,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Cci,GenericTypeInstanceHelpers,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,IsStructurallyEquivalentTo,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,Class,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetAbstractMethods,Cyclomatic complexity of the method is 17
Complex Method,Microsoft.Cci,NamespaceScope,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetAliasFor,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci,NamespaceScope,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetConflictingAlias,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,NamespaceScope,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetNamespaceFullNameFor,Cyclomatic complexity of the method is 19
Complex Method,Microsoft.Cci,NamespaceScope,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetType,Cyclomatic complexity of the method is 37
Complex Method,Microsoft.Cci,NamespaceScope,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetType,Cyclomatic complexity of the method is 49
Complex Method,Microsoft.Cci,NamespaceScope,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetReferencedTypes,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci,DelegateNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,ProvideMembers,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci,FunctionType,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,For,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.Cci,FunctionType,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,IsStructurallyEquivalentTo,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.Cci,Interface,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetAllDefaultMembers,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,TypeParameter,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,IsStructurallyEquivalentTo,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.Cci,ClassParameter,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,IsStructurallyEquivalentTo,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.Cci,ArrayType,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,IsAssignableTo,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.Cci,ArrayType,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,IsStructurallyEquivalentTo,Cyclomatic complexity of the method is 17
Complex Method,Microsoft.Cci,FunctionPointer,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,For,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci,Method,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetDocumentationId,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,Method,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetUnmangledNameWithoutTypeParameters,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,Method,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetUnmangledNameWithTypeParameters,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci,Method,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetMethod,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.Cci,Method,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetDynamicMethod,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,Method,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetMethodInfo,Cyclomatic complexity of the method is 26
Complex Method,Microsoft.Cci,Method,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,ParametersMatchStructurallyIncludingOutFlag,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci,Method,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetTemplateInstance,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci,InstanceInitializer,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetConstructorInfo,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.Cci,StaticInitializer,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetConstructorInfo,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.Cci,Property,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetBaseGetter,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,Property,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetBaseSetter,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,Property,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetPropertyInfo,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.Cci,Parameter,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetAttribute,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci,MethodBodySpecializer,C:\repos\Reactive-Extensions_IL2JS\CCI\Specializer.cs,VisitMemberBinding,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci,MethodBodySpecializer,C:\repos\Reactive-Extensions_IL2JS\CCI\Specializer.cs,VisitConstruct,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Cci,MethodBodySpecializer,C:\repos\Reactive-Extensions_IL2JS\CCI\Specializer.cs,VisitMethodCall,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.Cci,TargetPlatform,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,SetToV2Beta1,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.Cci,CoreSystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,Initialize,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci,Unstacker,C:\repos\Reactive-Extensions_IL2JS\CCI\Unstacker.cs,VisitMethod,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,VisitAliasDefinitionList,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,VisitAssemblyReferenceList,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,VisitAttributeList,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,VisitBlockList,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,VisitCatchList,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,VisitCompilationUnitList,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,VisitExpressionList,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,VisitFaultHandlerList,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,VisitFieldList,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,VisitNodeList,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,SetupMetadataWriter,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetMethodIndex,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetMethodSpecIndex,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetTypeSpecIndex,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetUnspecializedField,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetUnspecializedMethod,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateAssemblyRefTable,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateConstantTable,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateCustomAttributeTable,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateDeclSecurityTable,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateExportedTypeTable,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateGenericParamTable,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateGenericParamConstraintTable,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateInterfaceImplTable,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateMethodSemanticsTable,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateTypeDefTable,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitAttributeList,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitClass,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitEvent,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitMethod,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitMethodBody,Cyclomatic complexity of the method is 36
Complex Method,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitModule,Cyclomatic complexity of the method is 24
Complex Method,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitSecurityAttributeList,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetSerializedTypeName,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,WriteTypeSignature,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetTypeDefProps,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci,MethodSpecializer,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitMethod,Cyclomatic complexity of the method is 22
Complex Method,Microsoft.Cci,Writer,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,WritePE,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci,Writer,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,AddWin32Icon,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,Writer,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,AddWin32ResourceFileToModule,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,Cyclomatic complexity of the method is 22
Complex Method,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,SerializeMetadata,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,SerializeTables,Cyclomatic complexity of the method is 42
Complex Method,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WritePE,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WriteDirectory,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetCachedAssembly,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ReadModule,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,AddMoreStuffToParameters,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,AddMethodsToProperty,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,AddMethodsToEvent,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetTypeFromSerializedName,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseArrayOrGenericType,Cyclomatic complexity of the method is 25
Complex Method,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseSimpleTypeName,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetCustomAttributesFor,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetSecurityAttributesFor,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetTypeParameterConstraints,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetTypeParametersFor,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetGenericParameter,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetGenericParameterConstraints,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetFieldFromDef,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetInitialData,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetMarshallingInformation,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetMethodFromDef,Cyclomatic complexity of the method is 33
Complex Method,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetMemberFromRef,Cyclomatic complexity of the method is 42
Complex Method,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetTypeFromDefHelper,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetTypeExtensionFromDef,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetNestedTypes,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetTypeMembers,Cyclomatic complexity of the method is 25
Complex Method,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseCall,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,Cyclomatic complexity of the method is 8
Long Parameter List,Microsoft.Cci,GlobalAssemblyCache,C:\repos\Reactive-Extensions_IL2JS\CCI\AssemblyCache.cs,CreateAssemblyEnum,The method has 5 parameters. Parameters: ppEnum' pAppCtx' pName' dwFlags' pvReserved
Long Parameter List,Microsoft.Cci,IAssemblyName,C:\repos\Reactive-Extensions_IL2JS\CCI\AssemblyCache.cs,BindToObject,The method has 8 parameters. Parameters: refIID' pAsmBindSink' pApplicationContext' szCodeBase' llFlags' pvReserved' cbReserved' ppv
Long Parameter List,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The method has 8 parameters. Parameters: nd1' list1' list2' list1pos' list2start' matchedNodes' closestDifferences' list2pos
Long Parameter List,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The method has 8 parameters. Parameters: nd1' list1' list2' list1pos' list2start' matchedNodes' closestDifferences' list2pos
Long Parameter List,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The method has 8 parameters. Parameters: nd1' list1' list2' list1pos' list2start' matchedNodes' closestDifferences' list2pos
Long Parameter List,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The method has 8 parameters. Parameters: nd1' list1' list2' list1pos' list2start' matchedNodes' closestDifferences' list2pos
Long Parameter List,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The method has 8 parameters. Parameters: nd1' list1' list2' list1pos' list2start' matchedNodes' closestDifferences' list2pos
Long Parameter List,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The method has 8 parameters. Parameters: nd1' list1' list2' list1pos' list2start' matchedNodes' closestDifferences' list2pos
Long Parameter List,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The method has 8 parameters. Parameters: nd1' list1' list2' list1pos' list2start' matchedNodes' closestDifferences' list2pos
Long Parameter List,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The method has 8 parameters. Parameters: nd1' list1' list2' list1pos' list2start' matchedNodes' closestDifferences' list2pos
Long Parameter List,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The method has 8 parameters. Parameters: nd1' list1' list2' list1pos' list2start' matchedNodes' closestDifferences' list2pos
Long Parameter List,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The method has 8 parameters. Parameters: nd1' list1' list2' list1pos' list2start' matchedNodes' closestDifferences' list2pos
Long Parameter List,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The method has 8 parameters. Parameters: nd1' list1' list2' list1pos' list2start' matchedNodes' closestDifferences' list2pos
Long Parameter List,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The method has 8 parameters. Parameters: nd1' list1' list2' list1pos' list2start' matchedNodes' closestDifferences' list2pos
Long Parameter List,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The method has 8 parameters. Parameters: nd1' list1' list2' list1pos' list2start' matchedNodes' closestDifferences' list2pos
Long Parameter List,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitAliasDefinitionList,The method has 5 parameters. Parameters: list1' list2' changes' deletions' insertions
Long Parameter List,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitAssemblyReferenceList,The method has 5 parameters. Parameters: list1' list2' changes' deletions' insertions
Long Parameter List,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitAttributeList,The method has 5 parameters. Parameters: list1' list2' changes' deletions' insertions
Long Parameter List,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitBlockList,The method has 5 parameters. Parameters: list1' list2' changes' deletions' insertions
Long Parameter List,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitCatchList,The method has 5 parameters. Parameters: list1' list2' changes' deletions' insertions
Long Parameter List,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitCompilationUnitList,The method has 5 parameters. Parameters: list1' list2' changes' deletions' insertions
Long Parameter List,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitExpressionList,The method has 5 parameters. Parameters: list1' list2' changes' deletions' insertions
Long Parameter List,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitFaultHandlerList,The method has 5 parameters. Parameters: list1' list2' changes' deletions' insertions
Long Parameter List,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitFieldList,The method has 5 parameters. Parameters: list1' list2' changes' deletions' insertions
Long Parameter List,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitFilterList,The method has 5 parameters. Parameters: list1' list2' changes' deletions' insertions
Long Parameter List,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitInterfaceReferenceList,The method has 5 parameters. Parameters: list1' list2' changes' deletions' insertions
Long Parameter List,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitLocalDeclarationList,The method has 5 parameters. Parameters: list1' list2' changes' deletions' insertions
Long Parameter List,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitMemberList,The method has 5 parameters. Parameters: list1' list2' changes' deletions' insertions
Long Parameter List,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitMethodList,The method has 5 parameters. Parameters: list1' list2' changes' deletions' insertions
Long Parameter List,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitModuleReferenceList,The method has 5 parameters. Parameters: list1' list2' changes' deletions' insertions
Long Parameter List,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitNamespaceList,The method has 5 parameters. Parameters: list1' list2' changes' deletions' insertions
Long Parameter List,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitNodeList,The method has 5 parameters. Parameters: list1' list2' changes' deletions' insertions
Long Parameter List,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitParameterList,The method has 5 parameters. Parameters: list1' list2' changes' deletions' insertions
Long Parameter List,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitSecurityAttributeList,The method has 5 parameters. Parameters: list1' list2' changes' deletions' insertions
Long Parameter List,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitStatementList,The method has 5 parameters. Parameters: list1' list2' changes' deletions' insertions
Long Parameter List,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitSwitchCaseList,The method has 5 parameters. Parameters: list1' list2' changes' deletions' insertions
Long Parameter List,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitTypeswitchCaseList,The method has 5 parameters. Parameters: list1' list2' changes' deletions' insertions
Long Parameter List,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitTypeNodeList,The method has 5 parameters. Parameters: list1' list2' changes' deletions' insertions
Long Parameter List,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitUsedNamespaceList,The method has 5 parameters. Parameters: list1' list2' changes' deletions' insertions
Long Parameter List,Microsoft.Cci,Duplicator,C:\repos\Reactive-Extensions_IL2JS\CCI\Duplicator.cs,VisitTypeNode,The method has 5 parameters. Parameters: type' mangledName' templateArguments' template' delayVisitToNestedTypes
Long Parameter List,Microsoft.Cci,Document,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,Document,The method has 6 parameters. Parameters: name' lineNumber' text' documentType' language' languageVendor
Long Parameter List,Microsoft.Cci,Document,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,Document,The method has 6 parameters. Parameters: name' lineNumber' text' documentType' language' languageVendor
Long Parameter List,Microsoft.Cci,Document,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetOffsets,The method has 6 parameters. Parameters: startLine' startColumn' endLine' endColumn' startPos' endPos
Long Parameter List,Microsoft.Cci,DocumentWithPrecomputedLineNumbers,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,DocumentWithPrecomputedLineNumbers,The method has 5 parameters. Parameters: filename' startLine' startCol' endLine' endCol
Long Parameter List,Microsoft.Cci,UnmanagedDocument,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetOffsets,The method has 6 parameters. Parameters: startLine' startColumn' endLine' endColumn' startCol' endCol
Long Parameter List,Microsoft.Cci,SourceContext,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,SourceContext,The method has 5 parameters. Parameters: document' startLine' startColumn' endLine' endColumn
Long Parameter List,Microsoft.Cci,AddressDereference,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,AddressDereference,The method has 5 parameters. Parameters: address' type' Volatile' alignment' sctx
Long Parameter List,Microsoft.Cci,BinaryExpression,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,BinaryExpression,The method has 5 parameters. Parameters: operand1' operand2' nodeType' resultType' ctx
Long Parameter List,Microsoft.Cci,TernaryExpression,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,TernaryExpression,The method has 5 parameters. Parameters: operand1' operand2' operand3' nodeType' resultType
Long Parameter List,Microsoft.Cci,NameBinding,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,NameBinding,The method has 5 parameters. Parameters: identifier' boundMembers' mostNestedScope' lexLevel' sctx
Long Parameter List,Microsoft.Cci,MethodCall,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,MethodCall,The method has 5 parameters. Parameters: callee' arguments' typeOfCall' resultType' sctx
Long Parameter List,Microsoft.Cci,Block,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,Block,The method has 5 parameters. Parameters: statements' sourceContext' Checked' SuppressCheck' IsUnsafe
Long Parameter List,Microsoft.Cci,Branch,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,Branch,The method has 5 parameters. Parameters: condition' target' shortOffset' unordered' leavesExceptionBlock
Long Parameter List,Microsoft.Cci,Try,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,Try,The method has 5 parameters. Parameters: tryBlock' catchers' filters' faultHandlers' Finally
Long Parameter List,Microsoft.Cci,Module,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetModule,The method has 5 parameters. Parameters: buffer' cache' doNotLockFile' getDebugInfo' useGlobalCache
Long Parameter List,Microsoft.Cci,Module,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetModule,The method has 6 parameters. Parameters: buffer' cache' doNotLockFile' getDebugInfo' useGlobalCache' preserveShortBranches
Long Parameter List,Microsoft.Cci,Module,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetModule,The method has 5 parameters. Parameters: location' cache' doNotLockFile' getDebugInfo' useGlobalCache
Long Parameter List,Microsoft.Cci,Module,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetModule,The method has 6 parameters. Parameters: location' cache' doNotLockFile' getDebugInfo' useGlobalCache' preserveShortBranches
Long Parameter List,Microsoft.Cci,AssemblyNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,AssemblyNode,The method has 5 parameters. Parameters: provider' listProvider' provideCustomAttributes' provideResources' directory
Long Parameter List,Microsoft.Cci,AssemblyNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetAssembly,The method has 5 parameters. Parameters: buffer' cache' doNotLockFile' getDebugInfo' useGlobalCache
Long Parameter List,Microsoft.Cci,AssemblyNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetAssembly,The method has 6 parameters. Parameters: buffer' cache' doNotLockFile' getDebugInfo' useGlobalCache' preserveShortBranches
Long Parameter List,Microsoft.Cci,AssemblyNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetAssembly,The method has 5 parameters. Parameters: location' cache' doNotLockFile' getDebugInfo' useGlobalCache
Long Parameter List,Microsoft.Cci,AssemblyNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetAssembly,The method has 6 parameters. Parameters: location' cache' doNotLockFile' getDebugInfo' useGlobalCache' postLoadEvent
Long Parameter List,Microsoft.Cci,AssemblyNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetAssembly,The method has 6 parameters. Parameters: location' cache' doNotLockFile' getDebugInfo' useGlobalCache' preserveShortBranches
Long Parameter List,Microsoft.Cci,AssemblyNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetAssembly,The method has 7 parameters. Parameters: location' cache' doNotLockFile' getDebugInfo' useGlobalCache' preserveShortBranches' postLoadEvent
Long Parameter List,Microsoft.Cci,AssemblyNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetAssembly,The method has 5 parameters. Parameters: assemblyReference' cache' doNotLockFile' getDebugInfo' useGlobalCache
Long Parameter List,Microsoft.Cci,AssemblyNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetAssembly,The method has 6 parameters. Parameters: assemblyReference' cache' doNotLockFile' getDebugInfo' useGlobalCache' preserveShortBranches
Long Parameter List,Microsoft.Cci,AssemblyNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetAssembly,The method has 5 parameters. Parameters: runtimeAssembly' cache' getDebugInfo' useGlobalCache' preserveShortBranches
Long Parameter List,Microsoft.Cci,AssemblyNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetStrongName,The method has 5 parameters. Parameters: name' version' culture' publicKey' retargetable
Long Parameter List,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,TypeNode,The method has 5 parameters. Parameters: nodeType' provideNestedTypes' provideAttributes' provideMembers' handle
Long Parameter List,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,TypeNode,The method has 9 parameters. Parameters: declaringModule' declaringType' attributes' flags' Namespace' name' interfaces' members' nodeType
Long Parameter List,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetArrayType,The method has 5 parameters. Parameters: rank' numSizes' numLoBounds' sizes' loBounds
Long Parameter List,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,TryToFindExistingInstance,The method has 7 parameters. Parameters: module' declaringType' templateArguments' mangledName' uniqueMangledName' result' unusedMangledName
Long Parameter List,Microsoft.Cci,Class,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,Class,The method has 9 parameters. Parameters: declaringModule' declaringType' attributes' flags' Namespace' name' baseClass' interfaces' members
Long Parameter List,Microsoft.Cci,DelegateNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,DelegateNode,The method has 8 parameters. Parameters: declaringModule' declaringType' attributes' flags' Namespace' name' returnType' parameters
Long Parameter List,Microsoft.Cci,EnumNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,EnumNode,The method has 8 parameters. Parameters: declaringModule' declaringType' attributes' typeAttributes' Namespace' name' interfaces' members
Long Parameter List,Microsoft.Cci,Interface,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,Interface,The method has 5 parameters. Parameters: baseInterfaces' provideNestedTypes' provideAttributes' provideMembers' handle
Long Parameter List,Microsoft.Cci,Interface,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,Interface,The method has 8 parameters. Parameters: declaringModule' declaringType' attributes' flags' Namespace' name' baseInterfaces' members
Long Parameter List,Microsoft.Cci,Struct,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,Struct,The method has 8 parameters. Parameters: declaringModule' declaringType' attributes' flags' Namespace' name' interfaces' members
Long Parameter List,Microsoft.Cci,TypeParameter,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,TypeParameter,The method has 5 parameters. Parameters: baseInterfaces' provideNestedTypes' provideAttributes' provideMembers' handle
Long Parameter List,Microsoft.Cci,MethodTypeParameter,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,MethodTypeParameter,The method has 5 parameters. Parameters: baseInterfaces' provideNestedTypes' provideAttributes' provideMembers' handle
Long Parameter List,Microsoft.Cci,ArrayTypeExpression,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,ArrayTypeExpression,The method has 5 parameters. Parameters: elementType' rank' sizes' lowerBounds' sctx
Long Parameter List,Microsoft.Cci,Event,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,Event,The method has 8 parameters. Parameters: declaringType' attributes' flags' name' handlerAdder' handlerCaller' handlerRemover' handlerType
Long Parameter List,Microsoft.Cci,Method,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,Method,The method has 6 parameters. Parameters: declaringType' attributes' name' parameters' returnType' body
Long Parameter List,Microsoft.Cci,ProxyMethod,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,ProxyMethod,The method has 6 parameters. Parameters: declaringType' attributes' name' parameters' returnType' body
Long Parameter List,Microsoft.Cci,InstanceInitializer,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,InstanceInitializer,The method has 5 parameters. Parameters: declaringType' attributes' parameters' body' returnType
Long Parameter List,Microsoft.Cci,ParameterField,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,ParameterField,The method has 6 parameters. Parameters: declaringType' attributes' flags' name' Type' defaultValue
Long Parameter List,Microsoft.Cci,Field,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,Field,The method has 6 parameters. Parameters: declaringType' attributes' flags' name' type' defaultValue
Long Parameter List,Microsoft.Cci,Property,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,Property,The method has 6 parameters. Parameters: declaringType' attributes' flags' name' getter' setter
Long Parameter List,Microsoft.Cci,Parameter,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,Parameter,The method has 6 parameters. Parameters: attributes' flags' name' type' defaultValue' marshallingInformation
Long Parameter List,Microsoft.Cci,Namespace,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,Namespace,The method has 6 parameters. Parameters: name' fullName' aliasDefinitions' usedNamespaces' nestedNamespaces' types
Long Parameter List,Microsoft.Cci,PlatformHelpers,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,StringCompareOrdinalIgnoreCase,The method has 5 parameters. Parameters: strA' indexA' strB' indexB' length
Long Parameter List,Microsoft.Cci,IParserFactory,C:\repos\Reactive-Extensions_IL2JS\CCI\StandardVisitor.cs,CreateParser,The method has 6 parameters. Parameters: fileName' lineNumber' text' symbolTable' errorNodes' options
Long Parameter List,Microsoft.Cci,ISymUnmanagedWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,DefineLocalVariable,The method has 9 parameters. Parameters: name' attributes' cSig' signature' addrKind' addr1' addr2' startOffset' endOffset
Long Parameter List,Microsoft.Cci,ISymUnmanagedWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,DefineParameter,The method has 7 parameters. Parameters: name' attributes' sequence' addrKind' addr1' addr2' addr3
Long Parameter List,Microsoft.Cci,ISymUnmanagedWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,DefineField,The method has 9 parameters. Parameters: parent' name' attributes' cSig' signature' addrKind' addr1' addr2' addr3
Long Parameter List,Microsoft.Cci,ISymUnmanagedWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,DefineGlobalVariable,The method has 8 parameters. Parameters: name' attributes' cSig' signature' addrKind' addr1' addr2' addr3
Long Parameter List,Microsoft.Cci,ISymUnmanagedWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,SetMethodSourceRange,The method has 6 parameters. Parameters: startDoc' startLine' startColumn' endDoc' endLine' endColumn
Long Parameter List,Microsoft.Cci,ISymUnmanagedWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,DefineSequencePoints,The method has 7 parameters. Parameters: document' spCount' offsets' lines' columns' endLines' endColumns
Long Parameter List,Microsoft.Cci,ISymUnmanagedWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,Initialize2,The method has 5 parameters. Parameters: emitter' tempfilename' pIStream' fFullBuild' finalfilename
Long Parameter List,Microsoft.Cci,IMetaDataEmit,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,DefineNestedType,The method has 5 parameters. Parameters: szTypeDef' dwTypeDefFlags' tkExtends' rtkImplements' tdEncloser
Long Parameter List,Microsoft.Cci,IMetaDataEmit,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,DefineMethod,The method has 7 parameters. Parameters: td' zName' dwMethodFlags' pvSigBlob' cbSigBlob' ulCodeRVA' dwImplFlags
Long Parameter List,Microsoft.Cci,IMetaDataEmit,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,DefineImportType,The method has 6 parameters. Parameters: pAssemImport' pbHashValue' cbHashValue' pImport' tdImport' pAssemEmit
Long Parameter List,Microsoft.Cci,IMetaDataEmit,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,DefineImportMember,The method has 7 parameters. Parameters: pAssemImport' pbHashValue' cbHashValue' pImport' mbMember' pAssemEmit' tkParent
Long Parameter List,Microsoft.Cci,IMetaDataEmit,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,DefineEvent,The method has 8 parameters. Parameters: td' szEvent' dwEventFlags' tkEventType' mdAddOn' mdRemoveOn' mdFire' rmdOtherMethods
Long Parameter List,Microsoft.Cci,IMetaDataEmit,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,SetEventProps,The method has 7 parameters. Parameters: ev' dwEventFlags' tkEventType' mdAddOn' mdRemoveOn' mdFire' rmdOtherMethods
Long Parameter List,Microsoft.Cci,IMetaDataEmit,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,DefineField,The method has 8 parameters. Parameters: td' szName' dwFieldFlags' pvSigBlob' cbSigBlob' dwCPlusTypeFlag' pValue' cchValue
Long Parameter List,Microsoft.Cci,IMetaDataEmit,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,DefineProperty,The method has 11 parameters. Parameters: td' szProperty' dwPropFlags' pvSig' cbSig' dwCPlusTypeFlag' pValue' cchValue' mdSetter' mdGetter' rmdOtherMethods
Long Parameter List,Microsoft.Cci,IMetaDataEmit,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,DefineParam,The method has 7 parameters. Parameters: md' ulParamSeq' szName' dwParamFlags' dwCPlusTypeFlag' pValue' cchValue
Long Parameter List,Microsoft.Cci,IMetaDataEmit,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,SetFieldProps,The method has 5 parameters. Parameters: fd' dwFieldFlags' dwCPlusTypeFlag' pValue' cchValue
Long Parameter List,Microsoft.Cci,IMetaDataEmit,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,SetPropertyProps,The method has 8 parameters. Parameters: pr' dwPropFlags' dwCPlusTypeFlag' pValue' cchValue' mdSetter' mdGetter' rmdOtherMethods
Long Parameter List,Microsoft.Cci,IMetaDataEmit,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,SetParamProps,The method has 6 parameters. Parameters: pd' szName' dwParamFlags' dwCPlusTypeFlag' pValue' cchValue
Long Parameter List,Microsoft.Cci,IMetaDataEmit,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,TranslateSigWithScope,The method has 10 parameters. Parameters: pAssemImport' pbHashValue' cbHashValue' import' pbSigBlob' cbSigBlob' pAssemEmit' emit' pvTranslatedSig' cbTranslatedSigMax
Long Parameter List,Microsoft.Cci,IMetaDataImport,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetTypeDefProps,The method has 5 parameters. Parameters: td' szTypeDef' cchTypeDef' pchTypeDef' pdwTypeDefFlags
Long Parameter List,Microsoft.Cci,IMetaDataImport,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,EnumMembersWithName,The method has 5 parameters. Parameters: phEnum' cl' szName' rMembers' cMax
Long Parameter List,Microsoft.Cci,IMetaDataImport,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,EnumMethodsWithName,The method has 5 parameters. Parameters: phEnum' cl' szName' rMethods' cMax
Long Parameter List,Microsoft.Cci,IMetaDataImport,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,EnumFieldsWithName,The method has 5 parameters. Parameters: phEnum' cl' szName' rFields' cMax
Long Parameter List,Microsoft.Cci,IMetaDataImport,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,EnumMethodImpls,The method has 5 parameters. Parameters: phEnum' td' rMethodBody' rMethodDecl' cMax
Long Parameter List,Microsoft.Cci,IMetaDataImport,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,EnumPermissionSets,The method has 5 parameters. Parameters: phEnum' tk' dwActions' rPermission' cMax
Long Parameter List,Microsoft.Cci,IMetaDataImport,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetMethodProps,The method has 9 parameters. Parameters: mb' pClass' szMethod' cchMethod' pchMethod' pdwAttr' ppvSigBlob' pcbSigBlob' pulCodeRVA
Long Parameter List,Microsoft.Cci,IMetaDataImport,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetMemberRefProps,The method has 6 parameters. Parameters: mr' ptk' szMember' cchMember' pchMember' ppvSigBlob
Long Parameter List,Microsoft.Cci,IMetaDataImport,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetEventProps,The method has 12 parameters. Parameters: ev' pClass' szEvent' cchEvent' pchEvent' pdwEventFlags' ptkEventType' pmdAddOn' pmdRemoveOn' pmdFire' rmdOtherMethod' cMax
Long Parameter List,Microsoft.Cci,IMetaDataImport,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetClassLayout,The method has 5 parameters. Parameters: td' pdwPackSize' rFieldOffset' cMax' pcFieldOffset
Long Parameter List,Microsoft.Cci,IMetaDataImport,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetPinvokeMap,The method has 5 parameters. Parameters: tk' pdwMappingFlags' szImportName' cchImportName' pchImportName
Long Parameter List,Microsoft.Cci,IMetaDataImport,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,EnumCustomAttributes,The method has 5 parameters. Parameters: phEnum' tk' tkType' rCustomAttributes' cMax
Long Parameter List,Microsoft.Cci,IMetaDataImport,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetMemberProps,The method has 12 parameters. Parameters: mb' pClass' szMember' cchMember' pchMember' pdwAttr' ppvSigBlob' pcbSigBlob' pulCodeRVA' pdwImplFlags' pdwCPlusTypeFlag' ppValue
Long Parameter List,Microsoft.Cci,IMetaDataImport,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetFieldProps,The method has 10 parameters. Parameters: mb' pClass' szField' cchField' pchField' pdwAttr' ppvSigBlob' pcbSigBlob' pdwCPlusTypeFlag' ppValue
Long Parameter List,Microsoft.Cci,IMetaDataImport,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetPropertyProps,The method has 15 parameters. Parameters: prop' pClass' szProperty' cchProperty' pchProperty' pdwPropFlags' ppvSig' pbSig' pdwCPlusTypeFlag' ppDefaultValue' pcchDefaultValue' pmdSetter' pmdGetter' rmdOtherMethod' cMax
Long Parameter List,Microsoft.Cci,IMetaDataImport,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetParamProps,The method has 9 parameters. Parameters: tk' pmd' pulSequence' szName' cchName' pchName' pdwAttr' pdwCPlusTypeFlag' ppValue
Long Parameter List,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,DefineSequencePoints,The method has 5 parameters. Parameters: statementNodes' statementOffsets' start' count' doc
Long Parameter List,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,DefineNestedType,The method has 5 parameters. Parameters: szTypeDef' dwTypeDefFlags' tkExtends' rtkImplements' tdEncloser
Long Parameter List,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,DefineMethod,The method has 7 parameters. Parameters: td' zName' dwMethodFlags' pvSigBlob' cbSigBlob' ulCodeRVA' dwImplFlags
Long Parameter List,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,DefineImportType,The method has 6 parameters. Parameters: pAssemImport' pbHashValue' cbHashValue' pImport' tdImport' pAssemEmit
Long Parameter List,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,DefineImportMember,The method has 7 parameters. Parameters: pAssemImport' pbHashValue' cbHashValue' pImport' mbMember' pAssemEmit' tkParent
Long Parameter List,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,DefineEvent,The method has 8 parameters. Parameters: td' szEvent' dwEventFlags' tkEventType' mdAddOn' mdRemoveOn' mdFire' rmdOtherMethods
Long Parameter List,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,SetEventProps,The method has 7 parameters. Parameters: ev' dwEventFlags' tkEventType' mdAddOn' mdRemoveOn' mdFire' rmdOtherMethods
Long Parameter List,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,DefineField,The method has 8 parameters. Parameters: td' szName' dwFieldFlags' pvSigBlob' cbSigBlob' dwCPlusTypeFlag' pValue' cchValue
Long Parameter List,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,DefineProperty,The method has 11 parameters. Parameters: td' szProperty' dwPropFlags' pvSig' cbSig' dwCPlusTypeFlag' pValue' cchValue' mdSetter' mdGetter' rmdOtherMethods
Long Parameter List,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,DefineParam,The method has 7 parameters. Parameters: md' ulParamSeq' szName' dwParamFlags' dwCPlusTypeFlag' pValue' cchValue
Long Parameter List,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,SetFieldProps,The method has 5 parameters. Parameters: fd' dwFieldFlags' dwCPlusTypeFlag' pValue' cchValue
Long Parameter List,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,SetPropertyProps,The method has 8 parameters. Parameters: pr' dwPropFlags' dwCPlusTypeFlag' pValue' cchValue' mdSetter' mdGetter' rmdOtherMethods
Long Parameter List,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,SetParamProps,The method has 6 parameters. Parameters: pd' szName' dwParamFlags' dwCPlusTypeFlag' pValue' cchValue
Long Parameter List,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,TranslateSigWithScope,The method has 10 parameters. Parameters: pAssemImport' pbHashValue' cbHashValue' import' pbSigBlob' cbSigBlob' pAssemEmit' emit' pvTranslatedSig' cbTranslatedSigMax
Long Parameter List,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetTypeDefProps,The method has 5 parameters. Parameters: td' szTypeDef' cchTypeDef' pchTypeDef' pdwTypeDefFlags
Long Parameter List,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,EnumMembersWithName,The method has 5 parameters. Parameters: phEnum' cl' szName' rMembers' cMax
Long Parameter List,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,EnumMethodsWithName,The method has 5 parameters. Parameters: phEnum' cl' szName' rMethods' cMax
Long Parameter List,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,EnumFieldsWithName,The method has 5 parameters. Parameters: phEnum' cl' szName' rFields' cMax
Long Parameter List,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,EnumMethodImpls,The method has 5 parameters. Parameters: phEnum' td' rMethodBody' rMethodDecl' cMax
Long Parameter List,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,EnumPermissionSets,The method has 5 parameters. Parameters: phEnum' tk' dwActions' rPermission' cMax
Long Parameter List,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetMethodProps,The method has 9 parameters. Parameters: mb' pClass' szMethod' cchMethod' pchMethod' pdwAttr' ppvSigBlob' pcbSigBlob' pulCodeRVA
Long Parameter List,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetMemberRefProps,The method has 6 parameters. Parameters: mr' ptk' szMember' cchMember' pchMember' ppvSigBlob
Long Parameter List,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetEventProps,The method has 12 parameters. Parameters: ev' pClass' szEvent' cchEvent' pchEvent' pdwEventFlags' ptkEventType' pmdAddOn' pmdRemoveOn' pmdFire' rmdOtherMethod' cMax
Long Parameter List,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetClassLayout,The method has 5 parameters. Parameters: td' pdwPackSize' rFieldOffset' cMax' pcFieldOffset
Long Parameter List,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetPinvokeMap,The method has 5 parameters. Parameters: tk' pdwMappingFlags' szImportName' cchImportName' pchImportName
Long Parameter List,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,EnumCustomAttributes,The method has 5 parameters. Parameters: phEnum' tk' tkType' rCustomAttributes' cMax
Long Parameter List,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetMemberProps,The method has 12 parameters. Parameters: mb' pClass' szMember' cchMember' pchMember' pdwAttr' ppvSigBlob' pcbSigBlob' pulCodeRVA' pdwImplFlags' pdwCPlusTypeFlag' ppValue
Long Parameter List,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetFieldProps,The method has 10 parameters. Parameters: mb' pClass' szField' cchField' pchField' pdwAttr' ppvSigBlob' pcbSigBlob' pdwCPlusTypeFlag' ppValue
Long Parameter List,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetPropertyProps,The method has 15 parameters. Parameters: prop' pClass' szProperty' cchProperty' pchProperty' pdwPropFlags' ppvSig' pbSig' pdwCPlusTypeFlag' ppDefaultValue' pcchDefaultValue' pmdSetter' pmdGetter' rmdOtherMethod' cMax
Long Parameter List,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetParamProps,The method has 9 parameters. Parameters: tk' pmd' pulSequence' szName' cchName' pchName' pdwAttr' pdwCPlusTypeFlag' ppValue
Long Parameter List,Microsoft.Cci,Writer,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,WritePE,The method has 6 parameters. Parameters: location' writeDebugSymbols' module' delaySign' keyFileName' keyName
Long Parameter List,Microsoft.Cci,Writer,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,StrongNameSignatureGeneration,The method has 6 parameters. Parameters: wszFilePath' wszKeyContainer' pbKeyBlob' cbKeyBlob' ppbSignatureBlob' pcbSignatureBlob
Long Parameter List,Microsoft.Cci,Writer,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,MscorsnStrongNameSignatureGeneration,The method has 6 parameters. Parameters: wszFilePath' wszKeyContainer' pbKeyBlob' cbKeyBlob' ppbSignatureBlob' pcbSignatureBlob
Long Parameter List,Microsoft.Cci,Writer,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,StrongNameGetPublicKey,The method has 5 parameters. Parameters: wszKeyContainer' pbKeyBlob' cbKeyBlob' ppbPublicKeyBlob' pcbPublicKeyBlob
Long Parameter List,Microsoft.Cci,Writer,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,MscorsnStrongNameGetPublicKeyUsing,The method has 5 parameters. Parameters: wszKeyContainer' pbKeyBlob' cbKeyBlob' ppbPublicKeyBlob' pcbPublicKeyBlob
Long Parameter List,Microsoft.Cci.Metadata,MemoryMappedFile,C:\repos\Reactive-Extensions_IL2JS\CCI\MemoryMappedFile.cs,CreateFileMapping,The method has 6 parameters. Parameters: hFile' lpAttributes' flProtect' dwMaximumSizeHigh' dwMaximumSizeLow' lpName
Long Parameter List,Microsoft.Cci.Metadata,MemoryMappedFile,C:\repos\Reactive-Extensions_IL2JS\CCI\MemoryMappedFile.cs,MapViewOfFile,The method has 5 parameters. Parameters: hFileMappingObject' dwDesiredAccess' dwFileOffsetHigh' dwFileOffsetLow' dwNumberOfBytesToMap
Long Parameter List,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadWin32ResourceDataEntry,The method has 7 parameters. Parameters: c' position' TypeName' TypeID' Name' ID' LanguageID
Long Parameter List,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WriteDirectory,The method has 7 parameters. Parameters: directory' writer' offset' level' sizeOfDirectoryTree' virtualAddressBase' dataHeap
Long Parameter List,Microsoft.Cci.Metadata,IMetaDataDispenser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,OpenScopeOnMemory,The method has 5 parameters. Parameters: data' dataSize' openFlags' iid' retval
Long Parameter List,Microsoft.Cci.Metadata,ISymUnmanagedBinder2,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetReaderForFile2,The method has 5 parameters. Parameters: importer' fileName' searchPath' searchPolicy' pRetVal
Long Parameter List,Microsoft.Cci.Metadata,ISymUnmanagedReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetSymAttribute,The method has 5 parameters. Parameters: parent' name' size' length' buffer
Long Parameter List,Microsoft.Cci.Metadata,ISymUnmanagedReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetMethodsFromDocumentPosition,The method has 6 parameters. Parameters: document' line' column' size' length' retval
Long Parameter List,Microsoft.Cci.Metadata,ISymUnmanagedMethod,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetRanges,The method has 6 parameters. Parameters: document' line' column' size' length' ranges
Long Parameter List,Microsoft.Cci.Metadata,ISymUnmanagedMethod,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetSequencePoints,The method has 8 parameters. Parameters: size' length' offsets' documents' lines' columns' endLines' endColumns
Long Parameter List,Microsoft.Cci.Metadata,ISymUnmanagedDocument,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetSourceRange,The method has 7 parameters. Parameters: startLine' startColumn' endLine' endColumn' size' length' source
Long Parameter List,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,Reader,The method has 6 parameters. Parameters: buffer' localAssemblyCache' doNotLockFile' getDebugInfo' useStaticCache' preserveShortBranches
Long Parameter List,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,Reader,The method has 6 parameters. Parameters: fileName' localAssemblyCache' doNotLockFile' getDebugInfo' useStaticCache' preserveShortBranches
Long Parameter List,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,Reader,The method has 5 parameters. Parameters: localAssemblyCache' doNotLockFile' getDebugInfo' useStaticCache' preserveShortBranches
Long Parameter List,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ReadFile,The method has 5 parameters. Parameters: FileHandle' Buffer' NumberOfBytesToRead' NumberOfBytesRead' Overlapped
Long Parameter List,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,AddFieldsToType,The method has 5 parameters. Parameters: type' fieldDefs' fieldPtrs' start' end
Long Parameter List,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetUnderlyingTypeOfEnumNode,The method has 5 parameters. Parameters: enumNode' fieldDefs' fieldPtrs' start' end
Long Parameter List,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,AddPropertiesToType,The method has 5 parameters. Parameters: type' propertyDefs' propertyPtrs' start' end
Long Parameter List,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,AddEventsToType,The method has 5 parameters. Parameters: type' eventDefs' eventPtrs' start' end
Long Parameter List,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ConstructCorrectTypeNodeSubclass,The method has 8 parameters. Parameters: i' namesp' firstInterfaceIndex' lastInterfaceIndex' flags' interfaces' baseTypeCodedIndex' isSystemEnum
Long Parameter List,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,DummyTypeExtensionProvider,The method has 5 parameters. Parameters: nprovider' aprovider' mprovider' baseType' handle
Long Parameter List,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetTypeExtensionFromDef,The method has 6 parameters. Parameters: nestedTypeProvider' attributeProvider' memberProvider' handle' baseType' lastInterface
Long Parameter List,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetDummyTypeNode,The method has 5 parameters. Parameters: namesp' name' declaringModule' declaringType' expectStruct
Long Parameter List,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseBranch,The method has 5 parameters. Parameters: operatorType' operandCount' shortOffset' unordered' leavesExceptionBlock
Long Identifier,Microsoft.Cci,CompilerOptions,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,,The length of the parameter AliasesForReferencedAssemblies is 30.
Long Identifier,Microsoft.Cci,CompilerOptions,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,,The length of the parameter SpecificWarningsToTreatAsErrors is 31.
Long Identifier,Microsoft.Cci,CompilerOptions,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,,The length of the parameter SpecificWarningsNotToTreatAsErrors is 34.
Long Identifier,Microsoft.Cci,Literal,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,,The length of the parameter TypeWasExplicitlySpecifiedInSource is 34.
Long Identifier,Microsoft.Cci,ComprehensionBinding,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,,The length of the parameter AsTargetVariableTypeExpression is 30.
Long Identifier,Microsoft.Cci,Indexer,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,,The length of the parameter CorrespondingDefaultIndexedProperty is 35.
Long Identifier,Microsoft.Cci,ForEach,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,,The length of the parameter StatementTerminatesNormallyIfEnumerableIsNull is 45.
Long Identifier,Microsoft.Cci,ForEach,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,,The length of the parameter StatementTerminatesNormallyIfEnumeratorIsNull is 45.
Long Identifier,Microsoft.Cci,AliasDefinition,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,,The length of the parameter RestrictToClassesAndInterfaces is 30.
Long Identifier,Microsoft.Cci,Module,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,,The length of the parameter UsePublicKeyTokensForAssemblyReferences is 39.
Long Identifier,Microsoft.Cci,Module,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,,The length of the parameter StripOptionalModifiersFromLocals is 32.
Long Identifier,Microsoft.Cci,Module,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,,The length of the parameter referencedModulesAndAssemblies is 30.
Long Identifier,Microsoft.Cci,Member,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,,The length of the parameter hidesBaseClassMemberSpecifiedExplicitly is 39.
Long Identifier,Microsoft.Cci,Member,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,,The length of the parameter overridesBaseClassMemberSpecifiedExplicitly is 43.
Long Identifier,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,ImplementsExplicitly,The length of the parameter explicitInterfaceImplementations is 32.
Long Identifier,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,,The length of the parameter NewTemplateInstanceIsRecursive is 30.
Long Identifier,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,,The length of the parameter consolidatedTemplateParameters is 30.
Long Identifier,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,,The length of the parameter cachingModuleForGenericInstances is 32.
Long Identifier,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,,The length of the parameter explicitInterfaceImplementations is 32.
Long Identifier,Microsoft.Cci,Class,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,,The length of the parameter IsAbstractSealedContainerForStatics is 35.
Long Identifier,Microsoft.Cci,NamespaceScope,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetType,The length of the parameter returnNullIfHiddenByNestedNamespace is 35.
Long Identifier,Microsoft.Cci,Method,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,,The length of the parameter implicitlyImplementedInterfaceMethods is 37.
Long Identifier,Microsoft.Cci,Method,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,,The length of the parameter returnTypeMarshallingInformation is 32.
Long Identifier,Microsoft.Cci,InstanceInitializer,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,,The length of the parameter ContainsBaseMarkerBecauseOfNonNullFields is 40.
Long Identifier,Microsoft.Cci,Field,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,,The length of the parameter ImplementedInterfaceExpressions is 31.
Long Identifier,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,,The length of the parameter AllowPartiallyTrustedCallersAttribute is 37.
Long Identifier,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,,The length of the parameter AssemblyConfigurationAttribute is 30.
Long Identifier,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,,The length of the parameter AssemblyInformationalVersionAttribute is 37.
Long Identifier,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,,The length of the parameter ComUnregisterFunctionAttribute is 30.
Long Identifier,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,,The length of the parameter SatelliteContractVersionAttribute is 33.
Long Identifier,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,,The length of the parameter SuppressUnmanagedCodeSecurityAttribute is 38.
Long Identifier,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,,The length of the parameter GenericArrayToIEnumerableAdapter is 32.
Long Identifier,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,DefineLocalVariables,The length of the parameter posOfFirstInstructionOfNextBlock is 32.
Long Identifier,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,ForceTemplateTypeMethodBodiesToGetSpecialized,The length of the parameter savedNewTemplateInstanceIsRecursive is 35.
Long Identifier,Microsoft.Cci,MethodSpecializer,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitMethod,The length of the parameter savedNewTemplateInstanceIsRecursive is 35.
Long Identifier,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The length of the parameter customAttributeConstructorRefSize is 33.
Long Identifier,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,,The length of the parameter customAttributeConstructorRefSize is 33.
Long Identifier,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The length of the parameter customAttributeConstructorRefSize is 33.
Long Identifier,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,,The length of the parameter customAttributeConstructorRefSize is 33.
Long Identifier,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetMethodBody,The length of the parameter savedCurrentMethodTypeParameters is 32.
Long Identifier,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetMethodInstructions,The length of the parameter savedCurrentMethodTypeParameters is 32.
Long Identifier,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetMethodFromDef,The length of the parameter savedCurrentMethodTypeParameters is 32.
Long Identifier,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetMethodAttributes,The length of the parameter savedCurrentMethodTypeParameters is 32.
Long Identifier,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetMemberFromRef,The length of the parameter methodToSkipPastWhenLookingForMethodParameters is 46.
Long Statement,Microsoft.Cci,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CCI\AssemblyCache.cs,GetLocation,The length of the statement  "      assemblyCache.QueryAssemblyInfo(ASSEMBLYINFO_FLAG.VALIDATE | ASSEMBLYINFO_FLAG.GETSIZE' this.StrongName' ref assemblyInfo); " is 123.
Long Statement,Microsoft.Cci,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CCI\AssemblyCache.cs,GetLocation,The length of the statement  "      assemblyCache.QueryAssemblyInfo(ASSEMBLYINFO_FLAG.VALIDATE | ASSEMBLYINFO_FLAG.GETSIZE' this.StrongName' ref assemblyInfo); " is 123.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The length of the statement  "      if (nd1 == null || list1 == null || matchedNodes == null ||  list1pos < 0 || list1pos >= list1.Count || list2start < 0 || list2start >= list2.Count) { " is 150.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The length of the statement  "          if (list2start == j+1) list2start--; //The next call to GetClosestMatch will start looking at list2start' so this node will be considered then " is 142.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The length of the statement  "        //closest is closer to nd1 than any other node in list2' but this is no good if some other node in list1 has a better claim on closest " is 134.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The length of the statement  "          AttributeNode newClosest = this.GetClosestMatch(nd1' list1' list2' i' ref k' matchedNodes' out winnerSoFar' out list2pos); " is 122.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The length of the statement  "      if (nd1 == null || list1 == null || matchedNodes == null || list1pos < 0 || list1pos >= list1.Count || list2start < 0 || list2start >= list2.Count) { " is 149.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The length of the statement  "          if (list2start == j+1) list2start--; //The next call to GetClosestMatch will start looking at list2start' so this node will be considered then " is 142.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The length of the statement  "        //closest is closer to nd1 than any other node in list2' but this is no good if some other node in list1 has a better claim on closest " is 134.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The length of the statement  "      if (nd1 == null || list1 == null || matchedNodes == null || list1pos < 0 || list1pos >= list1.Count || list2start < 0 || list2start >= list2.Count) { " is 149.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The length of the statement  "          if (list2start == j+1) list2start--; //The next call to GetClosestMatch will start looking at list2start' so this node will be considered then " is 142.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The length of the statement  "        //closest is closer to nd1 than any other node in list2' but this is no good if some other node in list1 has a better claim on closest " is 134.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The length of the statement  "      if (nd1 == null || list1 == null || matchedNodes == null || list1pos < 0 || list1pos >= list1.Count || list2start < 0 || list2start >= list2.Count) { " is 149.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The length of the statement  "          if (list2start == j+1) list2start--; //The next call to GetClosestMatch will start looking at list2start' so this node will be considered then " is 142.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The length of the statement  "        //closest is closer to nd1 than any other node in list2' but this is no good if some other node in list1 has a better claim on closest " is 134.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The length of the statement  "      if (nd1 == null || list1 == null || matchedNodes == null || list1pos < 0 || list1pos >= list1.Count || list2start < 0 || list2start >= list2.Count) { " is 149.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The length of the statement  "          if (list2start == j+1) list2start--; //The next call to GetClosestMatch will start looking at list2start' so this node will be considered then " is 142.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The length of the statement  "        //closest is closer to nd1 than any other node in list2' but this is no good if some other node in list1 has a better claim on closest " is 134.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The length of the statement  "          FaultHandler newClosest = this.GetClosestMatch(nd1' list1' list2' i' ref k' matchedNodes' out winnerSoFar' out list2pos); " is 121.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The length of the statement  "      if (nd1 == null || list1 == null || matchedNodes == null || list1pos < 0 || list1pos >= list1.Count || list2start < 0 || list2start >= list2.Count) { " is 149.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The length of the statement  "          if (list2start == j+1) list2start--; //The next call to GetClosestMatch will start looking at list2start' so this node will be considered then " is 142.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The length of the statement  "        //closest is closer to nd1 than any other node in list2' but this is no good if some other node in list1 has a better claim on closest " is 134.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The length of the statement  "      if (nd1 == null || list1 == null || matchedNodes == null || list1pos < 0 || list1pos >= list1.Count || list2start < 0 || list2start >= list2.Count) { " is 149.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The length of the statement  "          if (list2start == j+1) list2start--; //The next call to GetClosestMatch will start looking at list2start' so this node will be considered then " is 142.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The length of the statement  "        //closest is closer to nd1 than any other node in list2' but this is no good if some other node in list1 has a better claim on closest " is 134.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The length of the statement  "          LocalDeclaration newClosest = this.GetClosestMatch(nd1' list1' list2' i' ref k' matchedNodes' out winnerSoFar' out list2pos); " is 125.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The length of the statement  "      if (nd1 == null || list1 == null || matchedNodes == null || list1pos < 0 || list1pos >= list1.Count || list2start < 0 || list2start >= list2.Count) { " is 149.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The length of the statement  "          if (list2start == j+1) list2start--; //The next call to GetClosestMatch will start looking at list2start' so this node will be considered then " is 142.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The length of the statement  "        //closest is closer to nd1 than any other node in list2' but this is no good if some other node in list1 has a better claim on closest " is 134.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The length of the statement  "      if (nd1 == null || list1 == null || matchedNodes == null || list1pos < 0 || list1pos >= list1.Count || list2start < 0 || list2start >= list2.Count) { " is 149.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The length of the statement  "          if (list2start == j+1) list2start--; //The next call to GetClosestMatch will start looking at list2start' so this node will be considered then " is 142.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The length of the statement  "        //closest is closer to nd1 than any other node in list2' but this is no good if some other node in list1 has a better claim on closest " is 134.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The length of the statement  "          SecurityAttribute newClosest = this.GetClosestMatch(nd1' list1' list2' i' ref k' matchedNodes' out winnerSoFar' out list2pos); " is 126.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The length of the statement  "      if (nd1 == null || list1 == null || matchedNodes == null || list1pos < 0 || list1pos >= list1.Count || list2start < 0 || list2start >= list2.Count) { " is 149.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The length of the statement  "          if (list2start == j+1) list2start--; //The next call to GetClosestMatch will start looking at list2start' so this node will be considered then " is 142.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The length of the statement  "        //closest is closer to nd1 than any other node in list2' but this is no good if some other node in list1 has a better claim on closest " is 134.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The length of the statement  "      if (nd1 == null || list1 == null ||  matchedNodes == null || list1pos < 0 || list1pos >= list1.Count || list2start < 0 || list2start >= list2.Count) { " is 150.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The length of the statement  "          if (list2start == j+1) list2start--; //The next call to GetClosestMatch will start looking at list2start' so this node will be considered then " is 142.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The length of the statement  "        //closest is closer to nd1 than any other node in list2' but this is no good if some other node in list1 has a better claim on closest " is 134.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The length of the statement  "      if (nd1 == null || list1 == null ||  matchedNodes == null || list1pos < 0 || list1pos >= list1.Count || list2start < 0 || list2start >= list2.Count) { " is 150.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The length of the statement  "          if (list2start == j+1) list2start--; //The next call to GetClosestMatch will start looking at list2start' so this node will be considered then " is 142.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The length of the statement  "        //closest is closer to nd1 than any other node in list2' but this is no good if some other node in list1 has a better claim on closest " is 134.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The length of the statement  "          TypeswitchCase newClosest = this.GetClosestMatch(nd1' list1' list2' i' ref k' matchedNodes' out winnerSoFar' out list2pos); " is 123.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The length of the statement  "      if (nd1 == null || list1 == null || matchedNodes == null || list1pos < 0 || list1pos >= list1.Count || list2start < 0 || list2start >= list2.Count) { " is 149.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The length of the statement  "          if (list2start == j+1) list2start--; //The next call to GetClosestMatch will start looking at list2start' so this node will be considered then " is 142.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The length of the statement  "        //closest is closer to nd1 than any other node in list2' but this is no good if some other node in list1 has a better claim on closest " is 134.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The length of the statement  "          UsedNamespace newClosest = this.GetClosestMatch(nd1' list1' list2' i' ref k' matchedNodes' out winnerSoFar' out list2pos); " is 122.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitAddressDereference,The length of the statement  "      Debug.Assert(diff.Changes == changes.Address && diff.Deletions == deletions.Address && diff.Insertions == insertions.Address); " is 126.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitAliasDefinition,The length of the statement  "      Debug.Assert(diff.Changes == changes.Alias && diff.Deletions == deletions.Alias && diff.Insertions == insertions.Alias); " is 120.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitAliasDefinition,The length of the statement  "      Debug.Assert(diff.Changes == changes.AliasedExpression && diff.Deletions == deletions.AliasedExpression && diff.Insertions == insertions.AliasedExpression); " is 156.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitAliasDefinition,The length of the statement  "      Debug.Assert(diff.Changes == changes.AliasedUri && diff.Deletions == deletions.AliasedUri && diff.Insertions == insertions.AliasedUri); " is 135.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitAnonymousNestedFunction,The length of the statement  "      diff = this.VisitParameterList(func1.Parameters' func2.Parameters' out parChanges' out parDeletions' out parInsertions); " is 120.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitApplyToAll,The length of the statement  "      Debug.Assert(diff.Changes == changes.Operand1 && diff.Deletions == deletions.Operand1 && diff.Insertions == insertions.Operand1); " is 129.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitApplyToAll,The length of the statement  "      Debug.Assert(diff.Changes == changes.Operand2 && diff.Deletions == deletions.Operand2 && diff.Insertions == insertions.Operand2); " is 129.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitAssembly,The length of the statement  "      Differences diff = this.VisitAssemblyReferenceList(assembly1.AssemblyReferences' assembly2.AssemblyReferences' out arChanges' out arDeletions' out arInsertions); " is 161.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitAssembly,The length of the statement  "      diff = this.VisitAttributeList(assembly1.Attributes' assembly2.Attributes' out attrChanges' out attrDeletions' out attrInsertions); " is 131.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitAssembly,The length of the statement  "      diff = this.VisitTypeNodeList(assembly1.ExportedTypes' assembly2.ExportedTypes' out typeChanges' out typeDeletions' out typeInsertions); " is 136.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitAssembly,The length of the statement  "      diff = this.VisitAttributeList(assembly1.ModuleAttributes' assembly2.ModuleAttributes' out attrChanges' out attrDeletions' out attrInsertions); " is 143.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitAssembly,The length of the statement  "      diff = this.VisitModuleReferenceList(assembly1.ModuleReferences' assembly2.ModuleReferences' out mrChanges' out mrDeletions' out mrInsertions); " is 143.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitAssembly,The length of the statement  "      diff = this.VisitSecurityAttributeList(assembly1.SecurityAttributes' assembly2.SecurityAttributes' out secChanges' out secDeletions' out secInsertions); " is 152.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitAssembly,The length of the statement  "      diff = this.VisitTypeNodeList(assembly1.Types' assembly2.Types' out typeChanges' out typeDeletions' out typeInsertions); " is 120.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitAssemblyReference,The length of the statement  "        if (assemblyReference1 != assemblyReference2) differences.NumberOfDifferences++; else differences.NumberOfSimilarities++; " is 121.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitAssemblyReference,The length of the statement  "      if (assemblyReference1.Culture == assemblyReference2.Culture) differences.NumberOfSimilarities++; else differences.NumberOfDifferences++; " is 137.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitAssemblyReference,The length of the statement  "      if (assemblyReference1.Flags == assemblyReference2.Flags) differences.NumberOfSimilarities++; else differences.NumberOfDifferences++; " is 133.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitAssemblyReference,The length of the statement  "      if (assemblyReference1.Name == assemblyReference2.Name) differences.NumberOfSimilarities++; else differences.NumberOfDifferences++; " is 131.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitAssemblyReference,The length of the statement  "      if (this.ValuesAreEqual(assemblyReference1.PublicKeyOrToken' assemblyReference2.PublicKeyOrToken)) differences.NumberOfSimilarities++; else differences.NumberOfDifferences++; " is 174.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitAssemblyReference,The length of the statement  "      if (assemblyReference1.Version == assemblyReference2.Version) differences.NumberOfSimilarities++; else differences.NumberOfDifferences++; " is 137.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitAssertion,The length of the statement  "      Debug.Assert(diff.Changes == changes.Condition && diff.Deletions == deletions.Condition && diff.Insertions == insertions.Condition); " is 132.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitAssignmentExpression,The length of the statement  "      Debug.Assert(diff.Changes == changes.AssignmentStatement && diff.Deletions == deletions.AssignmentStatement && diff.Insertions == insertions.AssignmentStatement); " is 162.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitAssignmentStatement,The length of the statement  "      if (assignment1.Operator == assignment2.Operator) differences.NumberOfSimilarities++; else differences.NumberOfDifferences++; " is 125.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitAssignmentStatement,The length of the statement  "      Debug.Assert(diff.Changes == changes.Source && diff.Deletions == deletions.Source && diff.Insertions == insertions.Source); " is 123.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitAssignmentStatement,The length of the statement  "      Debug.Assert(diff.Changes == changes.Target && diff.Deletions == deletions.Target && diff.Insertions == insertions.Target); " is 123.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitAttributeNode,The length of the statement  "      if (attribute1.AllowMultiple == attribute2.AllowMultiple) differences.NumberOfSimilarities++; else differences.NumberOfDifferences++; " is 133.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitAttributeNode,The length of the statement  "      Debug.Assert(diff.Changes == changes.Constructor && diff.Deletions == deletions.Constructor && diff.Insertions == insertions.Constructor); " is 138.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitAttributeNode,The length of the statement  "      diff = this.VisitExpressionList(attribute1.Expressions' attribute2.Expressions' out exprChanges' out exprDeletions' out exprInsertions); " is 136.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitBinaryExpression,The length of the statement  "      if (binaryExpression1.NodeType == binaryExpression2.NodeType) differences.NumberOfSimilarities++; else differences.NumberOfDifferences++; " is 137.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitBinaryExpression,The length of the statement  "      Debug.Assert(diff.Changes == changes.Operand1 && diff.Deletions == deletions.Operand1 && diff.Insertions == insertions.Operand1); " is 129.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitBinaryExpression,The length of the statement  "      Debug.Assert(diff.Changes == changes.Operand2 && diff.Deletions == deletions.Operand2 && diff.Insertions == insertions.Operand2); " is 129.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitBlock,The length of the statement  "      Differences diff = this.VisitStatementList(block1.Statements' block2.Statements' out statChanges' out statDeletions' out statInsertions); " is 137.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitBlock,The length of the statement  "      if (block1.SuppressCheck == block2.SuppressCheck) differences.NumberOfSimilarities++; else differences.NumberOfDifferences++; " is 125.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitBlockExpression,The length of the statement  "      Debug.Assert(diff.Changes == changes.Block && diff.Deletions == deletions.Block && diff.Insertions == insertions.Block); " is 120.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitCatch,The length of the statement  "      Debug.Assert(diff.Changes == changes.Block && diff.Deletions == deletions.Block && diff.Insertions == insertions.Block); " is 120.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitCatch,The length of the statement  "      Debug.Assert(diff.Changes == changes.Variable && diff.Deletions == deletions.Variable && diff.Insertions == insertions.Variable); " is 129.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitClass,The length of the statement  "      //Debug.Assert(diff.Changes == changes.BaseClass && diff.Deletions == deletions.BaseClass && diff.Insertions == insertions.BaseClass); " is 134.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitCoerceTuple,The length of the statement  "      Differences diff = this.VisitFieldList(coerceTuple1.Fields' coerceTuple2.Fields' out fieldChanges' out fieldDeletions' out fieldInsertions); " is 140.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitCoerceTuple,The length of the statement  "      Debug.Assert(diff.Changes == changes.OriginalTuple && diff.Deletions == deletions.OriginalTuple && diff.Insertions == insertions.OriginalTuple); " is 144.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitCollectionEnumerator,The length of the statement  "      Debug.Assert(diff.Changes == changes.Collection && diff.Deletions == deletions.Collection && diff.Insertions == insertions.Collection); " is 135.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitCompilation,The length of the statement  "      Differences diff = this.VisitCompilationUnitList(compilation1.CompilationUnits' compilation2.CompilationUnits' out cuChanges' out cuDeletions' out cuInsertions); " is 161.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitCompilationUnit,The length of the statement  "      Differences diff = this.VisitNodeList(cUnit1.Nodes' cUnit2.Nodes' out nodeChanges' out nodeDeletions' out nodeInsertions); " is 122.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitCompilationUnitSnippet,The length of the statement  "        if (snippet1.SourceContext.Document == snippet2.SourceContext.Document) differences.NumberOfSimilarities++; else differences.NumberOfDifferences++; " is 147.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitComposition,The length of the statement  "      if (comp1.Composer != comp2.Composer && comp1.Composer != null && comp2.Composer != null && comp1.Composer.ToString() != comp2.Composer.ToString()) " is 147.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitComposition,The length of the statement  "        Debug.Assert(diff.Changes == changes.Expression && diff.Deletions == deletions.Expression && diff.Insertions == insertions.Expression); " is 135.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitQuantifier,The length of the statement  "      Differences diff = this.VisitComprehension((Comprehension)quantifier1.Comprehension' (Comprehension)quantifier2.Comprehension); " is 127.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitQuantifier,The length of the statement  "      if (quantifier1.QuantifierType == quantifier2.QuantifierType) differences.NumberOfSimilarities++; else differences.NumberOfDifferences++; " is 137.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitComprehension,The length of the statement  "      Differences diff = this.VisitExpressionList(comprehension1.BindingsAndFilters' comprehension2.BindingsAndFilters' out exprChanges' out exprDeletions' out exprInsertions); " is 170.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitComprehension,The length of the statement  "      diff = this.VisitExpressionList(comprehension1.Elements' comprehension2.Elements' out exprChanges' out exprDeletions' out exprInsertions); " is 138.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitComprehension,The length of the statement  "      if (comprehension1.Mode == comprehension2.Mode) differences.NumberOfSimilarities++; else differences.NumberOfDifferences++; " is 123.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitComprehensionBinding,The length of the statement  "        if (comprehensionBinding1 != comprehensionBinding2) differences.NumberOfDifferences++; else differences.NumberOfSimilarities++; " is 127.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitComprehensionBinding,The length of the statement  "      Differences diff = this.VisitTypeNode(comprehensionBinding1.AsTargetVariableType' comprehensionBinding2.AsTargetVariableType); " is 126.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitComprehensionBinding,The length of the statement  "      //Debug.Assert(diff.Changes == changes.AsTargetVariableType && diff.Deletions == deletions.AsTargetVariableType && diff.Insertions == insertions.AsTargetVariableType); " is 167.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitComprehensionBinding,The length of the statement  "      if (comprehensionBinding1.Mode == comprehensionBinding2.Mode) differences.NumberOfSimilarities++; else differences.NumberOfDifferences++; " is 137.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitComprehensionBinding,The length of the statement  "      Debug.Assert(diff.Changes == changes.SourceEnumerable && diff.Deletions == deletions.SourceEnumerable && diff.Insertions == insertions.SourceEnumerable); " is 153.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitComprehensionBinding,The length of the statement  "      Debug.Assert(diff.Changes == changes.TargetVariable && diff.Deletions == deletions.TargetVariable && diff.Insertions == insertions.TargetVariable); " is 147.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitComprehensionBinding,The length of the statement  "      //Debug.Assert(diff.Changes == changes.TargetVariableType && diff.Deletions == deletions.TargetVariableType && diff.Insertions == insertions.TargetVariableType); " is 161.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitConstruct,The length of the statement  "      Debug.Assert(diff.Changes == changes.Constructor && diff.Deletions == deletions.Constructor && diff.Insertions == insertions.Constructor); " is 138.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitConstruct,The length of the statement  "      diff = this.VisitExpressionList(cons1.Operands' cons2.Operands' out exprChanges' out exprDeletions' out exprInsertions); " is 120.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitConstruct,The length of the statement  "      Debug.Assert(diff.Changes == changes.Owner && diff.Deletions == deletions.Owner && diff.Insertions == insertions.Owner); " is 120.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitConstructArray,The length of the statement  "      //Debug.Assert(diff.Changes == changes.ElementType && diff.Deletions == deletions.ElementType && diff.Insertions == insertions.ElementType); " is 140.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitConstructArray,The length of the statement  "      diff = this.VisitExpressionList(consArr1.Initializers' consArr2.Initializers' out exprChanges' out exprDeletions' out exprInsertions); " is 134.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitConstructArray,The length of the statement  "      diff = this.VisitExpressionList(consArr1.Operands' consArr2.Operands' out exprChanges' out exprDeletions' out exprInsertions); " is 126.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitConstructArray,The length of the statement  "      Debug.Assert(diff.Changes == changes.Owner && diff.Deletions == deletions.Owner && diff.Insertions == insertions.Owner); " is 120.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitConstructDelegate,The length of the statement  "      //Debug.Assert(diff.Changes == changes.DelegateType && diff.Deletions == deletions.DelegateType && diff.Insertions == insertions.DelegateType); " is 143.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitConstructDelegate,The length of the statement  "      Debug.Assert(diff.Changes == changes.MethodName && diff.Deletions == deletions.MethodName && diff.Insertions == insertions.MethodName); " is 135.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitConstructFlexArray,The length of the statement  "      //Debug.Assert(diff.Changes == changes.ElementType && diff.Deletions == deletions.ElementType && diff.Insertions == insertions.ElementType); " is 140.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitConstructFlexArray,The length of the statement  "      diff = this.VisitExpressionList(consArr1.Initializers' consArr2.Initializers' out exprChanges' out exprDeletions' out exprInsertions); " is 134.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitConstructFlexArray,The length of the statement  "      diff = this.VisitExpressionList(consArr1.Operands' consArr2.Operands' out exprChanges' out exprDeletions' out exprInsertions); " is 126.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitConstructIterator,The length of the statement  "      //Debug.Assert(diff.Changes == changes.ElementType && diff.Deletions == deletions.ElementType && diff.Insertions == insertions.ElementType); " is 140.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitConstructIterator,The length of the statement  "      //Debug.Assert(diff.Changes == changes.State && diff.Deletions == deletions.State && diff.Insertions == insertions.State); " is 122.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitConstructTuple,The length of the statement  "      Differences diff = this.VisitFieldList(consTuple1.Fields' consTuple2.Fields' out fieldChanges' out fieldDeletions' out fieldInsertions); " is 136.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitDelegateNode,The length of the statement  "      Differences diff = this.VisitAttributeList(delegateNode1.Attributes' delegateNode2.Attributes' out attrChanges' out attrDeletions' out attrInsertions); " is 151.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitDelegateNode,The length of the statement  "      if (delegateNode1.Flags == delegateNode2.Flags) differences.NumberOfSimilarities++; else differences.NumberOfDifferences++; " is 123.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitDelegateNode,The length of the statement  "      diff = this.VisitParameterList(delegateNode1.Parameters' delegateNode2.Parameters' out parChanges' out parDeletions' out parInsertions); " is 136.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitDelegateNode,The length of the statement  "      //Debug.Assert(diff.Changes == changes.ReturnType && diff.Deletions == deletions.ReturnType && diff.Insertions == insertions.ReturnType); " is 137.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitDelegateNode,The length of the statement  "      diff = this.VisitSecurityAttributeList(delegateNode1.SecurityAttributes' delegateNode2.SecurityAttributes' out secChanges' out secDeletions' out secInsertions); " is 160.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitDelegateNode,The length of the statement  "      diff = this.VisitTypeNodeList(delegateNode1.TemplateParameters' delegateNode2.TemplateParameters' out typeChanges' out typeDeletions' out typeInsertions); " is 154.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitDoWhile,The length of the statement  "      diff = this.VisitExpressionList(doWhile1.Invariants' doWhile2.Invariants' out changes.Invariants' out deletions.Invariants' out insertions.Invariants); " is 151.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitDoWhile,The length of the statement  "      Debug.Assert(diff.Changes == changes.Condition && diff.Deletions == deletions.Condition && diff.Insertions == insertions.Condition); " is 132.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitEndFilter,The length of the statement  "      Debug.Assert(diff.Changes == changes.Value && diff.Deletions == deletions.Value && diff.Insertions == insertions.Value); " is 120.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitEnumNode,The length of the statement  "      //Debug.Assert(diff.Changes == changes.UnderlyingType && diff.Deletions == deletions.UnderlyingType && diff.Insertions == insertions.UnderlyingType); " is 149.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitEvent,The length of the statement  "      Differences diff = this.VisitAttributeList(evnt1.Attributes' evnt2.Attributes' out attrChanges' out attrDeletions' out attrInsertions); " is 135.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitEvent,The length of the statement  "      Debug.Assert(diff.Changes == changes.HandlerAdder && diff.Deletions == deletions.HandlerAdder && diff.Insertions == insertions.HandlerAdder); " is 141.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitEvent,The length of the statement  "      Debug.Assert(diff.Changes == changes.HandlerCaller && diff.Deletions == deletions.HandlerCaller && diff.Insertions == insertions.HandlerCaller); " is 144.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitEvent,The length of the statement  "      if (evnt1.HandlerFlags == evnt2.HandlerFlags) differences.NumberOfSimilarities++; else differences.NumberOfDifferences++; " is 121.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitEvent,The length of the statement  "      Debug.Assert(diff.Changes == changes.HandlerRemover && diff.Deletions == deletions.HandlerRemover && diff.Insertions == insertions.HandlerRemover); " is 147.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitEvent,The length of the statement  "      //Debug.Assert(diff.Changes == changes.HandlerType && diff.Deletions == deletions.HandlerType && diff.Insertions == insertions.HandlerType); " is 140.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitEvent,The length of the statement  "      Debug.Assert(diff.Changes == changes.InitialHandler && diff.Deletions == deletions.InitialHandler && diff.Insertions == insertions.InitialHandler); " is 147.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitEvent,The length of the statement  "      diff = this.VisitMethodList(evnt1.OtherMethods' evnt2.OtherMethods' out methChanges' out methDeletions' out methInsertions); " is 124.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitEvent,The length of the statement  "      if (evnt1.OverridesBaseClassMember == evnt2.OverridesBaseClassMember) differences.NumberOfSimilarities++; else differences.NumberOfDifferences++; " is 145.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitExpression,The length of the statement  "        differences.Changes = expression2; //Happens when different types of expressions are compared (e.g. UnaryExpression vs BinaryExpression) " is 136.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitExpressionSnippet,The length of the statement  "        if (snippet1.SourceContext.Document == snippet2.SourceContext.Document) differences.NumberOfSimilarities++; else differences.NumberOfDifferences++; " is 147.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitExpressionStatement,The length of the statement  "      Debug.Assert(diff.Changes == changes.Expression && diff.Deletions == deletions.Expression && diff.Insertions == insertions.Expression); " is 135.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitFaultHandler,The length of the statement  "      Debug.Assert(diff.Changes == changes.Block && diff.Deletions == deletions.Block && diff.Insertions == insertions.Block); " is 120.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitField,The length of the statement  "      Differences diff = this.VisitAttributeList(field1.Attributes' field2.Attributes' out attrChanges' out attrDeletions' out attrInsertions); " is 137.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitField,The length of the statement  "      Debug.Assert(diff.Changes == changes.DefaultValue && diff.Deletions == deletions.DefaultValue && diff.Insertions == insertions.DefaultValue); " is 141.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitField,The length of the statement  "      if (field1.HidesBaseClassMember == field2.HidesBaseClassMember) differences.NumberOfSimilarities++; else differences.NumberOfDifferences++; " is 139.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitField,The length of the statement  "      diff = this.VisitInterfaceReferenceList(field1.ImplementedInterfaces' field2.ImplementedInterfaces' out ifaceChanges' out ifaceDeletions' out ifaceInsertions); " is 159.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitField,The length of the statement  "      if (this.ValuesAreEqual(field1.InitialData' field2.InitialData)) differences.NumberOfSimilarities++; else differences.NumberOfDifferences++; " is 140.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitField,The length of the statement  "      Debug.Assert(diff.Changes == changes.Initializer && diff.Deletions == deletions.Initializer && diff.Insertions == insertions.Initializer); " is 138.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitField,The length of the statement  "      if (this.ValuesAreEqual(field1.MarshallingInformation' field2.MarshallingInformation)) differences.NumberOfSimilarities++; else differences.NumberOfDifferences++; " is 162.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitField,The length of the statement  "      if (field1.OverridesBaseClassMember == field2.OverridesBaseClassMember) differences.NumberOfSimilarities++; else differences.NumberOfDifferences++; " is 147.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitFilter,The length of the statement  "      Debug.Assert(diff.Changes == changes.Block && diff.Deletions == deletions.Block && diff.Insertions == insertions.Block); " is 120.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitFilter,The length of the statement  "      Debug.Assert(diff.Changes == changes.Expression && diff.Deletions == deletions.Expression && diff.Insertions == insertions.Expression); " is 135.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitFinally,The length of the statement  "      Debug.Assert(diff.Changes == changes.Block && diff.Deletions == deletions.Block && diff.Insertions == insertions.Block); " is 120.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitFixed,The length of the statement  "      Debug.Assert(diff.Changes == changes.Declarators && diff.Deletions == deletions.Declarators && diff.Insertions == insertions.Declarators); " is 138.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitFor,The length of the statement  "      diff = this.VisitExpressionList(for1.Invariants' for2.Invariants' out changes.Invariants' out deletions.Invariants' out insertions.Invariants); " is 143.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitFor,The length of the statement  "      Debug.Assert(diff.Changes == changes.Condition && diff.Deletions == deletions.Condition && diff.Insertions == insertions.Condition); " is 132.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitFor,The length of the statement  "      diff = this.VisitStatementList(for1.Incrementer' for2.Incrementer' out statChanges' out statDeletions' out statInsertions); " is 123.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitFor,The length of the statement  "      diff = this.VisitStatementList(for1.Initializer' for2.Initializer' out statChanges' out statDeletions' out statInsertions); " is 123.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitForEach,The length of the statement  "      Debug.Assert(diff.Changes == changes.SourceEnumerable && diff.Deletions == deletions.SourceEnumerable && diff.Insertions == insertions.SourceEnumerable); " is 153.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitForEach,The length of the statement  "      diff = this.VisitExpressionList(forEach1.Invariants' forEach2.Invariants' out changes.Invariants' out deletions.Invariants' out insertions.Invariants); " is 151.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitForEach,The length of the statement  "      Debug.Assert(diff.Changes == changes.InductionVariable && diff.Deletions == deletions.InductionVariable && diff.Insertions == insertions.InductionVariable); " is 156.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitForEach,The length of the statement  "      Debug.Assert(diff.Changes == changes.TargetVariable && diff.Deletions == deletions.TargetVariable && diff.Insertions == insertions.TargetVariable); " is 147.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitForEach,The length of the statement  "      //Debug.Assert(diff.Changes == changes.TargetVariableType && diff.Deletions == deletions.TargetVariableType && diff.Insertions == insertions.TargetVariableType); " is 161.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitForEach,The length of the statement  "      if (forEach1.StatementTerminatesNormallyIfEnumerableIsNull == forEach2.StatementTerminatesNormallyIfEnumerableIsNull) differences.NumberOfSimilarities++; else differences.NumberOfDifferences++; " is 193.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitForEach,The length of the statement  "      if (forEach1.StatementTerminatesNormallyIfEnumeratorIsNull == forEach2.StatementTerminatesNormallyIfEnumeratorIsNull) differences.NumberOfSimilarities++; else differences.NumberOfDifferences++; " is 193.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitFunctionDeclaration,The length of the statement  "        if (functionDeclaration1 != functionDeclaration2) differences.NumberOfDifferences++; else differences.NumberOfSimilarities++; " is 125.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitFunctionDeclaration,The length of the statement  "      diff = this.VisitParameterList(functionDeclaration1.Parameters' functionDeclaration2.Parameters' out parChanges' out parDeletions' out parInsertions); " is 150.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitFunctionDeclaration,The length of the statement  "      //Debug.Assert(diff.Changes == changes.ReturnType && diff.Deletions == deletions.ReturnType && diff.Insertions == insertions.ReturnType); " is 137.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitTemplateInstance,The length of the statement  "      Debug.Assert(diff.Changes == changes.Expression && diff.Deletions == deletions.Expression && diff.Insertions == insertions.Expression); " is 135.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitTemplateInstance,The length of the statement  "      diff = this.VisitTypeNodeList(instance1.TypeArguments' instance2.TypeArguments' out typeChanges' out typeDeletions' out typeInsertions); " is 136.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitStackAlloc,The length of the statement  "      //Debug.Assert(diff.Changes == changes.ElementType && diff.Deletions == deletions.ElementType && diff.Insertions == insertions.ElementType); " is 140.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitStackAlloc,The length of the statement  "      Debug.Assert(diff.Changes == changes.NumberOfElements && diff.Deletions == deletions.NumberOfElements && diff.Insertions == insertions.NumberOfElements); " is 153.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitGoto,The length of the statement  "      Debug.Assert(diff.Changes == changes.TargetLabel && diff.Deletions == deletions.TargetLabel && diff.Insertions == insertions.TargetLabel); " is 138.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitGotoCase,The length of the statement  "      Debug.Assert(diff.Changes == changes.CaseLabel && diff.Deletions == deletions.CaseLabel && diff.Insertions == insertions.CaseLabel); " is 132.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitIf,The length of the statement  "      Debug.Assert(diff.Changes == changes.Condition && diff.Deletions == deletions.Condition && diff.Insertions == insertions.Condition); " is 132.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitIf,The length of the statement  "      Debug.Assert(diff.Changes == changes.FalseBlock && diff.Deletions == deletions.FalseBlock && diff.Insertions == insertions.FalseBlock); " is 135.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitIf,The length of the statement  "      Debug.Assert(diff.Changes == changes.TrueBlock && diff.Deletions == deletions.TrueBlock && diff.Insertions == insertions.TrueBlock); " is 132.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitIndexer,The length of the statement  "      Debug.Assert(diff.Changes == changes.Object && diff.Deletions == deletions.Object && diff.Insertions == insertions.Object); " is 123.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitIndexer,The length of the statement  "      diff = this.VisitExpressionList(indexer1.Operands' indexer2.Operands' out exprChanges' out exprDeletions' out exprInsertions); " is 126.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitLabeledStatement,The length of the statement  "      Debug.Assert(diff.Changes == changes.Label && diff.Deletions == deletions.Label && diff.Insertions == insertions.Label); " is 120.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitLabeledStatement,The length of the statement  "      Debug.Assert(diff.Changes == changes.Statement && diff.Deletions == deletions.Statement && diff.Insertions == insertions.Statement); " is 132.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitLocalDeclaration,The length of the statement  "      Debug.Assert(diff.Changes == changes.InitialValue && diff.Deletions == deletions.InitialValue && diff.Insertions == insertions.InitialValue); " is 141.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitLocalDeclarationsStatement,The length of the statement  "        if (localDeclarations1 != localDeclarations2) differences.NumberOfDifferences++; else differences.NumberOfSimilarities++; " is 121.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitLocalDeclarationsStatement,The length of the statement  "      if (localDeclarations1.Constant == localDeclarations2.Constant) differences.NumberOfSimilarities++; else differences.NumberOfDifferences++; " is 139.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitLocalDeclarationsStatement,The length of the statement  "      Differences diff = this.VisitLocalDeclarationList(localDeclarations1.Declarations' localDeclarations2.Declarations' out declChanges' out declDeletions' out declInsertions); " is 172.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitLocalDeclarationsStatement,The length of the statement  "      if (localDeclarations1.InitOnly == localDeclarations2.InitOnly) differences.NumberOfSimilarities++; else differences.NumberOfDifferences++; " is 139.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitLock,The length of the statement  "      Debug.Assert(diff.Changes == changes.Guard && diff.Deletions == deletions.Guard && diff.Insertions == insertions.Guard); " is 120.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitLRExpression,The length of the statement  "      Debug.Assert(diff.Changes == changes.Expression && diff.Deletions == deletions.Expression && diff.Insertions == insertions.Expression); " is 135.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitMemberBinding,The length of the statement  "      if (memberBinding1.Alignment == memberBinding2.Alignment) differences.NumberOfSimilarities++; else differences.NumberOfDifferences++; " is 133.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitMemberBinding,The length of the statement  "      Debug.Assert(diff.Changes == changes.BoundMember && diff.Deletions == deletions.BoundMember && diff.Insertions == insertions.BoundMember); " is 138.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitMemberBinding,The length of the statement  "      Debug.Assert(diff.Changes == changes.TargetObject && diff.Deletions == deletions.TargetObject && diff.Insertions == insertions.TargetObject); " is 141.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitMemberBinding,The length of the statement  "      if (memberBinding1.Volatile == memberBinding2.Volatile) differences.NumberOfSimilarities++; else differences.NumberOfDifferences++; " is 131.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitMethod,The length of the statement  "      Differences diff = this.VisitAttributeList(method1.Attributes' method2.Attributes' out attrChanges' out attrDeletions' out attrInsertions); " is 139.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitMethod,The length of the statement  "      if (method1.CallingConvention == method2.CallingConvention) differences.NumberOfSimilarities++; else differences.NumberOfDifferences++; " is 135.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitMethod,The length of the statement  "      Debug.Assert(diff.Changes == changes.DeclaringMember && diff.Deletions == deletions.DeclaringMember && diff.Insertions == insertions.DeclaringMember); " is 150.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitMethod,The length of the statement  "      if (method1.HasCompilerGeneratedSignature == method2.HasCompilerGeneratedSignature) differences.NumberOfSimilarities++; else differences.NumberOfDifferences++; " is 159.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitMethod,The length of the statement  "      if (method1.InitLocals == method2.InitLocals) differences.NumberOfSimilarities++; else differences.NumberOfDifferences++; " is 121.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitMethod,The length of the statement  "      diff = this.VisitTypeNodeList(method1.ImplementedTypes' method2.ImplementedTypes' out typeChanges' out typeDeletions' out typeInsertions); " is 138.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitMethod,The length of the statement  "      diff = this.VisitParameterList(method1.Parameters' method2.Parameters' out parChanges' out parDeletions' out parInsertions); " is 124.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitMethod,The length of the statement  "      if (method1.PInvokeFlags == method2.PInvokeFlags) differences.NumberOfSimilarities++; else differences.NumberOfDifferences++; " is 125.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitMethod,The length of the statement  "      if (method1.PInvokeImportName == method2.PInvokeImportName) differences.NumberOfSimilarities++; else differences.NumberOfDifferences++; " is 135.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitMethod,The length of the statement  "        (method1.PInvokeModule != null && method2.PInvokeModule != null && method1.PInvokeModule.Name == method2.PInvokeModule.Name)) " is 125.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitMethod,The length of the statement  "      diff = this.VisitAttributeList(method1.ReturnAttributes' method2.ReturnAttributes' out attrChanges' out attrDeletions' out attrInsertions); " is 139.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitMethod,The length of the statement  "      //Debug.Assert(diff.Changes == changes.ReturnType && diff.Deletions == deletions.ReturnType && diff.Insertions == insertions.ReturnType); " is 137.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitMethod,The length of the statement  "      diff = this.VisitSecurityAttributeList(method1.SecurityAttributes' method2.SecurityAttributes' out secChanges' out secDeletions' out secInsertions); " is 148.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitMethod,The length of the statement  "      Debug.Assert(diff.Changes == changes.Template && diff.Deletions == deletions.Template && diff.Insertions == insertions.Template); " is 129.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitMethod,The length of the statement  "      diff = this.VisitTypeNodeList(method1.TemplateArguments' method2.TemplateArguments' out typeChanges' out typeDeletions' out typeInsertions); " is 140.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitMethod,The length of the statement  "      diff = this.VisitTypeNodeList(method1.TemplateParameters' method2.TemplateParameters' out typeChanges' out typeDeletions' out typeInsertions); " is 142.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitMethodCall,The length of the statement  "      Debug.Assert(diff.Changes == changes.Callee && diff.Deletions == deletions.Callee && diff.Insertions == insertions.Callee); " is 123.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitMethodCall,The length of the statement  "      diff = this.VisitExpressionList(call1.Operands' call2.Operands' out exprChanges' out exprDeletions' out exprInsertions); " is 120.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitModule,The length of the statement  "      Differences diff = this.VisitAssemblyReferenceList(module1.AssemblyReferences' module2.AssemblyReferences' out arChanges' out arDeletions' out arInsertions); " is 157.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitModule,The length of the statement  "      diff = this.VisitAttributeList(module1.Attributes' module2.Attributes' out attrChanges' out attrDeletions' out attrInsertions); " is 127.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitModule,The length of the statement  "      if (module1.HashAlgorithm == module2.HashAlgorithm) differences.NumberOfSimilarities++; else differences.NumberOfDifferences++; " is 127.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitModule,The length of the statement  "      diff = this.VisitModuleReferenceList(module1.ModuleReferences' module2.ModuleReferences' out mrChanges' out mrDeletions' out mrInsertions); " is 139.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitModule,The length of the statement  "      diff = this.VisitSecurityAttributeList(module1.SecurityAttributes' module2.SecurityAttributes' out secChanges' out secDeletions' out secInsertions); " is 148.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitModule,The length of the statement  "      if (module1.TargetRuntimeVersion == module2.TargetRuntimeVersion) differences.NumberOfSimilarities++; else differences.NumberOfDifferences++; " is 141.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitModule,The length of the statement  "      if (module1.TrackDebugData == module2.TrackDebugData) differences.NumberOfSimilarities++; else differences.NumberOfDifferences++; " is 129.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitModuleReference,The length of the statement  "      if (moduleReference1.Name == moduleReference2.Name) differences.NumberOfSimilarities++; else differences.NumberOfDifferences++; " is 127.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitNameBinding,The length of the statement  "      Differences diff = this.VisitMemberList(nameBinding1.BoundMembers' nameBinding2.BoundMembers' out memChanges' out memDeletions' out memInsertions); " is 147.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitNameBinding,The length of the statement  "      Debug.Assert(diff.Changes == changes.Identifier && diff.Deletions == deletions.Identifier && diff.Insertions == insertions.Identifier); " is 135.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitNamedArgument,The length of the statement  "      if (namedArgument1.IsCustomAttributeProperty == namedArgument2.IsCustomAttributeProperty) differences.NumberOfSimilarities++; else differences.NumberOfDifferences++; " is 165.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitNamedArgument,The length of the statement  "      Debug.Assert(diff.Changes == changes.Value && diff.Deletions == deletions.Value && diff.Insertions == insertions.Value); " is 120.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitNamespace,The length of the statement  "      Differences diff = this.VisitAliasDefinitionList(nspace1.AliasDefinitions' nspace2.AliasDefinitions' out aliasChanges' out aliasDeletions' out aliasInsertions); " is 160.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitNamespace,The length of the statement  "      diff = this.VisitAttributeList(nspace1.Attributes' nspace2.Attributes' out attrChanges' out attrDeletions' out attrInsertions); " is 127.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitNamespace,The length of the statement  "      diff = this.VisitNamespaceList(nspace1.NestedNamespaces' nspace2.NestedNamespaces' out nsChanges' out nsDeletions' out nsInsertions); " is 133.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitNamespace,The length of the statement  "      diff = this.VisitUsedNamespaceList(nspace1.UsedNamespaces' nspace2.UsedNamespaces' out usedChanges' out usedDeletions' out usedInsertions); " is 139.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitParameter,The length of the statement  "      Differences diff = this.VisitAttributeList(parameter1.Attributes' parameter2.Attributes' out attrChanges' out attrDeletions' out attrInsertions); " is 145.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitParameter,The length of the statement  "      Debug.Assert(diff.Changes == changes.DefaultValue && diff.Deletions == deletions.DefaultValue && diff.Insertions == insertions.DefaultValue); " is 141.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitParameter,The length of the statement  "      if (this.ValuesAreEqual(parameter1.MarshallingInformation'parameter2.MarshallingInformation)) differences.NumberOfSimilarities++; else differences.NumberOfDifferences++;       " is 169.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitPrefixExpression,The length of the statement  "      Debug.Assert(diff.Changes == changes.Expression && diff.Deletions == deletions.Expression && diff.Insertions == insertions.Expression); " is 135.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitPostfixExpression,The length of the statement  "      Debug.Assert(diff.Changes == changes.Expression && diff.Deletions == deletions.Expression && diff.Insertions == insertions.Expression); " is 135.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitProperty,The length of the statement  "      Differences diff = this.VisitAttributeList(property1.Attributes' property2.Attributes' out attrChanges' out attrDeletions' out attrInsertions); " is 143.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitProperty,The length of the statement  "      Debug.Assert(diff.Changes == changes.Getter && diff.Deletions == deletions.Getter && diff.Insertions == insertions.Getter); " is 123.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitProperty,The length of the statement  "      diff = this.VisitTypeNodeList(property1.ImplementedTypes' property2.ImplementedTypes' out typeChanges' out typeDeletions' out typeInsertions); " is 142.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitProperty,The length of the statement  "      diff = this.VisitMethodList(property1.OtherMethods' property2.OtherMethods' out methChanges' out methDeletions' out methInsertions); " is 132.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitProperty,The length of the statement  "      if (property1.OverridesBaseClassMember == property2.OverridesBaseClassMember) differences.NumberOfSimilarities++; else differences.NumberOfDifferences++; " is 153.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitProperty,The length of the statement  "      diff = this.VisitParameterList(property1.Parameters' property2.Parameters' out parChanges' out parDeletions' out parInsertions); " is 128.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitProperty,The length of the statement  "      Debug.Assert(diff.Changes == changes.Setter && diff.Deletions == deletions.Setter && diff.Insertions == insertions.Setter); " is 123.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitQualifiedIdentifier,The length of the statement  "        if (qualifiedIdentifier1 != qualifiedIdentifier2) differences.NumberOfDifferences++; else differences.NumberOfSimilarities++; " is 125.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitQualifiedIdentifier,The length of the statement  "      Debug.Assert(diff.Changes == changes.Identifier && diff.Deletions == deletions.Identifier && diff.Insertions == insertions.Identifier); " is 135.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitQualifiedIdentifier,The length of the statement  "      Debug.Assert(diff.Changes == changes.Qualifier && diff.Deletions == deletions.Qualifier && diff.Insertions == insertions.Qualifier); " is 132.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitRepeat,The length of the statement  "      Debug.Assert(diff.Changes == changes.Condition && diff.Deletions == deletions.Condition && diff.Insertions == insertions.Condition); " is 132.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitResourceUse,The length of the statement  "      Debug.Assert(diff.Changes == changes.ResourceAcquisition && diff.Deletions == deletions.ResourceAcquisition && diff.Insertions == insertions.ResourceAcquisition); " is 162.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitReturn,The length of the statement  "      Debug.Assert(diff.Changes == changes.Expression && diff.Deletions == deletions.Expression && diff.Insertions == insertions.Expression); " is 135.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitSecurityAttribute,The length of the statement  "      Differences diff = this.VisitAttributeList(attribute1.PermissionAttributes' attribute2.PermissionAttributes' out attrChanges' out attrDeletions' out attrInsertions); " is 165.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitSecurityAttribute,The length of the statement  "        attribute1.SerializedPermissions == attribute2.SerializedPermissions) differences.NumberOfSimilarities++; else differences.NumberOfDifferences++; " is 145.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitStatementSnippet,The length of the statement  "        if (snippet1.SourceContext.Document == snippet2.SourceContext.Document) differences.NumberOfSimilarities++; else differences.NumberOfDifferences++; " is 147.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitSwitch,The length of the statement  "      Differences diff = this.VisitSwitchCaseList(switch1.Cases' switch2.Cases' out caseChanges' out caseDeletions' out caseInsertions); " is 130.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitSwitch,The length of the statement  "      Debug.Assert(diff.Changes == changes.Expression && diff.Deletions == deletions.Expression && diff.Insertions == insertions.Expression); " is 135.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitSwitchCase,The length of the statement  "      Debug.Assert(diff.Changes == changes.Label && diff.Deletions == deletions.Label && diff.Insertions == insertions.Label); " is 120.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitSwitchInstruction,The length of the statement  "        if (switchInstruction1 != switchInstruction2) differences.NumberOfDifferences++; else differences.NumberOfSimilarities++; " is 121.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitSwitchInstruction,The length of the statement  "      Debug.Assert(diff.Changes == changes.Expression && diff.Deletions == deletions.Expression && diff.Insertions == insertions.Expression); " is 135.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitSwitchInstruction,The length of the statement  "      diff = this.VisitBlockList(switchInstruction1.Targets' switchInstruction2.Targets' out blockChanges' out blockDeletions' out blockInsertions); " is 142.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitTypeswitch,The length of the statement  "      Differences diff = this.VisitTypeswitchCaseList(typeswitch1.Cases' typeswitch2.Cases' out caseChanges' out caseDeletions' out caseInsertions); " is 142.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitTypeswitch,The length of the statement  "      Debug.Assert(diff.Changes == changes.Expression && diff.Deletions == deletions.Expression && diff.Insertions == insertions.Expression); " is 135.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitTypeswitchCase,The length of the statement  "      //Debug.Assert(diff.Changes == changes.LabelType && diff.Deletions == deletions.LabelType && diff.Insertions == insertions.LabelType); " is 134.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitTypeswitchCase,The length of the statement  "      Debug.Assert(diff.Changes == changes.LabelVariable && diff.Deletions == deletions.LabelVariable && diff.Insertions == insertions.LabelVariable); " is 144.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitTernaryExpression,The length of the statement  "      if (expression1.NodeType == expression2.NodeType) differences.NumberOfSimilarities++; else differences.NumberOfDifferences++; " is 125.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitTernaryExpression,The length of the statement  "      Debug.Assert(diff.Changes == changes.Operand1 && diff.Deletions == deletions.Operand1 && diff.Insertions == insertions.Operand1); " is 129.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitTernaryExpression,The length of the statement  "      Debug.Assert(diff.Changes == changes.Operand2 && diff.Deletions == deletions.Operand2 && diff.Insertions == insertions.Operand2); " is 129.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitTernaryExpression,The length of the statement  "      Debug.Assert(diff.Changes == changes.Operand3 && diff.Deletions == deletions.Operand3 && diff.Insertions == insertions.Operand3); " is 129.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitThrow,The length of the statement  "      Debug.Assert(diff.Changes == changes.Expression && diff.Deletions == deletions.Expression && diff.Insertions == insertions.Expression); " is 135.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitTry,The length of the statement  "      Differences diff = this.VisitCatchList(try1.Catchers' try2.Catchers' out catchChanges' out catchDeletions' out catchInsertions); " is 128.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitTry,The length of the statement  "      diff = this.VisitFaultHandlerList(try1.FaultHandlers' try2.FaultHandlers' out faultChanges' out faultDeletions' out faultInsertions); " is 133.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitTry,The length of the statement  "      Debug.Assert(diff.Changes == changes.Finally && diff.Deletions == deletions.Finally && diff.Insertions == insertions.Finally); " is 126.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitTry,The length of the statement  "      Debug.Assert(diff.Changes == changes.TryBlock && diff.Deletions == deletions.TryBlock && diff.Insertions == insertions.TryBlock); " is 129.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitTypeMemberSnippet,The length of the statement  "        if (snippet1.SourceContext.Document == snippet2.SourceContext.Document) differences.NumberOfSimilarities++; else differences.NumberOfDifferences++; " is 147.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitTypeModifier,The length of the statement  "      //Debug.Assert(diff.Changes == changes.ModifiedType && diff.Deletions == deletions.ModifiedType && diff.Insertions == insertions.ModifiedType); " is 143.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitTypeModifier,The length of the statement  "      //Debug.Assert(diff.Changes == changes.Modifier && diff.Deletions == deletions.Modifier && diff.Insertions == insertions.Modifier); " is 131.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitTypeNode,The length of the statement  "      Differences diff = this.VisitAttributeList(typeNode1.Attributes' typeNode2.Attributes' out attrChanges' out attrDeletions' out attrInsertions); " is 143.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitTypeNode,The length of the statement  "      if (typeNode1.ClassSize == typeNode2.ClassSize) differences.NumberOfSimilarities++; else differences.NumberOfDifferences++; " is 123.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitTypeNode,The length of the statement  "      //Debug.Assert(diff.Changes == changes.DeclaringType && diff.Deletions == deletions.DeclaringType && diff.Insertions == insertions.DeclaringType); " is 146.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitTypeNode,The length of the statement  "      if (typeNode1.HidesBaseClassMember == typeNode2.HidesBaseClassMember) differences.NumberOfSimilarities++; else differences.NumberOfDifferences++; " is 145.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitTypeNode,The length of the statement  "      diff = this.VisitInterfaceReferenceList(typeNode1.Interfaces' typeNode2.Interfaces' out ifaceChanges' out ifaceDeletions' out ifaceInsertions); " is 143.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitTypeNode,The length of the statement  "      if (typeNode1.IsGeneric == typeNode2.IsGeneric) differences.NumberOfSimilarities++; else differences.NumberOfDifferences++; " is 123.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitTypeNode,The length of the statement  "      Debug.Assert(diff.Changes == changes.Namespace && diff.Deletions == deletions.Namespace && diff.Insertions == insertions.Namespace); " is 132.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitTypeNode,The length of the statement  "      if (typeNode1.NodeType == typeNode2.NodeType) differences.NumberOfSimilarities++; else differences.NumberOfDifferences++; " is 121.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitTypeNode,The length of the statement  "      if (typeNode1.PackingSize == typeNode2.PackingSize) differences.NumberOfSimilarities++; else differences.NumberOfDifferences++; " is 127.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitTypeNode,The length of the statement  "      diff = this.VisitSecurityAttributeList(typeNode1.SecurityAttributes' typeNode2.SecurityAttributes' out secChanges' out secDeletions' out secInsertions); " is 152.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitTypeNode,The length of the statement  "      //Debug.Assert(diff.Changes == changes.Template && diff.Deletions == deletions.Template && diff.Insertions == insertions.Template); " is 131.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitTypeNode,The length of the statement  "      diff = this.VisitTypeNodeList(typeNode1.TemplateArguments' typeNode2.TemplateArguments' out typeChanges' out typeDeletions' out typeInsertions); " is 144.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitTypeNode,The length of the statement  "      diff = this.VisitTypeNodeList(typeNode1.TemplateParameters' typeNode2.TemplateParameters' out typeChanges' out typeDeletions' out typeInsertions); " is 146.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitUnaryExpression,The length of the statement  "      if (unaryExpression1.NodeType == unaryExpression2.NodeType) differences.NumberOfSimilarities++; else differences.NumberOfDifferences++; " is 135.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitUnaryExpression,The length of the statement  "      Debug.Assert(diff.Changes == changes.Operand && diff.Deletions == deletions.Operand && diff.Insertions == insertions.Operand); " is 126.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitVariableDeclaration,The length of the statement  "        if (variableDeclaration1 != variableDeclaration2) differences.NumberOfDifferences++; else differences.NumberOfSimilarities++; " is 125.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitUsedNamespace,The length of the statement  "      Debug.Assert(diff.Changes == changes.Namespace && diff.Deletions == deletions.Namespace && diff.Insertions == insertions.Namespace); " is 132.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitWhile,The length of the statement  "      diff = this.VisitExpressionList(while1.Invariants' while2.Invariants' out changes.Invariants' out deletions.Invariants' out insertions.Invariants); " is 147.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitWhile,The length of the statement  "      Debug.Assert(diff.Changes == changes.Condition && diff.Deletions == deletions.Condition && diff.Insertions == insertions.Condition); " is 132.
Long Statement,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitYield,The length of the statement  "      Debug.Assert(diff.Changes == changes.Expression && diff.Deletions == deletions.Expression && diff.Insertions == insertions.Expression); " is 135.
Long Statement,Microsoft.Cci,StandardDoubleVisitor,C:\repos\Reactive-Extensions_IL2JS\CCI\DoubleVisitor.cs,VisitAssembly,The length of the statement  "        assembly1.SecurityAttributes = this.VisitSecurityAttributeList(assembly1.SecurityAttributes' assembly2.SecurityAttributes); " is 123.
Long Statement,Microsoft.Cci,StandardDoubleVisitor,C:\repos\Reactive-Extensions_IL2JS\CCI\DoubleVisitor.cs,VisitAssignmentExpression,The length of the statement  "        assignment1.AssignmentStatement = (Statement)this.Visit(assignment1.AssignmentStatement' assignment2.AssignmentStatement); " is 122.
Long Statement,Microsoft.Cci,StandardDoubleVisitor,C:\repos\Reactive-Extensions_IL2JS\CCI\DoubleVisitor.cs,VisitCompilation,The length of the statement  "      compilation1.CompilationUnits = this.VisitCompilationUnitList(compilation1.CompilationUnits' compilation2 == null ? null : compilation2.CompilationUnits); " is 154.
Long Statement,Microsoft.Cci,StandardDoubleVisitor,C:\repos\Reactive-Extensions_IL2JS\CCI\DoubleVisitor.cs,VisitField,The length of the statement  "        field1.ImplementedInterfaces = this.VisitInterfaceReferenceList(field1.ImplementedInterfaces' field2.ImplementedInterfaces); " is 124.
Long Statement,Microsoft.Cci,StandardDoubleVisitor,C:\repos\Reactive-Extensions_IL2JS\CCI\DoubleVisitor.cs,VisitFunctionDeclaration,The length of the statement  "        functionDeclaration1.Parameters = this.VisitParameterList(functionDeclaration1.Parameters' functionDeclaration2.Parameters); " is 124.
Long Statement,Microsoft.Cci,StandardDoubleVisitor,C:\repos\Reactive-Extensions_IL2JS\CCI\DoubleVisitor.cs,VisitFunctionDeclaration,The length of the statement  "        functionDeclaration1.ReturnType = this.VisitTypeReference(functionDeclaration1.ReturnType' functionDeclaration2.ReturnType); " is 124.
Long Statement,Microsoft.Cci,StandardDoubleVisitor,C:\repos\Reactive-Extensions_IL2JS\CCI\DoubleVisitor.cs,VisitTemplateInstance,The length of the statement  "        genericInstance1.TypeArguments = this.VisitTypeReferenceList(genericInstance1.TypeArguments' genericInstance2.TypeArguments); " is 125.
Long Statement,Microsoft.Cci,StandardDoubleVisitor,C:\repos\Reactive-Extensions_IL2JS\CCI\DoubleVisitor.cs,VisitInterfaceReferenceList,The length of the statement  "      for (int i = 0' n = interfaceReferences1.Count' m = interfaceReferences2 == null ? 0 : interfaceReferences2.Count; i < n; i++){ " is 127.
Long Statement,Microsoft.Cci,StandardDoubleVisitor,C:\repos\Reactive-Extensions_IL2JS\CCI\DoubleVisitor.cs,VisitLocalDeclarationList,The length of the statement  "      for (int i = 0' n = localDeclarations1.Count' m = localDeclarations2 == null ? 0 : localDeclarations2.Count; i < n; i++){ " is 121.
Long Statement,Microsoft.Cci,StandardDoubleVisitor,C:\repos\Reactive-Extensions_IL2JS\CCI\DoubleVisitor.cs,VisitLocalDeclarationsStatement,The length of the statement  "        localDeclarations1.Declarations = this.VisitLocalDeclarationList(localDeclarations1.Declarations' localDeclarations2.Declarations); " is 131.
Long Statement,Microsoft.Cci,StandardDoubleVisitor,C:\repos\Reactive-Extensions_IL2JS\CCI\DoubleVisitor.cs,VisitQuantifier,The length of the statement  "        quantifier1.Comprehension = (Comprehension)this.VisitComprehension(quantifier1.Comprehension'quantifier2.Comprehension); " is 120.
Long Statement,Microsoft.Cci,StandardDoubleVisitor,C:\repos\Reactive-Extensions_IL2JS\CCI\DoubleVisitor.cs,VisitComprehension,The length of the statement  "        comprehension1.BindingsAndFilters = this.VisitExpressionList(comprehension1.BindingsAndFilters' comprehension2.BindingsAndFilters); " is 131.
Long Statement,Microsoft.Cci,StandardDoubleVisitor,C:\repos\Reactive-Extensions_IL2JS\CCI\DoubleVisitor.cs,VisitComprehensionBinding,The length of the statement  "        comprehensionBinding1.TargetVariableType = this.VisitTypeReference(comprehensionBinding1.TargetVariableType' comprehensionBinding2.TargetVariableType); " is 151.
Long Statement,Microsoft.Cci,StandardDoubleVisitor,C:\repos\Reactive-Extensions_IL2JS\CCI\DoubleVisitor.cs,VisitComprehensionBinding,The length of the statement  "        comprehensionBinding1.TargetVariable = this.VisitTargetExpression(comprehensionBinding1.TargetVariable' comprehensionBinding2.TargetVariable); " is 142.
Long Statement,Microsoft.Cci,StandardDoubleVisitor,C:\repos\Reactive-Extensions_IL2JS\CCI\DoubleVisitor.cs,VisitComprehensionBinding,The length of the statement  "        comprehensionBinding1.SourceEnumerable = this.VisitExpression(comprehensionBinding1.SourceEnumerable' comprehensionBinding2.SourceEnumerable); " is 142.
Long Statement,Microsoft.Cci,StandardDoubleVisitor,C:\repos\Reactive-Extensions_IL2JS\CCI\DoubleVisitor.cs,VisitResourceUse,The length of the statement  "        resourceUse1.ResourceAcquisition = (Statement)this.Visit(resourceUse1.ResourceAcquisition' resourceUse2.ResourceAcquisition); " is 125.
Long Statement,Microsoft.Cci,StandardDoubleVisitor,C:\repos\Reactive-Extensions_IL2JS\CCI\DoubleVisitor.cs,VisitTypeswitchCase,The length of the statement  "        typeswitchCase1.LabelVariable = this.VisitTargetExpression(typeswitchCase1.LabelVariable' typeswitchCase2.LabelVariable); " is 121.
Long Statement,Microsoft.Cci,StandardDoubleVisitor,C:\repos\Reactive-Extensions_IL2JS\CCI\DoubleVisitor.cs,VisitTypeNode,The length of the statement  "        typeNode1.SecurityAttributes = this.VisitSecurityAttributeList(typeNode1.SecurityAttributes' typeNode2.SecurityAttributes); " is 123.
Long Statement,Microsoft.Cci,StandardDoubleVisitor,C:\repos\Reactive-Extensions_IL2JS\CCI\DoubleVisitor.cs,VisitVariableDeclaration,The length of the statement  "        variableDeclaration1.Initializer = this.VisitExpression(variableDeclaration1.Initializer' variableDeclaration2.Initializer); " is 124.
Long Statement,Microsoft.Cci,Duplicator,C:\repos\Reactive-Extensions_IL2JS\CCI\Duplicator.cs,VisitMemberReference,The length of the statement  "      if (member is ParameterField && !(member.DeclaringType is ClosureClass)) return member; //Can happen when duplicating expressions within a method " is 145.
Long Statement,Microsoft.Cci,Duplicator,C:\repos\Reactive-Extensions_IL2JS\CCI\Duplicator.cs,VisitMemberReference,The length of the statement  "      if (method != null && method.Template != null && method.TemplateArguments != null && method.TemplateArguments.Count > 0){ " is 121.
Long Statement,Microsoft.Cci,Duplicator,C:\repos\Reactive-Extensions_IL2JS\CCI\Duplicator.cs,VisitModuleReference,The length of the statement  "      for (int i = 0' n = this.TargetModule.ModuleReferences == null ? 0 : this.TargetModule.ModuleReferences.Count; i < n; i++){ " is 123.
Long Statement,Microsoft.Cci,Duplicator,C:\repos\Reactive-Extensions_IL2JS\CCI\Duplicator.cs,VisitTypeReference,The length of the statement  "          dup = FunctionType.For(this.VisitTypeReference(ftype.ReturnType)' this.VisitParameterList(ftype.Parameters)' this.TargetType); " is 126.
Long Statement,Microsoft.Cci,Duplicator,C:\repos\Reactive-Extensions_IL2JS\CCI\Duplicator.cs,VisitTypeReference,The length of the statement  "          (!this.RecordOriginalAsTemplate && type.ConsolidatedTemplateArguments != null && type.ConsolidatedTemplateArguments.Count > 0))) { " is 130.
Long Statement,Microsoft.Cci,BetterPath,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,ChangeExtension,The length of the statement  "        if (((ch1 == BetterPath.DirectorySeparatorChar) || (ch1 == BetterPath.AltDirectorySeparatorChar)) || (ch1 == BetterPath.VolumeSeparatorChar)) " is 141.
Long Statement,Microsoft.Cci,BetterPath,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Combine,The length of the statement  "      if (ch == BetterPath.DirectorySeparatorChar || ch == BetterPath.AltDirectorySeparatorChar || (path2.Length >= 2 && path2[1] == BetterPath.VolumeSeparatorChar)) " is 159.
Long Statement,Microsoft.Cci,BetterPath,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Combine,The length of the statement  "      if (ch != BetterPath.DirectorySeparatorChar && ch != BetterPath.AltDirectorySeparatorChar && ch != BetterPath.VolumeSeparatorChar) " is 130.
Long Statement,Microsoft.Cci,BetterPath,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,GetExtension,The length of the statement  "        if (ch == BetterPath.DirectorySeparatorChar || ch == BetterPath.AltDirectorySeparatorChar || ch == BetterPath.VolumeSeparatorChar) " is 130.
Long Statement,Microsoft.Cci,BetterPath,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,GetFileName,The length of the statement  "        if (ch == BetterPath.DirectorySeparatorChar || ch == BetterPath.AltDirectorySeparatorChar || ch == BetterPath.VolumeSeparatorChar) " is 130.
Long Statement,Microsoft.Cci,BetterPath,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,GetDirectoryName,The length of the statement  "        if (ch == BetterPath.DirectorySeparatorChar || ch == BetterPath.AltDirectorySeparatorChar || ch == BetterPath.VolumeSeparatorChar) " is 130.
Long Statement,Microsoft.Cci,BetterPath,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,HasExtension,The length of the statement  "          if (((ch1 == BetterPath.DirectorySeparatorChar) || (ch1 == BetterPath.AltDirectorySeparatorChar)) || (ch1 == BetterPath.VolumeSeparatorChar)) { " is 143.
Long Statement,Microsoft.Cci,ReGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI\ILGenerator.cs,VisitExceptionHandlers,The length of the statement  "      //When a handler does not have exactly the same start and end blocks as the previous handler' it is either a parent or a sibling. " is 129.
Long Statement,Microsoft.Cci,ReGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI\ILGenerator.cs,VisitExceptionHandlers,The length of the statement  "      //When this transition occurs an end exception can be emitted when processing the last handler block of the previous handler. " is 125.
Long Statement,Microsoft.Cci,ReGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI\ILGenerator.cs,VisitExceptionHandlers,The length of the statement  "      //Need to keep counts of the number of times a block starts a handler protected region and the number of times that a block " is 123.
Long Statement,Microsoft.Cci,DocumentText,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,Substring,The length of the statement  "      if (position+length > this.Length) length = this.Length-position; //Allow virtual EOF character to be included in length " is 120.
Long Statement,Microsoft.Cci,Document,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,DeleteLines,The length of the statement  "      Debug.Assert(offset >= 0 && this.Text != null && offset < this.Text.Length && lineCount > 0 && this.lineOffsets != null); " is 121.
Long Statement,Microsoft.Cci,Document,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,InsertLines,The length of the statement  "      Debug.Assert(offset >= 0 && this.Text != null && offset < this.Text.Length && lineCount > 0 && this.lineOffsets != null); " is 121.
Long Statement,Microsoft.Cci,SourceContext,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,Encloses,The length of the statement  "      return this.StartPos <= sourceContext.StartPos && this.EndPos >= sourceContext.EndPos && this.EndPos > sourceContext.StartPos; " is 126.
Long Statement,Microsoft.Cci,AttributeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,SetAttributeProperty,The length of the statement  "      //Because we invoke the setter through reflection' a stack walk is performed. The following two commented-out statements " is 120.
Long Statement,Microsoft.Cci,AttributeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,SetAttributeProperty,The length of the statement  "      //System.Security.PermissionSet perm = new System.Security.PermissionSet(System.Security.Permissions.PermissionState.None); " is 123.
Long Statement,Microsoft.Cci,AttributeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,ConstructAttribute,The length of the statement  "      //Because we invoke the constructor through reflection' a stack walk is performed. The following two commented-out statements " is 125.
Long Statement,Microsoft.Cci,AttributeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,ConstructAttribute,The length of the statement  "      //System.Security.PermissionSet perm = new System.Security.PermissionSet(System.Security.Permissions.PermissionState.None); " is 123.
Long Statement,Microsoft.Cci,SecurityAttribute,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetSecurityElement,The length of the statement  "      System.Reflection.MethodInfo getTopElement = parserType.GetMethod("GetTopElement"' BindingFlags.NonPublic|BindingFlags.Instance' null' new Type[]{}' null); " is 155.
Long Statement,Microsoft.Cci,SecurityAttribute,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetSecurityElement,The length of the statement  "      object parser = Activator.CreateInstance(parserType' BindingFlags.Instance|BindingFlags.NonPublic' null' new Object[]{this.serializedPermissions}' null); " is 153.
Long Statement,Microsoft.Cci,SecurityAttribute,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,InstantiatePermissionAttributes,The length of the statement  "      System.Security.PermissionSet permissions = new System.Security.PermissionSet(System.Security.Permissions.PermissionState.None); " is 128.
Long Statement,Microsoft.Cci,SecurityAttribute,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetPermissionOrSetOfPermissionsFromAttribute,The length of the statement  "      System.Security.Permissions.SecurityAttribute secAttr = attr.GetRuntimeAttribute() as System.Security.Permissions.SecurityAttribute; " is 132.
Long Statement,Microsoft.Cci,SecurityAttribute,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetPermissionOrSetOfPermissionsFromAttribute,The length of the statement  "      System.Security.Permissions.PermissionSetAttribute pSetAttr = secAttr as System.Security.Permissions.PermissionSetAttribute; " is 124.
Long Statement,Microsoft.Cci,SecurityAttribute,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,CreatePermission,The length of the statement  "      System.Security.PermissionSet perm = new System.Security.PermissionSet(System.Security.Permissions.PermissionState.None); " is 121.
Long Statement,Microsoft.Cci,Module,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetNestedModule,The length of the statement  "      ModuleReferenceList moduleReferences = this.ModuleReferences; //This should now contain all interesting referenced modules " is 122.
Long Statement,Microsoft.Cci,Module,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetType,The length of the statement  "      return this.GetType(@namespace' name' lookInReferencedAssemblies' lookInReferencedAssemblies ? new TrivialHashtable() : null); " is 126.
Long Statement,Microsoft.Cci,AssemblyNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetAssembly,The length of the statement  "      return (new Reader(buffer' cache' doNotLockFile' getDebugInfo' useGlobalCache' preserveShortBranches)).ReadModule() as AssemblyNode; " is 132.
Long Statement,Microsoft.Cci,AssemblyNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetAssembly,The length of the statement  "      return (new Reader(location' cache' doNotLockFile' getDebugInfo' useGlobalCache' preserveShortBranches)).ReadModule(postLoadEvent) as AssemblyNode; " is 147.
Long Statement,Microsoft.Cci,AssemblyNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetAssembly,The length of the statement  "        return AssemblyNode.GetAssembly(runtimeAssembly.Location' cache' false' getDebugInfo' useGlobalCache' preserveShortBranches); " is 125.
Long Statement,Microsoft.Cci,AssemblyNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetRuntimeAssembly,The length of the statement  "          if (this.cachedRuntimeAssembly != null && evidence == null && targetAppDomain == null) return this.cachedRuntimeAssembly.Value; " is 127.
Long Statement,Microsoft.Cci,AssemblyNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,InitializePostAssemblyLoadAndFire,The length of the statement  "        this.AfterAssemblyLoad = referringAssembly.AfterAssemblyLoad; // pass it along so any assembly references from "this" also get it " is 129.
Long Statement,Microsoft.Cci,AssemblyReference,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,Matches,The length of the statement  "      if (this.Version != version && this.Version != null && (version == null || !this.Version.Equals(version))) return false; " is 120.
Long Statement,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetArrayType,The length of the statement  "      return this.GetArrayType(rank' sizes == null ? 0 : sizes.Length' loBounds == null ? 0 : loBounds.Length' sizes == null ? new int[0] : sizes' loBounds == null ? new int[0] : loBounds); " is 183.
Long Statement,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetConstructors,The length of the statement  "        return this.constructors = TypeNode.WeedOutNonSpecialMethods(this.GetMembersNamed(StandardIds.Ctor)' MethodFlags.RTSpecialName); " is 128.
Long Statement,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetModified,The length of the statement  "      result = optionalModifier ? (TypeNode)new OptionalModifier(modifierType' this) : (TypeNode)new RequiredModifier(modifierType' this); " is 132.
Long Statement,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetGenericTemplateInstance,The length of the statement  "      if (nestedType == null) { Debug.Fail("template declaring type dummy instance does not have a nested type corresponding to template"); nestedType = this; } " is 154.
Long Statement,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,TryToFindExistingInstance,The length of the statement  "      bool lookInReferencedAssemblies = TargetPlatform.GenericTypeNamesMangleChar != '`'; //REVIEW: huh? why not use IsGeneric? " is 121.
Long Statement,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,TryToFindExistingInstance,The length of the statement  "      result = module.GetStructurallyEquivalentType(this.Namespace == null ? Identifier.Empty : this.Namespace' mangledName' uniqueMangledName' lookInReferencedAssemblies); " is 166.
Long Statement,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,TryToFindExistingInstance,The length of the statement  "        //Mangled name is the same. But mangling is not unique (types are not qualified with assemblies)' so check for equality. " is 120.
Long Statement,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,TryToFindExistingInstance,The length of the statement  "        result = module.GetStructurallyEquivalentType(this.Namespace == null ? Identifier.Empty : this.Namespace' mangledName' null' lookInReferencedAssemblies); " is 153.
Long Statement,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetMangledTemplateInstanceName,The length of the statement  "        GetMangledTemplateInstanceName(templateArguments' out notFullySpecialized' mangledNameBuilder' uniqueMangledNameBuilder); " is 121.
Long Statement,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetTemplateInstance,The length of the statement  "      if (module == null || templateArguments == null || (declaringType == null && (templateParameters == null || templateParameters.Count == 0))) " is 140.
Long Statement,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetTemplateInstance,The length of the statement  "      Identifier mangledName = this.GetMangledTemplateInstanceName(templateArguments' out uniqueMangledName' out notFullySpecialized); " is 128.
Long Statement,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetTemplateInstance,The length of the statement  "      this.TryToFindExistingInstance(module' declaringType' templateArguments' mangledName' uniqueMangledName' out result' out dummyId); " is 130.
Long Statement,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetTemplateInstance,The length of the statement  "      if (this.NewTemplateInstanceIsRecursive) return this; //An instance of this template is trying to instantiate the template again " is 128.
Long Statement,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetTemplateInstance,The length of the statement  "        this.TryToFindExistingInstance(module' declaringType' templateArguments' mangledName' uniqueMangledName' out result' out unusedMangledName); " is 140.
Long Statement,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetTemplateInstance,The length of the statement  "        result = duplicator.VisitTypeNode(this' unusedMangledName' consolidatedTemplateArguments' this.Template == null ? this : this.Template' true); " is 142.
Long Statement,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetTemplateInstance,The length of the statement  "        result.IsNotFullySpecialized = notFullySpecialized || (declaringType != null && TypeIsNotFullySpecialized(declaringType)); " is 122.
Long Statement,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetTemplateInstance,The length of the statement  "        //Arrange for template instance to be emitted to module and to be recognized as a template instance when imported from module. " is 126.
Long Statement,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetTemplateInstance,The length of the statement  "        attr.Target = AttributeTargets.Delegate|AttributeTargets.Class|AttributeTargets.Enum|AttributeTargets.Interface|AttributeTargets.Struct; " is 136.
Long Statement,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetOpFalse,The length of the statement  "              if (!opFalse.IsSpecialName || !opFalse.IsStatic || !opFalse.IsPublic || opFalse.ReturnType != CoreSystemTypes.Boolean || " is 120.
Long Statement,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetRuntimeType,The length of the statement  "              if (this.IsPublic) flags |= System.Reflection.BindingFlags.Public; else flags |= System.Reflection.BindingFlags.NonPublic; " is 122.
Long Statement,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetRuntimeType,The length of the statement  "          }else if (this.DeclaringModule != null && this.DeclaringModule.IsNormalized && this.DeclaringModule.ContainingAssembly != null){         " is 128.
Long Statement,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetImplementingMethod,The length of the statement  "        if ((locM.ReturnType != meth.ReturnType && !(locM.ReturnType != null && locM.ReturnType.IsStructurallyEquivalentTo(meth.ReturnType))) || " is 136.
Long Statement,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,IsAssignableTo,The length of the statement  "      if (this.BaseType != null && this.ConsolidatedTemplateParameters != null && this.BaseType.Template != null && this.BaseType.Template.IsAssignableTo(targetType)) " is 160.
Long Statement,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,IsAssignableTo,The length of the statement  "        return true; //When seeing if one template is assignable to another' be sure to strip off template instances along the inheritance chain " is 136.
Long Statement,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,IsAssignableTo,The length of the statement  "          return true; //When seeing if one template is assignable to another' be sure to strip off template instances along the inheritance chain " is 136.
Long Statement,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,IsAssignableToInstanceOf,The length of the statement  "      if (this != CoreSystemTypes.Object && this.BaseType != null && this.BaseType.IsAssignableToInstanceOf(targetTemplate' out templateArguments)) return true; " is 154.
Long Statement,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,DeepStripModifiers,The length of the statement  "          TypeNodeList templateTypeArgs = templateType.TemplateArguments != null ? templateType.TemplateArguments : templateType.TemplateParameters; " is 138.
Long Statement,Microsoft.Cci,GenericTypeInstanceHelpers,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,IsStructurallyEquivalentTo,The length of the statement  "                return IsStructurallyEquivalentTo(leftGenericInstance' rightGenericInstance.Generic' rightGenericInstance.GenericArguments); " is 124.
Long Statement,Microsoft.Cci,NamespaceScope,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetNamespaceFullNameFor,The length of the statement  "      if (name == null || this.AssociatedNamespace == null || this.AssociatedModule == null || this.nestedNamespaceFullName == null){ " is 127.
Long Statement,Microsoft.Cci,NamespaceScope,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetType,The length of the statement  "          if (nsScope.AssociatedNamespace.FullNameId != null && nsScope.AssociatedNamespace.FullNameId.UniqueIdKey != Identifier.Empty.UniqueIdKey) " is 137.
Long Statement,Microsoft.Cci,NamespaceScope,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetType,The length of the statement  "            if (nsScope.AssociatedNamespace.FullNameId != null && nsScope.AssociatedNamespace.FullNameId.UniqueIdKey != Identifier.Empty.UniqueIdKey) " is 137.
Long Statement,Microsoft.Cci,NamespaceScope,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetType,The length of the statement  "        if (this.AssociatedNamespace.FullName != null && this.AssociatedNamespace.Name.UniqueIdKey != Identifier.Empty.UniqueIdKey) " is 123.
Long Statement,Microsoft.Cci,NamespaceScope,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetType,The length of the statement  "        //If the namespace (or an outer namespace) has an alias definition with this name it wins. (Expected to be mutually exclusive with above.)         " is 138.
Long Statement,Microsoft.Cci,NamespaceScope,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetType,The length of the statement  "      if (duplicates != null && duplicates.Count > 1 && this.AssociatedNamespace != null && this.AssociatedNamespace.Name != null && this.AssociatedNamespace.Name.Name != null) { " is 172.
Long Statement,Microsoft.Cci,NamespaceScope,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,IsNotAccessible,The length of the statement  "              !associatedAssembly.MayAccessInternalTypesOf(dup.DeclaringModule as AssemblyNode)) && !this.AssociatedModule.ContainsModule(dup.DeclaringModule); " is 145.
Long Statement,Microsoft.Cci,FunctionType,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,For,The length of the statement  "        //Mangled name is the same. But mangling is not unique (types are not qualified with assemblies)' so check for equality. " is 120.
Long Statement,Microsoft.Cci,ArrayType,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,IsAssignableTo,The length of the statement  "      if (targetType == this || targetType == CoreSystemTypes.Object || targetType == CoreSystemTypes.Array || targetType == SystemTypes.ICloneable) return true; " is 155.
Long Statement,Microsoft.Cci,ArrayType,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,IsAssignableTo,The length of the statement  "      if (targetType.Template != null && SystemTypes.GenericIEnumerable != null && SystemTypes.GenericIEnumerable.DeclaringModule == CoreSystemTypes.SystemAssembly) { " is 160.
Long Statement,Microsoft.Cci,TypeModifier,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,IsStructurallyEquivalentTo,The length of the statement  "      if (this.ModifiedType != t.ModifiedType && (this.ModifiedType == null || !this.ModifiedType.IsStructurallyEquivalentTo(t.ModifiedType))) " is 136.
Long Statement,Microsoft.Cci,FunctionPointer,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,IsStructurallyEquivalentTo,The length of the statement  "      if (this.Flags != t.Flags || this.CallingConvention != t.CallingConvention || this.VarArgStart != t.VarArgStart) return false; " is 126.
Long Statement,Microsoft.Cci,Event,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetEventInfo,The length of the statement  "        if (this.IsPublic) flags |= System.Reflection.BindingFlags.Public; else flags |= System.Reflection.BindingFlags.NonPublic; " is 122.
Long Statement,Microsoft.Cci,Event,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetEventInfo,The length of the statement  "        if (this.IsStatic) flags |= System.Reflection.BindingFlags.Static; else flags |= System.Reflection.BindingFlags.Instance;  " is 121.
Long Statement,Microsoft.Cci,Method,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetDocumentationId,The length of the statement  "        if (TargetPlatform.GenericTypeNamesMangleChar != 0 && this.TemplateParameters != null && this.TemplateParameters.Count > 0) { " is 125.
Long Statement,Microsoft.Cci,Method,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetDocumentationId,The length of the statement  "        (this.Name.UniqueIdKey == StandardIds.opExplicit.UniqueIdKey || this.Name.UniqueIdKey == StandardIds.opImplicit.UniqueIdKey)){ " is 126.
Long Statement,Microsoft.Cci,Method,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetDynamicMethod,The length of the statement  "        if (this.DeclaringType == null || this.DeclaringType.DeclaringModule == null || !this.IsNormalized || this.Name == null || this.ReturnType == null){ " is 148.
Long Statement,Microsoft.Cci,Method,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetDynamicMethod,The length of the statement  "        if ((this.CallingConvention & CallingConventionFlags.ArgumentConvention) != CallingConventionFlags.StandardCall || this.IsGeneric){ " is 131.
Long Statement,Microsoft.Cci,Method,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetDynamicMethod,The length of the statement  "        callConv |= (System.Reflection.CallingConventions)(this.CallingConvention & ~CallingConventionFlags.ArgumentConvention); " is 120.
Long Statement,Microsoft.Cci,Method,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetMethodInfo,The length of the statement  "            pt = types[i] = typeof(object); //Have to cheat here since the type might involve a type parameter of the method and getting the runtime type for that is a problem " is 163.
Long Statement,Microsoft.Cci,Field,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetFieldInfo,The length of the statement  "        if (this.IsPublic) flags |= System.Reflection.BindingFlags.Public; else flags |= System.Reflection.BindingFlags.NonPublic; " is 122.
Long Statement,Microsoft.Cci,Field,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetFieldInfo,The length of the statement  "        if (this.IsStatic) flags |= System.Reflection.BindingFlags.Static; else flags |= System.Reflection.BindingFlags.Instance;  " is 121.
Long Statement,Microsoft.Cci,Specializer,C:\repos\Reactive-Extensions_IL2JS\CCI\Specializer.cs,VisitTypeNode,The length of the statement  "      if (savedCurrentType != null && savedCurrentType.TemplateArguments != null && savedCurrentType.TemplateArguments.Count > 0 && " is 125.
Long Statement,Microsoft.Cci,Specializer,C:\repos\Reactive-Extensions_IL2JS\CCI\Specializer.cs,VisitTypeNode,The length of the statement  "        typeNode.Template != null && (typeNode.Template.TemplateParameters == null || typeNode.Template.TemplateParameters.Count == 0)){ " is 128.
Long Statement,Microsoft.Cci,Specializer,C:\repos\Reactive-Extensions_IL2JS\CCI\Specializer.cs,VisitTypeNode,The length of the statement  "        typeNode.ProviderHandle = new SpecializerHandle(typeNode.ProvideNestedTypes' typeNode.ProvideTypeMembers' typeNode.ProviderHandle); " is 131.
Long Statement,Microsoft.Cci,Specializer,C:\repos\Reactive-Extensions_IL2JS\CCI\Specializer.cs,VisitTypeNode,The length of the statement  "          if (!delegateNode.IsNormalized){ //In the Normalized case Parameters are retrieved from the Invoke method' which means evaluating Members " is 137.
Long Statement,Microsoft.Cci,Specializer,C:\repos\Reactive-Extensions_IL2JS\CCI\Specializer.cs,VisitTypeReference,The length of the statement  "          return FunctionType.For(this.VisitTypeReference(ftype.ReturnType)' this.VisitParameterList(ftype.Parameters)' referringType);} " is 126.
Long Statement,Microsoft.Cci,Specializer,C:\repos\Reactive-Extensions_IL2JS\CCI\Specializer.cs,VisitTypeReference,The length of the statement  "          TypeNode referringType = tIntersect.DeclaringType == null ? this.CurrentType : this.VisitTypeReference(tIntersect.DeclaringType); " is 129.
Long Statement,Microsoft.Cci,Specializer,C:\repos\Reactive-Extensions_IL2JS\CCI\Specializer.cs,VisitTypeReference,The length of the statement  "          TypeNode referringType = tUnion.DeclaringType == null ? this.CurrentType : this.VisitTypeReference(tUnion.DeclaringType); " is 121.
Long Statement,Microsoft.Cci,Specializer,C:\repos\Reactive-Extensions_IL2JS\CCI\Specializer.cs,VisitTypeReference,The length of the statement  "          TypeNode referringType = conType.DeclaringType == null ? this.CurrentType : this.VisitTypeReference(conType.DeclaringType); " is 123.
Long Statement,Microsoft.Cci,Specializer,C:\repos\Reactive-Extensions_IL2JS\CCI\Specializer.cs,VisitTypeReference,The length of the statement  "                if (arguments != null && arguments.Count > 0 && nt.ConsolidatedTemplateParameters != null && nt.ConsolidatedTemplateParameters.Count > 0) " is 137.
Long Statement,Microsoft.Cci,Specializer,C:\repos\Reactive-Extensions_IL2JS\CCI\Specializer.cs,VisitTypeReference,The length of the statement  "          if (type.Template != null && (type.ConsolidatedTemplateParameters == null || type.ConsolidatedTemplateParameters.Count == 0)){ " is 126.
Long Statement,Microsoft.Cci,Specializer,C:\repos\Reactive-Extensions_IL2JS\CCI\Specializer.cs,VisitTypeReference,The length of the statement  "                      if (tparg == par || (tparg.ParameterListIndex == par.ParameterListIndex && tparg.DeclaringMember == par.DeclaringMember)) { " is 123.
Long Statement,Microsoft.Cci,Specializer,C:\repos\Reactive-Extensions_IL2JS\CCI\Specializer.cs,VisitTypeReference,The length of the statement  "              if (this.CurrentType.ReferencedTemplateInstances == null) this.CurrentType.ReferencedTemplateInstances = new TypeNodeList(); " is 124.
Long Statement,Microsoft.Cci,Specializer,C:\repos\Reactive-Extensions_IL2JS\CCI\Specializer.cs,VisitTypeReference,The length of the statement  "          TypeNode ti = type.GetTemplateInstance(this.TargetModule' this.CurrentType' this.VisitTypeReference(type.DeclaringType)' tArgs); " is 128.
Long Statement,Microsoft.Cci,Specializer,C:\repos\Reactive-Extensions_IL2JS\CCI\Specializer.cs,VisitTypeReference,The length of the statement  "            if (this.CurrentType.ReferencedTemplateInstances == null) this.CurrentType.ReferencedTemplateInstances = new TypeNodeList(); " is 124.
Long Statement,Microsoft.Cci,MethodBodySpecializer,C:\repos\Reactive-Extensions_IL2JS\CCI\Specializer.cs,VisitAssignmentStatement,The length of the statement  "          else if (!sType.IsValueType && !(sType == CoreSystemTypes.Object && source is Literal && target.NodeType == NodeType.AddressDereference)) " is 137.
Long Statement,Microsoft.Cci,MethodBodySpecializer,C:\repos\Reactive-Extensions_IL2JS\CCI\Specializer.cs,VisitAssignmentStatement,The length of the statement  "            assignment.Source = new AddressDereference(new BinaryExpression(source' new MemberBinding(null' sType)' NodeType.Unbox)' sType); " is 128.
Long Statement,Microsoft.Cci,MethodBodySpecializer,C:\repos\Reactive-Extensions_IL2JS\CCI\Specializer.cs,VisitMemberBinding,The length of the statement  "        //Need to take the address of the target object (this parameter)' or need to box it' if this target object type is value type " is 125.
Long Statement,Microsoft.Cci,MethodBodySpecializer,C:\repos\Reactive-Extensions_IL2JS\CCI\Specializer.cs,VisitMemberBinding,The length of the statement  "              memberBinding.TargetObject = new UnaryExpression(memberBinding.TargetObject' NodeType.AddressOf' memberBinding.TargetObject.Type.GetReferenceType()); " is 149.
Long Statement,Microsoft.Cci,MethodBodySpecializer,C:\repos\Reactive-Extensions_IL2JS\CCI\Specializer.cs,VisitMemberBinding,The length of the statement  "              memberBinding.TargetObject = new BinaryExpression(memberBinding.TargetObject' obType' NodeType.Box' method.DeclaringType); " is 122.
Long Statement,Microsoft.Cci,MethodBodySpecializer,C:\repos\Reactive-Extensions_IL2JS\CCI\Specializer.cs,VisitReturn,The length of the statement  "        Return.Expression = new BinaryExpression(rval' new MemberBinding(null' rval.Type)' NodeType.Box' this.CurrentMethod.ReturnType); " is 128.
Long Statement,Microsoft.Cci,SnippetParser,C:\repos\Reactive-Extensions_IL2JS\CCI\StandardVisitor.cs,VisitCompilationUnitSnippet,The length of the statement  "        p = this.DefaultParserFactory.CreateParser(fileName' lineNumber' sourceText' this.SymbolTable' this.ErrorNodes' this.Options); " is 126.
Long Statement,Microsoft.Cci,SnippetParser,C:\repos\Reactive-Extensions_IL2JS\CCI\StandardVisitor.cs,VisitExpressionSnippet,The length of the statement  "        p = this.DefaultParserFactory.CreateParser(fileName' lineNumber' sourceText' this.SymbolTable' this.ErrorNodes' this.Options); " is 126.
Long Statement,Microsoft.Cci,SnippetParser,C:\repos\Reactive-Extensions_IL2JS\CCI\StandardVisitor.cs,VisitStatementSnippet,The length of the statement  "        p = this.DefaultParserFactory.CreateParser(fileName' lineNumber' sourceText' this.SymbolTable' this.ErrorNodes' this.Options); " is 126.
Long Statement,Microsoft.Cci,SnippetParser,C:\repos\Reactive-Extensions_IL2JS\CCI\StandardVisitor.cs,VisitTypeMemberSnippet,The length of the statement  "        p = this.DefaultParserFactory.CreateParser(fileName' lineNumber' sourceText' this.SymbolTable' this.ErrorNodes' this.Options); " is 126.
Long Statement,Microsoft.Cci,TargetPlatform,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,SetTo,The length of the statement  "        else if (version.Minor == 1 && version.Build == 9999) TargetPlatform.SetToPostV1_1(TargetPlatform.PlatformAssembliesLocation); " is 126.
Long Statement,Microsoft.Cci,TargetPlatform,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,SetToV1,The length of the statement  "        platformAssembliesLocation = TargetPlatform.PlatformAssembliesLocation = Path.Combine(Path.GetDirectoryName(typeof(object).Module.Assembly.Location)' "..\\v1.0.3705"); " is 167.
Long Statement,Microsoft.Cci,TargetPlatform,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,SetToV1_1,The length of the statement  "        platformAssembliesLocation = TargetPlatform.PlatformAssembliesLocation = Path.Combine(Path.GetDirectoryName(typeof(object).Module.Assembly.Location)' "..\\v1.1.4322"); " is 167.
Long Statement,Microsoft.Cci,TargetPlatform,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,SetToV2,The length of the statement  "        platformAssembliesLocation = TargetPlatform.PlatformAssembliesLocation = Path.Combine(Path.GetDirectoryName(typeof(object).Module.Assembly.Location)' "..\\v2.0.50727"); " is 168.
Long Statement,Microsoft.Cci,TargetPlatform,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,SetToV2Beta1,The length of the statement  "        if (dotNetDirLocation != null) dotNetDirLocation = dotNetDirLocation.ToUpper(System.Globalization.CultureInfo.InvariantCulture); " is 128.
Long Statement,Microsoft.Cci,TargetPlatform,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,SetToV2Beta1,The length of the statement  "        AssemblyReference aref = new AssemblyReference(name + "' Version=" + version + "' Culture=neutral' PublicKeyToken=" + token); " is 125.
Long Statement,Microsoft.Cci,CoreSystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,Clear,The length of the statement  "        //Dispose the system assemblies in case they were not in the static cache. It is safe to dispose an assembly more than once. " is 124.
Long Statement,Microsoft.Cci,CoreSystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InstantiateGenericInterfaces,The length of the statement  "      if (TargetPlatform.TargetVersion != null && (TargetPlatform.TargetVersion.Major < 2 && TargetPlatform.TargetVersion.Minor < 2)) return; " is 135.
Long Statement,Microsoft.Cci,CoreSystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InstantiateGenericInterfaces,The length of the statement  "        interfaces[i] = (Interface)ifaceExpr.Template.GetGenericTemplateInstance(type.DeclaringModule' ifaceExpr.ConsolidatedTemplateArguments); " is 136.
Long Statement,Microsoft.Cci,CoreSystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,GetSystemAssembly,The length of the statement  "      result = (AssemblyNode)(new Reader(SystemAssemblyLocation.Location' SystemAssemblyLocation.SystemAssemblyCache' doNotLockFile' getDebugInfo' true' false)).ReadModule(); " is 168.
Long Statement,Microsoft.Cci,CoreSystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,GetSystemAssembly,The length of the statement  "      if (result == null && TargetPlatform.TargetVersion != null && TargetPlatform.TargetVersion == typeof(object).Module.Assembly.GetName().Version){ " is 144.
Long Statement,Microsoft.Cci,CoreSystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,GetSystemAssembly,The length of the statement  "        result = (AssemblyNode)(new Reader(SystemAssemblyLocation.Location' SystemAssemblyLocation.SystemAssemblyCache' doNotLockFile' getDebugInfo' true' false)).ReadModule(); " is 168.
Long Statement,Microsoft.Cci,CoreSystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,GetDummyTypeNode,The length of the statement  "          else if (name.EndsWith("Callback") || name.EndsWith("Delegate") || name == "ThreadStart" || name == "FrameGuardGetter" || name == "GuardThreadStart") " is 149.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,Clear,The length of the statement  "        if (SystemTypes.SystemCompilerRuntimeAssembly != null && SystemTypes.SystemCompilerRuntimeAssembly != AssemblyNode.Dummy) { " is 123.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      InternalsVisibleToAttribute = (Class)GetTypeNodeFor("System.Runtime.CompilerServices"' "InternalsVisibleToAttribute"' ElementType.Class); " is 137.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      GenericICollection = (Interface)GetGenericRuntimeTypeNodeFor("System.Collections.Generic"' "ICollection"' 1' ElementType.Class); " is 128.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      GenericIEnumerable = (Interface)GetGenericRuntimeTypeNodeFor("System.Collections.Generic"' "IEnumerable"' 1' ElementType.Class); " is 128.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      AllowPartiallyTrustedCallersAttribute = (Class)GetTypeNodeFor("System.Security"' "AllowPartiallyTrustedCallersAttribute"' ElementType.Class); " is 141.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      AssemblyConfigurationAttribute = (Class)GetTypeNodeFor("System.Reflection"' "AssemblyConfigurationAttribute"' ElementType.Class); " is 129.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      AssemblyCopyrightAttribute = (Class)GetTypeNodeFor("System.Reflection"' "AssemblyCopyrightAttribute"' ElementType.Class); " is 121.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      AssemblyDelaySignAttribute = (Class)GetTypeNodeFor("System.Reflection"' "AssemblyDelaySignAttribute"' ElementType.Class); " is 121.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      AssemblyDescriptionAttribute = (Class)GetTypeNodeFor("System.Reflection"' "AssemblyDescriptionAttribute"' ElementType.Class); " is 125.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      AssemblyFileVersionAttribute = (Class)GetTypeNodeFor("System.Reflection"' "AssemblyFileVersionAttribute"' ElementType.Class); " is 125.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      AssemblyInformationalVersionAttribute = (Class)GetTypeNodeFor("System.Reflection"' "AssemblyInformationalVersionAttribute"' ElementType.Class); " is 143.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      AssemblyTrademarkAttribute = (Class)GetTypeNodeFor("System.Reflection"' "AssemblyTrademarkAttribute"' ElementType.Class); " is 121.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      ClassInterfaceAttribute = (Class)GetTypeNodeFor("System.Runtime.InteropServices"' "ClassInterfaceAttribute"' ElementType.Class); " is 128.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      ComRegisterFunctionAttribute = (Class)GetTypeNodeFor("System.Runtime.InteropServices"' "ComRegisterFunctionAttribute"' ElementType.Class); " is 138.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      ComSourceInterfacesAttribute = (Class)GetTypeNodeFor("System.Runtime.InteropServices"' "ComSourceInterfacesAttribute"' ElementType.Class); " is 138.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      ComUnregisterFunctionAttribute = (Class)GetTypeNodeFor("System.Runtime.InteropServices"' "ComUnregisterFunctionAttribute"' ElementType.Class); " is 142.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      ComVisibleAttribute = (Class)GetTypeNodeFor("System.Runtime.InteropServices"' "ComVisibleAttribute"' ElementType.Class);       " is 120.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      DebuggerStepThroughAttribute = (Class)GetTypeNodeFor("System.Diagnostics"' "DebuggerStepThroughAttribute"' ElementType.Class); " is 126.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      DebuggingModes = DebuggableAttribute == null ? null : DebuggableAttribute.GetNestedType(Identifier.For("DebuggingModes")) as EnumNode; " is 134.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      FieldOffsetAttribute = (Class)GetTypeNodeFor("System.Runtime.InteropServices"' "FieldOffsetAttribute"' ElementType.Class); " is 122.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      ImportedFromTypeLibAttribute = (Class)GetTypeNodeFor("System.Runtime.InteropServices"' "ImportedFromTypeLibAttribute"' ElementType.Class); " is 138.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      IndexerNameAttribute = (Class)GetTypeNodeFor("System.Runtime.CompilerServices"' "IndexerNameAttribute"' ElementType.Class); " is 123.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      InterfaceTypeAttribute = (Class)GetTypeNodeFor("System.Runtime.InteropServices"' "InterfaceTypeAttribute"' ElementType.Class); " is 126.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      MethodImplAttribute = (Class)GetTypeNodeFor("System.Runtime.CompilerServices"' "MethodImplAttribute"' ElementType.Class); " is 121.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      RuntimeCompatibilityAttribute = (Class)GetTypeNodeFor("System.Runtime.CompilerServices"' "RuntimeCompatibilityAttribute"' ElementType.Class); " is 141.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      SatelliteContractVersionAttribute = (Class)GetTypeNodeFor("System.Resources"' "SatelliteContractVersionAttribute"' ElementType.Class); " is 134.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      SecurityTransparentAttribute = (Class)GetTypeNodeFor("System.Security"' "SecurityTransparentAttribute"' ElementType.Class); " is 123.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      SecurityTreatAsSafeAttribute = (Class)GetTypeNodeFor("System.Security"' "SecurityTreatAsSafeAttribute"' ElementType.Class); " is 123.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      StructLayoutAttribute = (Class)GetTypeNodeFor("System.Runtime.InteropServices"' "StructLayoutAttribute"' ElementType.Class); " is 124.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      SuppressMessageAttribute = (Class)GetTypeNodeFor("System.Diagnostics.CodeAnalysis"' "SuppressMessageAttribute"' ElementType.Class);      " is 131.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      SuppressUnmanagedCodeSecurityAttribute = (Class)GetTypeNodeFor("System.Security"' "SuppressUnmanagedCodeSecurityAttribute"' ElementType.Class); " is 143.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      GenericDictionary = (Class)GetGenericRuntimeTypeNodeFor("System.Collections.Generic"' "Dictionary"' 2' ElementType.Class); " is 122.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      GenericIComparable = (Interface)GetGenericRuntimeTypeNodeFor("System.Collections.Generic"' "IComparable"' 1' ElementType.Class); " is 128.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      GenericIComparer = (Interface)GetGenericRuntimeTypeNodeFor("System.Collections.Generic"' "IComparer"' 1' ElementType.Class); " is 124.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      GenericIDictionary = (Interface)GetGenericRuntimeTypeNodeFor("System.Collections.Generic"' "IDictionary"' 2' ElementType.Class); " is 128.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      GenericIEnumerator = (Interface)GetGenericRuntimeTypeNodeFor("System.Collections.Generic"' "IEnumerator"' 1' ElementType.Class); " is 128.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      GenericKeyValuePair = (Struct)GetGenericRuntimeTypeNodeFor("System.Collections.Generic"' "KeyValuePair"' 2' ElementType.ValueType); " is 131.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      GenericSortedDictionary = (Class)GetGenericRuntimeTypeNodeFor("System.Collections.Generic"' "SortedDictionary"' 2' ElementType.Class); " is 134.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      WindowsImpersonationContext = (Class)GetTypeNodeFor("System.Security.Principal"' "WindowsImpersonationContext"' ElementType.Class); " is 131.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      XmlAttributeAttributeClass = (Class)GetXmlTypeNodeFor("System.Xml.Serialization"' "XmlAttributeAttribute"' ElementType.Class); " is 126.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      XmlChoiceIdentifierAttributeClass = (Class)GetXmlTypeNodeFor("System.Xml.Serialization"' "XmlChoiceIdentifierAttribute"' ElementType.Class); " is 140.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      XmlElementAttributeClass = (Class)GetXmlTypeNodeFor("System.Xml.Serialization"' "XmlElementAttribute"' ElementType.Class); " is 122.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      XmlIgnoreAttributeClass = (Class)GetXmlTypeNodeFor("System.Xml.Serialization"' "XmlIgnoreAttribute"' ElementType.Class); " is 120.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      TemplateInstanceAttribute = (Class)GetCompilerRuntimeTypeNodeFor(CciNs' "TemplateInstanceAttribute"' ElementType.Class); " is 120.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      UnmanagedStructTemplateParameterAttribute = (Class)GetCompilerRuntimeTypeNodeFor(CciNs' "UnmanagedStructTemplateParameterAttribute"' ElementType.Class); " is 152.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      PointerFreeStructTemplateParameterAttribute = (Class)GetCompilerRuntimeTypeNodeFor(CciNs' "PointerFreeStructTemplateParameterAttribute"' ElementType.Class); " is 156.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      TemplateParameterFlagsAttribute = (Class)GetCompilerRuntimeTypeNodeFor(CciNs' "TemplateParameterFlagsAttribute"' ElementType.Class); " is 132.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      GenericArrayToIEnumerableAdapter = (Class)GetCompilerRuntimeTypeNodeFor("StructuralTypes"' "ArrayToIEnumerableAdapter"' 1' ElementType.Class); " is 142.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      GenericIEnumerableToGenericIListAdapter = (Class)GetCompilerRuntimeTypeNodeFor("StructuralTypes"' "GenericIEnumerableToGenericIListAdapter"' 1' ElementType.Class); " is 163.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      GenericNonEmptyIEnumerable = (Struct)GetCompilerRuntimeTypeNodeFor("StructuralTypes"' "NonEmptyIEnumerable"' 1' ElementType.ValueType); " is 135.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      StreamNotSingletonException = (Class)GetCompilerRuntimeTypeNodeFor("System.Query"' "StreamNotSingletonException"' ElementType.Class); " is 133.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      IllegalUpcastException = (Class)GetCompilerRuntimeTypeNodeFor(ContractsNs' "IllegalUpcastException"' ElementType.Class); " is 120.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      InitGuardSetsDelegate = (DelegateNode) GetCompilerRuntimeTypeNodeFor(GuardsNs' "InitGuardSetsDelegate"' ElementType.Class); " is 123.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      CheckInvariantDelegate = (DelegateNode) GetCompilerRuntimeTypeNodeFor(GuardsNs' "CheckInvariantDelegate"' ElementType.Class); " is 125.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      ObjectInvariantException = (Class)GetCompilerRuntimeTypeNodeFor("Microsoft.Contracts"' "ObjectInvariantException"' ElementType.Class); " is 134.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      ThreadConditionDelegate = (DelegateNode) GetCompilerRuntimeTypeNodeFor(GuardsNs' "ThreadConditionDelegate"' ElementType.Class); " is 127.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      InvalidContractException = (Class)GetCompilerRuntimeTypeNodeFor(ContractsNs' "InvalidContractException"' ElementType.Class); " is 124.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      ContractMarkerException = (Class)GetCompilerRuntimeTypeNodeFor(ContractsNs' "ContractMarkerException"' ElementType.Class); " is 122.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      PreAllocatedExceptions = (Class)GetCompilerRuntimeTypeNodeFor(ContractsNs' "PreAllocatedExceptions"' ElementType.Class); " is 120.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      ModelfieldContractAttribute = (Class)GetCompilerRuntimeTypeNodeFor(ContractsNs' "ModelfieldContractAttribute"' ElementType.Class); " is 130.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      ModelfieldException = (Class)GetCompilerRuntimeTypeNodeFor("Microsoft.Contracts"' "ModelfieldException"' ElementType.Class); " is 124.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "        WriteConfinedAttribute = (Class)GetCompilerRuntimeTypeNodeFor(CompilerGuardsNs' "WriteConfinedAttribute"' ElementType.Class); " is 125.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "        GlobalWriteAttribute = (Class)GetCompilerRuntimeTypeNodeFor(CompilerGuardsNs' "GlobalWriteAttribute"' ElementType.Class); " is 121.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "        GlobalAccessAttribute = (Class)GetCompilerRuntimeTypeNodeFor(CompilerGuardsNs' "GlobalAccessAttribute"' ElementType.Class); " is 123.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      StateIndependentAttribute = (Class)GetCompilerRuntimeTypeNodeFor(ContractsNs' "StateIndependentAttribute"' ElementType.Class); " is 126.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      SpecProtectedAttribute = (Class)GetCompilerRuntimeTypeNodeFor(ContractsNs' "SpecProtectedAttribute"' ElementType.Class); " is 120.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      LockProtectedAttribute = (Class)GetCompilerRuntimeTypeNodeFor(CompilerGuardsNs' "LockProtectedAttribute"' ElementType.Class); " is 125.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      RequiresLockProtectedAttribute = (Class)GetCompilerRuntimeTypeNodeFor(CompilerGuardsNs' "RequiresLockProtectedAttribute"' ElementType.Class); " is 141.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      RequiresImmutableAttribute = (Class)GetCompilerRuntimeTypeNodeFor(CompilerGuardsNs' "RequiresImmutableAttribute"' ElementType.Class); " is 133.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      RequiresCanWriteAttribute = (Class)GetCompilerRuntimeTypeNodeFor(CompilerGuardsNs' "RequiresCanWriteAttribute"' ElementType.Class); " is 131.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      InferredReturnValueAttribute = (Class)GetCompilerRuntimeTypeNodeFor(ContractsNs' "InferredReturnValueAttribute"' ElementType.Class); " is 132.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      NoDefaultContractAttribute = (Class)GetCompilerRuntimeTypeNodeFor(CompilerGuardsNs' "NoDefaultContractAttribute"' ElementType.Class); " is 133.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      ShadowsAssemblyAttribute = (Class)GetCompilerRuntimeTypeNodeFor(ContractsNs' "ShadowsAssemblyAttribute"' ElementType.Class); " is 124.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      ElementCollectionAttribute = (Class)GetCompilerRuntimeTypeNodeFor(ContractsNs' "ElementCollectionAttribute"' ElementType.Class); " is 128.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      RecursionTerminationAttribute = (Class)GetCompilerRuntimeTypeNodeFor(ContractsNs' "RecursionTerminationAttribute"' ElementType.Class); " is 134.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      NoReferenceComparisonAttribute = (Class)GetCompilerRuntimeTypeNodeFor(ContractsNs' "NoReferenceComparisonAttribute"' ElementType.Class); " is 136.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The length of the statement  "      ResultNotNewlyAllocatedAttribute = (Class)GetCompilerRuntimeTypeNodeFor(ContractsNs' "ResultNotNewlyAllocatedAttribute"' ElementType.Class); " is 140.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,GetGenericRuntimeTypeNodeFor,The length of the statement  "      if (TargetPlatform.GenericTypeNamesMangleChar != 0) name = name + TargetPlatform.GenericTypeNamesMangleChar + numParams; " is 120.
Long Statement,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,GetGenericRuntimeTypeNodeFor,The length of the statement  "      if (TargetPlatform.TargetVersion != null && TargetPlatform.TargetVersion.Major == 1 && TargetPlatform.TargetVersion.Minor < 2) " is 126.
Long Statement,Microsoft.Cci,Unstacker,C:\repos\Reactive-Extensions_IL2JS\CCI\Unstacker.cs,VisitBinaryExpression,The length of the statement  "      if (binaryExpression.Type == null) binaryExpression.Type = binaryExpression.Operand1.Type; //Hack: need proper inferencing " is 122.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitAddressDereference((AddressDereference)node' changes as AddressDereference' deletions as AddressDereference' insertions as AddressDereference); " is 160.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitAliasDefinition((AliasDefinition)node' changes as AliasDefinition' deletions as AliasDefinition' insertions as AliasDefinition); " is 145.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitAnonymousNestedFunction((AnonymousNestedFunction)node' changes as AnonymousNestedFunction' deletions as AnonymousNestedFunction' insertions as AnonymousNestedFunction); " is 185.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitApplyToAll((ApplyToAll)node' changes as ApplyToAll' deletions as ApplyToAll' insertions as ApplyToAll); " is 120.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitExpression((Expression)node' changes as Expression' deletions as Expression' insertions as Expression); " is 120.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitAssembly((AssemblyNode)node' changes as AssemblyNode' deletions as AssemblyNode' insertions as AssemblyNode); " is 126.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitAssemblyReference((AssemblyReference)node' changes as AssemblyReference' deletions as AssemblyReference' insertions as AssemblyReference); " is 155.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitAssignmentExpression((AssignmentExpression)node' changes as AssignmentExpression' deletions as AssignmentExpression' insertions as AssignmentExpression); " is 170.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitAssignmentStatement((AssignmentStatement)node' changes as AssignmentStatement' deletions as AssignmentStatement' insertions as AssignmentStatement); " is 165.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitAttributeNode((AttributeNode)node' changes as AttributeNode' deletions as AttributeNode' insertions as AttributeNode); " is 135.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitBlockExpression((BlockExpression)node' changes as BlockExpression' deletions as BlockExpression' insertions as BlockExpression); " is 145.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitCompilation((Compilation)node' changes as Compilation' deletions as Compilation' insertions as Compilation); " is 125.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitCompilationUnit((CompilationUnit)node' changes as CompilationUnit' deletions as CompilationUnit' insertions as CompilationUnit); " is 145.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitCompilationUnitSnippet((CompilationUnitSnippet)node' changes as CompilationUnitSnippet' deletions as CompilationUnitSnippet' insertions as CompilationUnitSnippet); " is 180.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitConstrainedType((ConstrainedType)node' changes as ConstrainedType' deletions as ConstrainedType' insertions as ConstrainedType); " is 145.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitCurrentClosure((CurrentClosure)node' changes as CurrentClosure' deletions as CurrentClosure' insertions as CurrentClosure); " is 140.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitMethodCall((MethodCall)node' changes as MethodCall' deletions as MethodCall' insertions as MethodCall); " is 120.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitCoerceTuple((CoerceTuple)node' changes as CoerceTuple' deletions as CoerceTuple' insertions as CoerceTuple); " is 125.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitCollectionEnumerator((CollectionEnumerator)node' changes as CollectionEnumerator' deletions as CollectionEnumerator' insertions as CollectionEnumerator); " is 170.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitComposition((Composition)node' changes as Composition' deletions as Composition' insertions as Composition); " is 125.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitConstructArray((ConstructArray)node' changes as ConstructArray' deletions as ConstructArray' insertions as ConstructArray); " is 140.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitConstructDelegate((ConstructDelegate)node' changes as ConstructDelegate' deletions as ConstructDelegate' insertions as ConstructDelegate); " is 155.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitConstructFlexArray((ConstructFlexArray)node' changes as ConstructFlexArray' deletions as ConstructFlexArray' insertions as ConstructFlexArray); " is 160.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitConstructIterator((ConstructIterator)node' changes as ConstructIterator' deletions as ConstructIterator' insertions as ConstructIterator); " is 155.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitConstructTuple((ConstructTuple)node' changes as ConstructTuple' deletions as ConstructTuple' insertions as ConstructTuple); " is 140.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitDelegateNode((DelegateNode)node' changes as DelegateNode' deletions as DelegateNode' insertions as DelegateNode); " is 130.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitExpression((Expression)node' changes as Expression' deletions as Expression' insertions as Expression); " is 120.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitEndFinally((EndFinally)node' changes as EndFinally' deletions as EndFinally' insertions as EndFinally); " is 120.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitExpressionSnippet((ExpressionSnippet)node' changes as ExpressionSnippet' deletions as ExpressionSnippet' insertions as ExpressionSnippet); " is 155.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitExpressionStatement((ExpressionStatement)node' changes as ExpressionStatement' deletions as ExpressionStatement' insertions as ExpressionStatement); " is 165.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitFaultHandler((FaultHandler)node' changes as FaultHandler' deletions as FaultHandler' insertions as FaultHandler); " is 130.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitFieldInitializerBlock((FieldInitializerBlock)node' changes as FieldInitializerBlock' deletions as FieldInitializerBlock' insertions as FieldInitializerBlock); " is 175.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitFunctionDeclaration((FunctionDeclaration)node' changes as FunctionDeclaration' deletions as FunctionDeclaration' insertions as FunctionDeclaration); " is 165.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitIdentifier((Identifier)node' changes as Identifier' deletions as Identifier' insertions as Identifier); " is 120.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitImplicitThis((ImplicitThis)node' changes as ImplicitThis' deletions as ImplicitThis' insertions as ImplicitThis); " is 130.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitInstanceInitializer((InstanceInitializer)node' changes as InstanceInitializer' deletions as InstanceInitializer' insertions as InstanceInitializer); " is 165.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitStaticInitializer((StaticInitializer)node' changes as StaticInitializer' deletions as StaticInitializer' insertions as StaticInitializer); " is 155.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitLabeledStatement((LabeledStatement)node' changes as LabeledStatement' deletions as LabeledStatement' insertions as LabeledStatement); " is 150.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitLocalDeclaration((LocalDeclaration)node' changes as LocalDeclaration' deletions as LocalDeclaration' insertions as LocalDeclaration); " is 150.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitLocalDeclarationsStatement((LocalDeclarationsStatement)node' changes as LocalDeclarationsStatement' deletions as LocalDeclarationsStatement' insertions as LocalDeclarationsStatement); " is 200.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitLRExpression((LRExpression)node' changes as LRExpression' deletions as LRExpression' insertions as LRExpression); " is 130.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitMemberBinding((MemberBinding)node' changes as MemberBinding' deletions as MemberBinding' insertions as MemberBinding); " is 135.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitTemplateInstance((TemplateInstance)node' changes as TemplateInstance' deletions as TemplateInstance' insertions as TemplateInstance); " is 150.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitStackAlloc((StackAlloc)node' changes as StackAlloc' deletions as StackAlloc' insertions as StackAlloc); " is 120.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitModuleReference((ModuleReference)node' changes as ModuleReference' deletions as ModuleReference' insertions as ModuleReference); " is 145.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitNameBinding((NameBinding)node' changes as NameBinding' deletions as NameBinding' insertions as NameBinding); " is 125.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitNamedArgument((NamedArgument)node' changes as NamedArgument' deletions as NamedArgument' insertions as NamedArgument); " is 135.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitTypeModifier((TypeModifier)node' changes as TypeModifier' deletions as TypeModifier' insertions as TypeModifier); " is 130.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitExpression((Expression)node' changes as Expression' deletions as Expression' insertions as Expression); " is 120.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitPrefixExpression((PrefixExpression)node' changes as PrefixExpression' deletions as PrefixExpression' insertions as PrefixExpression); " is 150.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitPostfixExpression((PostfixExpression)node' changes as PostfixExpression' deletions as PostfixExpression' insertions as PostfixExpression); " is 155.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQualifiedIdentifier((QualifiedIdentifier)node' changes as QualifiedIdentifier' deletions as QualifiedIdentifier' insertions as QualifiedIdentifier); " is 165.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitResourceUse((ResourceUse)node' changes as ResourceUse' deletions as ResourceUse' insertions as ResourceUse); " is 125.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitSecurityAttribute((SecurityAttribute)node' changes as SecurityAttribute' deletions as SecurityAttribute' insertions as SecurityAttribute); " is 155.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitSetterValue((SetterValue)node' changes as SetterValue' deletions as SetterValue' insertions as SetterValue); " is 125.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitStatementSnippet((StatementSnippet)node' changes as StatementSnippet' deletions as StatementSnippet' insertions as StatementSnippet); " is 150.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitSwitchCase((SwitchCase)node' changes as SwitchCase' deletions as SwitchCase' insertions as SwitchCase); " is 120.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitSwitchInstruction((SwitchInstruction)node' changes as SwitchInstruction' deletions as SwitchInstruction' insertions as SwitchInstruction); " is 155.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitTypeswitch((Typeswitch)node' changes as Typeswitch' deletions as Typeswitch' insertions as Typeswitch); " is 120.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitTypeswitchCase((TypeswitchCase)node' changes as TypeswitchCase' deletions as TypeswitchCase' insertions as TypeswitchCase); " is 140.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitTypeIntersection((TypeIntersection)node' changes as TypeIntersection' deletions as TypeIntersection' insertions as TypeIntersection); " is 150.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitTypeMemberSnippet((TypeMemberSnippet)node' changes as TypeMemberSnippet' deletions as TypeMemberSnippet' insertions as TypeMemberSnippet); " is 155.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitTypeReference((TypeReference)node' changes as TypeReference' deletions as TypeReference' insertions as TypeReference); " is 135.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitUsedNamespace((UsedNamespace)node' changes as UsedNamespace' deletions as UsedNamespace' insertions as UsedNamespace); " is 135.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitVariableDeclaration((VariableDeclaration)node' changes as VariableDeclaration' deletions as VariableDeclaration' insertions as VariableDeclaration); " is 165.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitTernaryExpression((TernaryExpression)node' changes as TernaryExpression' deletions as TernaryExpression' insertions as TernaryExpression); " is 155.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitBinaryExpression((BinaryExpression)node' changes as BinaryExpression' deletions as BinaryExpression' insertions as BinaryExpression); " is 150.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitUnaryExpression((UnaryExpression)node' changes as UnaryExpression' deletions as UnaryExpression' insertions as UnaryExpression); " is 145.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryAggregate((QueryAggregate)node' changes as QueryAggregate' deletions as QueryAggregate' insertions as QueryAggregate); " is 140.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryAlias((QueryAlias)node' changes as QueryAlias' deletions as QueryAlias' insertions as QueryAlias); " is 120.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryQuantifier((QueryQuantifier)node' changes as QueryQuantifier' deletions as QueryQuantifier' insertions as QueryQuantifier); " is 145.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryCommit((QueryCommit)node' changes as QueryCommit' deletions as QueryCommit' insertions as QueryCommit); " is 125.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryContext((QueryContext)node' changes as QueryContext' deletions as QueryContext' insertions as QueryContext); " is 130.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryDelete((QueryDelete)node' changes as QueryDelete' deletions as QueryDelete' insertions as QueryDelete); " is 125.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryDifference((QueryDifference)node' changes as QueryDifference' deletions as QueryDifference' insertions as QueryDifference); " is 145.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryDistinct((QueryDistinct)node' changes as QueryDistinct' deletions as QueryDistinct' insertions as QueryDistinct); " is 135.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryExists((QueryExists)node' changes as QueryExists' deletions as QueryExists' insertions as QueryExists); " is 125.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryFilter((QueryFilter)node' changes as QueryFilter' deletions as QueryFilter' insertions as QueryFilter); " is 125.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryGeneratedType((QueryGeneratedType)node' changes as QueryGeneratedType' deletions as QueryGeneratedType' insertions as QueryGeneratedType); " is 160.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryGroupBy((QueryGroupBy)node' changes as QueryGroupBy' deletions as QueryGroupBy' insertions as QueryGroupBy); " is 130.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryInsert((QueryInsert)node' changes as QueryInsert' deletions as QueryInsert' insertions as QueryInsert); " is 125.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryIntersection((QueryIntersection)node' changes as QueryIntersection' deletions as QueryIntersection' insertions as QueryIntersection); " is 155.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryIterator((QueryIterator)node' changes as QueryIterator' deletions as QueryIterator' insertions as QueryIterator); " is 135.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryLimit((QueryLimit)node' changes as QueryLimit' deletions as QueryLimit' insertions as QueryLimit); " is 120.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryOrderBy((QueryOrderBy)node' changes as QueryOrderBy' deletions as QueryOrderBy' insertions as QueryOrderBy); " is 130.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryOrderItem((QueryOrderItem)node' changes as QueryOrderItem' deletions as QueryOrderItem' insertions as QueryOrderItem); " is 140.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryPosition((QueryPosition)node' changes as QueryPosition' deletions as QueryPosition' insertions as QueryPosition); " is 135.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryProject((QueryProject)node' changes as QueryProject' deletions as QueryProject' insertions as QueryProject);           " is 130.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryQuantifiedExpression((QueryQuantifiedExpression)node' changes as QueryQuantifiedExpression' deletions as QueryQuantifiedExpression' insertions as QueryQuantifiedExpression); " is 195.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryRollback((QueryRollback)node' changes as QueryRollback' deletions as QueryRollback' insertions as QueryRollback); " is 135.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQuerySelect((QuerySelect)node' changes as QuerySelect' deletions as QuerySelect' insertions as QuerySelect); " is 125.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQuerySingleton((QuerySingleton)node' changes as QuerySingleton' deletions as QuerySingleton' insertions as QuerySingleton); " is 140.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryTransact((QueryTransact)node' changes as QueryTransact' deletions as QueryTransact' insertions as QueryTransact); " is 135.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryTypeFilter((QueryTypeFilter)node' changes as QueryTypeFilter' deletions as QueryTypeFilter' insertions as QueryTypeFilter); " is 145.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryUnion((QueryUnion)node' changes as QueryUnion' deletions as QueryUnion' insertions as QueryUnion); " is 120.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryUpdate((QueryUpdate)node' changes as QueryUpdate' deletions as QueryUpdate' insertions as QueryUpdate); " is 125.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,Visit,The length of the statement  "          return this.VisitQueryYielder((QueryYielder)node' changes as QueryYielder' deletions as QueryYielder' insertions as QueryYielder); " is 130.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,UpdateSourceContext,The length of the statement  "//            node.SourceContext.Document.Update(node.SourceContext.StartPos' node.SourceContext.EndPos-node.SourceContext.StartPos' ""); " is 137.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,UpdateSourceContext,The length of the statement  "//            node.SourceContext.Document.Update(node.SourceContext.StartPos' node.SourceContext.EndPos-node.SourceContext.StartPos'  " is 132.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,UpdateSourceContext,The length of the statement  "//        //Remove the length of the node from the delta. If the node is being deleted' all subsequent nodes will now shift up. " is 127.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,VisitAliasDefinition,The length of the statement  "          aliasDefinition.AliasedType = this.VisitTypeReference(aliasDefinition.AliasedType' changes.AliasedType' deletions.AliasedType' insertions.AliasedType); " is 151.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,VisitAnonymousNestedFunction,The length of the statement  "          func.Parameters = this.VisitParameterList(func.Parameters' changes.Parameters' deletions.Parameters' insertions.Parameters); " is 124.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,VisitApplyToAll,The length of the statement  "          applyToAll.Operand1 = this.VisitExpression(applyToAll.Operand1' changes.Operand1' deletions.Operand1' insertions.Operand1); " is 123.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,VisitApplyToAll,The length of the statement  "          applyToAll.Operand2 = this.VisitExpression(applyToAll.Operand2' changes.Operand2' deletions.Operand2' insertions.Operand2); " is 123.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,VisitAssembly,The length of the statement  "          assembly.AssemblyReferences = this.VisitAssemblyReferenceList(assembly.AssemblyReferences' changes.AssemblyReferences' deletions.AssemblyReferences' insertions.AssemblyReferences); " is 180.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,VisitAssembly,The length of the statement  "          assembly.Attributes = this.VisitAttributeList(assembly.Attributes' changes.Attributes' deletions.Attributes' insertions.Attributes); " is 132.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,VisitAssembly,The length of the statement  "          assembly.ExportedTypes = this.VisitTypeReferenceList(assembly.ExportedTypes' changes.ExportedTypes' deletions.ExportedTypes' insertions.ExportedTypes); " is 151.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,VisitAssembly,The length of the statement  "          assembly.ModuleAttributes = this.VisitAttributeList(assembly.ModuleAttributes' changes.ModuleAttributes' deletions.ModuleAttributes' insertions.ModuleAttributes); " is 162.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,VisitAssembly,The length of the statement  "          assembly.ModuleReferences = this.VisitModuleReferenceList(assembly.ModuleReferences' changes.ModuleReferences' deletions.ModuleReferences' insertions.ModuleReferences); " is 168.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,VisitAssembly,The length of the statement  "          assembly.SecurityAttributes = this.VisitSecurityAttributeList(assembly.SecurityAttributes' changes.SecurityAttributes' deletions.SecurityAttributes' insertions.SecurityAttributes); " is 180.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,VisitAssertion,The length of the statement  "          assertion.Condition = this.VisitExpression(assertion.Condition' changes.Condition' deletions.Condition' insertions.Condition); " is 126.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,VisitAssignmentExpression,The length of the statement  "          assignment.AssignmentStatement = this.VisitAssignmentStatement(assignment.AssignmentStatement as AssignmentStatement' changes.AssignmentStatement as AssignmentStatement' deletions.AssignmentStatement as AssignmentStatement' insertions.AssignmentStatement as AssignmentStatement); " is 279.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,VisitAttributeNode,The length of the statement  "          attribute.Constructor = this.VisitExpression(attribute.Constructor' changes.Constructor' deletions.Constructor' insertions.Constructor); " is 136.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,VisitAttributeNode,The length of the statement  "          attribute.Expressions = this.VisitExpressionList(attribute.Expressions' changes.Expressions' deletions.Expressions' insertions.Expressions); " is 140.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,VisitBinaryExpression,The length of the statement  "          binaryExpression.Operand1 = this.VisitExpression(binaryExpression.Operand1' changes.Operand1' deletions.Operand1' insertions.Operand1); " is 135.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,VisitBinaryExpression,The length of the statement  "          binaryExpression.Operand2 = this.VisitExpression(binaryExpression.Operand2' changes.Operand2' deletions.Operand2' insertions.Operand2); " is 135.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,VisitBlock,The length of the statement  "          block.Statements = this.VisitStatementList(block.Statements' changes.Statements' deletions.Statements' insertions.Statements); " is 126.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,VisitCoerceTuple,The length of the statement  "          coerceTuple.OriginalTuple = this.VisitExpression(coerceTuple.OriginalTuple' changes.OriginalTuple' deletions.OriginalTuple' insertions.OriginalTuple); " is 150.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,VisitCompilation,The length of the statement  "          compilation.CompilationUnits = this.VisitCompilationUnitList(compilation.CompilationUnits' changes.CompilationUnits' deletions.CompilationUnits' insertions.CompilationUnits); " is 174.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,VisitComposition,The length of the statement  "          comp.Expression = this.VisitExpression(comp.Expression' changes.Expression' deletions.Expression' insertions.Expression); " is 121.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,VisitConstruct,The length of the statement  "          cons.Constructor = this.VisitExpression(cons.Constructor' changes.Constructor' deletions.Constructor' insertions.Constructor);  " is 126.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,VisitConstructArray,The length of the statement  "          consArr.Initializers = this.VisitExpressionList(consArr.Initializers' changes.Initializers' deletions.Initializers' insertions.Initializers); " is 141.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,VisitConstructArray,The length of the statement  "          consArr.Operands = this.VisitExpressionList(consArr.Operands' changes.Operands' deletions.Operands' insertions.Operands); " is 121.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,VisitConstructDelegate,The length of the statement  "          consDelegate.TargetObject = this.VisitExpression(consDelegate.TargetObject' changes.TargetObject' deletions.TargetObject' insertions.TargetObject); " is 147.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,VisitConstructFlexArray,The length of the statement  "          consArr.Initializers = this.VisitExpressionList(consArr.Initializers' changes.Initializers' deletions.Initializers' insertions.Initializers); " is 141.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,VisitConstructFlexArray,The length of the statement  "          consArr.Operands = this.VisitExpressionList(consArr.Operands' changes.Operands' deletions.Operands' insertions.Operands); " is 121.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,VisitDelegateNode,The length of the statement  "          delegateNode.Attributes = this.VisitAttributeList(delegateNode.Attributes' changes.Attributes' deletions.Attributes' insertions.Attributes); " is 140.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,VisitDelegateNode,The length of the statement  "          delegateNode.Parameters = this.VisitParameterList(delegateNode.Parameters' changes.Parameters' deletions.Parameters' insertions.Parameters); " is 140.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,VisitDelegateNode,The length of the statement  "          delegateNode.SecurityAttributes = this.VisitSecurityAttributeList(delegateNode.SecurityAttributes' changes.SecurityAttributes' deletions.SecurityAttributes' insertions.SecurityAttributes); " is 188.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,VisitDelegateNode,The length of the statement  "          delegateNode.TemplateParameters = this.VisitTypeReferenceList(delegateNode.TemplateParameters' changes.TemplateParameters' deletions.TemplateParameters' insertions.TemplateParameters); " is 184.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,VisitDoWhile,The length of the statement  "          doWhile.Condition = this.VisitExpression(doWhile.Condition' changes.Condition' deletions.Condition' insertions.Condition); " is 122.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,VisitEvent,The length of the statement  "          evnt.Attributes = this.VisitAttributeList(evnt.Attributes' changes.Attributes' deletions.Attributes' insertions.Attributes); " is 124.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,VisitEvent,The length of the statement  "          evnt.InitialHandler = this.VisitExpression(evnt.InitialHandler' changes.InitialHandler' deletions.InitialHandler' insertions.InitialHandler); " is 141.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,VisitExpressionStatement,The length of the statement  "          statement.Expression = this.VisitExpression(statement.Expression' changes.Expression' deletions.Expression' insertions.Expression); " is 131.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,VisitField,The length of the statement  "          field.Attributes = this.VisitAttributeList(field.Attributes' changes.Attributes' deletions.Attributes' insertions.Attributes); " is 126.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,VisitField,The length of the statement  "          field.DefaultValue = this.VisitLiteral(field.DefaultValue' changes.DefaultValue' deletions.DefaultValue' insertions.DefaultValue); " is 130.
Long Statement,Microsoft.Cci,Updater,C:\repos\Reactive-Extensions_IL2JS\CCI\Updater.cs,VisitField,The length of the statement  "          field.ImplementedInterfaces = this.VisitInterfaceReferenceList(field.ImplementedInterfaces' changes.ImplementedInterfaces' deletions.ImplementedInterfaces' insertions.ImplementedInterfaces); " is 190.
Long Statement,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,SetupMetadataWriter,The length of the statement  "      this.PopulateGenericParamTable(); //Needs to happen before PopulateCustomAttributeTable since it the latter refers to indices in the sorted table " is 145.
Long Statement,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,SetupMetadataWriter,The length of the statement  "      this.PopulateManifestResourceTable(); //This needs to happen before PopulateFileTable because resources are not visited separately " is 130.
Long Statement,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetBlobIndex,The length of the statement  "      if (field != null && field.DeclaringType != null && field.DeclaringType.Template != null && field.DeclaringType.Template.IsGeneric) " is 131.
Long Statement,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetBlobIndex,The length of the statement  "        case ElementType.SzArray: this.blobHeap.Write((byte)4); this.blobHeap.Write((int)0); break; //REVIEW: standard implies this should be 0' peverify thinks otherwise. " is 163.
Long Statement,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The length of the statement  "          if (this.IsStructural(t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0))) " is 155.
Long Statement,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetMethodIndex,The length of the statement  "        Debug.Assert(!methodEntriesAlreadyWritten' "Table has already been written. Adding entries now will not make them be written out."); " is 132.
Long Statement,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetMethodIndex,The length of the statement  "            this.paramEntries.Add(p); //TODO: provide a way to suppress the param table entries unless param has custom attributes or flags " is 127.
Long Statement,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetModuleRefIndex,The length of the statement  "      if (module.Location == "unknown:location") throw new InvalidOperationException(ExceptionStrings.UnresolvedModuleReferenceNotAllowed); " is 133.
Long Statement,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetTypeDefOrRefOrSpecEncoded,The length of the statement  "        if (cp != null) { Debug.Assert(!cp.IsGeneric); return this.GetTypeDefOrRefOrSpecEncoded(cp.BaseClass); } //REVIEW: why??? " is 121.
Long Statement,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetTypeToken,The length of the statement  "      if (this.IsStructural(type) && (!type.IsGeneric || (type.ConsolidatedTemplateArguments != null && type.ConsolidatedTemplateArguments.Count > 0))) " is 145.
Long Statement,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetTypeDefToken,The length of the statement  "      if (this.IsStructural(type) && (!type.IsGeneric || (type.Template != null && type.ConsolidatedTemplateArguments != null && type.ConsolidatedTemplateArguments.Count > 0))) " is 170.
Long Statement,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetUnspecializedMethod,The length of the statement  "        for (int j = 0' m = unspecializedMethod.TemplateParameters == null ? 0 : unspecializedMethod.TemplateParameters.Count; j < m; j++) { " is 132.
Long Statement,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateCustomAttributeTable,The length of the statement  "            if (this.IsStructural(t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0))) " is 155.
Long Statement,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateDeclSecurityTable,The length of the statement  "          if (CoreSystemTypes.SystemAssembly.MetadataFormatMajorVersion == 1 && CoreSystemTypes.SystemAssembly.MetadataFormatMinorVersion < 1) " is 132.
Long Statement,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitClass,The length of the statement  "      if ((Class.Flags & (TypeFlags.ExplicitLayout|TypeFlags.SequentialLayout)) != 0 && (Class.PackingSize != 0 || Class.ClassSize != 0)) " is 131.
Long Statement,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitDelegateNode,The length of the statement  "      for (int i = 0' n = delegateNode.Interfaces == null ? 0 : delegateNode.Interfaces.Count; i < n; i++) { //REVIEW: is this valid? " is 127.
Long Statement,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitMethodBody,The length of the statement  "          if (eh == null || eh.HandlerStartBlock == null || (eh.HandlerType != NodeType.Catch && eh.HandlerType != NodeType.Filter)) continue; " is 132.
Long Statement,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitMethodBody,The length of the statement  "      int maxStack = this.stackHeightExitTotal + this.stackHeightMax; //Wildly pessimistic estimate. Works dandy if BBlocks never leave anything on the stack. " is 152.
Long Statement,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitMethodBody,The length of the statement  "          int handlerLength = handlerLengths[i] = ((int)this.methodInfo.fixupIndex[eh.BlockAfterHandlerEnd.UniqueKey]) - handlerOffset; " is 125.
Long Statement,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,DefineSequencePoint,The length of the statement  "      if (this.symWriter != null && node != null && node.SourceContext.Document != null && !node.SourceContext.Document.Hidden){ " is 122.
Long Statement,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitStruct,The length of the statement  "      if ((Struct.Flags & (TypeFlags.ExplicitLayout|TypeFlags.SequentialLayout)) != 0 && (Struct.PackingSize != 0 || Struct.ClassSize != 0)) " is 134.
Long Statement,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,WriteCustomAttributeLiteral,The length of the statement  "        case ElementType.ValueType: this.WriteCustomAttributeLiteral(writer' new Literal(value' ((EnumNode)literal.Type).UnderlyingType)' false); return; " is 145.
Long Statement,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,WriteMethodSignature,The length of the statement  "        returnType = TypeNode.DeepStripModifiers(returnType' (method.Template != null) ? method.Template.ReturnType : null' SystemTypes.NonNullType' SystemTypes.NullableType); " is 167.
Long Statement,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,WriteMethodSignature,The length of the statement  "    //    returnType = TypeNode.DeepStripModifier(returnType' SystemTypes.NullableType' (method.Template != null) ? returnType.GetTemplateInstance(returnType' returnType.TemplateArguments) : null); " is 193.
Long Statement,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,WriteMethodSignature,The length of the statement  "          parameterType = TypeNode.DeepStripModifiers(parameterType' (method.Template != null) ? method.Template.Parameters[i].Type : null' SystemTypes.NonNullType' SystemTypes.NullableType); " is 181.
Long Statement,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,WriteMethodSignature,The length of the statement  "          //parameterType = TypeNode.DeepStripModifier(parameterType' SystemTypes.NullableType' (method.Template != null) ? parameterType.GetTemplateInstance(parameterType' parameterType.TemplateArguments) : null); " is 204.
Long Statement,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,WritePropertySignature,The length of the statement  "      if (!prop.IsStatic) propHeader |= (byte)0x20; //bizarre redundant way to indicate that property accessors are instance methods " is 126.
Long Statement,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,AppendAssemblyQualifierIfNecessary,The length of the statement  "      if (referencedAssembly != null && referencedAssembly != this.module /*&& referencedAssembly != CoreSystemTypes.SystemAssembly*/) { " is 130.
Long Statement,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,WriteTypeSignature,The length of the statement  "        case ElementType.Array: this.WriteTypeSignature(target' ((ArrayType)t).ElementType); Ir2md.WriteArrayShape(target' (ArrayType)t); break; " is 136.
Long Statement,Microsoft.Cci,MethodSpecializer,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitMethod,The length of the statement  "              //This happens when the declaring type was instantiated after Normalizer has already injected a closure into the template " is 121.
Long Statement,Microsoft.Cci,MethodSpecializer,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitMethod,The length of the statement  "          //Dealing with imported IR that misses important type information if it contains explicit stack operations (push' pop' dup)  " is 123.
Long Statement,Microsoft.Cci,Writer,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,WritePE,The length of the statement  "        Writer.WritePE(module.Location' options.IncludeDebugInformation' module' options.DelaySign' options.AssemblyKeyFile' options.AssemblyKeyName); " is 142.
Long Statement,Microsoft.Cci,Writer,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,WritePE,The length of the statement  "          if (!Writer.StrongNameSignatureGeneration(location' keyName' assem.KeyBlob' assem.KeyBlob == null ? 0 : assem.KeyBlob.Length' IntPtr.Zero' IntPtr.Zero)) " is 152.
Long Statement,Microsoft.Cci,Writer,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,WritePE,The length of the statement  "          if (!Writer.MscorsnStrongNameSignatureGeneration(location' keyName' assem.KeyBlob' assem.KeyBlob == null ? 0 : assem.KeyBlob.Length' IntPtr.Zero' IntPtr.Zero)) " is 159.
Long Statement,Microsoft.Cci.Metadata,MemoryMappedFile,C:\repos\Reactive-Extensions_IL2JS\CCI\MemoryMappedFile.cs,OpenMap,The length of the statement  "        hmap = CreateFileMapping(stream.SafeFileHandle.DangerousGetHandle()' IntPtr.Zero' PageAccess.PAGE_READONLY' 0' length' null); " is 125.
Long Statement,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The length of the statement  "          case TableIndices.TypeDef : offset += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break; " is 177.
Long Statement,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The length of the statement  "          case TableIndices.Method : offset += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break; " is 122.
Long Statement,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The length of the statement  "          case TableIndices.InterfaceImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break; " is 120.
Long Statement,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The length of the statement  "          case TableIndices.CustomAttribute : offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break; " is 138.
Long Statement,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The length of the statement  "          case TableIndices.EventMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break; " is 132.
Long Statement,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The length of the statement  "          case TableIndices.PropertyMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break; " is 138.
Long Statement,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The length of the statement  "          case TableIndices.MethodSemantics : offset += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break; " is 123.
Long Statement,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The length of the statement  "          case TableIndices.ImplMap : offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break; " is 138.
Long Statement,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The length of the statement  "          case TableIndices.GenericParamConstraint: offset += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break; " is 135.
Long Statement,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The length of the statement  "          case TableIndices.ManifestResource : if (this.manifestResourceTable != null) j = this.manifestResourceTable.Length; break; " is 122.
Long Statement,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The length of the statement  "          case TableIndices.GenericParamConstraint: if (this.genericParamConstraintTable != null) j = this.genericParamConstraintTable.Length; break; " is 139.
Long Statement,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The length of the statement  "          case TableIndices.TypeDef : length += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break; " is 177.
Long Statement,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The length of the statement  "          case TableIndices.Method : length += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break; " is 122.
Long Statement,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The length of the statement  "          case TableIndices.InterfaceImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break; " is 120.
Long Statement,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The length of the statement  "          case TableIndices.CustomAttribute : length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break; " is 138.
Long Statement,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The length of the statement  "          case TableIndices.EventMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break; " is 132.
Long Statement,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The length of the statement  "          case TableIndices.PropertyMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break; " is 138.
Long Statement,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The length of the statement  "          case TableIndices.MethodSemantics : length += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break; " is 123.
Long Statement,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The length of the statement  "          case TableIndices.ImplMap : length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break; " is 138.
Long Statement,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The length of the statement  "          case TableIndices.GenericParamConstraint: length += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break; " is 135.
Long Statement,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WritePE,The length of the statement  "      if (this.symWriter != null) this.WriteReferenceToPDBFile(writer' textSection.virtualAddress' textSection.pointerToRawData); " is 123.
Long Statement,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WritePE,The length of the statement  "        int vaddr = sdataSection.virtualAddress = previousSection.virtualAddress + n * (int)Math.Ceiling(previousSection.sizeOfRawData / (double)n); " is 140.
Long Statement,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WritePE,The length of the statement  "        sdataSection.pointerToRawData = previousSection.pointerToRawData + m * (int)Math.Ceiling(previousSection.sizeOfRawData / (double)m); " is 132.
Long Statement,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WritePE,The length of the statement  "        int vaddr = tlsSection.virtualAddress = previousSection.virtualAddress + n * (int)Math.Ceiling(previousSection.sizeOfRawData / (double)n); " is 138.
Long Statement,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WritePE,The length of the statement  "        tlsSection.pointerToRawData = previousSection.pointerToRawData + m * (int)Math.Ceiling(previousSection.sizeOfRawData / (double)m); " is 130.
Long Statement,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WritePE,The length of the statement  "        rsrcSection.virtualAddress = previousSection.virtualAddress + n * (int)Math.Ceiling(previousSection.sizeOfRawData / (double)n); " is 127.
Long Statement,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WritePE,The length of the statement  "        rsrcSection.pointerToRawData = previousSection.pointerToRawData + m * (int)Math.Ceiling(previousSection.sizeOfRawData / (double)m); " is 131.
Long Statement,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WritePE,The length of the statement  "      relocSection.virtualAddress = previousSection.virtualAddress + n * (int)Math.Ceiling(previousSection.sizeOfRawData / (double)n); " is 128.
Long Statement,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WritePE,The length of the statement  "      relocSection.pointerToRawData = previousSection.pointerToRawData + m * (int)Math.Ceiling(previousSection.sizeOfRawData / (double)m); " is 132.
Long Statement,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WriteDirectory,The length of the statement  "          dataHeap.Write(name.ToCharArray());  //REVIEW: what happens if the name contains chars that do not fit into a single utf8 code point? " is 133.
Long Statement,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ReadFileIntoUnmanagedBuffer,The length of the statement  "      if (!Reader.ReadFile(inputStream.SafeFileHandle.DangerousGetHandle()' pb' n' &n' IntPtr.Zero)) throw new System.IO.FileLoadException(); " is 135.
Long Statement,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,SetupDebugReader,The length of the statement  "              throw new InvalidOperationException(String.Format(CultureInfo.CurrentCulture' ExceptionStrings.PdbAssociatedWithFileIsOutOfDate' filename)); " is 140.
Long Statement,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetCachedAssembly,The length of the statement  "      //if (CoreSystemTypes.SystemAssembly != null && CoreSystemTypes.SystemAssembly.Name == assembly.Name && CoreSystemTypes.SystemAssembly.reader != null) { " is 152.
Long Statement,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetCachedAssembly,The length of the statement  "      //    if (this.getDebugSymbols && !CoreSystemTypes.SystemAssembly.reader.getDebugSymbols && !CoreSystemTypes.SystemAssembly.reader.getDebugSymbolsFailed) " is 153.
Long Statement,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetCachedAssembly,The length of the statement  "          AssemblyReference aRef = (AssemblyReference)TargetPlatform.AssemblyReferenceFor[Identifier.For(assemblyReference.Name).UniqueIdKey]; " is 132.
Long Statement,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetCachedAssembly,The length of the statement  "          if (aRef != null && assemblyReference.Version != null && aRef.Version >= assemblyReference.Version && aRef.MatchesIgnoringVersion(assemblyReference)) { " is 151.
Long Statement,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetCachedAssembly,The length of the statement  "                  HandleError(assembly' String.Format(CultureInfo.CurrentCulture' ExceptionStrings.BadTargetPlatformLocation' assembly.Name' TargetPlatform.PlatformAssembliesLocation' assembly.Version' aRef.Version)); " is 199.
Long Statement,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetCachedAssembly,The length of the statement  "              platformAssembly = AssemblyNode.GetAssembly(aRef.Location' this.doNotLockFile' this.getDebugSymbols' this.useStaticCache); " is 122.
Long Statement,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ReadModule,The length of the statement  "            if (cachedAssembly != null && cachedAssembly.FileLastWriteTimeUtc == System.IO.File.GetLastWriteTimeUtc(this.fileName)) { " is 121.
Long Statement,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ReadModule,The length of the statement  "          if (cachedAssembly != null && cachedAssembly.FileLastWriteTimeUtc == System.IO.File.GetLastWriteTimeUtc(this.fileName)) { " is 121.
Long Statement,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ReadAssemblyProperties,The length of the statement  "      assembly.Version = new System.Version(assemblyRow.MajorVersion' assemblyRow.MinorVersion' assemblyRow.BuildNumber' assemblyRow.RevisionNumber); " is 143.
Long Statement,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,AddMethodsToType,The length of the statement  "        if (method != null && ((method.Flags & MethodFlags.RTSpecialName) == 0 || method.Name.UniqueIdKey != StandardIds._Deleted.UniqueIdKey)) " is 135.
Long Statement,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,AddPropertiesToType,The length of the statement  "        if ((property.Flags & PropertyFlags.RTSpecialName) == 0 || property.Name.UniqueIdKey != StandardIds._Deleted.UniqueIdKey){ " is 122.
Long Statement,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetAssemblyFromReference,The length of the statement  "        if (SystemAssemblyLocation.ParsedAssembly != null && (assemblyReference.Name == "mscorlib" || assemblyReference.Name == "basetypes" || assemblyReference.Name == "ioconfig" " is 171.
Long Statement,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetAssemblyFromReference,The length of the statement  "        if (CoreSystemTypes.SystemAssembly != null && CoreSystemTypes.SystemAssembly.Name == assemblyReference.Name) return CoreSystemTypes.SystemAssembly; " is 147.
Long Statement,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetAssemblyFromReference,The length of the statement  "          AssemblyReference aRef = (AssemblyReference)TargetPlatform.AssemblyReferenceFor[Identifier.For(assemblyReference.Name).UniqueIdKey]; " is 132.
Long Statement,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetAssemblyFromReference,The length of the statement  "          if (aRef != null && assemblyReference.Version != null && aRef.Version >= assemblyReference.Version && aRef.MatchesIgnoringVersion(assemblyReference)){ " is 150.
Long Statement,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetAssemblyFromReference,The length of the statement  "              platformAssembly = AssemblyNode.GetAssembly(aRef.Location' this.doNotLockFile' this.getDebugSymbols' this.useStaticCache); " is 122.
Long Statement,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetAssemblyFromReference,The length of the statement  "              if (CoreSystemTypes.SystemAssembly != null && CoreSystemTypes.SystemAssembly.Name == assembly.Name) return CoreSystemTypes.SystemAssembly; " is 138.
Long Statement,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetAssemblyFromReference,The length of the statement  "            assembly = AssemblyNode.GetAssembly(fileName' this.localAssemblyCache' this.doNotLockFile' this.getDebugSymbols' this.useStaticCache); " is 134.
Long Statement,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetAssemblyFromReference,The length of the statement  "              if (assemblyReference.Matches(assembly.Name' assembly.Version' assembly.Culture' assembly.PublicKeyToken)) goto cacheIt; " is 120.
Long Statement,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetAssemblyFromReference,The length of the statement  "            assembly = AssemblyNode.GetAssembly(fileName' this.localAssemblyCache' this.doNotLockFile' this.getDebugSymbols' this.useStaticCache); " is 134.
Long Statement,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetAssemblyFromReference,The length of the statement  "              if (assemblyReference.Matches(assembly.Name' assembly.Version' assembly.Culture' assembly.PublicKeyToken)) goto cacheIt; " is 120.
Long Statement,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetAssemblyFromReference,The length of the statement  "            assembly = AssemblyNode.GetAssembly(fileName' this.localAssemblyCache' this.doNotLockFile' this.getDebugSymbols' this.useStaticCache); " is 134.
Long Statement,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetAssemblyFromReference,The length of the statement  "              if (assemblyReference.Matches(assembly.Name' assembly.Version' assembly.Culture' assembly.PublicKeyToken)) goto cacheIt; " is 120.
Long Statement,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetAssemblyFromReference,The length of the statement  "            assembly = AssemblyNode.GetAssembly(fileName' this.localAssemblyCache' this.doNotLockFile' this.getDebugSymbols' this.useStaticCache); " is 134.
Long Statement,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetAssemblyFromReference,The length of the statement  "              if (assemblyReference.Matches(assembly.Name' assembly.Version' assembly.Culture' assembly.PublicKeyToken)) goto cacheIt; " is 120.
Long Statement,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetAssemblyFromReference,The length of the statement  "            assembly = AssemblyNode.GetAssembly(fileName' this.localAssemblyCache' this.doNotLockFile' this.getDebugSymbols' this.useStaticCache); " is 134.
Long Statement,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetAssemblyFromReference,The length of the statement  "              if (assemblyReference.Matches(assembly.Name' assembly.Version' assembly.Culture' assembly.PublicKeyToken)) goto cacheIt; " is 120.
Long Statement,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetAssemblyFromReference,The length of the statement  "            assembly = AssemblyNode.GetAssembly(gacLocation' this.useStaticCache ? Reader.StaticAssemblyCache : this.localAssemblyCache' this.doNotLockFile' this.getDebugSymbols' this.useStaticCache); " is 188.
Long Statement,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetAssemblyFromReference,The length of the statement  "            HandleError(this.module' String.Format(CultureInfo.CurrentCulture' ExceptionStrings.AssemblyReferenceNotResolved' assemblyReference.StrongName)); " is 145.
Long Statement,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetPermissionAttribute2,The length of the statement  "        HandleError(this.module' String.Format(CultureInfo.CurrentCulture' ExceptionStrings.CouldNotResolveType'serializedTypeName)); " is 125.
Long Statement,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,HandleError,The length of the statement  "      throw new InvalidMetadataException(String.Format(CultureInfo.CurrentCulture' ExceptionStrings.ModuleError' mod.Name' errorMessage)); " is 132.
Long Statement,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseArrayOrGenericType,The length of the statement  "      //Get here after "rootType[" has been parsed. What follows is either an array type specifier or some generic type arguments. " is 124.
Long Statement,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseArrayOrGenericType,The length of the statement  "        if (ch == '[') retVal = this.ParseArrayOrGenericType(typeName.Substring(lastCharPos+2' typeName.Length-1-lastCharPos-1)' retVal); " is 129.
Long Statement,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetFieldFromDef,The length of the statement  "      if ((field.Flags & FieldFlags.RTSpecialName) != 0 && field.Name.UniqueIdKey == StandardIds._Deleted.UniqueIdKey) return null; " is 125.
Long Statement,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetLocalSourceNames,The length of the statement  "          (ISymUnmanagedVariable)System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(localPtrs[i]' typeof(ISymUnmanagedVariable)); " is 133.
Long Statement,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetLocalSourceNames,The length of the statement  "          (ISymUnmanagedScope)System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(subscopes[i]' typeof(ISymUnmanagedScope)); " is 127.
Long Statement,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetMarshallingInformation,The length of the statement  "          result.ElementType = (NativeType)c.ReadByte(); //Actually a variant type. TODO: what about VT_VECTOR VT_ARRAY and VT_BYREF? " is 123.
Long Statement,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,MethodIsExtern,The length of the statement  "            m.IsExtern = !(meth.RVA != 0 && (((MethodImplFlags)meth.ImplFlags) & MethodImplFlags.ManagedMask) == MethodImplFlags.Managed); " is 126.
Long Statement,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetMethodFromDef,The length of the statement  "          method = methodDefs[index - 1].Method = new InstanceInitializer(provider' index' (int)TableIndices.Method << 24 | index); " is 121.
Long Statement,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetMethodFromDef,The length of the statement  "        ParamPtrRow[] parPtrs = this.tables.ParamPtrTable; //TODO: why use ParamPtrTable in the branch and not the one above? Factor this out. " is 134.
Long Statement,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetMethodAttributes,The length of the statement  "        if (method != md.Method) throw new System.ArgumentOutOfRangeException("handle"' ExceptionStrings.InvalidTypeTableIndex); " is 120.
Long Statement,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetMemberFromRef,The length of the statement  "      TypeNodeList paramTypes = this.ParseParameterTypes(out varArgTypes' sigReader' paramCount' ref genericParameterEncountered); " is 124.
Long Statement,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetMemberFromRef,The length of the statement  "          if (typeParamCount != int.MinValue && (!m.IsGeneric || m.TemplateParameters == null || m.TemplateParameters.Count != typeParamCount)) " is 133.
Long Statement,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,TypeDefIsClassButNotValueTypeBaseClass,The length of the statement  "      if (typeDef.Type != null) return typeDef.Type != CoreSystemTypes.ValueType && typeDef.Type != CoreSystemTypes.Enum && typeDef.Type is Class; " is 140.
Long Statement,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetTypeFromDefHelper,The length of the statement  "          for (int j = 0' offset = typeParameters.Count-result.templateParameters.Count' n = result.templateParameters.Count; j < n; j++) " is 127.
Long Statement,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ConstructCorrectTypeNodeSubclass,The length of the statement  "          isTemplateParameter = CoreSystemTypes.IsInitialized && lastInterface != null && lastInterface == ExtendedRuntimeTypes.ITemplateParameter; " is 137.
Long Statement,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ConstructCorrectTypeNodeSubclass,The length of the statement  "              result = this.GetTypeExtensionFromDef(nestedTypeProvider' attributeProvider' memberProvider' i' baseClass' lastInterface); " is 122.
Long Statement,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ConstructCorrectTypeNodeSubclass,The length of the statement  "            result = this.GetTypeExtensionFromDef(nestedTypeProvider' attributeProvider' memberProvider' i' baseClass' lastInterface); " is 122.
Long Statement,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetTypeExtensionFromDef,The length of the statement  "              HandleError(this.module' string.Format(CultureInfo.CurrentCulture' ExceptionStrings.CannotLoadTypeExtension' lastInterface.FullName' compilerDllName)); " is 151.
Long Statement,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseArrayElementLoadAddress,The length of the statement  "      return new UnaryExpression(this.ParseArrayElementLoad(0' elemType)' this.isReadOnly ? NodeType.ReadOnlyAddressOf : NodeType.AddressOf' elemType.GetReferenceType()); " is 164.
Long Statement,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseBranch,The length of the statement  "        (operandCount > 0 ? (operatorType == NodeType.Nop ? operand1 : (Expression)new UnaryExpression(operand1' operatorType)) : null); " is 128.
Long Statement,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseCopyObject,The length of the statement  "      return new AssignmentStatement(new AddressDereference(lhaddr' type' this.isVolatile' this.alignment)' new AddressDereference(rhaddr' type)); " is 140.
Long Statement,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseInitObject,The length of the statement  "      return new AssignmentStatement(new AddressDereference(lhaddr' type' this.isVolatile' this.alignment)' new Literal(null' CoreSystemTypes.Object)); " is 145.
Long Statement,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The length of the statement  "        startingAddress = this.counter+1; //Add one so that it is never zero (the latter means no entry to the TrivialHashtable) " is 120.
Long Statement,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The length of the statement  "          case OpCode.Brfalse_S: statement = this.ParseBranch(NodeType.LogicalNot' 1' true' false); transferStatement = true; goto done; " is 126.
Long Statement,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The length of the statement  "          case OpCode.Brfalse: statement = this.ParseBranch(NodeType.LogicalNot' 1' false' false); transferStatement = true; goto done; " is 125.
Long Statement,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The length of the statement  "          case OpCode.Ldind_I1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int8' this.isVolatile' this.alignment); break; " is 128.
Long Statement,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The length of the statement  "          case OpCode.Ldind_U1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment); break; " is 129.
Long Statement,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The length of the statement  "          case OpCode.Ldind_I2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int16' this.isVolatile' this.alignment); break; " is 129.
Long Statement,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The length of the statement  "          case OpCode.Ldind_U2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment); break; " is 130.
Long Statement,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The length of the statement  "          case OpCode.Ldind_I4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int32' this.isVolatile' this.alignment); break; " is 129.
Long Statement,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The length of the statement  "          case OpCode.Ldind_U4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment); break; " is 130.
Long Statement,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The length of the statement  "          case OpCode.Ldind_I8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int64' this.isVolatile' this.alignment); break; " is 129.
Long Statement,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The length of the statement  "          case OpCode.Ldind_I: expr = new AddressDereference(PopOperand()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment); break; " is 129.
Long Statement,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The length of the statement  "          case OpCode.Ldind_R4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Single' this.isVolatile' this.alignment); break; " is 130.
Long Statement,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The length of the statement  "          case OpCode.Ldind_R8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Double' this.isVolatile' this.alignment); break; " is 130.
Long Statement,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The length of the statement  "          case OpCode.Ldind_Ref: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Object' this.isVolatile' this.alignment); break; " is 131.
Long Statement,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The length of the statement  "          case OpCode.Ldobj: expr = new AddressDereference(PopOperand()' (TypeNode)this.GetMemberFromToken()' this.isVolatile' this.alignment); break; " is 140.
Long Statement,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The length of the statement  "          case OpCode.Castclass: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Castclass); break; " is 123.
Long Statement,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The length of the statement  "            expr = SetType(new UnaryExpression(new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf));  " is 149.
Long Statement,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The length of the statement  "          case OpCode.Ldsflda: expr = SetType(new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf)); break; " is 169.
Long Statement,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The length of the statement  "          case OpCode.Stsfld: statement = new AssignmentStatement(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' PopOperand()); goto done; " is 166.
Long Statement,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The length of the statement  "          case OpCode.Conv_Ovf_I1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8); break; " is 123.
Long Statement,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The length of the statement  "          case OpCode.Conv_Ovf_I2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16); break; " is 124.
Long Statement,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The length of the statement  "          case OpCode.Conv_Ovf_I4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32); break; " is 124.
Long Statement,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The length of the statement  "          case OpCode.Conv_Ovf_I8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64); break; " is 124.
Long Statement,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The length of the statement  "          case OpCode.Conv_Ovf_U1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8); break; " is 124.
Long Statement,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The length of the statement  "          case OpCode.Conv_Ovf_U2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16); break; " is 125.
Long Statement,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The length of the statement  "          case OpCode.Conv_Ovf_U4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32); break; " is 125.
Long Statement,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The length of the statement  "          case OpCode.Conv_Ovf_U8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64); break; " is 125.
Long Statement,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The length of the statement  "          case OpCode.Conv_Ovf_I_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr); break; " is 123.
Long Statement,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The length of the statement  "          case OpCode.Conv_Ovf_U_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr); break; " is 124.
Long Statement,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The length of the statement  "          case OpCode.Unbox_Any: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.UnboxAny); break; " is 122.
Long Statement,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The length of the statement  "          case OpCode.Refanyval: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr); break; " is 178.
Long Statement,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The length of the statement  "          case OpCode.Mkrefany: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference); break; " is 195.
Long Statement,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The length of the statement  "          case OpCode.Leave: statement = this.ParseBranch(NodeType.Nop' 0' false' false' true); transferStatement = true; goto done; " is 122.
Long Statement,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The length of the statement  "          case OpCode.Leave_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false' true); transferStatement = true; goto done; " is 123.
Long Statement,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The length of the statement  "          case OpCode.Ldftn: expr = new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldftn' CoreSystemTypes.IntPtr); break; " is 145.
Long Statement,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The length of the statement  "          case OpCode.Ldvirtftn: expr = new BinaryExpression(PopOperand()' new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr); break; " is 168.
Long Statement,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The length of the statement  "          case OpCode.Ldarga: expr = SetType(new UnaryExpression(this.Parameters((ushort)this.GetInt16())' NodeType.AddressOf)); break; " is 125.
Long Statement,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The length of the statement  "          case OpCode.Starg: statement = new AssignmentStatement(this.Parameters((ushort)this.GetInt16())' PopOperand()); goto done; " is 122.
Long Statement,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The length of the statement  "          case OpCode.Ldloca: expr = SetType(new UnaryExpression(this.locals[(ushort)this.GetInt16()]' NodeType.AddressOf)); break; " is 121.
Long Statement,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The length of the statement  "          case OpCode.Rethrow: statement = new Throw(null); statement.NodeType = NodeType.Rethrow; transferStatement = true; goto done; " is 125.
Long Statement,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The length of the statement  "          case OpCode.Sizeof: expr = new UnaryExpression(new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32); break; " is 156.
Long Statement,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The length of the statement  "          case OpCode.Refanytype: expr = new UnaryExpression(PopOperand()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle); break; " is 128.
Long Statement,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStoreField,The length of the statement  "      AssignmentStatement s = new AssignmentStatement(new MemberBinding(thisob' this.GetMemberFromToken()' this.isVolatile' this.alignment)' rhvalue); " is 144.
Long Statement,Microsoft.Cci.Metadata,InstructionParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,AddInstruction,The length of the statement  "      SortedDictionary<int'InstructionList> instructionPriority = (SortedDictionary<int'InstructionList>)this.ehMap[offset+1]; " is 120.
Long Statement,Microsoft.Cci.Metadata,InstructionParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,AddInstruction,The length of the statement  "      if (instructionPriority == null) this.ehMap[offset+1] = instructionPriority = new SortedDictionary<int'InstructionList>(); " is 122.
Long Statement,Microsoft.Cci.Metadata,InstructionParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseInstructions,The length of the statement  "        SortedDictionary<int'InstructionList> instructionPriority = (SortedDictionary<int'InstructionList>)this.ehMap[this.counter+1]; " is 126.
Complex Conditional,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The conditional expression  "nd1 == null || list1 == null || matchedNodes == null ||  list1pos < 0 || list1pos >= list1.Count || list2start < 0 || list2start >= list2.Count"  is complex.
Complex Conditional,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The conditional expression  "nd1 == null || list1 == null || matchedNodes == null || list1pos < 0 || list1pos >= list1.Count || list2start < 0 || list2start >= list2.Count"  is complex.
Complex Conditional,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The conditional expression  "nd1 == null || list1 == null || matchedNodes == null || list1pos < 0 || list1pos >= list1.Count || list2start < 0 || list2start >= list2.Count"  is complex.
Complex Conditional,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The conditional expression  "nd1 == null || list1 == null || matchedNodes == null || list1pos < 0 || list1pos >= list1.Count || list2start < 0 || list2start >= list2.Count"  is complex.
Complex Conditional,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The conditional expression  "nd1 == null || list1 == null || matchedNodes == null || list1pos < 0 || list1pos >= list1.Count || list2start < 0 || list2start >= list2.Count"  is complex.
Complex Conditional,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The conditional expression  "nd1 == null || list1 == null || matchedNodes == null || list1pos < 0 || list1pos >= list1.Count || list2start < 0 || list2start >= list2.Count"  is complex.
Complex Conditional,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The conditional expression  "nd1 == null || list1 == null || matchedNodes == null || list1pos < 0 || list1pos >= list1.Count || list2start < 0 || list2start >= list2.Count"  is complex.
Complex Conditional,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The conditional expression  "nd1 == null || list1 == null || matchedNodes == null || list1pos < 0 || list1pos >= list1.Count || list2start < 0 || list2start >= list2.Count"  is complex.
Complex Conditional,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The conditional expression  "nd1 == null || list1 == null || matchedNodes == null || list1pos < 0 || list1pos >= list1.Count || list2start < 0 || list2start >= list2.Count"  is complex.
Complex Conditional,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The conditional expression  "nd1 == null || list1 == null || matchedNodes == null || list1pos < 0 || list1pos >= list1.Count || list2start < 0 || list2start >= list2.Count"  is complex.
Complex Conditional,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The conditional expression  "nd1 == null || list1 == null ||  matchedNodes == null || list1pos < 0 || list1pos >= list1.Count || list2start < 0 || list2start >= list2.Count"  is complex.
Complex Conditional,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The conditional expression  "nd1 == null || list1 == null ||  matchedNodes == null || list1pos < 0 || list1pos >= list1.Count || list2start < 0 || list2start >= list2.Count"  is complex.
Complex Conditional,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The conditional expression  "nd1 == null || list1 == null || matchedNodes == null || list1pos < 0 || list1pos >= list1.Count || list2start < 0 || list2start >= list2.Count"  is complex.
Complex Conditional,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitComposition,The conditional expression  "comp1.Composer != comp2.Composer && comp1.Composer != null && comp2.Composer != null && comp1.Composer.ToString() != comp2.Composer.ToString()"  is complex.
Complex Conditional,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitMemberList,The conditional expression  "(nd1.DeclaringType != null && nd1.DeclaringType.DeclaringModule == this.OriginalModule) ||              (nd1 is TypeNode && ((TypeNode)nd1).DeclaringModule == this.OriginalModule)"  is complex.
Complex Conditional,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitMemberList,The conditional expression  "(nd1.DeclaringType != null && nd1.DeclaringType.DeclaringModule == this.OriginalModule) ||            (nd1 is TypeNode && ((TypeNode)nd1).DeclaringModule == this.OriginalModule)"  is complex.
Complex Conditional,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,VisitMethod,The conditional expression  "method1.PInvokeModule == method2.PInvokeModule ||          (method1.PInvokeModule != null && method2.PInvokeModule != null && method1.PInvokeModule.Name == method2.PInvokeModule.Name)"  is complex.
Complex Conditional,Microsoft.Cci,Duplicator,C:\repos\Reactive-Extensions_IL2JS\CCI\Duplicator.cs,VisitMemberReference,The conditional expression  "method != null && method.Template != null && method.TemplateArguments != null && method.TemplateArguments.Count > 0"  is complex.
Complex Conditional,Microsoft.Cci,Duplicator,C:\repos\Reactive-Extensions_IL2JS\CCI\Duplicator.cs,VisitTypeReference,The conditional expression  "type.Template != null && type.Template != type && (type.TemplateArguments != null ||             (!this.RecordOriginalAsTemplate && type.ConsolidatedTemplateArguments != null && type.ConsolidatedTemplateArguments.Count > 0))"  is complex.
Complex Conditional,Microsoft.Cci,BetterPath,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Combine,The conditional expression  "ch == BetterPath.DirectorySeparatorChar || ch == BetterPath.AltDirectorySeparatorChar || (path2.Length >= 2 && path2[1] == BetterPath.VolumeSeparatorChar)"  is complex.
Complex Conditional,Microsoft.Cci,ReGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI\ILGenerator.cs,VisitAssignmentStatement,The conditional expression  "adrType != null && (adrType.IsValueType ||                  adrType.NodeType == NodeType.TypeParameter || adrType.NodeType == NodeType.ClassParameter)"  is complex.
Complex Conditional,Microsoft.Cci,ReGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI\ILGenerator.cs,VisitLiteral,The conditional expression  "n >= System.Int32.MinValue && n <= System.Int32.MaxValue ||                  n <= System.UInt32.MaxValue && (tc == TypeCode.Char || tc == TypeCode.UInt16 || tc == TypeCode.UInt32)"  is complex.
Complex Conditional,Microsoft.Cci,AssemblyReference,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,Matches,The conditional expression  "this.Version != version && this.Version != null && (version == null || !this.Version.Equals(version))"  is complex.
Complex Conditional,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetTemplateInstance,The conditional expression  "module == null || templateArguments == null || (declaringType == null && (templateParameters == null || templateParameters.Count == 0))"  is complex.
Complex Conditional,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetOpFalse,The conditional expression  "!opFalse.IsSpecialName || !opFalse.IsStatic || !opFalse.IsPublic || opFalse.ReturnType != CoreSystemTypes.Boolean ||                  opFalse.Parameters == null || opFalse.Parameters.Count != 1"  is complex.
Complex Conditional,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetOpTrue,The conditional expression  "!opTrue.IsSpecialName || !opTrue.IsStatic || !opTrue.IsPublic || opTrue.ReturnType != CoreSystemTypes.Boolean ||                  opTrue.Parameters == null || opTrue.Parameters.Count != 1"  is complex.
Complex Conditional,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetImplementingMethod,The conditional expression  "locM == null || !locM.IsVirtual || (checkPublic && !locM.IsPublic)"  is complex.
Complex Conditional,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetImplementingMethod,The conditional expression  "(locM.ReturnType != meth.ReturnType && !(locM.ReturnType != null && locM.ReturnType.IsStructurallyEquivalentTo(meth.ReturnType))) ||            !locM.ParametersMatchStructurally(meth.Parameters)"  is complex.
Complex Conditional,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,IsAssignableTo,The conditional expression  "targetType == CoreSystemTypes.Object || this.IsStructurallyEquivalentTo(targetType) ||          this.BaseType != null && (this.BaseType.IsAssignableTo(targetType))"  is complex.
Complex Conditional,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,IsAssignableTo,The conditional expression  "this.BaseType != null && this.ConsolidatedTemplateParameters != null && this.BaseType.Template != null && this.BaseType.Template.IsAssignableTo(targetType)"  is complex.
Complex Conditional,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,IsAssignableToInstanceOf,The conditional expression  "targetTemplate.IsStructurallyEquivalentTo(this.Template == null ? this : this.Template) ||           this.BaseType != null && (this.BaseType.IsAssignableToInstanceOf(targetTemplate) ||          this.BaseType.Template != null && this.BaseType.Template.IsAssignableToInstanceOf(targetTemplate))"  is complex.
Complex Conditional,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,IsStructurallyEquivalentTo,The conditional expression  "this.DeclaringType != null && (this.TemplateArguments == null || this.TemplateArguments.Count == 0) &&            (type.TemplateArguments == null || type.TemplateArguments.Count == 0)"  is complex.
Complex Conditional,Microsoft.Cci,NamespaceScope,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetAliasFor,The conditional expression  "name == null || this.AssociatedNamespace == null || this.AssociatedModule == null || this.aliasFor == null"  is complex.
Complex Conditional,Microsoft.Cci,NamespaceScope,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetConflictingAlias,The conditional expression  "name == null || this.typeFor == null || this.AssociatedNamespace == null || this.AssociatedModule == null"  is complex.
Complex Conditional,Microsoft.Cci,NamespaceScope,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetNamespaceFullNameFor,The conditional expression  "name == null || this.AssociatedNamespace == null || this.AssociatedModule == null || this.nestedNamespaceFullName == null"  is complex.
Complex Conditional,Microsoft.Cci,NamespaceScope,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetType,The conditional expression  "Namespace == null || name == null || this.AssociatedNamespace == null || this.AssociatedModule == null"  is complex.
Complex Conditional,Microsoft.Cci,NamespaceScope,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetType,The conditional expression  "name == null || this.typeFor == null || this.AssociatedNamespace == null || this.AssociatedModule == null"  is complex.
Complex Conditional,Microsoft.Cci,NamespaceScope,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetType,The conditional expression  "result == null && returnNullIfHiddenByNestedNamespace && nsScope != null &&             nsScope.AliasedNamespace != null && nsScope.AliasedNamespace[name.UniqueIdKey] != null"  is complex.
Complex Conditional,Microsoft.Cci,NamespaceScope,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetType,The conditional expression  "duplicates != null && duplicates.Count > 1 && this.AssociatedNamespace != null && this.AssociatedNamespace.Name != null && this.AssociatedNamespace.Name.Name != null"  is complex.
Complex Conditional,Microsoft.Cci,NamespaceScope,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetReferencedTypes,The conditional expression  "Namespace == null || name == null || types == null || this.AssociatedModule == null"  is complex.
Complex Conditional,Microsoft.Cci,ArrayType,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,IsAssignableTo,The conditional expression  "targetType == this || targetType == CoreSystemTypes.Object || targetType == CoreSystemTypes.Array || targetType == SystemTypes.ICloneable"  is complex.
Complex Conditional,Microsoft.Cci,Method,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetDocumentationId,The conditional expression  "this.IsSpecialName && this.ReturnType != null && this.Name != null &&           (this.Name.UniqueIdKey == StandardIds.opExplicit.UniqueIdKey || this.Name.UniqueIdKey == StandardIds.opImplicit.UniqueIdKey)"  is complex.
Complex Conditional,Microsoft.Cci,Method,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetDynamicMethod,The conditional expression  "this.DeclaringType == null || this.DeclaringType.DeclaringModule == null || !this.IsNormalized || this.Name == null || this.ReturnType == null"  is complex.
Complex Conditional,Microsoft.Cci,Method,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetMethodInfo,The conditional expression  "t1 == null || t2 == null || t1.Name == null || t1.Name.Name != t2.Name"  is complex.
Complex Conditional,Microsoft.Cci,Specializer,C:\repos\Reactive-Extensions_IL2JS\CCI\Specializer.cs,GetCorrespondingMember,The conditional expression  "unspecializedMember != null && specializedMember == null && unspecializedOffset == i &&            !(unspecializedMember is TypeParameter || unspecializedMember is ClassParameter)"  is complex.
Complex Conditional,Microsoft.Cci,Specializer,C:\repos\Reactive-Extensions_IL2JS\CCI\Specializer.cs,GetCorrespondingMember,The conditional expression  "unspecializedMember == null && specializedMember != null && specializedOffset == i &&            !(specializedMember is TypeParameter || specializedMember is ClassParameter)"  is complex.
Complex Conditional,Microsoft.Cci,Specializer,C:\repos\Reactive-Extensions_IL2JS\CCI\Specializer.cs,VisitTypeNode,The conditional expression  "savedCurrentType != null && savedCurrentType.TemplateArguments != null && savedCurrentType.TemplateArguments.Count > 0 &&          typeNode.Template != null && (typeNode.Template.TemplateParameters == null || typeNode.Template.TemplateParameters.Count == 0)"  is complex.
Complex Conditional,Microsoft.Cci,Specializer,C:\repos\Reactive-Extensions_IL2JS\CCI\Specializer.cs,VisitTypeReference,The conditional expression  "arguments != null && arguments.Count > 0 && nt.ConsolidatedTemplateParameters != null && nt.ConsolidatedTemplateParameters.Count > 0"  is complex.
Complex Conditional,Microsoft.Cci,Specializer,C:\repos\Reactive-Extensions_IL2JS\CCI\Specializer.cs,VisitTypeReference,The conditional expression  "!type.IsNotFullySpecialized && (!type.IsNormalized ||                (this.CurrentType != null && type.DeclaringModule == this.CurrentType.DeclaringModule))"  is complex.
Complex Conditional,Microsoft.Cci,MethodBodySpecializer,C:\repos\Reactive-Extensions_IL2JS\CCI\Specializer.cs,VisitAssignmentStatement,The conditional expression  "!sType.IsValueType && !(sType == CoreSystemTypes.Object && source is Literal && target.NodeType == NodeType.AddressDereference)"  is complex.
Complex Conditional,Microsoft.Cci,MethodBodySpecializer,C:\repos\Reactive-Extensions_IL2JS\CCI\Specializer.cs,VisitBinaryExpression,The conditional expression  "lit != null && lit.Value == null && opnd1 != null && opnd1.Type != null && opnd1.Type.IsValueType"  is complex.
Complex Conditional,Microsoft.Cci,MethodBodySpecializer,C:\repos\Reactive-Extensions_IL2JS\CCI\Specializer.cs,VisitBinaryExpression,The conditional expression  "lit != null && lit.Value == null && opnd2 != null && opnd2.Type != null && opnd2.Type.IsValueType"  is complex.
Complex Conditional,Microsoft.Cci,MethodBodySpecializer,C:\repos\Reactive-Extensions_IL2JS\CCI\Specializer.cs,VisitBinaryExpression,The conditional expression  "lit != null && lit.Value == null && opnd1 != null && opnd1.Type != null && opnd1.Type.IsValueType"  is complex.
Complex Conditional,Microsoft.Cci,MethodBodySpecializer,C:\repos\Reactive-Extensions_IL2JS\CCI\Specializer.cs,VisitBinaryExpression,The conditional expression  "lit != null && lit.Value == null && opnd2 != null && opnd2.Type != null && opnd2.Type.IsValueType"  is complex.
Complex Conditional,Microsoft.Cci,MethodBodySpecializer,C:\repos\Reactive-Extensions_IL2JS\CCI\Specializer.cs,VisitBranch,The conditional expression  "ct != null && !ct.IsPrimitiveInteger && ct != CoreSystemTypes.Boolean && ct.IsValueType"  is complex.
Complex Conditional,Microsoft.Cci,MethodBodySpecializer,C:\repos\Reactive-Extensions_IL2JS\CCI\Specializer.cs,VisitMethodCall,The conditional expression  "meth.ReturnType != null && call.Type != null && meth.ReturnType.IsValueType && !call.Type.IsValueType"  is complex.
Complex Conditional,Microsoft.Cci,MethodBodySpecializer,C:\repos\Reactive-Extensions_IL2JS\CCI\Specializer.cs,VisitReturn,The conditional expression  "rval == null || rval.Type == null || this.CurrentMethod == null || this.CurrentMethod.ReturnType == null"  is complex.
Complex Conditional,Microsoft.Cci,CoreSystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,Initialize,The conditional expression  "TargetPlatform.TargetVersion.Major > 1 || TargetPlatform.TargetVersion.Minor > 1 ||                (TargetPlatform.TargetVersion.Minor == 1 && TargetPlatform.TargetVersion.Build == 9999)"  is complex.
Complex Conditional,Microsoft.Cci,CoreSystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,GetDummyTypeNode,The conditional expression  "name.EndsWith("Callback") || name.EndsWith("Delegate") || name == "ThreadStart" || name == "FrameGuardGetter" || name == "GuardThreadStart""  is complex.
Complex Conditional,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetBlobIndex,The conditional expression  "field != null && field.DeclaringType != null && field.DeclaringType.Template != null && field.DeclaringType.Template.IsGeneric"  is complex.
Complex Conditional,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The conditional expression  "this.IsStructural(t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0))"  is complex.
Complex Conditional,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,IsStructural,The conditional expression  "this.UseGenerics && (type.IsGeneric || type.Template != null && type.Template.IsGeneric)"  is complex.
Complex Conditional,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetTypeToken,The conditional expression  "this.IsStructural(type) && (!type.IsGeneric || (type.ConsolidatedTemplateArguments != null && type.ConsolidatedTemplateArguments.Count > 0))"  is complex.
Complex Conditional,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetTypeDefToken,The conditional expression  "this.IsStructural(type) && (!type.IsGeneric || (type.Template != null && type.ConsolidatedTemplateArguments != null && type.ConsolidatedTemplateArguments.Count > 0))"  is complex.
Complex Conditional,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateConstantTable,The conditional expression  "t is Reference || ((t != p.Type || t == SystemTypes.Object)&& Literal.IsNullLiteral(p.DefaultValue))"  is complex.
Complex Conditional,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateCustomAttributeTable,The conditional expression  "this.IsStructural(t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0))"  is complex.
Complex Conditional,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateMethodTable,The conditional expression  "m.IsAbstract || m.Body == null || m.Body.Statements == null || m.Body.Statements.Count == 0"  is complex.
Complex Conditional,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitAssignmentStatement,The conditional expression  "adrType != null && (adrType.IsValueType ||                  this.UseGenerics && (adrType is ITypeParameter))"  is complex.
Complex Conditional,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitLiteral,The conditional expression  "n >= System.Int32.MinValue && n <= System.Int32.MaxValue ||                  n <= System.UInt32.MaxValue && (tc == TypeCode.Char || tc == TypeCode.UInt16 || tc == TypeCode.UInt32)"  is complex.
Complex Conditional,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitMethodBody,The conditional expression  "eh == null || eh.HandlerStartBlock == null || (eh.HandlerType != NodeType.Catch && eh.HandlerType != NodeType.Filter)"  is complex.
Complex Conditional,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitMethodBody,The conditional expression  "tryOffset > 0xffff || tryLength > 0xff || handlerOffset > 0xffff || handlerLength > 0xff"  is complex.
Complex Conditional,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,DefineSequencePoint,The conditional expression  "this.symWriter != null && node != null && node.SourceContext.Document != null && !node.SourceContext.Document.Hidden"  is complex.
Complex Conditional,Microsoft.Cci,Writer,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,ParseVersion,The conditional expression  "major == UInt16.MaxValue && minor == UInt16.MaxValue && build == UInt16.MaxValue && revision == UInt16.MaxValue"  is complex.
Complex Conditional,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WriteWin32Resources,The conditional expression  "typeDifferent || (r.Id < 0 && r.Name != lastName) || r.Id > lastID"  is complex.
Complex Conditional,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetCachedAssembly,The conditional expression  "aRef != null && assemblyReference.Version != null && aRef.Version >= assemblyReference.Version && aRef.MatchesIgnoringVersion(assemblyReference)"  is complex.
Complex Conditional,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetCachedAssembly,The conditional expression  "aRef == null && assembly.FileLastWriteTimeUtc > cachedAssembly.FileLastWriteTimeUtc &&                assembly.Location != null && cachedAssembly.Location != null && assembly.Location == cachedAssembly.Location"  is complex.
Complex Conditional,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetCachedAssembly,The conditional expression  "assembly.FileLastWriteTimeUtc > cachedAssembly.FileLastWriteTimeUtc &&                assembly.Location != null && cachedAssembly.Location != null && assembly.Location == cachedAssembly.Location"  is complex.
Complex Conditional,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetAssemblyFromReference,The conditional expression  "SystemAssemblyLocation.ParsedAssembly != null && (assemblyReference.Name == "mscorlib" || assemblyReference.Name == "basetypes" || assemblyReference.Name == "ioconfig"            || assemblyReference.Name == "singularity.v1" )"  is complex.
Complex Conditional,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetAssemblyFromReference,The conditional expression  "aRef != null && assemblyReference.Version != null && aRef.Version >= assemblyReference.Version && aRef.MatchesIgnoringVersion(assemblyReference)"  is complex.
Complex Conditional,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseSimpleTypeName,The conditional expression  "ch == '.' || ch == '+' || ch == '&' || ch == '*' || ch == '[' || ch == '!'"  is complex.
Complex Conditional,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetMemberFromRef,The conditional expression  "typeParamCount != int.MinValue && (!m.IsGeneric || m.TemplateParameters == null || m.TemplateParameters.Count != typeParamCount)"  is complex.
Complex Conditional,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetDummyTypeNode,The conditional expression  "name != null && name.ToString().StartsWith("I") && name.ToString().Length > 1 && char.IsUpper(name.ToString()[1])"  is complex.
Complex Conditional,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,CanCacheTypeNode,The conditional expression  "!type.IsGeneric && (type.Template == null || !type.IsNotFullySpecialized) &&        type.NodeType != NodeType.TypeParameter && type.NodeType != NodeType.ClassParameter &&        type.NodeType != NodeType.InterfaceExpression"  is complex.
Virtual Method Call from Constructor,Microsoft.Cci,SourceContext,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,SourceContext,The constructor "SourceContext" calls a virtual method "GetOffsets".
Virtual Method Call from Constructor,Microsoft.Cci,ConstructArray,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,ConstructArray,The constructor "ConstructArray" calls a virtual method "GetArrayType".
Virtual Method Call from Constructor,Microsoft.Cci,ConstructArray,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,ConstructArray,The constructor "ConstructArray" calls a virtual method "GetArrayType".
Empty Catch Block,Microsoft.Cci,GlobalAssemblyCache,C:\repos\Reactive-Extensions_IL2JS\CCI\AssemblyCache.cs,Contains,The method has an empty catch block.
Empty Catch Block,Microsoft.Cci,CollectibleSourceText,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,ReadFile,The method has an empty catch block.
Empty Catch Block,Microsoft.Cci,Node,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetVisitorFor,The method has an empty catch block.
Empty Catch Block,Microsoft.Cci,Node,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetVisitorFor,The method has an empty catch block.
Empty Catch Block,Microsoft.Cci,Node,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetVisitorFor,The method has an empty catch block.
Empty Catch Block,Microsoft.Cci,AttributeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,SetAttributeProperty,The method has an empty catch block.
Empty Catch Block,Microsoft.Cci,AttributeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,ConstructAttribute,The method has an empty catch block.
Empty Catch Block,Microsoft.Cci,SecurityAttribute,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,CreatePermission,The method has an empty catch block.
Empty Catch Block,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateFileTable,The method has an empty catch block.
Empty Catch Block,Microsoft.Cci,Writer,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetPublicKey,The method has an empty catch block.
Empty Catch Block,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetPermissionAttribute2,The method has an empty catch block.
Empty Catch Block,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetMethodDebugSymbols,The method has an empty catch block.
Empty Catch Block,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetMethodDebugSymbols,The method has an empty catch block.
Empty Catch Block,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetMethodDebugSymbols,The method has an empty catch block.
Empty Catch Block,Microsoft.Cci.Metadata,ILParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseHeader,The method has an empty catch block.
Empty Catch Block,Microsoft.Cci.Metadata,ILParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseHeader,The method has an empty catch block.
Empty Catch Block,Microsoft.Cci.Metadata,ILParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseHeader,The method has an empty catch block.
Magic Number,Microsoft.Cci,GlobalAssemblyCache,C:\repos\Reactive-Extensions_IL2JS\CCI\AssemblyCache.cs,GetLocation,The following statement contains a magic number: lock(GlobalAssemblyCache.Lock){          if (!GlobalAssemblyCache.FusionLoaded){            GlobalAssemblyCache.FusionLoaded = true;            System.Reflection.Assembly systemAssembly = typeof(object).Assembly;            //^ assume systemAssembly != null && systemAssembly.Location != null;            string dir = Path.GetDirectoryName(systemAssembly.Location);            //^ assume dir != null;            GlobalAssemblyCache.LoadLibrary(Path.Combine(dir' "fusion.dll"));          }          IAssemblyEnum assemblyEnum;          CreateAssemblyEnum(out assemblyEnum' null' null' ASM_CACHE.GAC' 0);          if (assemblyEnum == null) return null;          IApplicationContext applicationContext;          IAssemblyName currentName;          while (assemblyEnum.GetNextAssembly(out applicationContext' out currentName' 0) == 0){            //^ assume currentName != null;            AssemblyName aName = new AssemblyName(currentName);            if (assemblyReference.Matches(aName.Name' aName.Version' aName.Culture' aName.PublicKeyToken)){              string codeBase = aName.CodeBase;              if (codeBase != null && codeBase.StartsWith("file:///"))                return codeBase.Substring(8);              return aName.GetLocation();            }          }          return null;        }
Magic Number,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The following statement contains a magic number: for (int j = list2start' m = list2.Count; j < m; j++){          AttributeNode nd2 = list2[j];          if (list2start == j) list2start++;          if (nd2 == null) continue;          if (matchedNodes[nd2.UniqueKey] != null) continue;          Differences diff = this.GetDifferences(nd1' nd2);          if (diff == null){Debug.Assert(false); continue;}          if (diff.Similarity <= 0.5){            //Not a good enough match            if (list2start == j+1) list2start--; //The next call to GetClosestMatch will start looking at list2start' so this node will be considered then            continue; //ignore it for the rest of this call          }          if (winnerSoFar != null && winnerSoFar.Similarity >= diff.Similarity) continue;          winnerSoFar = closestDifferences = diff;          closest = nd2;          list2pos = j;          if (diff.NumberOfDifferences == 0) return closest; //Perfect match' no need to look for other matches        }
Magic Number,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The following statement contains a magic number: for (int j = list2start' m = list2.Count; j < m; j++){          Block nd2 = list2[j];          if (list2start == j) list2start++;          if (nd2 == null) continue;          if (matchedNodes[nd2.UniqueKey] != null) continue;          Differences diff = this.GetDifferences(nd1' nd2);          if (diff == null){Debug.Assert(false); continue;}          if (diff.Similarity <= 0.5){            //Not a good enough match            if (list2start == j+1) list2start--; //The next call to GetClosestMatch will start looking at list2start' so this node will be considered then            continue; //ignore it for the rest of this call          }          if (winnerSoFar != null && winnerSoFar.Similarity >= diff.Similarity) continue;          winnerSoFar = closestDifferences = diff;          closest = nd2;          list2pos = j;          if (diff.NumberOfDifferences == 0) return closest; //Perfect match' no need to look for other matches        }
Magic Number,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The following statement contains a magic number: for (int j = list2start' m = list2.Count; j < m; j++){          Catch nd2 = list2[j];          if (list2start == j) list2start++;          if (nd2 == null) continue;          if (matchedNodes[nd2.UniqueKey] != null) continue;          Differences diff = this.GetDifferences(nd1' nd2);          if (diff == null){Debug.Assert(false); continue;}          if (diff.Similarity <= 0.5){            //Not a good enough match            if (list2start == j+1) list2start--; //The next call to GetClosestMatch will start looking at list2start' so this node will be considered then            continue; //ignore it for the rest of this call          }          if (winnerSoFar != null && winnerSoFar.Similarity >= diff.Similarity) continue;          winnerSoFar = closestDifferences = diff;          closest = nd2;          list2pos = j;          if (diff.NumberOfDifferences == 0) return closest; //Perfect match' no need to look for other matches        }
Magic Number,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The following statement contains a magic number: for (int j = list2start' m = list2.Count; j < m; j++){          Expression nd2 = list2[j];          if (list2start == j) list2start++;          if (nd2 == null) continue;          if (matchedNodes[nd2.UniqueKey] != null) continue;          Differences diff = this.GetDifferences(nd1' nd2);          if (diff == null){Debug.Assert(false); continue;}          if (diff.Similarity <= 0.5){            //Not a good enough match            if (list2start == j+1) list2start--; //The next call to GetClosestMatch will start looking at list2start' so this node will be considered then            continue; //ignore it for the rest of this call          }          if (winnerSoFar != null && winnerSoFar.Similarity >= diff.Similarity) continue;          winnerSoFar = closestDifferences = diff;          closest = nd2;          list2pos = j;          if (diff.NumberOfDifferences == 0) return closest; //Perfect match' no need to look for other matches        }
Magic Number,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The following statement contains a magic number: for (int j = list2start' m = list2.Count; j < m; j++){          FaultHandler nd2 = list2[j];          if (list2start == j) list2start++;          if (nd2 == null) continue;          if (matchedNodes[nd2.UniqueKey] != null) continue;          Differences diff = this.GetDifferences(nd1' nd2);          if (diff == null){Debug.Assert(false); continue;}          if (diff.Similarity <= 0.5){            //Not a good enough match            if (list2start == j+1) list2start--; //The next call to GetClosestMatch will start looking at list2start' so this node will be considered then            continue; //ignore it for the rest of this call          }          if (winnerSoFar != null && winnerSoFar.Similarity >= diff.Similarity) continue;          winnerSoFar = closestDifferences = diff;          closest = nd2;          list2pos = j;          if (diff.NumberOfDifferences == 0) return closest; //Perfect match' no need to look for other matches        }
Magic Number,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The following statement contains a magic number: for (int j = list2start' m = list2.Count; j < m; j++){          Filter nd2 = list2[j];          if (list2start == j) list2start++;          if (nd2 == null) continue;          if (matchedNodes[nd2.UniqueKey] != null) continue;          Differences diff = this.GetDifferences(nd1' nd2);          if (diff == null){Debug.Assert(false); continue;}          if (diff.Similarity <= 0.5){            //Not a good enough match            if (list2start == j+1) list2start--; //The next call to GetClosestMatch will start looking at list2start' so this node will be considered then            continue; //ignore it for the rest of this call          }          if (winnerSoFar != null && winnerSoFar.Similarity >= diff.Similarity) continue;          winnerSoFar = closestDifferences = diff;          closest = nd2;          list2pos = j;          if (diff.NumberOfDifferences == 0) return closest; //Perfect match' no need to look for other matches        }
Magic Number,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The following statement contains a magic number: for (int j = list2start' m = list2.Count; j < m; j++){          LocalDeclaration nd2 = list2[j];          if (list2start == j) list2start++;          if (nd2 == null) continue;          if (matchedNodes[nd2.UniqueKey] != null) continue;          Differences diff = this.GetDifferences(nd1' nd2);          if (diff == null){Debug.Assert(false); continue;}          if (diff.Similarity <= 0.5){            //Not a good enough match            if (list2start == j+1) list2start--; //The next call to GetClosestMatch will start looking at list2start' so this node will be considered then            continue; //ignore it for the rest of this call          }          if (winnerSoFar != null && winnerSoFar.Similarity >= diff.Similarity) continue;          winnerSoFar = closestDifferences = diff;          closest = nd2;          list2pos = j;          if (diff.NumberOfDifferences == 0) return closest; //Perfect match' no need to look for other matches        }
Magic Number,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The following statement contains a magic number: for (int j = list2start' m = list2.Count; j < m; j++){          Node nd2 = list2[j];          if (list2start == j) list2start++;          if (nd2 == null) continue;          if (matchedNodes[nd2.UniqueKey] != null) continue;          Differences diff = this.GetDifferences(nd1' nd2);          if (diff == null){Debug.Assert(false); continue;}          if (diff.Similarity <= 0.5){            //Not a good enough match            if (list2start == j+1) list2start--; //The next call to GetClosestMatch will start looking at list2start' so this node will be considered then            continue; //ignore it for the rest of this call          }          if (winnerSoFar != null && winnerSoFar.Similarity >= diff.Similarity) continue;          winnerSoFar = closestDifferences = diff;          closest = nd2;          list2pos = j;          if (diff.NumberOfDifferences == 0) return closest; //Perfect match' no need to look for other matches        }
Magic Number,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The following statement contains a magic number: for (int j = list2start' m = list2.Count; j < m; j++){          SecurityAttribute nd2 = list2[j];          if (list2start == j) list2start++;          if (nd2 == null) continue;          if (matchedNodes[nd2.UniqueKey] != null) continue;          Differences diff = this.GetDifferences(nd1' nd2);          if (diff == null){Debug.Assert(false); continue;}          if (diff.Similarity <= 0.5){            //Not a good enough match            if (list2start == j+1) list2start--; //The next call to GetClosestMatch will start looking at list2start' so this node will be considered then            continue; //ignore it for the rest of this call          }          if (winnerSoFar != null && winnerSoFar.Similarity >= diff.Similarity) continue;          winnerSoFar = closestDifferences = diff;          closest = nd2;          list2pos = j;          if (diff.NumberOfDifferences == 0) return closest; //Perfect match' no need to look for other matches        }
Magic Number,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The following statement contains a magic number: for (int j = list2start' m = list2.Count; j < m; j++){          Statement nd2 = list2[j];          if (list2start == j) list2start++;          if (nd2 == null) continue;          if (matchedNodes[nd2.UniqueKey] != null) continue;          Differences diff = this.GetDifferences(nd1' nd2);          if (diff == null){Debug.Assert(false); continue;}          if (diff.Similarity <= 0.5){            //Not a good enough match            if (list2start == j+1) list2start--; //The next call to GetClosestMatch will start looking at list2start' so this node will be considered then            continue; //ignore it for the rest of this call          }          if (winnerSoFar != null && winnerSoFar.Similarity >= diff.Similarity) continue;          winnerSoFar = closestDifferences = diff;          closest = nd2;          list2pos = j;          if (diff.NumberOfDifferences == 0) return closest; //Perfect match' no need to look for other matches        }
Magic Number,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The following statement contains a magic number: for (int j = list2start' m = list2.Count; j < m; j++){          SwitchCase nd2 = list2[j];          if (list2start == j) list2start++;          if (nd2 == null) continue;          if (matchedNodes[nd2.UniqueKey] != null) continue;          Differences diff = this.GetDifferences(nd1' nd2);          if (diff == null){Debug.Assert(false); continue;}          if (diff.Similarity <= 0.5){            //Not a good enough match            if (list2start == j+1) list2start--; //The next call to GetClosestMatch will start looking at list2start' so this node will be considered then            continue; //ignore it for the rest of this call          }          if (winnerSoFar != null && winnerSoFar.Similarity >= diff.Similarity) continue;          winnerSoFar = closestDifferences = diff;          closest = nd2;          list2pos = j;          if (diff.NumberOfDifferences == 0) return closest; //Perfect match' no need to look for other matches        }
Magic Number,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The following statement contains a magic number: for (int j = list2start' m = list2.Count; j < m; j++){          TypeswitchCase nd2 = list2[j];          if (list2start == j) list2start++;          if (nd2 == null) continue;          if (matchedNodes[nd2.UniqueKey] != null) continue;          Differences diff = this.GetDifferences(nd1' nd2);          if (diff == null){Debug.Assert(false); continue;}          if (diff.Similarity <= 0.5){            //Not a good enough match            if (list2start == j+1) list2start--; //The next call to GetClosestMatch will start looking at list2start' so this node will be considered then            continue; //ignore it for the rest of this call          }          if (winnerSoFar != null && winnerSoFar.Similarity >= diff.Similarity) continue;          winnerSoFar = closestDifferences = diff;          closest = nd2;          list2pos = j;          if (diff.NumberOfDifferences == 0) return closest; //Perfect match' no need to look for other matches        }
Magic Number,Microsoft.Cci,Comparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Comparer.cs,GetClosestMatch,The following statement contains a magic number: for (int j = list2start' m = list2.Count; j < m; j++){          UsedNamespace nd2 = list2[j];          if (list2start == j) list2start++;          if (nd2 == null) continue;          if (matchedNodes[nd2.UniqueKey] != null) continue;          Differences diff = this.GetDifferences(nd1' nd2);          if (diff == null){Debug.Assert(false); continue;}          if (diff.Similarity <= 0.5){            //Not a good enough match            if (list2start == j+1) list2start--; //The next call to GetClosestMatch will start looking at list2start' so this node will be considered then            continue; //ignore it for the rest of this call          }          if (winnerSoFar != null && winnerSoFar.Similarity >= diff.Similarity) continue;          winnerSoFar = closestDifferences = diff;          closest = nd2;          list2pos = j;          if (diff.NumberOfDifferences == 0) return closest; //Perfect match' no need to look for other matches        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8){          if (ch < 0x80){            m.Position = i+1;            m.Buffer[i] = (byte)ch;          }else            this.Write(new char[]{ch});        }else{          m.Position = i+2;          byte[] buffer = m.Buffer;          buffer[i++] = (byte)ch;          buffer[i] = (byte)(ch >> 8);        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8){          if (ch < 0x80){            m.Position = i+1;            m.Buffer[i] = (byte)ch;          }else            this.Write(new char[]{ch});        }else{          m.Position = i+2;          byte[] buffer = m.Buffer;          buffer[i++] = (byte)ch;          buffer[i] = (byte)(ch >> 8);        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8){          m.Position = i+n;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++){            char ch = chars[j];            if ((ch & 0x80) != 0) goto writeUTF8;            buffer[i++] = (byte)ch;          }          return;        writeUTF8:          int ch32 = 0;          for (int j = n-(m.Position-i); j < n; j++){            char ch = chars[j];            if (ch < 0x80){              m.Position = i+1;              buffer = m.Buffer;              buffer[i++] = (byte)ch;            }else if (ch < 0x800){              m.Position = i+2;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>6) & 0x1F) | 0xC0);              buffer[i] = (byte)((ch & 0x3F) | 0x80);            }else if (0xD800 <= ch && ch <= 0xDBFF){              ch32 = (ch & 0x3FF) << 10;            }else if (0xDC00 <= ch && ch <= 0xDFFF){              ch32 |= ch & 0x3FF;              m.Position = i+4;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch32>>18) & 0x7) | 0xF0);              buffer[i++] = (byte)(((ch32>>12) & 0x3F) | 0x80);              buffer[i++] = (byte)(((ch32>>6) & 0x3F) | 0x80);              buffer[i] = (byte)((ch32 & 0x3F) | 0x80);                        }else{              m.Position = i+3;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>12) & 0xF) | 0xE0);              buffer[i++] = (byte)(((ch>>6) & 0x3F) | 0x80);              buffer[i] = (byte)((ch & 0x3F) | 0x80);            }          }        }else{          m.Position = i+n*2;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++){            char ch = chars[j];            buffer[i++] = (byte)ch;            buffer[i++] = (byte)(ch >> 8);          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8){          m.Position = i+n;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++){            char ch = chars[j];            if ((ch & 0x80) != 0) goto writeUTF8;            buffer[i++] = (byte)ch;          }          return;        writeUTF8:          int ch32 = 0;          for (int j = n-(m.Position-i); j < n; j++){            char ch = chars[j];            if (ch < 0x80){              m.Position = i+1;              buffer = m.Buffer;              buffer[i++] = (byte)ch;            }else if (ch < 0x800){              m.Position = i+2;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>6) & 0x1F) | 0xC0);              buffer[i] = (byte)((ch & 0x3F) | 0x80);            }else if (0xD800 <= ch && ch <= 0xDBFF){              ch32 = (ch & 0x3FF) << 10;            }else if (0xDC00 <= ch && ch <= 0xDFFF){              ch32 |= ch & 0x3FF;              m.Position = i+4;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch32>>18) & 0x7) | 0xF0);              buffer[i++] = (byte)(((ch32>>12) & 0x3F) | 0x80);              buffer[i++] = (byte)(((ch32>>6) & 0x3F) | 0x80);              buffer[i] = (byte)((ch32 & 0x3F) | 0x80);                        }else{              m.Position = i+3;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>12) & 0xF) | 0xE0);              buffer[i++] = (byte)(((ch>>6) & 0x3F) | 0x80);              buffer[i] = (byte)((ch & 0x3F) | 0x80);            }          }        }else{          m.Position = i+n*2;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++){            char ch = chars[j];            buffer[i++] = (byte)ch;            buffer[i++] = (byte)(ch >> 8);          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8){          m.Position = i+n;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++){            char ch = chars[j];            if ((ch & 0x80) != 0) goto writeUTF8;            buffer[i++] = (byte)ch;          }          return;        writeUTF8:          int ch32 = 0;          for (int j = n-(m.Position-i); j < n; j++){            char ch = chars[j];            if (ch < 0x80){              m.Position = i+1;              buffer = m.Buffer;              buffer[i++] = (byte)ch;            }else if (ch < 0x800){              m.Position = i+2;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>6) & 0x1F) | 0xC0);              buffer[i] = (byte)((ch & 0x3F) | 0x80);            }else if (0xD800 <= ch && ch <= 0xDBFF){              ch32 = (ch & 0x3FF) << 10;            }else if (0xDC00 <= ch && ch <= 0xDFFF){              ch32 |= ch & 0x3FF;              m.Position = i+4;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch32>>18) & 0x7) | 0xF0);              buffer[i++] = (byte)(((ch32>>12) & 0x3F) | 0x80);              buffer[i++] = (byte)(((ch32>>6) & 0x3F) | 0x80);              buffer[i] = (byte)((ch32 & 0x3F) | 0x80);                        }else{              m.Position = i+3;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>12) & 0xF) | 0xE0);              buffer[i++] = (byte)(((ch>>6) & 0x3F) | 0x80);              buffer[i] = (byte)((ch & 0x3F) | 0x80);            }          }        }else{          m.Position = i+n*2;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++){            char ch = chars[j];            buffer[i++] = (byte)ch;            buffer[i++] = (byte)(ch >> 8);          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8){          m.Position = i+n;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++){            char ch = chars[j];            if ((ch & 0x80) != 0) goto writeUTF8;            buffer[i++] = (byte)ch;          }          return;        writeUTF8:          int ch32 = 0;          for (int j = n-(m.Position-i); j < n; j++){            char ch = chars[j];            if (ch < 0x80){              m.Position = i+1;              buffer = m.Buffer;              buffer[i++] = (byte)ch;            }else if (ch < 0x800){              m.Position = i+2;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>6) & 0x1F) | 0xC0);              buffer[i] = (byte)((ch & 0x3F) | 0x80);            }else if (0xD800 <= ch && ch <= 0xDBFF){              ch32 = (ch & 0x3FF) << 10;            }else if (0xDC00 <= ch && ch <= 0xDFFF){              ch32 |= ch & 0x3FF;              m.Position = i+4;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch32>>18) & 0x7) | 0xF0);              buffer[i++] = (byte)(((ch32>>12) & 0x3F) | 0x80);              buffer[i++] = (byte)(((ch32>>6) & 0x3F) | 0x80);              buffer[i] = (byte)((ch32 & 0x3F) | 0x80);                        }else{              m.Position = i+3;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>12) & 0xF) | 0xE0);              buffer[i++] = (byte)(((ch>>6) & 0x3F) | 0x80);              buffer[i] = (byte)((ch & 0x3F) | 0x80);            }          }        }else{          m.Position = i+n*2;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++){            char ch = chars[j];            buffer[i++] = (byte)ch;            buffer[i++] = (byte)(ch >> 8);          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8){          m.Position = i+n;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++){            char ch = chars[j];            if ((ch & 0x80) != 0) goto writeUTF8;            buffer[i++] = (byte)ch;          }          return;        writeUTF8:          int ch32 = 0;          for (int j = n-(m.Position-i); j < n; j++){            char ch = chars[j];            if (ch < 0x80){              m.Position = i+1;              buffer = m.Buffer;              buffer[i++] = (byte)ch;            }else if (ch < 0x800){              m.Position = i+2;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>6) & 0x1F) | 0xC0);              buffer[i] = (byte)((ch & 0x3F) | 0x80);            }else if (0xD800 <= ch && ch <= 0xDBFF){              ch32 = (ch & 0x3FF) << 10;            }else if (0xDC00 <= ch && ch <= 0xDFFF){              ch32 |= ch & 0x3FF;              m.Position = i+4;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch32>>18) & 0x7) | 0xF0);              buffer[i++] = (byte)(((ch32>>12) & 0x3F) | 0x80);              buffer[i++] = (byte)(((ch32>>6) & 0x3F) | 0x80);              buffer[i] = (byte)((ch32 & 0x3F) | 0x80);                        }else{              m.Position = i+3;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>12) & 0xF) | 0xE0);              buffer[i++] = (byte)(((ch>>6) & 0x3F) | 0x80);              buffer[i] = (byte)((ch & 0x3F) | 0x80);            }          }        }else{          m.Position = i+n*2;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++){            char ch = chars[j];            buffer[i++] = (byte)ch;            buffer[i++] = (byte)(ch >> 8);          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8){          m.Position = i+n;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++){            char ch = chars[j];            if ((ch & 0x80) != 0) goto writeUTF8;            buffer[i++] = (byte)ch;          }          return;        writeUTF8:          int ch32 = 0;          for (int j = n-(m.Position-i); j < n; j++){            char ch = chars[j];            if (ch < 0x80){              m.Position = i+1;              buffer = m.Buffer;              buffer[i++] = (byte)ch;            }else if (ch < 0x800){              m.Position = i+2;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>6) & 0x1F) | 0xC0);              buffer[i] = (byte)((ch & 0x3F) | 0x80);            }else if (0xD800 <= ch && ch <= 0xDBFF){              ch32 = (ch & 0x3FF) << 10;            }else if (0xDC00 <= ch && ch <= 0xDFFF){              ch32 |= ch & 0x3FF;              m.Position = i+4;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch32>>18) & 0x7) | 0xF0);              buffer[i++] = (byte)(((ch32>>12) & 0x3F) | 0x80);              buffer[i++] = (byte)(((ch32>>6) & 0x3F) | 0x80);              buffer[i] = (byte)((ch32 & 0x3F) | 0x80);                        }else{              m.Position = i+3;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>12) & 0xF) | 0xE0);              buffer[i++] = (byte)(((ch>>6) & 0x3F) | 0x80);              buffer[i] = (byte)((ch & 0x3F) | 0x80);            }          }        }else{          m.Position = i+n*2;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++){            char ch = chars[j];            buffer[i++] = (byte)ch;            buffer[i++] = (byte)(ch >> 8);          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8){          m.Position = i+n;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++){            char ch = chars[j];            if ((ch & 0x80) != 0) goto writeUTF8;            buffer[i++] = (byte)ch;          }          return;        writeUTF8:          int ch32 = 0;          for (int j = n-(m.Position-i); j < n; j++){            char ch = chars[j];            if (ch < 0x80){              m.Position = i+1;              buffer = m.Buffer;              buffer[i++] = (byte)ch;            }else if (ch < 0x800){              m.Position = i+2;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>6) & 0x1F) | 0xC0);              buffer[i] = (byte)((ch & 0x3F) | 0x80);            }else if (0xD800 <= ch && ch <= 0xDBFF){              ch32 = (ch & 0x3FF) << 10;            }else if (0xDC00 <= ch && ch <= 0xDFFF){              ch32 |= ch & 0x3FF;              m.Position = i+4;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch32>>18) & 0x7) | 0xF0);              buffer[i++] = (byte)(((ch32>>12) & 0x3F) | 0x80);              buffer[i++] = (byte)(((ch32>>6) & 0x3F) | 0x80);              buffer[i] = (byte)((ch32 & 0x3F) | 0x80);                        }else{              m.Position = i+3;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>12) & 0xF) | 0xE0);              buffer[i++] = (byte)(((ch>>6) & 0x3F) | 0x80);              buffer[i] = (byte)((ch & 0x3F) | 0x80);            }          }        }else{          m.Position = i+n*2;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++){            char ch = chars[j];            buffer[i++] = (byte)ch;            buffer[i++] = (byte)(ch >> 8);          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8){          m.Position = i+n;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++){            char ch = chars[j];            if ((ch & 0x80) != 0) goto writeUTF8;            buffer[i++] = (byte)ch;          }          return;        writeUTF8:          int ch32 = 0;          for (int j = n-(m.Position-i); j < n; j++){            char ch = chars[j];            if (ch < 0x80){              m.Position = i+1;              buffer = m.Buffer;              buffer[i++] = (byte)ch;            }else if (ch < 0x800){              m.Position = i+2;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>6) & 0x1F) | 0xC0);              buffer[i] = (byte)((ch & 0x3F) | 0x80);            }else if (0xD800 <= ch && ch <= 0xDBFF){              ch32 = (ch & 0x3FF) << 10;            }else if (0xDC00 <= ch && ch <= 0xDFFF){              ch32 |= ch & 0x3FF;              m.Position = i+4;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch32>>18) & 0x7) | 0xF0);              buffer[i++] = (byte)(((ch32>>12) & 0x3F) | 0x80);              buffer[i++] = (byte)(((ch32>>6) & 0x3F) | 0x80);              buffer[i] = (byte)((ch32 & 0x3F) | 0x80);                        }else{              m.Position = i+3;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>12) & 0xF) | 0xE0);              buffer[i++] = (byte)(((ch>>6) & 0x3F) | 0x80);              buffer[i] = (byte)((ch & 0x3F) | 0x80);            }          }        }else{          m.Position = i+n*2;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++){            char ch = chars[j];            buffer[i++] = (byte)ch;            buffer[i++] = (byte)(ch >> 8);          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8){          m.Position = i+n;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++){            char ch = chars[j];            if ((ch & 0x80) != 0) goto writeUTF8;            buffer[i++] = (byte)ch;          }          return;        writeUTF8:          int ch32 = 0;          for (int j = n-(m.Position-i); j < n; j++){            char ch = chars[j];            if (ch < 0x80){              m.Position = i+1;              buffer = m.Buffer;              buffer[i++] = (byte)ch;            }else if (ch < 0x800){              m.Position = i+2;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>6) & 0x1F) | 0xC0);              buffer[i] = (byte)((ch & 0x3F) | 0x80);            }else if (0xD800 <= ch && ch <= 0xDBFF){              ch32 = (ch & 0x3FF) << 10;            }else if (0xDC00 <= ch && ch <= 0xDFFF){              ch32 |= ch & 0x3FF;              m.Position = i+4;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch32>>18) & 0x7) | 0xF0);              buffer[i++] = (byte)(((ch32>>12) & 0x3F) | 0x80);              buffer[i++] = (byte)(((ch32>>6) & 0x3F) | 0x80);              buffer[i] = (byte)((ch32 & 0x3F) | 0x80);                        }else{              m.Position = i+3;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>12) & 0xF) | 0xE0);              buffer[i++] = (byte)(((ch>>6) & 0x3F) | 0x80);              buffer[i] = (byte)((ch & 0x3F) | 0x80);            }          }        }else{          m.Position = i+n*2;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++){            char ch = chars[j];            buffer[i++] = (byte)ch;            buffer[i++] = (byte)(ch >> 8);          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8){          m.Position = i+n;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++){            char ch = chars[j];            if ((ch & 0x80) != 0) goto writeUTF8;            buffer[i++] = (byte)ch;          }          return;        writeUTF8:          int ch32 = 0;          for (int j = n-(m.Position-i); j < n; j++){            char ch = chars[j];            if (ch < 0x80){              m.Position = i+1;              buffer = m.Buffer;              buffer[i++] = (byte)ch;            }else if (ch < 0x800){              m.Position = i+2;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>6) & 0x1F) | 0xC0);              buffer[i] = (byte)((ch & 0x3F) | 0x80);            }else if (0xD800 <= ch && ch <= 0xDBFF){              ch32 = (ch & 0x3FF) << 10;            }else if (0xDC00 <= ch && ch <= 0xDFFF){              ch32 |= ch & 0x3FF;              m.Position = i+4;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch32>>18) & 0x7) | 0xF0);              buffer[i++] = (byte)(((ch32>>12) & 0x3F) | 0x80);              buffer[i++] = (byte)(((ch32>>6) & 0x3F) | 0x80);              buffer[i] = (byte)((ch32 & 0x3F) | 0x80);                        }else{              m.Position = i+3;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>12) & 0xF) | 0xE0);              buffer[i++] = (byte)(((ch>>6) & 0x3F) | 0x80);              buffer[i] = (byte)((ch & 0x3F) | 0x80);            }          }        }else{          m.Position = i+n*2;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++){            char ch = chars[j];            buffer[i++] = (byte)ch;            buffer[i++] = (byte)(ch >> 8);          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8){          m.Position = i+n;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++){            char ch = chars[j];            if ((ch & 0x80) != 0) goto writeUTF8;            buffer[i++] = (byte)ch;          }          return;        writeUTF8:          int ch32 = 0;          for (int j = n-(m.Position-i); j < n; j++){            char ch = chars[j];            if (ch < 0x80){              m.Position = i+1;              buffer = m.Buffer;              buffer[i++] = (byte)ch;            }else if (ch < 0x800){              m.Position = i+2;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>6) & 0x1F) | 0xC0);              buffer[i] = (byte)((ch & 0x3F) | 0x80);            }else if (0xD800 <= ch && ch <= 0xDBFF){              ch32 = (ch & 0x3FF) << 10;            }else if (0xDC00 <= ch && ch <= 0xDFFF){              ch32 |= ch & 0x3FF;              m.Position = i+4;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch32>>18) & 0x7) | 0xF0);              buffer[i++] = (byte)(((ch32>>12) & 0x3F) | 0x80);              buffer[i++] = (byte)(((ch32>>6) & 0x3F) | 0x80);              buffer[i] = (byte)((ch32 & 0x3F) | 0x80);                        }else{              m.Position = i+3;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>12) & 0xF) | 0xE0);              buffer[i++] = (byte)(((ch>>6) & 0x3F) | 0x80);              buffer[i] = (byte)((ch & 0x3F) | 0x80);            }          }        }else{          m.Position = i+n*2;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++){            char ch = chars[j];            buffer[i++] = (byte)ch;            buffer[i++] = (byte)(ch >> 8);          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8){          m.Position = i+n;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++){            char ch = chars[j];            if ((ch & 0x80) != 0) goto writeUTF8;            buffer[i++] = (byte)ch;          }          return;        writeUTF8:          int ch32 = 0;          for (int j = n-(m.Position-i); j < n; j++){            char ch = chars[j];            if (ch < 0x80){              m.Position = i+1;              buffer = m.Buffer;              buffer[i++] = (byte)ch;            }else if (ch < 0x800){              m.Position = i+2;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>6) & 0x1F) | 0xC0);              buffer[i] = (byte)((ch & 0x3F) | 0x80);            }else if (0xD800 <= ch && ch <= 0xDBFF){              ch32 = (ch & 0x3FF) << 10;            }else if (0xDC00 <= ch && ch <= 0xDFFF){              ch32 |= ch & 0x3FF;              m.Position = i+4;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch32>>18) & 0x7) | 0xF0);              buffer[i++] = (byte)(((ch32>>12) & 0x3F) | 0x80);              buffer[i++] = (byte)(((ch32>>6) & 0x3F) | 0x80);              buffer[i] = (byte)((ch32 & 0x3F) | 0x80);                        }else{              m.Position = i+3;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>12) & 0xF) | 0xE0);              buffer[i++] = (byte)(((ch>>6) & 0x3F) | 0x80);              buffer[i] = (byte)((ch & 0x3F) | 0x80);            }          }        }else{          m.Position = i+n*2;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++){            char ch = chars[j];            buffer[i++] = (byte)ch;            buffer[i++] = (byte)(ch >> 8);          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: m.Position=i+8;
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: m.Position=i+2;
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer[i] = (byte)(value >> 8);
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: m.Position=i+2;
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer[i] = (byte)(value >> 8);
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: m.Position=i+4;
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer[i++] = (byte)(value >> 8);
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer[i++] = (byte)(value >> 16);
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer[i] = (byte)(value >> 24);
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: m.Position=i+4;
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer[i++] = (byte)(value >> 8);
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer[i++] = (byte)(value >> 16);
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer[i] = (byte)(value >> 24);
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: m.Position=i+8;
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: uint hi = (uint)(value >> 32);
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer[i++] = (byte)(lo >> 8);
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer[i++] = (byte)(lo >> 16);
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer[i++] = (byte)(lo >> 24);
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer[i++] = (byte)(hi >> 8);
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer[i++] = (byte)(hi >> 16);
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer[i] = (byte)(hi >> 24);
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: m.Position=i+8;
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: uint hi = (uint)(value >> 32);
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer[i++] = (byte)(lo >> 8);
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer[i++] = (byte)(lo >> 16);
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer[i++] = (byte)(lo >> 24);
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer[i++] = (byte)(hi >> 8);
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer[i++] = (byte)(hi >> 16);
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: buffer[i] = (byte)(hi >> 24);
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: m.Position=i+4;
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (!emitNullTerminator){          if (this.UTF8)            Ir2md.WriteCompressedInt(this' this.GetUTF8ByteCount(str));          else            Ir2md.WriteCompressedInt(this' n*2);        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8){          m.Position = i+n;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++){            char ch = str[j];            if (ch >= 0x80) goto writeUTF8;            buffer[i++] = (byte)ch;          }          if (emitNullTerminator){            m.Position = i+1;            buffer = m.Buffer;            buffer[i] = 0;          }          return;        writeUTF8:          int ch32 = 0;          for (int j = n-(m.Position-i); j < n; j++){            char ch = str[j];            if (ch < 0x80){              m.Position = i+1;              buffer = m.Buffer;               buffer[i++] = (byte)ch;            }else if (ch < 0x800){              m.Position = i+2;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>6) & 0x1F) | 0xC0);              buffer[i++] = (byte)((ch & 0x3F) | 0x80);            }else if (0xD800 <= ch && ch <= 0xDBFF){              ch32 = (ch & 0x3FF) << 10;            }else if (0xDC00 <= ch && ch <= 0xDFFF){              ch32 |= ch & 0x3FF;              m.Position = i+4;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch32>>18) & 0x7) | 0xF0);              buffer[i++] = (byte)(((ch32>>12) & 0x3F) | 0x80);              buffer[i++] = (byte)(((ch32>>6) & 0x3F) | 0x80);              buffer[i++] = (byte)((ch32 & 0x3F) | 0x80);                        }else{              m.Position = i+3;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>12) & 0xF) | 0xE0);              buffer[i++] = (byte)(((ch>>6) & 0x3F) | 0x80);              buffer[i++] = (byte)((ch & 0x3F) | 0x80);            }          }          if (emitNullTerminator){            m.Position = i+1;            buffer = m.Buffer;            buffer[i] = 0;          }        }else{          m.Position = i+n*2;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++){            char ch = str[j];            buffer[i++] = (byte)ch;            buffer[i++] = (byte)(ch >> 8);          }          if (emitNullTerminator){            m.Position = i+2;            buffer = m.Buffer;            buffer[i++] = 0;            buffer[i] = 0;          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8){          m.Position = i+n;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++){            char ch = str[j];            if (ch >= 0x80) goto writeUTF8;            buffer[i++] = (byte)ch;          }          if (emitNullTerminator){            m.Position = i+1;            buffer = m.Buffer;            buffer[i] = 0;          }          return;        writeUTF8:          int ch32 = 0;          for (int j = n-(m.Position-i); j < n; j++){            char ch = str[j];            if (ch < 0x80){              m.Position = i+1;              buffer = m.Buffer;               buffer[i++] = (byte)ch;            }else if (ch < 0x800){              m.Position = i+2;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>6) & 0x1F) | 0xC0);              buffer[i++] = (byte)((ch & 0x3F) | 0x80);            }else if (0xD800 <= ch && ch <= 0xDBFF){              ch32 = (ch & 0x3FF) << 10;            }else if (0xDC00 <= ch && ch <= 0xDFFF){              ch32 |= ch & 0x3FF;              m.Position = i+4;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch32>>18) & 0x7) | 0xF0);              buffer[i++] = (byte)(((ch32>>12) & 0x3F) | 0x80);              buffer[i++] = (byte)(((ch32>>6) & 0x3F) | 0x80);              buffer[i++] = (byte)((ch32 & 0x3F) | 0x80);                        }else{              m.Position = i+3;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>12) & 0xF) | 0xE0);              buffer[i++] = (byte)(((ch>>6) & 0x3F) | 0x80);              buffer[i++] = (byte)((ch & 0x3F) | 0x80);            }          }          if (emitNullTerminator){            m.Position = i+1;            buffer = m.Buffer;            buffer[i] = 0;          }        }else{          m.Position = i+n*2;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++){            char ch = str[j];            buffer[i++] = (byte)ch;            buffer[i++] = (byte)(ch >> 8);          }          if (emitNullTerminator){            m.Position = i+2;            buffer = m.Buffer;            buffer[i++] = 0;            buffer[i] = 0;          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8){          m.Position = i+n;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++){            char ch = str[j];            if (ch >= 0x80) goto writeUTF8;            buffer[i++] = (byte)ch;          }          if (emitNullTerminator){            m.Position = i+1;            buffer = m.Buffer;            buffer[i] = 0;          }          return;        writeUTF8:          int ch32 = 0;          for (int j = n-(m.Position-i); j < n; j++){            char ch = str[j];            if (ch < 0x80){              m.Position = i+1;              buffer = m.Buffer;               buffer[i++] = (byte)ch;            }else if (ch < 0x800){              m.Position = i+2;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>6) & 0x1F) | 0xC0);              buffer[i++] = (byte)((ch & 0x3F) | 0x80);            }else if (0xD800 <= ch && ch <= 0xDBFF){              ch32 = (ch & 0x3FF) << 10;            }else if (0xDC00 <= ch && ch <= 0xDFFF){              ch32 |= ch & 0x3FF;              m.Position = i+4;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch32>>18) & 0x7) | 0xF0);              buffer[i++] = (byte)(((ch32>>12) & 0x3F) | 0x80);              buffer[i++] = (byte)(((ch32>>6) & 0x3F) | 0x80);              buffer[i++] = (byte)((ch32 & 0x3F) | 0x80);                        }else{              m.Position = i+3;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>12) & 0xF) | 0xE0);              buffer[i++] = (byte)(((ch>>6) & 0x3F) | 0x80);              buffer[i++] = (byte)((ch & 0x3F) | 0x80);            }          }          if (emitNullTerminator){            m.Position = i+1;            buffer = m.Buffer;            buffer[i] = 0;          }        }else{          m.Position = i+n*2;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++){            char ch = str[j];            buffer[i++] = (byte)ch;            buffer[i++] = (byte)(ch >> 8);          }          if (emitNullTerminator){            m.Position = i+2;            buffer = m.Buffer;            buffer[i++] = 0;            buffer[i] = 0;          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8){          m.Position = i+n;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++){            char ch = str[j];            if (ch >= 0x80) goto writeUTF8;            buffer[i++] = (byte)ch;          }          if (emitNullTerminator){            m.Position = i+1;            buffer = m.Buffer;            buffer[i] = 0;          }          return;        writeUTF8:          int ch32 = 0;          for (int j = n-(m.Position-i); j < n; j++){            char ch = str[j];            if (ch < 0x80){              m.Position = i+1;              buffer = m.Buffer;               buffer[i++] = (byte)ch;            }else if (ch < 0x800){              m.Position = i+2;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>6) & 0x1F) | 0xC0);              buffer[i++] = (byte)((ch & 0x3F) | 0x80);            }else if (0xD800 <= ch && ch <= 0xDBFF){              ch32 = (ch & 0x3FF) << 10;            }else if (0xDC00 <= ch && ch <= 0xDFFF){              ch32 |= ch & 0x3FF;              m.Position = i+4;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch32>>18) & 0x7) | 0xF0);              buffer[i++] = (byte)(((ch32>>12) & 0x3F) | 0x80);              buffer[i++] = (byte)(((ch32>>6) & 0x3F) | 0x80);              buffer[i++] = (byte)((ch32 & 0x3F) | 0x80);                        }else{              m.Position = i+3;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>12) & 0xF) | 0xE0);              buffer[i++] = (byte)(((ch>>6) & 0x3F) | 0x80);              buffer[i++] = (byte)((ch & 0x3F) | 0x80);            }          }          if (emitNullTerminator){            m.Position = i+1;            buffer = m.Buffer;            buffer[i] = 0;          }        }else{          m.Position = i+n*2;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++){            char ch = str[j];            buffer[i++] = (byte)ch;            buffer[i++] = (byte)(ch >> 8);          }          if (emitNullTerminator){            m.Position = i+2;            buffer = m.Buffer;            buffer[i++] = 0;            buffer[i] = 0;          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8){          m.Position = i+n;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++){            char ch = str[j];            if (ch >= 0x80) goto writeUTF8;            buffer[i++] = (byte)ch;          }          if (emitNullTerminator){            m.Position = i+1;            buffer = m.Buffer;            buffer[i] = 0;          }          return;        writeUTF8:          int ch32 = 0;          for (int j = n-(m.Position-i); j < n; j++){            char ch = str[j];            if (ch < 0x80){              m.Position = i+1;              buffer = m.Buffer;               buffer[i++] = (byte)ch;            }else if (ch < 0x800){              m.Position = i+2;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>6) & 0x1F) | 0xC0);              buffer[i++] = (byte)((ch & 0x3F) | 0x80);            }else if (0xD800 <= ch && ch <= 0xDBFF){              ch32 = (ch & 0x3FF) << 10;            }else if (0xDC00 <= ch && ch <= 0xDFFF){              ch32 |= ch & 0x3FF;              m.Position = i+4;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch32>>18) & 0x7) | 0xF0);              buffer[i++] = (byte)(((ch32>>12) & 0x3F) | 0x80);              buffer[i++] = (byte)(((ch32>>6) & 0x3F) | 0x80);              buffer[i++] = (byte)((ch32 & 0x3F) | 0x80);                        }else{              m.Position = i+3;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>12) & 0xF) | 0xE0);              buffer[i++] = (byte)(((ch>>6) & 0x3F) | 0x80);              buffer[i++] = (byte)((ch & 0x3F) | 0x80);            }          }          if (emitNullTerminator){            m.Position = i+1;            buffer = m.Buffer;            buffer[i] = 0;          }        }else{          m.Position = i+n*2;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++){            char ch = str[j];            buffer[i++] = (byte)ch;            buffer[i++] = (byte)(ch >> 8);          }          if (emitNullTerminator){            m.Position = i+2;            buffer = m.Buffer;            buffer[i++] = 0;            buffer[i] = 0;          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8){          m.Position = i+n;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++){            char ch = str[j];            if (ch >= 0x80) goto writeUTF8;            buffer[i++] = (byte)ch;          }          if (emitNullTerminator){            m.Position = i+1;            buffer = m.Buffer;            buffer[i] = 0;          }          return;        writeUTF8:          int ch32 = 0;          for (int j = n-(m.Position-i); j < n; j++){            char ch = str[j];            if (ch < 0x80){              m.Position = i+1;              buffer = m.Buffer;               buffer[i++] = (byte)ch;            }else if (ch < 0x800){              m.Position = i+2;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>6) & 0x1F) | 0xC0);              buffer[i++] = (byte)((ch & 0x3F) | 0x80);            }else if (0xD800 <= ch && ch <= 0xDBFF){              ch32 = (ch & 0x3FF) << 10;            }else if (0xDC00 <= ch && ch <= 0xDFFF){              ch32 |= ch & 0x3FF;              m.Position = i+4;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch32>>18) & 0x7) | 0xF0);              buffer[i++] = (byte)(((ch32>>12) & 0x3F) | 0x80);              buffer[i++] = (byte)(((ch32>>6) & 0x3F) | 0x80);              buffer[i++] = (byte)((ch32 & 0x3F) | 0x80);                        }else{              m.Position = i+3;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>12) & 0xF) | 0xE0);              buffer[i++] = (byte)(((ch>>6) & 0x3F) | 0x80);              buffer[i++] = (byte)((ch & 0x3F) | 0x80);            }          }          if (emitNullTerminator){            m.Position = i+1;            buffer = m.Buffer;            buffer[i] = 0;          }        }else{          m.Position = i+n*2;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++){            char ch = str[j];            buffer[i++] = (byte)ch;            buffer[i++] = (byte)(ch >> 8);          }          if (emitNullTerminator){            m.Position = i+2;            buffer = m.Buffer;            buffer[i++] = 0;            buffer[i] = 0;          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8){          m.Position = i+n;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++){            char ch = str[j];            if (ch >= 0x80) goto writeUTF8;            buffer[i++] = (byte)ch;          }          if (emitNullTerminator){            m.Position = i+1;            buffer = m.Buffer;            buffer[i] = 0;          }          return;        writeUTF8:          int ch32 = 0;          for (int j = n-(m.Position-i); j < n; j++){            char ch = str[j];            if (ch < 0x80){              m.Position = i+1;              buffer = m.Buffer;               buffer[i++] = (byte)ch;            }else if (ch < 0x800){              m.Position = i+2;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>6) & 0x1F) | 0xC0);              buffer[i++] = (byte)((ch & 0x3F) | 0x80);            }else if (0xD800 <= ch && ch <= 0xDBFF){              ch32 = (ch & 0x3FF) << 10;            }else if (0xDC00 <= ch && ch <= 0xDFFF){              ch32 |= ch & 0x3FF;              m.Position = i+4;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch32>>18) & 0x7) | 0xF0);              buffer[i++] = (byte)(((ch32>>12) & 0x3F) | 0x80);              buffer[i++] = (byte)(((ch32>>6) & 0x3F) | 0x80);              buffer[i++] = (byte)((ch32 & 0x3F) | 0x80);                        }else{              m.Position = i+3;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>12) & 0xF) | 0xE0);              buffer[i++] = (byte)(((ch>>6) & 0x3F) | 0x80);              buffer[i++] = (byte)((ch & 0x3F) | 0x80);            }          }          if (emitNullTerminator){            m.Position = i+1;            buffer = m.Buffer;            buffer[i] = 0;          }        }else{          m.Position = i+n*2;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++){            char ch = str[j];            buffer[i++] = (byte)ch;            buffer[i++] = (byte)(ch >> 8);          }          if (emitNullTerminator){            m.Position = i+2;            buffer = m.Buffer;            buffer[i++] = 0;            buffer[i] = 0;          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8){          m.Position = i+n;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++){            char ch = str[j];            if (ch >= 0x80) goto writeUTF8;            buffer[i++] = (byte)ch;          }          if (emitNullTerminator){            m.Position = i+1;            buffer = m.Buffer;            buffer[i] = 0;          }          return;        writeUTF8:          int ch32 = 0;          for (int j = n-(m.Position-i); j < n; j++){            char ch = str[j];            if (ch < 0x80){              m.Position = i+1;              buffer = m.Buffer;               buffer[i++] = (byte)ch;            }else if (ch < 0x800){              m.Position = i+2;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>6) & 0x1F) | 0xC0);              buffer[i++] = (byte)((ch & 0x3F) | 0x80);            }else if (0xD800 <= ch && ch <= 0xDBFF){              ch32 = (ch & 0x3FF) << 10;            }else if (0xDC00 <= ch && ch <= 0xDFFF){              ch32 |= ch & 0x3FF;              m.Position = i+4;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch32>>18) & 0x7) | 0xF0);              buffer[i++] = (byte)(((ch32>>12) & 0x3F) | 0x80);              buffer[i++] = (byte)(((ch32>>6) & 0x3F) | 0x80);              buffer[i++] = (byte)((ch32 & 0x3F) | 0x80);                        }else{              m.Position = i+3;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>12) & 0xF) | 0xE0);              buffer[i++] = (byte)(((ch>>6) & 0x3F) | 0x80);              buffer[i++] = (byte)((ch & 0x3F) | 0x80);            }          }          if (emitNullTerminator){            m.Position = i+1;            buffer = m.Buffer;            buffer[i] = 0;          }        }else{          m.Position = i+n*2;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++){            char ch = str[j];            buffer[i++] = (byte)ch;            buffer[i++] = (byte)(ch >> 8);          }          if (emitNullTerminator){            m.Position = i+2;            buffer = m.Buffer;            buffer[i++] = 0;            buffer[i] = 0;          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8){          m.Position = i+n;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++){            char ch = str[j];            if (ch >= 0x80) goto writeUTF8;            buffer[i++] = (byte)ch;          }          if (emitNullTerminator){            m.Position = i+1;            buffer = m.Buffer;            buffer[i] = 0;          }          return;        writeUTF8:          int ch32 = 0;          for (int j = n-(m.Position-i); j < n; j++){            char ch = str[j];            if (ch < 0x80){              m.Position = i+1;              buffer = m.Buffer;               buffer[i++] = (byte)ch;            }else if (ch < 0x800){              m.Position = i+2;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>6) & 0x1F) | 0xC0);              buffer[i++] = (byte)((ch & 0x3F) | 0x80);            }else if (0xD800 <= ch && ch <= 0xDBFF){              ch32 = (ch & 0x3FF) << 10;            }else if (0xDC00 <= ch && ch <= 0xDFFF){              ch32 |= ch & 0x3FF;              m.Position = i+4;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch32>>18) & 0x7) | 0xF0);              buffer[i++] = (byte)(((ch32>>12) & 0x3F) | 0x80);              buffer[i++] = (byte)(((ch32>>6) & 0x3F) | 0x80);              buffer[i++] = (byte)((ch32 & 0x3F) | 0x80);                        }else{              m.Position = i+3;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>12) & 0xF) | 0xE0);              buffer[i++] = (byte)(((ch>>6) & 0x3F) | 0x80);              buffer[i++] = (byte)((ch & 0x3F) | 0x80);            }          }          if (emitNullTerminator){            m.Position = i+1;            buffer = m.Buffer;            buffer[i] = 0;          }        }else{          m.Position = i+n*2;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++){            char ch = str[j];            buffer[i++] = (byte)ch;            buffer[i++] = (byte)(ch >> 8);          }          if (emitNullTerminator){            m.Position = i+2;            buffer = m.Buffer;            buffer[i++] = 0;            buffer[i] = 0;          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8){          m.Position = i+n;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++){            char ch = str[j];            if (ch >= 0x80) goto writeUTF8;            buffer[i++] = (byte)ch;          }          if (emitNullTerminator){            m.Position = i+1;            buffer = m.Buffer;            buffer[i] = 0;          }          return;        writeUTF8:          int ch32 = 0;          for (int j = n-(m.Position-i); j < n; j++){            char ch = str[j];            if (ch < 0x80){              m.Position = i+1;              buffer = m.Buffer;               buffer[i++] = (byte)ch;            }else if (ch < 0x800){              m.Position = i+2;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>6) & 0x1F) | 0xC0);              buffer[i++] = (byte)((ch & 0x3F) | 0x80);            }else if (0xD800 <= ch && ch <= 0xDBFF){              ch32 = (ch & 0x3FF) << 10;            }else if (0xDC00 <= ch && ch <= 0xDFFF){              ch32 |= ch & 0x3FF;              m.Position = i+4;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch32>>18) & 0x7) | 0xF0);              buffer[i++] = (byte)(((ch32>>12) & 0x3F) | 0x80);              buffer[i++] = (byte)(((ch32>>6) & 0x3F) | 0x80);              buffer[i++] = (byte)((ch32 & 0x3F) | 0x80);                        }else{              m.Position = i+3;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>12) & 0xF) | 0xE0);              buffer[i++] = (byte)(((ch>>6) & 0x3F) | 0x80);              buffer[i++] = (byte)((ch & 0x3F) | 0x80);            }          }          if (emitNullTerminator){            m.Position = i+1;            buffer = m.Buffer;            buffer[i] = 0;          }        }else{          m.Position = i+n*2;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++){            char ch = str[j];            buffer[i++] = (byte)ch;            buffer[i++] = (byte)(ch >> 8);          }          if (emitNullTerminator){            m.Position = i+2;            buffer = m.Buffer;            buffer[i++] = 0;            buffer[i] = 0;          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8){          m.Position = i+n;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++){            char ch = str[j];            if (ch >= 0x80) goto writeUTF8;            buffer[i++] = (byte)ch;          }          if (emitNullTerminator){            m.Position = i+1;            buffer = m.Buffer;            buffer[i] = 0;          }          return;        writeUTF8:          int ch32 = 0;          for (int j = n-(m.Position-i); j < n; j++){            char ch = str[j];            if (ch < 0x80){              m.Position = i+1;              buffer = m.Buffer;               buffer[i++] = (byte)ch;            }else if (ch < 0x800){              m.Position = i+2;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>6) & 0x1F) | 0xC0);              buffer[i++] = (byte)((ch & 0x3F) | 0x80);            }else if (0xD800 <= ch && ch <= 0xDBFF){              ch32 = (ch & 0x3FF) << 10;            }else if (0xDC00 <= ch && ch <= 0xDFFF){              ch32 |= ch & 0x3FF;              m.Position = i+4;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch32>>18) & 0x7) | 0xF0);              buffer[i++] = (byte)(((ch32>>12) & 0x3F) | 0x80);              buffer[i++] = (byte)(((ch32>>6) & 0x3F) | 0x80);              buffer[i++] = (byte)((ch32 & 0x3F) | 0x80);                        }else{              m.Position = i+3;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>12) & 0xF) | 0xE0);              buffer[i++] = (byte)(((ch>>6) & 0x3F) | 0x80);              buffer[i++] = (byte)((ch & 0x3F) | 0x80);            }          }          if (emitNullTerminator){            m.Position = i+1;            buffer = m.Buffer;            buffer[i] = 0;          }        }else{          m.Position = i+n*2;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++){            char ch = str[j];            buffer[i++] = (byte)ch;            buffer[i++] = (byte)(ch >> 8);          }          if (emitNullTerminator){            m.Position = i+2;            buffer = m.Buffer;            buffer[i++] = 0;            buffer[i] = 0;          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8){          m.Position = i+n;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++){            char ch = str[j];            if (ch >= 0x80) goto writeUTF8;            buffer[i++] = (byte)ch;          }          if (emitNullTerminator){            m.Position = i+1;            buffer = m.Buffer;            buffer[i] = 0;          }          return;        writeUTF8:          int ch32 = 0;          for (int j = n-(m.Position-i); j < n; j++){            char ch = str[j];            if (ch < 0x80){              m.Position = i+1;              buffer = m.Buffer;               buffer[i++] = (byte)ch;            }else if (ch < 0x800){              m.Position = i+2;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>6) & 0x1F) | 0xC0);              buffer[i++] = (byte)((ch & 0x3F) | 0x80);            }else if (0xD800 <= ch && ch <= 0xDBFF){              ch32 = (ch & 0x3FF) << 10;            }else if (0xDC00 <= ch && ch <= 0xDFFF){              ch32 |= ch & 0x3FF;              m.Position = i+4;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch32>>18) & 0x7) | 0xF0);              buffer[i++] = (byte)(((ch32>>12) & 0x3F) | 0x80);              buffer[i++] = (byte)(((ch32>>6) & 0x3F) | 0x80);              buffer[i++] = (byte)((ch32 & 0x3F) | 0x80);                        }else{              m.Position = i+3;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>12) & 0xF) | 0xE0);              buffer[i++] = (byte)(((ch>>6) & 0x3F) | 0x80);              buffer[i++] = (byte)((ch & 0x3F) | 0x80);            }          }          if (emitNullTerminator){            m.Position = i+1;            buffer = m.Buffer;            buffer[i] = 0;          }        }else{          m.Position = i+n*2;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++){            char ch = str[j];            buffer[i++] = (byte)ch;            buffer[i++] = (byte)(ch >> 8);          }          if (emitNullTerminator){            m.Position = i+2;            buffer = m.Buffer;            buffer[i++] = 0;            buffer[i] = 0;          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Write,The following statement contains a magic number: if (this.UTF8){          m.Position = i+n;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++){            char ch = str[j];            if (ch >= 0x80) goto writeUTF8;            buffer[i++] = (byte)ch;          }          if (emitNullTerminator){            m.Position = i+1;            buffer = m.Buffer;            buffer[i] = 0;          }          return;        writeUTF8:          int ch32 = 0;          for (int j = n-(m.Position-i); j < n; j++){            char ch = str[j];            if (ch < 0x80){              m.Position = i+1;              buffer = m.Buffer;               buffer[i++] = (byte)ch;            }else if (ch < 0x800){              m.Position = i+2;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>6) & 0x1F) | 0xC0);              buffer[i++] = (byte)((ch & 0x3F) | 0x80);            }else if (0xD800 <= ch && ch <= 0xDBFF){              ch32 = (ch & 0x3FF) << 10;            }else if (0xDC00 <= ch && ch <= 0xDFFF){              ch32 |= ch & 0x3FF;              m.Position = i+4;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch32>>18) & 0x7) | 0xF0);              buffer[i++] = (byte)(((ch32>>12) & 0x3F) | 0x80);              buffer[i++] = (byte)(((ch32>>6) & 0x3F) | 0x80);              buffer[i++] = (byte)((ch32 & 0x3F) | 0x80);                        }else{              m.Position = i+3;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>12) & 0xF) | 0xE0);              buffer[i++] = (byte)(((ch>>6) & 0x3F) | 0x80);              buffer[i++] = (byte)((ch & 0x3F) | 0x80);            }          }          if (emitNullTerminator){            m.Position = i+1;            buffer = m.Buffer;            buffer[i] = 0;          }        }else{          m.Position = i+n*2;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++){            char ch = str[j];            buffer[i++] = (byte)ch;            buffer[i++] = (byte)(ch >> 8);          }          if (emitNullTerminator){            m.Position = i+2;            buffer = m.Buffer;            buffer[i++] = 0;            buffer[i] = 0;          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,GetUTF8ByteCount,The following statement contains a magic number: for (int i = 0' n = str == null ? 0 : str.Length; i < n; i++){          //^ assume str != null;          char ch = str[i];          if (ch < 0x80){            count += 1;          }else if (ch < 0x800){            count += 2;          }else if (0xD800 <= ch && ch <= 0xDBFF){            count += 2;          }else if (0xDC00 <= ch && ch <= 0xDFFF){            count += 2;          }else{            count += 3;          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,GetUTF8ByteCount,The following statement contains a magic number: for (int i = 0' n = str == null ? 0 : str.Length; i < n; i++){          //^ assume str != null;          char ch = str[i];          if (ch < 0x80){            count += 1;          }else if (ch < 0x800){            count += 2;          }else if (0xD800 <= ch && ch <= 0xDBFF){            count += 2;          }else if (0xDC00 <= ch && ch <= 0xDFFF){            count += 2;          }else{            count += 3;          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,GetUTF8ByteCount,The following statement contains a magic number: for (int i = 0' n = str == null ? 0 : str.Length; i < n; i++){          //^ assume str != null;          char ch = str[i];          if (ch < 0x80){            count += 1;          }else if (ch < 0x800){            count += 2;          }else if (0xD800 <= ch && ch <= 0xDBFF){            count += 2;          }else if (0xDC00 <= ch && ch <= 0xDFFF){            count += 2;          }else{            count += 3;          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,GetUTF8ByteCount,The following statement contains a magic number: for (int i = 0' n = str == null ? 0 : str.Length; i < n; i++){          //^ assume str != null;          char ch = str[i];          if (ch < 0x80){            count += 1;          }else if (ch < 0x800){            count += 2;          }else if (0xD800 <= ch && ch <= 0xDBFF){            count += 2;          }else if (0xDC00 <= ch && ch <= 0xDFFF){            count += 2;          }else{            count += 3;          }        }
Magic Number,Microsoft.Cci,MemoryStream,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,MemoryStream,The following statement contains a magic number: this.Buffer = new byte[64];
Magic Number,Microsoft.Cci,MemoryStream,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Grow,The following statement contains a magic number: int n2 = n*2;
Magic Number,Microsoft.Cci,MemoryStream,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Grow,The following statement contains a magic number: while (m >= n2) n2 = n2*2;
Magic Number,Microsoft.Cci,BetterPath,C:\repos\Reactive-Extensions_IL2JS\CCI\FastFileIO.cs,Combine,The following statement contains a magic number: if (ch == BetterPath.DirectorySeparatorChar || ch == BetterPath.AltDirectorySeparatorChar || (path2.Length >= 2 && path2[1] == BetterPath.VolumeSeparatorChar))          return path2;
Magic Number,Microsoft.Cci,ReGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI\ILGenerator.cs,VisitAddressOf,The following statement contains a magic number: switch (operand.NodeType){          case NodeType.Indexer:            Indexer indexer = (Indexer)operand;            this.Visit(indexer.Object);            if (indexer.Operands != null && indexer.Operands.Count == 1)              this.Visit(indexer.Operands[0]);            if (expr.NodeType == NodeType.ReadOnlyAddressOf)              this.ILGenerator.Emit(OpCodes.Readonly);            if (indexer.ElementType != null)              this.ILGenerator.Emit(OpCodes.Ldelema' indexer.ElementType.GetRuntimeType());            return;          case NodeType.Local:            int li = this.GetLocalVarIndex((Local)operand);            if (li < 256)              this.ILGenerator.Emit(OpCodes.Ldloca_S' this.locals[li]);            else              this.ILGenerator.Emit(OpCodes.Ldloca' this.locals[li]);            return;          case NodeType.MemberBinding:            MemberBinding mb = (MemberBinding)operand;            Field f = mb.BoundMember as Field;            if (f == null) { Debug.Fail(""); return; }            System.Reflection.FieldInfo fieldInfo = f.GetFieldInfo();            if (fieldInfo == null) { Debug.Fail(""); return; }            if (mb.TargetObject != null){              this.Visit(mb.TargetObject);              this.ILGenerator.Emit(OpCodes.Ldflda' fieldInfo);            }else{              this.ILGenerator.Emit(OpCodes.Ldsflda' fieldInfo);            }            return;          case NodeType.Parameter:            ParameterBinding pb = operand as ParameterBinding;            if (pb != null) operand = pb.BoundParameter;            int pi = ((Parameter)operand).ArgumentListIndex;            if (pi < 256)              this.ILGenerator.Emit(OpCodes.Ldarga_S' (byte)pi);            else              this.ILGenerator.Emit(OpCodes.Ldarga' (ushort)pi);            return;        }
Magic Number,Microsoft.Cci,ReGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI\ILGenerator.cs,VisitAddressOf,The following statement contains a magic number: switch (operand.NodeType){          case NodeType.Indexer:            Indexer indexer = (Indexer)operand;            this.Visit(indexer.Object);            if (indexer.Operands != null && indexer.Operands.Count == 1)              this.Visit(indexer.Operands[0]);            if (expr.NodeType == NodeType.ReadOnlyAddressOf)              this.ILGenerator.Emit(OpCodes.Readonly);            if (indexer.ElementType != null)              this.ILGenerator.Emit(OpCodes.Ldelema' indexer.ElementType.GetRuntimeType());            return;          case NodeType.Local:            int li = this.GetLocalVarIndex((Local)operand);            if (li < 256)              this.ILGenerator.Emit(OpCodes.Ldloca_S' this.locals[li]);            else              this.ILGenerator.Emit(OpCodes.Ldloca' this.locals[li]);            return;          case NodeType.MemberBinding:            MemberBinding mb = (MemberBinding)operand;            Field f = mb.BoundMember as Field;            if (f == null) { Debug.Fail(""); return; }            System.Reflection.FieldInfo fieldInfo = f.GetFieldInfo();            if (fieldInfo == null) { Debug.Fail(""); return; }            if (mb.TargetObject != null){              this.Visit(mb.TargetObject);              this.ILGenerator.Emit(OpCodes.Ldflda' fieldInfo);            }else{              this.ILGenerator.Emit(OpCodes.Ldsflda' fieldInfo);            }            return;          case NodeType.Parameter:            ParameterBinding pb = operand as ParameterBinding;            if (pb != null) operand = pb.BoundParameter;            int pi = ((Parameter)operand).ArgumentListIndex;            if (pi < 256)              this.ILGenerator.Emit(OpCodes.Ldarga_S' (byte)pi);            else              this.ILGenerator.Emit(OpCodes.Ldarga' (ushort)pi);            return;        }
Magic Number,Microsoft.Cci,ReGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI\ILGenerator.cs,VisitAssignmentStatement,The following statement contains a magic number: switch (target.NodeType){          case NodeType.Local:            Local loc = (Local)target;            this.Visit(assignment.Source);            int li = this.GetLocalVarIndex(loc);            switch (li){              case 0: this.ILGenerator.Emit(OpCodes.Stloc_0); return;              case 1: this.ILGenerator.Emit(OpCodes.Stloc_1); return;              case 2: this.ILGenerator.Emit(OpCodes.Stloc_2); return;              case 3: this.ILGenerator.Emit(OpCodes.Stloc_3); return;              default:                if (li < 256)                  this.ILGenerator.Emit(OpCodes.Stloc_S' this.locals[li]);                else                  this.ILGenerator.Emit(OpCodes.Stloc' this.locals[li]);                return;            }          case NodeType.MemberBinding:            MemberBinding mb = (MemberBinding)target;            Field f = mb.BoundMember as Field;            if (f == null) { Debug.Fail(""); return; }            System.Reflection.FieldInfo fieldInfo = f.GetFieldInfo();            if (fieldInfo == null) { Debug.Fail(""); return; }            if (mb.TargetObject != null) this.Visit(mb.TargetObject);            this.Visit(assignment.Source);            if (mb.TargetObject != null){              if (mb.Alignment != -1)                this.ILGenerator.Emit(OpCodes.Unaligned' (byte)mb.Alignment);              if (mb.Volatile)                this.ILGenerator.Emit(OpCodes.Volatile);              this.ILGenerator.Emit(OpCodes.Stfld' fieldInfo);            }else              this.ILGenerator.Emit(OpCodes.Stsfld' fieldInfo);            return;          case NodeType.Parameter:            ParameterBinding pb = target as ParameterBinding;            if (pb != null) target = pb.BoundParameter;            Parameter par = (Parameter)target;            this.Visit(assignment.Source);            int pi = par.ArgumentListIndex;            if (pi < 256)               this.ILGenerator.Emit(OpCodes.Starg_S' (byte)pi);            else              this.ILGenerator.Emit(OpCodes.Starg' (ushort)pi);            return;          case NodeType.Indexer:            Indexer indexer = (Indexer)target;            this.Visit(indexer.Object);            if (indexer.Operands != null && indexer.Operands.Count == 1)              this.Visit(indexer.Operands[0]);            this.Visit(assignment.Source);            Type elementType = indexer.ElementType == null ? null : indexer.ElementType.GetRuntimeType();            if (elementType == null) {Debug.Fail(""); return; }            this.ILGenerator.Emit(OpCodes.Ldelema' elementType);            System.Reflection.Emit.OpCode opCode;            //^ assert indexer.ElementType != null;            switch (indexer.ElementType.typeCode){              case ElementType.UIntPtr:              case ElementType.IntPtr: opCode = OpCodes.Stelem_I; break;              case ElementType.Boolean:              case ElementType.Int8:              case ElementType.UInt8: opCode = OpCodes.Stelem_I1; break;              case ElementType.Char:              case ElementType.Int16:              case ElementType.UInt16: opCode = OpCodes.Stelem_I2; break;              case ElementType.Int32:              case ElementType.UInt32: opCode = OpCodes.Stelem_I4; break;              case ElementType.Int64:              case ElementType.UInt64: opCode = OpCodes.Stelem_I8; break;              case ElementType.Single: opCode = OpCodes.Stelem_R4; break;              case ElementType.Double: opCode = OpCodes.Stelem_R8; break;              default:                if (indexer.ElementType.NodeType == NodeType.TypeParameter || indexer.ElementType.NodeType == NodeType.ClassParameter)                  opCode = OpCodes.Stelem;                else if (TypeNode.StripModifiers(indexer.ElementType) is Pointer)                  opCode = OpCodes.Stelem_I;                else                  opCode = OpCodes.Stelem_Ref;                break;            }            if (opCode.Name == OpCodes.Stelem.Name)              this.ILGenerator.Emit(opCode' indexer.ElementType.GetRuntimeType());            else              this.ILGenerator.Emit(opCode);            return;          case NodeType.AddressDereference:            AddressDereference adr = (AddressDereference)target;            if (adr.Type == null) { Debug.Fail(""); return; }            this.Visit(adr.Address);            if (adr.Type.IsValueType || adr.Type is TypeParameter){              Literal lit = assignment.Source as Literal;              if (lit != null && lit.Value == null){                this.ILGenerator.Emit(OpCodes.Initobj' adr.Type.GetRuntimeType());                return;              }            }            this.Visit(assignment.Source);            if (adr.Alignment > 0)              this.ILGenerator.Emit(OpCodes.Unaligned' (byte)adr.Alignment);            if (adr.Volatile)              this.ILGenerator.Emit(OpCodes.Volatile);            TypeNode adrType = TypeNode.StripModifiers(adr.Type);            //^ assert adrType != null;            switch (adrType.typeCode){              case ElementType.Int8:              case ElementType.UInt8: this.ILGenerator.Emit(OpCodes.Stind_I1); return;              case ElementType.Int16:              case ElementType.UInt16: this.ILGenerator.Emit(OpCodes.Stind_I2); return;              case ElementType.Int32:              case ElementType.UInt32: this.ILGenerator.Emit(OpCodes.Stind_I4); return;              case ElementType.Int64:              case ElementType.UInt64: this.ILGenerator.Emit(OpCodes.Stind_I8); return;              case ElementType.Single: this.ILGenerator.Emit(OpCodes.Stind_R4); return;              case ElementType.Double: this.ILGenerator.Emit(OpCodes.Stind_R8); return;              case ElementType.UIntPtr:              case ElementType.IntPtr: this.ILGenerator.Emit(OpCodes.Stind_I); return;              default:                if (adrType != null && (adrType.IsValueType ||                  adrType.NodeType == NodeType.TypeParameter || adrType.NodeType == NodeType.ClassParameter)){                  this.ILGenerator.Emit(OpCodes.Stobj' adrType.GetRuntimeType());                  return;                }                if (adrType.NodeType == NodeType.Pointer){                  this.ILGenerator.Emit(OpCodes.Stind_I);                   return;                }                this.ILGenerator.Emit(OpCodes.Stind_Ref);                return;            }          default:            Debug.Assert(false' "unexpected assignment target");            return;        }
Magic Number,Microsoft.Cci,ReGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI\ILGenerator.cs,VisitAssignmentStatement,The following statement contains a magic number: switch (target.NodeType){          case NodeType.Local:            Local loc = (Local)target;            this.Visit(assignment.Source);            int li = this.GetLocalVarIndex(loc);            switch (li){              case 0: this.ILGenerator.Emit(OpCodes.Stloc_0); return;              case 1: this.ILGenerator.Emit(OpCodes.Stloc_1); return;              case 2: this.ILGenerator.Emit(OpCodes.Stloc_2); return;              case 3: this.ILGenerator.Emit(OpCodes.Stloc_3); return;              default:                if (li < 256)                  this.ILGenerator.Emit(OpCodes.Stloc_S' this.locals[li]);                else                  this.ILGenerator.Emit(OpCodes.Stloc' this.locals[li]);                return;            }          case NodeType.MemberBinding:            MemberBinding mb = (MemberBinding)target;            Field f = mb.BoundMember as Field;            if (f == null) { Debug.Fail(""); return; }            System.Reflection.FieldInfo fieldInfo = f.GetFieldInfo();            if (fieldInfo == null) { Debug.Fail(""); return; }            if (mb.TargetObject != null) this.Visit(mb.TargetObject);            this.Visit(assignment.Source);            if (mb.TargetObject != null){              if (mb.Alignment != -1)                this.ILGenerator.Emit(OpCodes.Unaligned' (byte)mb.Alignment);              if (mb.Volatile)                this.ILGenerator.Emit(OpCodes.Volatile);              this.ILGenerator.Emit(OpCodes.Stfld' fieldInfo);            }else              this.ILGenerator.Emit(OpCodes.Stsfld' fieldInfo);            return;          case NodeType.Parameter:            ParameterBinding pb = target as ParameterBinding;            if (pb != null) target = pb.BoundParameter;            Parameter par = (Parameter)target;            this.Visit(assignment.Source);            int pi = par.ArgumentListIndex;            if (pi < 256)               this.ILGenerator.Emit(OpCodes.Starg_S' (byte)pi);            else              this.ILGenerator.Emit(OpCodes.Starg' (ushort)pi);            return;          case NodeType.Indexer:            Indexer indexer = (Indexer)target;            this.Visit(indexer.Object);            if (indexer.Operands != null && indexer.Operands.Count == 1)              this.Visit(indexer.Operands[0]);            this.Visit(assignment.Source);            Type elementType = indexer.ElementType == null ? null : indexer.ElementType.GetRuntimeType();            if (elementType == null) {Debug.Fail(""); return; }            this.ILGenerator.Emit(OpCodes.Ldelema' elementType);            System.Reflection.Emit.OpCode opCode;            //^ assert indexer.ElementType != null;            switch (indexer.ElementType.typeCode){              case ElementType.UIntPtr:              case ElementType.IntPtr: opCode = OpCodes.Stelem_I; break;              case ElementType.Boolean:              case ElementType.Int8:              case ElementType.UInt8: opCode = OpCodes.Stelem_I1; break;              case ElementType.Char:              case ElementType.Int16:              case ElementType.UInt16: opCode = OpCodes.Stelem_I2; break;              case ElementType.Int32:              case ElementType.UInt32: opCode = OpCodes.Stelem_I4; break;              case ElementType.Int64:              case ElementType.UInt64: opCode = OpCodes.Stelem_I8; break;              case ElementType.Single: opCode = OpCodes.Stelem_R4; break;              case ElementType.Double: opCode = OpCodes.Stelem_R8; break;              default:                if (indexer.ElementType.NodeType == NodeType.TypeParameter || indexer.ElementType.NodeType == NodeType.ClassParameter)                  opCode = OpCodes.Stelem;                else if (TypeNode.StripModifiers(indexer.ElementType) is Pointer)                  opCode = OpCodes.Stelem_I;                else                  opCode = OpCodes.Stelem_Ref;                break;            }            if (opCode.Name == OpCodes.Stelem.Name)              this.ILGenerator.Emit(opCode' indexer.ElementType.GetRuntimeType());            else              this.ILGenerator.Emit(opCode);            return;          case NodeType.AddressDereference:            AddressDereference adr = (AddressDereference)target;            if (adr.Type == null) { Debug.Fail(""); return; }            this.Visit(adr.Address);            if (adr.Type.IsValueType || adr.Type is TypeParameter){              Literal lit = assignment.Source as Literal;              if (lit != null && lit.Value == null){                this.ILGenerator.Emit(OpCodes.Initobj' adr.Type.GetRuntimeType());                return;              }            }            this.Visit(assignment.Source);            if (adr.Alignment > 0)              this.ILGenerator.Emit(OpCodes.Unaligned' (byte)adr.Alignment);            if (adr.Volatile)              this.ILGenerator.Emit(OpCodes.Volatile);            TypeNode adrType = TypeNode.StripModifiers(adr.Type);            //^ assert adrType != null;            switch (adrType.typeCode){              case ElementType.Int8:              case ElementType.UInt8: this.ILGenerator.Emit(OpCodes.Stind_I1); return;              case ElementType.Int16:              case ElementType.UInt16: this.ILGenerator.Emit(OpCodes.Stind_I2); return;              case ElementType.Int32:              case ElementType.UInt32: this.ILGenerator.Emit(OpCodes.Stind_I4); return;              case ElementType.Int64:              case ElementType.UInt64: this.ILGenerator.Emit(OpCodes.Stind_I8); return;              case ElementType.Single: this.ILGenerator.Emit(OpCodes.Stind_R4); return;              case ElementType.Double: this.ILGenerator.Emit(OpCodes.Stind_R8); return;              case ElementType.UIntPtr:              case ElementType.IntPtr: this.ILGenerator.Emit(OpCodes.Stind_I); return;              default:                if (adrType != null && (adrType.IsValueType ||                  adrType.NodeType == NodeType.TypeParameter || adrType.NodeType == NodeType.ClassParameter)){                  this.ILGenerator.Emit(OpCodes.Stobj' adrType.GetRuntimeType());                  return;                }                if (adrType.NodeType == NodeType.Pointer){                  this.ILGenerator.Emit(OpCodes.Stind_I);                   return;                }                this.ILGenerator.Emit(OpCodes.Stind_Ref);                return;            }          default:            Debug.Assert(false' "unexpected assignment target");            return;        }
Magic Number,Microsoft.Cci,ReGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI\ILGenerator.cs,VisitAssignmentStatement,The following statement contains a magic number: switch (target.NodeType){          case NodeType.Local:            Local loc = (Local)target;            this.Visit(assignment.Source);            int li = this.GetLocalVarIndex(loc);            switch (li){              case 0: this.ILGenerator.Emit(OpCodes.Stloc_0); return;              case 1: this.ILGenerator.Emit(OpCodes.Stloc_1); return;              case 2: this.ILGenerator.Emit(OpCodes.Stloc_2); return;              case 3: this.ILGenerator.Emit(OpCodes.Stloc_3); return;              default:                if (li < 256)                  this.ILGenerator.Emit(OpCodes.Stloc_S' this.locals[li]);                else                  this.ILGenerator.Emit(OpCodes.Stloc' this.locals[li]);                return;            }          case NodeType.MemberBinding:            MemberBinding mb = (MemberBinding)target;            Field f = mb.BoundMember as Field;            if (f == null) { Debug.Fail(""); return; }            System.Reflection.FieldInfo fieldInfo = f.GetFieldInfo();            if (fieldInfo == null) { Debug.Fail(""); return; }            if (mb.TargetObject != null) this.Visit(mb.TargetObject);            this.Visit(assignment.Source);            if (mb.TargetObject != null){              if (mb.Alignment != -1)                this.ILGenerator.Emit(OpCodes.Unaligned' (byte)mb.Alignment);              if (mb.Volatile)                this.ILGenerator.Emit(OpCodes.Volatile);              this.ILGenerator.Emit(OpCodes.Stfld' fieldInfo);            }else              this.ILGenerator.Emit(OpCodes.Stsfld' fieldInfo);            return;          case NodeType.Parameter:            ParameterBinding pb = target as ParameterBinding;            if (pb != null) target = pb.BoundParameter;            Parameter par = (Parameter)target;            this.Visit(assignment.Source);            int pi = par.ArgumentListIndex;            if (pi < 256)               this.ILGenerator.Emit(OpCodes.Starg_S' (byte)pi);            else              this.ILGenerator.Emit(OpCodes.Starg' (ushort)pi);            return;          case NodeType.Indexer:            Indexer indexer = (Indexer)target;            this.Visit(indexer.Object);            if (indexer.Operands != null && indexer.Operands.Count == 1)              this.Visit(indexer.Operands[0]);            this.Visit(assignment.Source);            Type elementType = indexer.ElementType == null ? null : indexer.ElementType.GetRuntimeType();            if (elementType == null) {Debug.Fail(""); return; }            this.ILGenerator.Emit(OpCodes.Ldelema' elementType);            System.Reflection.Emit.OpCode opCode;            //^ assert indexer.ElementType != null;            switch (indexer.ElementType.typeCode){              case ElementType.UIntPtr:              case ElementType.IntPtr: opCode = OpCodes.Stelem_I; break;              case ElementType.Boolean:              case ElementType.Int8:              case ElementType.UInt8: opCode = OpCodes.Stelem_I1; break;              case ElementType.Char:              case ElementType.Int16:              case ElementType.UInt16: opCode = OpCodes.Stelem_I2; break;              case ElementType.Int32:              case ElementType.UInt32: opCode = OpCodes.Stelem_I4; break;              case ElementType.Int64:              case ElementType.UInt64: opCode = OpCodes.Stelem_I8; break;              case ElementType.Single: opCode = OpCodes.Stelem_R4; break;              case ElementType.Double: opCode = OpCodes.Stelem_R8; break;              default:                if (indexer.ElementType.NodeType == NodeType.TypeParameter || indexer.ElementType.NodeType == NodeType.ClassParameter)                  opCode = OpCodes.Stelem;                else if (TypeNode.StripModifiers(indexer.ElementType) is Pointer)                  opCode = OpCodes.Stelem_I;                else                  opCode = OpCodes.Stelem_Ref;                break;            }            if (opCode.Name == OpCodes.Stelem.Name)              this.ILGenerator.Emit(opCode' indexer.ElementType.GetRuntimeType());            else              this.ILGenerator.Emit(opCode);            return;          case NodeType.AddressDereference:            AddressDereference adr = (AddressDereference)target;            if (adr.Type == null) { Debug.Fail(""); return; }            this.Visit(adr.Address);            if (adr.Type.IsValueType || adr.Type is TypeParameter){              Literal lit = assignment.Source as Literal;              if (lit != null && lit.Value == null){                this.ILGenerator.Emit(OpCodes.Initobj' adr.Type.GetRuntimeType());                return;              }            }            this.Visit(assignment.Source);            if (adr.Alignment > 0)              this.ILGenerator.Emit(OpCodes.Unaligned' (byte)adr.Alignment);            if (adr.Volatile)              this.ILGenerator.Emit(OpCodes.Volatile);            TypeNode adrType = TypeNode.StripModifiers(adr.Type);            //^ assert adrType != null;            switch (adrType.typeCode){              case ElementType.Int8:              case ElementType.UInt8: this.ILGenerator.Emit(OpCodes.Stind_I1); return;              case ElementType.Int16:              case ElementType.UInt16: this.ILGenerator.Emit(OpCodes.Stind_I2); return;              case ElementType.Int32:              case ElementType.UInt32: this.ILGenerator.Emit(OpCodes.Stind_I4); return;              case ElementType.Int64:              case ElementType.UInt64: this.ILGenerator.Emit(OpCodes.Stind_I8); return;              case ElementType.Single: this.ILGenerator.Emit(OpCodes.Stind_R4); return;              case ElementType.Double: this.ILGenerator.Emit(OpCodes.Stind_R8); return;              case ElementType.UIntPtr:              case ElementType.IntPtr: this.ILGenerator.Emit(OpCodes.Stind_I); return;              default:                if (adrType != null && (adrType.IsValueType ||                  adrType.NodeType == NodeType.TypeParameter || adrType.NodeType == NodeType.ClassParameter)){                  this.ILGenerator.Emit(OpCodes.Stobj' adrType.GetRuntimeType());                  return;                }                if (adrType.NodeType == NodeType.Pointer){                  this.ILGenerator.Emit(OpCodes.Stind_I);                   return;                }                this.ILGenerator.Emit(OpCodes.Stind_Ref);                return;            }          default:            Debug.Assert(false' "unexpected assignment target");            return;        }
Magic Number,Microsoft.Cci,ReGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI\ILGenerator.cs,VisitAssignmentStatement,The following statement contains a magic number: switch (target.NodeType){          case NodeType.Local:            Local loc = (Local)target;            this.Visit(assignment.Source);            int li = this.GetLocalVarIndex(loc);            switch (li){              case 0: this.ILGenerator.Emit(OpCodes.Stloc_0); return;              case 1: this.ILGenerator.Emit(OpCodes.Stloc_1); return;              case 2: this.ILGenerator.Emit(OpCodes.Stloc_2); return;              case 3: this.ILGenerator.Emit(OpCodes.Stloc_3); return;              default:                if (li < 256)                  this.ILGenerator.Emit(OpCodes.Stloc_S' this.locals[li]);                else                  this.ILGenerator.Emit(OpCodes.Stloc' this.locals[li]);                return;            }          case NodeType.MemberBinding:            MemberBinding mb = (MemberBinding)target;            Field f = mb.BoundMember as Field;            if (f == null) { Debug.Fail(""); return; }            System.Reflection.FieldInfo fieldInfo = f.GetFieldInfo();            if (fieldInfo == null) { Debug.Fail(""); return; }            if (mb.TargetObject != null) this.Visit(mb.TargetObject);            this.Visit(assignment.Source);            if (mb.TargetObject != null){              if (mb.Alignment != -1)                this.ILGenerator.Emit(OpCodes.Unaligned' (byte)mb.Alignment);              if (mb.Volatile)                this.ILGenerator.Emit(OpCodes.Volatile);              this.ILGenerator.Emit(OpCodes.Stfld' fieldInfo);            }else              this.ILGenerator.Emit(OpCodes.Stsfld' fieldInfo);            return;          case NodeType.Parameter:            ParameterBinding pb = target as ParameterBinding;            if (pb != null) target = pb.BoundParameter;            Parameter par = (Parameter)target;            this.Visit(assignment.Source);            int pi = par.ArgumentListIndex;            if (pi < 256)               this.ILGenerator.Emit(OpCodes.Starg_S' (byte)pi);            else              this.ILGenerator.Emit(OpCodes.Starg' (ushort)pi);            return;          case NodeType.Indexer:            Indexer indexer = (Indexer)target;            this.Visit(indexer.Object);            if (indexer.Operands != null && indexer.Operands.Count == 1)              this.Visit(indexer.Operands[0]);            this.Visit(assignment.Source);            Type elementType = indexer.ElementType == null ? null : indexer.ElementType.GetRuntimeType();            if (elementType == null) {Debug.Fail(""); return; }            this.ILGenerator.Emit(OpCodes.Ldelema' elementType);            System.Reflection.Emit.OpCode opCode;            //^ assert indexer.ElementType != null;            switch (indexer.ElementType.typeCode){              case ElementType.UIntPtr:              case ElementType.IntPtr: opCode = OpCodes.Stelem_I; break;              case ElementType.Boolean:              case ElementType.Int8:              case ElementType.UInt8: opCode = OpCodes.Stelem_I1; break;              case ElementType.Char:              case ElementType.Int16:              case ElementType.UInt16: opCode = OpCodes.Stelem_I2; break;              case ElementType.Int32:              case ElementType.UInt32: opCode = OpCodes.Stelem_I4; break;              case ElementType.Int64:              case ElementType.UInt64: opCode = OpCodes.Stelem_I8; break;              case ElementType.Single: opCode = OpCodes.Stelem_R4; break;              case ElementType.Double: opCode = OpCodes.Stelem_R8; break;              default:                if (indexer.ElementType.NodeType == NodeType.TypeParameter || indexer.ElementType.NodeType == NodeType.ClassParameter)                  opCode = OpCodes.Stelem;                else if (TypeNode.StripModifiers(indexer.ElementType) is Pointer)                  opCode = OpCodes.Stelem_I;                else                  opCode = OpCodes.Stelem_Ref;                break;            }            if (opCode.Name == OpCodes.Stelem.Name)              this.ILGenerator.Emit(opCode' indexer.ElementType.GetRuntimeType());            else              this.ILGenerator.Emit(opCode);            return;          case NodeType.AddressDereference:            AddressDereference adr = (AddressDereference)target;            if (adr.Type == null) { Debug.Fail(""); return; }            this.Visit(adr.Address);            if (adr.Type.IsValueType || adr.Type is TypeParameter){              Literal lit = assignment.Source as Literal;              if (lit != null && lit.Value == null){                this.ILGenerator.Emit(OpCodes.Initobj' adr.Type.GetRuntimeType());                return;              }            }            this.Visit(assignment.Source);            if (adr.Alignment > 0)              this.ILGenerator.Emit(OpCodes.Unaligned' (byte)adr.Alignment);            if (adr.Volatile)              this.ILGenerator.Emit(OpCodes.Volatile);            TypeNode adrType = TypeNode.StripModifiers(adr.Type);            //^ assert adrType != null;            switch (adrType.typeCode){              case ElementType.Int8:              case ElementType.UInt8: this.ILGenerator.Emit(OpCodes.Stind_I1); return;              case ElementType.Int16:              case ElementType.UInt16: this.ILGenerator.Emit(OpCodes.Stind_I2); return;              case ElementType.Int32:              case ElementType.UInt32: this.ILGenerator.Emit(OpCodes.Stind_I4); return;              case ElementType.Int64:              case ElementType.UInt64: this.ILGenerator.Emit(OpCodes.Stind_I8); return;              case ElementType.Single: this.ILGenerator.Emit(OpCodes.Stind_R4); return;              case ElementType.Double: this.ILGenerator.Emit(OpCodes.Stind_R8); return;              case ElementType.UIntPtr:              case ElementType.IntPtr: this.ILGenerator.Emit(OpCodes.Stind_I); return;              default:                if (adrType != null && (adrType.IsValueType ||                  adrType.NodeType == NodeType.TypeParameter || adrType.NodeType == NodeType.ClassParameter)){                  this.ILGenerator.Emit(OpCodes.Stobj' adrType.GetRuntimeType());                  return;                }                if (adrType.NodeType == NodeType.Pointer){                  this.ILGenerator.Emit(OpCodes.Stind_I);                   return;                }                this.ILGenerator.Emit(OpCodes.Stind_Ref);                return;            }          default:            Debug.Assert(false' "unexpected assignment target");            return;        }
Magic Number,Microsoft.Cci,ReGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI\ILGenerator.cs,VisitLocal,The following statement contains a magic number: switch(li){          case 0: this.ILGenerator.Emit(OpCodes.Ldloc_0); return;          case 1: this.ILGenerator.Emit(OpCodes.Ldloc_1); return;          case 2: this.ILGenerator.Emit(OpCodes.Ldloc_2); return;          case 3: this.ILGenerator.Emit(OpCodes.Ldloc_3); return;          default:            if (li < 256)              this.ILGenerator.Emit(OpCodes.Ldloc_S' (byte)li);            else              this.ILGenerator.Emit(OpCodes.Ldloc' (ushort)li);            return;        }
Magic Number,Microsoft.Cci,ReGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI\ILGenerator.cs,VisitLocal,The following statement contains a magic number: switch(li){          case 0: this.ILGenerator.Emit(OpCodes.Ldloc_0); return;          case 1: this.ILGenerator.Emit(OpCodes.Ldloc_1); return;          case 2: this.ILGenerator.Emit(OpCodes.Ldloc_2); return;          case 3: this.ILGenerator.Emit(OpCodes.Ldloc_3); return;          default:            if (li < 256)              this.ILGenerator.Emit(OpCodes.Ldloc_S' (byte)li);            else              this.ILGenerator.Emit(OpCodes.Ldloc' (ushort)li);            return;        }
Magic Number,Microsoft.Cci,ReGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI\ILGenerator.cs,VisitLocal,The following statement contains a magic number: switch(li){          case 0: this.ILGenerator.Emit(OpCodes.Ldloc_0); return;          case 1: this.ILGenerator.Emit(OpCodes.Ldloc_1); return;          case 2: this.ILGenerator.Emit(OpCodes.Ldloc_2); return;          case 3: this.ILGenerator.Emit(OpCodes.Ldloc_3); return;          default:            if (li < 256)              this.ILGenerator.Emit(OpCodes.Ldloc_S' (byte)li);            else              this.ILGenerator.Emit(OpCodes.Ldloc' (ushort)li);            return;        }
Magic Number,Microsoft.Cci,ReGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI\ILGenerator.cs,VisitLiteral,The following statement contains a magic number: switch (tc){          case TypeCode.Boolean:          case TypeCode.SByte:          case TypeCode.Byte:          case TypeCode.Char:          case TypeCode.Int16:          case TypeCode.UInt16:          case TypeCode.Int32:          case TypeCode.UInt32:          case TypeCode.Int64:            long n = ic.ToInt64(null);            switch (n){              case -1: this.ILGenerator.Emit(OpCodes.Ldc_I4_M1); break;              case 0 : this.ILGenerator.Emit(OpCodes.Ldc_I4_0); break;              case 1 : this.ILGenerator.Emit(OpCodes.Ldc_I4_1); break;              case 2 : this.ILGenerator.Emit(OpCodes.Ldc_I4_2); break;              case 3 : this.ILGenerator.Emit(OpCodes.Ldc_I4_3); break;              case 4 : this.ILGenerator.Emit(OpCodes.Ldc_I4_4); break;              case 5 : this.ILGenerator.Emit(OpCodes.Ldc_I4_5); break;              case 6 : this.ILGenerator.Emit(OpCodes.Ldc_I4_6); break;              case 7 : this.ILGenerator.Emit(OpCodes.Ldc_I4_7); break;              case 8 : this.ILGenerator.Emit(OpCodes.Ldc_I4_8); break;              default:                if (n >= System.SByte.MinValue && n <= System.SByte.MaxValue){                  this.ILGenerator.Emit(OpCodes.Ldc_I4_S' (byte)n);                }else if (n >= System.Int32.MinValue && n <= System.Int32.MaxValue ||                  n <= System.UInt32.MaxValue && (tc == TypeCode.Char || tc == TypeCode.UInt16 || tc == TypeCode.UInt32)){                  if (n == System.UInt32.MaxValue && tc != TypeCode.Int64)                    this.ILGenerator.Emit(OpCodes.Ldc_I4_M1);                  else{                    this.ILGenerator.Emit(OpCodes.Ldc_I4' (int)n);                  }                }else{                  this.ILGenerator.Emit(OpCodes.Ldc_I8' (long)n);                  tc = TypeCode.Empty; //Suppress conversion to long                }                break;            }            if (tc == TypeCode.Int64)              this.ILGenerator.Emit(OpCodes.Conv_I8);            return;            case TypeCode.UInt64:            this.ILGenerator.Emit(OpCodes.Ldc_I8' ic.ToUInt64(null));            return;            case TypeCode.Single:            this.ILGenerator.Emit(OpCodes.Ldc_R4' ic.ToSingle(null));            return;            case TypeCode.Double:            this.ILGenerator.Emit(OpCodes.Ldc_R8' ic.ToDouble(null));            return;            case TypeCode.String:            this.ILGenerator.Emit(OpCodes.Ldstr' (string)literal.Value);            return;        }
Magic Number,Microsoft.Cci,ReGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI\ILGenerator.cs,VisitLiteral,The following statement contains a magic number: switch (tc){          case TypeCode.Boolean:          case TypeCode.SByte:          case TypeCode.Byte:          case TypeCode.Char:          case TypeCode.Int16:          case TypeCode.UInt16:          case TypeCode.Int32:          case TypeCode.UInt32:          case TypeCode.Int64:            long n = ic.ToInt64(null);            switch (n){              case -1: this.ILGenerator.Emit(OpCodes.Ldc_I4_M1); break;              case 0 : this.ILGenerator.Emit(OpCodes.Ldc_I4_0); break;              case 1 : this.ILGenerator.Emit(OpCodes.Ldc_I4_1); break;              case 2 : this.ILGenerator.Emit(OpCodes.Ldc_I4_2); break;              case 3 : this.ILGenerator.Emit(OpCodes.Ldc_I4_3); break;              case 4 : this.ILGenerator.Emit(OpCodes.Ldc_I4_4); break;              case 5 : this.ILGenerator.Emit(OpCodes.Ldc_I4_5); break;              case 6 : this.ILGenerator.Emit(OpCodes.Ldc_I4_6); break;              case 7 : this.ILGenerator.Emit(OpCodes.Ldc_I4_7); break;              case 8 : this.ILGenerator.Emit(OpCodes.Ldc_I4_8); break;              default:                if (n >= System.SByte.MinValue && n <= System.SByte.MaxValue){                  this.ILGenerator.Emit(OpCodes.Ldc_I4_S' (byte)n);                }else if (n >= System.Int32.MinValue && n <= System.Int32.MaxValue ||                  n <= System.UInt32.MaxValue && (tc == TypeCode.Char || tc == TypeCode.UInt16 || tc == TypeCode.UInt32)){                  if (n == System.UInt32.MaxValue && tc != TypeCode.Int64)                    this.ILGenerator.Emit(OpCodes.Ldc_I4_M1);                  else{                    this.ILGenerator.Emit(OpCodes.Ldc_I4' (int)n);                  }                }else{                  this.ILGenerator.Emit(OpCodes.Ldc_I8' (long)n);                  tc = TypeCode.Empty; //Suppress conversion to long                }                break;            }            if (tc == TypeCode.Int64)              this.ILGenerator.Emit(OpCodes.Conv_I8);            return;            case TypeCode.UInt64:            this.ILGenerator.Emit(OpCodes.Ldc_I8' ic.ToUInt64(null));            return;            case TypeCode.Single:            this.ILGenerator.Emit(OpCodes.Ldc_R4' ic.ToSingle(null));            return;            case TypeCode.Double:            this.ILGenerator.Emit(OpCodes.Ldc_R8' ic.ToDouble(null));            return;            case TypeCode.String:            this.ILGenerator.Emit(OpCodes.Ldstr' (string)literal.Value);            return;        }
Magic Number,Microsoft.Cci,ReGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI\ILGenerator.cs,VisitLiteral,The following statement contains a magic number: switch (tc){          case TypeCode.Boolean:          case TypeCode.SByte:          case TypeCode.Byte:          case TypeCode.Char:          case TypeCode.Int16:          case TypeCode.UInt16:          case TypeCode.Int32:          case TypeCode.UInt32:          case TypeCode.Int64:            long n = ic.ToInt64(null);            switch (n){              case -1: this.ILGenerator.Emit(OpCodes.Ldc_I4_M1); break;              case 0 : this.ILGenerator.Emit(OpCodes.Ldc_I4_0); break;              case 1 : this.ILGenerator.Emit(OpCodes.Ldc_I4_1); break;              case 2 : this.ILGenerator.Emit(OpCodes.Ldc_I4_2); break;              case 3 : this.ILGenerator.Emit(OpCodes.Ldc_I4_3); break;              case 4 : this.ILGenerator.Emit(OpCodes.Ldc_I4_4); break;              case 5 : this.ILGenerator.Emit(OpCodes.Ldc_I4_5); break;              case 6 : this.ILGenerator.Emit(OpCodes.Ldc_I4_6); break;              case 7 : this.ILGenerator.Emit(OpCodes.Ldc_I4_7); break;              case 8 : this.ILGenerator.Emit(OpCodes.Ldc_I4_8); break;              default:                if (n >= System.SByte.MinValue && n <= System.SByte.MaxValue){                  this.ILGenerator.Emit(OpCodes.Ldc_I4_S' (byte)n);                }else if (n >= System.Int32.MinValue && n <= System.Int32.MaxValue ||                  n <= System.UInt32.MaxValue && (tc == TypeCode.Char || tc == TypeCode.UInt16 || tc == TypeCode.UInt32)){                  if (n == System.UInt32.MaxValue && tc != TypeCode.Int64)                    this.ILGenerator.Emit(OpCodes.Ldc_I4_M1);                  else{                    this.ILGenerator.Emit(OpCodes.Ldc_I4' (int)n);                  }                }else{                  this.ILGenerator.Emit(OpCodes.Ldc_I8' (long)n);                  tc = TypeCode.Empty; //Suppress conversion to long                }                break;            }            if (tc == TypeCode.Int64)              this.ILGenerator.Emit(OpCodes.Conv_I8);            return;            case TypeCode.UInt64:            this.ILGenerator.Emit(OpCodes.Ldc_I8' ic.ToUInt64(null));            return;            case TypeCode.Single:            this.ILGenerator.Emit(OpCodes.Ldc_R4' ic.ToSingle(null));            return;            case TypeCode.Double:            this.ILGenerator.Emit(OpCodes.Ldc_R8' ic.ToDouble(null));            return;            case TypeCode.String:            this.ILGenerator.Emit(OpCodes.Ldstr' (string)literal.Value);            return;        }
Magic Number,Microsoft.Cci,ReGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI\ILGenerator.cs,VisitLiteral,The following statement contains a magic number: switch (tc){          case TypeCode.Boolean:          case TypeCode.SByte:          case TypeCode.Byte:          case TypeCode.Char:          case TypeCode.Int16:          case TypeCode.UInt16:          case TypeCode.Int32:          case TypeCode.UInt32:          case TypeCode.Int64:            long n = ic.ToInt64(null);            switch (n){              case -1: this.ILGenerator.Emit(OpCodes.Ldc_I4_M1); break;              case 0 : this.ILGenerator.Emit(OpCodes.Ldc_I4_0); break;              case 1 : this.ILGenerator.Emit(OpCodes.Ldc_I4_1); break;              case 2 : this.ILGenerator.Emit(OpCodes.Ldc_I4_2); break;              case 3 : this.ILGenerator.Emit(OpCodes.Ldc_I4_3); break;              case 4 : this.ILGenerator.Emit(OpCodes.Ldc_I4_4); break;              case 5 : this.ILGenerator.Emit(OpCodes.Ldc_I4_5); break;              case 6 : this.ILGenerator.Emit(OpCodes.Ldc_I4_6); break;              case 7 : this.ILGenerator.Emit(OpCodes.Ldc_I4_7); break;              case 8 : this.ILGenerator.Emit(OpCodes.Ldc_I4_8); break;              default:                if (n >= System.SByte.MinValue && n <= System.SByte.MaxValue){                  this.ILGenerator.Emit(OpCodes.Ldc_I4_S' (byte)n);                }else if (n >= System.Int32.MinValue && n <= System.Int32.MaxValue ||                  n <= System.UInt32.MaxValue && (tc == TypeCode.Char || tc == TypeCode.UInt16 || tc == TypeCode.UInt32)){                  if (n == System.UInt32.MaxValue && tc != TypeCode.Int64)                    this.ILGenerator.Emit(OpCodes.Ldc_I4_M1);                  else{                    this.ILGenerator.Emit(OpCodes.Ldc_I4' (int)n);                  }                }else{                  this.ILGenerator.Emit(OpCodes.Ldc_I8' (long)n);                  tc = TypeCode.Empty; //Suppress conversion to long                }                break;            }            if (tc == TypeCode.Int64)              this.ILGenerator.Emit(OpCodes.Conv_I8);            return;            case TypeCode.UInt64:            this.ILGenerator.Emit(OpCodes.Ldc_I8' ic.ToUInt64(null));            return;            case TypeCode.Single:            this.ILGenerator.Emit(OpCodes.Ldc_R4' ic.ToSingle(null));            return;            case TypeCode.Double:            this.ILGenerator.Emit(OpCodes.Ldc_R8' ic.ToDouble(null));            return;            case TypeCode.String:            this.ILGenerator.Emit(OpCodes.Ldstr' (string)literal.Value);            return;        }
Magic Number,Microsoft.Cci,ReGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI\ILGenerator.cs,VisitLiteral,The following statement contains a magic number: switch (tc){          case TypeCode.Boolean:          case TypeCode.SByte:          case TypeCode.Byte:          case TypeCode.Char:          case TypeCode.Int16:          case TypeCode.UInt16:          case TypeCode.Int32:          case TypeCode.UInt32:          case TypeCode.Int64:            long n = ic.ToInt64(null);            switch (n){              case -1: this.ILGenerator.Emit(OpCodes.Ldc_I4_M1); break;              case 0 : this.ILGenerator.Emit(OpCodes.Ldc_I4_0); break;              case 1 : this.ILGenerator.Emit(OpCodes.Ldc_I4_1); break;              case 2 : this.ILGenerator.Emit(OpCodes.Ldc_I4_2); break;              case 3 : this.ILGenerator.Emit(OpCodes.Ldc_I4_3); break;              case 4 : this.ILGenerator.Emit(OpCodes.Ldc_I4_4); break;              case 5 : this.ILGenerator.Emit(OpCodes.Ldc_I4_5); break;              case 6 : this.ILGenerator.Emit(OpCodes.Ldc_I4_6); break;              case 7 : this.ILGenerator.Emit(OpCodes.Ldc_I4_7); break;              case 8 : this.ILGenerator.Emit(OpCodes.Ldc_I4_8); break;              default:                if (n >= System.SByte.MinValue && n <= System.SByte.MaxValue){                  this.ILGenerator.Emit(OpCodes.Ldc_I4_S' (byte)n);                }else if (n >= System.Int32.MinValue && n <= System.Int32.MaxValue ||                  n <= System.UInt32.MaxValue && (tc == TypeCode.Char || tc == TypeCode.UInt16 || tc == TypeCode.UInt32)){                  if (n == System.UInt32.MaxValue && tc != TypeCode.Int64)                    this.ILGenerator.Emit(OpCodes.Ldc_I4_M1);                  else{                    this.ILGenerator.Emit(OpCodes.Ldc_I4' (int)n);                  }                }else{                  this.ILGenerator.Emit(OpCodes.Ldc_I8' (long)n);                  tc = TypeCode.Empty; //Suppress conversion to long                }                break;            }            if (tc == TypeCode.Int64)              this.ILGenerator.Emit(OpCodes.Conv_I8);            return;            case TypeCode.UInt64:            this.ILGenerator.Emit(OpCodes.Ldc_I8' ic.ToUInt64(null));            return;            case TypeCode.Single:            this.ILGenerator.Emit(OpCodes.Ldc_R4' ic.ToSingle(null));            return;            case TypeCode.Double:            this.ILGenerator.Emit(OpCodes.Ldc_R8' ic.ToDouble(null));            return;            case TypeCode.String:            this.ILGenerator.Emit(OpCodes.Ldstr' (string)literal.Value);            return;        }
Magic Number,Microsoft.Cci,ReGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI\ILGenerator.cs,VisitLiteral,The following statement contains a magic number: switch (tc){          case TypeCode.Boolean:          case TypeCode.SByte:          case TypeCode.Byte:          case TypeCode.Char:          case TypeCode.Int16:          case TypeCode.UInt16:          case TypeCode.Int32:          case TypeCode.UInt32:          case TypeCode.Int64:            long n = ic.ToInt64(null);            switch (n){              case -1: this.ILGenerator.Emit(OpCodes.Ldc_I4_M1); break;              case 0 : this.ILGenerator.Emit(OpCodes.Ldc_I4_0); break;              case 1 : this.ILGenerator.Emit(OpCodes.Ldc_I4_1); break;              case 2 : this.ILGenerator.Emit(OpCodes.Ldc_I4_2); break;              case 3 : this.ILGenerator.Emit(OpCodes.Ldc_I4_3); break;              case 4 : this.ILGenerator.Emit(OpCodes.Ldc_I4_4); break;              case 5 : this.ILGenerator.Emit(OpCodes.Ldc_I4_5); break;              case 6 : this.ILGenerator.Emit(OpCodes.Ldc_I4_6); break;              case 7 : this.ILGenerator.Emit(OpCodes.Ldc_I4_7); break;              case 8 : this.ILGenerator.Emit(OpCodes.Ldc_I4_8); break;              default:                if (n >= System.SByte.MinValue && n <= System.SByte.MaxValue){                  this.ILGenerator.Emit(OpCodes.Ldc_I4_S' (byte)n);                }else if (n >= System.Int32.MinValue && n <= System.Int32.MaxValue ||                  n <= System.UInt32.MaxValue && (tc == TypeCode.Char || tc == TypeCode.UInt16 || tc == TypeCode.UInt32)){                  if (n == System.UInt32.MaxValue && tc != TypeCode.Int64)                    this.ILGenerator.Emit(OpCodes.Ldc_I4_M1);                  else{                    this.ILGenerator.Emit(OpCodes.Ldc_I4' (int)n);                  }                }else{                  this.ILGenerator.Emit(OpCodes.Ldc_I8' (long)n);                  tc = TypeCode.Empty; //Suppress conversion to long                }                break;            }            if (tc == TypeCode.Int64)              this.ILGenerator.Emit(OpCodes.Conv_I8);            return;            case TypeCode.UInt64:            this.ILGenerator.Emit(OpCodes.Ldc_I8' ic.ToUInt64(null));            return;            case TypeCode.Single:            this.ILGenerator.Emit(OpCodes.Ldc_R4' ic.ToSingle(null));            return;            case TypeCode.Double:            this.ILGenerator.Emit(OpCodes.Ldc_R8' ic.ToDouble(null));            return;            case TypeCode.String:            this.ILGenerator.Emit(OpCodes.Ldstr' (string)literal.Value);            return;        }
Magic Number,Microsoft.Cci,ReGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI\ILGenerator.cs,VisitLiteral,The following statement contains a magic number: switch (tc){          case TypeCode.Boolean:          case TypeCode.SByte:          case TypeCode.Byte:          case TypeCode.Char:          case TypeCode.Int16:          case TypeCode.UInt16:          case TypeCode.Int32:          case TypeCode.UInt32:          case TypeCode.Int64:            long n = ic.ToInt64(null);            switch (n){              case -1: this.ILGenerator.Emit(OpCodes.Ldc_I4_M1); break;              case 0 : this.ILGenerator.Emit(OpCodes.Ldc_I4_0); break;              case 1 : this.ILGenerator.Emit(OpCodes.Ldc_I4_1); break;              case 2 : this.ILGenerator.Emit(OpCodes.Ldc_I4_2); break;              case 3 : this.ILGenerator.Emit(OpCodes.Ldc_I4_3); break;              case 4 : this.ILGenerator.Emit(OpCodes.Ldc_I4_4); break;              case 5 : this.ILGenerator.Emit(OpCodes.Ldc_I4_5); break;              case 6 : this.ILGenerator.Emit(OpCodes.Ldc_I4_6); break;              case 7 : this.ILGenerator.Emit(OpCodes.Ldc_I4_7); break;              case 8 : this.ILGenerator.Emit(OpCodes.Ldc_I4_8); break;              default:                if (n >= System.SByte.MinValue && n <= System.SByte.MaxValue){                  this.ILGenerator.Emit(OpCodes.Ldc_I4_S' (byte)n);                }else if (n >= System.Int32.MinValue && n <= System.Int32.MaxValue ||                  n <= System.UInt32.MaxValue && (tc == TypeCode.Char || tc == TypeCode.UInt16 || tc == TypeCode.UInt32)){                  if (n == System.UInt32.MaxValue && tc != TypeCode.Int64)                    this.ILGenerator.Emit(OpCodes.Ldc_I4_M1);                  else{                    this.ILGenerator.Emit(OpCodes.Ldc_I4' (int)n);                  }                }else{                  this.ILGenerator.Emit(OpCodes.Ldc_I8' (long)n);                  tc = TypeCode.Empty; //Suppress conversion to long                }                break;            }            if (tc == TypeCode.Int64)              this.ILGenerator.Emit(OpCodes.Conv_I8);            return;            case TypeCode.UInt64:            this.ILGenerator.Emit(OpCodes.Ldc_I8' ic.ToUInt64(null));            return;            case TypeCode.Single:            this.ILGenerator.Emit(OpCodes.Ldc_R4' ic.ToSingle(null));            return;            case TypeCode.Double:            this.ILGenerator.Emit(OpCodes.Ldc_R8' ic.ToDouble(null));            return;            case TypeCode.String:            this.ILGenerator.Emit(OpCodes.Ldstr' (string)literal.Value);            return;        }
Magic Number,Microsoft.Cci,ReGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI\ILGenerator.cs,VisitParameter,The following statement contains a magic number: switch (pi){          case 0: this.ILGenerator.Emit(OpCodes.Ldarg_0); return;          case 1: this.ILGenerator.Emit(OpCodes.Ldarg_1); return;          case 2: this.ILGenerator.Emit(OpCodes.Ldarg_2); return;          case 3: this.ILGenerator.Emit(OpCodes.Ldarg_3); return;          default:            if (pi < 256)              this.ILGenerator.Emit(OpCodes.Ldarg_S' (byte)pi);            else              this.ILGenerator.Emit(OpCodes.Ldarg' (ushort)pi);            return;        }
Magic Number,Microsoft.Cci,ReGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI\ILGenerator.cs,VisitParameter,The following statement contains a magic number: switch (pi){          case 0: this.ILGenerator.Emit(OpCodes.Ldarg_0); return;          case 1: this.ILGenerator.Emit(OpCodes.Ldarg_1); return;          case 2: this.ILGenerator.Emit(OpCodes.Ldarg_2); return;          case 3: this.ILGenerator.Emit(OpCodes.Ldarg_3); return;          default:            if (pi < 256)              this.ILGenerator.Emit(OpCodes.Ldarg_S' (byte)pi);            else              this.ILGenerator.Emit(OpCodes.Ldarg' (ushort)pi);            return;        }
Magic Number,Microsoft.Cci,ReGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI\ILGenerator.cs,VisitParameter,The following statement contains a magic number: switch (pi){          case 0: this.ILGenerator.Emit(OpCodes.Ldarg_0); return;          case 1: this.ILGenerator.Emit(OpCodes.Ldarg_1); return;          case 2: this.ILGenerator.Emit(OpCodes.Ldarg_2); return;          case 3: this.ILGenerator.Emit(OpCodes.Ldarg_3); return;          default:            if (pi < 256)              this.ILGenerator.Emit(OpCodes.Ldarg_S' (byte)pi);            else              this.ILGenerator.Emit(OpCodes.Ldarg' (ushort)pi);            return;        }
Magic Number,Microsoft.Cci,AliasDefinitionList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,AliasDefinitionList,The following statement contains a magic number: this.elements = new AliasDefinition[4];
Magic Number,Microsoft.Cci,AliasDefinitionList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          AliasDefinition[] newElements = new AliasDefinition[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,AliasDefinitionList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          AliasDefinition[] newElements = new AliasDefinition[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,AliasDefinitionList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          AliasDefinition[] newElements = new AliasDefinition[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,AssemblyNodeList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,AssemblyNodeList,The following statement contains a magic number: this.elements = new AssemblyNode[4];
Magic Number,Microsoft.Cci,AssemblyNodeList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          AssemblyNode[] newElements = new AssemblyNode[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,AssemblyNodeList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          AssemblyNode[] newElements = new AssemblyNode[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,AssemblyNodeList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          AssemblyNode[] newElements = new AssemblyNode[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,AssemblyReferenceList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,AssemblyReferenceList,The following statement contains a magic number: this.elements = new AssemblyReference[4];
Magic Number,Microsoft.Cci,AssemblyReferenceList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          AssemblyReference[] newElements = new AssemblyReference[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,AssemblyReferenceList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          AssemblyReference[] newElements = new AssemblyReference[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,AssemblyReferenceList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          AssemblyReference[] newElements = new AssemblyReference[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,BlockList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,BlockList,The following statement contains a magic number: this.elements = new Block[4];
Magic Number,Microsoft.Cci,BlockList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          Block[] newElements = new Block[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,BlockList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          Block[] newElements = new Block[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,BlockList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          Block[] newElements = new Block[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,CatchList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,CatchList,The following statement contains a magic number: this.elements = new Catch[4];
Magic Number,Microsoft.Cci,CatchList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          Catch[] newElements = new Catch[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,CatchList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          Catch[] newElements = new Catch[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,CatchList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          Catch[] newElements = new Catch[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,CompilationList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,CompilationList,The following statement contains a magic number: this.elements = new Compilation[4];
Magic Number,Microsoft.Cci,CompilationList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          Compilation[] newElements = new Compilation[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,CompilationList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          Compilation[] newElements = new Compilation[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,CompilationList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          Compilation[] newElements = new Compilation[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,CompilationUnitList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,CompilationUnitList,The following statement contains a magic number: this.elements = new CompilationUnit[4];
Magic Number,Microsoft.Cci,CompilationUnitList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          CompilationUnit[] newElements = new CompilationUnit[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,CompilationUnitList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          CompilationUnit[] newElements = new CompilationUnit[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,CompilationUnitList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          CompilationUnit[] newElements = new CompilationUnit[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,CompilationUnitSnippetList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,CompilationUnitSnippetList,The following statement contains a magic number: this.elements = new CompilationUnitSnippet[4];
Magic Number,Microsoft.Cci,CompilationUnitSnippetList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          CompilationUnitSnippet[] newElements = new CompilationUnitSnippet[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,CompilationUnitSnippetList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          CompilationUnitSnippet[] newElements = new CompilationUnitSnippet[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,CompilationUnitSnippetList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          CompilationUnitSnippet[] newElements = new CompilationUnitSnippet[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,EventList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,EventList,The following statement contains a magic number: this.elements = new Event[8];
Magic Number,Microsoft.Cci,EventList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 8) m = 8;          Event[] newElements = new Event[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,EventList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 8) m = 8;          Event[] newElements = new Event[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,EventList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 8) m = 8;          Event[] newElements = new Event[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,ErrorNodeList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,ErrorNodeList,The following statement contains a magic number: this.elements = new ErrorNode[8];
Magic Number,Microsoft.Cci,ErrorNodeList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 8) m = 8;          ErrorNode[] newElements = new ErrorNode[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,ErrorNodeList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 8) m = 8;          ErrorNode[] newElements = new ErrorNode[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,ErrorNodeList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 8) m = 8;          ErrorNode[] newElements = new ErrorNode[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,ErrorNodeComparer,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Compare,The following statement contains a magic number: int loc1 = e1.SourceContext.StartLine * 1000 + e1.SourceContext.StartColumn;
Magic Number,Microsoft.Cci,ErrorNodeComparer,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Compare,The following statement contains a magic number: int loc2 = e2.SourceContext.StartLine * 1000 + e2.SourceContext.StartColumn;
Magic Number,Microsoft.Cci,ExpressionList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,ExpressionList,The following statement contains a magic number: this.elements = new Expression[8];
Magic Number,Microsoft.Cci,ExpressionList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 8) m = 8;          Expression[] newElements = new Expression[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,ExpressionList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 8) m = 8;          Expression[] newElements = new Expression[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,ExpressionList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 8) m = 8;          Expression[] newElements = new Expression[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,ExceptionHandlerList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          ExceptionHandler[] newElements = new ExceptionHandler[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,ExceptionHandlerList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          ExceptionHandler[] newElements = new ExceptionHandler[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,ExceptionHandlerList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          ExceptionHandler[] newElements = new ExceptionHandler[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,FaultHandlerList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,FaultHandlerList,The following statement contains a magic number: this.elements = new FaultHandler[4];
Magic Number,Microsoft.Cci,FaultHandlerList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          FaultHandler[] newElements = new FaultHandler[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,FaultHandlerList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          FaultHandler[] newElements = new FaultHandler[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,FaultHandlerList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          FaultHandler[] newElements = new FaultHandler[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,FieldList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,FieldList,The following statement contains a magic number: this.elements = new Field[8];
Magic Number,Microsoft.Cci,FieldList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 8) m = 8;          Field[] newElements = new Field[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,FieldList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 8) m = 8;          Field[] newElements = new Field[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,FieldList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 8) m = 8;          Field[] newElements = new Field[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,FilterList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,FilterList,The following statement contains a magic number: this.elements = new Filter[4];
Magic Number,Microsoft.Cci,FilterList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          Filter[] newElements = new Filter[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,FilterList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          Filter[] newElements = new Filter[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,FilterList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          Filter[] newElements = new Filter[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,IdentifierList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,IdentifierList,The following statement contains a magic number: this.elements = new Identifier[8];
Magic Number,Microsoft.Cci,IdentifierList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 8) m = 8;          Identifier[] newElements = new Identifier[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,IdentifierList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 8) m = 8;          Identifier[] newElements = new Identifier[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,IdentifierList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 8) m = 8;          Identifier[] newElements = new Identifier[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,InstructionList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,InstructionList,The following statement contains a magic number: this.elements = new Instruction[32];
Magic Number,Microsoft.Cci,InstructionList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 32) m = 32;          Instruction[] newElements = new Instruction[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,InstructionList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 32) m = 32;          Instruction[] newElements = new Instruction[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,InstructionList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 32) m = 32;          Instruction[] newElements = new Instruction[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,InterfaceList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,InterfaceList,The following statement contains a magic number: this.elements = new Interface[8];
Magic Number,Microsoft.Cci,InterfaceList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 8) m = 8;          Interface[] newElements = new Interface[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,InterfaceList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 8) m = 8;          Interface[] newElements = new Interface[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,InterfaceList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 8) m = 8;          Interface[] newElements = new Interface[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,Int32List,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Int32List,The following statement contains a magic number: this.elements = new Int32[8];
Magic Number,Microsoft.Cci,Int32List,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 8) m = 8;          Int32[] newElements = new Int32[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,Int32List,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 8) m = 8;          Int32[] newElements = new Int32[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,Int32List,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 8) m = 8;          Int32[] newElements = new Int32[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,ISourceTextList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,ISourceTextList,The following statement contains a magic number: this.elements = new ISourceText[4];
Magic Number,Microsoft.Cci,ISourceTextList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          ISourceText[] newElements = new ISourceText[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,ISourceTextList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          ISourceText[] newElements = new ISourceText[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,ISourceTextList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          ISourceText[] newElements = new ISourceText[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,LocalDeclarationList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,LocalDeclarationList,The following statement contains a magic number: this.elements = new LocalDeclaration[8];
Magic Number,Microsoft.Cci,LocalDeclarationList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 8) m = 8;          LocalDeclaration[] newElements = new LocalDeclaration[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,LocalDeclarationList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 8) m = 8;          LocalDeclaration[] newElements = new LocalDeclaration[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,LocalDeclarationList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 8) m = 8;          LocalDeclaration[] newElements = new LocalDeclaration[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,MemberList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,MemberList,The following statement contains a magic number: this.elements = new Member[16];
Magic Number,Microsoft.Cci,MemberList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 16) m = 16;          Member[] newElements = new Member[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,MemberList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 16) m = 16;          Member[] newElements = new Member[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,MemberList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 16) m = 16;          Member[] newElements = new Member[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,MemberList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,AddList,The following statement contains a magic number: if (newN > n) {          int m = newN; if (m < 16) m = 16;          Member[] newElements = new Member[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,MemberList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,AddList,The following statement contains a magic number: if (newN > n) {          int m = newN; if (m < 16) m = 16;          Member[] newElements = new Member[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,MemberBindingList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,MemberBindingList,The following statement contains a magic number: this.elements = new MemberBinding[8];
Magic Number,Microsoft.Cci,MemberBindingList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 8) m = 8;          MemberBinding[] newElements = new MemberBinding[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,MemberBindingList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 8) m = 8;          MemberBinding[] newElements = new MemberBinding[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,MemberBindingList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 8) m = 8;          MemberBinding[] newElements = new MemberBinding[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,MethodList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,MethodList,The following statement contains a magic number: this.elements = new Method[8];
Magic Number,Microsoft.Cci,MethodList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 8) m = 8;          Method[] newElements = new Method[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,MethodList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 8) m = 8;          Method[] newElements = new Method[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,MethodList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 8) m = 8;          Method[] newElements = new Method[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,ModuleList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,ModuleList,The following statement contains a magic number: this.elements = new Module[4];
Magic Number,Microsoft.Cci,ModuleList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          Module[] newElements = new Module[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,ModuleList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          Module[] newElements = new Module[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,ModuleList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          Module[] newElements = new Module[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,ModuleReferenceList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,ModuleReferenceList,The following statement contains a magic number: this.elements = new ModuleReference[4];
Magic Number,Microsoft.Cci,ModuleReferenceList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          ModuleReference[] newElements = new ModuleReference[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,ModuleReferenceList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          ModuleReference[] newElements = new ModuleReference[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,ModuleReferenceList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          ModuleReference[] newElements = new ModuleReference[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,NamespaceList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,NamespaceList,The following statement contains a magic number: this.elements = new Namespace[4];
Magic Number,Microsoft.Cci,NamespaceList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          Namespace[] newElements = new Namespace[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,NamespaceList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          Namespace[] newElements = new Namespace[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,NamespaceList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          Namespace[] newElements = new Namespace[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,NodeList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,NodeList,The following statement contains a magic number: this.elements = new Node[4];
Magic Number,Microsoft.Cci,NodeList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          Node[] newElements = new Node[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,NodeList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          Node[] newElements = new Node[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,NodeList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          Node[] newElements = new Node[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,ParameterList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,ParameterList,The following statement contains a magic number: this.elements = new Parameter[8];
Magic Number,Microsoft.Cci,ParameterList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 8) m = 8;          Parameter[] newElements = new Parameter[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,ParameterList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 8) m = 8;          Parameter[] newElements = new Parameter[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,ParameterList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 8) m = 8;          Parameter[] newElements = new Parameter[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,PropertyList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,PropertyList,The following statement contains a magic number: this.elements = new Property[8];
Magic Number,Microsoft.Cci,PropertyList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 8) m = 8;          Property[] newElements = new Property[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,PropertyList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 8) m = 8;          Property[] newElements = new Property[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,PropertyList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 8) m = 8;          Property[] newElements = new Property[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,ScopeList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,ScopeList,The following statement contains a magic number: this.elements = new Scope[32];
Magic Number,Microsoft.Cci,ScopeList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 32) m = 32;          Scope[] newElements = new Scope[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,ScopeList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 32) m = 32;          Scope[] newElements = new Scope[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,ScopeList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 32) m = 32;          Scope[] newElements = new Scope[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,ScopeList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Insert,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 32) m = 32;          Scope[] newElements = new Scope[m];          for (int j = 0; j < index; j++) newElements[j] = elements[j];          newElements[index] = element;          for (int j = index; j < n; j++) newElements[j+1] = elements[j];          return;        }
Magic Number,Microsoft.Cci,ScopeList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Insert,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 32) m = 32;          Scope[] newElements = new Scope[m];          for (int j = 0; j < index; j++) newElements[j] = elements[j];          newElements[index] = element;          for (int j = index; j < n; j++) newElements[j+1] = elements[j];          return;        }
Magic Number,Microsoft.Cci,ScopeList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Insert,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 32) m = 32;          Scope[] newElements = new Scope[m];          for (int j = 0; j < index; j++) newElements[j] = elements[j];          newElements[index] = element;          for (int j = index; j < n; j++) newElements[j+1] = elements[j];          return;        }
Magic Number,Microsoft.Cci,SecurityAttributeList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,SecurityAttributeList,The following statement contains a magic number: this.elements = new SecurityAttribute[8];
Magic Number,Microsoft.Cci,SecurityAttributeList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 8) m = 8;          SecurityAttribute[] newElements = new SecurityAttribute[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,SecurityAttributeList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 8) m = 8;          SecurityAttribute[] newElements = new SecurityAttribute[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,SecurityAttributeList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 8) m = 8;          SecurityAttribute[] newElements = new SecurityAttribute[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,SourceChangeList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,SourceChangeList,The following statement contains a magic number: this.elements = new SourceChange[4];
Magic Number,Microsoft.Cci,SourceChangeList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          SourceChange[] newElements = new SourceChange[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,SourceChangeList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          SourceChange[] newElements = new SourceChange[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,SourceChangeList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          SourceChange[] newElements = new SourceChange[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,StatementList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,StatementList,The following statement contains a magic number: this.elements = new Statement[32];
Magic Number,Microsoft.Cci,StatementList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 32) m = 32;          Statement[] newElements = new Statement[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,StatementList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 32) m = 32;          Statement[] newElements = new Statement[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,StatementList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 32) m = 32;          Statement[] newElements = new Statement[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,StringList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,StringList,The following statement contains a magic number: this.elements = new string[4];
Magic Number,Microsoft.Cci,StringList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          String[] newElements = new String[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,StringList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          String[] newElements = new String[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,StringList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          String[] newElements = new String[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,SwitchCaseList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,SwitchCaseList,The following statement contains a magic number: this.elements = new SwitchCase[16];
Magic Number,Microsoft.Cci,SwitchCaseList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 16) m = 16;          SwitchCase[] newElements = new SwitchCase[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,SwitchCaseList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 16) m = 16;          SwitchCase[] newElements = new SwitchCase[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,SwitchCaseList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 16) m = 16;          SwitchCase[] newElements = new SwitchCase[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,TypeswitchCaseList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,TypeswitchCaseList,The following statement contains a magic number: this.elements = new TypeswitchCase[16];
Magic Number,Microsoft.Cci,TypeswitchCaseList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 16) m = 16;          TypeswitchCase[] newElements = new TypeswitchCase[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,TypeswitchCaseList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 16) m = 16;          TypeswitchCase[] newElements = new TypeswitchCase[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,TypeswitchCaseList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 16) m = 16;          TypeswitchCase[] newElements = new TypeswitchCase[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,UsedNamespaceList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,UsedNamespaceList,The following statement contains a magic number: this.elements = new UsedNamespace[4];
Magic Number,Microsoft.Cci,UsedNamespaceList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          UsedNamespace[] newElements = new UsedNamespace[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,UsedNamespaceList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          UsedNamespace[] newElements = new UsedNamespace[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,UsedNamespaceList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          UsedNamespace[] newElements = new UsedNamespace[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,VariableDeclarationList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,VariableDeclarationList,The following statement contains a magic number: this.elements = new VariableDeclaration[4];
Magic Number,Microsoft.Cci,VariableDeclarationList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          VariableDeclaration[] newElements = new VariableDeclaration[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,VariableDeclarationList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          VariableDeclaration[] newElements = new VariableDeclaration[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,VariableDeclarationList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          VariableDeclaration[] newElements = new VariableDeclaration[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,Win32ResourceList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Win32ResourceList,The following statement contains a magic number: this.elements = new Win32Resource[4];
Magic Number,Microsoft.Cci,Win32ResourceList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          Win32Resource[] newElements = new Win32Resource[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,Win32ResourceList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          Win32Resource[] newElements = new Win32Resource[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,Win32ResourceList,C:\repos\Reactive-Extensions_IL2JS\CCI\ListTemplate.cs,Add,The following statement contains a magic number: if (i == n){          int m = n*2; if (m < 4) m = 4;          Win32Resource[] newElements = new Win32Resource[m];          for (int j = 0; j < n; j++) newElements[j] = elements[j];          this.elements = newElements;        }
Magic Number,Microsoft.Cci,Document,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,Search,The following statement contains a magic number: while (low < high){          mid = (low+high)/2;          if (lineOffsets[mid] <= offset){            if (offset < lineOffsets[mid+1])              return mid;            else              low = mid + 1;          }else            high = mid;        }
Magic Number,Microsoft.Cci,Document,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,AddOffset,The following statement contains a magic number: if (this.lines >= this.lineOffsets.Length){          int n = this.lineOffsets.Length;          if (n <= 0) n = 16;          int[] newLineOffsets = new int[n*2];          Array.Copy(this.lineOffsets' newLineOffsets' this.lineOffsets.Length);          this.lineOffsets = newLineOffsets;        }
Magic Number,Microsoft.Cci,Document,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,AddOffset,The following statement contains a magic number: if (this.lines >= this.lineOffsets.Length){          int n = this.lineOffsets.Length;          if (n <= 0) n = 16;          int[] newLineOffsets = new int[n*2];          Array.Copy(this.lineOffsets' newLineOffsets' this.lineOffsets.Length);          this.lineOffsets = newLineOffsets;        }
Magic Number,Microsoft.Cci,Document,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,ComputeLineOffsets,The following statement contains a magic number: this.lineOffsets = new int[n/10+1];
Magic Number,Microsoft.Cci,Document,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,ComputeLineOffsets,The following statement contains a magic number: this.AddOffset(n+2);
Magic Number,Microsoft.Cci,UnmanagedDocument,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,UnmanagedDocument,The following statement contains a magic number: if (idoc != null){          try{  #if !FxCop            idoc.GetDocumentType(out this.DocumentType);            idoc.GetLanguage(out this.Language);            idoc.GetLanguageVendor(out this.LanguageVendor);  #endif            uint capacity = 1024;            uint len = 0;            char[] buffer = new char[capacity];            while (capacity >= 1024){              idoc.GetURL(capacity' out len' buffer);              if (len < capacity) break;              capacity += 1024;              buffer = new char[capacity];            }            if (len > 0)              this.Name = new String(buffer' 0' (int)len-1);          }finally{            System.Runtime.InteropServices.Marshal.ReleaseComObject(idoc);          }        }
Magic Number,Microsoft.Cci,UnmanagedDocument,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,UnmanagedDocument,The following statement contains a magic number: if (idoc != null){          try{  #if !FxCop            idoc.GetDocumentType(out this.DocumentType);            idoc.GetLanguage(out this.Language);            idoc.GetLanguageVendor(out this.LanguageVendor);  #endif            uint capacity = 1024;            uint len = 0;            char[] buffer = new char[capacity];            while (capacity >= 1024){              idoc.GetURL(capacity' out len' buffer);              if (len < capacity) break;              capacity += 1024;              buffer = new char[capacity];            }            if (len > 0)              this.Name = new String(buffer' 0' (int)len-1);          }finally{            System.Runtime.InteropServices.Marshal.ReleaseComObject(idoc);          }        }
Magic Number,Microsoft.Cci,UnmanagedDocument,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,UnmanagedDocument,The following statement contains a magic number: if (idoc != null){          try{  #if !FxCop            idoc.GetDocumentType(out this.DocumentType);            idoc.GetLanguage(out this.Language);            idoc.GetLanguageVendor(out this.LanguageVendor);  #endif            uint capacity = 1024;            uint len = 0;            char[] buffer = new char[capacity];            while (capacity >= 1024){              idoc.GetURL(capacity' out len' buffer);              if (len < capacity) break;              capacity += 1024;              buffer = new char[capacity];            }            if (len > 0)              this.Name = new String(buffer' 0' (int)len-1);          }finally{            System.Runtime.InteropServices.Marshal.ReleaseComObject(idoc);          }        }
Magic Number,Microsoft.Cci,UnmanagedDocument,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,BinarySearch,The following statement contains a magic number: while (low < high){          mid = low + (high-low)/2;          if (list[mid] <= value){            if (list[mid+1] > value)              return mid;            else              low = mid + 1;          }else            high = mid;        }
Magic Number,Microsoft.Cci,TrivialHashtable,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,TrivialHashtable,The following statement contains a magic number: this.entries = new HashEntry[16];
Magic Number,Microsoft.Cci,TrivialHashtable,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,TrivialHashtable,The following statement contains a magic number: int initialSize = 16;
Magic Number,Microsoft.Cci,TrivialHashtable,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,TrivialHashtable,The following statement contains a magic number: if (initialSize < 0) initialSize = 16;
Magic Number,Microsoft.Cci,TrivialHashtable,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,Expand,The following statement contains a magic number: int m = n*2;
Magic Number,Microsoft.Cci,TrivialHashtableUsingWeakReferences,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,TrivialHashtableUsingWeakReferences,The following statement contains a magic number: this.entries = new HashEntry[16];
Magic Number,Microsoft.Cci,TrivialHashtableUsingWeakReferences,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,TrivialHashtableUsingWeakReferences,The following statement contains a magic number: int initialSize = 16;
Magic Number,Microsoft.Cci,TrivialHashtableUsingWeakReferences,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,TrivialHashtableUsingWeakReferences,The following statement contains a magic number: if (initialSize < 0) initialSize = 16;
Magic Number,Microsoft.Cci,TrivialHashtableUsingWeakReferences,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,Expand,The following statement contains a magic number: int m = n*2;
Magic Number,Microsoft.Cci,TrivialHashtableUsingWeakReferences,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,Contract,The following statement contains a magic number: int m = n/2;
Magic Number,Microsoft.Cci,TrivialHashtableUsingWeakReferences,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,Contract,The following statement contains a magic number: if (m < 16) return;
Magic Number,Microsoft.Cci,Literal,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,Initialize,The following statement contains a magic number: Literal.Int32Two = new Literal(2' CoreSystemTypes.Int32);
Magic Number,Microsoft.Cci,Literal,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,Initialize,The following statement contains a magic number: Literal.Int32Sixteen = new Literal(16' CoreSystemTypes.Int32);
Magic Number,Microsoft.Cci,Identifier,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,Identifier,The following statement contains a magic number: for (int i = offset' n = length+i; i < n; i++){          char ch = text[i];          hcode = hcode*17 + ch;        }
Magic Number,Microsoft.Cci,Identifier,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,Identifier,The following statement contains a magic number: for (int i = 0; i < n; i++){          char ch = name[i];          hcode = hcode*17 + ch;        }
Magic Number,Microsoft.Cci,Identifier,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,Identifier,The following statement contains a magic number: for (int i = offset; ; i++){          byte b = *(pointer+i);          if (b == 0) break;          if ((b & 0x80) != 0) isASCII = false;          hcode = hcode*17 + b;          length++;        }
Magic Number,Microsoft.Cci,Identifier,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,Identifier,The following statement contains a magic number: for (int i = 0' n = this.length = name.Length; i < n; i++){          char ch = name[i];          hcode = hcode*17 + ch;        }
Magic Number,Microsoft.Cci,Identifier,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,Identifier,The following statement contains a magic number: for (uint i = 0; i < length; i++){          byte b = *(pointer+i);          if ((b & 0x80) != 0) goto doUTF8decoding;          hcode = hcode*17 + b;        }
Magic Number,Microsoft.Cci,Identifier,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,Identifier,The following statement contains a magic number: for (int i = 0' n = this.length = name.Length; i < n; i++){          char ch = name[i];          hcode = hcode*17 + ch;        }
Magic Number,Microsoft.Cci,Identifier,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetUniqueIdKey,The following statement contains a magic number: lock(Identifier.Lock){          int hcode = this.hashCode;          CanonicalIdentifier[] hTable = Identifier.HashTable;          int length = hTable.Length;          int i = hcode % length;          CanonicalIdentifier id = hTable[i];          while (id.Name != null){            if (this.HasSameNameAs(id)) return id.UniqueIdKey;            i = (i+1) % length;            id = hTable[i];          }          int count = Identifier.count;          int countp1 = count+1;          Identifier.count = countp1;          string name = this.Name; //Get a local copy of the name and drop any reference to a DocumentText instance          hTable[i] = new CanonicalIdentifier(name' countp1' hcode);          if (countp1 > length/2) Rehash(); //Threshold exceeded' need to rehash                  return countp1;        }
Magic Number,Microsoft.Cci,Identifier,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,Rehash,The following statement contains a magic number: int n2 = n*2;
Magic Number,Microsoft.Cci,Module,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetType,The following statement contains a magic number: if (nsTable != null){          result = (TypeNode)nsTable[name.UniqueIdKey];          if (result == Class.DoesNotExist) return null;          if (result != null) return result;        }else{                lock (Module.GlobalLock){            nsTable = (TrivialHashtable)this.namespaceTable[@namespace.UniqueIdKey];            if (nsTable == null)              this.namespaceTable[@namespace.UniqueIdKey] = nsTable = new TrivialHashtable(32);          }        }
Magic Number,Microsoft.Cci,Module,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,WriteDocumentation,The following statement contains a magic number: xwriter.Indentation = 2;
Magic Number,Microsoft.Cci,AssemblyNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetAssemblyName,The following statement contains a magic number: if (this.assemblyName == null){          System.Reflection.AssemblyName aName = new System.Reflection.AssemblyName();          if (this.Location != null && this.Location != "unknown:location"){            StringBuilder sb = new StringBuilder("file:///");            sb.Append(Path.GetFullPath(this.Location));            sb.Replace('\\'' '/');            aName.CodeBase = sb.ToString();          }          aName.CultureInfo = new System.Globalization.CultureInfo(this.Culture);          if (this.PublicKeyOrToken != null && this.PublicKeyOrToken.Length > 8)            aName.Flags = System.Reflection.AssemblyNameFlags.PublicKey;          if ((this.Flags & AssemblyFlags.Retargetable) != 0)            aName.Flags |= (System.Reflection.AssemblyNameFlags)AssemblyFlags.Retargetable;          aName.HashAlgorithm = (System.Configuration.Assemblies.AssemblyHashAlgorithm)this.HashAlgorithm;          if (this.PublicKeyOrToken != null && this.PublicKeyOrToken.Length > 0)            aName.SetPublicKey(this.PublicKeyOrToken);          else            aName.SetPublicKey(new byte[0]);          aName.Name = this.Name;          aName.Version = this.Version;          switch (this.Flags & AssemblyFlags.CompatibilityMask){            case AssemblyFlags.NonSideBySideCompatible:              aName.VersionCompatibility = System.Configuration.Assemblies.AssemblyVersionCompatibility.SameDomain;              break;            case AssemblyFlags.NonSideBySideProcess:              aName.VersionCompatibility = System.Configuration.Assemblies.AssemblyVersionCompatibility.SameProcess;              break;            case AssemblyFlags.NonSideBySideMachine:              aName.VersionCompatibility = System.Configuration.Assemblies.AssemblyVersionCompatibility.SameMachine;              break;          }          this.assemblyName = aName;        }
Magic Number,Microsoft.Cci,AssemblyNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetKeyString,The following statement contains a magic number: if (n > 8){  #if !ROTOR          System.Security.Cryptography.SHA1 sha1 = new System.Security.Cryptography.SHA1CryptoServiceProvider();          publicKey = sha1.ComputeHash(publicKey);          byte[] token = new byte[8];          for (int i = 0' m = publicKey.Length-1; i < 8; i++)            token[i] = publicKey[m-i];          publicKey = token;          n = 8;  #else          n = 0; //TODO: figure out how to compute the token on ROTOR  #endif        }
Magic Number,Microsoft.Cci,AssemblyNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetKeyString,The following statement contains a magic number: if (n > 8){  #if !ROTOR          System.Security.Cryptography.SHA1 sha1 = new System.Security.Cryptography.SHA1CryptoServiceProvider();          publicKey = sha1.ComputeHash(publicKey);          byte[] token = new byte[8];          for (int i = 0' m = publicKey.Length-1; i < 8; i++)            token[i] = publicKey[m-i];          publicKey = token;          n = 8;  #else          n = 0; //TODO: figure out how to compute the token on ROTOR  #endif        }
Magic Number,Microsoft.Cci,AssemblyNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetKeyString,The following statement contains a magic number: if (n > 8){  #if !ROTOR          System.Security.Cryptography.SHA1 sha1 = new System.Security.Cryptography.SHA1CryptoServiceProvider();          publicKey = sha1.ComputeHash(publicKey);          byte[] token = new byte[8];          for (int i = 0' m = publicKey.Length-1; i < 8; i++)            token[i] = publicKey[m-i];          publicKey = token;          n = 8;  #else          n = 0; //TODO: figure out how to compute the token on ROTOR  #endif        }
Magic Number,Microsoft.Cci,AssemblyNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetKeyString,The following statement contains a magic number: if (n > 8){  #if !ROTOR          System.Security.Cryptography.SHA1 sha1 = new System.Security.Cryptography.SHA1CryptoServiceProvider();          publicKey = sha1.ComputeHash(publicKey);          byte[] token = new byte[8];          for (int i = 0' m = publicKey.Length-1; i < 8; i++)            token[i] = publicKey[m-i];          publicKey = token;          n = 8;  #else          n = 0; //TODO: figure out how to compute the token on ROTOR  #endif        }
Magic Number,Microsoft.Cci,AssemblyNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetKeyString,The following statement contains a magic number: if (n == 0)          str = new StringBuilder("' PublicKeyToken=null");        else          str = new StringBuilder("' PublicKeyToken="' n*2+17);
Magic Number,Microsoft.Cci,AssemblyNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetKeyString,The following statement contains a magic number: if (n == 0)          str = new StringBuilder("' PublicKeyToken=null");        else          str = new StringBuilder("' PublicKeyToken="' n*2+17);
Magic Number,Microsoft.Cci,AssemblyReference,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (assembly.PublicKeyOrToken != null && assembly.PublicKeyOrToken.Length > 8)          this.flags |= AssemblyFlags.PublicKey;
Magic Number,Microsoft.Cci,AssemblyReference,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (token != null && (n = token.Length) > 0){          if (n > 16){            ArrayList tokArr = new ArrayList();            if (n % 2 == 1){              tokArr.Add(byte.Parse(token.Substring(0' 1)' System.Globalization.NumberStyles.HexNumber' null));              n--;            }            for (i = 0; i < n; i += 2) {  #if WHIDBEY              byte b = 0;              bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);              Debug.Assert(goodByte);  #else              byte b = byte.Parse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null);  #endif              tokArr.Add(b);            }            tok = (byte[])tokArr.ToArray(typeof(byte));          }else{            ulong tk = ulong.Parse(token' System.Globalization.NumberStyles.HexNumber' null);            tok = new byte[8];            tok[0] = (byte)(tk >> 56);            tok[1] = (byte)(tk >> 48);            tok[2] = (byte)(tk >> 40);            tok[3] = (byte)(tk >> 32);            tok[4] = (byte)(tk >> 24);            tok[5] = (byte)(tk >> 16);            tok[6] = (byte)(tk >> 8);            tok[7] = (byte)tk;          }        }
Magic Number,Microsoft.Cci,AssemblyReference,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (token != null && (n = token.Length) > 0){          if (n > 16){            ArrayList tokArr = new ArrayList();            if (n % 2 == 1){              tokArr.Add(byte.Parse(token.Substring(0' 1)' System.Globalization.NumberStyles.HexNumber' null));              n--;            }            for (i = 0; i < n; i += 2) {  #if WHIDBEY              byte b = 0;              bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);              Debug.Assert(goodByte);  #else              byte b = byte.Parse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null);  #endif              tokArr.Add(b);            }            tok = (byte[])tokArr.ToArray(typeof(byte));          }else{            ulong tk = ulong.Parse(token' System.Globalization.NumberStyles.HexNumber' null);            tok = new byte[8];            tok[0] = (byte)(tk >> 56);            tok[1] = (byte)(tk >> 48);            tok[2] = (byte)(tk >> 40);            tok[3] = (byte)(tk >> 32);            tok[4] = (byte)(tk >> 24);            tok[5] = (byte)(tk >> 16);            tok[6] = (byte)(tk >> 8);            tok[7] = (byte)tk;          }        }
Magic Number,Microsoft.Cci,AssemblyReference,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (token != null && (n = token.Length) > 0){          if (n > 16){            ArrayList tokArr = new ArrayList();            if (n % 2 == 1){              tokArr.Add(byte.Parse(token.Substring(0' 1)' System.Globalization.NumberStyles.HexNumber' null));              n--;            }            for (i = 0; i < n; i += 2) {  #if WHIDBEY              byte b = 0;              bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);              Debug.Assert(goodByte);  #else              byte b = byte.Parse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null);  #endif              tokArr.Add(b);            }            tok = (byte[])tokArr.ToArray(typeof(byte));          }else{            ulong tk = ulong.Parse(token' System.Globalization.NumberStyles.HexNumber' null);            tok = new byte[8];            tok[0] = (byte)(tk >> 56);            tok[1] = (byte)(tk >> 48);            tok[2] = (byte)(tk >> 40);            tok[3] = (byte)(tk >> 32);            tok[4] = (byte)(tk >> 24);            tok[5] = (byte)(tk >> 16);            tok[6] = (byte)(tk >> 8);            tok[7] = (byte)tk;          }        }
Magic Number,Microsoft.Cci,AssemblyReference,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (token != null && (n = token.Length) > 0){          if (n > 16){            ArrayList tokArr = new ArrayList();            if (n % 2 == 1){              tokArr.Add(byte.Parse(token.Substring(0' 1)' System.Globalization.NumberStyles.HexNumber' null));              n--;            }            for (i = 0; i < n; i += 2) {  #if WHIDBEY              byte b = 0;              bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);              Debug.Assert(goodByte);  #else              byte b = byte.Parse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null);  #endif              tokArr.Add(b);            }            tok = (byte[])tokArr.ToArray(typeof(byte));          }else{            ulong tk = ulong.Parse(token' System.Globalization.NumberStyles.HexNumber' null);            tok = new byte[8];            tok[0] = (byte)(tk >> 56);            tok[1] = (byte)(tk >> 48);            tok[2] = (byte)(tk >> 40);            tok[3] = (byte)(tk >> 32);            tok[4] = (byte)(tk >> 24);            tok[5] = (byte)(tk >> 16);            tok[6] = (byte)(tk >> 8);            tok[7] = (byte)tk;          }        }
Magic Number,Microsoft.Cci,AssemblyReference,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (token != null && (n = token.Length) > 0){          if (n > 16){            ArrayList tokArr = new ArrayList();            if (n % 2 == 1){              tokArr.Add(byte.Parse(token.Substring(0' 1)' System.Globalization.NumberStyles.HexNumber' null));              n--;            }            for (i = 0; i < n; i += 2) {  #if WHIDBEY              byte b = 0;              bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);              Debug.Assert(goodByte);  #else              byte b = byte.Parse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null);  #endif              tokArr.Add(b);            }            tok = (byte[])tokArr.ToArray(typeof(byte));          }else{            ulong tk = ulong.Parse(token' System.Globalization.NumberStyles.HexNumber' null);            tok = new byte[8];            tok[0] = (byte)(tk >> 56);            tok[1] = (byte)(tk >> 48);            tok[2] = (byte)(tk >> 40);            tok[3] = (byte)(tk >> 32);            tok[4] = (byte)(tk >> 24);            tok[5] = (byte)(tk >> 16);            tok[6] = (byte)(tk >> 8);            tok[7] = (byte)tk;          }        }
Magic Number,Microsoft.Cci,AssemblyReference,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (token != null && (n = token.Length) > 0){          if (n > 16){            ArrayList tokArr = new ArrayList();            if (n % 2 == 1){              tokArr.Add(byte.Parse(token.Substring(0' 1)' System.Globalization.NumberStyles.HexNumber' null));              n--;            }            for (i = 0; i < n; i += 2) {  #if WHIDBEY              byte b = 0;              bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);              Debug.Assert(goodByte);  #else              byte b = byte.Parse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null);  #endif              tokArr.Add(b);            }            tok = (byte[])tokArr.ToArray(typeof(byte));          }else{            ulong tk = ulong.Parse(token' System.Globalization.NumberStyles.HexNumber' null);            tok = new byte[8];            tok[0] = (byte)(tk >> 56);            tok[1] = (byte)(tk >> 48);            tok[2] = (byte)(tk >> 40);            tok[3] = (byte)(tk >> 32);            tok[4] = (byte)(tk >> 24);            tok[5] = (byte)(tk >> 16);            tok[6] = (byte)(tk >> 8);            tok[7] = (byte)tk;          }        }
Magic Number,Microsoft.Cci,AssemblyReference,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (token != null && (n = token.Length) > 0){          if (n > 16){            ArrayList tokArr = new ArrayList();            if (n % 2 == 1){              tokArr.Add(byte.Parse(token.Substring(0' 1)' System.Globalization.NumberStyles.HexNumber' null));              n--;            }            for (i = 0; i < n; i += 2) {  #if WHIDBEY              byte b = 0;              bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);              Debug.Assert(goodByte);  #else              byte b = byte.Parse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null);  #endif              tokArr.Add(b);            }            tok = (byte[])tokArr.ToArray(typeof(byte));          }else{            ulong tk = ulong.Parse(token' System.Globalization.NumberStyles.HexNumber' null);            tok = new byte[8];            tok[0] = (byte)(tk >> 56);            tok[1] = (byte)(tk >> 48);            tok[2] = (byte)(tk >> 40);            tok[3] = (byte)(tk >> 32);            tok[4] = (byte)(tk >> 24);            tok[5] = (byte)(tk >> 16);            tok[6] = (byte)(tk >> 8);            tok[7] = (byte)tk;          }        }
Magic Number,Microsoft.Cci,AssemblyReference,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (token != null && (n = token.Length) > 0){          if (n > 16){            ArrayList tokArr = new ArrayList();            if (n % 2 == 1){              tokArr.Add(byte.Parse(token.Substring(0' 1)' System.Globalization.NumberStyles.HexNumber' null));              n--;            }            for (i = 0; i < n; i += 2) {  #if WHIDBEY              byte b = 0;              bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);              Debug.Assert(goodByte);  #else              byte b = byte.Parse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null);  #endif              tokArr.Add(b);            }            tok = (byte[])tokArr.ToArray(typeof(byte));          }else{            ulong tk = ulong.Parse(token' System.Globalization.NumberStyles.HexNumber' null);            tok = new byte[8];            tok[0] = (byte)(tk >> 56);            tok[1] = (byte)(tk >> 48);            tok[2] = (byte)(tk >> 40);            tok[3] = (byte)(tk >> 32);            tok[4] = (byte)(tk >> 24);            tok[5] = (byte)(tk >> 16);            tok[6] = (byte)(tk >> 8);            tok[7] = (byte)tk;          }        }
Magic Number,Microsoft.Cci,AssemblyReference,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (token != null && (n = token.Length) > 0){          if (n > 16){            ArrayList tokArr = new ArrayList();            if (n % 2 == 1){              tokArr.Add(byte.Parse(token.Substring(0' 1)' System.Globalization.NumberStyles.HexNumber' null));              n--;            }            for (i = 0; i < n; i += 2) {  #if WHIDBEY              byte b = 0;              bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);              Debug.Assert(goodByte);  #else              byte b = byte.Parse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null);  #endif              tokArr.Add(b);            }            tok = (byte[])tokArr.ToArray(typeof(byte));          }else{            ulong tk = ulong.Parse(token' System.Globalization.NumberStyles.HexNumber' null);            tok = new byte[8];            tok[0] = (byte)(tk >> 56);            tok[1] = (byte)(tk >> 48);            tok[2] = (byte)(tk >> 40);            tok[3] = (byte)(tk >> 32);            tok[4] = (byte)(tk >> 24);            tok[5] = (byte)(tk >> 16);            tok[6] = (byte)(tk >> 8);            tok[7] = (byte)tk;          }        }
Magic Number,Microsoft.Cci,AssemblyReference,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (token != null && (n = token.Length) > 0){          if (n > 16){            ArrayList tokArr = new ArrayList();            if (n % 2 == 1){              tokArr.Add(byte.Parse(token.Substring(0' 1)' System.Globalization.NumberStyles.HexNumber' null));              n--;            }            for (i = 0; i < n; i += 2) {  #if WHIDBEY              byte b = 0;              bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);              Debug.Assert(goodByte);  #else              byte b = byte.Parse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null);  #endif              tokArr.Add(b);            }            tok = (byte[])tokArr.ToArray(typeof(byte));          }else{            ulong tk = ulong.Parse(token' System.Globalization.NumberStyles.HexNumber' null);            tok = new byte[8];            tok[0] = (byte)(tk >> 56);            tok[1] = (byte)(tk >> 48);            tok[2] = (byte)(tk >> 40);            tok[3] = (byte)(tk >> 32);            tok[4] = (byte)(tk >> 24);            tok[5] = (byte)(tk >> 16);            tok[6] = (byte)(tk >> 8);            tok[7] = (byte)tk;          }        }
Magic Number,Microsoft.Cci,AssemblyReference,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (token != null && (n = token.Length) > 0){          if (n > 16){            ArrayList tokArr = new ArrayList();            if (n % 2 == 1){              tokArr.Add(byte.Parse(token.Substring(0' 1)' System.Globalization.NumberStyles.HexNumber' null));              n--;            }            for (i = 0; i < n; i += 2) {  #if WHIDBEY              byte b = 0;              bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);              Debug.Assert(goodByte);  #else              byte b = byte.Parse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null);  #endif              tokArr.Add(b);            }            tok = (byte[])tokArr.ToArray(typeof(byte));          }else{            ulong tk = ulong.Parse(token' System.Globalization.NumberStyles.HexNumber' null);            tok = new byte[8];            tok[0] = (byte)(tk >> 56);            tok[1] = (byte)(tk >> 48);            tok[2] = (byte)(tk >> 40);            tok[3] = (byte)(tk >> 32);            tok[4] = (byte)(tk >> 24);            tok[5] = (byte)(tk >> 16);            tok[6] = (byte)(tk >> 8);            tok[7] = (byte)tk;          }        }
Magic Number,Microsoft.Cci,AssemblyReference,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (token != null && (n = token.Length) > 0){          if (n > 16){            ArrayList tokArr = new ArrayList();            if (n % 2 == 1){              tokArr.Add(byte.Parse(token.Substring(0' 1)' System.Globalization.NumberStyles.HexNumber' null));              n--;            }            for (i = 0; i < n; i += 2) {  #if WHIDBEY              byte b = 0;              bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);              Debug.Assert(goodByte);  #else              byte b = byte.Parse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null);  #endif              tokArr.Add(b);            }            tok = (byte[])tokArr.ToArray(typeof(byte));          }else{            ulong tk = ulong.Parse(token' System.Globalization.NumberStyles.HexNumber' null);            tok = new byte[8];            tok[0] = (byte)(tk >> 56);            tok[1] = (byte)(tk >> 48);            tok[2] = (byte)(tk >> 40);            tok[3] = (byte)(tk >> 32);            tok[4] = (byte)(tk >> 24);            tok[5] = (byte)(tk >> 16);            tok[6] = (byte)(tk >> 8);            tok[7] = (byte)tk;          }        }
Magic Number,Microsoft.Cci,AssemblyReference,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (token != null && (n = token.Length) > 0){          if (n > 16){            ArrayList tokArr = new ArrayList();            if (n % 2 == 1){              tokArr.Add(byte.Parse(token.Substring(0' 1)' System.Globalization.NumberStyles.HexNumber' null));              n--;            }            for (i = 0; i < n; i += 2) {  #if WHIDBEY              byte b = 0;              bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);              Debug.Assert(goodByte);  #else              byte b = byte.Parse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null);  #endif              tokArr.Add(b);            }            tok = (byte[])tokArr.ToArray(typeof(byte));          }else{            ulong tk = ulong.Parse(token' System.Globalization.NumberStyles.HexNumber' null);            tok = new byte[8];            tok[0] = (byte)(tk >> 56);            tok[1] = (byte)(tk >> 48);            tok[2] = (byte)(tk >> 40);            tok[3] = (byte)(tk >> 32);            tok[4] = (byte)(tk >> 24);            tok[5] = (byte)(tk >> 16);            tok[6] = (byte)(tk >> 8);            tok[7] = (byte)tk;          }        }
Magic Number,Microsoft.Cci,AssemblyReference,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (token != null && (n = token.Length) > 0){          if (n > 16){            ArrayList tokArr = new ArrayList();            if (n % 2 == 1){              tokArr.Add(byte.Parse(token.Substring(0' 1)' System.Globalization.NumberStyles.HexNumber' null));              n--;            }            for (i = 0; i < n; i += 2) {  #if WHIDBEY              byte b = 0;              bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);              Debug.Assert(goodByte);  #else              byte b = byte.Parse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null);  #endif              tokArr.Add(b);            }            tok = (byte[])tokArr.ToArray(typeof(byte));          }else{            ulong tk = ulong.Parse(token' System.Globalization.NumberStyles.HexNumber' null);            tok = new byte[8];            tok[0] = (byte)(tk >> 56);            tok[1] = (byte)(tk >> 48);            tok[2] = (byte)(tk >> 40);            tok[3] = (byte)(tk >> 32);            tok[4] = (byte)(tk >> 24);            tok[5] = (byte)(tk >> 16);            tok[6] = (byte)(tk >> 8);            tok[7] = (byte)tk;          }        }
Magic Number,Microsoft.Cci,AssemblyReference,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (token != null && (n = token.Length) > 0){          if (n > 16){            ArrayList tokArr = new ArrayList();            if (n % 2 == 1){              tokArr.Add(byte.Parse(token.Substring(0' 1)' System.Globalization.NumberStyles.HexNumber' null));              n--;            }            for (i = 0; i < n; i += 2) {  #if WHIDBEY              byte b = 0;              bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);              Debug.Assert(goodByte);  #else              byte b = byte.Parse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null);  #endif              tokArr.Add(b);            }            tok = (byte[])tokArr.ToArray(typeof(byte));          }else{            ulong tk = ulong.Parse(token' System.Globalization.NumberStyles.HexNumber' null);            tok = new byte[8];            tok[0] = (byte)(tk >> 56);            tok[1] = (byte)(tk >> 48);            tok[2] = (byte)(tk >> 40);            tok[3] = (byte)(tk >> 32);            tok[4] = (byte)(tk >> 24);            tok[5] = (byte)(tk >> 16);            tok[6] = (byte)(tk >> 8);            tok[7] = (byte)tk;          }        }
Magic Number,Microsoft.Cci,AssemblyReference,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (token != null && (n = token.Length) > 0){          if (n > 16){            ArrayList tokArr = new ArrayList();            if (n % 2 == 1){              tokArr.Add(byte.Parse(token.Substring(0' 1)' System.Globalization.NumberStyles.HexNumber' null));              n--;            }            for (i = 0; i < n; i += 2) {  #if WHIDBEY              byte b = 0;              bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);              Debug.Assert(goodByte);  #else              byte b = byte.Parse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null);  #endif              tokArr.Add(b);            }            tok = (byte[])tokArr.ToArray(typeof(byte));          }else{            ulong tk = ulong.Parse(token' System.Globalization.NumberStyles.HexNumber' null);            tok = new byte[8];            tok[0] = (byte)(tk >> 56);            tok[1] = (byte)(tk >> 48);            tok[2] = (byte)(tk >> 40);            tok[3] = (byte)(tk >> 32);            tok[4] = (byte)(tk >> 24);            tok[5] = (byte)(tk >> 16);            tok[6] = (byte)(tk >> 8);            tok[7] = (byte)tk;          }        }
Magic Number,Microsoft.Cci,AssemblyReference,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (token != null && (n = token.Length) > 0){          if (n > 16){            ArrayList tokArr = new ArrayList();            if (n % 2 == 1){              tokArr.Add(byte.Parse(token.Substring(0' 1)' System.Globalization.NumberStyles.HexNumber' null));              n--;            }            for (i = 0; i < n; i += 2) {  #if WHIDBEY              byte b = 0;              bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);              Debug.Assert(goodByte);  #else              byte b = byte.Parse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null);  #endif              tokArr.Add(b);            }            tok = (byte[])tokArr.ToArray(typeof(byte));          }else{            ulong tk = ulong.Parse(token' System.Globalization.NumberStyles.HexNumber' null);            tok = new byte[8];            tok[0] = (byte)(tk >> 56);            tok[1] = (byte)(tk >> 48);            tok[2] = (byte)(tk >> 40);            tok[3] = (byte)(tk >> 32);            tok[4] = (byte)(tk >> 24);            tok[5] = (byte)(tk >> 16);            tok[6] = (byte)(tk >> 8);            tok[7] = (byte)tk;          }        }
Magic Number,Microsoft.Cci,AssemblyReference,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,AssemblyReference,The following statement contains a magic number: if (token != null && (n = token.Length) > 0){          if (n > 16){            ArrayList tokArr = new ArrayList();            if (n % 2 == 1){              tokArr.Add(byte.Parse(token.Substring(0' 1)' System.Globalization.NumberStyles.HexNumber' null));              n--;            }            for (i = 0; i < n; i += 2) {  #if WHIDBEY              byte b = 0;              bool goodByte = byte.TryParse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null' out b);              Debug.Assert(goodByte);  #else              byte b = byte.Parse(token.Substring(i' 2)' System.Globalization.NumberStyles.HexNumber' null);  #endif              tokArr.Add(b);            }            tok = (byte[])tokArr.ToArray(typeof(byte));          }else{            ulong tk = ulong.Parse(token' System.Globalization.NumberStyles.HexNumber' null);            tok = new byte[8];            tok[0] = (byte)(tk >> 56);            tok[1] = (byte)(tk >> 48);            tok[2] = (byte)(tk >> 40);            tok[3] = (byte)(tk >> 32);            tok[4] = (byte)(tk >> 24);            tok[5] = (byte)(tk >> 16);            tok[6] = (byte)(tk >> 8);            tok[7] = (byte)tk;          }        }
Magic Number,Microsoft.Cci,AssemblyReference,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetAssemblyName,The following statement contains a magic number: if (this.assemblyName == null){          System.Reflection.AssemblyName aName = new System.Reflection.AssemblyName();          aName.CultureInfo = new System.Globalization.CultureInfo(this.Culture == null ? "" : this.Culture);          if (this.PublicKeyOrToken != null && this.PublicKeyOrToken.Length > 8)            aName.Flags = System.Reflection.AssemblyNameFlags.PublicKey;          if ((this.Flags & AssemblyFlags.Retargetable) != 0)            aName.Flags |= (System.Reflection.AssemblyNameFlags)AssemblyFlags.Retargetable;          aName.HashAlgorithm = System.Configuration.Assemblies.AssemblyHashAlgorithm.SHA1;          if (this.PublicKeyOrToken != null){            if (this.PublicKeyOrToken.Length > 8)              aName.SetPublicKey(this.PublicKeyOrToken);            else if (this.PublicKeyOrToken.Length > 0)              aName.SetPublicKeyToken(this.PublicKeyOrToken);          }          else            aName.SetPublicKey(new byte[0]);          aName.Name = this.Name;          aName.Version = this.Version;          switch (this.Flags & AssemblyFlags.CompatibilityMask){            case AssemblyFlags.NonSideBySideCompatible:              aName.VersionCompatibility = System.Configuration.Assemblies.AssemblyVersionCompatibility.SameDomain;              break;            case AssemblyFlags.NonSideBySideProcess:              aName.VersionCompatibility = System.Configuration.Assemblies.AssemblyVersionCompatibility.SameProcess;              break;            case AssemblyFlags.NonSideBySideMachine:              aName.VersionCompatibility = System.Configuration.Assemblies.AssemblyVersionCompatibility.SameMachine;              break;          }          this.assemblyName = aName;        }
Magic Number,Microsoft.Cci,AssemblyReference,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetAssemblyName,The following statement contains a magic number: if (this.assemblyName == null){          System.Reflection.AssemblyName aName = new System.Reflection.AssemblyName();          aName.CultureInfo = new System.Globalization.CultureInfo(this.Culture == null ? "" : this.Culture);          if (this.PublicKeyOrToken != null && this.PublicKeyOrToken.Length > 8)            aName.Flags = System.Reflection.AssemblyNameFlags.PublicKey;          if ((this.Flags & AssemblyFlags.Retargetable) != 0)            aName.Flags |= (System.Reflection.AssemblyNameFlags)AssemblyFlags.Retargetable;          aName.HashAlgorithm = System.Configuration.Assemblies.AssemblyHashAlgorithm.SHA1;          if (this.PublicKeyOrToken != null){            if (this.PublicKeyOrToken.Length > 8)              aName.SetPublicKey(this.PublicKeyOrToken);            else if (this.PublicKeyOrToken.Length > 0)              aName.SetPublicKeyToken(this.PublicKeyOrToken);          }          else            aName.SetPublicKey(new byte[0]);          aName.Name = this.Name;          aName.Version = this.Version;          switch (this.Flags & AssemblyFlags.CompatibilityMask){            case AssemblyFlags.NonSideBySideCompatible:              aName.VersionCompatibility = System.Configuration.Assemblies.AssemblyVersionCompatibility.SameDomain;              break;            case AssemblyFlags.NonSideBySideProcess:              aName.VersionCompatibility = System.Configuration.Assemblies.AssemblyVersionCompatibility.SameProcess;              break;            case AssemblyFlags.NonSideBySideMachine:              aName.VersionCompatibility = System.Configuration.Assemblies.AssemblyVersionCompatibility.SameMachine;              break;          }          this.assemblyName = aName;        }
Magic Number,Microsoft.Cci,Member,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,AppendValue,The following statement contains a magic number: if (str != null){          str = str.Trim();          if (str.Length > 2 && str[1] == ':' && str.LastIndexOfAny(tags' 0' 1) == 0){            char tag = str[0];            str = str.Substring(2);            if (tag == 'T' && str.IndexOf(TargetPlatform.GenericTypeNamesMangleChar) >= 0) {              Module mod = null;              if (this.DeclaringType != null)                mod = this.DeclaringType.DeclaringModule;              else if (this is TypeNode)                mod = ((TypeNode)this).DeclaringModule;              if (mod != null){                Identifier ns;                Identifier tn;                int i = str.LastIndexOf('.');                if (i < 0 || i >= str.Length){                  ns = Identifier.Empty;                  tn = Identifier.For(str);                }else{                  ns = Identifier.For(str.Substring(0' i));                  tn = Identifier.For(str.Substring(i + 1));                }                TypeNode t = mod.GetType(ns' tn' true);                if (t != null) str = t.GetFullUnmangledNameWithTypeParameters();              }            }          }          if (str == null || str.Length == 0) return;          bool lastCharWasSpace = false;          if (sb.Length > 0 && !Char.IsPunctuation(str[0]) && !Char.IsWhiteSpace(str[0])){            sb.Append(' ');            lastCharWasSpace = true;          }          foreach (char ch in str){            if (Char.IsWhiteSpace(ch)){              if (lastCharWasSpace) continue;              lastCharWasSpace = true;              sb.Append(' ');            }else{              lastCharWasSpace = false;              sb.Append(ch);            }          }          if (sb.Length > 0 && Char.IsWhiteSpace(sb[sb.Length-1]))            sb.Length -= 1;        }
Magic Number,Microsoft.Cci,Member,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,AppendValue,The following statement contains a magic number: if (str != null){          str = str.Trim();          if (str.Length > 2 && str[1] == ':' && str.LastIndexOfAny(tags' 0' 1) == 0){            char tag = str[0];            str = str.Substring(2);            if (tag == 'T' && str.IndexOf(TargetPlatform.GenericTypeNamesMangleChar) >= 0) {              Module mod = null;              if (this.DeclaringType != null)                mod = this.DeclaringType.DeclaringModule;              else if (this is TypeNode)                mod = ((TypeNode)this).DeclaringModule;              if (mod != null){                Identifier ns;                Identifier tn;                int i = str.LastIndexOf('.');                if (i < 0 || i >= str.Length){                  ns = Identifier.Empty;                  tn = Identifier.For(str);                }else{                  ns = Identifier.For(str.Substring(0' i));                  tn = Identifier.For(str.Substring(i + 1));                }                TypeNode t = mod.GetType(ns' tn' true);                if (t != null) str = t.GetFullUnmangledNameWithTypeParameters();              }            }          }          if (str == null || str.Length == 0) return;          bool lastCharWasSpace = false;          if (sb.Length > 0 && !Char.IsPunctuation(str[0]) && !Char.IsWhiteSpace(str[0])){            sb.Append(' ');            lastCharWasSpace = true;          }          foreach (char ch in str){            if (Char.IsWhiteSpace(ch)){              if (lastCharWasSpace) continue;              lastCharWasSpace = true;              sb.Append(' ');            }else{              lastCharWasSpace = false;              sb.Append(ch);            }          }          if (sb.Length > 0 && Char.IsWhiteSpace(sb[sb.Length-1]))            sb.Length -= 1;        }
Magic Number,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetArrayType,The following statement contains a magic number: StringBuilder sb = new StringBuilder(rank*5);
Magic Number,Microsoft.Cci,TypeNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,UpdateMemberTable,The following statement contains a magic number: lock(this){          if (this.memberTable == null) this.memberTable = new TrivialHashtable(32);          for (int i = this.memberCount; i < range; i++){            Member mem = thisMembers[i];            if (mem == null || mem.Name == null) continue;            MemberList members = (MemberList)this.memberTable[mem.Name.UniqueIdKey];            if (members == null) this.memberTable[mem.Name.UniqueIdKey] = members = new MemberList();            members.Add(mem);          }          this.memberCount = range;          this.constructors = null;        }
Magic Number,Microsoft.Cci,DelegateNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,ProvideMembers,The following statement contains a magic number: ParameterList parameters = new ParameterList(2);
Magic Number,Microsoft.Cci,DelegateNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,ProvideMembers,The following statement contains a magic number: if (SystemTypes.AsyncCallback.ReturnType != null)        {          //BeginInvoke          ParameterList dparams = this.parameters;          int n = dparams == null ? 0 : dparams.Count;          parameters = new ParameterList(n + 2);          for (int i = 0; i < n; i++)          {            //^ assert dparams != null;            Parameter p = dparams[i];            if (p == null) continue;            parameters.Add((Parameter)p.Clone());          }          parameters.Add(new Parameter(null' ParameterFlags.None' StandardIds.callback' SystemTypes.AsyncCallback' null' null));          parameters.Add(new Parameter(null' ParameterFlags.None' StandardIds.Object' CoreSystemTypes.Object' null' null));          Method beginInvoke = new Method(this' null' StandardIds.BeginInvoke' parameters' SystemTypes.IASyncResult' null);          beginInvoke.Flags = MethodFlags.Public | MethodFlags.HideBySig | MethodFlags.NewSlot | MethodFlags.Virtual;          beginInvoke.CallingConvention = CallingConventionFlags.HasThis;          beginInvoke.ImplFlags = MethodImplFlags.Runtime;          members.Add(beginInvoke);          //EndInvoke          parameters = new ParameterList(1);          for (int i = 0; i < n; i++)          {            Parameter p = dparams[i];            if (p == null || p.Type == null || !(p.Type is Reference)) continue;            parameters.Add((Parameter)p.Clone());          }          parameters.Add(new Parameter(null' ParameterFlags.None' StandardIds.result' SystemTypes.IASyncResult' null' null));          Method endInvoke = new Method(this' null' StandardIds.EndInvoke' parameters' this.ReturnType' null);          endInvoke.Flags = MethodFlags.Public | MethodFlags.HideBySig | MethodFlags.NewSlot | MethodFlags.Virtual;          endInvoke.CallingConvention = CallingConventionFlags.HasThis;          endInvoke.ImplFlags = MethodImplFlags.Runtime;          members.Add(endInvoke);        }
Magic Number,Microsoft.Cci,TargetPlatform,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,SetTo,The following statement contains a magic number: if (version.Major == 1) {          if (version.Minor == 0 && version.Build == 3300) TargetPlatform.SetToV1();          else if (version.Minor == 0 && version.Build == 5000) TargetPlatform.SetToV1_1();          else if (version.Minor == 1 && version.Build == 9999) TargetPlatform.SetToPostV1_1(TargetPlatform.PlatformAssembliesLocation);        } else if (version.Major == 2) {          if (version.Minor == 0 && version.Build == 3600) TargetPlatform.SetToV2Beta1();          else TargetPlatform.SetToV2();        } else          TargetPlatform.SetToV1();
Magic Number,Microsoft.Cci,TargetPlatform,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,SetTo,The following statement contains a magic number: if (version.Major == 1) {          if (version.Minor == 0 && version.Build == 3300) TargetPlatform.SetToV1();          else if (version.Minor == 0 && version.Build == 5000) TargetPlatform.SetToV1_1();          else if (version.Minor == 1 && version.Build == 9999) TargetPlatform.SetToPostV1_1(TargetPlatform.PlatformAssembliesLocation);        } else if (version.Major == 2) {          if (version.Minor == 0 && version.Build == 3600) TargetPlatform.SetToV2Beta1();          else TargetPlatform.SetToV2();        } else          TargetPlatform.SetToV1();
Magic Number,Microsoft.Cci,TargetPlatform,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,SetTo,The following statement contains a magic number: if (version.Major == 1) {          if (version.Minor == 0 && version.Build == 3300) TargetPlatform.SetToV1();          else if (version.Minor == 0 && version.Build == 5000) TargetPlatform.SetToV1_1();          else if (version.Minor == 1 && version.Build == 9999) TargetPlatform.SetToPostV1_1(TargetPlatform.PlatformAssembliesLocation);        } else if (version.Major == 2) {          if (version.Minor == 0 && version.Build == 3600) TargetPlatform.SetToV2Beta1();          else TargetPlatform.SetToV2();        } else          TargetPlatform.SetToV1();
Magic Number,Microsoft.Cci,TargetPlatform,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,SetTo,The following statement contains a magic number: if (version.Major == 1) {          if (version.Minor == 0 && version.Build == 3300) TargetPlatform.SetToV1();          else if (version.Minor == 0 && version.Build == 5000) TargetPlatform.SetToV1_1();          else if (version.Minor == 1 && version.Build == 9999) TargetPlatform.SetToPostV1_1(TargetPlatform.PlatformAssembliesLocation);        } else if (version.Major == 2) {          if (version.Minor == 0 && version.Build == 3600) TargetPlatform.SetToV2Beta1();          else TargetPlatform.SetToV2();        } else          TargetPlatform.SetToV1();
Magic Number,Microsoft.Cci,TargetPlatform,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,SetTo,The following statement contains a magic number: if (version.Major == 1) {          if (version.Minor == 0 && version.Build == 3300) TargetPlatform.SetToV1();          else if (version.Minor == 0 && version.Build == 5000) TargetPlatform.SetToV1_1();          else if (version.Minor == 1 && version.Build == 9999) TargetPlatform.SetToPostV1_1(TargetPlatform.PlatformAssembliesLocation);        } else if (version.Major == 2) {          if (version.Minor == 0 && version.Build == 3600) TargetPlatform.SetToV2Beta1();          else TargetPlatform.SetToV2();        } else          TargetPlatform.SetToV1();
Magic Number,Microsoft.Cci,TargetPlatform,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,SetTo,The following statement contains a magic number: if (version.Major == 1) {          if (version.Minor == 0 && version.Build == 3300) TargetPlatform.SetToV1(platformAssembliesLocation);          else if (version.Minor == 0 && version.Build == 5000) TargetPlatform.SetToV1_1(platformAssembliesLocation);          else if (version.Minor == 1 && version.Build == 9999) TargetPlatform.SetToPostV1_1(platformAssembliesLocation);        } else if (version.Major == 2) {          if (version.Minor == 0 && version.Build == 3600) TargetPlatform.SetToV2Beta1(platformAssembliesLocation);          else TargetPlatform.SetToV2(platformAssembliesLocation);        } else          TargetPlatform.SetToV1(platformAssembliesLocation);
Magic Number,Microsoft.Cci,TargetPlatform,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,SetTo,The following statement contains a magic number: if (version.Major == 1) {          if (version.Minor == 0 && version.Build == 3300) TargetPlatform.SetToV1(platformAssembliesLocation);          else if (version.Minor == 0 && version.Build == 5000) TargetPlatform.SetToV1_1(platformAssembliesLocation);          else if (version.Minor == 1 && version.Build == 9999) TargetPlatform.SetToPostV1_1(platformAssembliesLocation);        } else if (version.Major == 2) {          if (version.Minor == 0 && version.Build == 3600) TargetPlatform.SetToV2Beta1(platformAssembliesLocation);          else TargetPlatform.SetToV2(platformAssembliesLocation);        } else          TargetPlatform.SetToV1(platformAssembliesLocation);
Magic Number,Microsoft.Cci,TargetPlatform,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,SetTo,The following statement contains a magic number: if (version.Major == 1) {          if (version.Minor == 0 && version.Build == 3300) TargetPlatform.SetToV1(platformAssembliesLocation);          else if (version.Minor == 0 && version.Build == 5000) TargetPlatform.SetToV1_1(platformAssembliesLocation);          else if (version.Minor == 1 && version.Build == 9999) TargetPlatform.SetToPostV1_1(platformAssembliesLocation);        } else if (version.Major == 2) {          if (version.Minor == 0 && version.Build == 3600) TargetPlatform.SetToV2Beta1(platformAssembliesLocation);          else TargetPlatform.SetToV2(platformAssembliesLocation);        } else          TargetPlatform.SetToV1(platformAssembliesLocation);
Magic Number,Microsoft.Cci,TargetPlatform,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,SetTo,The following statement contains a magic number: if (version.Major == 1) {          if (version.Minor == 0 && version.Build == 3300) TargetPlatform.SetToV1(platformAssembliesLocation);          else if (version.Minor == 0 && version.Build == 5000) TargetPlatform.SetToV1_1(platformAssembliesLocation);          else if (version.Minor == 1 && version.Build == 9999) TargetPlatform.SetToPostV1_1(platformAssembliesLocation);        } else if (version.Major == 2) {          if (version.Minor == 0 && version.Build == 3600) TargetPlatform.SetToV2Beta1(platformAssembliesLocation);          else TargetPlatform.SetToV2(platformAssembliesLocation);        } else          TargetPlatform.SetToV1(platformAssembliesLocation);
Magic Number,Microsoft.Cci,TargetPlatform,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,SetTo,The following statement contains a magic number: if (version.Major == 1) {          if (version.Minor == 0 && version.Build == 3300) TargetPlatform.SetToV1(platformAssembliesLocation);          else if (version.Minor == 0 && version.Build == 5000) TargetPlatform.SetToV1_1(platformAssembliesLocation);          else if (version.Minor == 1 && version.Build == 9999) TargetPlatform.SetToPostV1_1(platformAssembliesLocation);        } else if (version.Major == 2) {          if (version.Minor == 0 && version.Build == 3600) TargetPlatform.SetToV2Beta1(platformAssembliesLocation);          else TargetPlatform.SetToV2(platformAssembliesLocation);        } else          TargetPlatform.SetToV1(platformAssembliesLocation);
Magic Number,Microsoft.Cci,TargetPlatform,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,SetToV1,The following statement contains a magic number: TargetPlatform.TargetVersion = new Version(1' 0' 3300);
Magic Number,Microsoft.Cci,TargetPlatform,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,SetToV1,The following statement contains a magic number: TrivialHashtable assemblyReferenceFor = new TrivialHashtable(46);
Magic Number,Microsoft.Cci,TargetPlatform,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,SetToV1_1,The following statement contains a magic number: TargetPlatform.TargetVersion = new Version(1' 0' 5000);
Magic Number,Microsoft.Cci,TargetPlatform,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,SetToV1_1,The following statement contains a magic number: TrivialHashtable assemblyReferenceFor = new TrivialHashtable(46);
Magic Number,Microsoft.Cci,TargetPlatform,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,SetToV2,The following statement contains a magic number: TargetPlatform.TargetVersion = new Version(2' 0' 50727);
Magic Number,Microsoft.Cci,TargetPlatform,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,SetToV2,The following statement contains a magic number: TargetPlatform.TargetVersion = new Version(2' 0' 50727);
Magic Number,Microsoft.Cci,TargetPlatform,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,SetToV2,The following statement contains a magic number: TrivialHashtable assemblyReferenceFor = new TrivialHashtable(46);
Magic Number,Microsoft.Cci,TargetPlatform,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,SetToV2Beta1,The following statement contains a magic number: TargetPlatform.TargetVersion = new Version(2' 0' 3600);
Magic Number,Microsoft.Cci,TargetPlatform,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,SetToV2Beta1,The following statement contains a magic number: TargetPlatform.TargetVersion = new Version(2' 0' 3600);
Magic Number,Microsoft.Cci,TargetPlatform,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,SetToV2Beta1,The following statement contains a magic number: TrivialHashtable assemblyReferenceFor = new TrivialHashtable(46);
Magic Number,Microsoft.Cci,TargetPlatform,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,SetToPostV1_1,The following statement contains a magic number: TargetPlatform.TargetVersion = new Version(1' 1' 9999);
Magic Number,Microsoft.Cci,TargetPlatform,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,SetToPostV1_1,The following statement contains a magic number: TargetPlatform.assemblyReferenceFor = new TrivialHashtable(46);
Magic Number,Microsoft.Cci,CoreSystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,Initialize,The following statement contains a magic number: if (TargetPlatform.TargetVersion != null)          {              if (TargetPlatform.TargetVersion.Major > 1 || TargetPlatform.TargetVersion.Minor > 1 ||                (TargetPlatform.TargetVersion.Minor == 1 && TargetPlatform.TargetVersion.Build == 9999))              {                  if (SystemAssembly.IsValidTypeName(StandardIds.System' Identifier.For("Nullable`1")))                      TargetPlatform.GenericTypeNamesMangleChar = '`';                  else if (SystemAssembly.IsValidTypeName(StandardIds.System' Identifier.For("Nullable!1")))                      TargetPlatform.GenericTypeNamesMangleChar = '!';                  else if (TargetPlatform.TargetVersion.Major == 1 && TargetPlatform.TargetVersion.Minor == 2)                      TargetPlatform.GenericTypeNamesMangleChar = (char)0;              }          }
Magic Number,Microsoft.Cci,CoreSystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,Initialize,The following statement contains a magic number: if (TargetPlatform.TargetVersion != null)          {              if (TargetPlatform.TargetVersion.Major > 1 || TargetPlatform.TargetVersion.Minor > 1 ||                (TargetPlatform.TargetVersion.Minor == 1 && TargetPlatform.TargetVersion.Build == 9999))              {                  if (SystemAssembly.IsValidTypeName(StandardIds.System' Identifier.For("Nullable`1")))                      TargetPlatform.GenericTypeNamesMangleChar = '`';                  else if (SystemAssembly.IsValidTypeName(StandardIds.System' Identifier.For("Nullable!1")))                      TargetPlatform.GenericTypeNamesMangleChar = '!';                  else if (TargetPlatform.TargetVersion.Major == 1 && TargetPlatform.TargetVersion.Minor == 2)                      TargetPlatform.GenericTypeNamesMangleChar = (char)0;              }          }
Magic Number,Microsoft.Cci,CoreSystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InstantiateGenericInterfaces,The following statement contains a magic number: if (TargetPlatform.TargetVersion != null && (TargetPlatform.TargetVersion.Major < 2 && TargetPlatform.TargetVersion.Minor < 2)) return;
Magic Number,Microsoft.Cci,CoreSystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InstantiateGenericInterfaces,The following statement contains a magic number: if (TargetPlatform.TargetVersion != null && (TargetPlatform.TargetVersion.Major < 2 && TargetPlatform.TargetVersion.Minor < 2)) return;
Magic Number,Microsoft.Cci,CoreSystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,GetSystemAssembly,The following statement contains a magic number: if (result != null) {          result.TargetRuntimeVersion = TargetPlatform.TargetRuntimeVersion;          result.MetadataFormatMajorVersion = 1;          result.MetadataFormatMinorVersion = 1;          result.LinkerMajorVersion = 8;          result.LinkerMinorVersion = 0;          return result;        }
Magic Number,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The following statement contains a magic number: GenericDictionary = (Class)GetGenericRuntimeTypeNodeFor("System.Collections.Generic"' "Dictionary"' 2' ElementType.Class);
Magic Number,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The following statement contains a magic number: GenericIDictionary = (Interface)GetGenericRuntimeTypeNodeFor("System.Collections.Generic"' "IDictionary"' 2' ElementType.Class);
Magic Number,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The following statement contains a magic number: GenericKeyValuePair = (Struct)GetGenericRuntimeTypeNodeFor("System.Collections.Generic"' "KeyValuePair"' 2' ElementType.ValueType);
Magic Number,Microsoft.Cci,SystemTypes,C:\repos\Reactive-Extensions_IL2JS\CCI\SystemTypes.cs,InitializeSystemTypes,The following statement contains a magic number: GenericSortedDictionary = (Class)GetGenericRuntimeTypeNodeFor("System.Collections.Generic"' "SortedDictionary"' 2' ElementType.Class);
Magic Number,Microsoft.Cci,LocalsStack,C:\repos\Reactive-Extensions_IL2JS\CCI\Unstacker.cs,Grow,The following statement contains a magic number: Local[] newElements = new Local[n+8];
Magic Number,Microsoft.Cci,LocalsStack,C:\repos\Reactive-Extensions_IL2JS\CCI\Unstacker.cs,LocalsStack,The following statement contains a magic number: this.elements = new Local[8];
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,SetupMetadataWriter,The following statement contains a magic number: if (debugSymbolsLocation != null){          // If targeting RTM (Version.Major = 1 and Version.Minor = 0)          // then use Symwriter.pdb as ProgID else use CorSymWriter_SxS          // (Note that RTM version 1.0.3705 has Assembly version 1.0.3300'          // hence the <= 3705 expression.  This also leaves room for RTM SP releases          // with slightly different build numbers).          Type t = null;          if (v.Major == 1 && v.Minor == 0 && v.Build <= 3705){            try{              t = Type.GetTypeFromProgID("Symwriter.pdb"' false);              this.symWriter = (ISymUnmanagedWriter)Activator.CreateInstance(t);              if (this.symWriter != null)                this.symWriter.Initialize(this' debugSymbolsLocation' null' true);                        }catch (Exception){              t = null;              this.symWriter = null;            }          }          if (t == null){            Debug.Assert(this.symWriter == null);            t = Type.GetTypeFromProgID("CorSymWriter_SxS"' false);            if (t != null) {              Guid guid = t.GUID;                // If the compiler was built with Whidbey' then mscoree will pick a matching              // diasymreader.dll out of the Whidbey directory.  But if we are cross-              // compiling' this is *NOT* what we want.  Instead' we want to override              // the shim's logic and explicitly pick a diasymreader.dll from the place              // that matches the version of the output file we are emitting.  This is              // strictly illegal by the CLR's rules.  However' the CLR does not yet              // support cross-compilation' so we have little choice.              if (!UseGenerics) {                Version vcompiler = typeof(object).Assembly.GetName().Version;                if (vcompiler.Major >= 2) {                  // This is the only cross-compilation case we currently support.                  string server = Path.Combine(Path.GetDirectoryName(typeof(object).Assembly.Location)'                                                                   "..\\v1.1.4322\\diasymreader.dll");                  object o = CrossCompileActivate(server' guid);                  this.symWriter = (ISymUnmanagedWriter)o;                }              }              if (this.symWriter == null) {                this.symWriter = (ISymUnmanagedWriter)Activator.CreateInstance(t);              }              if (this.symWriter != null)                this.symWriter.Initialize(this' debugSymbolsLocation' null' true);            } else {              throw new DebugSymbolsCouldNotBeWrittenException();            }          }        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,SetupMetadataWriter,The following statement contains a magic number: if (debugSymbolsLocation != null){          // If targeting RTM (Version.Major = 1 and Version.Minor = 0)          // then use Symwriter.pdb as ProgID else use CorSymWriter_SxS          // (Note that RTM version 1.0.3705 has Assembly version 1.0.3300'          // hence the <= 3705 expression.  This also leaves room for RTM SP releases          // with slightly different build numbers).          Type t = null;          if (v.Major == 1 && v.Minor == 0 && v.Build <= 3705){            try{              t = Type.GetTypeFromProgID("Symwriter.pdb"' false);              this.symWriter = (ISymUnmanagedWriter)Activator.CreateInstance(t);              if (this.symWriter != null)                this.symWriter.Initialize(this' debugSymbolsLocation' null' true);                        }catch (Exception){              t = null;              this.symWriter = null;            }          }          if (t == null){            Debug.Assert(this.symWriter == null);            t = Type.GetTypeFromProgID("CorSymWriter_SxS"' false);            if (t != null) {              Guid guid = t.GUID;                // If the compiler was built with Whidbey' then mscoree will pick a matching              // diasymreader.dll out of the Whidbey directory.  But if we are cross-              // compiling' this is *NOT* what we want.  Instead' we want to override              // the shim's logic and explicitly pick a diasymreader.dll from the place              // that matches the version of the output file we are emitting.  This is              // strictly illegal by the CLR's rules.  However' the CLR does not yet              // support cross-compilation' so we have little choice.              if (!UseGenerics) {                Version vcompiler = typeof(object).Assembly.GetName().Version;                if (vcompiler.Major >= 2) {                  // This is the only cross-compilation case we currently support.                  string server = Path.Combine(Path.GetDirectoryName(typeof(object).Assembly.Location)'                                                                   "..\\v1.1.4322\\diasymreader.dll");                  object o = CrossCompileActivate(server' guid);                  this.symWriter = (ISymUnmanagedWriter)o;                }              }              if (this.symWriter == null) {                this.symWriter = (ISymUnmanagedWriter)Activator.CreateInstance(t);              }              if (this.symWriter != null)                this.symWriter.Initialize(this' debugSymbolsLocation' null' true);            } else {              throw new DebugSymbolsCouldNotBeWrittenException();            }          }        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,SetupMetadataWriter,The following statement contains a magic number: if (writer.fileAlignment < 512) writer.fileAlignment = 512;
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,SetupMetadataWriter,The following statement contains a magic number: if (writer.fileAlignment < 512) writer.fileAlignment = 512;
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetBlobIndex,The following statement contains a magic number: switch(lType.typeCode){          case ElementType.Boolean: this.blobHeap.Write((byte)1); this.blobHeap.Write(ic.ToBoolean(null)); break;          case ElementType.Char: this.blobHeap.Write((byte)2); this.blobHeap.Write(ic.ToChar(null)); break;          case ElementType.Int8: this.blobHeap.Write((byte)1); this.blobHeap.Write(ic.ToSByte(null)); break;          case ElementType.UInt8: this.blobHeap.Write((byte)1); this.blobHeap.Write(ic.ToByte(null)); break;          case ElementType.Int16: this.blobHeap.Write((byte)2); this.blobHeap.Write(ic.ToInt16(null)); break;          case ElementType.UInt16: this.blobHeap.Write((byte)2); this.blobHeap.Write(ic.ToUInt16(null)); break;          case ElementType.Int32: this.blobHeap.Write((byte)4); this.blobHeap.Write(ic.ToInt32(null)); break;          case ElementType.UInt32: this.blobHeap.Write((byte)4); this.blobHeap.Write(ic.ToUInt32(null)); break;          case ElementType.Int64: this.blobHeap.Write((byte)8); this.blobHeap.Write(ic.ToInt64(null)); break;          case ElementType.UInt64: this.blobHeap.Write((byte)8); this.blobHeap.Write(ic.ToUInt64(null)); break;          case ElementType.Single: this.blobHeap.Write((byte)4); this.blobHeap.Write(ic.ToSingle(null)); break;          case ElementType.Double: this.blobHeap.Write((byte)8); this.blobHeap.Write(ic.ToDouble(null)); break;          case ElementType.String: this.blobHeap.Write((string)literal.Value' false); break;          case ElementType.Array:          case ElementType.Class:          case ElementType.Object:          case ElementType.Reference:          case ElementType.SzArray: this.blobHeap.Write((byte)4); this.blobHeap.Write((int)0); break; //REVIEW: standard implies this should be 0' peverify thinks otherwise.          default: Debug.Assert(false' "Unexpected Literal type"); return 0;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetBlobIndex,The following statement contains a magic number: switch(lType.typeCode){          case ElementType.Boolean: this.blobHeap.Write((byte)1); this.blobHeap.Write(ic.ToBoolean(null)); break;          case ElementType.Char: this.blobHeap.Write((byte)2); this.blobHeap.Write(ic.ToChar(null)); break;          case ElementType.Int8: this.blobHeap.Write((byte)1); this.blobHeap.Write(ic.ToSByte(null)); break;          case ElementType.UInt8: this.blobHeap.Write((byte)1); this.blobHeap.Write(ic.ToByte(null)); break;          case ElementType.Int16: this.blobHeap.Write((byte)2); this.blobHeap.Write(ic.ToInt16(null)); break;          case ElementType.UInt16: this.blobHeap.Write((byte)2); this.blobHeap.Write(ic.ToUInt16(null)); break;          case ElementType.Int32: this.blobHeap.Write((byte)4); this.blobHeap.Write(ic.ToInt32(null)); break;          case ElementType.UInt32: this.blobHeap.Write((byte)4); this.blobHeap.Write(ic.ToUInt32(null)); break;          case ElementType.Int64: this.blobHeap.Write((byte)8); this.blobHeap.Write(ic.ToInt64(null)); break;          case ElementType.UInt64: this.blobHeap.Write((byte)8); this.blobHeap.Write(ic.ToUInt64(null)); break;          case ElementType.Single: this.blobHeap.Write((byte)4); this.blobHeap.Write(ic.ToSingle(null)); break;          case ElementType.Double: this.blobHeap.Write((byte)8); this.blobHeap.Write(ic.ToDouble(null)); break;          case ElementType.String: this.blobHeap.Write((string)literal.Value' false); break;          case ElementType.Array:          case ElementType.Class:          case ElementType.Object:          case ElementType.Reference:          case ElementType.SzArray: this.blobHeap.Write((byte)4); this.blobHeap.Write((int)0); break; //REVIEW: standard implies this should be 0' peverify thinks otherwise.          default: Debug.Assert(false' "Unexpected Literal type"); return 0;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetBlobIndex,The following statement contains a magic number: switch(lType.typeCode){          case ElementType.Boolean: this.blobHeap.Write((byte)1); this.blobHeap.Write(ic.ToBoolean(null)); break;          case ElementType.Char: this.blobHeap.Write((byte)2); this.blobHeap.Write(ic.ToChar(null)); break;          case ElementType.Int8: this.blobHeap.Write((byte)1); this.blobHeap.Write(ic.ToSByte(null)); break;          case ElementType.UInt8: this.blobHeap.Write((byte)1); this.blobHeap.Write(ic.ToByte(null)); break;          case ElementType.Int16: this.blobHeap.Write((byte)2); this.blobHeap.Write(ic.ToInt16(null)); break;          case ElementType.UInt16: this.blobHeap.Write((byte)2); this.blobHeap.Write(ic.ToUInt16(null)); break;          case ElementType.Int32: this.blobHeap.Write((byte)4); this.blobHeap.Write(ic.ToInt32(null)); break;          case ElementType.UInt32: this.blobHeap.Write((byte)4); this.blobHeap.Write(ic.ToUInt32(null)); break;          case ElementType.Int64: this.blobHeap.Write((byte)8); this.blobHeap.Write(ic.ToInt64(null)); break;          case ElementType.UInt64: this.blobHeap.Write((byte)8); this.blobHeap.Write(ic.ToUInt64(null)); break;          case ElementType.Single: this.blobHeap.Write((byte)4); this.blobHeap.Write(ic.ToSingle(null)); break;          case ElementType.Double: this.blobHeap.Write((byte)8); this.blobHeap.Write(ic.ToDouble(null)); break;          case ElementType.String: this.blobHeap.Write((string)literal.Value' false); break;          case ElementType.Array:          case ElementType.Class:          case ElementType.Object:          case ElementType.Reference:          case ElementType.SzArray: this.blobHeap.Write((byte)4); this.blobHeap.Write((int)0); break; //REVIEW: standard implies this should be 0' peverify thinks otherwise.          default: Debug.Assert(false' "Unexpected Literal type"); return 0;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetBlobIndex,The following statement contains a magic number: switch(lType.typeCode){          case ElementType.Boolean: this.blobHeap.Write((byte)1); this.blobHeap.Write(ic.ToBoolean(null)); break;          case ElementType.Char: this.blobHeap.Write((byte)2); this.blobHeap.Write(ic.ToChar(null)); break;          case ElementType.Int8: this.blobHeap.Write((byte)1); this.blobHeap.Write(ic.ToSByte(null)); break;          case ElementType.UInt8: this.blobHeap.Write((byte)1); this.blobHeap.Write(ic.ToByte(null)); break;          case ElementType.Int16: this.blobHeap.Write((byte)2); this.blobHeap.Write(ic.ToInt16(null)); break;          case ElementType.UInt16: this.blobHeap.Write((byte)2); this.blobHeap.Write(ic.ToUInt16(null)); break;          case ElementType.Int32: this.blobHeap.Write((byte)4); this.blobHeap.Write(ic.ToInt32(null)); break;          case ElementType.UInt32: this.blobHeap.Write((byte)4); this.blobHeap.Write(ic.ToUInt32(null)); break;          case ElementType.Int64: this.blobHeap.Write((byte)8); this.blobHeap.Write(ic.ToInt64(null)); break;          case ElementType.UInt64: this.blobHeap.Write((byte)8); this.blobHeap.Write(ic.ToUInt64(null)); break;          case ElementType.Single: this.blobHeap.Write((byte)4); this.blobHeap.Write(ic.ToSingle(null)); break;          case ElementType.Double: this.blobHeap.Write((byte)8); this.blobHeap.Write(ic.ToDouble(null)); break;          case ElementType.String: this.blobHeap.Write((string)literal.Value' false); break;          case ElementType.Array:          case ElementType.Class:          case ElementType.Object:          case ElementType.Reference:          case ElementType.SzArray: this.blobHeap.Write((byte)4); this.blobHeap.Write((int)0); break; //REVIEW: standard implies this should be 0' peverify thinks otherwise.          default: Debug.Assert(false' "Unexpected Literal type"); return 0;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetBlobIndex,The following statement contains a magic number: switch(lType.typeCode){          case ElementType.Boolean: this.blobHeap.Write((byte)1); this.blobHeap.Write(ic.ToBoolean(null)); break;          case ElementType.Char: this.blobHeap.Write((byte)2); this.blobHeap.Write(ic.ToChar(null)); break;          case ElementType.Int8: this.blobHeap.Write((byte)1); this.blobHeap.Write(ic.ToSByte(null)); break;          case ElementType.UInt8: this.blobHeap.Write((byte)1); this.blobHeap.Write(ic.ToByte(null)); break;          case ElementType.Int16: this.blobHeap.Write((byte)2); this.blobHeap.Write(ic.ToInt16(null)); break;          case ElementType.UInt16: this.blobHeap.Write((byte)2); this.blobHeap.Write(ic.ToUInt16(null)); break;          case ElementType.Int32: this.blobHeap.Write((byte)4); this.blobHeap.Write(ic.ToInt32(null)); break;          case ElementType.UInt32: this.blobHeap.Write((byte)4); this.blobHeap.Write(ic.ToUInt32(null)); break;          case ElementType.Int64: this.blobHeap.Write((byte)8); this.blobHeap.Write(ic.ToInt64(null)); break;          case ElementType.UInt64: this.blobHeap.Write((byte)8); this.blobHeap.Write(ic.ToUInt64(null)); break;          case ElementType.Single: this.blobHeap.Write((byte)4); this.blobHeap.Write(ic.ToSingle(null)); break;          case ElementType.Double: this.blobHeap.Write((byte)8); this.blobHeap.Write(ic.ToDouble(null)); break;          case ElementType.String: this.blobHeap.Write((string)literal.Value' false); break;          case ElementType.Array:          case ElementType.Class:          case ElementType.Object:          case ElementType.Reference:          case ElementType.SzArray: this.blobHeap.Write((byte)4); this.blobHeap.Write((int)0); break; //REVIEW: standard implies this should be 0' peverify thinks otherwise.          default: Debug.Assert(false' "Unexpected Literal type"); return 0;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetBlobIndex,The following statement contains a magic number: switch(lType.typeCode){          case ElementType.Boolean: this.blobHeap.Write((byte)1); this.blobHeap.Write(ic.ToBoolean(null)); break;          case ElementType.Char: this.blobHeap.Write((byte)2); this.blobHeap.Write(ic.ToChar(null)); break;          case ElementType.Int8: this.blobHeap.Write((byte)1); this.blobHeap.Write(ic.ToSByte(null)); break;          case ElementType.UInt8: this.blobHeap.Write((byte)1); this.blobHeap.Write(ic.ToByte(null)); break;          case ElementType.Int16: this.blobHeap.Write((byte)2); this.blobHeap.Write(ic.ToInt16(null)); break;          case ElementType.UInt16: this.blobHeap.Write((byte)2); this.blobHeap.Write(ic.ToUInt16(null)); break;          case ElementType.Int32: this.blobHeap.Write((byte)4); this.blobHeap.Write(ic.ToInt32(null)); break;          case ElementType.UInt32: this.blobHeap.Write((byte)4); this.blobHeap.Write(ic.ToUInt32(null)); break;          case ElementType.Int64: this.blobHeap.Write((byte)8); this.blobHeap.Write(ic.ToInt64(null)); break;          case ElementType.UInt64: this.blobHeap.Write((byte)8); this.blobHeap.Write(ic.ToUInt64(null)); break;          case ElementType.Single: this.blobHeap.Write((byte)4); this.blobHeap.Write(ic.ToSingle(null)); break;          case ElementType.Double: this.blobHeap.Write((byte)8); this.blobHeap.Write(ic.ToDouble(null)); break;          case ElementType.String: this.blobHeap.Write((string)literal.Value' false); break;          case ElementType.Array:          case ElementType.Class:          case ElementType.Object:          case ElementType.Reference:          case ElementType.SzArray: this.blobHeap.Write((byte)4); this.blobHeap.Write((int)0); break; //REVIEW: standard implies this should be 0' peverify thinks otherwise.          default: Debug.Assert(false' "Unexpected Literal type"); return 0;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetBlobIndex,The following statement contains a magic number: switch(lType.typeCode){          case ElementType.Boolean: this.blobHeap.Write((byte)1); this.blobHeap.Write(ic.ToBoolean(null)); break;          case ElementType.Char: this.blobHeap.Write((byte)2); this.blobHeap.Write(ic.ToChar(null)); break;          case ElementType.Int8: this.blobHeap.Write((byte)1); this.blobHeap.Write(ic.ToSByte(null)); break;          case ElementType.UInt8: this.blobHeap.Write((byte)1); this.blobHeap.Write(ic.ToByte(null)); break;          case ElementType.Int16: this.blobHeap.Write((byte)2); this.blobHeap.Write(ic.ToInt16(null)); break;          case ElementType.UInt16: this.blobHeap.Write((byte)2); this.blobHeap.Write(ic.ToUInt16(null)); break;          case ElementType.Int32: this.blobHeap.Write((byte)4); this.blobHeap.Write(ic.ToInt32(null)); break;          case ElementType.UInt32: this.blobHeap.Write((byte)4); this.blobHeap.Write(ic.ToUInt32(null)); break;          case ElementType.Int64: this.blobHeap.Write((byte)8); this.blobHeap.Write(ic.ToInt64(null)); break;          case ElementType.UInt64: this.blobHeap.Write((byte)8); this.blobHeap.Write(ic.ToUInt64(null)); break;          case ElementType.Single: this.blobHeap.Write((byte)4); this.blobHeap.Write(ic.ToSingle(null)); break;          case ElementType.Double: this.blobHeap.Write((byte)8); this.blobHeap.Write(ic.ToDouble(null)); break;          case ElementType.String: this.blobHeap.Write((string)literal.Value' false); break;          case ElementType.Array:          case ElementType.Class:          case ElementType.Object:          case ElementType.Reference:          case ElementType.SzArray: this.blobHeap.Write((byte)4); this.blobHeap.Write((int)0); break; //REVIEW: standard implies this should be 0' peverify thinks otherwise.          default: Debug.Assert(false' "Unexpected Literal type"); return 0;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetBlobIndex,The following statement contains a magic number: switch(lType.typeCode){          case ElementType.Boolean: this.blobHeap.Write((byte)1); this.blobHeap.Write(ic.ToBoolean(null)); break;          case ElementType.Char: this.blobHeap.Write((byte)2); this.blobHeap.Write(ic.ToChar(null)); break;          case ElementType.Int8: this.blobHeap.Write((byte)1); this.blobHeap.Write(ic.ToSByte(null)); break;          case ElementType.UInt8: this.blobHeap.Write((byte)1); this.blobHeap.Write(ic.ToByte(null)); break;          case ElementType.Int16: this.blobHeap.Write((byte)2); this.blobHeap.Write(ic.ToInt16(null)); break;          case ElementType.UInt16: this.blobHeap.Write((byte)2); this.blobHeap.Write(ic.ToUInt16(null)); break;          case ElementType.Int32: this.blobHeap.Write((byte)4); this.blobHeap.Write(ic.ToInt32(null)); break;          case ElementType.UInt32: this.blobHeap.Write((byte)4); this.blobHeap.Write(ic.ToUInt32(null)); break;          case ElementType.Int64: this.blobHeap.Write((byte)8); this.blobHeap.Write(ic.ToInt64(null)); break;          case ElementType.UInt64: this.blobHeap.Write((byte)8); this.blobHeap.Write(ic.ToUInt64(null)); break;          case ElementType.Single: this.blobHeap.Write((byte)4); this.blobHeap.Write(ic.ToSingle(null)); break;          case ElementType.Double: this.blobHeap.Write((byte)8); this.blobHeap.Write(ic.ToDouble(null)); break;          case ElementType.String: this.blobHeap.Write((string)literal.Value' false); break;          case ElementType.Array:          case ElementType.Class:          case ElementType.Object:          case ElementType.Reference:          case ElementType.SzArray: this.blobHeap.Write((byte)4); this.blobHeap.Write((int)0); break; //REVIEW: standard implies this should be 0' peverify thinks otherwise.          default: Debug.Assert(false' "Unexpected Literal type"); return 0;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetBlobIndex,The following statement contains a magic number: switch(lType.typeCode){          case ElementType.Boolean: this.blobHeap.Write((byte)1); this.blobHeap.Write(ic.ToBoolean(null)); break;          case ElementType.Char: this.blobHeap.Write((byte)2); this.blobHeap.Write(ic.ToChar(null)); break;          case ElementType.Int8: this.blobHeap.Write((byte)1); this.blobHeap.Write(ic.ToSByte(null)); break;          case ElementType.UInt8: this.blobHeap.Write((byte)1); this.blobHeap.Write(ic.ToByte(null)); break;          case ElementType.Int16: this.blobHeap.Write((byte)2); this.blobHeap.Write(ic.ToInt16(null)); break;          case ElementType.UInt16: this.blobHeap.Write((byte)2); this.blobHeap.Write(ic.ToUInt16(null)); break;          case ElementType.Int32: this.blobHeap.Write((byte)4); this.blobHeap.Write(ic.ToInt32(null)); break;          case ElementType.UInt32: this.blobHeap.Write((byte)4); this.blobHeap.Write(ic.ToUInt32(null)); break;          case ElementType.Int64: this.blobHeap.Write((byte)8); this.blobHeap.Write(ic.ToInt64(null)); break;          case ElementType.UInt64: this.blobHeap.Write((byte)8); this.blobHeap.Write(ic.ToUInt64(null)); break;          case ElementType.Single: this.blobHeap.Write((byte)4); this.blobHeap.Write(ic.ToSingle(null)); break;          case ElementType.Double: this.blobHeap.Write((byte)8); this.blobHeap.Write(ic.ToDouble(null)); break;          case ElementType.String: this.blobHeap.Write((string)literal.Value' false); break;          case ElementType.Array:          case ElementType.Class:          case ElementType.Object:          case ElementType.Reference:          case ElementType.SzArray: this.blobHeap.Write((byte)4); this.blobHeap.Write((int)0); break; //REVIEW: standard implies this should be 0' peverify thinks otherwise.          default: Debug.Assert(false' "Unexpected Literal type"); return 0;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetBlobIndex,The following statement contains a magic number: switch(lType.typeCode){          case ElementType.Boolean: this.blobHeap.Write((byte)1); this.blobHeap.Write(ic.ToBoolean(null)); break;          case ElementType.Char: this.blobHeap.Write((byte)2); this.blobHeap.Write(ic.ToChar(null)); break;          case ElementType.Int8: this.blobHeap.Write((byte)1); this.blobHeap.Write(ic.ToSByte(null)); break;          case ElementType.UInt8: this.blobHeap.Write((byte)1); this.blobHeap.Write(ic.ToByte(null)); break;          case ElementType.Int16: this.blobHeap.Write((byte)2); this.blobHeap.Write(ic.ToInt16(null)); break;          case ElementType.UInt16: this.blobHeap.Write((byte)2); this.blobHeap.Write(ic.ToUInt16(null)); break;          case ElementType.Int32: this.blobHeap.Write((byte)4); this.blobHeap.Write(ic.ToInt32(null)); break;          case ElementType.UInt32: this.blobHeap.Write((byte)4); this.blobHeap.Write(ic.ToUInt32(null)); break;          case ElementType.Int64: this.blobHeap.Write((byte)8); this.blobHeap.Write(ic.ToInt64(null)); break;          case ElementType.UInt64: this.blobHeap.Write((byte)8); this.blobHeap.Write(ic.ToUInt64(null)); break;          case ElementType.Single: this.blobHeap.Write((byte)4); this.blobHeap.Write(ic.ToSingle(null)); break;          case ElementType.Double: this.blobHeap.Write((byte)8); this.blobHeap.Write(ic.ToDouble(null)); break;          case ElementType.String: this.blobHeap.Write((string)literal.Value' false); break;          case ElementType.Array:          case ElementType.Class:          case ElementType.Object:          case ElementType.Reference:          case ElementType.SzArray: this.blobHeap.Write((byte)4); this.blobHeap.Write((int)0); break; //REVIEW: standard implies this should be 0' peverify thinks otherwise.          default: Debug.Assert(false' "Unexpected Literal type"); return 0;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: switch(node.NodeType){          case NodeType.InstanceInitializer:          case NodeType.StaticInitializer:          case NodeType.Method: return this.GetMethodIndex((Method)node)<<5;          case NodeType.Field: return (this.GetFieldIndex((Field)node)<<5)|1;          case NodeType.Parameter: return (this.GetParamIndex((Parameter)node)<<5)|4;          case NodeType.Class:          case NodeType.DelegateNode:          case NodeType.EnumNode:          case NodeType.Interface:          case NodeType.Struct:  #if !MinimalReader          case NodeType.TupleType:          case NodeType.TypeAlias:          case NodeType.TypeIntersection:          case NodeType.TypeUnion:  #endif            TypeNode t = (TypeNode)node;            if (this.IsStructural(t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))              return (this.GetTypeSpecIndex(t) << 5) | 13;            else              return (this.GetTypeDefIndex(t) << 5) | 3;          case NodeType.ClassParameter:          case NodeType.TypeParameter:             if (!this.UseGenerics) goto case NodeType.Class;            return (this.GetGenericParamIndex((TypeNode)node)<<5)|19;          case NodeType.Property: return (this.GetPropertyIndex((Property)node)<<5)|9;          case NodeType.Event: return (this.GetEventIndex((Event)node)<<5)|10;          case NodeType.Module: return (1 << 5) | 7;          case NodeType.Assembly: return (1 << 5) | 14;          default: Debug.Assert(false' "Unexpect custom attribute parent"); return 0;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: switch(node.NodeType){          case NodeType.InstanceInitializer:          case NodeType.StaticInitializer:          case NodeType.Method: return this.GetMethodIndex((Method)node)<<5;          case NodeType.Field: return (this.GetFieldIndex((Field)node)<<5)|1;          case NodeType.Parameter: return (this.GetParamIndex((Parameter)node)<<5)|4;          case NodeType.Class:          case NodeType.DelegateNode:          case NodeType.EnumNode:          case NodeType.Interface:          case NodeType.Struct:  #if !MinimalReader          case NodeType.TupleType:          case NodeType.TypeAlias:          case NodeType.TypeIntersection:          case NodeType.TypeUnion:  #endif            TypeNode t = (TypeNode)node;            if (this.IsStructural(t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))              return (this.GetTypeSpecIndex(t) << 5) | 13;            else              return (this.GetTypeDefIndex(t) << 5) | 3;          case NodeType.ClassParameter:          case NodeType.TypeParameter:             if (!this.UseGenerics) goto case NodeType.Class;            return (this.GetGenericParamIndex((TypeNode)node)<<5)|19;          case NodeType.Property: return (this.GetPropertyIndex((Property)node)<<5)|9;          case NodeType.Event: return (this.GetEventIndex((Event)node)<<5)|10;          case NodeType.Module: return (1 << 5) | 7;          case NodeType.Assembly: return (1 << 5) | 14;          default: Debug.Assert(false' "Unexpect custom attribute parent"); return 0;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: switch(node.NodeType){          case NodeType.InstanceInitializer:          case NodeType.StaticInitializer:          case NodeType.Method: return this.GetMethodIndex((Method)node)<<5;          case NodeType.Field: return (this.GetFieldIndex((Field)node)<<5)|1;          case NodeType.Parameter: return (this.GetParamIndex((Parameter)node)<<5)|4;          case NodeType.Class:          case NodeType.DelegateNode:          case NodeType.EnumNode:          case NodeType.Interface:          case NodeType.Struct:  #if !MinimalReader          case NodeType.TupleType:          case NodeType.TypeAlias:          case NodeType.TypeIntersection:          case NodeType.TypeUnion:  #endif            TypeNode t = (TypeNode)node;            if (this.IsStructural(t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))              return (this.GetTypeSpecIndex(t) << 5) | 13;            else              return (this.GetTypeDefIndex(t) << 5) | 3;          case NodeType.ClassParameter:          case NodeType.TypeParameter:             if (!this.UseGenerics) goto case NodeType.Class;            return (this.GetGenericParamIndex((TypeNode)node)<<5)|19;          case NodeType.Property: return (this.GetPropertyIndex((Property)node)<<5)|9;          case NodeType.Event: return (this.GetEventIndex((Event)node)<<5)|10;          case NodeType.Module: return (1 << 5) | 7;          case NodeType.Assembly: return (1 << 5) | 14;          default: Debug.Assert(false' "Unexpect custom attribute parent"); return 0;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: switch(node.NodeType){          case NodeType.InstanceInitializer:          case NodeType.StaticInitializer:          case NodeType.Method: return this.GetMethodIndex((Method)node)<<5;          case NodeType.Field: return (this.GetFieldIndex((Field)node)<<5)|1;          case NodeType.Parameter: return (this.GetParamIndex((Parameter)node)<<5)|4;          case NodeType.Class:          case NodeType.DelegateNode:          case NodeType.EnumNode:          case NodeType.Interface:          case NodeType.Struct:  #if !MinimalReader          case NodeType.TupleType:          case NodeType.TypeAlias:          case NodeType.TypeIntersection:          case NodeType.TypeUnion:  #endif            TypeNode t = (TypeNode)node;            if (this.IsStructural(t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))              return (this.GetTypeSpecIndex(t) << 5) | 13;            else              return (this.GetTypeDefIndex(t) << 5) | 3;          case NodeType.ClassParameter:          case NodeType.TypeParameter:             if (!this.UseGenerics) goto case NodeType.Class;            return (this.GetGenericParamIndex((TypeNode)node)<<5)|19;          case NodeType.Property: return (this.GetPropertyIndex((Property)node)<<5)|9;          case NodeType.Event: return (this.GetEventIndex((Event)node)<<5)|10;          case NodeType.Module: return (1 << 5) | 7;          case NodeType.Assembly: return (1 << 5) | 14;          default: Debug.Assert(false' "Unexpect custom attribute parent"); return 0;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: switch(node.NodeType){          case NodeType.InstanceInitializer:          case NodeType.StaticInitializer:          case NodeType.Method: return this.GetMethodIndex((Method)node)<<5;          case NodeType.Field: return (this.GetFieldIndex((Field)node)<<5)|1;          case NodeType.Parameter: return (this.GetParamIndex((Parameter)node)<<5)|4;          case NodeType.Class:          case NodeType.DelegateNode:          case NodeType.EnumNode:          case NodeType.Interface:          case NodeType.Struct:  #if !MinimalReader          case NodeType.TupleType:          case NodeType.TypeAlias:          case NodeType.TypeIntersection:          case NodeType.TypeUnion:  #endif            TypeNode t = (TypeNode)node;            if (this.IsStructural(t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))              return (this.GetTypeSpecIndex(t) << 5) | 13;            else              return (this.GetTypeDefIndex(t) << 5) | 3;          case NodeType.ClassParameter:          case NodeType.TypeParameter:             if (!this.UseGenerics) goto case NodeType.Class;            return (this.GetGenericParamIndex((TypeNode)node)<<5)|19;          case NodeType.Property: return (this.GetPropertyIndex((Property)node)<<5)|9;          case NodeType.Event: return (this.GetEventIndex((Event)node)<<5)|10;          case NodeType.Module: return (1 << 5) | 7;          case NodeType.Assembly: return (1 << 5) | 14;          default: Debug.Assert(false' "Unexpect custom attribute parent"); return 0;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: switch(node.NodeType){          case NodeType.InstanceInitializer:          case NodeType.StaticInitializer:          case NodeType.Method: return this.GetMethodIndex((Method)node)<<5;          case NodeType.Field: return (this.GetFieldIndex((Field)node)<<5)|1;          case NodeType.Parameter: return (this.GetParamIndex((Parameter)node)<<5)|4;          case NodeType.Class:          case NodeType.DelegateNode:          case NodeType.EnumNode:          case NodeType.Interface:          case NodeType.Struct:  #if !MinimalReader          case NodeType.TupleType:          case NodeType.TypeAlias:          case NodeType.TypeIntersection:          case NodeType.TypeUnion:  #endif            TypeNode t = (TypeNode)node;            if (this.IsStructural(t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))              return (this.GetTypeSpecIndex(t) << 5) | 13;            else              return (this.GetTypeDefIndex(t) << 5) | 3;          case NodeType.ClassParameter:          case NodeType.TypeParameter:             if (!this.UseGenerics) goto case NodeType.Class;            return (this.GetGenericParamIndex((TypeNode)node)<<5)|19;          case NodeType.Property: return (this.GetPropertyIndex((Property)node)<<5)|9;          case NodeType.Event: return (this.GetEventIndex((Event)node)<<5)|10;          case NodeType.Module: return (1 << 5) | 7;          case NodeType.Assembly: return (1 << 5) | 14;          default: Debug.Assert(false' "Unexpect custom attribute parent"); return 0;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: switch(node.NodeType){          case NodeType.InstanceInitializer:          case NodeType.StaticInitializer:          case NodeType.Method: return this.GetMethodIndex((Method)node)<<5;          case NodeType.Field: return (this.GetFieldIndex((Field)node)<<5)|1;          case NodeType.Parameter: return (this.GetParamIndex((Parameter)node)<<5)|4;          case NodeType.Class:          case NodeType.DelegateNode:          case NodeType.EnumNode:          case NodeType.Interface:          case NodeType.Struct:  #if !MinimalReader          case NodeType.TupleType:          case NodeType.TypeAlias:          case NodeType.TypeIntersection:          case NodeType.TypeUnion:  #endif            TypeNode t = (TypeNode)node;            if (this.IsStructural(t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))              return (this.GetTypeSpecIndex(t) << 5) | 13;            else              return (this.GetTypeDefIndex(t) << 5) | 3;          case NodeType.ClassParameter:          case NodeType.TypeParameter:             if (!this.UseGenerics) goto case NodeType.Class;            return (this.GetGenericParamIndex((TypeNode)node)<<5)|19;          case NodeType.Property: return (this.GetPropertyIndex((Property)node)<<5)|9;          case NodeType.Event: return (this.GetEventIndex((Event)node)<<5)|10;          case NodeType.Module: return (1 << 5) | 7;          case NodeType.Assembly: return (1 << 5) | 14;          default: Debug.Assert(false' "Unexpect custom attribute parent"); return 0;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: switch(node.NodeType){          case NodeType.InstanceInitializer:          case NodeType.StaticInitializer:          case NodeType.Method: return this.GetMethodIndex((Method)node)<<5;          case NodeType.Field: return (this.GetFieldIndex((Field)node)<<5)|1;          case NodeType.Parameter: return (this.GetParamIndex((Parameter)node)<<5)|4;          case NodeType.Class:          case NodeType.DelegateNode:          case NodeType.EnumNode:          case NodeType.Interface:          case NodeType.Struct:  #if !MinimalReader          case NodeType.TupleType:          case NodeType.TypeAlias:          case NodeType.TypeIntersection:          case NodeType.TypeUnion:  #endif            TypeNode t = (TypeNode)node;            if (this.IsStructural(t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))              return (this.GetTypeSpecIndex(t) << 5) | 13;            else              return (this.GetTypeDefIndex(t) << 5) | 3;          case NodeType.ClassParameter:          case NodeType.TypeParameter:             if (!this.UseGenerics) goto case NodeType.Class;            return (this.GetGenericParamIndex((TypeNode)node)<<5)|19;          case NodeType.Property: return (this.GetPropertyIndex((Property)node)<<5)|9;          case NodeType.Event: return (this.GetEventIndex((Event)node)<<5)|10;          case NodeType.Module: return (1 << 5) | 7;          case NodeType.Assembly: return (1 << 5) | 14;          default: Debug.Assert(false' "Unexpect custom attribute parent"); return 0;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: switch(node.NodeType){          case NodeType.InstanceInitializer:          case NodeType.StaticInitializer:          case NodeType.Method: return this.GetMethodIndex((Method)node)<<5;          case NodeType.Field: return (this.GetFieldIndex((Field)node)<<5)|1;          case NodeType.Parameter: return (this.GetParamIndex((Parameter)node)<<5)|4;          case NodeType.Class:          case NodeType.DelegateNode:          case NodeType.EnumNode:          case NodeType.Interface:          case NodeType.Struct:  #if !MinimalReader          case NodeType.TupleType:          case NodeType.TypeAlias:          case NodeType.TypeIntersection:          case NodeType.TypeUnion:  #endif            TypeNode t = (TypeNode)node;            if (this.IsStructural(t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))              return (this.GetTypeSpecIndex(t) << 5) | 13;            else              return (this.GetTypeDefIndex(t) << 5) | 3;          case NodeType.ClassParameter:          case NodeType.TypeParameter:             if (!this.UseGenerics) goto case NodeType.Class;            return (this.GetGenericParamIndex((TypeNode)node)<<5)|19;          case NodeType.Property: return (this.GetPropertyIndex((Property)node)<<5)|9;          case NodeType.Event: return (this.GetEventIndex((Event)node)<<5)|10;          case NodeType.Module: return (1 << 5) | 7;          case NodeType.Assembly: return (1 << 5) | 14;          default: Debug.Assert(false' "Unexpect custom attribute parent"); return 0;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: switch(node.NodeType){          case NodeType.InstanceInitializer:          case NodeType.StaticInitializer:          case NodeType.Method: return this.GetMethodIndex((Method)node)<<5;          case NodeType.Field: return (this.GetFieldIndex((Field)node)<<5)|1;          case NodeType.Parameter: return (this.GetParamIndex((Parameter)node)<<5)|4;          case NodeType.Class:          case NodeType.DelegateNode:          case NodeType.EnumNode:          case NodeType.Interface:          case NodeType.Struct:  #if !MinimalReader          case NodeType.TupleType:          case NodeType.TypeAlias:          case NodeType.TypeIntersection:          case NodeType.TypeUnion:  #endif            TypeNode t = (TypeNode)node;            if (this.IsStructural(t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))              return (this.GetTypeSpecIndex(t) << 5) | 13;            else              return (this.GetTypeDefIndex(t) << 5) | 3;          case NodeType.ClassParameter:          case NodeType.TypeParameter:             if (!this.UseGenerics) goto case NodeType.Class;            return (this.GetGenericParamIndex((TypeNode)node)<<5)|19;          case NodeType.Property: return (this.GetPropertyIndex((Property)node)<<5)|9;          case NodeType.Event: return (this.GetEventIndex((Event)node)<<5)|10;          case NodeType.Module: return (1 << 5) | 7;          case NodeType.Assembly: return (1 << 5) | 14;          default: Debug.Assert(false' "Unexpect custom attribute parent"); return 0;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: switch(node.NodeType){          case NodeType.InstanceInitializer:          case NodeType.StaticInitializer:          case NodeType.Method: return this.GetMethodIndex((Method)node)<<5;          case NodeType.Field: return (this.GetFieldIndex((Field)node)<<5)|1;          case NodeType.Parameter: return (this.GetParamIndex((Parameter)node)<<5)|4;          case NodeType.Class:          case NodeType.DelegateNode:          case NodeType.EnumNode:          case NodeType.Interface:          case NodeType.Struct:  #if !MinimalReader          case NodeType.TupleType:          case NodeType.TypeAlias:          case NodeType.TypeIntersection:          case NodeType.TypeUnion:  #endif            TypeNode t = (TypeNode)node;            if (this.IsStructural(t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))              return (this.GetTypeSpecIndex(t) << 5) | 13;            else              return (this.GetTypeDefIndex(t) << 5) | 3;          case NodeType.ClassParameter:          case NodeType.TypeParameter:             if (!this.UseGenerics) goto case NodeType.Class;            return (this.GetGenericParamIndex((TypeNode)node)<<5)|19;          case NodeType.Property: return (this.GetPropertyIndex((Property)node)<<5)|9;          case NodeType.Event: return (this.GetEventIndex((Event)node)<<5)|10;          case NodeType.Module: return (1 << 5) | 7;          case NodeType.Assembly: return (1 << 5) | 14;          default: Debug.Assert(false' "Unexpect custom attribute parent"); return 0;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: switch(node.NodeType){          case NodeType.InstanceInitializer:          case NodeType.StaticInitializer:          case NodeType.Method: return this.GetMethodIndex((Method)node)<<5;          case NodeType.Field: return (this.GetFieldIndex((Field)node)<<5)|1;          case NodeType.Parameter: return (this.GetParamIndex((Parameter)node)<<5)|4;          case NodeType.Class:          case NodeType.DelegateNode:          case NodeType.EnumNode:          case NodeType.Interface:          case NodeType.Struct:  #if !MinimalReader          case NodeType.TupleType:          case NodeType.TypeAlias:          case NodeType.TypeIntersection:          case NodeType.TypeUnion:  #endif            TypeNode t = (TypeNode)node;            if (this.IsStructural(t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))              return (this.GetTypeSpecIndex(t) << 5) | 13;            else              return (this.GetTypeDefIndex(t) << 5) | 3;          case NodeType.ClassParameter:          case NodeType.TypeParameter:             if (!this.UseGenerics) goto case NodeType.Class;            return (this.GetGenericParamIndex((TypeNode)node)<<5)|19;          case NodeType.Property: return (this.GetPropertyIndex((Property)node)<<5)|9;          case NodeType.Event: return (this.GetEventIndex((Event)node)<<5)|10;          case NodeType.Module: return (1 << 5) | 7;          case NodeType.Assembly: return (1 << 5) | 14;          default: Debug.Assert(false' "Unexpect custom attribute parent"); return 0;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: switch(node.NodeType){          case NodeType.InstanceInitializer:          case NodeType.StaticInitializer:          case NodeType.Method: return this.GetMethodIndex((Method)node)<<5;          case NodeType.Field: return (this.GetFieldIndex((Field)node)<<5)|1;          case NodeType.Parameter: return (this.GetParamIndex((Parameter)node)<<5)|4;          case NodeType.Class:          case NodeType.DelegateNode:          case NodeType.EnumNode:          case NodeType.Interface:          case NodeType.Struct:  #if !MinimalReader          case NodeType.TupleType:          case NodeType.TypeAlias:          case NodeType.TypeIntersection:          case NodeType.TypeUnion:  #endif            TypeNode t = (TypeNode)node;            if (this.IsStructural(t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))              return (this.GetTypeSpecIndex(t) << 5) | 13;            else              return (this.GetTypeDefIndex(t) << 5) | 3;          case NodeType.ClassParameter:          case NodeType.TypeParameter:             if (!this.UseGenerics) goto case NodeType.Class;            return (this.GetGenericParamIndex((TypeNode)node)<<5)|19;          case NodeType.Property: return (this.GetPropertyIndex((Property)node)<<5)|9;          case NodeType.Event: return (this.GetEventIndex((Event)node)<<5)|10;          case NodeType.Module: return (1 << 5) | 7;          case NodeType.Assembly: return (1 << 5) | 14;          default: Debug.Assert(false' "Unexpect custom attribute parent"); return 0;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: switch(node.NodeType){          case NodeType.InstanceInitializer:          case NodeType.StaticInitializer:          case NodeType.Method: return this.GetMethodIndex((Method)node)<<5;          case NodeType.Field: return (this.GetFieldIndex((Field)node)<<5)|1;          case NodeType.Parameter: return (this.GetParamIndex((Parameter)node)<<5)|4;          case NodeType.Class:          case NodeType.DelegateNode:          case NodeType.EnumNode:          case NodeType.Interface:          case NodeType.Struct:  #if !MinimalReader          case NodeType.TupleType:          case NodeType.TypeAlias:          case NodeType.TypeIntersection:          case NodeType.TypeUnion:  #endif            TypeNode t = (TypeNode)node;            if (this.IsStructural(t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))              return (this.GetTypeSpecIndex(t) << 5) | 13;            else              return (this.GetTypeDefIndex(t) << 5) | 3;          case NodeType.ClassParameter:          case NodeType.TypeParameter:             if (!this.UseGenerics) goto case NodeType.Class;            return (this.GetGenericParamIndex((TypeNode)node)<<5)|19;          case NodeType.Property: return (this.GetPropertyIndex((Property)node)<<5)|9;          case NodeType.Event: return (this.GetEventIndex((Event)node)<<5)|10;          case NodeType.Module: return (1 << 5) | 7;          case NodeType.Assembly: return (1 << 5) | 14;          default: Debug.Assert(false' "Unexpect custom attribute parent"); return 0;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: switch(node.NodeType){          case NodeType.InstanceInitializer:          case NodeType.StaticInitializer:          case NodeType.Method: return this.GetMethodIndex((Method)node)<<5;          case NodeType.Field: return (this.GetFieldIndex((Field)node)<<5)|1;          case NodeType.Parameter: return (this.GetParamIndex((Parameter)node)<<5)|4;          case NodeType.Class:          case NodeType.DelegateNode:          case NodeType.EnumNode:          case NodeType.Interface:          case NodeType.Struct:  #if !MinimalReader          case NodeType.TupleType:          case NodeType.TypeAlias:          case NodeType.TypeIntersection:          case NodeType.TypeUnion:  #endif            TypeNode t = (TypeNode)node;            if (this.IsStructural(t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))              return (this.GetTypeSpecIndex(t) << 5) | 13;            else              return (this.GetTypeDefIndex(t) << 5) | 3;          case NodeType.ClassParameter:          case NodeType.TypeParameter:             if (!this.UseGenerics) goto case NodeType.Class;            return (this.GetGenericParamIndex((TypeNode)node)<<5)|19;          case NodeType.Property: return (this.GetPropertyIndex((Property)node)<<5)|9;          case NodeType.Event: return (this.GetEventIndex((Event)node)<<5)|10;          case NodeType.Module: return (1 << 5) | 7;          case NodeType.Assembly: return (1 << 5) | 14;          default: Debug.Assert(false' "Unexpect custom attribute parent"); return 0;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: switch(node.NodeType){          case NodeType.InstanceInitializer:          case NodeType.StaticInitializer:          case NodeType.Method: return this.GetMethodIndex((Method)node)<<5;          case NodeType.Field: return (this.GetFieldIndex((Field)node)<<5)|1;          case NodeType.Parameter: return (this.GetParamIndex((Parameter)node)<<5)|4;          case NodeType.Class:          case NodeType.DelegateNode:          case NodeType.EnumNode:          case NodeType.Interface:          case NodeType.Struct:  #if !MinimalReader          case NodeType.TupleType:          case NodeType.TypeAlias:          case NodeType.TypeIntersection:          case NodeType.TypeUnion:  #endif            TypeNode t = (TypeNode)node;            if (this.IsStructural(t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))              return (this.GetTypeSpecIndex(t) << 5) | 13;            else              return (this.GetTypeDefIndex(t) << 5) | 3;          case NodeType.ClassParameter:          case NodeType.TypeParameter:             if (!this.UseGenerics) goto case NodeType.Class;            return (this.GetGenericParamIndex((TypeNode)node)<<5)|19;          case NodeType.Property: return (this.GetPropertyIndex((Property)node)<<5)|9;          case NodeType.Event: return (this.GetEventIndex((Event)node)<<5)|10;          case NodeType.Module: return (1 << 5) | 7;          case NodeType.Assembly: return (1 << 5) | 14;          default: Debug.Assert(false' "Unexpect custom attribute parent"); return 0;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: switch(node.NodeType){          case NodeType.InstanceInitializer:          case NodeType.StaticInitializer:          case NodeType.Method: return this.GetMethodIndex((Method)node)<<5;          case NodeType.Field: return (this.GetFieldIndex((Field)node)<<5)|1;          case NodeType.Parameter: return (this.GetParamIndex((Parameter)node)<<5)|4;          case NodeType.Class:          case NodeType.DelegateNode:          case NodeType.EnumNode:          case NodeType.Interface:          case NodeType.Struct:  #if !MinimalReader          case NodeType.TupleType:          case NodeType.TypeAlias:          case NodeType.TypeIntersection:          case NodeType.TypeUnion:  #endif            TypeNode t = (TypeNode)node;            if (this.IsStructural(t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))              return (this.GetTypeSpecIndex(t) << 5) | 13;            else              return (this.GetTypeDefIndex(t) << 5) | 3;          case NodeType.ClassParameter:          case NodeType.TypeParameter:             if (!this.UseGenerics) goto case NodeType.Class;            return (this.GetGenericParamIndex((TypeNode)node)<<5)|19;          case NodeType.Property: return (this.GetPropertyIndex((Property)node)<<5)|9;          case NodeType.Event: return (this.GetEventIndex((Event)node)<<5)|10;          case NodeType.Module: return (1 << 5) | 7;          case NodeType.Assembly: return (1 << 5) | 14;          default: Debug.Assert(false' "Unexpect custom attribute parent"); return 0;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetCustomAttributeParentCodedIndex,The following statement contains a magic number: switch(node.NodeType){          case NodeType.InstanceInitializer:          case NodeType.StaticInitializer:          case NodeType.Method: return this.GetMethodIndex((Method)node)<<5;          case NodeType.Field: return (this.GetFieldIndex((Field)node)<<5)|1;          case NodeType.Parameter: return (this.GetParamIndex((Parameter)node)<<5)|4;          case NodeType.Class:          case NodeType.DelegateNode:          case NodeType.EnumNode:          case NodeType.Interface:          case NodeType.Struct:  #if !MinimalReader          case NodeType.TupleType:          case NodeType.TypeAlias:          case NodeType.TypeIntersection:          case NodeType.TypeUnion:  #endif            TypeNode t = (TypeNode)node;            if (this.IsStructural(t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))              return (this.GetTypeSpecIndex(t) << 5) | 13;            else              return (this.GetTypeDefIndex(t) << 5) | 3;          case NodeType.ClassParameter:          case NodeType.TypeParameter:             if (!this.UseGenerics) goto case NodeType.Class;            return (this.GetGenericParamIndex((TypeNode)node)<<5)|19;          case NodeType.Property: return (this.GetPropertyIndex((Property)node)<<5)|9;          case NodeType.Event: return (this.GetEventIndex((Event)node)<<5)|10;          case NodeType.Module: return (1 << 5) | 7;          case NodeType.Assembly: return (1 << 5) | 14;          default: Debug.Assert(false' "Unexpect custom attribute parent"); return 0;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetMemberRefParentEncoded,The following statement contains a magic number: if (this.IsStructural(type)) return (this.GetTypeSpecIndex(type) << 3) | 4;
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetMemberRefParentEncoded,The following statement contains a magic number: if (this.IsStructural(type)) return (this.GetTypeSpecIndex(type) << 3) | 4;
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetMemberRefParentEncoded,The following statement contains a magic number: if (type.DeclaringModule == this.module) return this.GetTypeDefIndex(type) << 3;
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetMemberRefParentEncoded,The following statement contains a magic number: if (type.DeclaringModule != null) return (this.GetTypeRefIndex(type) << 3)|1;
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetMemberRefParentEncoded,The following statement contains a magic number: if (type.typeCode == ElementType.Class || type.typeCode == ElementType.ValueType)          return this.GetTypeDefIndex(type) << 3;
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetMethodSpecIndex,The following statement contains a magic number: if (m.Template != null)          structuralKey = (m.Template.UniqueKey << 8) + blobIndex;        else          Debug.Assert(false);
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetOffset,The following statement contains a magic number: if (ob is int){          int targetAddress = (int)ob;          int offset = targetAddress - (fixupLocation+1);          if (-128 > offset || offset > 127){            offset = targetAddress - (fixupLocation+4);            Debug.Assert(offset < -128' "Forward short branch out of range");            shortOffset = false;          }else            shortOffset = true;          return offset;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetOffset,The following statement contains a magic number: if (ob is int){          int targetAddress = (int)ob;          int offset = targetAddress - (fixupLocation+1);          if (-128 > offset || offset > 127){            offset = targetAddress - (fixupLocation+4);            Debug.Assert(offset < -128' "Forward short branch out of range");            shortOffset = false;          }else            shortOffset = true;          return offset;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetOffset,The following statement contains a magic number: if (ob is int){          int targetAddress = (int)ob;          int offset = targetAddress - (fixupLocation+1);          if (-128 > offset || offset > 127){            offset = targetAddress - (fixupLocation+4);            Debug.Assert(offset < -128' "Forward short branch out of range");            shortOffset = false;          }else            shortOffset = true;          return offset;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetOffset,The following statement contains a magic number: if (ob is int){          int targetAddress = (int)ob;          int offset = targetAddress - (fixupLocation+1);          if (-128 > offset || offset > 127){            offset = targetAddress - (fixupLocation+4);            Debug.Assert(offset < -128' "Forward short branch out of range");            shortOffset = false;          }else            shortOffset = true;          return offset;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetOffset,The following statement contains a magic number: if (shortOffset) fixup.addressOfNextInstruction+=1; else fixup.addressOfNextInstruction+=4;
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetSecurityAttributeParentCodedIndex,The following statement contains a magic number: switch(node.NodeType){          case NodeType.InstanceInitializer:          case NodeType.StaticInitializer:          case NodeType.Method: return (this.GetMethodIndex((Method)node)<<2)|1;          case NodeType.Class:          case NodeType.Interface:          case NodeType.DelegateNode:          case NodeType.EnumNode:          case NodeType.Struct: return (this.GetTypeDefIndex((TypeNode)node)<<2)|0;          case NodeType.Assembly: return (1 << 2) | 2;          default: Debug.Assert(false' "Unexpected security attribute parent"); return 0;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetSecurityAttributeParentCodedIndex,The following statement contains a magic number: switch(node.NodeType){          case NodeType.InstanceInitializer:          case NodeType.StaticInitializer:          case NodeType.Method: return (this.GetMethodIndex((Method)node)<<2)|1;          case NodeType.Class:          case NodeType.Interface:          case NodeType.DelegateNode:          case NodeType.EnumNode:          case NodeType.Struct: return (this.GetTypeDefIndex((TypeNode)node)<<2)|0;          case NodeType.Assembly: return (1 << 2) | 2;          default: Debug.Assert(false' "Unexpected security attribute parent"); return 0;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetSecurityAttributeParentCodedIndex,The following statement contains a magic number: switch(node.NodeType){          case NodeType.InstanceInitializer:          case NodeType.StaticInitializer:          case NodeType.Method: return (this.GetMethodIndex((Method)node)<<2)|1;          case NodeType.Class:          case NodeType.Interface:          case NodeType.DelegateNode:          case NodeType.EnumNode:          case NodeType.Struct: return (this.GetTypeDefIndex((TypeNode)node)<<2)|0;          case NodeType.Assembly: return (1 << 2) | 2;          default: Debug.Assert(false' "Unexpected security attribute parent"); return 0;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetSecurityAttributeParentCodedIndex,The following statement contains a magic number: switch(node.NodeType){          case NodeType.InstanceInitializer:          case NodeType.StaticInitializer:          case NodeType.Method: return (this.GetMethodIndex((Method)node)<<2)|1;          case NodeType.Class:          case NodeType.Interface:          case NodeType.DelegateNode:          case NodeType.EnumNode:          case NodeType.Struct: return (this.GetTypeDefIndex((TypeNode)node)<<2)|0;          case NodeType.Assembly: return (1 << 2) | 2;          default: Debug.Assert(false' "Unexpected security attribute parent"); return 0;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetUserStringIndex,The following statement contains a magic number: if (index == null){          index = (int)this.userStringHeap.BaseStream.Position;          Ir2md.WriteCompressedInt(this.userStringHeap' str.Length*2+1);          this.userStringHeap.Write(str.ToCharArray());          this.userStringHeapIndex[str] = index;          //Write out a trailing byte indicating if the string is really quite simple          ulong stringKind = 0; //no funny business          foreach (char ch in str){            if (ch >= 0x7F) stringKind += 1;            else              switch((int)ch){                case 0x1:                case 0x2:                case 0x3:                case 0x4:                case 0x5:                case 0x6:                case 0x7:                case 0x8:                case 0xE:                case 0xF:                case 0x10:                case 0x11:                case 0x12:                case 0x13:                case 0x14:                case 0x15:                case 0x16:                case 0x17:                case 0x18:                case 0x19:                case 0x1A:                case 0x1B:                case 0x1C:                case 0x1D:                case 0x1E:                case 0x1F:                case 0x27:                case 0x2D:                  stringKind += 1;                  break;                default:                  break;              }          }          if (stringKind > 0) stringKind = 1;          this.userStringHeap.Write((byte)stringKind);        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetTypeDefOrRefOrSpecEncoded,The following statement contains a magic number: if (this.IsStructural(type)) return (this.GetTypeSpecIndex(type) << 2) | 2;
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetTypeDefOrRefOrSpecEncoded,The following statement contains a magic number: if (this.IsStructural(type)) return (this.GetTypeSpecIndex(type) << 2) | 2;
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetTypeDefOrRefOrSpecEncoded,The following statement contains a magic number: if (type.DeclaringModule == this.module) return this.GetTypeDefIndex(type) << 2;
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetTypeDefOrRefOrSpecEncoded,The following statement contains a magic number: return (this.GetTypeRefIndex(type) << 2)|1;
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetTypeSpecIndex,The following statement contains a magic number: if (type.Template != null){          blobIndex = this.GetBlobIndex(type);          structuralKey = ((type.Template.UniqueKey << 8)&int.MaxValue) + blobIndex;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateConstantTable,The following statement contains a magic number: for (int i = 0; i < n; i++){          Parameter p = this.constantTableEntries[i] as Parameter;          if (p != null){            cr[i].Parent = (this.GetParamIndex(p) << 2) | 1;            cr[i].Value = this.GetBlobIndex((Literal)p.DefaultValue);            TypeNode t = p.DefaultValue.Type;            if (t.NodeType == NodeType.EnumNode) t = ((EnumNode)t).UnderlyingType;            cr[i].Type = (int)t.typeCode;            if (t is Reference || ((t != p.Type || t == SystemTypes.Object)&& Literal.IsNullLiteral(p.DefaultValue)))              cr[i].Type = (int)ElementType.Class;          } else {            Field f = (Field)this.constantTableEntries[i];            cr[i].Parent = (this.GetFieldIndex(f) << 2);            cr[i].Value = this.GetBlobIndex(f.DefaultValue);            TypeNode t = f.DefaultValue.Type;            if (t.NodeType == NodeType.EnumNode) t = ((EnumNode)t).UnderlyingType;            cr[i].Type = (int)t.typeCode;            if (t is Reference || (t != f.Type && Literal.IsNullLiteral(f.DefaultValue)))               cr[i].Type = (int)ElementType.Class;          }          ConstantRow temp = cr[i];          int parent = temp.Parent;          for (int j = i-1; j >= 0; j--){            if (cr[j].Parent > parent){              cr[j+1] = cr[j];              if (j == 0){                cr[0] = temp;                break;              }            }else{              if (j < i-1) cr[j+1] = temp;              break;            }          }        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateConstantTable,The following statement contains a magic number: for (int i = 0; i < n; i++){          Parameter p = this.constantTableEntries[i] as Parameter;          if (p != null){            cr[i].Parent = (this.GetParamIndex(p) << 2) | 1;            cr[i].Value = this.GetBlobIndex((Literal)p.DefaultValue);            TypeNode t = p.DefaultValue.Type;            if (t.NodeType == NodeType.EnumNode) t = ((EnumNode)t).UnderlyingType;            cr[i].Type = (int)t.typeCode;            if (t is Reference || ((t != p.Type || t == SystemTypes.Object)&& Literal.IsNullLiteral(p.DefaultValue)))              cr[i].Type = (int)ElementType.Class;          } else {            Field f = (Field)this.constantTableEntries[i];            cr[i].Parent = (this.GetFieldIndex(f) << 2);            cr[i].Value = this.GetBlobIndex(f.DefaultValue);            TypeNode t = f.DefaultValue.Type;            if (t.NodeType == NodeType.EnumNode) t = ((EnumNode)t).UnderlyingType;            cr[i].Type = (int)t.typeCode;            if (t is Reference || (t != f.Type && Literal.IsNullLiteral(f.DefaultValue)))               cr[i].Type = (int)ElementType.Class;          }          ConstantRow temp = cr[i];          int parent = temp.Parent;          for (int j = i-1; j >= 0; j--){            if (cr[j].Parent > parent){              cr[j+1] = cr[j];              if (j == 0){                cr[0] = temp;                break;              }            }else{              if (j < i-1) cr[j+1] = temp;              break;            }          }        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: for (int i = 0' n = this.nodesWithCustomAttributes.Count; i < n; i++){          AttributeList attrs = null;          Node node = this.nodesWithCustomAttributes[i];          int codedIndex = 0;          switch(node.NodeType){            case NodeType.Method:            case NodeType.InstanceInitializer:            case NodeType.StaticInitializer:              Method m = (Method)node;              codedIndex = this.GetMethodIndex(m)<<5;               attrs = m.Attributes;              break;            case NodeType.Field:              Field f = (Field)node;              codedIndex = (this.GetFieldIndex(f)<<5)|1;              attrs = f.Attributes;              break;            case NodeType.Parameter:              Parameter par = (Parameter)node;              codedIndex = (this.GetParamIndex(par)<<5)|4;              attrs = par.Attributes;              break;            case NodeType.Class:            case NodeType.DelegateNode:            case NodeType.EnumNode:            case NodeType.Interface:            case NodeType.Struct:  #if !MinimalReader            case NodeType.TupleType:            case NodeType.TypeAlias:            case NodeType.TypeIntersection:            case NodeType.TypeUnion:  #endif              TypeNode t = (TypeNode)node;              if (this.IsStructural(t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))                codedIndex = (this.GetTypeSpecIndex(t)<<5)|13;              else                codedIndex = (this.GetTypeDefIndex(t)<<5)|3;              attrs = t.Attributes;              break;            case NodeType.ClassParameter:            case NodeType.TypeParameter:              if (!this.UseGenerics) goto case NodeType.Class;              t = (TypeNode)node;              codedIndex = (this.GetGenericParamIndex(t)<<5)|19;              attrs = t.Attributes;              break;            case NodeType.Property:              Property p = (Property)node;              codedIndex = (this.GetPropertyIndex(p)<<5)|9;              attrs = p.Attributes;              break;            case NodeType.Event:              Event e = (Event)node;              codedIndex = (this.GetEventIndex(e)<<5)|10;              attrs = e.Attributes;              break;            case NodeType.Module:            case NodeType.Assembly:              codedIndex =  (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);              attrs = ((Module)node).Attributes;              break;            default:              Debug.Assert(false);              break;          }          if (attrs == null) continue;          if (UseGenerics) {            Debug.Assert(codedIndex > prevCodedIndex);          }          prevCodedIndex = codedIndex;          for (int j = 0' m = attrs.Count; j < m; j++){            AttributeNode a = attrs[j];            if (a == null) continue;            table[k].Parent = codedIndex;            Debug.Assert(a.Constructor is MemberBinding);            Method cons = (Method)((MemberBinding)a.Constructor).BoundMember;            if (cons.DeclaringType.DeclaringModule == this.module && !this.IsStructural(cons.DeclaringType))              table[k].Constructor = (this.GetMethodIndex(cons) << 3) | 2;            else              table[k].Constructor = (this.GetMemberRefIndex(cons) << 3) | 3;            if (a.OriginalBlob != null)            {                table[k].Value = this.GetBlobIndex(a.OriginalBlob);            }            else            {                table[k].Value = this.GetBlobIndex(a.Expressions' cons.Parameters);            }            k++;          }        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: for (int i = 0' n = this.nodesWithCustomAttributes.Count; i < n; i++){          AttributeList attrs = null;          Node node = this.nodesWithCustomAttributes[i];          int codedIndex = 0;          switch(node.NodeType){            case NodeType.Method:            case NodeType.InstanceInitializer:            case NodeType.StaticInitializer:              Method m = (Method)node;              codedIndex = this.GetMethodIndex(m)<<5;               attrs = m.Attributes;              break;            case NodeType.Field:              Field f = (Field)node;              codedIndex = (this.GetFieldIndex(f)<<5)|1;              attrs = f.Attributes;              break;            case NodeType.Parameter:              Parameter par = (Parameter)node;              codedIndex = (this.GetParamIndex(par)<<5)|4;              attrs = par.Attributes;              break;            case NodeType.Class:            case NodeType.DelegateNode:            case NodeType.EnumNode:            case NodeType.Interface:            case NodeType.Struct:  #if !MinimalReader            case NodeType.TupleType:            case NodeType.TypeAlias:            case NodeType.TypeIntersection:            case NodeType.TypeUnion:  #endif              TypeNode t = (TypeNode)node;              if (this.IsStructural(t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))                codedIndex = (this.GetTypeSpecIndex(t)<<5)|13;              else                codedIndex = (this.GetTypeDefIndex(t)<<5)|3;              attrs = t.Attributes;              break;            case NodeType.ClassParameter:            case NodeType.TypeParameter:              if (!this.UseGenerics) goto case NodeType.Class;              t = (TypeNode)node;              codedIndex = (this.GetGenericParamIndex(t)<<5)|19;              attrs = t.Attributes;              break;            case NodeType.Property:              Property p = (Property)node;              codedIndex = (this.GetPropertyIndex(p)<<5)|9;              attrs = p.Attributes;              break;            case NodeType.Event:              Event e = (Event)node;              codedIndex = (this.GetEventIndex(e)<<5)|10;              attrs = e.Attributes;              break;            case NodeType.Module:            case NodeType.Assembly:              codedIndex =  (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);              attrs = ((Module)node).Attributes;              break;            default:              Debug.Assert(false);              break;          }          if (attrs == null) continue;          if (UseGenerics) {            Debug.Assert(codedIndex > prevCodedIndex);          }          prevCodedIndex = codedIndex;          for (int j = 0' m = attrs.Count; j < m; j++){            AttributeNode a = attrs[j];            if (a == null) continue;            table[k].Parent = codedIndex;            Debug.Assert(a.Constructor is MemberBinding);            Method cons = (Method)((MemberBinding)a.Constructor).BoundMember;            if (cons.DeclaringType.DeclaringModule == this.module && !this.IsStructural(cons.DeclaringType))              table[k].Constructor = (this.GetMethodIndex(cons) << 3) | 2;            else              table[k].Constructor = (this.GetMemberRefIndex(cons) << 3) | 3;            if (a.OriginalBlob != null)            {                table[k].Value = this.GetBlobIndex(a.OriginalBlob);            }            else            {                table[k].Value = this.GetBlobIndex(a.Expressions' cons.Parameters);            }            k++;          }        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: for (int i = 0' n = this.nodesWithCustomAttributes.Count; i < n; i++){          AttributeList attrs = null;          Node node = this.nodesWithCustomAttributes[i];          int codedIndex = 0;          switch(node.NodeType){            case NodeType.Method:            case NodeType.InstanceInitializer:            case NodeType.StaticInitializer:              Method m = (Method)node;              codedIndex = this.GetMethodIndex(m)<<5;               attrs = m.Attributes;              break;            case NodeType.Field:              Field f = (Field)node;              codedIndex = (this.GetFieldIndex(f)<<5)|1;              attrs = f.Attributes;              break;            case NodeType.Parameter:              Parameter par = (Parameter)node;              codedIndex = (this.GetParamIndex(par)<<5)|4;              attrs = par.Attributes;              break;            case NodeType.Class:            case NodeType.DelegateNode:            case NodeType.EnumNode:            case NodeType.Interface:            case NodeType.Struct:  #if !MinimalReader            case NodeType.TupleType:            case NodeType.TypeAlias:            case NodeType.TypeIntersection:            case NodeType.TypeUnion:  #endif              TypeNode t = (TypeNode)node;              if (this.IsStructural(t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))                codedIndex = (this.GetTypeSpecIndex(t)<<5)|13;              else                codedIndex = (this.GetTypeDefIndex(t)<<5)|3;              attrs = t.Attributes;              break;            case NodeType.ClassParameter:            case NodeType.TypeParameter:              if (!this.UseGenerics) goto case NodeType.Class;              t = (TypeNode)node;              codedIndex = (this.GetGenericParamIndex(t)<<5)|19;              attrs = t.Attributes;              break;            case NodeType.Property:              Property p = (Property)node;              codedIndex = (this.GetPropertyIndex(p)<<5)|9;              attrs = p.Attributes;              break;            case NodeType.Event:              Event e = (Event)node;              codedIndex = (this.GetEventIndex(e)<<5)|10;              attrs = e.Attributes;              break;            case NodeType.Module:            case NodeType.Assembly:              codedIndex =  (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);              attrs = ((Module)node).Attributes;              break;            default:              Debug.Assert(false);              break;          }          if (attrs == null) continue;          if (UseGenerics) {            Debug.Assert(codedIndex > prevCodedIndex);          }          prevCodedIndex = codedIndex;          for (int j = 0' m = attrs.Count; j < m; j++){            AttributeNode a = attrs[j];            if (a == null) continue;            table[k].Parent = codedIndex;            Debug.Assert(a.Constructor is MemberBinding);            Method cons = (Method)((MemberBinding)a.Constructor).BoundMember;            if (cons.DeclaringType.DeclaringModule == this.module && !this.IsStructural(cons.DeclaringType))              table[k].Constructor = (this.GetMethodIndex(cons) << 3) | 2;            else              table[k].Constructor = (this.GetMemberRefIndex(cons) << 3) | 3;            if (a.OriginalBlob != null)            {                table[k].Value = this.GetBlobIndex(a.OriginalBlob);            }            else            {                table[k].Value = this.GetBlobIndex(a.Expressions' cons.Parameters);            }            k++;          }        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: for (int i = 0' n = this.nodesWithCustomAttributes.Count; i < n; i++){          AttributeList attrs = null;          Node node = this.nodesWithCustomAttributes[i];          int codedIndex = 0;          switch(node.NodeType){            case NodeType.Method:            case NodeType.InstanceInitializer:            case NodeType.StaticInitializer:              Method m = (Method)node;              codedIndex = this.GetMethodIndex(m)<<5;               attrs = m.Attributes;              break;            case NodeType.Field:              Field f = (Field)node;              codedIndex = (this.GetFieldIndex(f)<<5)|1;              attrs = f.Attributes;              break;            case NodeType.Parameter:              Parameter par = (Parameter)node;              codedIndex = (this.GetParamIndex(par)<<5)|4;              attrs = par.Attributes;              break;            case NodeType.Class:            case NodeType.DelegateNode:            case NodeType.EnumNode:            case NodeType.Interface:            case NodeType.Struct:  #if !MinimalReader            case NodeType.TupleType:            case NodeType.TypeAlias:            case NodeType.TypeIntersection:            case NodeType.TypeUnion:  #endif              TypeNode t = (TypeNode)node;              if (this.IsStructural(t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))                codedIndex = (this.GetTypeSpecIndex(t)<<5)|13;              else                codedIndex = (this.GetTypeDefIndex(t)<<5)|3;              attrs = t.Attributes;              break;            case NodeType.ClassParameter:            case NodeType.TypeParameter:              if (!this.UseGenerics) goto case NodeType.Class;              t = (TypeNode)node;              codedIndex = (this.GetGenericParamIndex(t)<<5)|19;              attrs = t.Attributes;              break;            case NodeType.Property:              Property p = (Property)node;              codedIndex = (this.GetPropertyIndex(p)<<5)|9;              attrs = p.Attributes;              break;            case NodeType.Event:              Event e = (Event)node;              codedIndex = (this.GetEventIndex(e)<<5)|10;              attrs = e.Attributes;              break;            case NodeType.Module:            case NodeType.Assembly:              codedIndex =  (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);              attrs = ((Module)node).Attributes;              break;            default:              Debug.Assert(false);              break;          }          if (attrs == null) continue;          if (UseGenerics) {            Debug.Assert(codedIndex > prevCodedIndex);          }          prevCodedIndex = codedIndex;          for (int j = 0' m = attrs.Count; j < m; j++){            AttributeNode a = attrs[j];            if (a == null) continue;            table[k].Parent = codedIndex;            Debug.Assert(a.Constructor is MemberBinding);            Method cons = (Method)((MemberBinding)a.Constructor).BoundMember;            if (cons.DeclaringType.DeclaringModule == this.module && !this.IsStructural(cons.DeclaringType))              table[k].Constructor = (this.GetMethodIndex(cons) << 3) | 2;            else              table[k].Constructor = (this.GetMemberRefIndex(cons) << 3) | 3;            if (a.OriginalBlob != null)            {                table[k].Value = this.GetBlobIndex(a.OriginalBlob);            }            else            {                table[k].Value = this.GetBlobIndex(a.Expressions' cons.Parameters);            }            k++;          }        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: for (int i = 0' n = this.nodesWithCustomAttributes.Count; i < n; i++){          AttributeList attrs = null;          Node node = this.nodesWithCustomAttributes[i];          int codedIndex = 0;          switch(node.NodeType){            case NodeType.Method:            case NodeType.InstanceInitializer:            case NodeType.StaticInitializer:              Method m = (Method)node;              codedIndex = this.GetMethodIndex(m)<<5;               attrs = m.Attributes;              break;            case NodeType.Field:              Field f = (Field)node;              codedIndex = (this.GetFieldIndex(f)<<5)|1;              attrs = f.Attributes;              break;            case NodeType.Parameter:              Parameter par = (Parameter)node;              codedIndex = (this.GetParamIndex(par)<<5)|4;              attrs = par.Attributes;              break;            case NodeType.Class:            case NodeType.DelegateNode:            case NodeType.EnumNode:            case NodeType.Interface:            case NodeType.Struct:  #if !MinimalReader            case NodeType.TupleType:            case NodeType.TypeAlias:            case NodeType.TypeIntersection:            case NodeType.TypeUnion:  #endif              TypeNode t = (TypeNode)node;              if (this.IsStructural(t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))                codedIndex = (this.GetTypeSpecIndex(t)<<5)|13;              else                codedIndex = (this.GetTypeDefIndex(t)<<5)|3;              attrs = t.Attributes;              break;            case NodeType.ClassParameter:            case NodeType.TypeParameter:              if (!this.UseGenerics) goto case NodeType.Class;              t = (TypeNode)node;              codedIndex = (this.GetGenericParamIndex(t)<<5)|19;              attrs = t.Attributes;              break;            case NodeType.Property:              Property p = (Property)node;              codedIndex = (this.GetPropertyIndex(p)<<5)|9;              attrs = p.Attributes;              break;            case NodeType.Event:              Event e = (Event)node;              codedIndex = (this.GetEventIndex(e)<<5)|10;              attrs = e.Attributes;              break;            case NodeType.Module:            case NodeType.Assembly:              codedIndex =  (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);              attrs = ((Module)node).Attributes;              break;            default:              Debug.Assert(false);              break;          }          if (attrs == null) continue;          if (UseGenerics) {            Debug.Assert(codedIndex > prevCodedIndex);          }          prevCodedIndex = codedIndex;          for (int j = 0' m = attrs.Count; j < m; j++){            AttributeNode a = attrs[j];            if (a == null) continue;            table[k].Parent = codedIndex;            Debug.Assert(a.Constructor is MemberBinding);            Method cons = (Method)((MemberBinding)a.Constructor).BoundMember;            if (cons.DeclaringType.DeclaringModule == this.module && !this.IsStructural(cons.DeclaringType))              table[k].Constructor = (this.GetMethodIndex(cons) << 3) | 2;            else              table[k].Constructor = (this.GetMemberRefIndex(cons) << 3) | 3;            if (a.OriginalBlob != null)            {                table[k].Value = this.GetBlobIndex(a.OriginalBlob);            }            else            {                table[k].Value = this.GetBlobIndex(a.Expressions' cons.Parameters);            }            k++;          }        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: for (int i = 0' n = this.nodesWithCustomAttributes.Count; i < n; i++){          AttributeList attrs = null;          Node node = this.nodesWithCustomAttributes[i];          int codedIndex = 0;          switch(node.NodeType){            case NodeType.Method:            case NodeType.InstanceInitializer:            case NodeType.StaticInitializer:              Method m = (Method)node;              codedIndex = this.GetMethodIndex(m)<<5;               attrs = m.Attributes;              break;            case NodeType.Field:              Field f = (Field)node;              codedIndex = (this.GetFieldIndex(f)<<5)|1;              attrs = f.Attributes;              break;            case NodeType.Parameter:              Parameter par = (Parameter)node;              codedIndex = (this.GetParamIndex(par)<<5)|4;              attrs = par.Attributes;              break;            case NodeType.Class:            case NodeType.DelegateNode:            case NodeType.EnumNode:            case NodeType.Interface:            case NodeType.Struct:  #if !MinimalReader            case NodeType.TupleType:            case NodeType.TypeAlias:            case NodeType.TypeIntersection:            case NodeType.TypeUnion:  #endif              TypeNode t = (TypeNode)node;              if (this.IsStructural(t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))                codedIndex = (this.GetTypeSpecIndex(t)<<5)|13;              else                codedIndex = (this.GetTypeDefIndex(t)<<5)|3;              attrs = t.Attributes;              break;            case NodeType.ClassParameter:            case NodeType.TypeParameter:              if (!this.UseGenerics) goto case NodeType.Class;              t = (TypeNode)node;              codedIndex = (this.GetGenericParamIndex(t)<<5)|19;              attrs = t.Attributes;              break;            case NodeType.Property:              Property p = (Property)node;              codedIndex = (this.GetPropertyIndex(p)<<5)|9;              attrs = p.Attributes;              break;            case NodeType.Event:              Event e = (Event)node;              codedIndex = (this.GetEventIndex(e)<<5)|10;              attrs = e.Attributes;              break;            case NodeType.Module:            case NodeType.Assembly:              codedIndex =  (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);              attrs = ((Module)node).Attributes;              break;            default:              Debug.Assert(false);              break;          }          if (attrs == null) continue;          if (UseGenerics) {            Debug.Assert(codedIndex > prevCodedIndex);          }          prevCodedIndex = codedIndex;          for (int j = 0' m = attrs.Count; j < m; j++){            AttributeNode a = attrs[j];            if (a == null) continue;            table[k].Parent = codedIndex;            Debug.Assert(a.Constructor is MemberBinding);            Method cons = (Method)((MemberBinding)a.Constructor).BoundMember;            if (cons.DeclaringType.DeclaringModule == this.module && !this.IsStructural(cons.DeclaringType))              table[k].Constructor = (this.GetMethodIndex(cons) << 3) | 2;            else              table[k].Constructor = (this.GetMemberRefIndex(cons) << 3) | 3;            if (a.OriginalBlob != null)            {                table[k].Value = this.GetBlobIndex(a.OriginalBlob);            }            else            {                table[k].Value = this.GetBlobIndex(a.Expressions' cons.Parameters);            }            k++;          }        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: for (int i = 0' n = this.nodesWithCustomAttributes.Count; i < n; i++){          AttributeList attrs = null;          Node node = this.nodesWithCustomAttributes[i];          int codedIndex = 0;          switch(node.NodeType){            case NodeType.Method:            case NodeType.InstanceInitializer:            case NodeType.StaticInitializer:              Method m = (Method)node;              codedIndex = this.GetMethodIndex(m)<<5;               attrs = m.Attributes;              break;            case NodeType.Field:              Field f = (Field)node;              codedIndex = (this.GetFieldIndex(f)<<5)|1;              attrs = f.Attributes;              break;            case NodeType.Parameter:              Parameter par = (Parameter)node;              codedIndex = (this.GetParamIndex(par)<<5)|4;              attrs = par.Attributes;              break;            case NodeType.Class:            case NodeType.DelegateNode:            case NodeType.EnumNode:            case NodeType.Interface:            case NodeType.Struct:  #if !MinimalReader            case NodeType.TupleType:            case NodeType.TypeAlias:            case NodeType.TypeIntersection:            case NodeType.TypeUnion:  #endif              TypeNode t = (TypeNode)node;              if (this.IsStructural(t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))                codedIndex = (this.GetTypeSpecIndex(t)<<5)|13;              else                codedIndex = (this.GetTypeDefIndex(t)<<5)|3;              attrs = t.Attributes;              break;            case NodeType.ClassParameter:            case NodeType.TypeParameter:              if (!this.UseGenerics) goto case NodeType.Class;              t = (TypeNode)node;              codedIndex = (this.GetGenericParamIndex(t)<<5)|19;              attrs = t.Attributes;              break;            case NodeType.Property:              Property p = (Property)node;              codedIndex = (this.GetPropertyIndex(p)<<5)|9;              attrs = p.Attributes;              break;            case NodeType.Event:              Event e = (Event)node;              codedIndex = (this.GetEventIndex(e)<<5)|10;              attrs = e.Attributes;              break;            case NodeType.Module:            case NodeType.Assembly:              codedIndex =  (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);              attrs = ((Module)node).Attributes;              break;            default:              Debug.Assert(false);              break;          }          if (attrs == null) continue;          if (UseGenerics) {            Debug.Assert(codedIndex > prevCodedIndex);          }          prevCodedIndex = codedIndex;          for (int j = 0' m = attrs.Count; j < m; j++){            AttributeNode a = attrs[j];            if (a == null) continue;            table[k].Parent = codedIndex;            Debug.Assert(a.Constructor is MemberBinding);            Method cons = (Method)((MemberBinding)a.Constructor).BoundMember;            if (cons.DeclaringType.DeclaringModule == this.module && !this.IsStructural(cons.DeclaringType))              table[k].Constructor = (this.GetMethodIndex(cons) << 3) | 2;            else              table[k].Constructor = (this.GetMemberRefIndex(cons) << 3) | 3;            if (a.OriginalBlob != null)            {                table[k].Value = this.GetBlobIndex(a.OriginalBlob);            }            else            {                table[k].Value = this.GetBlobIndex(a.Expressions' cons.Parameters);            }            k++;          }        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: for (int i = 0' n = this.nodesWithCustomAttributes.Count; i < n; i++){          AttributeList attrs = null;          Node node = this.nodesWithCustomAttributes[i];          int codedIndex = 0;          switch(node.NodeType){            case NodeType.Method:            case NodeType.InstanceInitializer:            case NodeType.StaticInitializer:              Method m = (Method)node;              codedIndex = this.GetMethodIndex(m)<<5;               attrs = m.Attributes;              break;            case NodeType.Field:              Field f = (Field)node;              codedIndex = (this.GetFieldIndex(f)<<5)|1;              attrs = f.Attributes;              break;            case NodeType.Parameter:              Parameter par = (Parameter)node;              codedIndex = (this.GetParamIndex(par)<<5)|4;              attrs = par.Attributes;              break;            case NodeType.Class:            case NodeType.DelegateNode:            case NodeType.EnumNode:            case NodeType.Interface:            case NodeType.Struct:  #if !MinimalReader            case NodeType.TupleType:            case NodeType.TypeAlias:            case NodeType.TypeIntersection:            case NodeType.TypeUnion:  #endif              TypeNode t = (TypeNode)node;              if (this.IsStructural(t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))                codedIndex = (this.GetTypeSpecIndex(t)<<5)|13;              else                codedIndex = (this.GetTypeDefIndex(t)<<5)|3;              attrs = t.Attributes;              break;            case NodeType.ClassParameter:            case NodeType.TypeParameter:              if (!this.UseGenerics) goto case NodeType.Class;              t = (TypeNode)node;              codedIndex = (this.GetGenericParamIndex(t)<<5)|19;              attrs = t.Attributes;              break;            case NodeType.Property:              Property p = (Property)node;              codedIndex = (this.GetPropertyIndex(p)<<5)|9;              attrs = p.Attributes;              break;            case NodeType.Event:              Event e = (Event)node;              codedIndex = (this.GetEventIndex(e)<<5)|10;              attrs = e.Attributes;              break;            case NodeType.Module:            case NodeType.Assembly:              codedIndex =  (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);              attrs = ((Module)node).Attributes;              break;            default:              Debug.Assert(false);              break;          }          if (attrs == null) continue;          if (UseGenerics) {            Debug.Assert(codedIndex > prevCodedIndex);          }          prevCodedIndex = codedIndex;          for (int j = 0' m = attrs.Count; j < m; j++){            AttributeNode a = attrs[j];            if (a == null) continue;            table[k].Parent = codedIndex;            Debug.Assert(a.Constructor is MemberBinding);            Method cons = (Method)((MemberBinding)a.Constructor).BoundMember;            if (cons.DeclaringType.DeclaringModule == this.module && !this.IsStructural(cons.DeclaringType))              table[k].Constructor = (this.GetMethodIndex(cons) << 3) | 2;            else              table[k].Constructor = (this.GetMemberRefIndex(cons) << 3) | 3;            if (a.OriginalBlob != null)            {                table[k].Value = this.GetBlobIndex(a.OriginalBlob);            }            else            {                table[k].Value = this.GetBlobIndex(a.Expressions' cons.Parameters);            }            k++;          }        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: for (int i = 0' n = this.nodesWithCustomAttributes.Count; i < n; i++){          AttributeList attrs = null;          Node node = this.nodesWithCustomAttributes[i];          int codedIndex = 0;          switch(node.NodeType){            case NodeType.Method:            case NodeType.InstanceInitializer:            case NodeType.StaticInitializer:              Method m = (Method)node;              codedIndex = this.GetMethodIndex(m)<<5;               attrs = m.Attributes;              break;            case NodeType.Field:              Field f = (Field)node;              codedIndex = (this.GetFieldIndex(f)<<5)|1;              attrs = f.Attributes;              break;            case NodeType.Parameter:              Parameter par = (Parameter)node;              codedIndex = (this.GetParamIndex(par)<<5)|4;              attrs = par.Attributes;              break;            case NodeType.Class:            case NodeType.DelegateNode:            case NodeType.EnumNode:            case NodeType.Interface:            case NodeType.Struct:  #if !MinimalReader            case NodeType.TupleType:            case NodeType.TypeAlias:            case NodeType.TypeIntersection:            case NodeType.TypeUnion:  #endif              TypeNode t = (TypeNode)node;              if (this.IsStructural(t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))                codedIndex = (this.GetTypeSpecIndex(t)<<5)|13;              else                codedIndex = (this.GetTypeDefIndex(t)<<5)|3;              attrs = t.Attributes;              break;            case NodeType.ClassParameter:            case NodeType.TypeParameter:              if (!this.UseGenerics) goto case NodeType.Class;              t = (TypeNode)node;              codedIndex = (this.GetGenericParamIndex(t)<<5)|19;              attrs = t.Attributes;              break;            case NodeType.Property:              Property p = (Property)node;              codedIndex = (this.GetPropertyIndex(p)<<5)|9;              attrs = p.Attributes;              break;            case NodeType.Event:              Event e = (Event)node;              codedIndex = (this.GetEventIndex(e)<<5)|10;              attrs = e.Attributes;              break;            case NodeType.Module:            case NodeType.Assembly:              codedIndex =  (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);              attrs = ((Module)node).Attributes;              break;            default:              Debug.Assert(false);              break;          }          if (attrs == null) continue;          if (UseGenerics) {            Debug.Assert(codedIndex > prevCodedIndex);          }          prevCodedIndex = codedIndex;          for (int j = 0' m = attrs.Count; j < m; j++){            AttributeNode a = attrs[j];            if (a == null) continue;            table[k].Parent = codedIndex;            Debug.Assert(a.Constructor is MemberBinding);            Method cons = (Method)((MemberBinding)a.Constructor).BoundMember;            if (cons.DeclaringType.DeclaringModule == this.module && !this.IsStructural(cons.DeclaringType))              table[k].Constructor = (this.GetMethodIndex(cons) << 3) | 2;            else              table[k].Constructor = (this.GetMemberRefIndex(cons) << 3) | 3;            if (a.OriginalBlob != null)            {                table[k].Value = this.GetBlobIndex(a.OriginalBlob);            }            else            {                table[k].Value = this.GetBlobIndex(a.Expressions' cons.Parameters);            }            k++;          }        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: for (int i = 0' n = this.nodesWithCustomAttributes.Count; i < n; i++){          AttributeList attrs = null;          Node node = this.nodesWithCustomAttributes[i];          int codedIndex = 0;          switch(node.NodeType){            case NodeType.Method:            case NodeType.InstanceInitializer:            case NodeType.StaticInitializer:              Method m = (Method)node;              codedIndex = this.GetMethodIndex(m)<<5;               attrs = m.Attributes;              break;            case NodeType.Field:              Field f = (Field)node;              codedIndex = (this.GetFieldIndex(f)<<5)|1;              attrs = f.Attributes;              break;            case NodeType.Parameter:              Parameter par = (Parameter)node;              codedIndex = (this.GetParamIndex(par)<<5)|4;              attrs = par.Attributes;              break;            case NodeType.Class:            case NodeType.DelegateNode:            case NodeType.EnumNode:            case NodeType.Interface:            case NodeType.Struct:  #if !MinimalReader            case NodeType.TupleType:            case NodeType.TypeAlias:            case NodeType.TypeIntersection:            case NodeType.TypeUnion:  #endif              TypeNode t = (TypeNode)node;              if (this.IsStructural(t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))                codedIndex = (this.GetTypeSpecIndex(t)<<5)|13;              else                codedIndex = (this.GetTypeDefIndex(t)<<5)|3;              attrs = t.Attributes;              break;            case NodeType.ClassParameter:            case NodeType.TypeParameter:              if (!this.UseGenerics) goto case NodeType.Class;              t = (TypeNode)node;              codedIndex = (this.GetGenericParamIndex(t)<<5)|19;              attrs = t.Attributes;              break;            case NodeType.Property:              Property p = (Property)node;              codedIndex = (this.GetPropertyIndex(p)<<5)|9;              attrs = p.Attributes;              break;            case NodeType.Event:              Event e = (Event)node;              codedIndex = (this.GetEventIndex(e)<<5)|10;              attrs = e.Attributes;              break;            case NodeType.Module:            case NodeType.Assembly:              codedIndex =  (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);              attrs = ((Module)node).Attributes;              break;            default:              Debug.Assert(false);              break;          }          if (attrs == null) continue;          if (UseGenerics) {            Debug.Assert(codedIndex > prevCodedIndex);          }          prevCodedIndex = codedIndex;          for (int j = 0' m = attrs.Count; j < m; j++){            AttributeNode a = attrs[j];            if (a == null) continue;            table[k].Parent = codedIndex;            Debug.Assert(a.Constructor is MemberBinding);            Method cons = (Method)((MemberBinding)a.Constructor).BoundMember;            if (cons.DeclaringType.DeclaringModule == this.module && !this.IsStructural(cons.DeclaringType))              table[k].Constructor = (this.GetMethodIndex(cons) << 3) | 2;            else              table[k].Constructor = (this.GetMemberRefIndex(cons) << 3) | 3;            if (a.OriginalBlob != null)            {                table[k].Value = this.GetBlobIndex(a.OriginalBlob);            }            else            {                table[k].Value = this.GetBlobIndex(a.Expressions' cons.Parameters);            }            k++;          }        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: for (int i = 0' n = this.nodesWithCustomAttributes.Count; i < n; i++){          AttributeList attrs = null;          Node node = this.nodesWithCustomAttributes[i];          int codedIndex = 0;          switch(node.NodeType){            case NodeType.Method:            case NodeType.InstanceInitializer:            case NodeType.StaticInitializer:              Method m = (Method)node;              codedIndex = this.GetMethodIndex(m)<<5;               attrs = m.Attributes;              break;            case NodeType.Field:              Field f = (Field)node;              codedIndex = (this.GetFieldIndex(f)<<5)|1;              attrs = f.Attributes;              break;            case NodeType.Parameter:              Parameter par = (Parameter)node;              codedIndex = (this.GetParamIndex(par)<<5)|4;              attrs = par.Attributes;              break;            case NodeType.Class:            case NodeType.DelegateNode:            case NodeType.EnumNode:            case NodeType.Interface:            case NodeType.Struct:  #if !MinimalReader            case NodeType.TupleType:            case NodeType.TypeAlias:            case NodeType.TypeIntersection:            case NodeType.TypeUnion:  #endif              TypeNode t = (TypeNode)node;              if (this.IsStructural(t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))                codedIndex = (this.GetTypeSpecIndex(t)<<5)|13;              else                codedIndex = (this.GetTypeDefIndex(t)<<5)|3;              attrs = t.Attributes;              break;            case NodeType.ClassParameter:            case NodeType.TypeParameter:              if (!this.UseGenerics) goto case NodeType.Class;              t = (TypeNode)node;              codedIndex = (this.GetGenericParamIndex(t)<<5)|19;              attrs = t.Attributes;              break;            case NodeType.Property:              Property p = (Property)node;              codedIndex = (this.GetPropertyIndex(p)<<5)|9;              attrs = p.Attributes;              break;            case NodeType.Event:              Event e = (Event)node;              codedIndex = (this.GetEventIndex(e)<<5)|10;              attrs = e.Attributes;              break;            case NodeType.Module:            case NodeType.Assembly:              codedIndex =  (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);              attrs = ((Module)node).Attributes;              break;            default:              Debug.Assert(false);              break;          }          if (attrs == null) continue;          if (UseGenerics) {            Debug.Assert(codedIndex > prevCodedIndex);          }          prevCodedIndex = codedIndex;          for (int j = 0' m = attrs.Count; j < m; j++){            AttributeNode a = attrs[j];            if (a == null) continue;            table[k].Parent = codedIndex;            Debug.Assert(a.Constructor is MemberBinding);            Method cons = (Method)((MemberBinding)a.Constructor).BoundMember;            if (cons.DeclaringType.DeclaringModule == this.module && !this.IsStructural(cons.DeclaringType))              table[k].Constructor = (this.GetMethodIndex(cons) << 3) | 2;            else              table[k].Constructor = (this.GetMemberRefIndex(cons) << 3) | 3;            if (a.OriginalBlob != null)            {                table[k].Value = this.GetBlobIndex(a.OriginalBlob);            }            else            {                table[k].Value = this.GetBlobIndex(a.Expressions' cons.Parameters);            }            k++;          }        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: for (int i = 0' n = this.nodesWithCustomAttributes.Count; i < n; i++){          AttributeList attrs = null;          Node node = this.nodesWithCustomAttributes[i];          int codedIndex = 0;          switch(node.NodeType){            case NodeType.Method:            case NodeType.InstanceInitializer:            case NodeType.StaticInitializer:              Method m = (Method)node;              codedIndex = this.GetMethodIndex(m)<<5;               attrs = m.Attributes;              break;            case NodeType.Field:              Field f = (Field)node;              codedIndex = (this.GetFieldIndex(f)<<5)|1;              attrs = f.Attributes;              break;            case NodeType.Parameter:              Parameter par = (Parameter)node;              codedIndex = (this.GetParamIndex(par)<<5)|4;              attrs = par.Attributes;              break;            case NodeType.Class:            case NodeType.DelegateNode:            case NodeType.EnumNode:            case NodeType.Interface:            case NodeType.Struct:  #if !MinimalReader            case NodeType.TupleType:            case NodeType.TypeAlias:            case NodeType.TypeIntersection:            case NodeType.TypeUnion:  #endif              TypeNode t = (TypeNode)node;              if (this.IsStructural(t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))                codedIndex = (this.GetTypeSpecIndex(t)<<5)|13;              else                codedIndex = (this.GetTypeDefIndex(t)<<5)|3;              attrs = t.Attributes;              break;            case NodeType.ClassParameter:            case NodeType.TypeParameter:              if (!this.UseGenerics) goto case NodeType.Class;              t = (TypeNode)node;              codedIndex = (this.GetGenericParamIndex(t)<<5)|19;              attrs = t.Attributes;              break;            case NodeType.Property:              Property p = (Property)node;              codedIndex = (this.GetPropertyIndex(p)<<5)|9;              attrs = p.Attributes;              break;            case NodeType.Event:              Event e = (Event)node;              codedIndex = (this.GetEventIndex(e)<<5)|10;              attrs = e.Attributes;              break;            case NodeType.Module:            case NodeType.Assembly:              codedIndex =  (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);              attrs = ((Module)node).Attributes;              break;            default:              Debug.Assert(false);              break;          }          if (attrs == null) continue;          if (UseGenerics) {            Debug.Assert(codedIndex > prevCodedIndex);          }          prevCodedIndex = codedIndex;          for (int j = 0' m = attrs.Count; j < m; j++){            AttributeNode a = attrs[j];            if (a == null) continue;            table[k].Parent = codedIndex;            Debug.Assert(a.Constructor is MemberBinding);            Method cons = (Method)((MemberBinding)a.Constructor).BoundMember;            if (cons.DeclaringType.DeclaringModule == this.module && !this.IsStructural(cons.DeclaringType))              table[k].Constructor = (this.GetMethodIndex(cons) << 3) | 2;            else              table[k].Constructor = (this.GetMemberRefIndex(cons) << 3) | 3;            if (a.OriginalBlob != null)            {                table[k].Value = this.GetBlobIndex(a.OriginalBlob);            }            else            {                table[k].Value = this.GetBlobIndex(a.Expressions' cons.Parameters);            }            k++;          }        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: for (int i = 0' n = this.nodesWithCustomAttributes.Count; i < n; i++){          AttributeList attrs = null;          Node node = this.nodesWithCustomAttributes[i];          int codedIndex = 0;          switch(node.NodeType){            case NodeType.Method:            case NodeType.InstanceInitializer:            case NodeType.StaticInitializer:              Method m = (Method)node;              codedIndex = this.GetMethodIndex(m)<<5;               attrs = m.Attributes;              break;            case NodeType.Field:              Field f = (Field)node;              codedIndex = (this.GetFieldIndex(f)<<5)|1;              attrs = f.Attributes;              break;            case NodeType.Parameter:              Parameter par = (Parameter)node;              codedIndex = (this.GetParamIndex(par)<<5)|4;              attrs = par.Attributes;              break;            case NodeType.Class:            case NodeType.DelegateNode:            case NodeType.EnumNode:            case NodeType.Interface:            case NodeType.Struct:  #if !MinimalReader            case NodeType.TupleType:            case NodeType.TypeAlias:            case NodeType.TypeIntersection:            case NodeType.TypeUnion:  #endif              TypeNode t = (TypeNode)node;              if (this.IsStructural(t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))                codedIndex = (this.GetTypeSpecIndex(t)<<5)|13;              else                codedIndex = (this.GetTypeDefIndex(t)<<5)|3;              attrs = t.Attributes;              break;            case NodeType.ClassParameter:            case NodeType.TypeParameter:              if (!this.UseGenerics) goto case NodeType.Class;              t = (TypeNode)node;              codedIndex = (this.GetGenericParamIndex(t)<<5)|19;              attrs = t.Attributes;              break;            case NodeType.Property:              Property p = (Property)node;              codedIndex = (this.GetPropertyIndex(p)<<5)|9;              attrs = p.Attributes;              break;            case NodeType.Event:              Event e = (Event)node;              codedIndex = (this.GetEventIndex(e)<<5)|10;              attrs = e.Attributes;              break;            case NodeType.Module:            case NodeType.Assembly:              codedIndex =  (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);              attrs = ((Module)node).Attributes;              break;            default:              Debug.Assert(false);              break;          }          if (attrs == null) continue;          if (UseGenerics) {            Debug.Assert(codedIndex > prevCodedIndex);          }          prevCodedIndex = codedIndex;          for (int j = 0' m = attrs.Count; j < m; j++){            AttributeNode a = attrs[j];            if (a == null) continue;            table[k].Parent = codedIndex;            Debug.Assert(a.Constructor is MemberBinding);            Method cons = (Method)((MemberBinding)a.Constructor).BoundMember;            if (cons.DeclaringType.DeclaringModule == this.module && !this.IsStructural(cons.DeclaringType))              table[k].Constructor = (this.GetMethodIndex(cons) << 3) | 2;            else              table[k].Constructor = (this.GetMemberRefIndex(cons) << 3) | 3;            if (a.OriginalBlob != null)            {                table[k].Value = this.GetBlobIndex(a.OriginalBlob);            }            else            {                table[k].Value = this.GetBlobIndex(a.Expressions' cons.Parameters);            }            k++;          }        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: for (int i = 0' n = this.nodesWithCustomAttributes.Count; i < n; i++){          AttributeList attrs = null;          Node node = this.nodesWithCustomAttributes[i];          int codedIndex = 0;          switch(node.NodeType){            case NodeType.Method:            case NodeType.InstanceInitializer:            case NodeType.StaticInitializer:              Method m = (Method)node;              codedIndex = this.GetMethodIndex(m)<<5;               attrs = m.Attributes;              break;            case NodeType.Field:              Field f = (Field)node;              codedIndex = (this.GetFieldIndex(f)<<5)|1;              attrs = f.Attributes;              break;            case NodeType.Parameter:              Parameter par = (Parameter)node;              codedIndex = (this.GetParamIndex(par)<<5)|4;              attrs = par.Attributes;              break;            case NodeType.Class:            case NodeType.DelegateNode:            case NodeType.EnumNode:            case NodeType.Interface:            case NodeType.Struct:  #if !MinimalReader            case NodeType.TupleType:            case NodeType.TypeAlias:            case NodeType.TypeIntersection:            case NodeType.TypeUnion:  #endif              TypeNode t = (TypeNode)node;              if (this.IsStructural(t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))                codedIndex = (this.GetTypeSpecIndex(t)<<5)|13;              else                codedIndex = (this.GetTypeDefIndex(t)<<5)|3;              attrs = t.Attributes;              break;            case NodeType.ClassParameter:            case NodeType.TypeParameter:              if (!this.UseGenerics) goto case NodeType.Class;              t = (TypeNode)node;              codedIndex = (this.GetGenericParamIndex(t)<<5)|19;              attrs = t.Attributes;              break;            case NodeType.Property:              Property p = (Property)node;              codedIndex = (this.GetPropertyIndex(p)<<5)|9;              attrs = p.Attributes;              break;            case NodeType.Event:              Event e = (Event)node;              codedIndex = (this.GetEventIndex(e)<<5)|10;              attrs = e.Attributes;              break;            case NodeType.Module:            case NodeType.Assembly:              codedIndex =  (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);              attrs = ((Module)node).Attributes;              break;            default:              Debug.Assert(false);              break;          }          if (attrs == null) continue;          if (UseGenerics) {            Debug.Assert(codedIndex > prevCodedIndex);          }          prevCodedIndex = codedIndex;          for (int j = 0' m = attrs.Count; j < m; j++){            AttributeNode a = attrs[j];            if (a == null) continue;            table[k].Parent = codedIndex;            Debug.Assert(a.Constructor is MemberBinding);            Method cons = (Method)((MemberBinding)a.Constructor).BoundMember;            if (cons.DeclaringType.DeclaringModule == this.module && !this.IsStructural(cons.DeclaringType))              table[k].Constructor = (this.GetMethodIndex(cons) << 3) | 2;            else              table[k].Constructor = (this.GetMemberRefIndex(cons) << 3) | 3;            if (a.OriginalBlob != null)            {                table[k].Value = this.GetBlobIndex(a.OriginalBlob);            }            else            {                table[k].Value = this.GetBlobIndex(a.Expressions' cons.Parameters);            }            k++;          }        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: for (int i = 0' n = this.nodesWithCustomAttributes.Count; i < n; i++){          AttributeList attrs = null;          Node node = this.nodesWithCustomAttributes[i];          int codedIndex = 0;          switch(node.NodeType){            case NodeType.Method:            case NodeType.InstanceInitializer:            case NodeType.StaticInitializer:              Method m = (Method)node;              codedIndex = this.GetMethodIndex(m)<<5;               attrs = m.Attributes;              break;            case NodeType.Field:              Field f = (Field)node;              codedIndex = (this.GetFieldIndex(f)<<5)|1;              attrs = f.Attributes;              break;            case NodeType.Parameter:              Parameter par = (Parameter)node;              codedIndex = (this.GetParamIndex(par)<<5)|4;              attrs = par.Attributes;              break;            case NodeType.Class:            case NodeType.DelegateNode:            case NodeType.EnumNode:            case NodeType.Interface:            case NodeType.Struct:  #if !MinimalReader            case NodeType.TupleType:            case NodeType.TypeAlias:            case NodeType.TypeIntersection:            case NodeType.TypeUnion:  #endif              TypeNode t = (TypeNode)node;              if (this.IsStructural(t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))                codedIndex = (this.GetTypeSpecIndex(t)<<5)|13;              else                codedIndex = (this.GetTypeDefIndex(t)<<5)|3;              attrs = t.Attributes;              break;            case NodeType.ClassParameter:            case NodeType.TypeParameter:              if (!this.UseGenerics) goto case NodeType.Class;              t = (TypeNode)node;              codedIndex = (this.GetGenericParamIndex(t)<<5)|19;              attrs = t.Attributes;              break;            case NodeType.Property:              Property p = (Property)node;              codedIndex = (this.GetPropertyIndex(p)<<5)|9;              attrs = p.Attributes;              break;            case NodeType.Event:              Event e = (Event)node;              codedIndex = (this.GetEventIndex(e)<<5)|10;              attrs = e.Attributes;              break;            case NodeType.Module:            case NodeType.Assembly:              codedIndex =  (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);              attrs = ((Module)node).Attributes;              break;            default:              Debug.Assert(false);              break;          }          if (attrs == null) continue;          if (UseGenerics) {            Debug.Assert(codedIndex > prevCodedIndex);          }          prevCodedIndex = codedIndex;          for (int j = 0' m = attrs.Count; j < m; j++){            AttributeNode a = attrs[j];            if (a == null) continue;            table[k].Parent = codedIndex;            Debug.Assert(a.Constructor is MemberBinding);            Method cons = (Method)((MemberBinding)a.Constructor).BoundMember;            if (cons.DeclaringType.DeclaringModule == this.module && !this.IsStructural(cons.DeclaringType))              table[k].Constructor = (this.GetMethodIndex(cons) << 3) | 2;            else              table[k].Constructor = (this.GetMemberRefIndex(cons) << 3) | 3;            if (a.OriginalBlob != null)            {                table[k].Value = this.GetBlobIndex(a.OriginalBlob);            }            else            {                table[k].Value = this.GetBlobIndex(a.Expressions' cons.Parameters);            }            k++;          }        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: for (int i = 0' n = this.nodesWithCustomAttributes.Count; i < n; i++){          AttributeList attrs = null;          Node node = this.nodesWithCustomAttributes[i];          int codedIndex = 0;          switch(node.NodeType){            case NodeType.Method:            case NodeType.InstanceInitializer:            case NodeType.StaticInitializer:              Method m = (Method)node;              codedIndex = this.GetMethodIndex(m)<<5;               attrs = m.Attributes;              break;            case NodeType.Field:              Field f = (Field)node;              codedIndex = (this.GetFieldIndex(f)<<5)|1;              attrs = f.Attributes;              break;            case NodeType.Parameter:              Parameter par = (Parameter)node;              codedIndex = (this.GetParamIndex(par)<<5)|4;              attrs = par.Attributes;              break;            case NodeType.Class:            case NodeType.DelegateNode:            case NodeType.EnumNode:            case NodeType.Interface:            case NodeType.Struct:  #if !MinimalReader            case NodeType.TupleType:            case NodeType.TypeAlias:            case NodeType.TypeIntersection:            case NodeType.TypeUnion:  #endif              TypeNode t = (TypeNode)node;              if (this.IsStructural(t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))                codedIndex = (this.GetTypeSpecIndex(t)<<5)|13;              else                codedIndex = (this.GetTypeDefIndex(t)<<5)|3;              attrs = t.Attributes;              break;            case NodeType.ClassParameter:            case NodeType.TypeParameter:              if (!this.UseGenerics) goto case NodeType.Class;              t = (TypeNode)node;              codedIndex = (this.GetGenericParamIndex(t)<<5)|19;              attrs = t.Attributes;              break;            case NodeType.Property:              Property p = (Property)node;              codedIndex = (this.GetPropertyIndex(p)<<5)|9;              attrs = p.Attributes;              break;            case NodeType.Event:              Event e = (Event)node;              codedIndex = (this.GetEventIndex(e)<<5)|10;              attrs = e.Attributes;              break;            case NodeType.Module:            case NodeType.Assembly:              codedIndex =  (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);              attrs = ((Module)node).Attributes;              break;            default:              Debug.Assert(false);              break;          }          if (attrs == null) continue;          if (UseGenerics) {            Debug.Assert(codedIndex > prevCodedIndex);          }          prevCodedIndex = codedIndex;          for (int j = 0' m = attrs.Count; j < m; j++){            AttributeNode a = attrs[j];            if (a == null) continue;            table[k].Parent = codedIndex;            Debug.Assert(a.Constructor is MemberBinding);            Method cons = (Method)((MemberBinding)a.Constructor).BoundMember;            if (cons.DeclaringType.DeclaringModule == this.module && !this.IsStructural(cons.DeclaringType))              table[k].Constructor = (this.GetMethodIndex(cons) << 3) | 2;            else              table[k].Constructor = (this.GetMemberRefIndex(cons) << 3) | 3;            if (a.OriginalBlob != null)            {                table[k].Value = this.GetBlobIndex(a.OriginalBlob);            }            else            {                table[k].Value = this.GetBlobIndex(a.Expressions' cons.Parameters);            }            k++;          }        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: for (int i = 0' n = this.nodesWithCustomAttributes.Count; i < n; i++){          AttributeList attrs = null;          Node node = this.nodesWithCustomAttributes[i];          int codedIndex = 0;          switch(node.NodeType){            case NodeType.Method:            case NodeType.InstanceInitializer:            case NodeType.StaticInitializer:              Method m = (Method)node;              codedIndex = this.GetMethodIndex(m)<<5;               attrs = m.Attributes;              break;            case NodeType.Field:              Field f = (Field)node;              codedIndex = (this.GetFieldIndex(f)<<5)|1;              attrs = f.Attributes;              break;            case NodeType.Parameter:              Parameter par = (Parameter)node;              codedIndex = (this.GetParamIndex(par)<<5)|4;              attrs = par.Attributes;              break;            case NodeType.Class:            case NodeType.DelegateNode:            case NodeType.EnumNode:            case NodeType.Interface:            case NodeType.Struct:  #if !MinimalReader            case NodeType.TupleType:            case NodeType.TypeAlias:            case NodeType.TypeIntersection:            case NodeType.TypeUnion:  #endif              TypeNode t = (TypeNode)node;              if (this.IsStructural(t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))                codedIndex = (this.GetTypeSpecIndex(t)<<5)|13;              else                codedIndex = (this.GetTypeDefIndex(t)<<5)|3;              attrs = t.Attributes;              break;            case NodeType.ClassParameter:            case NodeType.TypeParameter:              if (!this.UseGenerics) goto case NodeType.Class;              t = (TypeNode)node;              codedIndex = (this.GetGenericParamIndex(t)<<5)|19;              attrs = t.Attributes;              break;            case NodeType.Property:              Property p = (Property)node;              codedIndex = (this.GetPropertyIndex(p)<<5)|9;              attrs = p.Attributes;              break;            case NodeType.Event:              Event e = (Event)node;              codedIndex = (this.GetEventIndex(e)<<5)|10;              attrs = e.Attributes;              break;            case NodeType.Module:            case NodeType.Assembly:              codedIndex =  (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);              attrs = ((Module)node).Attributes;              break;            default:              Debug.Assert(false);              break;          }          if (attrs == null) continue;          if (UseGenerics) {            Debug.Assert(codedIndex > prevCodedIndex);          }          prevCodedIndex = codedIndex;          for (int j = 0' m = attrs.Count; j < m; j++){            AttributeNode a = attrs[j];            if (a == null) continue;            table[k].Parent = codedIndex;            Debug.Assert(a.Constructor is MemberBinding);            Method cons = (Method)((MemberBinding)a.Constructor).BoundMember;            if (cons.DeclaringType.DeclaringModule == this.module && !this.IsStructural(cons.DeclaringType))              table[k].Constructor = (this.GetMethodIndex(cons) << 3) | 2;            else              table[k].Constructor = (this.GetMemberRefIndex(cons) << 3) | 3;            if (a.OriginalBlob != null)            {                table[k].Value = this.GetBlobIndex(a.OriginalBlob);            }            else            {                table[k].Value = this.GetBlobIndex(a.Expressions' cons.Parameters);            }            k++;          }        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: for (int i = 0' n = this.nodesWithCustomAttributes.Count; i < n; i++){          AttributeList attrs = null;          Node node = this.nodesWithCustomAttributes[i];          int codedIndex = 0;          switch(node.NodeType){            case NodeType.Method:            case NodeType.InstanceInitializer:            case NodeType.StaticInitializer:              Method m = (Method)node;              codedIndex = this.GetMethodIndex(m)<<5;               attrs = m.Attributes;              break;            case NodeType.Field:              Field f = (Field)node;              codedIndex = (this.GetFieldIndex(f)<<5)|1;              attrs = f.Attributes;              break;            case NodeType.Parameter:              Parameter par = (Parameter)node;              codedIndex = (this.GetParamIndex(par)<<5)|4;              attrs = par.Attributes;              break;            case NodeType.Class:            case NodeType.DelegateNode:            case NodeType.EnumNode:            case NodeType.Interface:            case NodeType.Struct:  #if !MinimalReader            case NodeType.TupleType:            case NodeType.TypeAlias:            case NodeType.TypeIntersection:            case NodeType.TypeUnion:  #endif              TypeNode t = (TypeNode)node;              if (this.IsStructural(t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))                codedIndex = (this.GetTypeSpecIndex(t)<<5)|13;              else                codedIndex = (this.GetTypeDefIndex(t)<<5)|3;              attrs = t.Attributes;              break;            case NodeType.ClassParameter:            case NodeType.TypeParameter:              if (!this.UseGenerics) goto case NodeType.Class;              t = (TypeNode)node;              codedIndex = (this.GetGenericParamIndex(t)<<5)|19;              attrs = t.Attributes;              break;            case NodeType.Property:              Property p = (Property)node;              codedIndex = (this.GetPropertyIndex(p)<<5)|9;              attrs = p.Attributes;              break;            case NodeType.Event:              Event e = (Event)node;              codedIndex = (this.GetEventIndex(e)<<5)|10;              attrs = e.Attributes;              break;            case NodeType.Module:            case NodeType.Assembly:              codedIndex =  (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);              attrs = ((Module)node).Attributes;              break;            default:              Debug.Assert(false);              break;          }          if (attrs == null) continue;          if (UseGenerics) {            Debug.Assert(codedIndex > prevCodedIndex);          }          prevCodedIndex = codedIndex;          for (int j = 0' m = attrs.Count; j < m; j++){            AttributeNode a = attrs[j];            if (a == null) continue;            table[k].Parent = codedIndex;            Debug.Assert(a.Constructor is MemberBinding);            Method cons = (Method)((MemberBinding)a.Constructor).BoundMember;            if (cons.DeclaringType.DeclaringModule == this.module && !this.IsStructural(cons.DeclaringType))              table[k].Constructor = (this.GetMethodIndex(cons) << 3) | 2;            else              table[k].Constructor = (this.GetMemberRefIndex(cons) << 3) | 3;            if (a.OriginalBlob != null)            {                table[k].Value = this.GetBlobIndex(a.OriginalBlob);            }            else            {                table[k].Value = this.GetBlobIndex(a.Expressions' cons.Parameters);            }            k++;          }        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: for (int i = 0' n = this.nodesWithCustomAttributes.Count; i < n; i++){          AttributeList attrs = null;          Node node = this.nodesWithCustomAttributes[i];          int codedIndex = 0;          switch(node.NodeType){            case NodeType.Method:            case NodeType.InstanceInitializer:            case NodeType.StaticInitializer:              Method m = (Method)node;              codedIndex = this.GetMethodIndex(m)<<5;               attrs = m.Attributes;              break;            case NodeType.Field:              Field f = (Field)node;              codedIndex = (this.GetFieldIndex(f)<<5)|1;              attrs = f.Attributes;              break;            case NodeType.Parameter:              Parameter par = (Parameter)node;              codedIndex = (this.GetParamIndex(par)<<5)|4;              attrs = par.Attributes;              break;            case NodeType.Class:            case NodeType.DelegateNode:            case NodeType.EnumNode:            case NodeType.Interface:            case NodeType.Struct:  #if !MinimalReader            case NodeType.TupleType:            case NodeType.TypeAlias:            case NodeType.TypeIntersection:            case NodeType.TypeUnion:  #endif              TypeNode t = (TypeNode)node;              if (this.IsStructural(t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))                codedIndex = (this.GetTypeSpecIndex(t)<<5)|13;              else                codedIndex = (this.GetTypeDefIndex(t)<<5)|3;              attrs = t.Attributes;              break;            case NodeType.ClassParameter:            case NodeType.TypeParameter:              if (!this.UseGenerics) goto case NodeType.Class;              t = (TypeNode)node;              codedIndex = (this.GetGenericParamIndex(t)<<5)|19;              attrs = t.Attributes;              break;            case NodeType.Property:              Property p = (Property)node;              codedIndex = (this.GetPropertyIndex(p)<<5)|9;              attrs = p.Attributes;              break;            case NodeType.Event:              Event e = (Event)node;              codedIndex = (this.GetEventIndex(e)<<5)|10;              attrs = e.Attributes;              break;            case NodeType.Module:            case NodeType.Assembly:              codedIndex =  (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);              attrs = ((Module)node).Attributes;              break;            default:              Debug.Assert(false);              break;          }          if (attrs == null) continue;          if (UseGenerics) {            Debug.Assert(codedIndex > prevCodedIndex);          }          prevCodedIndex = codedIndex;          for (int j = 0' m = attrs.Count; j < m; j++){            AttributeNode a = attrs[j];            if (a == null) continue;            table[k].Parent = codedIndex;            Debug.Assert(a.Constructor is MemberBinding);            Method cons = (Method)((MemberBinding)a.Constructor).BoundMember;            if (cons.DeclaringType.DeclaringModule == this.module && !this.IsStructural(cons.DeclaringType))              table[k].Constructor = (this.GetMethodIndex(cons) << 3) | 2;            else              table[k].Constructor = (this.GetMemberRefIndex(cons) << 3) | 3;            if (a.OriginalBlob != null)            {                table[k].Value = this.GetBlobIndex(a.OriginalBlob);            }            else            {                table[k].Value = this.GetBlobIndex(a.Expressions' cons.Parameters);            }            k++;          }        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: for (int i = 0' n = this.nodesWithCustomAttributes.Count; i < n; i++){          AttributeList attrs = null;          Node node = this.nodesWithCustomAttributes[i];          int codedIndex = 0;          switch(node.NodeType){            case NodeType.Method:            case NodeType.InstanceInitializer:            case NodeType.StaticInitializer:              Method m = (Method)node;              codedIndex = this.GetMethodIndex(m)<<5;               attrs = m.Attributes;              break;            case NodeType.Field:              Field f = (Field)node;              codedIndex = (this.GetFieldIndex(f)<<5)|1;              attrs = f.Attributes;              break;            case NodeType.Parameter:              Parameter par = (Parameter)node;              codedIndex = (this.GetParamIndex(par)<<5)|4;              attrs = par.Attributes;              break;            case NodeType.Class:            case NodeType.DelegateNode:            case NodeType.EnumNode:            case NodeType.Interface:            case NodeType.Struct:  #if !MinimalReader            case NodeType.TupleType:            case NodeType.TypeAlias:            case NodeType.TypeIntersection:            case NodeType.TypeUnion:  #endif              TypeNode t = (TypeNode)node;              if (this.IsStructural(t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))                codedIndex = (this.GetTypeSpecIndex(t)<<5)|13;              else                codedIndex = (this.GetTypeDefIndex(t)<<5)|3;              attrs = t.Attributes;              break;            case NodeType.ClassParameter:            case NodeType.TypeParameter:              if (!this.UseGenerics) goto case NodeType.Class;              t = (TypeNode)node;              codedIndex = (this.GetGenericParamIndex(t)<<5)|19;              attrs = t.Attributes;              break;            case NodeType.Property:              Property p = (Property)node;              codedIndex = (this.GetPropertyIndex(p)<<5)|9;              attrs = p.Attributes;              break;            case NodeType.Event:              Event e = (Event)node;              codedIndex = (this.GetEventIndex(e)<<5)|10;              attrs = e.Attributes;              break;            case NodeType.Module:            case NodeType.Assembly:              codedIndex =  (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);              attrs = ((Module)node).Attributes;              break;            default:              Debug.Assert(false);              break;          }          if (attrs == null) continue;          if (UseGenerics) {            Debug.Assert(codedIndex > prevCodedIndex);          }          prevCodedIndex = codedIndex;          for (int j = 0' m = attrs.Count; j < m; j++){            AttributeNode a = attrs[j];            if (a == null) continue;            table[k].Parent = codedIndex;            Debug.Assert(a.Constructor is MemberBinding);            Method cons = (Method)((MemberBinding)a.Constructor).BoundMember;            if (cons.DeclaringType.DeclaringModule == this.module && !this.IsStructural(cons.DeclaringType))              table[k].Constructor = (this.GetMethodIndex(cons) << 3) | 2;            else              table[k].Constructor = (this.GetMemberRefIndex(cons) << 3) | 3;            if (a.OriginalBlob != null)            {                table[k].Value = this.GetBlobIndex(a.OriginalBlob);            }            else            {                table[k].Value = this.GetBlobIndex(a.Expressions' cons.Parameters);            }            k++;          }        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateCustomAttributeTable,The following statement contains a magic number: for (int i = 0' n = this.nodesWithCustomAttributes.Count; i < n; i++){          AttributeList attrs = null;          Node node = this.nodesWithCustomAttributes[i];          int codedIndex = 0;          switch(node.NodeType){            case NodeType.Method:            case NodeType.InstanceInitializer:            case NodeType.StaticInitializer:              Method m = (Method)node;              codedIndex = this.GetMethodIndex(m)<<5;               attrs = m.Attributes;              break;            case NodeType.Field:              Field f = (Field)node;              codedIndex = (this.GetFieldIndex(f)<<5)|1;              attrs = f.Attributes;              break;            case NodeType.Parameter:              Parameter par = (Parameter)node;              codedIndex = (this.GetParamIndex(par)<<5)|4;              attrs = par.Attributes;              break;            case NodeType.Class:            case NodeType.DelegateNode:            case NodeType.EnumNode:            case NodeType.Interface:            case NodeType.Struct:  #if !MinimalReader            case NodeType.TupleType:            case NodeType.TypeAlias:            case NodeType.TypeIntersection:            case NodeType.TypeUnion:  #endif              TypeNode t = (TypeNode)node;              if (this.IsStructural(t) && (!t.IsGeneric || (t.Template != null && t.ConsolidatedTemplateArguments != null && t.ConsolidatedTemplateArguments.Count > 0)))                codedIndex = (this.GetTypeSpecIndex(t)<<5)|13;              else                codedIndex = (this.GetTypeDefIndex(t)<<5)|3;              attrs = t.Attributes;              break;            case NodeType.ClassParameter:            case NodeType.TypeParameter:              if (!this.UseGenerics) goto case NodeType.Class;              t = (TypeNode)node;              codedIndex = (this.GetGenericParamIndex(t)<<5)|19;              attrs = t.Attributes;              break;            case NodeType.Property:              Property p = (Property)node;              codedIndex = (this.GetPropertyIndex(p)<<5)|9;              attrs = p.Attributes;              break;            case NodeType.Event:              Event e = (Event)node;              codedIndex = (this.GetEventIndex(e)<<5)|10;              attrs = e.Attributes;              break;            case NodeType.Module:            case NodeType.Assembly:              codedIndex =  (1 << 5) | (node.NodeType == NodeType.Module ? 7 : 14);              attrs = ((Module)node).Attributes;              break;            default:              Debug.Assert(false);              break;          }          if (attrs == null) continue;          if (UseGenerics) {            Debug.Assert(codedIndex > prevCodedIndex);          }          prevCodedIndex = codedIndex;          for (int j = 0' m = attrs.Count; j < m; j++){            AttributeNode a = attrs[j];            if (a == null) continue;            table[k].Parent = codedIndex;            Debug.Assert(a.Constructor is MemberBinding);            Method cons = (Method)((MemberBinding)a.Constructor).BoundMember;            if (cons.DeclaringType.DeclaringModule == this.module && !this.IsStructural(cons.DeclaringType))              table[k].Constructor = (this.GetMethodIndex(cons) << 3) | 2;            else              table[k].Constructor = (this.GetMemberRefIndex(cons) << 3) | 3;            if (a.OriginalBlob != null)            {                table[k].Value = this.GetBlobIndex(a.OriginalBlob);            }            else            {                table[k].Value = this.GetBlobIndex(a.Expressions' cons.Parameters);            }            k++;          }        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateDeclSecurityTable,The following statement contains a magic number: for (int i = 0' n = this.nodesWithSecurityAttributes.Count; i < n; i++){          SecurityAttributeList attrs = null;          Node node = this.nodesWithSecurityAttributes[i];          int codedIndex = 0;          switch(node.NodeType){            case NodeType.Method:            case NodeType.InstanceInitializer:            case NodeType.StaticInitializer:              Method m = (Method)node;              codedIndex = (this.GetMethodIndex(m)<<2)|1;               attrs = m.SecurityAttributes;              break;            case NodeType.Class:            case NodeType.Interface:            case NodeType.DelegateNode:            case NodeType.EnumNode:            case NodeType.Struct:              TypeNode t = (TypeNode)node;              codedIndex = (this.GetTypeDefIndex(t)<<2)|0;              attrs = t.SecurityAttributes;              break;            case NodeType.Assembly:              codedIndex =  (1 << 2)|2;              attrs = ((AssemblyNode)node).SecurityAttributes;              break;            default:              Debug.Assert(false);              break;          }          if (attrs == null) continue;          Debug.Assert(codedIndex > prevCodedIndex);          prevCodedIndex = codedIndex;          for (int j = 0' m = attrs.Count; j < m; j++){            SecurityAttribute a = attrs[j];            if (a == null) continue;            this.VisitReferencedType(CoreSystemTypes.SecurityAction);            table[k].Action = (int)a.Action;            table[k].Parent = codedIndex;            if (CoreSystemTypes.SystemAssembly.MetadataFormatMajorVersion == 1 && CoreSystemTypes.SystemAssembly.MetadataFormatMinorVersion < 1)              table[k].PermissionSet = this.GetBlobIndex(a.SerializedPermissions);            else {              if (a.PermissionAttributes != null) {                table[k].PermissionSet = this.GetBlobIndex(a.PermissionAttributes);              } else {                // Came across some assemblies that had a metadata version > 1.0' but still used                // serialized security attributes. So might as well try to see if this is the case                // if the PermissionAttributes are null.                table[k].PermissionSet = this.GetBlobIndex(a.SerializedPermissions);              }            }            k++;          }        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateDeclSecurityTable,The following statement contains a magic number: for (int i = 0' n = this.nodesWithSecurityAttributes.Count; i < n; i++){          SecurityAttributeList attrs = null;          Node node = this.nodesWithSecurityAttributes[i];          int codedIndex = 0;          switch(node.NodeType){            case NodeType.Method:            case NodeType.InstanceInitializer:            case NodeType.StaticInitializer:              Method m = (Method)node;              codedIndex = (this.GetMethodIndex(m)<<2)|1;               attrs = m.SecurityAttributes;              break;            case NodeType.Class:            case NodeType.Interface:            case NodeType.DelegateNode:            case NodeType.EnumNode:            case NodeType.Struct:              TypeNode t = (TypeNode)node;              codedIndex = (this.GetTypeDefIndex(t)<<2)|0;              attrs = t.SecurityAttributes;              break;            case NodeType.Assembly:              codedIndex =  (1 << 2)|2;              attrs = ((AssemblyNode)node).SecurityAttributes;              break;            default:              Debug.Assert(false);              break;          }          if (attrs == null) continue;          Debug.Assert(codedIndex > prevCodedIndex);          prevCodedIndex = codedIndex;          for (int j = 0' m = attrs.Count; j < m; j++){            SecurityAttribute a = attrs[j];            if (a == null) continue;            this.VisitReferencedType(CoreSystemTypes.SecurityAction);            table[k].Action = (int)a.Action;            table[k].Parent = codedIndex;            if (CoreSystemTypes.SystemAssembly.MetadataFormatMajorVersion == 1 && CoreSystemTypes.SystemAssembly.MetadataFormatMinorVersion < 1)              table[k].PermissionSet = this.GetBlobIndex(a.SerializedPermissions);            else {              if (a.PermissionAttributes != null) {                table[k].PermissionSet = this.GetBlobIndex(a.PermissionAttributes);              } else {                // Came across some assemblies that had a metadata version > 1.0' but still used                // serialized security attributes. So might as well try to see if this is the case                // if the PermissionAttributes are null.                table[k].PermissionSet = this.GetBlobIndex(a.SerializedPermissions);              }            }            k++;          }        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateDeclSecurityTable,The following statement contains a magic number: for (int i = 0' n = this.nodesWithSecurityAttributes.Count; i < n; i++){          SecurityAttributeList attrs = null;          Node node = this.nodesWithSecurityAttributes[i];          int codedIndex = 0;          switch(node.NodeType){            case NodeType.Method:            case NodeType.InstanceInitializer:            case NodeType.StaticInitializer:              Method m = (Method)node;              codedIndex = (this.GetMethodIndex(m)<<2)|1;               attrs = m.SecurityAttributes;              break;            case NodeType.Class:            case NodeType.Interface:            case NodeType.DelegateNode:            case NodeType.EnumNode:            case NodeType.Struct:              TypeNode t = (TypeNode)node;              codedIndex = (this.GetTypeDefIndex(t)<<2)|0;              attrs = t.SecurityAttributes;              break;            case NodeType.Assembly:              codedIndex =  (1 << 2)|2;              attrs = ((AssemblyNode)node).SecurityAttributes;              break;            default:              Debug.Assert(false);              break;          }          if (attrs == null) continue;          Debug.Assert(codedIndex > prevCodedIndex);          prevCodedIndex = codedIndex;          for (int j = 0' m = attrs.Count; j < m; j++){            SecurityAttribute a = attrs[j];            if (a == null) continue;            this.VisitReferencedType(CoreSystemTypes.SecurityAction);            table[k].Action = (int)a.Action;            table[k].Parent = codedIndex;            if (CoreSystemTypes.SystemAssembly.MetadataFormatMajorVersion == 1 && CoreSystemTypes.SystemAssembly.MetadataFormatMinorVersion < 1)              table[k].PermissionSet = this.GetBlobIndex(a.SerializedPermissions);            else {              if (a.PermissionAttributes != null) {                table[k].PermissionSet = this.GetBlobIndex(a.PermissionAttributes);              } else {                // Came across some assemblies that had a metadata version > 1.0' but still used                // serialized security attributes. So might as well try to see if this is the case                // if the PermissionAttributes are null.                table[k].PermissionSet = this.GetBlobIndex(a.SerializedPermissions);              }            }            k++;          }        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateDeclSecurityTable,The following statement contains a magic number: for (int i = 0' n = this.nodesWithSecurityAttributes.Count; i < n; i++){          SecurityAttributeList attrs = null;          Node node = this.nodesWithSecurityAttributes[i];          int codedIndex = 0;          switch(node.NodeType){            case NodeType.Method:            case NodeType.InstanceInitializer:            case NodeType.StaticInitializer:              Method m = (Method)node;              codedIndex = (this.GetMethodIndex(m)<<2)|1;               attrs = m.SecurityAttributes;              break;            case NodeType.Class:            case NodeType.Interface:            case NodeType.DelegateNode:            case NodeType.EnumNode:            case NodeType.Struct:              TypeNode t = (TypeNode)node;              codedIndex = (this.GetTypeDefIndex(t)<<2)|0;              attrs = t.SecurityAttributes;              break;            case NodeType.Assembly:              codedIndex =  (1 << 2)|2;              attrs = ((AssemblyNode)node).SecurityAttributes;              break;            default:              Debug.Assert(false);              break;          }          if (attrs == null) continue;          Debug.Assert(codedIndex > prevCodedIndex);          prevCodedIndex = codedIndex;          for (int j = 0' m = attrs.Count; j < m; j++){            SecurityAttribute a = attrs[j];            if (a == null) continue;            this.VisitReferencedType(CoreSystemTypes.SecurityAction);            table[k].Action = (int)a.Action;            table[k].Parent = codedIndex;            if (CoreSystemTypes.SystemAssembly.MetadataFormatMajorVersion == 1 && CoreSystemTypes.SystemAssembly.MetadataFormatMinorVersion < 1)              table[k].PermissionSet = this.GetBlobIndex(a.SerializedPermissions);            else {              if (a.PermissionAttributes != null) {                table[k].PermissionSet = this.GetBlobIndex(a.PermissionAttributes);              } else {                // Came across some assemblies that had a metadata version > 1.0' but still used                // serialized security attributes. So might as well try to see if this is the case                // if the PermissionAttributes are null.                table[k].PermissionSet = this.GetBlobIndex(a.SerializedPermissions);              }            }            k++;          }        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateExportedTypeTable,The following statement contains a magic number: for (int i = 0; i < n; i++){          TypeNode et = exportedTypes[i];          if (et == null || et.Namespace == null || et.Name == null) continue;          ett[i].TypeDefId = 0;          ett[i].TypeNamespace = this.GetStringIndex(et.Namespace.ToString());          ett[i].TypeName = this.GetStringIndex(et.Name.ToString());          ett[i].Flags = (int)(et.Flags & TypeFlags.VisibilityMask);          if (et.DeclaringType != null){            for (int j = 0; j < i; j++){              if (exportedTypes[j] == et.DeclaringType){                ett[i].Implementation = (j << 2) | 2;                break;              }            }          } else if (et.DeclaringModule != this.module && et.DeclaringModule is AssemblyNode) {            ett[i].Implementation = (this.GetAssemblyRefIndex((AssemblyNode)et.DeclaringModule) << 2) | 1;            ett[i].Flags = (int)TypeFlags.Forwarder;          } else            ett[i].Implementation = (this.GetFileTableIndex(et.DeclaringModule) << 2) | 0;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateExportedTypeTable,The following statement contains a magic number: for (int i = 0; i < n; i++){          TypeNode et = exportedTypes[i];          if (et == null || et.Namespace == null || et.Name == null) continue;          ett[i].TypeDefId = 0;          ett[i].TypeNamespace = this.GetStringIndex(et.Namespace.ToString());          ett[i].TypeName = this.GetStringIndex(et.Name.ToString());          ett[i].Flags = (int)(et.Flags & TypeFlags.VisibilityMask);          if (et.DeclaringType != null){            for (int j = 0; j < i; j++){              if (exportedTypes[j] == et.DeclaringType){                ett[i].Implementation = (j << 2) | 2;                break;              }            }          } else if (et.DeclaringModule != this.module && et.DeclaringModule is AssemblyNode) {            ett[i].Implementation = (this.GetAssemblyRefIndex((AssemblyNode)et.DeclaringModule) << 2) | 1;            ett[i].Flags = (int)TypeFlags.Forwarder;          } else            ett[i].Implementation = (this.GetFileTableIndex(et.DeclaringModule) << 2) | 0;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateExportedTypeTable,The following statement contains a magic number: for (int i = 0; i < n; i++){          TypeNode et = exportedTypes[i];          if (et == null || et.Namespace == null || et.Name == null) continue;          ett[i].TypeDefId = 0;          ett[i].TypeNamespace = this.GetStringIndex(et.Namespace.ToString());          ett[i].TypeName = this.GetStringIndex(et.Name.ToString());          ett[i].Flags = (int)(et.Flags & TypeFlags.VisibilityMask);          if (et.DeclaringType != null){            for (int j = 0; j < i; j++){              if (exportedTypes[j] == et.DeclaringType){                ett[i].Implementation = (j << 2) | 2;                break;              }            }          } else if (et.DeclaringModule != this.module && et.DeclaringModule is AssemblyNode) {            ett[i].Implementation = (this.GetAssemblyRefIndex((AssemblyNode)et.DeclaringModule) << 2) | 1;            ett[i].Flags = (int)TypeFlags.Forwarder;          } else            ett[i].Implementation = (this.GetFileTableIndex(et.DeclaringModule) << 2) | 0;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateExportedTypeTable,The following statement contains a magic number: for (int i = 0; i < n; i++){          TypeNode et = exportedTypes[i];          if (et == null || et.Namespace == null || et.Name == null) continue;          ett[i].TypeDefId = 0;          ett[i].TypeNamespace = this.GetStringIndex(et.Namespace.ToString());          ett[i].TypeName = this.GetStringIndex(et.Name.ToString());          ett[i].Flags = (int)(et.Flags & TypeFlags.VisibilityMask);          if (et.DeclaringType != null){            for (int j = 0; j < i; j++){              if (exportedTypes[j] == et.DeclaringType){                ett[i].Implementation = (j << 2) | 2;                break;              }            }          } else if (et.DeclaringModule != this.module && et.DeclaringModule is AssemblyNode) {            ett[i].Implementation = (this.GetAssemblyRefIndex((AssemblyNode)et.DeclaringModule) << 2) | 1;            ett[i].Flags = (int)TypeFlags.Forwarder;          } else            ett[i].Implementation = (this.GetFileTableIndex(et.DeclaringModule) << 2) | 0;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateManifestResourceTable,The following statement contains a magic number: for (int i = 0; i < n; i++){          Resource r = resources[i];          mresources[i].Flags = r.IsPublic ? 1 : 2;          mresources[i].Name = this.GetStringIndex(r.Name);          if (r.Data != null)            mresources[i].Offset = this.GetResourceDataIndex(r.Data);          else if (r.DefiningModule is AssemblyNode)            mresources[i].Implementation = (this.GetAssemblyRefIndex((AssemblyNode)r.DefiningModule)<<2)|1;          else            mresources[i].Implementation = (this.GetFileTableIndex(r.DefiningModule)<<2)|0;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateManifestResourceTable,The following statement contains a magic number: for (int i = 0; i < n; i++){          Resource r = resources[i];          mresources[i].Flags = r.IsPublic ? 1 : 2;          mresources[i].Name = this.GetStringIndex(r.Name);          if (r.Data != null)            mresources[i].Offset = this.GetResourceDataIndex(r.Data);          else if (r.DefiningModule is AssemblyNode)            mresources[i].Implementation = (this.GetAssemblyRefIndex((AssemblyNode)r.DefiningModule)<<2)|1;          else            mresources[i].Implementation = (this.GetFileTableIndex(r.DefiningModule)<<2)|0;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateManifestResourceTable,The following statement contains a magic number: for (int i = 0; i < n; i++){          Resource r = resources[i];          mresources[i].Flags = r.IsPublic ? 1 : 2;          mresources[i].Name = this.GetStringIndex(r.Name);          if (r.Data != null)            mresources[i].Offset = this.GetResourceDataIndex(r.Data);          else if (r.DefiningModule is AssemblyNode)            mresources[i].Implementation = (this.GetAssemblyRefIndex((AssemblyNode)r.DefiningModule)<<2)|1;          else            mresources[i].Implementation = (this.GetFileTableIndex(r.DefiningModule)<<2)|0;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateMemberRefTable,The following statement contains a magic number: for (int i = 0; i < n; i++){          Member member = this.memberRefEntries[i];          if (member == null || member.Name == null) continue;          mr[i].Name = this.GetStringIndex(member.Name.ToString());          Field f = member as Field;          if (f != null)            mr[i].Signature = this.GetBlobIndex(f);          else{            FunctionPointer fp = member as FunctionPointer;            if (fp != null){              mr[i].Signature = this.GetBlobIndex(fp);              if (fp is VarargMethodCallSignature){                Method m = ((VarargMethodCallSignature)member).method;                if (m != null && m.DeclaringType.DeclaringModule == this.module && !this.IsStructural(m.DeclaringType)){                  mr[i].Class = (this.GetMethodIndex(m) << 3) | 3;                  continue;                }              }            }else{              Method m = (Method)member;              if (m.IsGeneric && m.Template != null) m = this.GetUnspecializedMethod(m);              mr[i].Signature = this.GetBlobIndex(m' false);              if (m.DeclaringType.DeclaringModule == this.module && !this.IsStructural(m.DeclaringType) && !m.IsGeneric){                mr[i].Class = (this.GetMethodIndex(m) << 3) | 3;                continue;              }              //TODO: if the declaring type is the special global members type of another module' set class to a module ref            }          }          int j = mr[i].Class = this.GetMemberRefParentEncoded(member.DeclaringType);          if ((j & 0x3) == 2) mr[i].Class = (j & ~0x3) | 4;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateMemberRefTable,The following statement contains a magic number: for (int i = 0; i < n; i++){          Member member = this.memberRefEntries[i];          if (member == null || member.Name == null) continue;          mr[i].Name = this.GetStringIndex(member.Name.ToString());          Field f = member as Field;          if (f != null)            mr[i].Signature = this.GetBlobIndex(f);          else{            FunctionPointer fp = member as FunctionPointer;            if (fp != null){              mr[i].Signature = this.GetBlobIndex(fp);              if (fp is VarargMethodCallSignature){                Method m = ((VarargMethodCallSignature)member).method;                if (m != null && m.DeclaringType.DeclaringModule == this.module && !this.IsStructural(m.DeclaringType)){                  mr[i].Class = (this.GetMethodIndex(m) << 3) | 3;                  continue;                }              }            }else{              Method m = (Method)member;              if (m.IsGeneric && m.Template != null) m = this.GetUnspecializedMethod(m);              mr[i].Signature = this.GetBlobIndex(m' false);              if (m.DeclaringType.DeclaringModule == this.module && !this.IsStructural(m.DeclaringType) && !m.IsGeneric){                mr[i].Class = (this.GetMethodIndex(m) << 3) | 3;                continue;              }              //TODO: if the declaring type is the special global members type of another module' set class to a module ref            }          }          int j = mr[i].Class = this.GetMemberRefParentEncoded(member.DeclaringType);          if ((j & 0x3) == 2) mr[i].Class = (j & ~0x3) | 4;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateMemberRefTable,The following statement contains a magic number: for (int i = 0; i < n; i++){          Member member = this.memberRefEntries[i];          if (member == null || member.Name == null) continue;          mr[i].Name = this.GetStringIndex(member.Name.ToString());          Field f = member as Field;          if (f != null)            mr[i].Signature = this.GetBlobIndex(f);          else{            FunctionPointer fp = member as FunctionPointer;            if (fp != null){              mr[i].Signature = this.GetBlobIndex(fp);              if (fp is VarargMethodCallSignature){                Method m = ((VarargMethodCallSignature)member).method;                if (m != null && m.DeclaringType.DeclaringModule == this.module && !this.IsStructural(m.DeclaringType)){                  mr[i].Class = (this.GetMethodIndex(m) << 3) | 3;                  continue;                }              }            }else{              Method m = (Method)member;              if (m.IsGeneric && m.Template != null) m = this.GetUnspecializedMethod(m);              mr[i].Signature = this.GetBlobIndex(m' false);              if (m.DeclaringType.DeclaringModule == this.module && !this.IsStructural(m.DeclaringType) && !m.IsGeneric){                mr[i].Class = (this.GetMethodIndex(m) << 3) | 3;                continue;              }              //TODO: if the declaring type is the special global members type of another module' set class to a module ref            }          }          int j = mr[i].Class = this.GetMemberRefParentEncoded(member.DeclaringType);          if ((j & 0x3) == 2) mr[i].Class = (j & ~0x3) | 4;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateMemberRefTable,The following statement contains a magic number: for (int i = 0; i < n; i++){          Member member = this.memberRefEntries[i];          if (member == null || member.Name == null) continue;          mr[i].Name = this.GetStringIndex(member.Name.ToString());          Field f = member as Field;          if (f != null)            mr[i].Signature = this.GetBlobIndex(f);          else{            FunctionPointer fp = member as FunctionPointer;            if (fp != null){              mr[i].Signature = this.GetBlobIndex(fp);              if (fp is VarargMethodCallSignature){                Method m = ((VarargMethodCallSignature)member).method;                if (m != null && m.DeclaringType.DeclaringModule == this.module && !this.IsStructural(m.DeclaringType)){                  mr[i].Class = (this.GetMethodIndex(m) << 3) | 3;                  continue;                }              }            }else{              Method m = (Method)member;              if (m.IsGeneric && m.Template != null) m = this.GetUnspecializedMethod(m);              mr[i].Signature = this.GetBlobIndex(m' false);              if (m.DeclaringType.DeclaringModule == this.module && !this.IsStructural(m.DeclaringType) && !m.IsGeneric){                mr[i].Class = (this.GetMethodIndex(m) << 3) | 3;                continue;              }              //TODO: if the declaring type is the special global members type of another module' set class to a module ref            }          }          int j = mr[i].Class = this.GetMemberRefParentEncoded(member.DeclaringType);          if ((j & 0x3) == 2) mr[i].Class = (j & ~0x3) | 4;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateMemberRefTable,The following statement contains a magic number: for (int i = 0; i < n; i++){          Member member = this.memberRefEntries[i];          if (member == null || member.Name == null) continue;          mr[i].Name = this.GetStringIndex(member.Name.ToString());          Field f = member as Field;          if (f != null)            mr[i].Signature = this.GetBlobIndex(f);          else{            FunctionPointer fp = member as FunctionPointer;            if (fp != null){              mr[i].Signature = this.GetBlobIndex(fp);              if (fp is VarargMethodCallSignature){                Method m = ((VarargMethodCallSignature)member).method;                if (m != null && m.DeclaringType.DeclaringModule == this.module && !this.IsStructural(m.DeclaringType)){                  mr[i].Class = (this.GetMethodIndex(m) << 3) | 3;                  continue;                }              }            }else{              Method m = (Method)member;              if (m.IsGeneric && m.Template != null) m = this.GetUnspecializedMethod(m);              mr[i].Signature = this.GetBlobIndex(m' false);              if (m.DeclaringType.DeclaringModule == this.module && !this.IsStructural(m.DeclaringType) && !m.IsGeneric){                mr[i].Class = (this.GetMethodIndex(m) << 3) | 3;                continue;              }              //TODO: if the declaring type is the special global members type of another module' set class to a module ref            }          }          int j = mr[i].Class = this.GetMemberRefParentEncoded(member.DeclaringType);          if ((j & 0x3) == 2) mr[i].Class = (j & ~0x3) | 4;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateMemberRefTable,The following statement contains a magic number: for (int i = 0; i < n; i++){          Member member = this.memberRefEntries[i];          if (member == null || member.Name == null) continue;          mr[i].Name = this.GetStringIndex(member.Name.ToString());          Field f = member as Field;          if (f != null)            mr[i].Signature = this.GetBlobIndex(f);          else{            FunctionPointer fp = member as FunctionPointer;            if (fp != null){              mr[i].Signature = this.GetBlobIndex(fp);              if (fp is VarargMethodCallSignature){                Method m = ((VarargMethodCallSignature)member).method;                if (m != null && m.DeclaringType.DeclaringModule == this.module && !this.IsStructural(m.DeclaringType)){                  mr[i].Class = (this.GetMethodIndex(m) << 3) | 3;                  continue;                }              }            }else{              Method m = (Method)member;              if (m.IsGeneric && m.Template != null) m = this.GetUnspecializedMethod(m);              mr[i].Signature = this.GetBlobIndex(m' false);              if (m.DeclaringType.DeclaringModule == this.module && !this.IsStructural(m.DeclaringType) && !m.IsGeneric){                mr[i].Class = (this.GetMethodIndex(m) << 3) | 3;                continue;              }              //TODO: if the declaring type is the special global members type of another module' set class to a module ref            }          }          int j = mr[i].Class = this.GetMemberRefParentEncoded(member.DeclaringType);          if ((j & 0x3) == 2) mr[i].Class = (j & ~0x3) | 4;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateMethodSemanticsTable,The following statement contains a magic number: for (int i = 0; i < n; i++){          Member owner = this.methodSemanticsEntries[i];          Property ownerProperty = owner as Property;          if (ownerProperty != null){            msr[i].Association = (this.GetPropertyIndex(ownerProperty) << 1)|1;            if (owner != previousOwner){              previousOwner = owner;              index = -1;              if (ownerProperty.Getter != null) {                msr[i].Method = this.GetMethodIndex(ownerProperty.Getter);                msr[i].Semantics = 0x0002;                continue;              }            }            if (index == -1){              index = 0;              if (ownerProperty.Setter != null) {                msr[i].Method = this.GetMethodIndex(ownerProperty.Setter);                msr[i].Semantics = 0x0001;                continue;              }            }            msr[i].Method = this.GetMethodIndex(ownerProperty.OtherMethods[index]);            msr[i].Semantics = 0x0004;            index++;            continue;          }          Event ownerEvent = owner as Event;          if (ownerEvent == null) { Debug.Fail(""); continue; }          msr[i].Association = this.GetEventIndex(ownerEvent)<<1;          if (owner != previousOwner){            previousOwner = owner;            index = -2;            if (ownerEvent.HandlerAdder != null){              msr[i].Method = this.GetMethodIndex(ownerEvent.HandlerAdder);              msr[i].Semantics = 0x0008;              continue;            }          }          if (index == -2){            index = -1;            if (ownerEvent.HandlerRemover != null){              msr[i].Method = this.GetMethodIndex(ownerEvent.HandlerRemover);              msr[i].Semantics = 0x0010;              continue;            }          }          if (index == -1){            index = 0;            if (ownerEvent.HandlerCaller != null){              msr[i].Method = this.GetMethodIndex(ownerEvent.HandlerCaller);              msr[i].Semantics = 0x0020;              continue;            }          }          msr[i].Method = this.GetMethodIndex(ownerEvent.OtherMethods[i]);          msr[i].Semantics = 0x0004;          index++;          continue;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateMethodSemanticsTable,The following statement contains a magic number: for (int i = 0; i < n; i++){          Member owner = this.methodSemanticsEntries[i];          Property ownerProperty = owner as Property;          if (ownerProperty != null){            msr[i].Association = (this.GetPropertyIndex(ownerProperty) << 1)|1;            if (owner != previousOwner){              previousOwner = owner;              index = -1;              if (ownerProperty.Getter != null) {                msr[i].Method = this.GetMethodIndex(ownerProperty.Getter);                msr[i].Semantics = 0x0002;                continue;              }            }            if (index == -1){              index = 0;              if (ownerProperty.Setter != null) {                msr[i].Method = this.GetMethodIndex(ownerProperty.Setter);                msr[i].Semantics = 0x0001;                continue;              }            }            msr[i].Method = this.GetMethodIndex(ownerProperty.OtherMethods[index]);            msr[i].Semantics = 0x0004;            index++;            continue;          }          Event ownerEvent = owner as Event;          if (ownerEvent == null) { Debug.Fail(""); continue; }          msr[i].Association = this.GetEventIndex(ownerEvent)<<1;          if (owner != previousOwner){            previousOwner = owner;            index = -2;            if (ownerEvent.HandlerAdder != null){              msr[i].Method = this.GetMethodIndex(ownerEvent.HandlerAdder);              msr[i].Semantics = 0x0008;              continue;            }          }          if (index == -2){            index = -1;            if (ownerEvent.HandlerRemover != null){              msr[i].Method = this.GetMethodIndex(ownerEvent.HandlerRemover);              msr[i].Semantics = 0x0010;              continue;            }          }          if (index == -1){            index = 0;            if (ownerEvent.HandlerCaller != null){              msr[i].Method = this.GetMethodIndex(ownerEvent.HandlerCaller);              msr[i].Semantics = 0x0020;              continue;            }          }          msr[i].Method = this.GetMethodIndex(ownerEvent.OtherMethods[i]);          msr[i].Semantics = 0x0004;          index++;          continue;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateTypeRefTable,The following statement contains a magic number: for (int i = 0; i < n; i++){          TypeNode t = this.typeRefEntries[i];          if (t == null || t.Name == null || t.Namespace == null) continue;          trr[i].Name = this.GetStringIndex(t.Name.ToString());          trr[i].Namespace = this.GetStringIndex(t.Namespace.ToString());          if (t.DeclaringType == null)            if (t.DeclaringModule is AssemblyNode)              trr[i].ResolutionScope = (this.GetAssemblyRefIndex((AssemblyNode)t.DeclaringModule) << 2) | 2;            else              trr[i].ResolutionScope = (this.GetModuleRefIndex(t.DeclaringModule) << 2) | 1;          else            trr[i].ResolutionScope = (this.GetTypeRefIndex(t.DeclaringType) << 2) | 3;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateTypeRefTable,The following statement contains a magic number: for (int i = 0; i < n; i++){          TypeNode t = this.typeRefEntries[i];          if (t == null || t.Name == null || t.Namespace == null) continue;          trr[i].Name = this.GetStringIndex(t.Name.ToString());          trr[i].Namespace = this.GetStringIndex(t.Namespace.ToString());          if (t.DeclaringType == null)            if (t.DeclaringModule is AssemblyNode)              trr[i].ResolutionScope = (this.GetAssemblyRefIndex((AssemblyNode)t.DeclaringModule) << 2) | 2;            else              trr[i].ResolutionScope = (this.GetModuleRefIndex(t.DeclaringModule) << 2) | 1;          else            trr[i].ResolutionScope = (this.GetTypeRefIndex(t.DeclaringType) << 2) | 3;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateTypeRefTable,The following statement contains a magic number: for (int i = 0; i < n; i++){          TypeNode t = this.typeRefEntries[i];          if (t == null || t.Name == null || t.Namespace == null) continue;          trr[i].Name = this.GetStringIndex(t.Name.ToString());          trr[i].Namespace = this.GetStringIndex(t.Namespace.ToString());          if (t.DeclaringType == null)            if (t.DeclaringModule is AssemblyNode)              trr[i].ResolutionScope = (this.GetAssemblyRefIndex((AssemblyNode)t.DeclaringModule) << 2) | 2;            else              trr[i].ResolutionScope = (this.GetModuleRefIndex(t.DeclaringModule) << 2) | 1;          else            trr[i].ResolutionScope = (this.GetTypeRefIndex(t.DeclaringType) << 2) | 3;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateTypeRefTable,The following statement contains a magic number: for (int i = 0; i < n; i++){          TypeNode t = this.typeRefEntries[i];          if (t == null || t.Name == null || t.Namespace == null) continue;          trr[i].Name = this.GetStringIndex(t.Name.ToString());          trr[i].Namespace = this.GetStringIndex(t.Namespace.ToString());          if (t.DeclaringType == null)            if (t.DeclaringModule is AssemblyNode)              trr[i].ResolutionScope = (this.GetAssemblyRefIndex((AssemblyNode)t.DeclaringModule) << 2) | 2;            else              trr[i].ResolutionScope = (this.GetModuleRefIndex(t.DeclaringModule) << 2) | 1;          else            trr[i].ResolutionScope = (this.GetTypeRefIndex(t.DeclaringType) << 2) | 3;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateTypeRefTable,The following statement contains a magic number: for (int i = 0; i < n; i++){          TypeNode t = this.typeRefEntries[i];          if (t == null || t.Name == null || t.Namespace == null) continue;          trr[i].Name = this.GetStringIndex(t.Name.ToString());          trr[i].Namespace = this.GetStringIndex(t.Namespace.ToString());          if (t.DeclaringType == null)            if (t.DeclaringModule is AssemblyNode)              trr[i].ResolutionScope = (this.GetAssemblyRefIndex((AssemblyNode)t.DeclaringModule) << 2) | 2;            else              trr[i].ResolutionScope = (this.GetModuleRefIndex(t.DeclaringModule) << 2) | 1;          else            trr[i].ResolutionScope = (this.GetTypeRefIndex(t.DeclaringType) << 2) | 3;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitAddressOf,The following statement contains a magic number: switch (operand.NodeType){          case NodeType.Indexer:            Indexer indexer = (Indexer)operand;            this.Visit(indexer.Object);            if (indexer.Operands == null || indexer.Operands.Count < 1) return;            this.Visit(indexer.Operands[0]);            if (expr.NodeType == NodeType.ReadOnlyAddressOf){              this.methodBodyHeap.Write((byte)0xfe);              this.methodBodyHeap.Write((byte)0x1e);            }            this.methodBodyHeap.Write((byte)0x8f);            this.methodBodyHeap.Write((int)this.GetTypeToken(indexer.ElementType));            this.stackHeight--;            return;          case NodeType.Local:             int li = this.GetLocalVarIndex((Local)operand);            if (li < 256){              this.methodBodyHeap.Write((byte)0x12);              this.methodBodyHeap.Write((byte)li);            }else{              this.methodBodyHeap.Write((byte)0xfe);              this.methodBodyHeap.Write((byte)0x0d);              this.methodBodyHeap.Write((ushort)li);            }            this.IncrementStackHeight();            return;          case NodeType.MemberBinding:            MemberBinding mb = (MemberBinding)operand;            if (mb.TargetObject != null){              this.Visit(mb.TargetObject);              this.methodBodyHeap.Write((byte)0x7c);            }else{              this.methodBodyHeap.Write((byte)0x7f);              this.IncrementStackHeight();            }            this.methodBodyHeap.Write((int)this.GetFieldToken((Field)mb.BoundMember));            return;          case NodeType.Parameter:   #if !MinimalReader            ParameterBinding pb = operand as ParameterBinding;            if (pb != null) operand = pb.BoundParameter;  #endif            int pi = ((Parameter)operand).ArgumentListIndex;            if (pi < 256){              this.methodBodyHeap.Write((byte)0x0f);              this.methodBodyHeap.Write((byte)pi);            }else{              this.methodBodyHeap.Write((byte)0xfe);              this.methodBodyHeap.Write((byte)0x0a);              this.methodBodyHeap.Write((ushort)pi);            }            this.IncrementStackHeight();            return;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitAddressOf,The following statement contains a magic number: switch (operand.NodeType){          case NodeType.Indexer:            Indexer indexer = (Indexer)operand;            this.Visit(indexer.Object);            if (indexer.Operands == null || indexer.Operands.Count < 1) return;            this.Visit(indexer.Operands[0]);            if (expr.NodeType == NodeType.ReadOnlyAddressOf){              this.methodBodyHeap.Write((byte)0xfe);              this.methodBodyHeap.Write((byte)0x1e);            }            this.methodBodyHeap.Write((byte)0x8f);            this.methodBodyHeap.Write((int)this.GetTypeToken(indexer.ElementType));            this.stackHeight--;            return;          case NodeType.Local:             int li = this.GetLocalVarIndex((Local)operand);            if (li < 256){              this.methodBodyHeap.Write((byte)0x12);              this.methodBodyHeap.Write((byte)li);            }else{              this.methodBodyHeap.Write((byte)0xfe);              this.methodBodyHeap.Write((byte)0x0d);              this.methodBodyHeap.Write((ushort)li);            }            this.IncrementStackHeight();            return;          case NodeType.MemberBinding:            MemberBinding mb = (MemberBinding)operand;            if (mb.TargetObject != null){              this.Visit(mb.TargetObject);              this.methodBodyHeap.Write((byte)0x7c);            }else{              this.methodBodyHeap.Write((byte)0x7f);              this.IncrementStackHeight();            }            this.methodBodyHeap.Write((int)this.GetFieldToken((Field)mb.BoundMember));            return;          case NodeType.Parameter:   #if !MinimalReader            ParameterBinding pb = operand as ParameterBinding;            if (pb != null) operand = pb.BoundParameter;  #endif            int pi = ((Parameter)operand).ArgumentListIndex;            if (pi < 256){              this.methodBodyHeap.Write((byte)0x0f);              this.methodBodyHeap.Write((byte)pi);            }else{              this.methodBodyHeap.Write((byte)0xfe);              this.methodBodyHeap.Write((byte)0x0a);              this.methodBodyHeap.Write((ushort)pi);            }            this.IncrementStackHeight();            return;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitAssignmentStatement,The following statement contains a magic number: switch(assignment.Target.NodeType){          case NodeType.Local:            Local loc = (Local)target;            this.Visit(assignment.Source);            this.stackHeight--;            int li = this.GetLocalVarIndex(loc);            switch(li){              case 0: this.methodBodyHeap.Write((byte)0x0a); return;              case 1: this.methodBodyHeap.Write((byte)0x0b); return;              case 2: this.methodBodyHeap.Write((byte)0x0c); return;              case 3: this.methodBodyHeap.Write((byte)0x0d); return;              default:                if (li < 256){                  this.methodBodyHeap.Write((byte)0x13);                  this.methodBodyHeap.Write((byte)li);                }else{                  this.methodBodyHeap.Write((byte)0xfe);                  this.methodBodyHeap.Write((byte)0x0e);                  this.methodBodyHeap.Write((ushort)li);                }                return;            }          case NodeType.MemberBinding:            MemberBinding mb = (MemberBinding)target;            if (mb.TargetObject != null) this.Visit(mb.TargetObject);            this.Visit(assignment.Source);            if (mb.TargetObject != null) {              if (mb.Alignment != -1) {                this.methodBodyHeap.Write((byte)0xfe);                this.methodBodyHeap.Write((byte)0x12);                this.methodBodyHeap.Write((byte)mb.Alignment);              }              if (mb.Volatile) {                this.methodBodyHeap.Write((byte)0xfe);                this.methodBodyHeap.Write((byte)0x13);              }              this.methodBodyHeap.Write((byte)0x7d);            } else {              if (mb.Volatile) {                this.methodBodyHeap.Write((byte)0xfe);                this.methodBodyHeap.Write((byte)0x13);              }              this.methodBodyHeap.Write((byte)0x80);            }            this.methodBodyHeap.Write((int)this.GetFieldToken((Field)mb.BoundMember));            if (mb.TargetObject != null)              this.stackHeight -= 2;            else              this.stackHeight--;            return;          case NodeType.This:            this.Visit(assignment.Source);            this.methodBodyHeap.Write((byte)0x10);            this.methodBodyHeap.Write((byte)0x00);            this.stackHeight--;            return;          case NodeType.Parameter:  #if !MinimalReader            ParameterBinding pb = target as ParameterBinding;            if (pb != null) target = pb.BoundParameter;  #endif            Parameter par = (Parameter)target;            this.Visit(assignment.Source);            int pi = par.ArgumentListIndex;            if (pi < 256){              this.methodBodyHeap.Write((byte)0x10);              this.methodBodyHeap.Write((byte)pi);            }else{              this.methodBodyHeap.Write((byte)0xfe);              this.methodBodyHeap.Write((byte)0x0b);              this.methodBodyHeap.Write((ushort)pi);            }            this.stackHeight--;            return;          case NodeType.Indexer:            Indexer indexer = (Indexer)target;            this.Visit(indexer.Object);            if (indexer.Operands == null || indexer.Operands.Count < 1) return;            this.Visit(indexer.Operands[0]);            this.Visit(assignment.Source);            byte opCode;            switch(indexer.ElementType.typeCode){              case ElementType.UIntPtr:              case ElementType.IntPtr: opCode = 0x9b; break;              case ElementType.Boolean:              case ElementType.Int8:                 case ElementType.UInt8:  opCode = 0x9c; break;              case ElementType.Char:              case ElementType.Int16:                case ElementType.UInt16: opCode = 0x9d; break;              case ElementType.Int32:                case ElementType.UInt32: opCode = 0x9e; break;              case ElementType.Int64:                case ElementType.UInt64: opCode = 0x9f; break;              case ElementType.Single: opCode = 0xa0; break;              case ElementType.Double: opCode = 0xa1; break;              default:                 if (this.UseGenerics && (indexer.ElementType is ITypeParameter))                  opCode = 0xa4;                else if (TypeNode.StripModifiers(indexer.ElementType) is Pointer)                  opCode = 0x9b;                else                  opCode = 0xa2;                 break;            }            this.methodBodyHeap.Write((byte)opCode);            if (opCode == 0xa4) this.methodBodyHeap.Write((int)this.GetTypeToken(indexer.ElementType));            this.stackHeight -= 3;            return;          case NodeType.AddressDereference:            AddressDereference adr = (AddressDereference)target;            this.Visit(adr.Address);            if (adr.Type.IsValueType || adr.Type is ITypeParameter){              Literal lit = assignment.Source as Literal;              if (lit != null && lit.Value == null){                this.methodBodyHeap.Write((byte)0xfe);                this.methodBodyHeap.Write((byte)0x15);                this.methodBodyHeap.Write((int)this.GetTypeToken(adr.Type));                this.stackHeight--;                return;              }            }            this.Visit(assignment.Source);            this.stackHeight -= 2;            if (adr.Alignment > 0){              this.methodBodyHeap.Write((byte)0xfe);              this.methodBodyHeap.Write((byte)0x12);              this.methodBodyHeap.Write((byte)adr.Alignment);            }            if (adr.Volatile){              this.methodBodyHeap.Write((byte)0xfe);              this.methodBodyHeap.Write((byte)0x13);            }            TypeNode adrType = TypeNode.StripModifiers(adr.Type);            if (adrType == null) return;            switch(adrType.typeCode){              case ElementType.Int8:                 case ElementType.UInt8:  this.methodBodyHeap.Write((byte)0x52); return;              case ElementType.Int16:                case ElementType.UInt16: this.methodBodyHeap.Write((byte)0x53); return;              case ElementType.Int32:                case ElementType.UInt32: this.methodBodyHeap.Write((byte)0x54); return;              case ElementType.Int64:              case ElementType.UInt64: this.methodBodyHeap.Write((byte)0x55); return;              case ElementType.Single: this.methodBodyHeap.Write((byte)0x56); return;              case ElementType.Double: this.methodBodyHeap.Write((byte)0x57); return;              case ElementType.UIntPtr:              case ElementType.IntPtr: this.methodBodyHeap.Write((byte)0xdf); return;              default:                if (adrType != null && (adrType.IsValueType ||                  this.UseGenerics && (adrType is ITypeParameter))){                  this.methodBodyHeap.Write((byte)0x81);                  this.methodBodyHeap.Write((int)this.GetTypeToken(adrType));                  return;                }                if (adrType.NodeType == NodeType.Pointer) {                  this.methodBodyHeap.Write((byte)0xdf); return;                }                this.methodBodyHeap.Write((byte) 0x51);                return;            }          default:            Debug.Assert(false' "unexpected assignment target");            return;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitAssignmentStatement,The following statement contains a magic number: switch(assignment.Target.NodeType){          case NodeType.Local:            Local loc = (Local)target;            this.Visit(assignment.Source);            this.stackHeight--;            int li = this.GetLocalVarIndex(loc);            switch(li){              case 0: this.methodBodyHeap.Write((byte)0x0a); return;              case 1: this.methodBodyHeap.Write((byte)0x0b); return;              case 2: this.methodBodyHeap.Write((byte)0x0c); return;              case 3: this.methodBodyHeap.Write((byte)0x0d); return;              default:                if (li < 256){                  this.methodBodyHeap.Write((byte)0x13);                  this.methodBodyHeap.Write((byte)li);                }else{                  this.methodBodyHeap.Write((byte)0xfe);                  this.methodBodyHeap.Write((byte)0x0e);                  this.methodBodyHeap.Write((ushort)li);                }                return;            }          case NodeType.MemberBinding:            MemberBinding mb = (MemberBinding)target;            if (mb.TargetObject != null) this.Visit(mb.TargetObject);            this.Visit(assignment.Source);            if (mb.TargetObject != null) {              if (mb.Alignment != -1) {                this.methodBodyHeap.Write((byte)0xfe);                this.methodBodyHeap.Write((byte)0x12);                this.methodBodyHeap.Write((byte)mb.Alignment);              }              if (mb.Volatile) {                this.methodBodyHeap.Write((byte)0xfe);                this.methodBodyHeap.Write((byte)0x13);              }              this.methodBodyHeap.Write((byte)0x7d);            } else {              if (mb.Volatile) {                this.methodBodyHeap.Write((byte)0xfe);                this.methodBodyHeap.Write((byte)0x13);              }              this.methodBodyHeap.Write((byte)0x80);            }            this.methodBodyHeap.Write((int)this.GetFieldToken((Field)mb.BoundMember));            if (mb.TargetObject != null)              this.stackHeight -= 2;            else              this.stackHeight--;            return;          case NodeType.This:            this.Visit(assignment.Source);            this.methodBodyHeap.Write((byte)0x10);            this.methodBodyHeap.Write((byte)0x00);            this.stackHeight--;            return;          case NodeType.Parameter:  #if !MinimalReader            ParameterBinding pb = target as ParameterBinding;            if (pb != null) target = pb.BoundParameter;  #endif            Parameter par = (Parameter)target;            this.Visit(assignment.Source);            int pi = par.ArgumentListIndex;            if (pi < 256){              this.methodBodyHeap.Write((byte)0x10);              this.methodBodyHeap.Write((byte)pi);            }else{              this.methodBodyHeap.Write((byte)0xfe);              this.methodBodyHeap.Write((byte)0x0b);              this.methodBodyHeap.Write((ushort)pi);            }            this.stackHeight--;            return;          case NodeType.Indexer:            Indexer indexer = (Indexer)target;            this.Visit(indexer.Object);            if (indexer.Operands == null || indexer.Operands.Count < 1) return;            this.Visit(indexer.Operands[0]);            this.Visit(assignment.Source);            byte opCode;            switch(indexer.ElementType.typeCode){              case ElementType.UIntPtr:              case ElementType.IntPtr: opCode = 0x9b; break;              case ElementType.Boolean:              case ElementType.Int8:                 case ElementType.UInt8:  opCode = 0x9c; break;              case ElementType.Char:              case ElementType.Int16:                case ElementType.UInt16: opCode = 0x9d; break;              case ElementType.Int32:                case ElementType.UInt32: opCode = 0x9e; break;              case ElementType.Int64:                case ElementType.UInt64: opCode = 0x9f; break;              case ElementType.Single: opCode = 0xa0; break;              case ElementType.Double: opCode = 0xa1; break;              default:                 if (this.UseGenerics && (indexer.ElementType is ITypeParameter))                  opCode = 0xa4;                else if (TypeNode.StripModifiers(indexer.ElementType) is Pointer)                  opCode = 0x9b;                else                  opCode = 0xa2;                 break;            }            this.methodBodyHeap.Write((byte)opCode);            if (opCode == 0xa4) this.methodBodyHeap.Write((int)this.GetTypeToken(indexer.ElementType));            this.stackHeight -= 3;            return;          case NodeType.AddressDereference:            AddressDereference adr = (AddressDereference)target;            this.Visit(adr.Address);            if (adr.Type.IsValueType || adr.Type is ITypeParameter){              Literal lit = assignment.Source as Literal;              if (lit != null && lit.Value == null){                this.methodBodyHeap.Write((byte)0xfe);                this.methodBodyHeap.Write((byte)0x15);                this.methodBodyHeap.Write((int)this.GetTypeToken(adr.Type));                this.stackHeight--;                return;              }            }            this.Visit(assignment.Source);            this.stackHeight -= 2;            if (adr.Alignment > 0){              this.methodBodyHeap.Write((byte)0xfe);              this.methodBodyHeap.Write((byte)0x12);              this.methodBodyHeap.Write((byte)adr.Alignment);            }            if (adr.Volatile){              this.methodBodyHeap.Write((byte)0xfe);              this.methodBodyHeap.Write((byte)0x13);            }            TypeNode adrType = TypeNode.StripModifiers(adr.Type);            if (adrType == null) return;            switch(adrType.typeCode){              case ElementType.Int8:                 case ElementType.UInt8:  this.methodBodyHeap.Write((byte)0x52); return;              case ElementType.Int16:                case ElementType.UInt16: this.methodBodyHeap.Write((byte)0x53); return;              case ElementType.Int32:                case ElementType.UInt32: this.methodBodyHeap.Write((byte)0x54); return;              case ElementType.Int64:              case ElementType.UInt64: this.methodBodyHeap.Write((byte)0x55); return;              case ElementType.Single: this.methodBodyHeap.Write((byte)0x56); return;              case ElementType.Double: this.methodBodyHeap.Write((byte)0x57); return;              case ElementType.UIntPtr:              case ElementType.IntPtr: this.methodBodyHeap.Write((byte)0xdf); return;              default:                if (adrType != null && (adrType.IsValueType ||                  this.UseGenerics && (adrType is ITypeParameter))){                  this.methodBodyHeap.Write((byte)0x81);                  this.methodBodyHeap.Write((int)this.GetTypeToken(adrType));                  return;                }                if (adrType.NodeType == NodeType.Pointer) {                  this.methodBodyHeap.Write((byte)0xdf); return;                }                this.methodBodyHeap.Write((byte) 0x51);                return;            }          default:            Debug.Assert(false' "unexpected assignment target");            return;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitAssignmentStatement,The following statement contains a magic number: switch(assignment.Target.NodeType){          case NodeType.Local:            Local loc = (Local)target;            this.Visit(assignment.Source);            this.stackHeight--;            int li = this.GetLocalVarIndex(loc);            switch(li){              case 0: this.methodBodyHeap.Write((byte)0x0a); return;              case 1: this.methodBodyHeap.Write((byte)0x0b); return;              case 2: this.methodBodyHeap.Write((byte)0x0c); return;              case 3: this.methodBodyHeap.Write((byte)0x0d); return;              default:                if (li < 256){                  this.methodBodyHeap.Write((byte)0x13);                  this.methodBodyHeap.Write((byte)li);                }else{                  this.methodBodyHeap.Write((byte)0xfe);                  this.methodBodyHeap.Write((byte)0x0e);                  this.methodBodyHeap.Write((ushort)li);                }                return;            }          case NodeType.MemberBinding:            MemberBinding mb = (MemberBinding)target;            if (mb.TargetObject != null) this.Visit(mb.TargetObject);            this.Visit(assignment.Source);            if (mb.TargetObject != null) {              if (mb.Alignment != -1) {                this.methodBodyHeap.Write((byte)0xfe);                this.methodBodyHeap.Write((byte)0x12);                this.methodBodyHeap.Write((byte)mb.Alignment);              }              if (mb.Volatile) {                this.methodBodyHeap.Write((byte)0xfe);                this.methodBodyHeap.Write((byte)0x13);              }              this.methodBodyHeap.Write((byte)0x7d);            } else {              if (mb.Volatile) {                this.methodBodyHeap.Write((byte)0xfe);                this.methodBodyHeap.Write((byte)0x13);              }              this.methodBodyHeap.Write((byte)0x80);            }            this.methodBodyHeap.Write((int)this.GetFieldToken((Field)mb.BoundMember));            if (mb.TargetObject != null)              this.stackHeight -= 2;            else              this.stackHeight--;            return;          case NodeType.This:            this.Visit(assignment.Source);            this.methodBodyHeap.Write((byte)0x10);            this.methodBodyHeap.Write((byte)0x00);            this.stackHeight--;            return;          case NodeType.Parameter:  #if !MinimalReader            ParameterBinding pb = target as ParameterBinding;            if (pb != null) target = pb.BoundParameter;  #endif            Parameter par = (Parameter)target;            this.Visit(assignment.Source);            int pi = par.ArgumentListIndex;            if (pi < 256){              this.methodBodyHeap.Write((byte)0x10);              this.methodBodyHeap.Write((byte)pi);            }else{              this.methodBodyHeap.Write((byte)0xfe);              this.methodBodyHeap.Write((byte)0x0b);              this.methodBodyHeap.Write((ushort)pi);            }            this.stackHeight--;            return;          case NodeType.Indexer:            Indexer indexer = (Indexer)target;            this.Visit(indexer.Object);            if (indexer.Operands == null || indexer.Operands.Count < 1) return;            this.Visit(indexer.Operands[0]);            this.Visit(assignment.Source);            byte opCode;            switch(indexer.ElementType.typeCode){              case ElementType.UIntPtr:              case ElementType.IntPtr: opCode = 0x9b; break;              case ElementType.Boolean:              case ElementType.Int8:                 case ElementType.UInt8:  opCode = 0x9c; break;              case ElementType.Char:              case ElementType.Int16:                case ElementType.UInt16: opCode = 0x9d; break;              case ElementType.Int32:                case ElementType.UInt32: opCode = 0x9e; break;              case ElementType.Int64:                case ElementType.UInt64: opCode = 0x9f; break;              case ElementType.Single: opCode = 0xa0; break;              case ElementType.Double: opCode = 0xa1; break;              default:                 if (this.UseGenerics && (indexer.ElementType is ITypeParameter))                  opCode = 0xa4;                else if (TypeNode.StripModifiers(indexer.ElementType) is Pointer)                  opCode = 0x9b;                else                  opCode = 0xa2;                 break;            }            this.methodBodyHeap.Write((byte)opCode);            if (opCode == 0xa4) this.methodBodyHeap.Write((int)this.GetTypeToken(indexer.ElementType));            this.stackHeight -= 3;            return;          case NodeType.AddressDereference:            AddressDereference adr = (AddressDereference)target;            this.Visit(adr.Address);            if (adr.Type.IsValueType || adr.Type is ITypeParameter){              Literal lit = assignment.Source as Literal;              if (lit != null && lit.Value == null){                this.methodBodyHeap.Write((byte)0xfe);                this.methodBodyHeap.Write((byte)0x15);                this.methodBodyHeap.Write((int)this.GetTypeToken(adr.Type));                this.stackHeight--;                return;              }            }            this.Visit(assignment.Source);            this.stackHeight -= 2;            if (adr.Alignment > 0){              this.methodBodyHeap.Write((byte)0xfe);              this.methodBodyHeap.Write((byte)0x12);              this.methodBodyHeap.Write((byte)adr.Alignment);            }            if (adr.Volatile){              this.methodBodyHeap.Write((byte)0xfe);              this.methodBodyHeap.Write((byte)0x13);            }            TypeNode adrType = TypeNode.StripModifiers(adr.Type);            if (adrType == null) return;            switch(adrType.typeCode){              case ElementType.Int8:                 case ElementType.UInt8:  this.methodBodyHeap.Write((byte)0x52); return;              case ElementType.Int16:                case ElementType.UInt16: this.methodBodyHeap.Write((byte)0x53); return;              case ElementType.Int32:                case ElementType.UInt32: this.methodBodyHeap.Write((byte)0x54); return;              case ElementType.Int64:              case ElementType.UInt64: this.methodBodyHeap.Write((byte)0x55); return;              case ElementType.Single: this.methodBodyHeap.Write((byte)0x56); return;              case ElementType.Double: this.methodBodyHeap.Write((byte)0x57); return;              case ElementType.UIntPtr:              case ElementType.IntPtr: this.methodBodyHeap.Write((byte)0xdf); return;              default:                if (adrType != null && (adrType.IsValueType ||                  this.UseGenerics && (adrType is ITypeParameter))){                  this.methodBodyHeap.Write((byte)0x81);                  this.methodBodyHeap.Write((int)this.GetTypeToken(adrType));                  return;                }                if (adrType.NodeType == NodeType.Pointer) {                  this.methodBodyHeap.Write((byte)0xdf); return;                }                this.methodBodyHeap.Write((byte) 0x51);                return;            }          default:            Debug.Assert(false' "unexpected assignment target");            return;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitAssignmentStatement,The following statement contains a magic number: switch(assignment.Target.NodeType){          case NodeType.Local:            Local loc = (Local)target;            this.Visit(assignment.Source);            this.stackHeight--;            int li = this.GetLocalVarIndex(loc);            switch(li){              case 0: this.methodBodyHeap.Write((byte)0x0a); return;              case 1: this.methodBodyHeap.Write((byte)0x0b); return;              case 2: this.methodBodyHeap.Write((byte)0x0c); return;              case 3: this.methodBodyHeap.Write((byte)0x0d); return;              default:                if (li < 256){                  this.methodBodyHeap.Write((byte)0x13);                  this.methodBodyHeap.Write((byte)li);                }else{                  this.methodBodyHeap.Write((byte)0xfe);                  this.methodBodyHeap.Write((byte)0x0e);                  this.methodBodyHeap.Write((ushort)li);                }                return;            }          case NodeType.MemberBinding:            MemberBinding mb = (MemberBinding)target;            if (mb.TargetObject != null) this.Visit(mb.TargetObject);            this.Visit(assignment.Source);            if (mb.TargetObject != null) {              if (mb.Alignment != -1) {                this.methodBodyHeap.Write((byte)0xfe);                this.methodBodyHeap.Write((byte)0x12);                this.methodBodyHeap.Write((byte)mb.Alignment);              }              if (mb.Volatile) {                this.methodBodyHeap.Write((byte)0xfe);                this.methodBodyHeap.Write((byte)0x13);              }              this.methodBodyHeap.Write((byte)0x7d);            } else {              if (mb.Volatile) {                this.methodBodyHeap.Write((byte)0xfe);                this.methodBodyHeap.Write((byte)0x13);              }              this.methodBodyHeap.Write((byte)0x80);            }            this.methodBodyHeap.Write((int)this.GetFieldToken((Field)mb.BoundMember));            if (mb.TargetObject != null)              this.stackHeight -= 2;            else              this.stackHeight--;            return;          case NodeType.This:            this.Visit(assignment.Source);            this.methodBodyHeap.Write((byte)0x10);            this.methodBodyHeap.Write((byte)0x00);            this.stackHeight--;            return;          case NodeType.Parameter:  #if !MinimalReader            ParameterBinding pb = target as ParameterBinding;            if (pb != null) target = pb.BoundParameter;  #endif            Parameter par = (Parameter)target;            this.Visit(assignment.Source);            int pi = par.ArgumentListIndex;            if (pi < 256){              this.methodBodyHeap.Write((byte)0x10);              this.methodBodyHeap.Write((byte)pi);            }else{              this.methodBodyHeap.Write((byte)0xfe);              this.methodBodyHeap.Write((byte)0x0b);              this.methodBodyHeap.Write((ushort)pi);            }            this.stackHeight--;            return;          case NodeType.Indexer:            Indexer indexer = (Indexer)target;            this.Visit(indexer.Object);            if (indexer.Operands == null || indexer.Operands.Count < 1) return;            this.Visit(indexer.Operands[0]);            this.Visit(assignment.Source);            byte opCode;            switch(indexer.ElementType.typeCode){              case ElementType.UIntPtr:              case ElementType.IntPtr: opCode = 0x9b; break;              case ElementType.Boolean:              case ElementType.Int8:                 case ElementType.UInt8:  opCode = 0x9c; break;              case ElementType.Char:              case ElementType.Int16:                case ElementType.UInt16: opCode = 0x9d; break;              case ElementType.Int32:                case ElementType.UInt32: opCode = 0x9e; break;              case ElementType.Int64:                case ElementType.UInt64: opCode = 0x9f; break;              case ElementType.Single: opCode = 0xa0; break;              case ElementType.Double: opCode = 0xa1; break;              default:                 if (this.UseGenerics && (indexer.ElementType is ITypeParameter))                  opCode = 0xa4;                else if (TypeNode.StripModifiers(indexer.ElementType) is Pointer)                  opCode = 0x9b;                else                  opCode = 0xa2;                 break;            }            this.methodBodyHeap.Write((byte)opCode);            if (opCode == 0xa4) this.methodBodyHeap.Write((int)this.GetTypeToken(indexer.ElementType));            this.stackHeight -= 3;            return;          case NodeType.AddressDereference:            AddressDereference adr = (AddressDereference)target;            this.Visit(adr.Address);            if (adr.Type.IsValueType || adr.Type is ITypeParameter){              Literal lit = assignment.Source as Literal;              if (lit != null && lit.Value == null){                this.methodBodyHeap.Write((byte)0xfe);                this.methodBodyHeap.Write((byte)0x15);                this.methodBodyHeap.Write((int)this.GetTypeToken(adr.Type));                this.stackHeight--;                return;              }            }            this.Visit(assignment.Source);            this.stackHeight -= 2;            if (adr.Alignment > 0){              this.methodBodyHeap.Write((byte)0xfe);              this.methodBodyHeap.Write((byte)0x12);              this.methodBodyHeap.Write((byte)adr.Alignment);            }            if (adr.Volatile){              this.methodBodyHeap.Write((byte)0xfe);              this.methodBodyHeap.Write((byte)0x13);            }            TypeNode adrType = TypeNode.StripModifiers(adr.Type);            if (adrType == null) return;            switch(adrType.typeCode){              case ElementType.Int8:                 case ElementType.UInt8:  this.methodBodyHeap.Write((byte)0x52); return;              case ElementType.Int16:                case ElementType.UInt16: this.methodBodyHeap.Write((byte)0x53); return;              case ElementType.Int32:                case ElementType.UInt32: this.methodBodyHeap.Write((byte)0x54); return;              case ElementType.Int64:              case ElementType.UInt64: this.methodBodyHeap.Write((byte)0x55); return;              case ElementType.Single: this.methodBodyHeap.Write((byte)0x56); return;              case ElementType.Double: this.methodBodyHeap.Write((byte)0x57); return;              case ElementType.UIntPtr:              case ElementType.IntPtr: this.methodBodyHeap.Write((byte)0xdf); return;              default:                if (adrType != null && (adrType.IsValueType ||                  this.UseGenerics && (adrType is ITypeParameter))){                  this.methodBodyHeap.Write((byte)0x81);                  this.methodBodyHeap.Write((int)this.GetTypeToken(adrType));                  return;                }                if (adrType.NodeType == NodeType.Pointer) {                  this.methodBodyHeap.Write((byte)0xdf); return;                }                this.methodBodyHeap.Write((byte) 0x51);                return;            }          default:            Debug.Assert(false' "unexpected assignment target");            return;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitAssignmentStatement,The following statement contains a magic number: switch(assignment.Target.NodeType){          case NodeType.Local:            Local loc = (Local)target;            this.Visit(assignment.Source);            this.stackHeight--;            int li = this.GetLocalVarIndex(loc);            switch(li){              case 0: this.methodBodyHeap.Write((byte)0x0a); return;              case 1: this.methodBodyHeap.Write((byte)0x0b); return;              case 2: this.methodBodyHeap.Write((byte)0x0c); return;              case 3: this.methodBodyHeap.Write((byte)0x0d); return;              default:                if (li < 256){                  this.methodBodyHeap.Write((byte)0x13);                  this.methodBodyHeap.Write((byte)li);                }else{                  this.methodBodyHeap.Write((byte)0xfe);                  this.methodBodyHeap.Write((byte)0x0e);                  this.methodBodyHeap.Write((ushort)li);                }                return;            }          case NodeType.MemberBinding:            MemberBinding mb = (MemberBinding)target;            if (mb.TargetObject != null) this.Visit(mb.TargetObject);            this.Visit(assignment.Source);            if (mb.TargetObject != null) {              if (mb.Alignment != -1) {                this.methodBodyHeap.Write((byte)0xfe);                this.methodBodyHeap.Write((byte)0x12);                this.methodBodyHeap.Write((byte)mb.Alignment);              }              if (mb.Volatile) {                this.methodBodyHeap.Write((byte)0xfe);                this.methodBodyHeap.Write((byte)0x13);              }              this.methodBodyHeap.Write((byte)0x7d);            } else {              if (mb.Volatile) {                this.methodBodyHeap.Write((byte)0xfe);                this.methodBodyHeap.Write((byte)0x13);              }              this.methodBodyHeap.Write((byte)0x80);            }            this.methodBodyHeap.Write((int)this.GetFieldToken((Field)mb.BoundMember));            if (mb.TargetObject != null)              this.stackHeight -= 2;            else              this.stackHeight--;            return;          case NodeType.This:            this.Visit(assignment.Source);            this.methodBodyHeap.Write((byte)0x10);            this.methodBodyHeap.Write((byte)0x00);            this.stackHeight--;            return;          case NodeType.Parameter:  #if !MinimalReader            ParameterBinding pb = target as ParameterBinding;            if (pb != null) target = pb.BoundParameter;  #endif            Parameter par = (Parameter)target;            this.Visit(assignment.Source);            int pi = par.ArgumentListIndex;            if (pi < 256){              this.methodBodyHeap.Write((byte)0x10);              this.methodBodyHeap.Write((byte)pi);            }else{              this.methodBodyHeap.Write((byte)0xfe);              this.methodBodyHeap.Write((byte)0x0b);              this.methodBodyHeap.Write((ushort)pi);            }            this.stackHeight--;            return;          case NodeType.Indexer:            Indexer indexer = (Indexer)target;            this.Visit(indexer.Object);            if (indexer.Operands == null || indexer.Operands.Count < 1) return;            this.Visit(indexer.Operands[0]);            this.Visit(assignment.Source);            byte opCode;            switch(indexer.ElementType.typeCode){              case ElementType.UIntPtr:              case ElementType.IntPtr: opCode = 0x9b; break;              case ElementType.Boolean:              case ElementType.Int8:                 case ElementType.UInt8:  opCode = 0x9c; break;              case ElementType.Char:              case ElementType.Int16:                case ElementType.UInt16: opCode = 0x9d; break;              case ElementType.Int32:                case ElementType.UInt32: opCode = 0x9e; break;              case ElementType.Int64:                case ElementType.UInt64: opCode = 0x9f; break;              case ElementType.Single: opCode = 0xa0; break;              case ElementType.Double: opCode = 0xa1; break;              default:                 if (this.UseGenerics && (indexer.ElementType is ITypeParameter))                  opCode = 0xa4;                else if (TypeNode.StripModifiers(indexer.ElementType) is Pointer)                  opCode = 0x9b;                else                  opCode = 0xa2;                 break;            }            this.methodBodyHeap.Write((byte)opCode);            if (opCode == 0xa4) this.methodBodyHeap.Write((int)this.GetTypeToken(indexer.ElementType));            this.stackHeight -= 3;            return;          case NodeType.AddressDereference:            AddressDereference adr = (AddressDereference)target;            this.Visit(adr.Address);            if (adr.Type.IsValueType || adr.Type is ITypeParameter){              Literal lit = assignment.Source as Literal;              if (lit != null && lit.Value == null){                this.methodBodyHeap.Write((byte)0xfe);                this.methodBodyHeap.Write((byte)0x15);                this.methodBodyHeap.Write((int)this.GetTypeToken(adr.Type));                this.stackHeight--;                return;              }            }            this.Visit(assignment.Source);            this.stackHeight -= 2;            if (adr.Alignment > 0){              this.methodBodyHeap.Write((byte)0xfe);              this.methodBodyHeap.Write((byte)0x12);              this.methodBodyHeap.Write((byte)adr.Alignment);            }            if (adr.Volatile){              this.methodBodyHeap.Write((byte)0xfe);              this.methodBodyHeap.Write((byte)0x13);            }            TypeNode adrType = TypeNode.StripModifiers(adr.Type);            if (adrType == null) return;            switch(adrType.typeCode){              case ElementType.Int8:                 case ElementType.UInt8:  this.methodBodyHeap.Write((byte)0x52); return;              case ElementType.Int16:                case ElementType.UInt16: this.methodBodyHeap.Write((byte)0x53); return;              case ElementType.Int32:                case ElementType.UInt32: this.methodBodyHeap.Write((byte)0x54); return;              case ElementType.Int64:              case ElementType.UInt64: this.methodBodyHeap.Write((byte)0x55); return;              case ElementType.Single: this.methodBodyHeap.Write((byte)0x56); return;              case ElementType.Double: this.methodBodyHeap.Write((byte)0x57); return;              case ElementType.UIntPtr:              case ElementType.IntPtr: this.methodBodyHeap.Write((byte)0xdf); return;              default:                if (adrType != null && (adrType.IsValueType ||                  this.UseGenerics && (adrType is ITypeParameter))){                  this.methodBodyHeap.Write((byte)0x81);                  this.methodBodyHeap.Write((int)this.GetTypeToken(adrType));                  return;                }                if (adrType.NodeType == NodeType.Pointer) {                  this.methodBodyHeap.Write((byte)0xdf); return;                }                this.methodBodyHeap.Write((byte) 0x51);                return;            }          default:            Debug.Assert(false' "unexpected assignment target");            return;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitAssignmentStatement,The following statement contains a magic number: switch(assignment.Target.NodeType){          case NodeType.Local:            Local loc = (Local)target;            this.Visit(assignment.Source);            this.stackHeight--;            int li = this.GetLocalVarIndex(loc);            switch(li){              case 0: this.methodBodyHeap.Write((byte)0x0a); return;              case 1: this.methodBodyHeap.Write((byte)0x0b); return;              case 2: this.methodBodyHeap.Write((byte)0x0c); return;              case 3: this.methodBodyHeap.Write((byte)0x0d); return;              default:                if (li < 256){                  this.methodBodyHeap.Write((byte)0x13);                  this.methodBodyHeap.Write((byte)li);                }else{                  this.methodBodyHeap.Write((byte)0xfe);                  this.methodBodyHeap.Write((byte)0x0e);                  this.methodBodyHeap.Write((ushort)li);                }                return;            }          case NodeType.MemberBinding:            MemberBinding mb = (MemberBinding)target;            if (mb.TargetObject != null) this.Visit(mb.TargetObject);            this.Visit(assignment.Source);            if (mb.TargetObject != null) {              if (mb.Alignment != -1) {                this.methodBodyHeap.Write((byte)0xfe);                this.methodBodyHeap.Write((byte)0x12);                this.methodBodyHeap.Write((byte)mb.Alignment);              }              if (mb.Volatile) {                this.methodBodyHeap.Write((byte)0xfe);                this.methodBodyHeap.Write((byte)0x13);              }              this.methodBodyHeap.Write((byte)0x7d);            } else {              if (mb.Volatile) {                this.methodBodyHeap.Write((byte)0xfe);                this.methodBodyHeap.Write((byte)0x13);              }              this.methodBodyHeap.Write((byte)0x80);            }            this.methodBodyHeap.Write((int)this.GetFieldToken((Field)mb.BoundMember));            if (mb.TargetObject != null)              this.stackHeight -= 2;            else              this.stackHeight--;            return;          case NodeType.This:            this.Visit(assignment.Source);            this.methodBodyHeap.Write((byte)0x10);            this.methodBodyHeap.Write((byte)0x00);            this.stackHeight--;            return;          case NodeType.Parameter:  #if !MinimalReader            ParameterBinding pb = target as ParameterBinding;            if (pb != null) target = pb.BoundParameter;  #endif            Parameter par = (Parameter)target;            this.Visit(assignment.Source);            int pi = par.ArgumentListIndex;            if (pi < 256){              this.methodBodyHeap.Write((byte)0x10);              this.methodBodyHeap.Write((byte)pi);            }else{              this.methodBodyHeap.Write((byte)0xfe);              this.methodBodyHeap.Write((byte)0x0b);              this.methodBodyHeap.Write((ushort)pi);            }            this.stackHeight--;            return;          case NodeType.Indexer:            Indexer indexer = (Indexer)target;            this.Visit(indexer.Object);            if (indexer.Operands == null || indexer.Operands.Count < 1) return;            this.Visit(indexer.Operands[0]);            this.Visit(assignment.Source);            byte opCode;            switch(indexer.ElementType.typeCode){              case ElementType.UIntPtr:              case ElementType.IntPtr: opCode = 0x9b; break;              case ElementType.Boolean:              case ElementType.Int8:                 case ElementType.UInt8:  opCode = 0x9c; break;              case ElementType.Char:              case ElementType.Int16:                case ElementType.UInt16: opCode = 0x9d; break;              case ElementType.Int32:                case ElementType.UInt32: opCode = 0x9e; break;              case ElementType.Int64:                case ElementType.UInt64: opCode = 0x9f; break;              case ElementType.Single: opCode = 0xa0; break;              case ElementType.Double: opCode = 0xa1; break;              default:                 if (this.UseGenerics && (indexer.ElementType is ITypeParameter))                  opCode = 0xa4;                else if (TypeNode.StripModifiers(indexer.ElementType) is Pointer)                  opCode = 0x9b;                else                  opCode = 0xa2;                 break;            }            this.methodBodyHeap.Write((byte)opCode);            if (opCode == 0xa4) this.methodBodyHeap.Write((int)this.GetTypeToken(indexer.ElementType));            this.stackHeight -= 3;            return;          case NodeType.AddressDereference:            AddressDereference adr = (AddressDereference)target;            this.Visit(adr.Address);            if (adr.Type.IsValueType || adr.Type is ITypeParameter){              Literal lit = assignment.Source as Literal;              if (lit != null && lit.Value == null){                this.methodBodyHeap.Write((byte)0xfe);                this.methodBodyHeap.Write((byte)0x15);                this.methodBodyHeap.Write((int)this.GetTypeToken(adr.Type));                this.stackHeight--;                return;              }            }            this.Visit(assignment.Source);            this.stackHeight -= 2;            if (adr.Alignment > 0){              this.methodBodyHeap.Write((byte)0xfe);              this.methodBodyHeap.Write((byte)0x12);              this.methodBodyHeap.Write((byte)adr.Alignment);            }            if (adr.Volatile){              this.methodBodyHeap.Write((byte)0xfe);              this.methodBodyHeap.Write((byte)0x13);            }            TypeNode adrType = TypeNode.StripModifiers(adr.Type);            if (adrType == null) return;            switch(adrType.typeCode){              case ElementType.Int8:                 case ElementType.UInt8:  this.methodBodyHeap.Write((byte)0x52); return;              case ElementType.Int16:                case ElementType.UInt16: this.methodBodyHeap.Write((byte)0x53); return;              case ElementType.Int32:                case ElementType.UInt32: this.methodBodyHeap.Write((byte)0x54); return;              case ElementType.Int64:              case ElementType.UInt64: this.methodBodyHeap.Write((byte)0x55); return;              case ElementType.Single: this.methodBodyHeap.Write((byte)0x56); return;              case ElementType.Double: this.methodBodyHeap.Write((byte)0x57); return;              case ElementType.UIntPtr:              case ElementType.IntPtr: this.methodBodyHeap.Write((byte)0xdf); return;              default:                if (adrType != null && (adrType.IsValueType ||                  this.UseGenerics && (adrType is ITypeParameter))){                  this.methodBodyHeap.Write((byte)0x81);                  this.methodBodyHeap.Write((int)this.GetTypeToken(adrType));                  return;                }                if (adrType.NodeType == NodeType.Pointer) {                  this.methodBodyHeap.Write((byte)0xdf); return;                }                this.methodBodyHeap.Write((byte) 0x51);                return;            }          default:            Debug.Assert(false' "unexpected assignment target");            return;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitAssignmentStatement,The following statement contains a magic number: switch(assignment.Target.NodeType){          case NodeType.Local:            Local loc = (Local)target;            this.Visit(assignment.Source);            this.stackHeight--;            int li = this.GetLocalVarIndex(loc);            switch(li){              case 0: this.methodBodyHeap.Write((byte)0x0a); return;              case 1: this.methodBodyHeap.Write((byte)0x0b); return;              case 2: this.methodBodyHeap.Write((byte)0x0c); return;              case 3: this.methodBodyHeap.Write((byte)0x0d); return;              default:                if (li < 256){                  this.methodBodyHeap.Write((byte)0x13);                  this.methodBodyHeap.Write((byte)li);                }else{                  this.methodBodyHeap.Write((byte)0xfe);                  this.methodBodyHeap.Write((byte)0x0e);                  this.methodBodyHeap.Write((ushort)li);                }                return;            }          case NodeType.MemberBinding:            MemberBinding mb = (MemberBinding)target;            if (mb.TargetObject != null) this.Visit(mb.TargetObject);            this.Visit(assignment.Source);            if (mb.TargetObject != null) {              if (mb.Alignment != -1) {                this.methodBodyHeap.Write((byte)0xfe);                this.methodBodyHeap.Write((byte)0x12);                this.methodBodyHeap.Write((byte)mb.Alignment);              }              if (mb.Volatile) {                this.methodBodyHeap.Write((byte)0xfe);                this.methodBodyHeap.Write((byte)0x13);              }              this.methodBodyHeap.Write((byte)0x7d);            } else {              if (mb.Volatile) {                this.methodBodyHeap.Write((byte)0xfe);                this.methodBodyHeap.Write((byte)0x13);              }              this.methodBodyHeap.Write((byte)0x80);            }            this.methodBodyHeap.Write((int)this.GetFieldToken((Field)mb.BoundMember));            if (mb.TargetObject != null)              this.stackHeight -= 2;            else              this.stackHeight--;            return;          case NodeType.This:            this.Visit(assignment.Source);            this.methodBodyHeap.Write((byte)0x10);            this.methodBodyHeap.Write((byte)0x00);            this.stackHeight--;            return;          case NodeType.Parameter:  #if !MinimalReader            ParameterBinding pb = target as ParameterBinding;            if (pb != null) target = pb.BoundParameter;  #endif            Parameter par = (Parameter)target;            this.Visit(assignment.Source);            int pi = par.ArgumentListIndex;            if (pi < 256){              this.methodBodyHeap.Write((byte)0x10);              this.methodBodyHeap.Write((byte)pi);            }else{              this.methodBodyHeap.Write((byte)0xfe);              this.methodBodyHeap.Write((byte)0x0b);              this.methodBodyHeap.Write((ushort)pi);            }            this.stackHeight--;            return;          case NodeType.Indexer:            Indexer indexer = (Indexer)target;            this.Visit(indexer.Object);            if (indexer.Operands == null || indexer.Operands.Count < 1) return;            this.Visit(indexer.Operands[0]);            this.Visit(assignment.Source);            byte opCode;            switch(indexer.ElementType.typeCode){              case ElementType.UIntPtr:              case ElementType.IntPtr: opCode = 0x9b; break;              case ElementType.Boolean:              case ElementType.Int8:                 case ElementType.UInt8:  opCode = 0x9c; break;              case ElementType.Char:              case ElementType.Int16:                case ElementType.UInt16: opCode = 0x9d; break;              case ElementType.Int32:                case ElementType.UInt32: opCode = 0x9e; break;              case ElementType.Int64:                case ElementType.UInt64: opCode = 0x9f; break;              case ElementType.Single: opCode = 0xa0; break;              case ElementType.Double: opCode = 0xa1; break;              default:                 if (this.UseGenerics && (indexer.ElementType is ITypeParameter))                  opCode = 0xa4;                else if (TypeNode.StripModifiers(indexer.ElementType) is Pointer)                  opCode = 0x9b;                else                  opCode = 0xa2;                 break;            }            this.methodBodyHeap.Write((byte)opCode);            if (opCode == 0xa4) this.methodBodyHeap.Write((int)this.GetTypeToken(indexer.ElementType));            this.stackHeight -= 3;            return;          case NodeType.AddressDereference:            AddressDereference adr = (AddressDereference)target;            this.Visit(adr.Address);            if (adr.Type.IsValueType || adr.Type is ITypeParameter){              Literal lit = assignment.Source as Literal;              if (lit != null && lit.Value == null){                this.methodBodyHeap.Write((byte)0xfe);                this.methodBodyHeap.Write((byte)0x15);                this.methodBodyHeap.Write((int)this.GetTypeToken(adr.Type));                this.stackHeight--;                return;              }            }            this.Visit(assignment.Source);            this.stackHeight -= 2;            if (adr.Alignment > 0){              this.methodBodyHeap.Write((byte)0xfe);              this.methodBodyHeap.Write((byte)0x12);              this.methodBodyHeap.Write((byte)adr.Alignment);            }            if (adr.Volatile){              this.methodBodyHeap.Write((byte)0xfe);              this.methodBodyHeap.Write((byte)0x13);            }            TypeNode adrType = TypeNode.StripModifiers(adr.Type);            if (adrType == null) return;            switch(adrType.typeCode){              case ElementType.Int8:                 case ElementType.UInt8:  this.methodBodyHeap.Write((byte)0x52); return;              case ElementType.Int16:                case ElementType.UInt16: this.methodBodyHeap.Write((byte)0x53); return;              case ElementType.Int32:                case ElementType.UInt32: this.methodBodyHeap.Write((byte)0x54); return;              case ElementType.Int64:              case ElementType.UInt64: this.methodBodyHeap.Write((byte)0x55); return;              case ElementType.Single: this.methodBodyHeap.Write((byte)0x56); return;              case ElementType.Double: this.methodBodyHeap.Write((byte)0x57); return;              case ElementType.UIntPtr:              case ElementType.IntPtr: this.methodBodyHeap.Write((byte)0xdf); return;              default:                if (adrType != null && (adrType.IsValueType ||                  this.UseGenerics && (adrType is ITypeParameter))){                  this.methodBodyHeap.Write((byte)0x81);                  this.methodBodyHeap.Write((int)this.GetTypeToken(adrType));                  return;                }                if (adrType.NodeType == NodeType.Pointer) {                  this.methodBodyHeap.Write((byte)0xdf); return;                }                this.methodBodyHeap.Write((byte) 0x51);                return;            }          default:            Debug.Assert(false' "unexpected assignment target");            return;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitBranch,The following statement contains a magic number: if (bex != null){          switch(bex.NodeType){            case NodeType.Eq:            case NodeType.Ge:            case NodeType.Gt:            case NodeType.Le:            case NodeType.Lt:            case NodeType.Ne:              this.Visit(bex.Operand1);              this.Visit(bex.Operand2);              typeOfCondition = bex.NodeType;              this.stackHeight -= 2;              break;            case NodeType.And:            case NodeType.Or:            case NodeType.Xor:            case NodeType.Isinst:            case NodeType.Castclass:              typeOfCondition = bex.NodeType;              goto default;            default:              this.Visit(branch.Condition);              this.stackHeight--;              break;          }        }else{          uex = branch.Condition as UnaryExpression;          if (uex != null && uex.NodeType == NodeType.LogicalNot) {            this.Visit(uex.Operand);            typeOfCondition = NodeType.LogicalNot;            this.stackHeight--;          }else if (branch.Condition != null){            // Undefined is used here simply as a sentinel value            typeOfCondition = NodeType.Undefined;            this.Visit(branch.Condition);            this.stackHeight--;          }        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitMethodCall,The following statement contains a magic number: if ((method.CallingConvention&(CallingConventionFlags)7) == CallingConventionFlags.VarArg ||           (method.CallingConvention&(CallingConventionFlags)7) == CallingConventionFlags.C){          this.methodBodyHeap.Write((int)this.GetMemberRefToken(method' arguments));        }else          this.methodBodyHeap.Write((int)this.GetMethodToken(method));
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitMethodCall,The following statement contains a magic number: if ((method.CallingConvention&(CallingConventionFlags)7) == CallingConventionFlags.VarArg ||           (method.CallingConvention&(CallingConventionFlags)7) == CallingConventionFlags.C){          this.methodBodyHeap.Write((int)this.GetMemberRefToken(method' arguments));        }else          this.methodBodyHeap.Write((int)this.GetMethodToken(method));
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitFixupList,The following statement contains a magic number: while (fixup != null){          this.methodBodyHeap.BaseStream.Position = fixup.fixupLocation;          if (fixup.shortOffset){            int offset = targetAddress - fixup.addressOfNextInstruction;            Debug.Assert(-128 <= offset && offset <= 127' "Invalid short branch");            this.methodBodyHeap.Write((byte)offset);          }else            this.methodBodyHeap.Write((int)(targetAddress - fixup.addressOfNextInstruction));          fixup = fixup.nextFixUp;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitFixupList,The following statement contains a magic number: while (fixup != null){          this.methodBodyHeap.BaseStream.Position = fixup.fixupLocation;          if (fixup.shortOffset){            int offset = targetAddress - fixup.addressOfNextInstruction;            Debug.Assert(-128 <= offset && offset <= 127' "Invalid short branch");            this.methodBodyHeap.Write((byte)offset);          }else            this.methodBodyHeap.Write((int)(targetAddress - fixup.addressOfNextInstruction));          fixup = fixup.nextFixUp;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitLocal,The following statement contains a magic number: switch(li){          case 0: this.methodBodyHeap.Write((byte)0x06); return;          case 1: this.methodBodyHeap.Write((byte)0x07); return;          case 2: this.methodBodyHeap.Write((byte)0x08); return;          case 3: this.methodBodyHeap.Write((byte)0x09); return;          default:            if (li < 256){              this.methodBodyHeap.Write((byte)0x11);              this.methodBodyHeap.Write((byte)li);            }else{              this.methodBodyHeap.Write((byte)0xfe);              this.methodBodyHeap.Write((byte)0x0c);              this.methodBodyHeap.Write((ushort)li);            }            return;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitLocal,The following statement contains a magic number: switch(li){          case 0: this.methodBodyHeap.Write((byte)0x06); return;          case 1: this.methodBodyHeap.Write((byte)0x07); return;          case 2: this.methodBodyHeap.Write((byte)0x08); return;          case 3: this.methodBodyHeap.Write((byte)0x09); return;          default:            if (li < 256){              this.methodBodyHeap.Write((byte)0x11);              this.methodBodyHeap.Write((byte)li);            }else{              this.methodBodyHeap.Write((byte)0xfe);              this.methodBodyHeap.Write((byte)0x0c);              this.methodBodyHeap.Write((ushort)li);            }            return;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitLocal,The following statement contains a magic number: switch(li){          case 0: this.methodBodyHeap.Write((byte)0x06); return;          case 1: this.methodBodyHeap.Write((byte)0x07); return;          case 2: this.methodBodyHeap.Write((byte)0x08); return;          case 3: this.methodBodyHeap.Write((byte)0x09); return;          default:            if (li < 256){              this.methodBodyHeap.Write((byte)0x11);              this.methodBodyHeap.Write((byte)li);            }else{              this.methodBodyHeap.Write((byte)0xfe);              this.methodBodyHeap.Write((byte)0x0c);              this.methodBodyHeap.Write((ushort)li);            }            return;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitLiteral,The following statement contains a magic number: switch (tc){          case TypeCode.Boolean:          case TypeCode.SByte:          case TypeCode.Byte:          case TypeCode.Char:          case TypeCode.Int16:          case TypeCode.UInt16:          case TypeCode.Int32:          case TypeCode.UInt32:          case TypeCode.Int64:            long n = ic.ToInt64(null);            switch (n){              case -1 : this.methodBodyHeap.Write((byte)0x15); break;              case 0 : this.methodBodyHeap.Write((byte)0x16); break;              case 1 : this.methodBodyHeap.Write((byte)0x17); break;              case 2 : this.methodBodyHeap.Write((byte)0x18); break;              case 3 : this.methodBodyHeap.Write((byte)0x19); break;              case 4 : this.methodBodyHeap.Write((byte)0x1a); break;              case 5 : this.methodBodyHeap.Write((byte)0x1b); break;              case 6 : this.methodBodyHeap.Write((byte)0x1c); break;              case 7 : this.methodBodyHeap.Write((byte)0x1d); break;              case 8 : this.methodBodyHeap.Write((byte)0x1e); break;              default:                if (n >= System.SByte.MinValue && n <= System.SByte.MaxValue){                  this.methodBodyHeap.Write((byte)0x1f);                  this.methodBodyHeap.Write((byte)n);                }else if (n >= System.Int32.MinValue && n <= System.Int32.MaxValue ||                  n <= System.UInt32.MaxValue && (tc == TypeCode.Char || tc == TypeCode.UInt16 || tc == TypeCode.UInt32)){                  if (n == System.UInt32.MaxValue && tc != TypeCode.Int64)                    this.methodBodyHeap.Write((byte)0x15);                  else{                    this.methodBodyHeap.Write((byte)0x20);                    this.methodBodyHeap.Write((int)n);                  }                }else{                  this.methodBodyHeap.Write((byte)0x21);                  this.methodBodyHeap.Write((long)n);                  tc = TypeCode.Empty; //Suppress conversion to long                }                break;            }            if (tc == TypeCode.Int64)              this.methodBodyHeap.Write((byte)0x6a);            return;            case TypeCode.UInt64:            this.methodBodyHeap.Write((byte)0x21);            this.methodBodyHeap.Write(ic.ToUInt64(null));            return;            case TypeCode.Single:            this.methodBodyHeap.Write((byte)0x22);            this.methodBodyHeap.Write(ic.ToSingle(null));            return;            case TypeCode.Double:            this.methodBodyHeap.Write((byte)0x23);            this.methodBodyHeap.Write(ic.ToDouble(null));            return;            case TypeCode.String:            this.methodBodyHeap.Write((byte)0x72);            this.methodBodyHeap.Write((int)(this.GetUserStringIndex((String)literal.Value)|0x70000000));            return;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitLiteral,The following statement contains a magic number: switch (tc){          case TypeCode.Boolean:          case TypeCode.SByte:          case TypeCode.Byte:          case TypeCode.Char:          case TypeCode.Int16:          case TypeCode.UInt16:          case TypeCode.Int32:          case TypeCode.UInt32:          case TypeCode.Int64:            long n = ic.ToInt64(null);            switch (n){              case -1 : this.methodBodyHeap.Write((byte)0x15); break;              case 0 : this.methodBodyHeap.Write((byte)0x16); break;              case 1 : this.methodBodyHeap.Write((byte)0x17); break;              case 2 : this.methodBodyHeap.Write((byte)0x18); break;              case 3 : this.methodBodyHeap.Write((byte)0x19); break;              case 4 : this.methodBodyHeap.Write((byte)0x1a); break;              case 5 : this.methodBodyHeap.Write((byte)0x1b); break;              case 6 : this.methodBodyHeap.Write((byte)0x1c); break;              case 7 : this.methodBodyHeap.Write((byte)0x1d); break;              case 8 : this.methodBodyHeap.Write((byte)0x1e); break;              default:                if (n >= System.SByte.MinValue && n <= System.SByte.MaxValue){                  this.methodBodyHeap.Write((byte)0x1f);                  this.methodBodyHeap.Write((byte)n);                }else if (n >= System.Int32.MinValue && n <= System.Int32.MaxValue ||                  n <= System.UInt32.MaxValue && (tc == TypeCode.Char || tc == TypeCode.UInt16 || tc == TypeCode.UInt32)){                  if (n == System.UInt32.MaxValue && tc != TypeCode.Int64)                    this.methodBodyHeap.Write((byte)0x15);                  else{                    this.methodBodyHeap.Write((byte)0x20);                    this.methodBodyHeap.Write((int)n);                  }                }else{                  this.methodBodyHeap.Write((byte)0x21);                  this.methodBodyHeap.Write((long)n);                  tc = TypeCode.Empty; //Suppress conversion to long                }                break;            }            if (tc == TypeCode.Int64)              this.methodBodyHeap.Write((byte)0x6a);            return;            case TypeCode.UInt64:            this.methodBodyHeap.Write((byte)0x21);            this.methodBodyHeap.Write(ic.ToUInt64(null));            return;            case TypeCode.Single:            this.methodBodyHeap.Write((byte)0x22);            this.methodBodyHeap.Write(ic.ToSingle(null));            return;            case TypeCode.Double:            this.methodBodyHeap.Write((byte)0x23);            this.methodBodyHeap.Write(ic.ToDouble(null));            return;            case TypeCode.String:            this.methodBodyHeap.Write((byte)0x72);            this.methodBodyHeap.Write((int)(this.GetUserStringIndex((String)literal.Value)|0x70000000));            return;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitLiteral,The following statement contains a magic number: switch (tc){          case TypeCode.Boolean:          case TypeCode.SByte:          case TypeCode.Byte:          case TypeCode.Char:          case TypeCode.Int16:          case TypeCode.UInt16:          case TypeCode.Int32:          case TypeCode.UInt32:          case TypeCode.Int64:            long n = ic.ToInt64(null);            switch (n){              case -1 : this.methodBodyHeap.Write((byte)0x15); break;              case 0 : this.methodBodyHeap.Write((byte)0x16); break;              case 1 : this.methodBodyHeap.Write((byte)0x17); break;              case 2 : this.methodBodyHeap.Write((byte)0x18); break;              case 3 : this.methodBodyHeap.Write((byte)0x19); break;              case 4 : this.methodBodyHeap.Write((byte)0x1a); break;              case 5 : this.methodBodyHeap.Write((byte)0x1b); break;              case 6 : this.methodBodyHeap.Write((byte)0x1c); break;              case 7 : this.methodBodyHeap.Write((byte)0x1d); break;              case 8 : this.methodBodyHeap.Write((byte)0x1e); break;              default:                if (n >= System.SByte.MinValue && n <= System.SByte.MaxValue){                  this.methodBodyHeap.Write((byte)0x1f);                  this.methodBodyHeap.Write((byte)n);                }else if (n >= System.Int32.MinValue && n <= System.Int32.MaxValue ||                  n <= System.UInt32.MaxValue && (tc == TypeCode.Char || tc == TypeCode.UInt16 || tc == TypeCode.UInt32)){                  if (n == System.UInt32.MaxValue && tc != TypeCode.Int64)                    this.methodBodyHeap.Write((byte)0x15);                  else{                    this.methodBodyHeap.Write((byte)0x20);                    this.methodBodyHeap.Write((int)n);                  }                }else{                  this.methodBodyHeap.Write((byte)0x21);                  this.methodBodyHeap.Write((long)n);                  tc = TypeCode.Empty; //Suppress conversion to long                }                break;            }            if (tc == TypeCode.Int64)              this.methodBodyHeap.Write((byte)0x6a);            return;            case TypeCode.UInt64:            this.methodBodyHeap.Write((byte)0x21);            this.methodBodyHeap.Write(ic.ToUInt64(null));            return;            case TypeCode.Single:            this.methodBodyHeap.Write((byte)0x22);            this.methodBodyHeap.Write(ic.ToSingle(null));            return;            case TypeCode.Double:            this.methodBodyHeap.Write((byte)0x23);            this.methodBodyHeap.Write(ic.ToDouble(null));            return;            case TypeCode.String:            this.methodBodyHeap.Write((byte)0x72);            this.methodBodyHeap.Write((int)(this.GetUserStringIndex((String)literal.Value)|0x70000000));            return;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitLiteral,The following statement contains a magic number: switch (tc){          case TypeCode.Boolean:          case TypeCode.SByte:          case TypeCode.Byte:          case TypeCode.Char:          case TypeCode.Int16:          case TypeCode.UInt16:          case TypeCode.Int32:          case TypeCode.UInt32:          case TypeCode.Int64:            long n = ic.ToInt64(null);            switch (n){              case -1 : this.methodBodyHeap.Write((byte)0x15); break;              case 0 : this.methodBodyHeap.Write((byte)0x16); break;              case 1 : this.methodBodyHeap.Write((byte)0x17); break;              case 2 : this.methodBodyHeap.Write((byte)0x18); break;              case 3 : this.methodBodyHeap.Write((byte)0x19); break;              case 4 : this.methodBodyHeap.Write((byte)0x1a); break;              case 5 : this.methodBodyHeap.Write((byte)0x1b); break;              case 6 : this.methodBodyHeap.Write((byte)0x1c); break;              case 7 : this.methodBodyHeap.Write((byte)0x1d); break;              case 8 : this.methodBodyHeap.Write((byte)0x1e); break;              default:                if (n >= System.SByte.MinValue && n <= System.SByte.MaxValue){                  this.methodBodyHeap.Write((byte)0x1f);                  this.methodBodyHeap.Write((byte)n);                }else if (n >= System.Int32.MinValue && n <= System.Int32.MaxValue ||                  n <= System.UInt32.MaxValue && (tc == TypeCode.Char || tc == TypeCode.UInt16 || tc == TypeCode.UInt32)){                  if (n == System.UInt32.MaxValue && tc != TypeCode.Int64)                    this.methodBodyHeap.Write((byte)0x15);                  else{                    this.methodBodyHeap.Write((byte)0x20);                    this.methodBodyHeap.Write((int)n);                  }                }else{                  this.methodBodyHeap.Write((byte)0x21);                  this.methodBodyHeap.Write((long)n);                  tc = TypeCode.Empty; //Suppress conversion to long                }                break;            }            if (tc == TypeCode.Int64)              this.methodBodyHeap.Write((byte)0x6a);            return;            case TypeCode.UInt64:            this.methodBodyHeap.Write((byte)0x21);            this.methodBodyHeap.Write(ic.ToUInt64(null));            return;            case TypeCode.Single:            this.methodBodyHeap.Write((byte)0x22);            this.methodBodyHeap.Write(ic.ToSingle(null));            return;            case TypeCode.Double:            this.methodBodyHeap.Write((byte)0x23);            this.methodBodyHeap.Write(ic.ToDouble(null));            return;            case TypeCode.String:            this.methodBodyHeap.Write((byte)0x72);            this.methodBodyHeap.Write((int)(this.GetUserStringIndex((String)literal.Value)|0x70000000));            return;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitLiteral,The following statement contains a magic number: switch (tc){          case TypeCode.Boolean:          case TypeCode.SByte:          case TypeCode.Byte:          case TypeCode.Char:          case TypeCode.Int16:          case TypeCode.UInt16:          case TypeCode.Int32:          case TypeCode.UInt32:          case TypeCode.Int64:            long n = ic.ToInt64(null);            switch (n){              case -1 : this.methodBodyHeap.Write((byte)0x15); break;              case 0 : this.methodBodyHeap.Write((byte)0x16); break;              case 1 : this.methodBodyHeap.Write((byte)0x17); break;              case 2 : this.methodBodyHeap.Write((byte)0x18); break;              case 3 : this.methodBodyHeap.Write((byte)0x19); break;              case 4 : this.methodBodyHeap.Write((byte)0x1a); break;              case 5 : this.methodBodyHeap.Write((byte)0x1b); break;              case 6 : this.methodBodyHeap.Write((byte)0x1c); break;              case 7 : this.methodBodyHeap.Write((byte)0x1d); break;              case 8 : this.methodBodyHeap.Write((byte)0x1e); break;              default:                if (n >= System.SByte.MinValue && n <= System.SByte.MaxValue){                  this.methodBodyHeap.Write((byte)0x1f);                  this.methodBodyHeap.Write((byte)n);                }else if (n >= System.Int32.MinValue && n <= System.Int32.MaxValue ||                  n <= System.UInt32.MaxValue && (tc == TypeCode.Char || tc == TypeCode.UInt16 || tc == TypeCode.UInt32)){                  if (n == System.UInt32.MaxValue && tc != TypeCode.Int64)                    this.methodBodyHeap.Write((byte)0x15);                  else{                    this.methodBodyHeap.Write((byte)0x20);                    this.methodBodyHeap.Write((int)n);                  }                }else{                  this.methodBodyHeap.Write((byte)0x21);                  this.methodBodyHeap.Write((long)n);                  tc = TypeCode.Empty; //Suppress conversion to long                }                break;            }            if (tc == TypeCode.Int64)              this.methodBodyHeap.Write((byte)0x6a);            return;            case TypeCode.UInt64:            this.methodBodyHeap.Write((byte)0x21);            this.methodBodyHeap.Write(ic.ToUInt64(null));            return;            case TypeCode.Single:            this.methodBodyHeap.Write((byte)0x22);            this.methodBodyHeap.Write(ic.ToSingle(null));            return;            case TypeCode.Double:            this.methodBodyHeap.Write((byte)0x23);            this.methodBodyHeap.Write(ic.ToDouble(null));            return;            case TypeCode.String:            this.methodBodyHeap.Write((byte)0x72);            this.methodBodyHeap.Write((int)(this.GetUserStringIndex((String)literal.Value)|0x70000000));            return;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitLiteral,The following statement contains a magic number: switch (tc){          case TypeCode.Boolean:          case TypeCode.SByte:          case TypeCode.Byte:          case TypeCode.Char:          case TypeCode.Int16:          case TypeCode.UInt16:          case TypeCode.Int32:          case TypeCode.UInt32:          case TypeCode.Int64:            long n = ic.ToInt64(null);            switch (n){              case -1 : this.methodBodyHeap.Write((byte)0x15); break;              case 0 : this.methodBodyHeap.Write((byte)0x16); break;              case 1 : this.methodBodyHeap.Write((byte)0x17); break;              case 2 : this.methodBodyHeap.Write((byte)0x18); break;              case 3 : this.methodBodyHeap.Write((byte)0x19); break;              case 4 : this.methodBodyHeap.Write((byte)0x1a); break;              case 5 : this.methodBodyHeap.Write((byte)0x1b); break;              case 6 : this.methodBodyHeap.Write((byte)0x1c); break;              case 7 : this.methodBodyHeap.Write((byte)0x1d); break;              case 8 : this.methodBodyHeap.Write((byte)0x1e); break;              default:                if (n >= System.SByte.MinValue && n <= System.SByte.MaxValue){                  this.methodBodyHeap.Write((byte)0x1f);                  this.methodBodyHeap.Write((byte)n);                }else if (n >= System.Int32.MinValue && n <= System.Int32.MaxValue ||                  n <= System.UInt32.MaxValue && (tc == TypeCode.Char || tc == TypeCode.UInt16 || tc == TypeCode.UInt32)){                  if (n == System.UInt32.MaxValue && tc != TypeCode.Int64)                    this.methodBodyHeap.Write((byte)0x15);                  else{                    this.methodBodyHeap.Write((byte)0x20);                    this.methodBodyHeap.Write((int)n);                  }                }else{                  this.methodBodyHeap.Write((byte)0x21);                  this.methodBodyHeap.Write((long)n);                  tc = TypeCode.Empty; //Suppress conversion to long                }                break;            }            if (tc == TypeCode.Int64)              this.methodBodyHeap.Write((byte)0x6a);            return;            case TypeCode.UInt64:            this.methodBodyHeap.Write((byte)0x21);            this.methodBodyHeap.Write(ic.ToUInt64(null));            return;            case TypeCode.Single:            this.methodBodyHeap.Write((byte)0x22);            this.methodBodyHeap.Write(ic.ToSingle(null));            return;            case TypeCode.Double:            this.methodBodyHeap.Write((byte)0x23);            this.methodBodyHeap.Write(ic.ToDouble(null));            return;            case TypeCode.String:            this.methodBodyHeap.Write((byte)0x72);            this.methodBodyHeap.Write((int)(this.GetUserStringIndex((String)literal.Value)|0x70000000));            return;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitLiteral,The following statement contains a magic number: switch (tc){          case TypeCode.Boolean:          case TypeCode.SByte:          case TypeCode.Byte:          case TypeCode.Char:          case TypeCode.Int16:          case TypeCode.UInt16:          case TypeCode.Int32:          case TypeCode.UInt32:          case TypeCode.Int64:            long n = ic.ToInt64(null);            switch (n){              case -1 : this.methodBodyHeap.Write((byte)0x15); break;              case 0 : this.methodBodyHeap.Write((byte)0x16); break;              case 1 : this.methodBodyHeap.Write((byte)0x17); break;              case 2 : this.methodBodyHeap.Write((byte)0x18); break;              case 3 : this.methodBodyHeap.Write((byte)0x19); break;              case 4 : this.methodBodyHeap.Write((byte)0x1a); break;              case 5 : this.methodBodyHeap.Write((byte)0x1b); break;              case 6 : this.methodBodyHeap.Write((byte)0x1c); break;              case 7 : this.methodBodyHeap.Write((byte)0x1d); break;              case 8 : this.methodBodyHeap.Write((byte)0x1e); break;              default:                if (n >= System.SByte.MinValue && n <= System.SByte.MaxValue){                  this.methodBodyHeap.Write((byte)0x1f);                  this.methodBodyHeap.Write((byte)n);                }else if (n >= System.Int32.MinValue && n <= System.Int32.MaxValue ||                  n <= System.UInt32.MaxValue && (tc == TypeCode.Char || tc == TypeCode.UInt16 || tc == TypeCode.UInt32)){                  if (n == System.UInt32.MaxValue && tc != TypeCode.Int64)                    this.methodBodyHeap.Write((byte)0x15);                  else{                    this.methodBodyHeap.Write((byte)0x20);                    this.methodBodyHeap.Write((int)n);                  }                }else{                  this.methodBodyHeap.Write((byte)0x21);                  this.methodBodyHeap.Write((long)n);                  tc = TypeCode.Empty; //Suppress conversion to long                }                break;            }            if (tc == TypeCode.Int64)              this.methodBodyHeap.Write((byte)0x6a);            return;            case TypeCode.UInt64:            this.methodBodyHeap.Write((byte)0x21);            this.methodBodyHeap.Write(ic.ToUInt64(null));            return;            case TypeCode.Single:            this.methodBodyHeap.Write((byte)0x22);            this.methodBodyHeap.Write(ic.ToSingle(null));            return;            case TypeCode.Double:            this.methodBodyHeap.Write((byte)0x23);            this.methodBodyHeap.Write(ic.ToDouble(null));            return;            case TypeCode.String:            this.methodBodyHeap.Write((byte)0x72);            this.methodBodyHeap.Write((int)(this.GetUserStringIndex((String)literal.Value)|0x70000000));            return;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitMethodBody,The following statement contains a magic number: bool fatHeader = codeSize >= 64 || exceptionHandlersCount > 0 || maxStack > 8 || localVarSigTok != 0;
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitMethodBody,The following statement contains a magic number: bool fatHeader = codeSize >= 64 || exceptionHandlersCount > 0 || maxStack > 8 || localVarSigTok != 0;
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitMethodBody,The following statement contains a magic number: if (fatHeader) {          //Emit fat header          byte header = 0x03;          if (method.InitLocals) header |= 0x10;          if (exceptionHandlersCount > 0) header |= 0x08;          this.methodBodiesHeap.Write((byte)header);          this.methodBodiesHeap.Write((byte)0x30); //top 4 bits represent length of fat header in dwords. Heaven only knows why.          this.methodBodiesHeap.Write((short)maxStack);          this.methodBodiesHeap.Write((int)codeSize);          if (localVarSigTok != 0){            if (this.methodInfo.localVarIndex.Count > 127){              //Need to make space for the two byte count              this.methodInfo.localVarSignature.Write((byte)0);              byte[] buf = this.methodInfo.localVarSignature.BaseStream.Buffer;              int n = buf.Length;              for (int i = n-2; i > 1; i--) buf[i+1] = buf[i];                        }            this.methodInfo.localVarSignature.BaseStream.Position = 0;            this.methodInfo.localVarSignature.Write((byte)7);            Ir2md.WriteCompressedInt(this.methodInfo.localVarSignature' this.methodInfo.localVarIndex.Count);            Debug.Assert(this.methodInfo.localVarIndex.Count <= 0xFFFE);          }          this.methodBodiesHeap.Write((int)localVarSigTok);        }else{          //Emit tiny header          this.methodBodiesHeap.Write((byte)(codeSize<<2 | 2));        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitMethodBody,The following statement contains a magic number: if (fatHeader) {          //Emit fat header          byte header = 0x03;          if (method.InitLocals) header |= 0x10;          if (exceptionHandlersCount > 0) header |= 0x08;          this.methodBodiesHeap.Write((byte)header);          this.methodBodiesHeap.Write((byte)0x30); //top 4 bits represent length of fat header in dwords. Heaven only knows why.          this.methodBodiesHeap.Write((short)maxStack);          this.methodBodiesHeap.Write((int)codeSize);          if (localVarSigTok != 0){            if (this.methodInfo.localVarIndex.Count > 127){              //Need to make space for the two byte count              this.methodInfo.localVarSignature.Write((byte)0);              byte[] buf = this.methodInfo.localVarSignature.BaseStream.Buffer;              int n = buf.Length;              for (int i = n-2; i > 1; i--) buf[i+1] = buf[i];                        }            this.methodInfo.localVarSignature.BaseStream.Position = 0;            this.methodInfo.localVarSignature.Write((byte)7);            Ir2md.WriteCompressedInt(this.methodInfo.localVarSignature' this.methodInfo.localVarIndex.Count);            Debug.Assert(this.methodInfo.localVarIndex.Count <= 0xFFFE);          }          this.methodBodiesHeap.Write((int)localVarSigTok);        }else{          //Emit tiny header          this.methodBodiesHeap.Write((byte)(codeSize<<2 | 2));        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitMethodBody,The following statement contains a magic number: if (fatHeader) {          //Emit fat header          byte header = 0x03;          if (method.InitLocals) header |= 0x10;          if (exceptionHandlersCount > 0) header |= 0x08;          this.methodBodiesHeap.Write((byte)header);          this.methodBodiesHeap.Write((byte)0x30); //top 4 bits represent length of fat header in dwords. Heaven only knows why.          this.methodBodiesHeap.Write((short)maxStack);          this.methodBodiesHeap.Write((int)codeSize);          if (localVarSigTok != 0){            if (this.methodInfo.localVarIndex.Count > 127){              //Need to make space for the two byte count              this.methodInfo.localVarSignature.Write((byte)0);              byte[] buf = this.methodInfo.localVarSignature.BaseStream.Buffer;              int n = buf.Length;              for (int i = n-2; i > 1; i--) buf[i+1] = buf[i];                        }            this.methodInfo.localVarSignature.BaseStream.Position = 0;            this.methodInfo.localVarSignature.Write((byte)7);            Ir2md.WriteCompressedInt(this.methodInfo.localVarSignature' this.methodInfo.localVarIndex.Count);            Debug.Assert(this.methodInfo.localVarIndex.Count <= 0xFFFE);          }          this.methodBodiesHeap.Write((int)localVarSigTok);        }else{          //Emit tiny header          this.methodBodiesHeap.Write((byte)(codeSize<<2 | 2));        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitMethodBody,The following statement contains a magic number: if (fatHeader) {          //Emit fat header          byte header = 0x03;          if (method.InitLocals) header |= 0x10;          if (exceptionHandlersCount > 0) header |= 0x08;          this.methodBodiesHeap.Write((byte)header);          this.methodBodiesHeap.Write((byte)0x30); //top 4 bits represent length of fat header in dwords. Heaven only knows why.          this.methodBodiesHeap.Write((short)maxStack);          this.methodBodiesHeap.Write((int)codeSize);          if (localVarSigTok != 0){            if (this.methodInfo.localVarIndex.Count > 127){              //Need to make space for the two byte count              this.methodInfo.localVarSignature.Write((byte)0);              byte[] buf = this.methodInfo.localVarSignature.BaseStream.Buffer;              int n = buf.Length;              for (int i = n-2; i > 1; i--) buf[i+1] = buf[i];                        }            this.methodInfo.localVarSignature.BaseStream.Position = 0;            this.methodInfo.localVarSignature.Write((byte)7);            Ir2md.WriteCompressedInt(this.methodInfo.localVarSignature' this.methodInfo.localVarIndex.Count);            Debug.Assert(this.methodInfo.localVarIndex.Count <= 0xFFFE);          }          this.methodBodiesHeap.Write((int)localVarSigTok);        }else{          //Emit tiny header          this.methodBodiesHeap.Write((byte)(codeSize<<2 | 2));        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitMethodBody,The following statement contains a magic number: if (fatHeader) {          //Emit fat header          byte header = 0x03;          if (method.InitLocals) header |= 0x10;          if (exceptionHandlersCount > 0) header |= 0x08;          this.methodBodiesHeap.Write((byte)header);          this.methodBodiesHeap.Write((byte)0x30); //top 4 bits represent length of fat header in dwords. Heaven only knows why.          this.methodBodiesHeap.Write((short)maxStack);          this.methodBodiesHeap.Write((int)codeSize);          if (localVarSigTok != 0){            if (this.methodInfo.localVarIndex.Count > 127){              //Need to make space for the two byte count              this.methodInfo.localVarSignature.Write((byte)0);              byte[] buf = this.methodInfo.localVarSignature.BaseStream.Buffer;              int n = buf.Length;              for (int i = n-2; i > 1; i--) buf[i+1] = buf[i];                        }            this.methodInfo.localVarSignature.BaseStream.Position = 0;            this.methodInfo.localVarSignature.Write((byte)7);            Ir2md.WriteCompressedInt(this.methodInfo.localVarSignature' this.methodInfo.localVarIndex.Count);            Debug.Assert(this.methodInfo.localVarIndex.Count <= 0xFFFE);          }          this.methodBodiesHeap.Write((int)localVarSigTok);        }else{          //Emit tiny header          this.methodBodiesHeap.Write((byte)(codeSize<<2 | 2));        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitMethodBody,The following statement contains a magic number: while (pad % 4 != 0){ pad++; this.methodBodiesHeap.Write((byte)0);}
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitMethodBody,The following statement contains a magic number: if (fatHeader) {          //Emit exception handler entries          int[] tryOffsets = new int[exceptionHandlersCount];          int[] tryLengths = new int[exceptionHandlersCount];          int[] handlerOffsets = new int[exceptionHandlersCount];          int[] handlerLengths = new int[exceptionHandlersCount];          bool fatFormat = false;          for (int i = 0; i < exceptionHandlersCount; i++) {            ExceptionHandler eh = method.ExceptionHandlers[i];            int tryOffset = tryOffsets[i] = (int)this.methodInfo.fixupIndex[eh.TryStartBlock.UniqueKey];            int tryLength = tryLengths[i] = ((int)this.methodInfo.fixupIndex[eh.BlockAfterTryEnd.UniqueKey]) - tryOffset;            int handlerOffset = handlerOffsets[i] = (int)this.methodInfo.fixupIndex[eh.HandlerStartBlock.UniqueKey];            int handlerLength = handlerLengths[i] = ((int)this.methodInfo.fixupIndex[eh.BlockAfterHandlerEnd.UniqueKey]) - handlerOffset;            if (tryOffset > 0xffff || tryLength > 0xff || handlerOffset > 0xffff || handlerLength > 0xff) fatFormat = true;          }          if (exceptionHandlersCount*12 > 0xff) fatFormat = true;          if (fatFormat) {            int dataSize = exceptionHandlersCount*24+4;            this.methodBodiesHeap.Write((byte)0x41);            this.methodBodiesHeap.Write((byte)(dataSize & 0xff));            this.methodBodiesHeap.Write((short)((dataSize >> 8) & 0xffff));          } else {            int dataSize = exceptionHandlersCount*12+4;            this.methodBodiesHeap.Write((byte)0x01);            this.methodBodiesHeap.Write((byte)dataSize);            this.methodBodiesHeap.Write((short)0);          }          for (int i = 0; i < exceptionHandlersCount; i++) {            ExceptionHandler eh = method.ExceptionHandlers[i];            byte flags = 0;            switch (eh.HandlerType) {              case NodeType.Filter: flags = 0x0001; break;              case NodeType.Finally: flags = 0x0002; break;              case NodeType.FaultHandler: flags = 0x0004; break;            }            if (fatFormat) {              this.methodBodiesHeap.Write((int)flags);              this.methodBodiesHeap.Write((int)tryOffsets[i]);              this.methodBodiesHeap.Write((int)tryLengths[i]);              this.methodBodiesHeap.Write((int)handlerOffsets[i]);              this.methodBodiesHeap.Write((int)handlerLengths[i]);            } else {              this.methodBodiesHeap.Write((short)flags);              this.methodBodiesHeap.Write((ushort)tryOffsets[i]);              this.methodBodiesHeap.Write((byte)tryLengths[i]);              this.methodBodiesHeap.Write((ushort)handlerOffsets[i]);              this.methodBodiesHeap.Write((byte)handlerLengths[i]);            }            if (eh.FilterType != null)              this.methodBodiesHeap.Write((int)this.GetTypeToken(eh.FilterType));            else if (eh.FilterExpression != null)              this.methodBodiesHeap.Write((int)this.methodInfo.fixupIndex[eh.FilterExpression.UniqueKey]);            else              this.methodBodiesHeap.Write((int)0);          }        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitMethodBody,The following statement contains a magic number: if (fatHeader) {          //Emit exception handler entries          int[] tryOffsets = new int[exceptionHandlersCount];          int[] tryLengths = new int[exceptionHandlersCount];          int[] handlerOffsets = new int[exceptionHandlersCount];          int[] handlerLengths = new int[exceptionHandlersCount];          bool fatFormat = false;          for (int i = 0; i < exceptionHandlersCount; i++) {            ExceptionHandler eh = method.ExceptionHandlers[i];            int tryOffset = tryOffsets[i] = (int)this.methodInfo.fixupIndex[eh.TryStartBlock.UniqueKey];            int tryLength = tryLengths[i] = ((int)this.methodInfo.fixupIndex[eh.BlockAfterTryEnd.UniqueKey]) - tryOffset;            int handlerOffset = handlerOffsets[i] = (int)this.methodInfo.fixupIndex[eh.HandlerStartBlock.UniqueKey];            int handlerLength = handlerLengths[i] = ((int)this.methodInfo.fixupIndex[eh.BlockAfterHandlerEnd.UniqueKey]) - handlerOffset;            if (tryOffset > 0xffff || tryLength > 0xff || handlerOffset > 0xffff || handlerLength > 0xff) fatFormat = true;          }          if (exceptionHandlersCount*12 > 0xff) fatFormat = true;          if (fatFormat) {            int dataSize = exceptionHandlersCount*24+4;            this.methodBodiesHeap.Write((byte)0x41);            this.methodBodiesHeap.Write((byte)(dataSize & 0xff));            this.methodBodiesHeap.Write((short)((dataSize >> 8) & 0xffff));          } else {            int dataSize = exceptionHandlersCount*12+4;            this.methodBodiesHeap.Write((byte)0x01);            this.methodBodiesHeap.Write((byte)dataSize);            this.methodBodiesHeap.Write((short)0);          }          for (int i = 0; i < exceptionHandlersCount; i++) {            ExceptionHandler eh = method.ExceptionHandlers[i];            byte flags = 0;            switch (eh.HandlerType) {              case NodeType.Filter: flags = 0x0001; break;              case NodeType.Finally: flags = 0x0002; break;              case NodeType.FaultHandler: flags = 0x0004; break;            }            if (fatFormat) {              this.methodBodiesHeap.Write((int)flags);              this.methodBodiesHeap.Write((int)tryOffsets[i]);              this.methodBodiesHeap.Write((int)tryLengths[i]);              this.methodBodiesHeap.Write((int)handlerOffsets[i]);              this.methodBodiesHeap.Write((int)handlerLengths[i]);            } else {              this.methodBodiesHeap.Write((short)flags);              this.methodBodiesHeap.Write((ushort)tryOffsets[i]);              this.methodBodiesHeap.Write((byte)tryLengths[i]);              this.methodBodiesHeap.Write((ushort)handlerOffsets[i]);              this.methodBodiesHeap.Write((byte)handlerLengths[i]);            }            if (eh.FilterType != null)              this.methodBodiesHeap.Write((int)this.GetTypeToken(eh.FilterType));            else if (eh.FilterExpression != null)              this.methodBodiesHeap.Write((int)this.methodInfo.fixupIndex[eh.FilterExpression.UniqueKey]);            else              this.methodBodiesHeap.Write((int)0);          }        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitMethodBody,The following statement contains a magic number: if (fatHeader) {          //Emit exception handler entries          int[] tryOffsets = new int[exceptionHandlersCount];          int[] tryLengths = new int[exceptionHandlersCount];          int[] handlerOffsets = new int[exceptionHandlersCount];          int[] handlerLengths = new int[exceptionHandlersCount];          bool fatFormat = false;          for (int i = 0; i < exceptionHandlersCount; i++) {            ExceptionHandler eh = method.ExceptionHandlers[i];            int tryOffset = tryOffsets[i] = (int)this.methodInfo.fixupIndex[eh.TryStartBlock.UniqueKey];            int tryLength = tryLengths[i] = ((int)this.methodInfo.fixupIndex[eh.BlockAfterTryEnd.UniqueKey]) - tryOffset;            int handlerOffset = handlerOffsets[i] = (int)this.methodInfo.fixupIndex[eh.HandlerStartBlock.UniqueKey];            int handlerLength = handlerLengths[i] = ((int)this.methodInfo.fixupIndex[eh.BlockAfterHandlerEnd.UniqueKey]) - handlerOffset;            if (tryOffset > 0xffff || tryLength > 0xff || handlerOffset > 0xffff || handlerLength > 0xff) fatFormat = true;          }          if (exceptionHandlersCount*12 > 0xff) fatFormat = true;          if (fatFormat) {            int dataSize = exceptionHandlersCount*24+4;            this.methodBodiesHeap.Write((byte)0x41);            this.methodBodiesHeap.Write((byte)(dataSize & 0xff));            this.methodBodiesHeap.Write((short)((dataSize >> 8) & 0xffff));          } else {            int dataSize = exceptionHandlersCount*12+4;            this.methodBodiesHeap.Write((byte)0x01);            this.methodBodiesHeap.Write((byte)dataSize);            this.methodBodiesHeap.Write((short)0);          }          for (int i = 0; i < exceptionHandlersCount; i++) {            ExceptionHandler eh = method.ExceptionHandlers[i];            byte flags = 0;            switch (eh.HandlerType) {              case NodeType.Filter: flags = 0x0001; break;              case NodeType.Finally: flags = 0x0002; break;              case NodeType.FaultHandler: flags = 0x0004; break;            }            if (fatFormat) {              this.methodBodiesHeap.Write((int)flags);              this.methodBodiesHeap.Write((int)tryOffsets[i]);              this.methodBodiesHeap.Write((int)tryLengths[i]);              this.methodBodiesHeap.Write((int)handlerOffsets[i]);              this.methodBodiesHeap.Write((int)handlerLengths[i]);            } else {              this.methodBodiesHeap.Write((short)flags);              this.methodBodiesHeap.Write((ushort)tryOffsets[i]);              this.methodBodiesHeap.Write((byte)tryLengths[i]);              this.methodBodiesHeap.Write((ushort)handlerOffsets[i]);              this.methodBodiesHeap.Write((byte)handlerLengths[i]);            }            if (eh.FilterType != null)              this.methodBodiesHeap.Write((int)this.GetTypeToken(eh.FilterType));            else if (eh.FilterExpression != null)              this.methodBodiesHeap.Write((int)this.methodInfo.fixupIndex[eh.FilterExpression.UniqueKey]);            else              this.methodBodiesHeap.Write((int)0);          }        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitMethodBody,The following statement contains a magic number: if (fatHeader) {          //Emit exception handler entries          int[] tryOffsets = new int[exceptionHandlersCount];          int[] tryLengths = new int[exceptionHandlersCount];          int[] handlerOffsets = new int[exceptionHandlersCount];          int[] handlerLengths = new int[exceptionHandlersCount];          bool fatFormat = false;          for (int i = 0; i < exceptionHandlersCount; i++) {            ExceptionHandler eh = method.ExceptionHandlers[i];            int tryOffset = tryOffsets[i] = (int)this.methodInfo.fixupIndex[eh.TryStartBlock.UniqueKey];            int tryLength = tryLengths[i] = ((int)this.methodInfo.fixupIndex[eh.BlockAfterTryEnd.UniqueKey]) - tryOffset;            int handlerOffset = handlerOffsets[i] = (int)this.methodInfo.fixupIndex[eh.HandlerStartBlock.UniqueKey];            int handlerLength = handlerLengths[i] = ((int)this.methodInfo.fixupIndex[eh.BlockAfterHandlerEnd.UniqueKey]) - handlerOffset;            if (tryOffset > 0xffff || tryLength > 0xff || handlerOffset > 0xffff || handlerLength > 0xff) fatFormat = true;          }          if (exceptionHandlersCount*12 > 0xff) fatFormat = true;          if (fatFormat) {            int dataSize = exceptionHandlersCount*24+4;            this.methodBodiesHeap.Write((byte)0x41);            this.methodBodiesHeap.Write((byte)(dataSize & 0xff));            this.methodBodiesHeap.Write((short)((dataSize >> 8) & 0xffff));          } else {            int dataSize = exceptionHandlersCount*12+4;            this.methodBodiesHeap.Write((byte)0x01);            this.methodBodiesHeap.Write((byte)dataSize);            this.methodBodiesHeap.Write((short)0);          }          for (int i = 0; i < exceptionHandlersCount; i++) {            ExceptionHandler eh = method.ExceptionHandlers[i];            byte flags = 0;            switch (eh.HandlerType) {              case NodeType.Filter: flags = 0x0001; break;              case NodeType.Finally: flags = 0x0002; break;              case NodeType.FaultHandler: flags = 0x0004; break;            }            if (fatFormat) {              this.methodBodiesHeap.Write((int)flags);              this.methodBodiesHeap.Write((int)tryOffsets[i]);              this.methodBodiesHeap.Write((int)tryLengths[i]);              this.methodBodiesHeap.Write((int)handlerOffsets[i]);              this.methodBodiesHeap.Write((int)handlerLengths[i]);            } else {              this.methodBodiesHeap.Write((short)flags);              this.methodBodiesHeap.Write((ushort)tryOffsets[i]);              this.methodBodiesHeap.Write((byte)tryLengths[i]);              this.methodBodiesHeap.Write((ushort)handlerOffsets[i]);              this.methodBodiesHeap.Write((byte)handlerLengths[i]);            }            if (eh.FilterType != null)              this.methodBodiesHeap.Write((int)this.GetTypeToken(eh.FilterType));            else if (eh.FilterExpression != null)              this.methodBodiesHeap.Write((int)this.methodInfo.fixupIndex[eh.FilterExpression.UniqueKey]);            else              this.methodBodiesHeap.Write((int)0);          }        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitMethodBody,The following statement contains a magic number: if (fatHeader) {          //Emit exception handler entries          int[] tryOffsets = new int[exceptionHandlersCount];          int[] tryLengths = new int[exceptionHandlersCount];          int[] handlerOffsets = new int[exceptionHandlersCount];          int[] handlerLengths = new int[exceptionHandlersCount];          bool fatFormat = false;          for (int i = 0; i < exceptionHandlersCount; i++) {            ExceptionHandler eh = method.ExceptionHandlers[i];            int tryOffset = tryOffsets[i] = (int)this.methodInfo.fixupIndex[eh.TryStartBlock.UniqueKey];            int tryLength = tryLengths[i] = ((int)this.methodInfo.fixupIndex[eh.BlockAfterTryEnd.UniqueKey]) - tryOffset;            int handlerOffset = handlerOffsets[i] = (int)this.methodInfo.fixupIndex[eh.HandlerStartBlock.UniqueKey];            int handlerLength = handlerLengths[i] = ((int)this.methodInfo.fixupIndex[eh.BlockAfterHandlerEnd.UniqueKey]) - handlerOffset;            if (tryOffset > 0xffff || tryLength > 0xff || handlerOffset > 0xffff || handlerLength > 0xff) fatFormat = true;          }          if (exceptionHandlersCount*12 > 0xff) fatFormat = true;          if (fatFormat) {            int dataSize = exceptionHandlersCount*24+4;            this.methodBodiesHeap.Write((byte)0x41);            this.methodBodiesHeap.Write((byte)(dataSize & 0xff));            this.methodBodiesHeap.Write((short)((dataSize >> 8) & 0xffff));          } else {            int dataSize = exceptionHandlersCount*12+4;            this.methodBodiesHeap.Write((byte)0x01);            this.methodBodiesHeap.Write((byte)dataSize);            this.methodBodiesHeap.Write((short)0);          }          for (int i = 0; i < exceptionHandlersCount; i++) {            ExceptionHandler eh = method.ExceptionHandlers[i];            byte flags = 0;            switch (eh.HandlerType) {              case NodeType.Filter: flags = 0x0001; break;              case NodeType.Finally: flags = 0x0002; break;              case NodeType.FaultHandler: flags = 0x0004; break;            }            if (fatFormat) {              this.methodBodiesHeap.Write((int)flags);              this.methodBodiesHeap.Write((int)tryOffsets[i]);              this.methodBodiesHeap.Write((int)tryLengths[i]);              this.methodBodiesHeap.Write((int)handlerOffsets[i]);              this.methodBodiesHeap.Write((int)handlerLengths[i]);            } else {              this.methodBodiesHeap.Write((short)flags);              this.methodBodiesHeap.Write((ushort)tryOffsets[i]);              this.methodBodiesHeap.Write((byte)tryLengths[i]);              this.methodBodiesHeap.Write((ushort)handlerOffsets[i]);              this.methodBodiesHeap.Write((byte)handlerLengths[i]);            }            if (eh.FilterType != null)              this.methodBodiesHeap.Write((int)this.GetTypeToken(eh.FilterType));            else if (eh.FilterExpression != null)              this.methodBodiesHeap.Write((int)this.methodInfo.fixupIndex[eh.FilterExpression.UniqueKey]);            else              this.methodBodiesHeap.Write((int)0);          }        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitMethodBody,The following statement contains a magic number: if (fatHeader) {          //Emit exception handler entries          int[] tryOffsets = new int[exceptionHandlersCount];          int[] tryLengths = new int[exceptionHandlersCount];          int[] handlerOffsets = new int[exceptionHandlersCount];          int[] handlerLengths = new int[exceptionHandlersCount];          bool fatFormat = false;          for (int i = 0; i < exceptionHandlersCount; i++) {            ExceptionHandler eh = method.ExceptionHandlers[i];            int tryOffset = tryOffsets[i] = (int)this.methodInfo.fixupIndex[eh.TryStartBlock.UniqueKey];            int tryLength = tryLengths[i] = ((int)this.methodInfo.fixupIndex[eh.BlockAfterTryEnd.UniqueKey]) - tryOffset;            int handlerOffset = handlerOffsets[i] = (int)this.methodInfo.fixupIndex[eh.HandlerStartBlock.UniqueKey];            int handlerLength = handlerLengths[i] = ((int)this.methodInfo.fixupIndex[eh.BlockAfterHandlerEnd.UniqueKey]) - handlerOffset;            if (tryOffset > 0xffff || tryLength > 0xff || handlerOffset > 0xffff || handlerLength > 0xff) fatFormat = true;          }          if (exceptionHandlersCount*12 > 0xff) fatFormat = true;          if (fatFormat) {            int dataSize = exceptionHandlersCount*24+4;            this.methodBodiesHeap.Write((byte)0x41);            this.methodBodiesHeap.Write((byte)(dataSize & 0xff));            this.methodBodiesHeap.Write((short)((dataSize >> 8) & 0xffff));          } else {            int dataSize = exceptionHandlersCount*12+4;            this.methodBodiesHeap.Write((byte)0x01);            this.methodBodiesHeap.Write((byte)dataSize);            this.methodBodiesHeap.Write((short)0);          }          for (int i = 0; i < exceptionHandlersCount; i++) {            ExceptionHandler eh = method.ExceptionHandlers[i];            byte flags = 0;            switch (eh.HandlerType) {              case NodeType.Filter: flags = 0x0001; break;              case NodeType.Finally: flags = 0x0002; break;              case NodeType.FaultHandler: flags = 0x0004; break;            }            if (fatFormat) {              this.methodBodiesHeap.Write((int)flags);              this.methodBodiesHeap.Write((int)tryOffsets[i]);              this.methodBodiesHeap.Write((int)tryLengths[i]);              this.methodBodiesHeap.Write((int)handlerOffsets[i]);              this.methodBodiesHeap.Write((int)handlerLengths[i]);            } else {              this.methodBodiesHeap.Write((short)flags);              this.methodBodiesHeap.Write((ushort)tryOffsets[i]);              this.methodBodiesHeap.Write((byte)tryLengths[i]);              this.methodBodiesHeap.Write((ushort)handlerOffsets[i]);              this.methodBodiesHeap.Write((byte)handlerLengths[i]);            }            if (eh.FilterType != null)              this.methodBodiesHeap.Write((int)this.GetTypeToken(eh.FilterType));            else if (eh.FilterExpression != null)              this.methodBodiesHeap.Write((int)this.methodInfo.fixupIndex[eh.FilterExpression.UniqueKey]);            else              this.methodBodiesHeap.Write((int)0);          }        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitParameter,The following statement contains a magic number: switch(pi){          case 0: this.methodBodyHeap.Write((byte)0x02); return;          case 1: this.methodBodyHeap.Write((byte)0x03); return;          case 2: this.methodBodyHeap.Write((byte)0x04); return;          case 3: this.methodBodyHeap.Write((byte)0x05); return;          default:            if (pi < 256){              this.methodBodyHeap.Write((byte)0x0e);              this.methodBodyHeap.Write((byte)pi);            }else{              this.methodBodyHeap.Write((byte)0xfe);              this.methodBodyHeap.Write((byte)0x09);              this.methodBodyHeap.Write((ushort)pi);            }            return;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitParameter,The following statement contains a magic number: switch(pi){          case 0: this.methodBodyHeap.Write((byte)0x02); return;          case 1: this.methodBodyHeap.Write((byte)0x03); return;          case 2: this.methodBodyHeap.Write((byte)0x04); return;          case 3: this.methodBodyHeap.Write((byte)0x05); return;          default:            if (pi < 256){              this.methodBodyHeap.Write((byte)0x0e);              this.methodBodyHeap.Write((byte)pi);            }else{              this.methodBodyHeap.Write((byte)0xfe);              this.methodBodyHeap.Write((byte)0x09);              this.methodBodyHeap.Write((ushort)pi);            }            return;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitParameter,The following statement contains a magic number: switch(pi){          case 0: this.methodBodyHeap.Write((byte)0x02); return;          case 1: this.methodBodyHeap.Write((byte)0x03); return;          case 2: this.methodBodyHeap.Write((byte)0x04); return;          case 3: this.methodBodyHeap.Write((byte)0x05); return;          default:            if (pi < 256){              this.methodBodyHeap.Write((byte)0x0e);              this.methodBodyHeap.Write((byte)pi);            }else{              this.methodBodyHeap.Write((byte)0xfe);              this.methodBodyHeap.Write((byte)0x09);              this.methodBodyHeap.Write((ushort)pi);            }            return;        }
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitSwitchInstruction,The following statement contains a magic number: int addressOfNextInstruction = ((int)this.methodBodyHeap.BaseStream.Position) + 5 + 4*n;
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitSwitchInstruction,The following statement contains a magic number: int addressOfNextInstruction = ((int)this.methodBodyHeap.BaseStream.Position) + 5 + 4*n;
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitTernaryExpression,The following statement contains a magic number: this.stackHeight-=3;
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,WriteCompressedInt,The following statement contains a magic number: if (val <= 0x7f)          target.Write((byte)val);        else if (val < 0x3fff){          target.Write((byte)((val >> 8)|0x80));          target.Write((byte)(val & 0xff));        }else if (val < 0x1fffffff){          target.Write((byte)((val >> 24)|0xc0));          target.Write((byte)((val & 0xff0000)>>16));          target.Write((byte)((val & 0xff00)>>8));          target.Write((byte)(val & 0xff));        }else          Debug.Assert(false' "index too large for compression");
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,WriteCompressedInt,The following statement contains a magic number: if (val <= 0x7f)          target.Write((byte)val);        else if (val < 0x3fff){          target.Write((byte)((val >> 8)|0x80));          target.Write((byte)(val & 0xff));        }else if (val < 0x1fffffff){          target.Write((byte)((val >> 24)|0xc0));          target.Write((byte)((val & 0xff0000)>>16));          target.Write((byte)((val & 0xff00)>>8));          target.Write((byte)(val & 0xff));        }else          Debug.Assert(false' "index too large for compression");
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,WriteCompressedInt,The following statement contains a magic number: if (val <= 0x7f)          target.Write((byte)val);        else if (val < 0x3fff){          target.Write((byte)((val >> 8)|0x80));          target.Write((byte)(val & 0xff));        }else if (val < 0x1fffffff){          target.Write((byte)((val >> 24)|0xc0));          target.Write((byte)((val & 0xff0000)>>16));          target.Write((byte)((val & 0xff00)>>8));          target.Write((byte)(val & 0xff));        }else          Debug.Assert(false' "index too large for compression");
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,WriteCompressedInt,The following statement contains a magic number: if (val <= 0x7f)          target.Write((byte)val);        else if (val < 0x3fff){          target.Write((byte)((val >> 8)|0x80));          target.Write((byte)(val & 0xff));        }else if (val < 0x1fffffff){          target.Write((byte)((val >> 24)|0xc0));          target.Write((byte)((val & 0xff0000)>>16));          target.Write((byte)((val & 0xff00)>>8));          target.Write((byte)(val & 0xff));        }else          Debug.Assert(false' "index too large for compression");
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,WriteTypeDefEncoded,The following statement contains a magic number: Ir2md.WriteCompressedInt(target' (tok << 2));
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,WriteTypeRefEncoded,The following statement contains a magic number: Ir2md.WriteCompressedInt(target' (tok << 2)|1);
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,WriteTypeSpecEncoded,The following statement contains a magic number: Ir2md.WriteCompressedInt(target' (tok << 2)|2);
Magic Number,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,WriteTypeSpecEncoded,The following statement contains a magic number: Ir2md.WriteCompressedInt(target' (tok << 2)|2);
Magic Number,Microsoft.Cci,ByteArrayKeyComparer,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetHashCode,The following statement contains a magic number: for (int i = 0' n = xa.Length; i < n; i++)          hcode = hcode * 17 + xa[i];
Magic Number,Microsoft.Cci,Writer,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,WritePE,The following statement contains a magic number: if (options == null)          Writer.WritePE(module.Location' compilerParameters.IncludeDebugInformation' module' false' null' null);        else{          if (options.FileAlignment > 512) module.FileAlignment = options.FileAlignment;          Writer.WritePE(module.Location' options.IncludeDebugInformation' module' options.DelaySign' options.AssemblyKeyFile' options.AssemblyKeyName);        }
Magic Number,Microsoft.Cci,Writer,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,AddWin32Icon,The following statement contains a magic number: for (int i = 0; i < imageCount; i++){          resource = new Win32Resource();          resource.CodePage = 0;          resource.Id = module.Win32Resources.Count+2;          resource.LanguageId = 0;          resource.Name = null;          resource.TypeId = 3;          resource.TypeName = null;          indexHeap.Write(cursor.ReadByte()); //width          indexHeap.Write(cursor.ReadByte()); //height          indexHeap.Write(cursor.ReadByte()); //color count          indexHeap.Write(cursor.ReadByte()); //reserved          indexHeap.Write(cursor.ReadUInt16()); //planes          indexHeap.Write(cursor.ReadUInt16()); //bit count          int len = cursor.ReadInt32();          int offset = cursor.ReadInt32();          indexHeap.Write((int)len);          indexHeap.Write((int)module.Win32Resources.Count+2);          MemoryCursor c = new MemoryCursor(cursor);          c.Position = offset;          resource.Data = c.ReadBytes(len);          module.Win32Resources.Add(resource);        }
Magic Number,Microsoft.Cci,Writer,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,AddWin32Icon,The following statement contains a magic number: for (int i = 0; i < imageCount; i++){          resource = new Win32Resource();          resource.CodePage = 0;          resource.Id = module.Win32Resources.Count+2;          resource.LanguageId = 0;          resource.Name = null;          resource.TypeId = 3;          resource.TypeName = null;          indexHeap.Write(cursor.ReadByte()); //width          indexHeap.Write(cursor.ReadByte()); //height          indexHeap.Write(cursor.ReadByte()); //color count          indexHeap.Write(cursor.ReadByte()); //reserved          indexHeap.Write(cursor.ReadUInt16()); //planes          indexHeap.Write(cursor.ReadUInt16()); //bit count          int len = cursor.ReadInt32();          int offset = cursor.ReadInt32();          indexHeap.Write((int)len);          indexHeap.Write((int)module.Win32Resources.Count+2);          MemoryCursor c = new MemoryCursor(cursor);          c.Position = offset;          resource.Data = c.ReadBytes(len);          module.Win32Resources.Add(resource);        }
Magic Number,Microsoft.Cci,Writer,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,AddWin32Icon,The following statement contains a magic number: for (int i = 0; i < imageCount; i++){          resource = new Win32Resource();          resource.CodePage = 0;          resource.Id = module.Win32Resources.Count+2;          resource.LanguageId = 0;          resource.Name = null;          resource.TypeId = 3;          resource.TypeName = null;          indexHeap.Write(cursor.ReadByte()); //width          indexHeap.Write(cursor.ReadByte()); //height          indexHeap.Write(cursor.ReadByte()); //color count          indexHeap.Write(cursor.ReadByte()); //reserved          indexHeap.Write(cursor.ReadUInt16()); //planes          indexHeap.Write(cursor.ReadUInt16()); //bit count          int len = cursor.ReadInt32();          int offset = cursor.ReadInt32();          indexHeap.Write((int)len);          indexHeap.Write((int)module.Win32Resources.Count+2);          MemoryCursor c = new MemoryCursor(cursor);          c.Position = offset;          resource.Data = c.ReadBytes(len);          module.Win32Resources.Add(resource);        }
Magic Number,Microsoft.Cci,Writer,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,FillInVsVersionStructure,The following statement contains a magic number: if (options.GenerateExecutable)          data.Write((uint)1); //App        else          data.Write((uint)2);
Magic Number,Microsoft.Cci,Writer,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,WriteVersionString,The following statement contains a magic number: int totalLength = 6;
Magic Number,Microsoft.Cci,Writer,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,WriteVersionString,The following statement contains a magic number: totalLength += key.Length*2;
Magic Number,Microsoft.Cci,Writer,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,WriteVersionString,The following statement contains a magic number: totalLength += 4 - (totalLength % 4);
Magic Number,Microsoft.Cci,Writer,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,WriteVersionString,The following statement contains a magic number: totalLength += 4 - (totalLength % 4);
Magic Number,Microsoft.Cci,Writer,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,WriteVersionString,The following statement contains a magic number: totalLength += value.Length*2;
Magic Number,Microsoft.Cci,Writer,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,WriteVersionString,The following statement contains a magic number: totalLength += 4 - (totalLength % 4);
Magic Number,Microsoft.Cci,Writer,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,WriteVersionString,The following statement contains a magic number: totalLength += 4 - (totalLength % 4);
Magic Number,Microsoft.Cci,Writer,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,WriteVersionString,The following statement contains a magic number: if (data.BaseStream.Position % 4 != 0) data.Write((char)0);
Magic Number,Microsoft.Cci,Writer,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,WriteVersionString,The following statement contains a magic number: if (data.BaseStream.Position % 4 != 0) data.Write((char)0);
Magic Number,Microsoft.Cci,Writer,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,DaysSince2000,The following statement contains a magic number: return (ushort)(DateTime.Now - new DateTime(2000' 1' 1)).Days;
Magic Number,Microsoft.Cci,Writer,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,SecondsSinceMidnight,The following statement contains a magic number: return (ushort)((sinceMidnight.Hours*60*60+sinceMidnight.Minutes*60+sinceMidnight.Seconds)/2);
Magic Number,Microsoft.Cci,Writer,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,SecondsSinceMidnight,The following statement contains a magic number: return (ushort)((sinceMidnight.Hours*60*60+sinceMidnight.Minutes*60+sinceMidnight.Seconds)/2);
Magic Number,Microsoft.Cci,Writer,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,SecondsSinceMidnight,The following statement contains a magic number: return (ushort)((sinceMidnight.Hours*60*60+sinceMidnight.Minutes*60+sinceMidnight.Seconds)/2);
Magic Number,Microsoft.Cci,Writer,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,SecondsSinceMidnight,The following statement contains a magic number: return (ushort)((sinceMidnight.Hours*60*60+sinceMidnight.Minutes*60+sinceMidnight.Seconds)/2);
Magic Number,Microsoft.Cci.Metadata,MemoryCursor,C:\repos\Reactive-Extensions_IL2JS\CCI\MemoryMappedFile.cs,Align,The following statement contains a magic number: Debug.Assert(size == 2 || size == 4 || size == 8 || size == 16 || size == 32 || size == 64);
Magic Number,Microsoft.Cci.Metadata,MemoryCursor,C:\repos\Reactive-Extensions_IL2JS\CCI\MemoryMappedFile.cs,Align,The following statement contains a magic number: Debug.Assert(size == 2 || size == 4 || size == 8 || size == 16 || size == 32 || size == 64);
Magic Number,Microsoft.Cci.Metadata,MemoryCursor,C:\repos\Reactive-Extensions_IL2JS\CCI\MemoryMappedFile.cs,Align,The following statement contains a magic number: Debug.Assert(size == 2 || size == 4 || size == 8 || size == 16 || size == 32 || size == 64);
Magic Number,Microsoft.Cci.Metadata,MemoryCursor,C:\repos\Reactive-Extensions_IL2JS\CCI\MemoryMappedFile.cs,Align,The following statement contains a magic number: Debug.Assert(size == 2 || size == 4 || size == 8 || size == 16 || size == 32 || size == 64);
Magic Number,Microsoft.Cci.Metadata,MemoryCursor,C:\repos\Reactive-Extensions_IL2JS\CCI\MemoryMappedFile.cs,Align,The following statement contains a magic number: Debug.Assert(size == 2 || size == 4 || size == 8 || size == 16 || size == 32 || size == 64);
Magic Number,Microsoft.Cci.Metadata,MemoryCursor,C:\repos\Reactive-Extensions_IL2JS\CCI\MemoryMappedFile.cs,Align,The following statement contains a magic number: Debug.Assert(size == 2 || size == 4 || size == 8 || size == 16 || size == 32 || size == 64);
Magic Number,Microsoft.Cci.Metadata,MemoryCursor,C:\repos\Reactive-Extensions_IL2JS\CCI\MemoryMappedFile.cs,ReadReference,The following statement contains a magic number: if (refSize == 2) return ReadUInt16();
Magic Number,Microsoft.Cci.Metadata,MemoryCursor,C:\repos\Reactive-Extensions_IL2JS\CCI\MemoryMappedFile.cs,ReadCompressedInt,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00)          result = headerByte;        else if ((headerByte & 0x40) == 0x00)          result = ((headerByte & 0x3f) << 8) | ReadByte();        else if (headerByte == 0xFF)          result = -1;        else          result = ((headerByte & 0x3f) << 24) | (ReadByte() << 16) | (ReadByte() << 8) | ReadByte();
Magic Number,Microsoft.Cci.Metadata,MemoryCursor,C:\repos\Reactive-Extensions_IL2JS\CCI\MemoryMappedFile.cs,ReadCompressedInt,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00)          result = headerByte;        else if ((headerByte & 0x40) == 0x00)          result = ((headerByte & 0x3f) << 8) | ReadByte();        else if (headerByte == 0xFF)          result = -1;        else          result = ((headerByte & 0x3f) << 24) | (ReadByte() << 16) | (ReadByte() << 8) | ReadByte();
Magic Number,Microsoft.Cci.Metadata,MemoryCursor,C:\repos\Reactive-Extensions_IL2JS\CCI\MemoryMappedFile.cs,ReadCompressedInt,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00)          result = headerByte;        else if ((headerByte & 0x40) == 0x00)          result = ((headerByte & 0x3f) << 8) | ReadByte();        else if (headerByte == 0xFF)          result = -1;        else          result = ((headerByte & 0x3f) << 24) | (ReadByte() << 16) | (ReadByte() << 8) | ReadByte();
Magic Number,Microsoft.Cci.Metadata,MemoryCursor,C:\repos\Reactive-Extensions_IL2JS\CCI\MemoryMappedFile.cs,ReadCompressedInt,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00)          result = headerByte;        else if ((headerByte & 0x40) == 0x00)          result = ((headerByte & 0x3f) << 8) | ReadByte();        else if (headerByte == 0xFF)          result = -1;        else          result = ((headerByte & 0x3f) << 24) | (ReadByte() << 16) | (ReadByte() << 8) | ReadByte();
Magic Number,Microsoft.Cci.Metadata,MemoryCursor,C:\repos\Reactive-Extensions_IL2JS\CCI\MemoryMappedFile.cs,ReadIdentifierFromSerString,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00)          length = headerByte;        else if ((headerByte & 0x40) == 0x00)          length = (uint)((headerByte & 0x3f) << 8) | *pb++;        else          length = (uint)((headerByte & 0x3f) << 24) | (uint)(*pb++ << 16) | (uint)(*pb++ << 8) | (*pb++);
Magic Number,Microsoft.Cci.Metadata,MemoryCursor,C:\repos\Reactive-Extensions_IL2JS\CCI\MemoryMappedFile.cs,ReadIdentifierFromSerString,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00)          length = headerByte;        else if ((headerByte & 0x40) == 0x00)          length = (uint)((headerByte & 0x3f) << 8) | *pb++;        else          length = (uint)((headerByte & 0x3f) << 24) | (uint)(*pb++ << 16) | (uint)(*pb++ << 8) | (*pb++);
Magic Number,Microsoft.Cci.Metadata,MemoryCursor,C:\repos\Reactive-Extensions_IL2JS\CCI\MemoryMappedFile.cs,ReadIdentifierFromSerString,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00)          length = headerByte;        else if ((headerByte & 0x40) == 0x00)          length = (uint)((headerByte & 0x3f) << 8) | *pb++;        else          length = (uint)((headerByte & 0x3f) << 24) | (uint)(*pb++ << 16) | (uint)(*pb++ << 8) | (*pb++);
Magic Number,Microsoft.Cci.Metadata,MemoryCursor,C:\repos\Reactive-Extensions_IL2JS\CCI\MemoryMappedFile.cs,ReadIdentifierFromSerString,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00)          length = headerByte;        else if ((headerByte & 0x40) == 0x00)          length = (uint)((headerByte & 0x3f) << 8) | *pb++;        else          length = (uint)((headerByte & 0x3f) << 24) | (uint)(*pb++ << 16) | (uint)(*pb++ << 8) | (*pb++);
Magic Number,Microsoft.Cci.Metadata,MemoryCursor,C:\repos\Reactive-Extensions_IL2JS\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: while (bytesToRead > 0){          byte b = *pb++; bytesToRead--;          if ((b & 0x80) == 0 || bytesToRead == 0){            buffer[j++] = (char)b;            continue;          }          char ch;          byte b1 = *pb++; bytesToRead--;          if ((b & 0x20) == 0)            ch = (char)(((b&0x1F)<<6) | (b1&0x3F));          else{            if (bytesToRead == 0){ //Dangling lead bytes' do not decompose              buffer[j++] = (char)((b << 8) | b1);              break;            }            byte b2 = *pb++; bytesToRead--;            uint ch32;            if ((b & 0x10) == 0)              ch32 = (uint)(((b&0x0F)<<12) | ((b1&0x3F)<<6) | (b2&0x3F));            else{              if (bytesToRead == 0){ //Dangling lead bytes' do not decompose                buffer[j++] = (char)((b << 8) | b1);                buffer[j++] = (char)b2;                break;              }              byte b3 = *pb++; bytesToRead--;              ch32 = (uint)(((b&0x07)<<18) | ((b1&0x3F)<<12) | ((b2&0x3F)<<6) | (b3&0x3F));            }            if ((ch32 & 0xFFFF0000) == 0)              ch = (char)ch32;            else{ //break up into UTF16 surrogate pair              buffer[j++] = (char)((ch32 >> 10) | 0xD800);              ch = (char)((ch32 & 0x3FF) | 0xDC00);            }          }          buffer[j++] = ch;        }
Magic Number,Microsoft.Cci.Metadata,MemoryCursor,C:\repos\Reactive-Extensions_IL2JS\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: while (bytesToRead > 0){          byte b = *pb++; bytesToRead--;          if ((b & 0x80) == 0 || bytesToRead == 0){            buffer[j++] = (char)b;            continue;          }          char ch;          byte b1 = *pb++; bytesToRead--;          if ((b & 0x20) == 0)            ch = (char)(((b&0x1F)<<6) | (b1&0x3F));          else{            if (bytesToRead == 0){ //Dangling lead bytes' do not decompose              buffer[j++] = (char)((b << 8) | b1);              break;            }            byte b2 = *pb++; bytesToRead--;            uint ch32;            if ((b & 0x10) == 0)              ch32 = (uint)(((b&0x0F)<<12) | ((b1&0x3F)<<6) | (b2&0x3F));            else{              if (bytesToRead == 0){ //Dangling lead bytes' do not decompose                buffer[j++] = (char)((b << 8) | b1);                buffer[j++] = (char)b2;                break;              }              byte b3 = *pb++; bytesToRead--;              ch32 = (uint)(((b&0x07)<<18) | ((b1&0x3F)<<12) | ((b2&0x3F)<<6) | (b3&0x3F));            }            if ((ch32 & 0xFFFF0000) == 0)              ch = (char)ch32;            else{ //break up into UTF16 surrogate pair              buffer[j++] = (char)((ch32 >> 10) | 0xD800);              ch = (char)((ch32 & 0x3FF) | 0xDC00);            }          }          buffer[j++] = ch;        }
Magic Number,Microsoft.Cci.Metadata,MemoryCursor,C:\repos\Reactive-Extensions_IL2JS\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: while (bytesToRead > 0){          byte b = *pb++; bytesToRead--;          if ((b & 0x80) == 0 || bytesToRead == 0){            buffer[j++] = (char)b;            continue;          }          char ch;          byte b1 = *pb++; bytesToRead--;          if ((b & 0x20) == 0)            ch = (char)(((b&0x1F)<<6) | (b1&0x3F));          else{            if (bytesToRead == 0){ //Dangling lead bytes' do not decompose              buffer[j++] = (char)((b << 8) | b1);              break;            }            byte b2 = *pb++; bytesToRead--;            uint ch32;            if ((b & 0x10) == 0)              ch32 = (uint)(((b&0x0F)<<12) | ((b1&0x3F)<<6) | (b2&0x3F));            else{              if (bytesToRead == 0){ //Dangling lead bytes' do not decompose                buffer[j++] = (char)((b << 8) | b1);                buffer[j++] = (char)b2;                break;              }              byte b3 = *pb++; bytesToRead--;              ch32 = (uint)(((b&0x07)<<18) | ((b1&0x3F)<<12) | ((b2&0x3F)<<6) | (b3&0x3F));            }            if ((ch32 & 0xFFFF0000) == 0)              ch = (char)ch32;            else{ //break up into UTF16 surrogate pair              buffer[j++] = (char)((ch32 >> 10) | 0xD800);              ch = (char)((ch32 & 0x3FF) | 0xDC00);            }          }          buffer[j++] = ch;        }
Magic Number,Microsoft.Cci.Metadata,MemoryCursor,C:\repos\Reactive-Extensions_IL2JS\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: while (bytesToRead > 0){          byte b = *pb++; bytesToRead--;          if ((b & 0x80) == 0 || bytesToRead == 0){            buffer[j++] = (char)b;            continue;          }          char ch;          byte b1 = *pb++; bytesToRead--;          if ((b & 0x20) == 0)            ch = (char)(((b&0x1F)<<6) | (b1&0x3F));          else{            if (bytesToRead == 0){ //Dangling lead bytes' do not decompose              buffer[j++] = (char)((b << 8) | b1);              break;            }            byte b2 = *pb++; bytesToRead--;            uint ch32;            if ((b & 0x10) == 0)              ch32 = (uint)(((b&0x0F)<<12) | ((b1&0x3F)<<6) | (b2&0x3F));            else{              if (bytesToRead == 0){ //Dangling lead bytes' do not decompose                buffer[j++] = (char)((b << 8) | b1);                buffer[j++] = (char)b2;                break;              }              byte b3 = *pb++; bytesToRead--;              ch32 = (uint)(((b&0x07)<<18) | ((b1&0x3F)<<12) | ((b2&0x3F)<<6) | (b3&0x3F));            }            if ((ch32 & 0xFFFF0000) == 0)              ch = (char)ch32;            else{ //break up into UTF16 surrogate pair              buffer[j++] = (char)((ch32 >> 10) | 0xD800);              ch = (char)((ch32 & 0x3FF) | 0xDC00);            }          }          buffer[j++] = ch;        }
Magic Number,Microsoft.Cci.Metadata,MemoryCursor,C:\repos\Reactive-Extensions_IL2JS\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: while (bytesToRead > 0){          byte b = *pb++; bytesToRead--;          if ((b & 0x80) == 0 || bytesToRead == 0){            buffer[j++] = (char)b;            continue;          }          char ch;          byte b1 = *pb++; bytesToRead--;          if ((b & 0x20) == 0)            ch = (char)(((b&0x1F)<<6) | (b1&0x3F));          else{            if (bytesToRead == 0){ //Dangling lead bytes' do not decompose              buffer[j++] = (char)((b << 8) | b1);              break;            }            byte b2 = *pb++; bytesToRead--;            uint ch32;            if ((b & 0x10) == 0)              ch32 = (uint)(((b&0x0F)<<12) | ((b1&0x3F)<<6) | (b2&0x3F));            else{              if (bytesToRead == 0){ //Dangling lead bytes' do not decompose                buffer[j++] = (char)((b << 8) | b1);                buffer[j++] = (char)b2;                break;              }              byte b3 = *pb++; bytesToRead--;              ch32 = (uint)(((b&0x07)<<18) | ((b1&0x3F)<<12) | ((b2&0x3F)<<6) | (b3&0x3F));            }            if ((ch32 & 0xFFFF0000) == 0)              ch = (char)ch32;            else{ //break up into UTF16 surrogate pair              buffer[j++] = (char)((ch32 >> 10) | 0xD800);              ch = (char)((ch32 & 0x3FF) | 0xDC00);            }          }          buffer[j++] = ch;        }
Magic Number,Microsoft.Cci.Metadata,MemoryCursor,C:\repos\Reactive-Extensions_IL2JS\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: while (bytesToRead > 0){          byte b = *pb++; bytesToRead--;          if ((b & 0x80) == 0 || bytesToRead == 0){            buffer[j++] = (char)b;            continue;          }          char ch;          byte b1 = *pb++; bytesToRead--;          if ((b & 0x20) == 0)            ch = (char)(((b&0x1F)<<6) | (b1&0x3F));          else{            if (bytesToRead == 0){ //Dangling lead bytes' do not decompose              buffer[j++] = (char)((b << 8) | b1);              break;            }            byte b2 = *pb++; bytesToRead--;            uint ch32;            if ((b & 0x10) == 0)              ch32 = (uint)(((b&0x0F)<<12) | ((b1&0x3F)<<6) | (b2&0x3F));            else{              if (bytesToRead == 0){ //Dangling lead bytes' do not decompose                buffer[j++] = (char)((b << 8) | b1);                buffer[j++] = (char)b2;                break;              }              byte b3 = *pb++; bytesToRead--;              ch32 = (uint)(((b&0x07)<<18) | ((b1&0x3F)<<12) | ((b2&0x3F)<<6) | (b3&0x3F));            }            if ((ch32 & 0xFFFF0000) == 0)              ch = (char)ch32;            else{ //break up into UTF16 surrogate pair              buffer[j++] = (char)((ch32 >> 10) | 0xD800);              ch = (char)((ch32 & 0x3FF) | 0xDC00);            }          }          buffer[j++] = ch;        }
Magic Number,Microsoft.Cci.Metadata,MemoryCursor,C:\repos\Reactive-Extensions_IL2JS\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: while (bytesToRead > 0){          byte b = *pb++; bytesToRead--;          if ((b & 0x80) == 0 || bytesToRead == 0){            buffer[j++] = (char)b;            continue;          }          char ch;          byte b1 = *pb++; bytesToRead--;          if ((b & 0x20) == 0)            ch = (char)(((b&0x1F)<<6) | (b1&0x3F));          else{            if (bytesToRead == 0){ //Dangling lead bytes' do not decompose              buffer[j++] = (char)((b << 8) | b1);              break;            }            byte b2 = *pb++; bytesToRead--;            uint ch32;            if ((b & 0x10) == 0)              ch32 = (uint)(((b&0x0F)<<12) | ((b1&0x3F)<<6) | (b2&0x3F));            else{              if (bytesToRead == 0){ //Dangling lead bytes' do not decompose                buffer[j++] = (char)((b << 8) | b1);                buffer[j++] = (char)b2;                break;              }              byte b3 = *pb++; bytesToRead--;              ch32 = (uint)(((b&0x07)<<18) | ((b1&0x3F)<<12) | ((b2&0x3F)<<6) | (b3&0x3F));            }            if ((ch32 & 0xFFFF0000) == 0)              ch = (char)ch32;            else{ //break up into UTF16 surrogate pair              buffer[j++] = (char)((ch32 >> 10) | 0xD800);              ch = (char)((ch32 & 0x3FF) | 0xDC00);            }          }          buffer[j++] = ch;        }
Magic Number,Microsoft.Cci.Metadata,MemoryCursor,C:\repos\Reactive-Extensions_IL2JS\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: while (bytesToRead > 0){          byte b = *pb++; bytesToRead--;          if ((b & 0x80) == 0 || bytesToRead == 0){            buffer[j++] = (char)b;            continue;          }          char ch;          byte b1 = *pb++; bytesToRead--;          if ((b & 0x20) == 0)            ch = (char)(((b&0x1F)<<6) | (b1&0x3F));          else{            if (bytesToRead == 0){ //Dangling lead bytes' do not decompose              buffer[j++] = (char)((b << 8) | b1);              break;            }            byte b2 = *pb++; bytesToRead--;            uint ch32;            if ((b & 0x10) == 0)              ch32 = (uint)(((b&0x0F)<<12) | ((b1&0x3F)<<6) | (b2&0x3F));            else{              if (bytesToRead == 0){ //Dangling lead bytes' do not decompose                buffer[j++] = (char)((b << 8) | b1);                buffer[j++] = (char)b2;                break;              }              byte b3 = *pb++; bytesToRead--;              ch32 = (uint)(((b&0x07)<<18) | ((b1&0x3F)<<12) | ((b2&0x3F)<<6) | (b3&0x3F));            }            if ((ch32 & 0xFFFF0000) == 0)              ch = (char)ch32;            else{ //break up into UTF16 surrogate pair              buffer[j++] = (char)((ch32 >> 10) | 0xD800);              ch = (char)((ch32 & 0x3FF) | 0xDC00);            }          }          buffer[j++] = ch;        }
Magic Number,Microsoft.Cci.Metadata,MemoryCursor,C:\repos\Reactive-Extensions_IL2JS\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: while (bytesToRead > 0){          byte b = *pb++; bytesToRead--;          if ((b & 0x80) == 0 || bytesToRead == 0){            buffer[j++] = (char)b;            continue;          }          char ch;          byte b1 = *pb++; bytesToRead--;          if ((b & 0x20) == 0)            ch = (char)(((b&0x1F)<<6) | (b1&0x3F));          else{            if (bytesToRead == 0){ //Dangling lead bytes' do not decompose              buffer[j++] = (char)((b << 8) | b1);              break;            }            byte b2 = *pb++; bytesToRead--;            uint ch32;            if ((b & 0x10) == 0)              ch32 = (uint)(((b&0x0F)<<12) | ((b1&0x3F)<<6) | (b2&0x3F));            else{              if (bytesToRead == 0){ //Dangling lead bytes' do not decompose                buffer[j++] = (char)((b << 8) | b1);                buffer[j++] = (char)b2;                break;              }              byte b3 = *pb++; bytesToRead--;              ch32 = (uint)(((b&0x07)<<18) | ((b1&0x3F)<<12) | ((b2&0x3F)<<6) | (b3&0x3F));            }            if ((ch32 & 0xFFFF0000) == 0)              ch = (char)ch32;            else{ //break up into UTF16 surrogate pair              buffer[j++] = (char)((ch32 >> 10) | 0xD800);              ch = (char)((ch32 & 0x3FF) | 0xDC00);            }          }          buffer[j++] = ch;        }
Magic Number,Microsoft.Cci.Metadata,MemoryCursor,C:\repos\Reactive-Extensions_IL2JS\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: for(;;){          b = *pb++;          if (b == 0) break;          if ((b & 0x80) == 0){            sb.Append((char)b);            continue;          }          char ch;          byte b1 = *pb++;          if (b1 == 0){ //Dangling lead byte' do not decompose            sb.Append((char)b);            break;          }          if ((b & 0x20) == 0){            ch = (char)(((b&0x1F)<<6) | (b1&0x3F));          }else{            byte b2 = *pb++;            if (b2 == 0){ //Dangling lead bytes' do not decompose              sb.Append((char)((b << 8)|b1));              break;            }            uint ch32;            if ((b & 0x10) == 0)              ch32 = (uint)(((b&0x0F)<<12) | ((b1&0x3F)<<6) | (b2&0x3F));            else{              byte b3 = *pb++;              if (b3 == 0){ //Dangling lead bytes' do not decompose                sb.Append((char)((b << 8)|b1));                sb.Append((char)b2);                break;              }              ch32 = (uint)(((b&0x07)<<18) | ((b1&0x3F)<<12) | ((b2&0x3F)<<6) | (b3&0x3F));            }            if ((ch32 & 0xFFFF0000) == 0)              ch = (char)ch32;            else{ //break up into UTF16 surrogate pair              sb.Append((char)((ch32 >> 10) | 0xD800));              ch = (char)((ch32 & 0x3FF) | 0xDC00);            }          }          sb.Append(ch);        }
Magic Number,Microsoft.Cci.Metadata,MemoryCursor,C:\repos\Reactive-Extensions_IL2JS\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: for(;;){          b = *pb++;          if (b == 0) break;          if ((b & 0x80) == 0){            sb.Append((char)b);            continue;          }          char ch;          byte b1 = *pb++;          if (b1 == 0){ //Dangling lead byte' do not decompose            sb.Append((char)b);            break;          }          if ((b & 0x20) == 0){            ch = (char)(((b&0x1F)<<6) | (b1&0x3F));          }else{            byte b2 = *pb++;            if (b2 == 0){ //Dangling lead bytes' do not decompose              sb.Append((char)((b << 8)|b1));              break;            }            uint ch32;            if ((b & 0x10) == 0)              ch32 = (uint)(((b&0x0F)<<12) | ((b1&0x3F)<<6) | (b2&0x3F));            else{              byte b3 = *pb++;              if (b3 == 0){ //Dangling lead bytes' do not decompose                sb.Append((char)((b << 8)|b1));                sb.Append((char)b2);                break;              }              ch32 = (uint)(((b&0x07)<<18) | ((b1&0x3F)<<12) | ((b2&0x3F)<<6) | (b3&0x3F));            }            if ((ch32 & 0xFFFF0000) == 0)              ch = (char)ch32;            else{ //break up into UTF16 surrogate pair              sb.Append((char)((ch32 >> 10) | 0xD800));              ch = (char)((ch32 & 0x3FF) | 0xDC00);            }          }          sb.Append(ch);        }
Magic Number,Microsoft.Cci.Metadata,MemoryCursor,C:\repos\Reactive-Extensions_IL2JS\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: for(;;){          b = *pb++;          if (b == 0) break;          if ((b & 0x80) == 0){            sb.Append((char)b);            continue;          }          char ch;          byte b1 = *pb++;          if (b1 == 0){ //Dangling lead byte' do not decompose            sb.Append((char)b);            break;          }          if ((b & 0x20) == 0){            ch = (char)(((b&0x1F)<<6) | (b1&0x3F));          }else{            byte b2 = *pb++;            if (b2 == 0){ //Dangling lead bytes' do not decompose              sb.Append((char)((b << 8)|b1));              break;            }            uint ch32;            if ((b & 0x10) == 0)              ch32 = (uint)(((b&0x0F)<<12) | ((b1&0x3F)<<6) | (b2&0x3F));            else{              byte b3 = *pb++;              if (b3 == 0){ //Dangling lead bytes' do not decompose                sb.Append((char)((b << 8)|b1));                sb.Append((char)b2);                break;              }              ch32 = (uint)(((b&0x07)<<18) | ((b1&0x3F)<<12) | ((b2&0x3F)<<6) | (b3&0x3F));            }            if ((ch32 & 0xFFFF0000) == 0)              ch = (char)ch32;            else{ //break up into UTF16 surrogate pair              sb.Append((char)((ch32 >> 10) | 0xD800));              ch = (char)((ch32 & 0x3FF) | 0xDC00);            }          }          sb.Append(ch);        }
Magic Number,Microsoft.Cci.Metadata,MemoryCursor,C:\repos\Reactive-Extensions_IL2JS\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: for(;;){          b = *pb++;          if (b == 0) break;          if ((b & 0x80) == 0){            sb.Append((char)b);            continue;          }          char ch;          byte b1 = *pb++;          if (b1 == 0){ //Dangling lead byte' do not decompose            sb.Append((char)b);            break;          }          if ((b & 0x20) == 0){            ch = (char)(((b&0x1F)<<6) | (b1&0x3F));          }else{            byte b2 = *pb++;            if (b2 == 0){ //Dangling lead bytes' do not decompose              sb.Append((char)((b << 8)|b1));              break;            }            uint ch32;            if ((b & 0x10) == 0)              ch32 = (uint)(((b&0x0F)<<12) | ((b1&0x3F)<<6) | (b2&0x3F));            else{              byte b3 = *pb++;              if (b3 == 0){ //Dangling lead bytes' do not decompose                sb.Append((char)((b << 8)|b1));                sb.Append((char)b2);                break;              }              ch32 = (uint)(((b&0x07)<<18) | ((b1&0x3F)<<12) | ((b2&0x3F)<<6) | (b3&0x3F));            }            if ((ch32 & 0xFFFF0000) == 0)              ch = (char)ch32;            else{ //break up into UTF16 surrogate pair              sb.Append((char)((ch32 >> 10) | 0xD800));              ch = (char)((ch32 & 0x3FF) | 0xDC00);            }          }          sb.Append(ch);        }
Magic Number,Microsoft.Cci.Metadata,MemoryCursor,C:\repos\Reactive-Extensions_IL2JS\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: for(;;){          b = *pb++;          if (b == 0) break;          if ((b & 0x80) == 0){            sb.Append((char)b);            continue;          }          char ch;          byte b1 = *pb++;          if (b1 == 0){ //Dangling lead byte' do not decompose            sb.Append((char)b);            break;          }          if ((b & 0x20) == 0){            ch = (char)(((b&0x1F)<<6) | (b1&0x3F));          }else{            byte b2 = *pb++;            if (b2 == 0){ //Dangling lead bytes' do not decompose              sb.Append((char)((b << 8)|b1));              break;            }            uint ch32;            if ((b & 0x10) == 0)              ch32 = (uint)(((b&0x0F)<<12) | ((b1&0x3F)<<6) | (b2&0x3F));            else{              byte b3 = *pb++;              if (b3 == 0){ //Dangling lead bytes' do not decompose                sb.Append((char)((b << 8)|b1));                sb.Append((char)b2);                break;              }              ch32 = (uint)(((b&0x07)<<18) | ((b1&0x3F)<<12) | ((b2&0x3F)<<6) | (b3&0x3F));            }            if ((ch32 & 0xFFFF0000) == 0)              ch = (char)ch32;            else{ //break up into UTF16 surrogate pair              sb.Append((char)((ch32 >> 10) | 0xD800));              ch = (char)((ch32 & 0x3FF) | 0xDC00);            }          }          sb.Append(ch);        }
Magic Number,Microsoft.Cci.Metadata,MemoryCursor,C:\repos\Reactive-Extensions_IL2JS\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: for(;;){          b = *pb++;          if (b == 0) break;          if ((b & 0x80) == 0){            sb.Append((char)b);            continue;          }          char ch;          byte b1 = *pb++;          if (b1 == 0){ //Dangling lead byte' do not decompose            sb.Append((char)b);            break;          }          if ((b & 0x20) == 0){            ch = (char)(((b&0x1F)<<6) | (b1&0x3F));          }else{            byte b2 = *pb++;            if (b2 == 0){ //Dangling lead bytes' do not decompose              sb.Append((char)((b << 8)|b1));              break;            }            uint ch32;            if ((b & 0x10) == 0)              ch32 = (uint)(((b&0x0F)<<12) | ((b1&0x3F)<<6) | (b2&0x3F));            else{              byte b3 = *pb++;              if (b3 == 0){ //Dangling lead bytes' do not decompose                sb.Append((char)((b << 8)|b1));                sb.Append((char)b2);                break;              }              ch32 = (uint)(((b&0x07)<<18) | ((b1&0x3F)<<12) | ((b2&0x3F)<<6) | (b3&0x3F));            }            if ((ch32 & 0xFFFF0000) == 0)              ch = (char)ch32;            else{ //break up into UTF16 surrogate pair              sb.Append((char)((ch32 >> 10) | 0xD800));              ch = (char)((ch32 & 0x3FF) | 0xDC00);            }          }          sb.Append(ch);        }
Magic Number,Microsoft.Cci.Metadata,MemoryCursor,C:\repos\Reactive-Extensions_IL2JS\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: for(;;){          b = *pb++;          if (b == 0) break;          if ((b & 0x80) == 0){            sb.Append((char)b);            continue;          }          char ch;          byte b1 = *pb++;          if (b1 == 0){ //Dangling lead byte' do not decompose            sb.Append((char)b);            break;          }          if ((b & 0x20) == 0){            ch = (char)(((b&0x1F)<<6) | (b1&0x3F));          }else{            byte b2 = *pb++;            if (b2 == 0){ //Dangling lead bytes' do not decompose              sb.Append((char)((b << 8)|b1));              break;            }            uint ch32;            if ((b & 0x10) == 0)              ch32 = (uint)(((b&0x0F)<<12) | ((b1&0x3F)<<6) | (b2&0x3F));            else{              byte b3 = *pb++;              if (b3 == 0){ //Dangling lead bytes' do not decompose                sb.Append((char)((b << 8)|b1));                sb.Append((char)b2);                break;              }              ch32 = (uint)(((b&0x07)<<18) | ((b1&0x3F)<<12) | ((b2&0x3F)<<6) | (b3&0x3F));            }            if ((ch32 & 0xFFFF0000) == 0)              ch = (char)ch32;            else{ //break up into UTF16 surrogate pair              sb.Append((char)((ch32 >> 10) | 0xD800));              ch = (char)((ch32 & 0x3FF) | 0xDC00);            }          }          sb.Append(ch);        }
Magic Number,Microsoft.Cci.Metadata,MemoryCursor,C:\repos\Reactive-Extensions_IL2JS\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: for(;;){          b = *pb++;          if (b == 0) break;          if ((b & 0x80) == 0){            sb.Append((char)b);            continue;          }          char ch;          byte b1 = *pb++;          if (b1 == 0){ //Dangling lead byte' do not decompose            sb.Append((char)b);            break;          }          if ((b & 0x20) == 0){            ch = (char)(((b&0x1F)<<6) | (b1&0x3F));          }else{            byte b2 = *pb++;            if (b2 == 0){ //Dangling lead bytes' do not decompose              sb.Append((char)((b << 8)|b1));              break;            }            uint ch32;            if ((b & 0x10) == 0)              ch32 = (uint)(((b&0x0F)<<12) | ((b1&0x3F)<<6) | (b2&0x3F));            else{              byte b3 = *pb++;              if (b3 == 0){ //Dangling lead bytes' do not decompose                sb.Append((char)((b << 8)|b1));                sb.Append((char)b2);                break;              }              ch32 = (uint)(((b&0x07)<<18) | ((b1&0x3F)<<12) | ((b2&0x3F)<<6) | (b3&0x3F));            }            if ((ch32 & 0xFFFF0000) == 0)              ch = (char)ch32;            else{ //break up into UTF16 surrogate pair              sb.Append((char)((ch32 >> 10) | 0xD800));              ch = (char)((ch32 & 0x3FF) | 0xDC00);            }          }          sb.Append(ch);        }
Magic Number,Microsoft.Cci.Metadata,MemoryCursor,C:\repos\Reactive-Extensions_IL2JS\CCI\MemoryMappedFile.cs,ReadUTF8,The following statement contains a magic number: for(;;){          b = *pb++;          if (b == 0) break;          if ((b & 0x80) == 0){            sb.Append((char)b);            continue;          }          char ch;          byte b1 = *pb++;          if (b1 == 0){ //Dangling lead byte' do not decompose            sb.Append((char)b);            break;          }          if ((b & 0x20) == 0){            ch = (char)(((b&0x1F)<<6) | (b1&0x3F));          }else{            byte b2 = *pb++;            if (b2 == 0){ //Dangling lead bytes' do not decompose              sb.Append((char)((b << 8)|b1));              break;            }            uint ch32;            if ((b & 0x10) == 0)              ch32 = (uint)(((b&0x0F)<<12) | ((b1&0x3F)<<6) | (b2&0x3F));            else{              byte b3 = *pb++;              if (b3 == 0){ //Dangling lead bytes' do not decompose                sb.Append((char)((b << 8)|b1));                sb.Append((char)b2);                break;              }              ch32 = (uint)(((b&0x07)<<18) | ((b1&0x3F)<<12) | ((b2&0x3F)<<6) | (b3&0x3F));            }            if ((ch32 & 0xFFFF0000) == 0)              ch = (char)ch32;            else{ //break up into UTF16 surrogate pair              sb.Append((char)((ch32 >> 10) | 0xD800));              ch = (char)((ch32 & 0x3FF) | 0xDC00);            }          }          sb.Append(ch);        }
Magic Number,Microsoft.Cci.Metadata,MemoryCursor,C:\repos\Reactive-Extensions_IL2JS\CCI\MemoryMappedFile.cs,ReadUTF16,The following statement contains a magic number: this.pb += (result.Length+1)*2;
Magic Number,Microsoft.Cci.Metadata,MemoryCursor,C:\repos\Reactive-Extensions_IL2JS\CCI\MemoryMappedFile.cs,ReadASCII,The following statement contains a magic number: if (bytesToRead == -1) c = 128;
Magic Number,Microsoft.Cci.Metadata,MemoryCursor,C:\repos\Reactive-Extensions_IL2JS\CCI\MemoryMappedFile.cs,ReadASCII,The following statement contains a magic number: if (bytesToRead == -1){          if (b != 0){            char[] newBuffer = new char[c *= 2];            for (int copy = 0; copy < j; copy++)              newBuffer[copy] = buffer[copy];            buffer = newBuffer;            goto Restart;          }          this.pb = pb;        }else          this.pb += bytesToRead;
Magic Number,Microsoft.Cci.Metadata,CLIHeader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,CLIHeader,The following statement contains a magic number: this.cb = 72;
Magic Number,Microsoft.Cci.Metadata,CLIHeader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,CLIHeader,The following statement contains a magic number: this.majorRuntimeVersion = 2;
Magic Number,Microsoft.Cci.Metadata,CLIHeader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,CLIHeader,The following statement contains a magic number: this.minorRuntimeVersion = 5;
Magic Number,Microsoft.Cci.Metadata,NTHeader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,NTHeader,The following statement contains a magic number: this.sizeOfOptionalHeader = 224;
Magic Number,Microsoft.Cci.Metadata,NTHeader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,NTHeader,The following statement contains a magic number: this.majorLinkerVersion = 6;
Magic Number,Microsoft.Cci.Metadata,NTHeader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,NTHeader,The following statement contains a magic number: this.sectionAlignment = 8192;
Magic Number,Microsoft.Cci.Metadata,NTHeader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,NTHeader,The following statement contains a magic number: this.fileAlignment = 512;
Magic Number,Microsoft.Cci.Metadata,NTHeader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,NTHeader,The following statement contains a magic number: this.majorOperatingSystemVersion = 4;
Magic Number,Microsoft.Cci.Metadata,NTHeader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,NTHeader,The following statement contains a magic number: this.majorSubsystemVersion = 4;
Magic Number,Microsoft.Cci.Metadata,NTHeader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,NTHeader,The following statement contains a magic number: this.sizeOfStackReserve = 1048576;
Magic Number,Microsoft.Cci.Metadata,NTHeader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,NTHeader,The following statement contains a magic number: this.sizeOfStackCommit = 4096;
Magic Number,Microsoft.Cci.Metadata,NTHeader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,NTHeader,The following statement contains a magic number: this.sizeOfHeapReserve = 1048576;
Magic Number,Microsoft.Cci.Metadata,NTHeader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,NTHeader,The following statement contains a magic number: this.sizeOfHeapCommit = 4096;
Magic Number,Microsoft.Cci.Metadata,NTHeader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,NTHeader,The following statement contains a magic number: this.numberOfDataDirectories = 16;
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,AlignTo32BitBoundary,The following statement contains a magic number: this.cursor.Align(4);
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,GetGuid,The following statement contains a magic number: int guidOffset = guidIndex * 16;
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,GetGuid,The following statement contains a magic number: if (guidOffset < 16 || this.guidHeap.size < guidOffset)          throw new System.ArgumentOutOfRangeException("guidIndex"' ExceptionStrings.BadGuidHeapIndex);
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,GetGuid,The following statement contains a magic number: c.Position = this.mdOffset+this.guidHeap.offset+guidOffset-16;
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,GetGuid,The following statement contains a magic number: return new System.Guid(c.ReadBytes(16));
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,GetUserString,The following statement contains a magic number: return c.ReadUTF16(strLength/2);
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,GetBlobString,The following statement contains a magic number: return c.ReadUTF16(blobLength/2);
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,GetValueFromBlob,The following statement contains a magic number: switch((ElementType)type){          case ElementType.Boolean: return c.ReadBoolean();           case ElementType.Char: return (char)c.ReadUInt16();           case ElementType.Double: return c.ReadDouble();           case ElementType.Single: return c.ReadSingle();           case ElementType.Int16: return c.ReadInt16();           case ElementType.Int32: return c.ReadInt32();           case ElementType.Int64: return c.ReadInt64();           case ElementType.Int8: return c.ReadSByte();           case ElementType.UInt16: return c.ReadUInt16();           case ElementType.UInt32: return c.ReadUInt32();           case ElementType.UInt64: return c.ReadUInt64();           case ElementType.UInt8: return c.ReadByte();           case ElementType.Class: return null;          case ElementType.String: return c.ReadUTF16(blobLength/2);        }
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: switch (ntHeader.machine){          case 0x0200 :             this.peKind |= PEKindFlags.Requires64bits;             break;          case 0x8664 :             this.peKind |= PEKindFlags.Requires64bits|PEKindFlags.AMD;             break;          default:             if (ntHeader.magic == 0x20B) //Optional header magic for PE32+              this.peKind |= PEKindFlags.Requires64bits;            else if ((cliHeader.flags & 2) != 0)              this.peKind |= PEKindFlags.Requires32bits;             break;        }
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0' j = 0; i < (int)TableIndices.Count; i++){          if (valid % 2 == 1){            int m = tableSize[i] = countArray[j++];            tableRefSize[i] = m < 0x10000 ? 2 : 4;          }else            tableRefSize[i] = 2;          valid /= 2;        }
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0' j = 0; i < (int)TableIndices.Count; i++){          if (valid % 2 == 1){            int m = tableSize[i] = countArray[j++];            tableRefSize[i] = m < 0x10000 ? 2 : 4;          }else            tableRefSize[i] = 2;          valid /= 2;        }
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0' j = 0; i < (int)TableIndices.Count; i++){          if (valid % 2 == 1){            int m = tableSize[i] = countArray[j++];            tableRefSize[i] = m < 0x10000 ? 2 : 4;          }else            tableRefSize[i] = 2;          valid /= 2;        }
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0' j = 0; i < (int)TableIndices.Count; i++){          if (valid % 2 == 1){            int m = tableSize[i] = countArray[j++];            tableRefSize[i] = m < 0x10000 ? 2 : 4;          }else            tableRefSize[i] = 2;          valid /= 2;        }
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0' j = 0; i < (int)TableIndices.Count; i++){          if (valid % 2 == 1){            int m = tableSize[i] = countArray[j++];            tableRefSize[i] = m < 0x10000 ? 2 : 4;          }else            tableRefSize[i] = 2;          valid /= 2;        }
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: int blobRefSize = this.blobRefSize = ((tablesHeader.heapSizes & 0x04) == 0 ? 2 : 4);
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: int blobRefSize = this.blobRefSize = ((tablesHeader.heapSizes & 0x04) == 0 ? 2 : 4);
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: int constantParentRefSize = this.constantParentRefSize =           tableSize[(int)TableIndices.Param] < 0x4000 &&           tableSize[(int)TableIndices.Field] < 0x4000 &&           tableSize[(int)TableIndices.Property] < 0x4000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: int constantParentRefSize = this.constantParentRefSize =           tableSize[(int)TableIndices.Param] < 0x4000 &&           tableSize[(int)TableIndices.Field] < 0x4000 &&           tableSize[(int)TableIndices.Property] < 0x4000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: if (this.metadataFormatMajorVersion > 1 || this.metadataFormatMinorVersion > 0){          customAttributeParentRefSize = this.customAttributeParentRefSize =            tableSize[(int)TableIndices.Method] < 0x0800 &&            tableSize[(int)TableIndices.Field] < 0x0800 &&            tableSize[(int)TableIndices.TypeRef] < 0x0800 &&            tableSize[(int)TableIndices.TypeDef] < 0x0800 &&            tableSize[(int)TableIndices.Param] < 0x0800 &&            tableSize[(int)TableIndices.InterfaceImpl] < 0x0800 &&            tableSize[(int)TableIndices.MemberRef] < 0x0800 &&            tableSize[(int)TableIndices.Module] < 0x0800 &&            tableSize[(int)TableIndices.DeclSecurity] < 0x0800 &&            tableSize[(int)TableIndices.Property] < 0x0800 &&            tableSize[(int)TableIndices.Event] < 0x0800 &&            tableSize[(int)TableIndices.StandAloneSig] < 0x0800 &&            tableSize[(int)TableIndices.ModuleRef] < 0x0800 &&            tableSize[(int)TableIndices.TypeSpec] < 0x0800 &&            tableSize[(int)TableIndices.Assembly] < 0x0800 &&            tableSize[(int)TableIndices.File] < 0x0800 &&            tableSize[(int)TableIndices.ExportedType] < 0x0800 &&            tableSize[(int)TableIndices.ManifestResource] < 0x0800 &&            tableSize[(int)TableIndices.GenericParam] < 0x0800 &&            tableSize[(int)TableIndices.MethodSpec] < 0x0800 &&            tableSize[(int)TableIndices.GenericParamConstraint] < 0x0800 ? 2 : 4;        }else{          customAttributeParentRefSize = this.customAttributeParentRefSize =            tableSize[(int)TableIndices.Method] < 0x0800 &&            tableSize[(int)TableIndices.Field] < 0x0800 &&            tableSize[(int)TableIndices.TypeRef] < 0x0800 &&            tableSize[(int)TableIndices.TypeDef] < 0x0800 &&            tableSize[(int)TableIndices.Param] < 0x0800 &&            tableSize[(int)TableIndices.InterfaceImpl] < 0x0800 &&            tableSize[(int)TableIndices.MemberRef] < 0x0800 &&            tableSize[(int)TableIndices.Module] < 0x0800 &&            tableSize[(int)TableIndices.DeclSecurity] < 0x0800 &&            tableSize[(int)TableIndices.Property] < 0x0800 &&            tableSize[(int)TableIndices.Event] < 0x0800 &&            tableSize[(int)TableIndices.StandAloneSig] < 0x0800 &&            tableSize[(int)TableIndices.ModuleRef] < 0x0800 &&            tableSize[(int)TableIndices.TypeSpec] < 0x0800 &&            tableSize[(int)TableIndices.Assembly] < 0x0800 &&            tableSize[(int)TableIndices.File] < 0x0800 &&            tableSize[(int)TableIndices.ExportedType] < 0x0800 &&            tableSize[(int)TableIndices.ManifestResource] < 0x0800 ? 2 : 4;        }
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: if (this.metadataFormatMajorVersion > 1 || this.metadataFormatMinorVersion > 0){          customAttributeParentRefSize = this.customAttributeParentRefSize =            tableSize[(int)TableIndices.Method] < 0x0800 &&            tableSize[(int)TableIndices.Field] < 0x0800 &&            tableSize[(int)TableIndices.TypeRef] < 0x0800 &&            tableSize[(int)TableIndices.TypeDef] < 0x0800 &&            tableSize[(int)TableIndices.Param] < 0x0800 &&            tableSize[(int)TableIndices.InterfaceImpl] < 0x0800 &&            tableSize[(int)TableIndices.MemberRef] < 0x0800 &&            tableSize[(int)TableIndices.Module] < 0x0800 &&            tableSize[(int)TableIndices.DeclSecurity] < 0x0800 &&            tableSize[(int)TableIndices.Property] < 0x0800 &&            tableSize[(int)TableIndices.Event] < 0x0800 &&            tableSize[(int)TableIndices.StandAloneSig] < 0x0800 &&            tableSize[(int)TableIndices.ModuleRef] < 0x0800 &&            tableSize[(int)TableIndices.TypeSpec] < 0x0800 &&            tableSize[(int)TableIndices.Assembly] < 0x0800 &&            tableSize[(int)TableIndices.File] < 0x0800 &&            tableSize[(int)TableIndices.ExportedType] < 0x0800 &&            tableSize[(int)TableIndices.ManifestResource] < 0x0800 &&            tableSize[(int)TableIndices.GenericParam] < 0x0800 &&            tableSize[(int)TableIndices.MethodSpec] < 0x0800 &&            tableSize[(int)TableIndices.GenericParamConstraint] < 0x0800 ? 2 : 4;        }else{          customAttributeParentRefSize = this.customAttributeParentRefSize =            tableSize[(int)TableIndices.Method] < 0x0800 &&            tableSize[(int)TableIndices.Field] < 0x0800 &&            tableSize[(int)TableIndices.TypeRef] < 0x0800 &&            tableSize[(int)TableIndices.TypeDef] < 0x0800 &&            tableSize[(int)TableIndices.Param] < 0x0800 &&            tableSize[(int)TableIndices.InterfaceImpl] < 0x0800 &&            tableSize[(int)TableIndices.MemberRef] < 0x0800 &&            tableSize[(int)TableIndices.Module] < 0x0800 &&            tableSize[(int)TableIndices.DeclSecurity] < 0x0800 &&            tableSize[(int)TableIndices.Property] < 0x0800 &&            tableSize[(int)TableIndices.Event] < 0x0800 &&            tableSize[(int)TableIndices.StandAloneSig] < 0x0800 &&            tableSize[(int)TableIndices.ModuleRef] < 0x0800 &&            tableSize[(int)TableIndices.TypeSpec] < 0x0800 &&            tableSize[(int)TableIndices.Assembly] < 0x0800 &&            tableSize[(int)TableIndices.File] < 0x0800 &&            tableSize[(int)TableIndices.ExportedType] < 0x0800 &&            tableSize[(int)TableIndices.ManifestResource] < 0x0800 ? 2 : 4;        }
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: if (this.metadataFormatMajorVersion > 1 || this.metadataFormatMinorVersion > 0){          customAttributeParentRefSize = this.customAttributeParentRefSize =            tableSize[(int)TableIndices.Method] < 0x0800 &&            tableSize[(int)TableIndices.Field] < 0x0800 &&            tableSize[(int)TableIndices.TypeRef] < 0x0800 &&            tableSize[(int)TableIndices.TypeDef] < 0x0800 &&            tableSize[(int)TableIndices.Param] < 0x0800 &&            tableSize[(int)TableIndices.InterfaceImpl] < 0x0800 &&            tableSize[(int)TableIndices.MemberRef] < 0x0800 &&            tableSize[(int)TableIndices.Module] < 0x0800 &&            tableSize[(int)TableIndices.DeclSecurity] < 0x0800 &&            tableSize[(int)TableIndices.Property] < 0x0800 &&            tableSize[(int)TableIndices.Event] < 0x0800 &&            tableSize[(int)TableIndices.StandAloneSig] < 0x0800 &&            tableSize[(int)TableIndices.ModuleRef] < 0x0800 &&            tableSize[(int)TableIndices.TypeSpec] < 0x0800 &&            tableSize[(int)TableIndices.Assembly] < 0x0800 &&            tableSize[(int)TableIndices.File] < 0x0800 &&            tableSize[(int)TableIndices.ExportedType] < 0x0800 &&            tableSize[(int)TableIndices.ManifestResource] < 0x0800 &&            tableSize[(int)TableIndices.GenericParam] < 0x0800 &&            tableSize[(int)TableIndices.MethodSpec] < 0x0800 &&            tableSize[(int)TableIndices.GenericParamConstraint] < 0x0800 ? 2 : 4;        }else{          customAttributeParentRefSize = this.customAttributeParentRefSize =            tableSize[(int)TableIndices.Method] < 0x0800 &&            tableSize[(int)TableIndices.Field] < 0x0800 &&            tableSize[(int)TableIndices.TypeRef] < 0x0800 &&            tableSize[(int)TableIndices.TypeDef] < 0x0800 &&            tableSize[(int)TableIndices.Param] < 0x0800 &&            tableSize[(int)TableIndices.InterfaceImpl] < 0x0800 &&            tableSize[(int)TableIndices.MemberRef] < 0x0800 &&            tableSize[(int)TableIndices.Module] < 0x0800 &&            tableSize[(int)TableIndices.DeclSecurity] < 0x0800 &&            tableSize[(int)TableIndices.Property] < 0x0800 &&            tableSize[(int)TableIndices.Event] < 0x0800 &&            tableSize[(int)TableIndices.StandAloneSig] < 0x0800 &&            tableSize[(int)TableIndices.ModuleRef] < 0x0800 &&            tableSize[(int)TableIndices.TypeSpec] < 0x0800 &&            tableSize[(int)TableIndices.Assembly] < 0x0800 &&            tableSize[(int)TableIndices.File] < 0x0800 &&            tableSize[(int)TableIndices.ExportedType] < 0x0800 &&            tableSize[(int)TableIndices.ManifestResource] < 0x0800 ? 2 : 4;        }
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: if (this.metadataFormatMajorVersion > 1 || this.metadataFormatMinorVersion > 0){          customAttributeParentRefSize = this.customAttributeParentRefSize =            tableSize[(int)TableIndices.Method] < 0x0800 &&            tableSize[(int)TableIndices.Field] < 0x0800 &&            tableSize[(int)TableIndices.TypeRef] < 0x0800 &&            tableSize[(int)TableIndices.TypeDef] < 0x0800 &&            tableSize[(int)TableIndices.Param] < 0x0800 &&            tableSize[(int)TableIndices.InterfaceImpl] < 0x0800 &&            tableSize[(int)TableIndices.MemberRef] < 0x0800 &&            tableSize[(int)TableIndices.Module] < 0x0800 &&            tableSize[(int)TableIndices.DeclSecurity] < 0x0800 &&            tableSize[(int)TableIndices.Property] < 0x0800 &&            tableSize[(int)TableIndices.Event] < 0x0800 &&            tableSize[(int)TableIndices.StandAloneSig] < 0x0800 &&            tableSize[(int)TableIndices.ModuleRef] < 0x0800 &&            tableSize[(int)TableIndices.TypeSpec] < 0x0800 &&            tableSize[(int)TableIndices.Assembly] < 0x0800 &&            tableSize[(int)TableIndices.File] < 0x0800 &&            tableSize[(int)TableIndices.ExportedType] < 0x0800 &&            tableSize[(int)TableIndices.ManifestResource] < 0x0800 &&            tableSize[(int)TableIndices.GenericParam] < 0x0800 &&            tableSize[(int)TableIndices.MethodSpec] < 0x0800 &&            tableSize[(int)TableIndices.GenericParamConstraint] < 0x0800 ? 2 : 4;        }else{          customAttributeParentRefSize = this.customAttributeParentRefSize =            tableSize[(int)TableIndices.Method] < 0x0800 &&            tableSize[(int)TableIndices.Field] < 0x0800 &&            tableSize[(int)TableIndices.TypeRef] < 0x0800 &&            tableSize[(int)TableIndices.TypeDef] < 0x0800 &&            tableSize[(int)TableIndices.Param] < 0x0800 &&            tableSize[(int)TableIndices.InterfaceImpl] < 0x0800 &&            tableSize[(int)TableIndices.MemberRef] < 0x0800 &&            tableSize[(int)TableIndices.Module] < 0x0800 &&            tableSize[(int)TableIndices.DeclSecurity] < 0x0800 &&            tableSize[(int)TableIndices.Property] < 0x0800 &&            tableSize[(int)TableIndices.Event] < 0x0800 &&            tableSize[(int)TableIndices.StandAloneSig] < 0x0800 &&            tableSize[(int)TableIndices.ModuleRef] < 0x0800 &&            tableSize[(int)TableIndices.TypeSpec] < 0x0800 &&            tableSize[(int)TableIndices.Assembly] < 0x0800 &&            tableSize[(int)TableIndices.File] < 0x0800 &&            tableSize[(int)TableIndices.ExportedType] < 0x0800 &&            tableSize[(int)TableIndices.ManifestResource] < 0x0800 ? 2 : 4;        }
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: int customAttributeConstructorRefSize = this.customAttributeConstructorRefSize =          tableSize[(int)TableIndices.Method] < 0x2000 &&          tableSize[(int)TableIndices.MemberRef] < 0x2000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: int customAttributeConstructorRefSize = this.customAttributeConstructorRefSize =          tableSize[(int)TableIndices.Method] < 0x2000 &&          tableSize[(int)TableIndices.MemberRef] < 0x2000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: int declSecurityParentRefSize = this.declSecurityParentRefSize =           tableSize[(int)TableIndices.TypeDef] < 0x4000 &&           tableSize[(int)TableIndices.Method] < 0x4000 &&           tableSize[(int)TableIndices.Assembly] < 0x4000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: int declSecurityParentRefSize = this.declSecurityParentRefSize =           tableSize[(int)TableIndices.TypeDef] < 0x4000 &&           tableSize[(int)TableIndices.Method] < 0x4000 &&           tableSize[(int)TableIndices.Assembly] < 0x4000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: int fieldMarshalParentRefSize = this.fieldMarshalParentRefSize =           tableSize[(int)TableIndices.Field] < 0x8000 &&           tableSize[(int)TableIndices.Param] < 0x8000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: int fieldMarshalParentRefSize = this.fieldMarshalParentRefSize =           tableSize[(int)TableIndices.Field] < 0x8000 &&           tableSize[(int)TableIndices.Param] < 0x8000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: int guidRefSize = this.guidRefSize = ((tablesHeader.heapSizes & 0x02) == 0 ? 2 : 4);
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: int guidRefSize = this.guidRefSize = ((tablesHeader.heapSizes & 0x02) == 0 ? 2 : 4);
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: int hasSemanticRefSize = this.hasSemanticRefSize =           tableSize[(int)TableIndices.Event] < 0x8000 &&           tableSize[(int)TableIndices.Property] < 0x8000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: int hasSemanticRefSize = this.hasSemanticRefSize =           tableSize[(int)TableIndices.Event] < 0x8000 &&           tableSize[(int)TableIndices.Property] < 0x8000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: int implementationRefSize = this.implementationRefSize =           tableSize[(int)TableIndices.File] < 0x4000 &&           tableSize[(int)TableIndices.AssemblyRef] < 0x4000 &&           tableSize[(int)TableIndices.ExportedType] < 0x4000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: int implementationRefSize = this.implementationRefSize =           tableSize[(int)TableIndices.File] < 0x4000 &&           tableSize[(int)TableIndices.AssemblyRef] < 0x4000 &&           tableSize[(int)TableIndices.ExportedType] < 0x4000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: int methodDefOrRefSize = this.methodDefOrRefSize =           tableSize[(int)TableIndices.Method] < 0x8000 &&           tableSize[(int)TableIndices.MemberRef] < 0x8000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: int methodDefOrRefSize = this.methodDefOrRefSize =           tableSize[(int)TableIndices.Method] < 0x8000 &&           tableSize[(int)TableIndices.MemberRef] < 0x8000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: int memberRefParentSize = this.memberRefParentSize =          tableSize[(int)TableIndices.TypeDef] < 0x2000 &&          tableSize[(int)TableIndices.TypeRef] < 0x2000 &&          tableSize[(int)TableIndices.ModuleRef] < 0x2000 &&          tableSize[(int)TableIndices.Method] < 0x2000 &&          tableSize[(int)TableIndices.TypeSpec] < 0x2000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: int memberRefParentSize = this.memberRefParentSize =          tableSize[(int)TableIndices.TypeDef] < 0x2000 &&          tableSize[(int)TableIndices.TypeRef] < 0x2000 &&          tableSize[(int)TableIndices.ModuleRef] < 0x2000 &&          tableSize[(int)TableIndices.Method] < 0x2000 &&          tableSize[(int)TableIndices.TypeSpec] < 0x2000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: int memberForwardedRefSize = this.memberForwardedRefSize =           tableSize[(int)TableIndices.Field] < 0x8000 &&           tableSize[(int)TableIndices.Method] < 0x8000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: int memberForwardedRefSize = this.memberForwardedRefSize =           tableSize[(int)TableIndices.Field] < 0x8000 &&           tableSize[(int)TableIndices.Method] < 0x8000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: int typeDefOrMethodDefSize = this.typeDefOrMethodDefSize =          tableSize[(int)TableIndices.TypeDef] < 0x8000 &&          tableSize[(int)TableIndices.Method] < 0x8000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: int typeDefOrMethodDefSize = this.typeDefOrMethodDefSize =          tableSize[(int)TableIndices.TypeDef] < 0x8000 &&          tableSize[(int)TableIndices.Method] < 0x8000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: int typeDefOrRefOrSpecSize = this.typeDefOrRefOrSpecSize =           tableSize[(int)TableIndices.TypeDef] < 0x4000 &&           tableSize[(int)TableIndices.TypeRef] < 0x4000 &&           tableSize[(int)TableIndices.TypeSpec] < 0x4000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: int typeDefOrRefOrSpecSize = this.typeDefOrRefOrSpecSize =           tableSize[(int)TableIndices.TypeDef] < 0x4000 &&           tableSize[(int)TableIndices.TypeRef] < 0x4000 &&           tableSize[(int)TableIndices.TypeSpec] < 0x4000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: int resolutionScopeRefSize = this.resolutionScopeRefSize =          tableSize[(int)TableIndices.Module] < 0x4000 &&          tableSize[(int)TableIndices.ModuleRef] < 0x4000 &&          tableSize[(int)TableIndices.AssemblyRef] < 0x4000 &&          tableSize[(int)TableIndices.TypeRef] < 0x4000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: int resolutionScopeRefSize = this.resolutionScopeRefSize =          tableSize[(int)TableIndices.Module] < 0x4000 &&          tableSize[(int)TableIndices.ModuleRef] < 0x4000 &&          tableSize[(int)TableIndices.AssemblyRef] < 0x4000 &&          tableSize[(int)TableIndices.TypeRef] < 0x4000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: int stringRefSize = this.stringRefSize = ((tablesHeader.heapSizes & 0x01) == 0 ? 2 : 4);
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: int stringRefSize = this.stringRefSize = ((tablesHeader.heapSizes & 0x01) == 0 ? 2 : 4);
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: int offset = this.mdOffset + this.tables.offset + 24 + countArray.Length*4;
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: int offset = this.mdOffset + this.tables.offset + 24 + countArray.Length*4;
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          tableOffset[i] = offset;          switch((TableIndices)i){            case TableIndices.Module : offset += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : offset += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : offset += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.FieldPtr: offset += m * (tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.Field : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodPtr : offset += m * (tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Method : offset += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.ParamPtr: offset += m * (tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : offset += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : offset += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : offset += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : offset += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : offset += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : offset += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : offset += m * (blobRefSize); break;            case TableIndices.EventMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.EventPtr: offset += m * (tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.PropertyPtr: offset += m * (tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : offset += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : offset += m * (stringRefSize); break;            case TableIndices.TypeSpec : offset += m * (blobRefSize); break;            case TableIndices.ImplMap : offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : offset += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyProcessor : offset += m * (4); break;            case TableIndices.AssemblyOS : offset += m * (12); break;            case TableIndices.AssemblyRef : offset += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRefProcessor : offset += m * (4 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.AssemblyRefOS : offset += m * (12 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.File : offset += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : offset += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : offset += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : offset += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)                offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: offset += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: offset += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;            default: throw new InvalidMetadataException(ExceptionStrings.UnsupportedTableEncountered);          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          tableOffset[i] = offset;          switch((TableIndices)i){            case TableIndices.Module : offset += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : offset += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : offset += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.FieldPtr: offset += m * (tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.Field : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodPtr : offset += m * (tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Method : offset += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.ParamPtr: offset += m * (tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : offset += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : offset += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : offset += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : offset += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : offset += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : offset += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : offset += m * (blobRefSize); break;            case TableIndices.EventMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.EventPtr: offset += m * (tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.PropertyPtr: offset += m * (tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : offset += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : offset += m * (stringRefSize); break;            case TableIndices.TypeSpec : offset += m * (blobRefSize); break;            case TableIndices.ImplMap : offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : offset += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyProcessor : offset += m * (4); break;            case TableIndices.AssemblyOS : offset += m * (12); break;            case TableIndices.AssemblyRef : offset += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRefProcessor : offset += m * (4 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.AssemblyRefOS : offset += m * (12 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.File : offset += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : offset += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : offset += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : offset += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)                offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: offset += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: offset += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;            default: throw new InvalidMetadataException(ExceptionStrings.UnsupportedTableEncountered);          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          tableOffset[i] = offset;          switch((TableIndices)i){            case TableIndices.Module : offset += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : offset += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : offset += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.FieldPtr: offset += m * (tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.Field : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodPtr : offset += m * (tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Method : offset += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.ParamPtr: offset += m * (tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : offset += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : offset += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : offset += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : offset += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : offset += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : offset += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : offset += m * (blobRefSize); break;            case TableIndices.EventMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.EventPtr: offset += m * (tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.PropertyPtr: offset += m * (tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : offset += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : offset += m * (stringRefSize); break;            case TableIndices.TypeSpec : offset += m * (blobRefSize); break;            case TableIndices.ImplMap : offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : offset += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyProcessor : offset += m * (4); break;            case TableIndices.AssemblyOS : offset += m * (12); break;            case TableIndices.AssemblyRef : offset += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRefProcessor : offset += m * (4 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.AssemblyRefOS : offset += m * (12 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.File : offset += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : offset += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : offset += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : offset += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)                offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: offset += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: offset += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;            default: throw new InvalidMetadataException(ExceptionStrings.UnsupportedTableEncountered);          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          tableOffset[i] = offset;          switch((TableIndices)i){            case TableIndices.Module : offset += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : offset += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : offset += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.FieldPtr: offset += m * (tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.Field : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodPtr : offset += m * (tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Method : offset += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.ParamPtr: offset += m * (tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : offset += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : offset += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : offset += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : offset += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : offset += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : offset += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : offset += m * (blobRefSize); break;            case TableIndices.EventMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.EventPtr: offset += m * (tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.PropertyPtr: offset += m * (tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : offset += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : offset += m * (stringRefSize); break;            case TableIndices.TypeSpec : offset += m * (blobRefSize); break;            case TableIndices.ImplMap : offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : offset += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyProcessor : offset += m * (4); break;            case TableIndices.AssemblyOS : offset += m * (12); break;            case TableIndices.AssemblyRef : offset += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRefProcessor : offset += m * (4 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.AssemblyRefOS : offset += m * (12 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.File : offset += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : offset += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : offset += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : offset += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)                offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: offset += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: offset += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;            default: throw new InvalidMetadataException(ExceptionStrings.UnsupportedTableEncountered);          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          tableOffset[i] = offset;          switch((TableIndices)i){            case TableIndices.Module : offset += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : offset += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : offset += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.FieldPtr: offset += m * (tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.Field : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodPtr : offset += m * (tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Method : offset += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.ParamPtr: offset += m * (tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : offset += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : offset += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : offset += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : offset += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : offset += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : offset += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : offset += m * (blobRefSize); break;            case TableIndices.EventMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.EventPtr: offset += m * (tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.PropertyPtr: offset += m * (tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : offset += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : offset += m * (stringRefSize); break;            case TableIndices.TypeSpec : offset += m * (blobRefSize); break;            case TableIndices.ImplMap : offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : offset += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyProcessor : offset += m * (4); break;            case TableIndices.AssemblyOS : offset += m * (12); break;            case TableIndices.AssemblyRef : offset += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRefProcessor : offset += m * (4 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.AssemblyRefOS : offset += m * (12 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.File : offset += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : offset += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : offset += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : offset += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)                offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: offset += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: offset += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;            default: throw new InvalidMetadataException(ExceptionStrings.UnsupportedTableEncountered);          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          tableOffset[i] = offset;          switch((TableIndices)i){            case TableIndices.Module : offset += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : offset += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : offset += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.FieldPtr: offset += m * (tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.Field : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodPtr : offset += m * (tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Method : offset += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.ParamPtr: offset += m * (tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : offset += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : offset += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : offset += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : offset += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : offset += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : offset += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : offset += m * (blobRefSize); break;            case TableIndices.EventMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.EventPtr: offset += m * (tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.PropertyPtr: offset += m * (tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : offset += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : offset += m * (stringRefSize); break;            case TableIndices.TypeSpec : offset += m * (blobRefSize); break;            case TableIndices.ImplMap : offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : offset += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyProcessor : offset += m * (4); break;            case TableIndices.AssemblyOS : offset += m * (12); break;            case TableIndices.AssemblyRef : offset += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRefProcessor : offset += m * (4 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.AssemblyRefOS : offset += m * (12 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.File : offset += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : offset += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : offset += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : offset += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)                offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: offset += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: offset += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;            default: throw new InvalidMetadataException(ExceptionStrings.UnsupportedTableEncountered);          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          tableOffset[i] = offset;          switch((TableIndices)i){            case TableIndices.Module : offset += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : offset += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : offset += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.FieldPtr: offset += m * (tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.Field : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodPtr : offset += m * (tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Method : offset += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.ParamPtr: offset += m * (tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : offset += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : offset += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : offset += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : offset += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : offset += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : offset += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : offset += m * (blobRefSize); break;            case TableIndices.EventMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.EventPtr: offset += m * (tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.PropertyPtr: offset += m * (tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : offset += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : offset += m * (stringRefSize); break;            case TableIndices.TypeSpec : offset += m * (blobRefSize); break;            case TableIndices.ImplMap : offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : offset += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyProcessor : offset += m * (4); break;            case TableIndices.AssemblyOS : offset += m * (12); break;            case TableIndices.AssemblyRef : offset += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRefProcessor : offset += m * (4 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.AssemblyRefOS : offset += m * (12 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.File : offset += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : offset += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : offset += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : offset += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)                offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: offset += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: offset += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;            default: throw new InvalidMetadataException(ExceptionStrings.UnsupportedTableEncountered);          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          tableOffset[i] = offset;          switch((TableIndices)i){            case TableIndices.Module : offset += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : offset += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : offset += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.FieldPtr: offset += m * (tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.Field : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodPtr : offset += m * (tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Method : offset += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.ParamPtr: offset += m * (tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : offset += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : offset += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : offset += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : offset += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : offset += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : offset += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : offset += m * (blobRefSize); break;            case TableIndices.EventMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.EventPtr: offset += m * (tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.PropertyPtr: offset += m * (tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : offset += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : offset += m * (stringRefSize); break;            case TableIndices.TypeSpec : offset += m * (blobRefSize); break;            case TableIndices.ImplMap : offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : offset += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyProcessor : offset += m * (4); break;            case TableIndices.AssemblyOS : offset += m * (12); break;            case TableIndices.AssemblyRef : offset += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRefProcessor : offset += m * (4 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.AssemblyRefOS : offset += m * (12 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.File : offset += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : offset += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : offset += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : offset += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)                offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: offset += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: offset += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;            default: throw new InvalidMetadataException(ExceptionStrings.UnsupportedTableEncountered);          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          tableOffset[i] = offset;          switch((TableIndices)i){            case TableIndices.Module : offset += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : offset += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : offset += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.FieldPtr: offset += m * (tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.Field : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodPtr : offset += m * (tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Method : offset += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.ParamPtr: offset += m * (tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : offset += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : offset += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : offset += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : offset += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : offset += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : offset += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : offset += m * (blobRefSize); break;            case TableIndices.EventMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.EventPtr: offset += m * (tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.PropertyPtr: offset += m * (tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : offset += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : offset += m * (stringRefSize); break;            case TableIndices.TypeSpec : offset += m * (blobRefSize); break;            case TableIndices.ImplMap : offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : offset += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyProcessor : offset += m * (4); break;            case TableIndices.AssemblyOS : offset += m * (12); break;            case TableIndices.AssemblyRef : offset += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRefProcessor : offset += m * (4 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.AssemblyRefOS : offset += m * (12 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.File : offset += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : offset += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : offset += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : offset += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)                offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: offset += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: offset += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;            default: throw new InvalidMetadataException(ExceptionStrings.UnsupportedTableEncountered);          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          tableOffset[i] = offset;          switch((TableIndices)i){            case TableIndices.Module : offset += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : offset += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : offset += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.FieldPtr: offset += m * (tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.Field : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodPtr : offset += m * (tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Method : offset += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.ParamPtr: offset += m * (tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : offset += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : offset += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : offset += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : offset += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : offset += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : offset += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : offset += m * (blobRefSize); break;            case TableIndices.EventMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.EventPtr: offset += m * (tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.PropertyPtr: offset += m * (tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : offset += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : offset += m * (stringRefSize); break;            case TableIndices.TypeSpec : offset += m * (blobRefSize); break;            case TableIndices.ImplMap : offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : offset += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyProcessor : offset += m * (4); break;            case TableIndices.AssemblyOS : offset += m * (12); break;            case TableIndices.AssemblyRef : offset += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRefProcessor : offset += m * (4 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.AssemblyRefOS : offset += m * (12 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.File : offset += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : offset += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : offset += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : offset += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)                offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: offset += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: offset += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;            default: throw new InvalidMetadataException(ExceptionStrings.UnsupportedTableEncountered);          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          tableOffset[i] = offset;          switch((TableIndices)i){            case TableIndices.Module : offset += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : offset += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : offset += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.FieldPtr: offset += m * (tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.Field : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodPtr : offset += m * (tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Method : offset += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.ParamPtr: offset += m * (tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : offset += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : offset += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : offset += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : offset += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : offset += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : offset += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : offset += m * (blobRefSize); break;            case TableIndices.EventMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.EventPtr: offset += m * (tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.PropertyPtr: offset += m * (tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : offset += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : offset += m * (stringRefSize); break;            case TableIndices.TypeSpec : offset += m * (blobRefSize); break;            case TableIndices.ImplMap : offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : offset += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyProcessor : offset += m * (4); break;            case TableIndices.AssemblyOS : offset += m * (12); break;            case TableIndices.AssemblyRef : offset += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRefProcessor : offset += m * (4 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.AssemblyRefOS : offset += m * (12 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.File : offset += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : offset += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : offset += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : offset += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)                offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: offset += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: offset += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;            default: throw new InvalidMetadataException(ExceptionStrings.UnsupportedTableEncountered);          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          tableOffset[i] = offset;          switch((TableIndices)i){            case TableIndices.Module : offset += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : offset += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : offset += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.FieldPtr: offset += m * (tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.Field : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodPtr : offset += m * (tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Method : offset += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.ParamPtr: offset += m * (tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : offset += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : offset += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : offset += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : offset += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : offset += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : offset += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : offset += m * (blobRefSize); break;            case TableIndices.EventMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.EventPtr: offset += m * (tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.PropertyPtr: offset += m * (tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : offset += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : offset += m * (stringRefSize); break;            case TableIndices.TypeSpec : offset += m * (blobRefSize); break;            case TableIndices.ImplMap : offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : offset += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyProcessor : offset += m * (4); break;            case TableIndices.AssemblyOS : offset += m * (12); break;            case TableIndices.AssemblyRef : offset += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRefProcessor : offset += m * (4 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.AssemblyRefOS : offset += m * (12 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.File : offset += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : offset += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : offset += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : offset += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)                offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: offset += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: offset += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;            default: throw new InvalidMetadataException(ExceptionStrings.UnsupportedTableEncountered);          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          tableOffset[i] = offset;          switch((TableIndices)i){            case TableIndices.Module : offset += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : offset += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : offset += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.FieldPtr: offset += m * (tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.Field : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodPtr : offset += m * (tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Method : offset += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.ParamPtr: offset += m * (tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : offset += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : offset += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : offset += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : offset += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : offset += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : offset += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : offset += m * (blobRefSize); break;            case TableIndices.EventMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.EventPtr: offset += m * (tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.PropertyPtr: offset += m * (tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : offset += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : offset += m * (stringRefSize); break;            case TableIndices.TypeSpec : offset += m * (blobRefSize); break;            case TableIndices.ImplMap : offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : offset += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyProcessor : offset += m * (4); break;            case TableIndices.AssemblyOS : offset += m * (12); break;            case TableIndices.AssemblyRef : offset += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRefProcessor : offset += m * (4 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.AssemblyRefOS : offset += m * (12 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.File : offset += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : offset += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : offset += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : offset += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)                offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: offset += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: offset += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;            default: throw new InvalidMetadataException(ExceptionStrings.UnsupportedTableEncountered);          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          tableOffset[i] = offset;          switch((TableIndices)i){            case TableIndices.Module : offset += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : offset += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : offset += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.FieldPtr: offset += m * (tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.Field : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodPtr : offset += m * (tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Method : offset += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.ParamPtr: offset += m * (tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : offset += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : offset += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : offset += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : offset += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : offset += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : offset += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : offset += m * (blobRefSize); break;            case TableIndices.EventMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.EventPtr: offset += m * (tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.PropertyPtr: offset += m * (tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : offset += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : offset += m * (stringRefSize); break;            case TableIndices.TypeSpec : offset += m * (blobRefSize); break;            case TableIndices.ImplMap : offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : offset += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyProcessor : offset += m * (4); break;            case TableIndices.AssemblyOS : offset += m * (12); break;            case TableIndices.AssemblyRef : offset += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRefProcessor : offset += m * (4 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.AssemblyRefOS : offset += m * (12 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.File : offset += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : offset += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : offset += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : offset += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)                offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: offset += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: offset += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;            default: throw new InvalidMetadataException(ExceptionStrings.UnsupportedTableEncountered);          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          tableOffset[i] = offset;          switch((TableIndices)i){            case TableIndices.Module : offset += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : offset += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : offset += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.FieldPtr: offset += m * (tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.Field : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodPtr : offset += m * (tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Method : offset += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.ParamPtr: offset += m * (tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : offset += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : offset += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : offset += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : offset += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : offset += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : offset += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : offset += m * (blobRefSize); break;            case TableIndices.EventMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.EventPtr: offset += m * (tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.PropertyPtr: offset += m * (tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : offset += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : offset += m * (stringRefSize); break;            case TableIndices.TypeSpec : offset += m * (blobRefSize); break;            case TableIndices.ImplMap : offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : offset += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyProcessor : offset += m * (4); break;            case TableIndices.AssemblyOS : offset += m * (12); break;            case TableIndices.AssemblyRef : offset += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRefProcessor : offset += m * (4 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.AssemblyRefOS : offset += m * (12 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.File : offset += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : offset += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : offset += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : offset += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)                offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: offset += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: offset += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;            default: throw new InvalidMetadataException(ExceptionStrings.UnsupportedTableEncountered);          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          tableOffset[i] = offset;          switch((TableIndices)i){            case TableIndices.Module : offset += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : offset += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : offset += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.FieldPtr: offset += m * (tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.Field : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodPtr : offset += m * (tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Method : offset += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.ParamPtr: offset += m * (tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : offset += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : offset += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : offset += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : offset += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : offset += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : offset += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : offset += m * (blobRefSize); break;            case TableIndices.EventMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.EventPtr: offset += m * (tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.PropertyPtr: offset += m * (tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : offset += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : offset += m * (stringRefSize); break;            case TableIndices.TypeSpec : offset += m * (blobRefSize); break;            case TableIndices.ImplMap : offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : offset += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyProcessor : offset += m * (4); break;            case TableIndices.AssemblyOS : offset += m * (12); break;            case TableIndices.AssemblyRef : offset += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRefProcessor : offset += m * (4 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.AssemblyRefOS : offset += m * (12 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.File : offset += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : offset += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : offset += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : offset += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)                offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: offset += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: offset += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;            default: throw new InvalidMetadataException(ExceptionStrings.UnsupportedTableEncountered);          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          tableOffset[i] = offset;          switch((TableIndices)i){            case TableIndices.Module : offset += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : offset += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : offset += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.FieldPtr: offset += m * (tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.Field : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodPtr : offset += m * (tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Method : offset += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.ParamPtr: offset += m * (tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : offset += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : offset += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : offset += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : offset += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : offset += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : offset += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : offset += m * (blobRefSize); break;            case TableIndices.EventMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.EventPtr: offset += m * (tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.PropertyPtr: offset += m * (tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : offset += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : offset += m * (stringRefSize); break;            case TableIndices.TypeSpec : offset += m * (blobRefSize); break;            case TableIndices.ImplMap : offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : offset += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyProcessor : offset += m * (4); break;            case TableIndices.AssemblyOS : offset += m * (12); break;            case TableIndices.AssemblyRef : offset += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRefProcessor : offset += m * (4 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.AssemblyRefOS : offset += m * (12 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.File : offset += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : offset += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : offset += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : offset += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)                offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: offset += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: offset += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;            default: throw new InvalidMetadataException(ExceptionStrings.UnsupportedTableEncountered);          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          tableOffset[i] = offset;          switch((TableIndices)i){            case TableIndices.Module : offset += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : offset += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : offset += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.FieldPtr: offset += m * (tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.Field : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodPtr : offset += m * (tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Method : offset += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.ParamPtr: offset += m * (tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : offset += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : offset += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : offset += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : offset += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : offset += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : offset += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : offset += m * (blobRefSize); break;            case TableIndices.EventMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.EventPtr: offset += m * (tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.PropertyPtr: offset += m * (tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : offset += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : offset += m * (stringRefSize); break;            case TableIndices.TypeSpec : offset += m * (blobRefSize); break;            case TableIndices.ImplMap : offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : offset += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyProcessor : offset += m * (4); break;            case TableIndices.AssemblyOS : offset += m * (12); break;            case TableIndices.AssemblyRef : offset += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRefProcessor : offset += m * (4 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.AssemblyRefOS : offset += m * (12 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.File : offset += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : offset += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : offset += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : offset += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)                offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: offset += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: offset += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;            default: throw new InvalidMetadataException(ExceptionStrings.UnsupportedTableEncountered);          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          tableOffset[i] = offset;          switch((TableIndices)i){            case TableIndices.Module : offset += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : offset += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : offset += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.FieldPtr: offset += m * (tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.Field : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodPtr : offset += m * (tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Method : offset += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.ParamPtr: offset += m * (tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : offset += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : offset += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : offset += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : offset += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : offset += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : offset += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : offset += m * (blobRefSize); break;            case TableIndices.EventMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.EventPtr: offset += m * (tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.PropertyPtr: offset += m * (tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : offset += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : offset += m * (stringRefSize); break;            case TableIndices.TypeSpec : offset += m * (blobRefSize); break;            case TableIndices.ImplMap : offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : offset += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyProcessor : offset += m * (4); break;            case TableIndices.AssemblyOS : offset += m * (12); break;            case TableIndices.AssemblyRef : offset += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRefProcessor : offset += m * (4 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.AssemblyRefOS : offset += m * (12 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.File : offset += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : offset += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : offset += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : offset += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)                offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: offset += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: offset += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;            default: throw new InvalidMetadataException(ExceptionStrings.UnsupportedTableEncountered);          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          tableOffset[i] = offset;          switch((TableIndices)i){            case TableIndices.Module : offset += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : offset += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : offset += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.FieldPtr: offset += m * (tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.Field : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodPtr : offset += m * (tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Method : offset += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.ParamPtr: offset += m * (tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : offset += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : offset += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : offset += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : offset += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : offset += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : offset += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : offset += m * (blobRefSize); break;            case TableIndices.EventMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.EventPtr: offset += m * (tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.PropertyPtr: offset += m * (tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : offset += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : offset += m * (stringRefSize); break;            case TableIndices.TypeSpec : offset += m * (blobRefSize); break;            case TableIndices.ImplMap : offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : offset += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyProcessor : offset += m * (4); break;            case TableIndices.AssemblyOS : offset += m * (12); break;            case TableIndices.AssemblyRef : offset += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRefProcessor : offset += m * (4 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.AssemblyRefOS : offset += m * (12 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.File : offset += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : offset += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : offset += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : offset += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)                offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: offset += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: offset += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;            default: throw new InvalidMetadataException(ExceptionStrings.UnsupportedTableEncountered);          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          tableOffset[i] = offset;          switch((TableIndices)i){            case TableIndices.Module : offset += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : offset += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : offset += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.FieldPtr: offset += m * (tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.Field : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodPtr : offset += m * (tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Method : offset += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.ParamPtr: offset += m * (tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : offset += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : offset += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : offset += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : offset += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : offset += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : offset += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : offset += m * (blobRefSize); break;            case TableIndices.EventMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.EventPtr: offset += m * (tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.PropertyPtr: offset += m * (tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : offset += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : offset += m * (stringRefSize); break;            case TableIndices.TypeSpec : offset += m * (blobRefSize); break;            case TableIndices.ImplMap : offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : offset += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyProcessor : offset += m * (4); break;            case TableIndices.AssemblyOS : offset += m * (12); break;            case TableIndices.AssemblyRef : offset += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRefProcessor : offset += m * (4 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.AssemblyRefOS : offset += m * (12 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.File : offset += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : offset += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : offset += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : offset += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)                offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: offset += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: offset += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;            default: throw new InvalidMetadataException(ExceptionStrings.UnsupportedTableEncountered);          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          tableOffset[i] = offset;          switch((TableIndices)i){            case TableIndices.Module : offset += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : offset += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : offset += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.FieldPtr: offset += m * (tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.Field : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodPtr : offset += m * (tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Method : offset += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.ParamPtr: offset += m * (tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : offset += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : offset += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : offset += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : offset += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : offset += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : offset += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : offset += m * (blobRefSize); break;            case TableIndices.EventMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.EventPtr: offset += m * (tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.PropertyPtr: offset += m * (tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : offset += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : offset += m * (stringRefSize); break;            case TableIndices.TypeSpec : offset += m * (blobRefSize); break;            case TableIndices.ImplMap : offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : offset += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyProcessor : offset += m * (4); break;            case TableIndices.AssemblyOS : offset += m * (12); break;            case TableIndices.AssemblyRef : offset += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRefProcessor : offset += m * (4 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.AssemblyRefOS : offset += m * (12 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.File : offset += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : offset += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : offset += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : offset += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)                offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: offset += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: offset += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;            default: throw new InvalidMetadataException(ExceptionStrings.UnsupportedTableEncountered);          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          tableOffset[i] = offset;          switch((TableIndices)i){            case TableIndices.Module : offset += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : offset += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : offset += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.FieldPtr: offset += m * (tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.Field : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodPtr : offset += m * (tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Method : offset += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.ParamPtr: offset += m * (tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : offset += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : offset += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : offset += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : offset += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : offset += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : offset += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : offset += m * (blobRefSize); break;            case TableIndices.EventMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.EventPtr: offset += m * (tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.PropertyPtr: offset += m * (tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : offset += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : offset += m * (stringRefSize); break;            case TableIndices.TypeSpec : offset += m * (blobRefSize); break;            case TableIndices.ImplMap : offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : offset += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyProcessor : offset += m * (4); break;            case TableIndices.AssemblyOS : offset += m * (12); break;            case TableIndices.AssemblyRef : offset += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRefProcessor : offset += m * (4 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.AssemblyRefOS : offset += m * (12 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.File : offset += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : offset += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : offset += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : offset += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)                offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: offset += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: offset += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;            default: throw new InvalidMetadataException(ExceptionStrings.UnsupportedTableEncountered);          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          tableOffset[i] = offset;          switch((TableIndices)i){            case TableIndices.Module : offset += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : offset += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : offset += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.FieldPtr: offset += m * (tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.Field : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodPtr : offset += m * (tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Method : offset += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.ParamPtr: offset += m * (tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : offset += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : offset += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : offset += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : offset += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : offset += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : offset += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : offset += m * (blobRefSize); break;            case TableIndices.EventMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.EventPtr: offset += m * (tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.PropertyPtr: offset += m * (tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : offset += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : offset += m * (stringRefSize); break;            case TableIndices.TypeSpec : offset += m * (blobRefSize); break;            case TableIndices.ImplMap : offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : offset += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyProcessor : offset += m * (4); break;            case TableIndices.AssemblyOS : offset += m * (12); break;            case TableIndices.AssemblyRef : offset += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRefProcessor : offset += m * (4 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.AssemblyRefOS : offset += m * (12 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.File : offset += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : offset += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : offset += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : offset += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)                offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: offset += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: offset += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;            default: throw new InvalidMetadataException(ExceptionStrings.UnsupportedTableEncountered);          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          tableOffset[i] = offset;          switch((TableIndices)i){            case TableIndices.Module : offset += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : offset += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : offset += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.FieldPtr: offset += m * (tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.Field : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodPtr : offset += m * (tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Method : offset += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.ParamPtr: offset += m * (tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : offset += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : offset += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : offset += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : offset += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : offset += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : offset += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : offset += m * (blobRefSize); break;            case TableIndices.EventMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.EventPtr: offset += m * (tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.PropertyPtr: offset += m * (tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : offset += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : offset += m * (stringRefSize); break;            case TableIndices.TypeSpec : offset += m * (blobRefSize); break;            case TableIndices.ImplMap : offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : offset += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyProcessor : offset += m * (4); break;            case TableIndices.AssemblyOS : offset += m * (12); break;            case TableIndices.AssemblyRef : offset += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRefProcessor : offset += m * (4 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.AssemblyRefOS : offset += m * (12 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.File : offset += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : offset += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : offset += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : offset += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)                offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: offset += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: offset += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;            default: throw new InvalidMetadataException(ExceptionStrings.UnsupportedTableEncountered);          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          tableOffset[i] = offset;          switch((TableIndices)i){            case TableIndices.Module : offset += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : offset += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : offset += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.FieldPtr: offset += m * (tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.Field : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodPtr : offset += m * (tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Method : offset += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.ParamPtr: offset += m * (tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : offset += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : offset += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : offset += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : offset += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : offset += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : offset += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : offset += m * (blobRefSize); break;            case TableIndices.EventMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.EventPtr: offset += m * (tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.PropertyPtr: offset += m * (tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : offset += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : offset += m * (stringRefSize); break;            case TableIndices.TypeSpec : offset += m * (blobRefSize); break;            case TableIndices.ImplMap : offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : offset += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyProcessor : offset += m * (4); break;            case TableIndices.AssemblyOS : offset += m * (12); break;            case TableIndices.AssemblyRef : offset += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRefProcessor : offset += m * (4 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.AssemblyRefOS : offset += m * (12 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.File : offset += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : offset += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : offset += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : offset += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)                offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: offset += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: offset += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;            default: throw new InvalidMetadataException(ExceptionStrings.UnsupportedTableEncountered);          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          tableOffset[i] = offset;          switch((TableIndices)i){            case TableIndices.Module : offset += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : offset += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : offset += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.FieldPtr: offset += m * (tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.Field : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodPtr : offset += m * (tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Method : offset += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.ParamPtr: offset += m * (tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : offset += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : offset += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : offset += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : offset += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : offset += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : offset += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : offset += m * (blobRefSize); break;            case TableIndices.EventMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.EventPtr: offset += m * (tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.PropertyPtr: offset += m * (tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : offset += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : offset += m * (stringRefSize); break;            case TableIndices.TypeSpec : offset += m * (blobRefSize); break;            case TableIndices.ImplMap : offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : offset += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyProcessor : offset += m * (4); break;            case TableIndices.AssemblyOS : offset += m * (12); break;            case TableIndices.AssemblyRef : offset += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRefProcessor : offset += m * (4 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.AssemblyRefOS : offset += m * (12 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.File : offset += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : offset += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : offset += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : offset += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)                offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: offset += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: offset += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;            default: throw new InvalidMetadataException(ExceptionStrings.UnsupportedTableEncountered);          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          tableOffset[i] = offset;          switch((TableIndices)i){            case TableIndices.Module : offset += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : offset += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : offset += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.FieldPtr: offset += m * (tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.Field : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodPtr : offset += m * (tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Method : offset += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.ParamPtr: offset += m * (tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : offset += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : offset += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : offset += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : offset += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : offset += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : offset += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : offset += m * (blobRefSize); break;            case TableIndices.EventMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.EventPtr: offset += m * (tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.PropertyPtr: offset += m * (tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : offset += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : offset += m * (stringRefSize); break;            case TableIndices.TypeSpec : offset += m * (blobRefSize); break;            case TableIndices.ImplMap : offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : offset += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyProcessor : offset += m * (4); break;            case TableIndices.AssemblyOS : offset += m * (12); break;            case TableIndices.AssemblyRef : offset += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRefProcessor : offset += m * (4 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.AssemblyRefOS : offset += m * (12 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.File : offset += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : offset += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : offset += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : offset += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)                offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: offset += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: offset += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;            default: throw new InvalidMetadataException(ExceptionStrings.UnsupportedTableEncountered);          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          tableOffset[i] = offset;          switch((TableIndices)i){            case TableIndices.Module : offset += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : offset += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : offset += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.FieldPtr: offset += m * (tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.Field : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodPtr : offset += m * (tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Method : offset += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.ParamPtr: offset += m * (tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : offset += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : offset += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : offset += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : offset += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : offset += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : offset += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : offset += m * (blobRefSize); break;            case TableIndices.EventMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.EventPtr: offset += m * (tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.PropertyPtr: offset += m * (tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : offset += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : offset += m * (stringRefSize); break;            case TableIndices.TypeSpec : offset += m * (blobRefSize); break;            case TableIndices.ImplMap : offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : offset += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyProcessor : offset += m * (4); break;            case TableIndices.AssemblyOS : offset += m * (12); break;            case TableIndices.AssemblyRef : offset += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRefProcessor : offset += m * (4 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.AssemblyRefOS : offset += m * (12 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.File : offset += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : offset += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : offset += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : offset += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)                offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: offset += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: offset += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;            default: throw new InvalidMetadataException(ExceptionStrings.UnsupportedTableEncountered);          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          tableOffset[i] = offset;          switch((TableIndices)i){            case TableIndices.Module : offset += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : offset += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : offset += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.FieldPtr: offset += m * (tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.Field : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodPtr : offset += m * (tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Method : offset += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.ParamPtr: offset += m * (tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : offset += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : offset += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : offset += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : offset += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : offset += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : offset += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : offset += m * (blobRefSize); break;            case TableIndices.EventMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.EventPtr: offset += m * (tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.PropertyPtr: offset += m * (tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : offset += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : offset += m * (stringRefSize); break;            case TableIndices.TypeSpec : offset += m * (blobRefSize); break;            case TableIndices.ImplMap : offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : offset += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyProcessor : offset += m * (4); break;            case TableIndices.AssemblyOS : offset += m * (12); break;            case TableIndices.AssemblyRef : offset += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRefProcessor : offset += m * (4 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.AssemblyRefOS : offset += m * (12 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.File : offset += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : offset += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : offset += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : offset += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)                offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: offset += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: offset += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;            default: throw new InvalidMetadataException(ExceptionStrings.UnsupportedTableEncountered);          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          tableOffset[i] = offset;          switch((TableIndices)i){            case TableIndices.Module : offset += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : offset += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : offset += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.FieldPtr: offset += m * (tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.Field : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodPtr : offset += m * (tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Method : offset += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.ParamPtr: offset += m * (tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : offset += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : offset += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : offset += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : offset += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : offset += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : offset += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : offset += m * (blobRefSize); break;            case TableIndices.EventMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.EventPtr: offset += m * (tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.PropertyPtr: offset += m * (tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : offset += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : offset += m * (stringRefSize); break;            case TableIndices.TypeSpec : offset += m * (blobRefSize); break;            case TableIndices.ImplMap : offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : offset += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyProcessor : offset += m * (4); break;            case TableIndices.AssemblyOS : offset += m * (12); break;            case TableIndices.AssemblyRef : offset += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRefProcessor : offset += m * (4 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.AssemblyRefOS : offset += m * (12 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.File : offset += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : offset += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : offset += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : offset += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)                offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: offset += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: offset += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;            default: throw new InvalidMetadataException(ExceptionStrings.UnsupportedTableEncountered);          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          tableOffset[i] = offset;          switch((TableIndices)i){            case TableIndices.Module : offset += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : offset += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : offset += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.FieldPtr: offset += m * (tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.Field : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodPtr : offset += m * (tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Method : offset += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.ParamPtr: offset += m * (tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : offset += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : offset += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : offset += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : offset += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : offset += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : offset += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : offset += m * (blobRefSize); break;            case TableIndices.EventMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.EventPtr: offset += m * (tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.PropertyPtr: offset += m * (tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : offset += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : offset += m * (stringRefSize); break;            case TableIndices.TypeSpec : offset += m * (blobRefSize); break;            case TableIndices.ImplMap : offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : offset += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyProcessor : offset += m * (4); break;            case TableIndices.AssemblyOS : offset += m * (12); break;            case TableIndices.AssemblyRef : offset += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRefProcessor : offset += m * (4 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.AssemblyRefOS : offset += m * (12 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.File : offset += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : offset += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : offset += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : offset += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)                offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: offset += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: offset += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;            default: throw new InvalidMetadataException(ExceptionStrings.UnsupportedTableEncountered);          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          tableOffset[i] = offset;          switch((TableIndices)i){            case TableIndices.Module : offset += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : offset += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : offset += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.FieldPtr: offset += m * (tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.Field : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodPtr : offset += m * (tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Method : offset += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.ParamPtr: offset += m * (tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : offset += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : offset += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : offset += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : offset += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : offset += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : offset += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : offset += m * (blobRefSize); break;            case TableIndices.EventMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.EventPtr: offset += m * (tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.PropertyPtr: offset += m * (tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : offset += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : offset += m * (stringRefSize); break;            case TableIndices.TypeSpec : offset += m * (blobRefSize); break;            case TableIndices.ImplMap : offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : offset += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyProcessor : offset += m * (4); break;            case TableIndices.AssemblyOS : offset += m * (12); break;            case TableIndices.AssemblyRef : offset += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRefProcessor : offset += m * (4 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.AssemblyRefOS : offset += m * (12 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.File : offset += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : offset += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : offset += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : offset += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)                offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: offset += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: offset += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;            default: throw new InvalidMetadataException(ExceptionStrings.UnsupportedTableEncountered);          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          tableOffset[i] = offset;          switch((TableIndices)i){            case TableIndices.Module : offset += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : offset += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : offset += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.FieldPtr: offset += m * (tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.Field : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodPtr : offset += m * (tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Method : offset += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.ParamPtr: offset += m * (tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : offset += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : offset += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : offset += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : offset += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : offset += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : offset += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : offset += m * (blobRefSize); break;            case TableIndices.EventMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.EventPtr: offset += m * (tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.PropertyPtr: offset += m * (tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : offset += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : offset += m * (stringRefSize); break;            case TableIndices.TypeSpec : offset += m * (blobRefSize); break;            case TableIndices.ImplMap : offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : offset += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyProcessor : offset += m * (4); break;            case TableIndices.AssemblyOS : offset += m * (12); break;            case TableIndices.AssemblyRef : offset += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRefProcessor : offset += m * (4 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.AssemblyRefOS : offset += m * (12 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.File : offset += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : offset += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : offset += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : offset += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)                offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: offset += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: offset += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;            default: throw new InvalidMetadataException(ExceptionStrings.UnsupportedTableEncountered);          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          tableOffset[i] = offset;          switch((TableIndices)i){            case TableIndices.Module : offset += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : offset += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : offset += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.FieldPtr: offset += m * (tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.Field : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodPtr : offset += m * (tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Method : offset += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.ParamPtr: offset += m * (tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : offset += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : offset += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : offset += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : offset += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : offset += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : offset += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : offset += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : offset += m * (blobRefSize); break;            case TableIndices.EventMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.EventPtr: offset += m * (tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : offset += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.PropertyPtr: offset += m * (tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : offset += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : offset += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : offset += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : offset += m * (stringRefSize); break;            case TableIndices.TypeSpec : offset += m * (blobRefSize); break;            case TableIndices.ImplMap : offset += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : offset += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : offset += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyProcessor : offset += m * (4); break;            case TableIndices.AssemblyOS : offset += m * (12); break;            case TableIndices.AssemblyRef : offset += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRefProcessor : offset += m * (4 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.AssemblyRefOS : offset += m * (12 + tableRefSize[(int)TableIndices.AssemblyRef]); break;            case TableIndices.File : offset += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : offset += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : offset += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : offset += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 0)                offset += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (this.metadataFormatMajorVersion == 1 && this.metadataFormatMinorVersion == 1)                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                offset += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: offset += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: offset += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;            default: throw new InvalidMetadataException(ExceptionStrings.UnsupportedTableEncountered);          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadCLIHeader,The following statement contains a magic number: c.SkipUInt16(2);
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadCLIHeader,The following statement contains a magic number: c.SkipInt32(2);
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadCLIHeader,The following statement contains a magic number: if (header.majorRuntimeVersion < 2)          throw new InvalidMetadataException(ExceptionStrings.BadCLIHeader);
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadDirectoryEntry,The following statement contains a magic number: c.SkipInt32(2);
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadMetadataHeader,The following statement contains a magic number: while (len++ % 4 != 0) c.ReadByte();
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadSectionHeader,The following statement contains a magic number: header.name                 = c.ReadASCII(8);
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadSectionHeader,The following statement contains a magic number: header.sizeOfRawData        = c.Int32(2);
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadSectionHeader,The following statement contains a magic number: header.pointerToRawData     = c.Int32(3);
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadSectionHeader,The following statement contains a magic number: header.pointerToRelocations = c.Int32(4);
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadSectionHeader,The following statement contains a magic number: header.pointerToLinenumbers = c.Int32(5);
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadSectionHeader,The following statement contains a magic number: c.SkipInt32(6);
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadSectionHeader,The following statement contains a magic number: c.SkipInt16(2);
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadStreamHeader,The following statement contains a magic number: c.Position += (4-(n%4))%4;
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadStreamHeader,The following statement contains a magic number: c.Position += (4-(n%4))%4;
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadStreamHeader,The following statement contains a magic number: c.Position += (4-(n%4))%4;
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadTablesHeader,The following statement contains a magic number: while (mask != 0){          if (mask % 2 == 1) n++;          mask /= 2;        }
Magic Number,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,ReadTablesHeader,The following statement contains a magic number: while (mask != 0){          if (mask % 2 == 1) n++;          mask /= 2;        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,SerializeMetadata,The following statement contains a magic number: while (tableOffset % 4 != 0) {writer.Write((byte)0); tableOffset++;}
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,SerializeMetadata,The following statement contains a magic number: if (this.PublicKey != null && 0 < this.PublicKey.Length){          this.cliHeader.strongNameSignature.virtualAddress = virtualAddressBase+72+tableOffset;          int keysize = this.PublicKey.Length - 32;          if (keysize < 128) keysize = 128;          this.cliHeader.strongNameSignature.size = keysize;          tableOffset += keysize;          writer.BaseStream.Position += keysize;        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,SerializeMetadata,The following statement contains a magic number: if (this.PublicKey != null && 0 < this.PublicKey.Length){          this.cliHeader.strongNameSignature.virtualAddress = virtualAddressBase+72+tableOffset;          int keysize = this.PublicKey.Length - 32;          if (keysize < 128) keysize = 128;          this.cliHeader.strongNameSignature.size = keysize;          tableOffset += keysize;          writer.BaseStream.Position += keysize;        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,SerializeMetadata,The following statement contains a magic number: if (this.PublicKey != null && 0 < this.PublicKey.Length){          this.cliHeader.strongNameSignature.virtualAddress = virtualAddressBase+72+tableOffset;          int keysize = this.PublicKey.Length - 32;          if (keysize < 128) keysize = 128;          this.cliHeader.strongNameSignature.size = keysize;          tableOffset += keysize;          writer.BaseStream.Position += keysize;        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,SerializeMetadata,The following statement contains a magic number: if (this.PublicKey != null && 0 < this.PublicKey.Length){          this.cliHeader.strongNameSignature.virtualAddress = virtualAddressBase+72+tableOffset;          int keysize = this.PublicKey.Length - 32;          if (keysize < 128) keysize = 128;          this.cliHeader.strongNameSignature.size = keysize;          tableOffset += keysize;          writer.BaseStream.Position += keysize;        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,SerializeMetadata,The following statement contains a magic number: if (this.ResourceDataHeap.Length > 0){          this.cliHeader.resources.virtualAddress = virtualAddressBase+72+tableOffset;          this.ResourceDataHeap.WriteTo(writer.BaseStream);          int sizeOfResources = (int)this.ResourceDataHeap.Length;          while (sizeOfResources % 4 != 0) {writer.Write((byte)0); sizeOfResources++;}          this.cliHeader.resources.size = sizeOfResources;          tableOffset += sizeOfResources;        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,SerializeMetadata,The following statement contains a magic number: if (this.ResourceDataHeap.Length > 0){          this.cliHeader.resources.virtualAddress = virtualAddressBase+72+tableOffset;          this.ResourceDataHeap.WriteTo(writer.BaseStream);          int sizeOfResources = (int)this.ResourceDataHeap.Length;          while (sizeOfResources % 4 != 0) {writer.Write((byte)0); sizeOfResources++;}          this.cliHeader.resources.size = sizeOfResources;          tableOffset += sizeOfResources;        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,SerializeMetadata,The following statement contains a magic number: this.cliHeader.metaData.virtualAddress = virtualAddressBase+72+tableOffset;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,SerializeMetadata,The following statement contains a magic number: writer.Write((int)12);
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,SerializeMetadata,The following statement contains a magic number: char[] version = new char[12];
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,SerializeMetadata,The following statement contains a magic number: Array.Copy(aversion' 0' version' 0' Math.Min(12' aversion.Length));
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,SerializeMetadata,The following statement contains a magic number: writer.Write((short)5);
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,SerializeMetadata,The following statement contains a magic number: int offsetFromStartOfMetadata = 108;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,SerializeMetadata,The following statement contains a magic number: while (offsetFromStartOfMetadata % 4 != 0) {          offsetFromStartOfMetadata++;          cbStringHeapPad++;        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,SerializeMetadata,The following statement contains a magic number: while (offsetFromStartOfMetadata % 4 != 0) {          offsetFromStartOfMetadata++;          cbUserStringHeapPad++;        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,SerializeMetadata,The following statement contains a magic number: while (offsetFromStartOfMetadata % 4 != 0) offsetFromStartOfMetadata++;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,SerializeMetadata,The following statement contains a magic number: writer.Write((int)this.GuidHeap.Length*16);
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,SerializeMetadata,The following statement contains a magic number: offsetFromStartOfMetadata += this.GuidHeap.Length*16;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,SerializeMetadata,The following statement contains a magic number: while (p % 4 != 0) { writer.Write((byte)0); p++; }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,SerializeMetadata,The following statement contains a magic number: while (p % 4 != 0) { writer.Write((byte)0); p++; }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,SerializeMetadata,The following statement contains a magic number: while (p % 4 != 0){ writer.Write((byte)0); p++;}
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,SerializeMetadata,The following statement contains a magic number: this.SerializeTables(writer' virtualAddressBase+72' sdataFixup' tlsFixup);
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WriteReferenceToPDBFile,The following statement contains a magic number: this.ntHeader.debugTable.size = 28;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WriteReferenceToPDBFile,The following statement contains a magic number: writer.Write((int)startPos+28-fileBase+virtualAddressBase);
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WriteReferenceToPDBFile,The following statement contains a magic number: writer.Write((int)startPos+28);
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,SerializeTables,The following statement contains a magic number: if (this.UseGenerics) {          writer.Write((byte)2); writer.Write((byte)0);        } else {          writer.Write((byte)1); writer.Write((byte)1);        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++)          tableRefSize[i] = tableSize[i] < 0x10000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++)          tableRefSize[i] = tableSize[i] < 0x10000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: int blobRefSize = this.blobRefSize = this.BlobHeap.Length < 0x10000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: int blobRefSize = this.blobRefSize = this.BlobHeap.Length < 0x10000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: int constantParentRefSize = this.constantParentRefSize =           tableSize[(int)TableIndices.Param] < 0x4000 &&           tableSize[(int)TableIndices.Field] < 0x4000 &&           tableSize[(int)TableIndices.Property] < 0x4000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: int constantParentRefSize = this.constantParentRefSize =           tableSize[(int)TableIndices.Param] < 0x4000 &&           tableSize[(int)TableIndices.Field] < 0x4000 &&           tableSize[(int)TableIndices.Property] < 0x4000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: int customAttributeParentRefSize = this.customAttributeParentRefSize =           tableSize[(int)TableIndices.Method] < 0x0800 &&          tableSize[(int)TableIndices.Field] < 0x0800 &&          tableSize[(int)TableIndices.TypeRef] < 0x0800 &&          tableSize[(int)TableIndices.TypeDef] < 0x0800 &&          tableSize[(int)TableIndices.Param] < 0x0800 &&          tableSize[(int)TableIndices.InterfaceImpl] < 0x0800 &&          tableSize[(int)TableIndices.MemberRef] < 0x0800 &&          tableSize[(int)TableIndices.Module] < 0x0800 &&          tableSize[(int)TableIndices.DeclSecurity] < 0x0800 &&          tableSize[(int)TableIndices.Property] < 0x0800 &&          tableSize[(int)TableIndices.Event] < 0x0800 &&          tableSize[(int)TableIndices.StandAloneSig] < 0x0800 &&          tableSize[(int)TableIndices.ModuleRef] < 0x0800 &&          tableSize[(int)TableIndices.TypeSpec] < 0x0800 &&          tableSize[(int)TableIndices.Assembly] < 0x0800 &&          tableSize[(int)TableIndices.File] < 0x0800 &&          tableSize[(int)TableIndices.ExportedType] < 0x0800 &&          tableSize[(int)TableIndices.ManifestResource] < 0x0800 &&          tableSize[(int)TableIndices.GenericParam] < 0x0800 &&          tableSize[(int)TableIndices.MethodSpec] < 0x0800 &&          tableSize[(int)TableIndices.GenericParamConstraint] < 0x0800 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: int customAttributeParentRefSize = this.customAttributeParentRefSize =           tableSize[(int)TableIndices.Method] < 0x0800 &&          tableSize[(int)TableIndices.Field] < 0x0800 &&          tableSize[(int)TableIndices.TypeRef] < 0x0800 &&          tableSize[(int)TableIndices.TypeDef] < 0x0800 &&          tableSize[(int)TableIndices.Param] < 0x0800 &&          tableSize[(int)TableIndices.InterfaceImpl] < 0x0800 &&          tableSize[(int)TableIndices.MemberRef] < 0x0800 &&          tableSize[(int)TableIndices.Module] < 0x0800 &&          tableSize[(int)TableIndices.DeclSecurity] < 0x0800 &&          tableSize[(int)TableIndices.Property] < 0x0800 &&          tableSize[(int)TableIndices.Event] < 0x0800 &&          tableSize[(int)TableIndices.StandAloneSig] < 0x0800 &&          tableSize[(int)TableIndices.ModuleRef] < 0x0800 &&          tableSize[(int)TableIndices.TypeSpec] < 0x0800 &&          tableSize[(int)TableIndices.Assembly] < 0x0800 &&          tableSize[(int)TableIndices.File] < 0x0800 &&          tableSize[(int)TableIndices.ExportedType] < 0x0800 &&          tableSize[(int)TableIndices.ManifestResource] < 0x0800 &&          tableSize[(int)TableIndices.GenericParam] < 0x0800 &&          tableSize[(int)TableIndices.MethodSpec] < 0x0800 &&          tableSize[(int)TableIndices.GenericParamConstraint] < 0x0800 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: int customAttributeConstructorRefSize = this.customAttributeConstructorRefSize =          tableSize[(int)TableIndices.Method] < 0x2000 &&          tableSize[(int)TableIndices.MemberRef] < 0x2000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: int customAttributeConstructorRefSize = this.customAttributeConstructorRefSize =          tableSize[(int)TableIndices.Method] < 0x2000 &&          tableSize[(int)TableIndices.MemberRef] < 0x2000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: int declSecurityParentRefSize = this.declSecurityParentRefSize =           tableSize[(int)TableIndices.TypeDef] < 0x4000 &&           tableSize[(int)TableIndices.Method] < 0x4000 &&           tableSize[(int)TableIndices.Assembly] < 0x4000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: int declSecurityParentRefSize = this.declSecurityParentRefSize =           tableSize[(int)TableIndices.TypeDef] < 0x4000 &&           tableSize[(int)TableIndices.Method] < 0x4000 &&           tableSize[(int)TableIndices.Assembly] < 0x4000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: int fieldMarshalParentRefSize = this.fieldMarshalParentRefSize =           tableSize[(int)TableIndices.Field] < 0x8000 &&           tableSize[(int)TableIndices.Param] < 0x8000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: int fieldMarshalParentRefSize = this.fieldMarshalParentRefSize =           tableSize[(int)TableIndices.Field] < 0x8000 &&           tableSize[(int)TableIndices.Param] < 0x8000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: int guidRefSize = this.guidRefSize = this.GuidHeap.Length < 0x10000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: int guidRefSize = this.guidRefSize = this.GuidHeap.Length < 0x10000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: int hasSemanticRefSize = this.hasSemanticRefSize =           tableSize[(int)TableIndices.Event] < 0x8000 &&           tableSize[(int)TableIndices.Property] < 0x8000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: int hasSemanticRefSize = this.hasSemanticRefSize =           tableSize[(int)TableIndices.Event] < 0x8000 &&           tableSize[(int)TableIndices.Property] < 0x8000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: int implementationRefSize = this.implementationRefSize =           tableSize[(int)TableIndices.File] < 0x4000 &&           tableSize[(int)TableIndices.AssemblyRef] < 0x4000 &&           tableSize[(int)TableIndices.ExportedType] < 0x4000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: int implementationRefSize = this.implementationRefSize =           tableSize[(int)TableIndices.File] < 0x4000 &&           tableSize[(int)TableIndices.AssemblyRef] < 0x4000 &&           tableSize[(int)TableIndices.ExportedType] < 0x4000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: int methodDefOrRefSize = this.methodDefOrRefSize =           tableSize[(int)TableIndices.Method] < 0x8000 &&           tableSize[(int)TableIndices.MemberRef] < 0x8000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: int methodDefOrRefSize = this.methodDefOrRefSize =           tableSize[(int)TableIndices.Method] < 0x8000 &&           tableSize[(int)TableIndices.MemberRef] < 0x8000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: int memberRefParentSize = this.memberRefParentSize =          tableSize[(int)TableIndices.TypeDef] < 0x2000 &&          tableSize[(int)TableIndices.TypeRef] < 0x2000 &&          tableSize[(int)TableIndices.ModuleRef] < 0x2000 &&          tableSize[(int)TableIndices.Method] < 0x2000 &&          tableSize[(int)TableIndices.TypeSpec] < 0x2000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: int memberRefParentSize = this.memberRefParentSize =          tableSize[(int)TableIndices.TypeDef] < 0x2000 &&          tableSize[(int)TableIndices.TypeRef] < 0x2000 &&          tableSize[(int)TableIndices.ModuleRef] < 0x2000 &&          tableSize[(int)TableIndices.Method] < 0x2000 &&          tableSize[(int)TableIndices.TypeSpec] < 0x2000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: int memberForwardedRefSize = this.memberForwardedRefSize =           tableSize[(int)TableIndices.Field] < 0x8000 &&           tableSize[(int)TableIndices.Method] < 0x8000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: int memberForwardedRefSize = this.memberForwardedRefSize =           tableSize[(int)TableIndices.Field] < 0x8000 &&           tableSize[(int)TableIndices.Method] < 0x8000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: int typeDefOrMethodDefSize = this.typeDefOrMethodDefSize =           tableSize[(int)TableIndices.TypeDef] < 0x8000 &&           tableSize[(int)TableIndices.Method] < 0x8000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: int typeDefOrMethodDefSize = this.typeDefOrMethodDefSize =           tableSize[(int)TableIndices.TypeDef] < 0x8000 &&           tableSize[(int)TableIndices.Method] < 0x8000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: int typeDefOrRefOrSpecSize = this.typeDefOrRefOrSpecSize =           tableSize[(int)TableIndices.TypeDef] < 0x4000 &&           tableSize[(int)TableIndices.TypeRef] < 0x4000 &&           tableSize[(int)TableIndices.TypeSpec] < 0x4000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: int typeDefOrRefOrSpecSize = this.typeDefOrRefOrSpecSize =           tableSize[(int)TableIndices.TypeDef] < 0x4000 &&           tableSize[(int)TableIndices.TypeRef] < 0x4000 &&           tableSize[(int)TableIndices.TypeSpec] < 0x4000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: int resolutionScopeRefSize = this.resolutionScopeRefSize =          tableSize[(int)TableIndices.Module] < 0x4000 &&          tableSize[(int)TableIndices.ModuleRef] < 0x4000 &&          tableSize[(int)TableIndices.AssemblyRef] < 0x4000 &&          tableSize[(int)TableIndices.TypeRef] < 0x4000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: int resolutionScopeRefSize = this.resolutionScopeRefSize =          tableSize[(int)TableIndices.Module] < 0x4000 &&          tableSize[(int)TableIndices.ModuleRef] < 0x4000 &&          tableSize[(int)TableIndices.AssemblyRef] < 0x4000 &&          tableSize[(int)TableIndices.TypeRef] < 0x4000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: int stringRefSize = this.stringRefSize = this.StringHeap.Length < 0x10000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: int stringRefSize = this.stringRefSize = this.StringHeap.Length < 0x10000 ? 2 : 4;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          switch((TableIndices)i){            case TableIndices.Module : length += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : length += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : length += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Field : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.Method : length += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : length += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : length += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : length += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : length += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : length += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : length += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : length += m * (blobRefSize); break;            case TableIndices.EventMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : length += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : length += m * (stringRefSize); break;            case TableIndices.TypeSpec : length += m * (blobRefSize); break;            case TableIndices.ImplMap : length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : length += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRef : length += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.File : length += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : length += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : length += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : length += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)                length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)                length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                length += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: length += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: length += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          switch((TableIndices)i){            case TableIndices.Module : length += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : length += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : length += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Field : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.Method : length += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : length += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : length += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : length += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : length += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : length += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : length += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : length += m * (blobRefSize); break;            case TableIndices.EventMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : length += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : length += m * (stringRefSize); break;            case TableIndices.TypeSpec : length += m * (blobRefSize); break;            case TableIndices.ImplMap : length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : length += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRef : length += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.File : length += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : length += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : length += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : length += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)                length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)                length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                length += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: length += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: length += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          switch((TableIndices)i){            case TableIndices.Module : length += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : length += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : length += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Field : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.Method : length += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : length += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : length += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : length += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : length += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : length += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : length += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : length += m * (blobRefSize); break;            case TableIndices.EventMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : length += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : length += m * (stringRefSize); break;            case TableIndices.TypeSpec : length += m * (blobRefSize); break;            case TableIndices.ImplMap : length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : length += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRef : length += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.File : length += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : length += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : length += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : length += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)                length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)                length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                length += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: length += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: length += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          switch((TableIndices)i){            case TableIndices.Module : length += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : length += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : length += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Field : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.Method : length += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : length += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : length += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : length += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : length += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : length += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : length += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : length += m * (blobRefSize); break;            case TableIndices.EventMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : length += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : length += m * (stringRefSize); break;            case TableIndices.TypeSpec : length += m * (blobRefSize); break;            case TableIndices.ImplMap : length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : length += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRef : length += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.File : length += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : length += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : length += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : length += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)                length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)                length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                length += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: length += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: length += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          switch((TableIndices)i){            case TableIndices.Module : length += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : length += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : length += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Field : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.Method : length += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : length += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : length += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : length += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : length += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : length += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : length += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : length += m * (blobRefSize); break;            case TableIndices.EventMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : length += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : length += m * (stringRefSize); break;            case TableIndices.TypeSpec : length += m * (blobRefSize); break;            case TableIndices.ImplMap : length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : length += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRef : length += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.File : length += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : length += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : length += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : length += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)                length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)                length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                length += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: length += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: length += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          switch((TableIndices)i){            case TableIndices.Module : length += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : length += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : length += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Field : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.Method : length += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : length += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : length += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : length += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : length += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : length += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : length += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : length += m * (blobRefSize); break;            case TableIndices.EventMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : length += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : length += m * (stringRefSize); break;            case TableIndices.TypeSpec : length += m * (blobRefSize); break;            case TableIndices.ImplMap : length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : length += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRef : length += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.File : length += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : length += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : length += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : length += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)                length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)                length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                length += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: length += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: length += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          switch((TableIndices)i){            case TableIndices.Module : length += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : length += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : length += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Field : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.Method : length += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : length += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : length += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : length += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : length += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : length += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : length += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : length += m * (blobRefSize); break;            case TableIndices.EventMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : length += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : length += m * (stringRefSize); break;            case TableIndices.TypeSpec : length += m * (blobRefSize); break;            case TableIndices.ImplMap : length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : length += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRef : length += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.File : length += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : length += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : length += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : length += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)                length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)                length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                length += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: length += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: length += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          switch((TableIndices)i){            case TableIndices.Module : length += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : length += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : length += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Field : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.Method : length += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : length += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : length += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : length += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : length += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : length += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : length += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : length += m * (blobRefSize); break;            case TableIndices.EventMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : length += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : length += m * (stringRefSize); break;            case TableIndices.TypeSpec : length += m * (blobRefSize); break;            case TableIndices.ImplMap : length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : length += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRef : length += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.File : length += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : length += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : length += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : length += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)                length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)                length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                length += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: length += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: length += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          switch((TableIndices)i){            case TableIndices.Module : length += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : length += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : length += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Field : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.Method : length += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : length += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : length += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : length += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : length += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : length += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : length += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : length += m * (blobRefSize); break;            case TableIndices.EventMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : length += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : length += m * (stringRefSize); break;            case TableIndices.TypeSpec : length += m * (blobRefSize); break;            case TableIndices.ImplMap : length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : length += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRef : length += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.File : length += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : length += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : length += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : length += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)                length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)                length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                length += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: length += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: length += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          switch((TableIndices)i){            case TableIndices.Module : length += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : length += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : length += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Field : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.Method : length += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : length += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : length += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : length += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : length += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : length += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : length += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : length += m * (blobRefSize); break;            case TableIndices.EventMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : length += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : length += m * (stringRefSize); break;            case TableIndices.TypeSpec : length += m * (blobRefSize); break;            case TableIndices.ImplMap : length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : length += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRef : length += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.File : length += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : length += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : length += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : length += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)                length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)                length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                length += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: length += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: length += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          switch((TableIndices)i){            case TableIndices.Module : length += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : length += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : length += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Field : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.Method : length += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : length += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : length += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : length += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : length += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : length += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : length += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : length += m * (blobRefSize); break;            case TableIndices.EventMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : length += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : length += m * (stringRefSize); break;            case TableIndices.TypeSpec : length += m * (blobRefSize); break;            case TableIndices.ImplMap : length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : length += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRef : length += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.File : length += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : length += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : length += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : length += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)                length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)                length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                length += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: length += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: length += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          switch((TableIndices)i){            case TableIndices.Module : length += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : length += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : length += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Field : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.Method : length += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : length += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : length += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : length += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : length += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : length += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : length += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : length += m * (blobRefSize); break;            case TableIndices.EventMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : length += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : length += m * (stringRefSize); break;            case TableIndices.TypeSpec : length += m * (blobRefSize); break;            case TableIndices.ImplMap : length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : length += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRef : length += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.File : length += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : length += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : length += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : length += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)                length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)                length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                length += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: length += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: length += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          switch((TableIndices)i){            case TableIndices.Module : length += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : length += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : length += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Field : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.Method : length += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : length += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : length += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : length += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : length += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : length += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : length += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : length += m * (blobRefSize); break;            case TableIndices.EventMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : length += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : length += m * (stringRefSize); break;            case TableIndices.TypeSpec : length += m * (blobRefSize); break;            case TableIndices.ImplMap : length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : length += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRef : length += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.File : length += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : length += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : length += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : length += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)                length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)                length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                length += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: length += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: length += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          switch((TableIndices)i){            case TableIndices.Module : length += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : length += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : length += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Field : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.Method : length += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : length += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : length += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : length += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : length += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : length += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : length += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : length += m * (blobRefSize); break;            case TableIndices.EventMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : length += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : length += m * (stringRefSize); break;            case TableIndices.TypeSpec : length += m * (blobRefSize); break;            case TableIndices.ImplMap : length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : length += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRef : length += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.File : length += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : length += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : length += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : length += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)                length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)                length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                length += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: length += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: length += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          switch((TableIndices)i){            case TableIndices.Module : length += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : length += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : length += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Field : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.Method : length += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : length += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : length += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : length += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : length += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : length += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : length += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : length += m * (blobRefSize); break;            case TableIndices.EventMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : length += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : length += m * (stringRefSize); break;            case TableIndices.TypeSpec : length += m * (blobRefSize); break;            case TableIndices.ImplMap : length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : length += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRef : length += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.File : length += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : length += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : length += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : length += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)                length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)                length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                length += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: length += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: length += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          switch((TableIndices)i){            case TableIndices.Module : length += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : length += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : length += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Field : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.Method : length += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : length += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : length += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : length += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : length += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : length += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : length += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : length += m * (blobRefSize); break;            case TableIndices.EventMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : length += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : length += m * (stringRefSize); break;            case TableIndices.TypeSpec : length += m * (blobRefSize); break;            case TableIndices.ImplMap : length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : length += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRef : length += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.File : length += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : length += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : length += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : length += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)                length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)                length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                length += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: length += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: length += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          switch((TableIndices)i){            case TableIndices.Module : length += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : length += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : length += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Field : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.Method : length += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : length += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : length += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : length += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : length += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : length += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : length += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : length += m * (blobRefSize); break;            case TableIndices.EventMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : length += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : length += m * (stringRefSize); break;            case TableIndices.TypeSpec : length += m * (blobRefSize); break;            case TableIndices.ImplMap : length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : length += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRef : length += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.File : length += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : length += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : length += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : length += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)                length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)                length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                length += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: length += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: length += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          switch((TableIndices)i){            case TableIndices.Module : length += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : length += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : length += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Field : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.Method : length += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : length += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : length += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : length += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : length += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : length += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : length += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : length += m * (blobRefSize); break;            case TableIndices.EventMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : length += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : length += m * (stringRefSize); break;            case TableIndices.TypeSpec : length += m * (blobRefSize); break;            case TableIndices.ImplMap : length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : length += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRef : length += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.File : length += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : length += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : length += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : length += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)                length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)                length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                length += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: length += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: length += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          switch((TableIndices)i){            case TableIndices.Module : length += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : length += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : length += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Field : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.Method : length += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : length += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : length += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : length += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : length += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : length += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : length += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : length += m * (blobRefSize); break;            case TableIndices.EventMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : length += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : length += m * (stringRefSize); break;            case TableIndices.TypeSpec : length += m * (blobRefSize); break;            case TableIndices.ImplMap : length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : length += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRef : length += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.File : length += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : length += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : length += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : length += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)                length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)                length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                length += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: length += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: length += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          switch((TableIndices)i){            case TableIndices.Module : length += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : length += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : length += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Field : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.Method : length += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : length += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : length += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : length += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : length += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : length += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : length += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : length += m * (blobRefSize); break;            case TableIndices.EventMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : length += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : length += m * (stringRefSize); break;            case TableIndices.TypeSpec : length += m * (blobRefSize); break;            case TableIndices.ImplMap : length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : length += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRef : length += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.File : length += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : length += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : length += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : length += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)                length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)                length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                length += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: length += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: length += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          switch((TableIndices)i){            case TableIndices.Module : length += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : length += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : length += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Field : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.Method : length += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : length += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : length += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : length += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : length += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : length += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : length += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : length += m * (blobRefSize); break;            case TableIndices.EventMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : length += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : length += m * (stringRefSize); break;            case TableIndices.TypeSpec : length += m * (blobRefSize); break;            case TableIndices.ImplMap : length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : length += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRef : length += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.File : length += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : length += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : length += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : length += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)                length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)                length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                length += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: length += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: length += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          switch((TableIndices)i){            case TableIndices.Module : length += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : length += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : length += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Field : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.Method : length += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : length += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : length += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : length += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : length += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : length += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : length += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : length += m * (blobRefSize); break;            case TableIndices.EventMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : length += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : length += m * (stringRefSize); break;            case TableIndices.TypeSpec : length += m * (blobRefSize); break;            case TableIndices.ImplMap : length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : length += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRef : length += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.File : length += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : length += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : length += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : length += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)                length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)                length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                length += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: length += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: length += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          switch((TableIndices)i){            case TableIndices.Module : length += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : length += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : length += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Field : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.Method : length += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : length += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : length += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : length += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : length += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : length += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : length += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : length += m * (blobRefSize); break;            case TableIndices.EventMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : length += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : length += m * (stringRefSize); break;            case TableIndices.TypeSpec : length += m * (blobRefSize); break;            case TableIndices.ImplMap : length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : length += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRef : length += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.File : length += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : length += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : length += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : length += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)                length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)                length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                length += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: length += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: length += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          switch((TableIndices)i){            case TableIndices.Module : length += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : length += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : length += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Field : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.Method : length += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : length += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : length += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : length += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : length += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : length += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : length += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : length += m * (blobRefSize); break;            case TableIndices.EventMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : length += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : length += m * (stringRefSize); break;            case TableIndices.TypeSpec : length += m * (blobRefSize); break;            case TableIndices.ImplMap : length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : length += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRef : length += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.File : length += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : length += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : length += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : length += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)                length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)                length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                length += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: length += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: length += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          switch((TableIndices)i){            case TableIndices.Module : length += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : length += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : length += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Field : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.Method : length += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : length += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : length += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : length += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : length += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : length += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : length += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : length += m * (blobRefSize); break;            case TableIndices.EventMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : length += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : length += m * (stringRefSize); break;            case TableIndices.TypeSpec : length += m * (blobRefSize); break;            case TableIndices.ImplMap : length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : length += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRef : length += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.File : length += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : length += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : length += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : length += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)                length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)                length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                length += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: length += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: length += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          switch((TableIndices)i){            case TableIndices.Module : length += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : length += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : length += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Field : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.Method : length += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : length += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : length += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : length += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : length += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : length += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : length += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : length += m * (blobRefSize); break;            case TableIndices.EventMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : length += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : length += m * (stringRefSize); break;            case TableIndices.TypeSpec : length += m * (blobRefSize); break;            case TableIndices.ImplMap : length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : length += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRef : length += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.File : length += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : length += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : length += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : length += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)                length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)                length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                length += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: length += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: length += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          switch((TableIndices)i){            case TableIndices.Module : length += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : length += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : length += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Field : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.Method : length += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : length += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : length += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : length += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : length += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : length += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : length += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : length += m * (blobRefSize); break;            case TableIndices.EventMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : length += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : length += m * (stringRefSize); break;            case TableIndices.TypeSpec : length += m * (blobRefSize); break;            case TableIndices.ImplMap : length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : length += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRef : length += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.File : length += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : length += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : length += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : length += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)                length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)                length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                length += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: length += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: length += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          switch((TableIndices)i){            case TableIndices.Module : length += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : length += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : length += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Field : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.Method : length += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : length += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : length += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : length += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : length += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : length += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : length += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : length += m * (blobRefSize); break;            case TableIndices.EventMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : length += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : length += m * (stringRefSize); break;            case TableIndices.TypeSpec : length += m * (blobRefSize); break;            case TableIndices.ImplMap : length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : length += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRef : length += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.File : length += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : length += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : length += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : length += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)                length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)                length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                length += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: length += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: length += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          switch((TableIndices)i){            case TableIndices.Module : length += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : length += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : length += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Field : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.Method : length += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : length += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : length += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : length += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : length += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : length += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : length += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : length += m * (blobRefSize); break;            case TableIndices.EventMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : length += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : length += m * (stringRefSize); break;            case TableIndices.TypeSpec : length += m * (blobRefSize); break;            case TableIndices.ImplMap : length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : length += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRef : length += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.File : length += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : length += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : length += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : length += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)                length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)                length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                length += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: length += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: length += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          switch((TableIndices)i){            case TableIndices.Module : length += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : length += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : length += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Field : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.Method : length += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : length += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : length += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : length += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : length += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : length += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : length += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : length += m * (blobRefSize); break;            case TableIndices.EventMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : length += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : length += m * (stringRefSize); break;            case TableIndices.TypeSpec : length += m * (blobRefSize); break;            case TableIndices.ImplMap : length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : length += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRef : length += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.File : length += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : length += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : length += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : length += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)                length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)                length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                length += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: length += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: length += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: for (int i = 0; i < (int)TableIndices.Count; i++){          int m = tableSize[i];          if (m == 0) continue;          switch((TableIndices)i){            case TableIndices.Module : length += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : length += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : length += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Field : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.Method : length += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : length += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : length += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : length += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : length += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : length += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : length += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : length += m * (blobRefSize); break;            case TableIndices.EventMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : length += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : length += m * (stringRefSize); break;            case TableIndices.TypeSpec : length += m * (blobRefSize); break;            case TableIndices.ImplMap : length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : length += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRef : length += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.File : length += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : length += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : length += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : length += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)                length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)                length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                length += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: length += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: length += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: length += 24+(tableCount*4);
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following statement contains a magic number: length += 24+(tableCount*4);
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WritePE,The following statement contains a magic number: switch (this.moduleKind){          case ModuleKindFlags.ConsoleApplication:             this.ntHeader.subsystem = 3;            break;          case ModuleKindFlags.DynamicallyLinkedLibrary:            this.ntHeader.characteristics |= 0x2000;            this.ntHeader.subsystem = 3;            break;          case ModuleKindFlags.WindowsApplication:            this.ntHeader.subsystem = 2;            break;        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WritePE,The following statement contains a magic number: switch (this.moduleKind){          case ModuleKindFlags.ConsoleApplication:             this.ntHeader.subsystem = 3;            break;          case ModuleKindFlags.DynamicallyLinkedLibrary:            this.ntHeader.characteristics |= 0x2000;            this.ntHeader.subsystem = 3;            break;          case ModuleKindFlags.WindowsApplication:            this.ntHeader.subsystem = 2;            break;        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WritePE,The following statement contains a magic number: switch (this.moduleKind){          case ModuleKindFlags.ConsoleApplication:             this.ntHeader.subsystem = 3;            break;          case ModuleKindFlags.DynamicallyLinkedLibrary:            this.ntHeader.characteristics |= 0x2000;            this.ntHeader.subsystem = 3;            break;          case ModuleKindFlags.WindowsApplication:            this.ntHeader.subsystem = 2;            break;        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WritePE,The following statement contains a magic number: int numSectionHeaders = 2;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WritePE,The following statement contains a magic number: textSection.virtualAddress = 8192;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WritePE,The following statement contains a magic number: int sizeOfPeHeaders = 376 + 40*numSectionHeaders;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WritePE,The following statement contains a magic number: int sizeOfPeHeaders = 376 + 40*numSectionHeaders;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WritePE,The following statement contains a magic number: if ((this.peKind & PEKindFlags.Requires64bits) != 0) sizeOfPeHeaders += 16;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WritePE,The following statement contains a magic number: writer.BaseStream.Position = textSection.pointerToRawData+72;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WritePE,The following statement contains a magic number: this.ntHeader.cliHeaderTable.size = 72;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WritePE,The following statement contains a magic number: relocSection.virtualSize = 12;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WritePE,The following statement contains a magic number: writer.Write((int)((RVAofEntryPointJumpTarget / 4096) * 4096));
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WritePE,The following statement contains a magic number: writer.Write((int)((RVAofEntryPointJumpTarget / 4096) * 4096));
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WritePE,The following statement contains a magic number: writer.Write((int)12);
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WritePE,The following statement contains a magic number: int offsetWithinPage = RVAofEntryPointJumpTarget % 4096;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WritePE,The following statement contains a magic number: short s = (short)(3 << 12 | offsetWithinPage);
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WritePE,The following statement contains a magic number: short s = (short)(3 << 12 | offsetWithinPage);
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WritePE,The following statement contains a magic number: writer.BaseStream.Position += m - 13;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WriteWin32Resources,The following statement contains a magic number: int sizeOfDirectoryTree = 16;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WriteWin32Resources,The following statement contains a magic number: for (int i = 0' n = rsrcs.Count; i < n; i++){          Win32Resource r = rsrcs[i];          bool typeDifferent = (r.TypeId < 0 && r.TypeName != lastTypeName) || r.TypeId > lastTypeID;          if (typeDifferent){            lastTypeID = r.TypeId;            lastTypeName = r.TypeName;            if (lastTypeID < 0) TypeDirectory.NumberOfNamedEntries++; else TypeDirectory.NumberOfIdEntries++;            sizeOfDirectoryTree += 24;            TypeDirectory.Entries.Add(NameDirectory = new Directory(lastTypeName' lastTypeID));          }          //^ assume NameDirectory != null;          if (typeDifferent || (r.Id < 0 && r.Name != lastName) || r.Id > lastID){            lastID = r.Id;            lastName = r.Name;            if (lastID < 0) NameDirectory.NumberOfNamedEntries++; else NameDirectory.NumberOfIdEntries++;            sizeOfDirectoryTree += 24;            NameDirectory.Entries.Add(LanguageDirectory = new Directory(lastName' lastID));          }          //^ assume LanguageDirectory != null;          LanguageDirectory.NumberOfIdEntries++;          sizeOfDirectoryTree += 8;          LanguageDirectory.Entries.Add(r);          continue;        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WriteWin32Resources,The following statement contains a magic number: for (int i = 0' n = rsrcs.Count; i < n; i++){          Win32Resource r = rsrcs[i];          bool typeDifferent = (r.TypeId < 0 && r.TypeName != lastTypeName) || r.TypeId > lastTypeID;          if (typeDifferent){            lastTypeID = r.TypeId;            lastTypeName = r.TypeName;            if (lastTypeID < 0) TypeDirectory.NumberOfNamedEntries++; else TypeDirectory.NumberOfIdEntries++;            sizeOfDirectoryTree += 24;            TypeDirectory.Entries.Add(NameDirectory = new Directory(lastTypeName' lastTypeID));          }          //^ assume NameDirectory != null;          if (typeDifferent || (r.Id < 0 && r.Name != lastName) || r.Id > lastID){            lastID = r.Id;            lastName = r.Name;            if (lastID < 0) NameDirectory.NumberOfNamedEntries++; else NameDirectory.NumberOfIdEntries++;            sizeOfDirectoryTree += 24;            NameDirectory.Entries.Add(LanguageDirectory = new Directory(lastName' lastID));          }          //^ assume LanguageDirectory != null;          LanguageDirectory.NumberOfIdEntries++;          sizeOfDirectoryTree += 8;          LanguageDirectory.Entries.Add(r);          continue;        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WriteWin32Resources,The following statement contains a magic number: for (int i = 0' n = rsrcs.Count; i < n; i++){          Win32Resource r = rsrcs[i];          bool typeDifferent = (r.TypeId < 0 && r.TypeName != lastTypeName) || r.TypeId > lastTypeID;          if (typeDifferent){            lastTypeID = r.TypeId;            lastTypeName = r.TypeName;            if (lastTypeID < 0) TypeDirectory.NumberOfNamedEntries++; else TypeDirectory.NumberOfIdEntries++;            sizeOfDirectoryTree += 24;            TypeDirectory.Entries.Add(NameDirectory = new Directory(lastTypeName' lastTypeID));          }          //^ assume NameDirectory != null;          if (typeDifferent || (r.Id < 0 && r.Name != lastName) || r.Id > lastID){            lastID = r.Id;            lastName = r.Name;            if (lastID < 0) NameDirectory.NumberOfNamedEntries++; else NameDirectory.NumberOfIdEntries++;            sizeOfDirectoryTree += 24;            NameDirectory.Entries.Add(LanguageDirectory = new Directory(lastName' lastID));          }          //^ assume LanguageDirectory != null;          LanguageDirectory.NumberOfIdEntries++;          sizeOfDirectoryTree += 8;          LanguageDirectory.Entries.Add(r);          continue;        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WriteDirectory,The following statement contains a magic number: int k = offset + 16 + n * 8;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WriteDirectory,The following statement contains a magic number: int k = offset + 16 + n * 8;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WriteDirectory,The following statement contains a magic number: for (int i = 0; i < n; i++){          int id = int.MinValue;          string name = null;          int nOff = dataHeap.BaseStream.Position+sizeOfDirectoryTree;          int dOff = k;          Directory subDir = directory.Entries[i] as Directory;          if (subDir != null){            id = subDir.ID;            name = subDir.Name;            if (level == 0)              k += this.SizeOfDirectory(subDir);            else              k += 16 + 8 * subDir.Entries.Count;          }else{            Win32Resource r = (Win32Resource)directory.Entries[i];            id = level == 0 ? r.TypeId : level == 1 ? r.Id : r.LanguageId;            name = level == 0 ? r.TypeName : level == 1 ? r.Name : null;            dataHeap.Write((int)(virtualAddressBase+sizeOfDirectoryTree+16+dataHeap.BaseStream.Position));            dataHeap.Write((int)r.Data.Length);            dataHeap.Write((int)r.CodePage);            dataHeap.Write((int)0);            dataHeap.Write(r.Data);          }          if (id >= 0)            writer.Write(id);          else{            if (name == null) name = "";            writer.Write(((uint)nOff)|0x80000000);            dataHeap.Write((ushort)name.Length);             dataHeap.Write(name.ToCharArray());  //REVIEW: what happens if the name contains chars that do not fit into a single utf8 code point?          }          if (subDir != null)            writer.Write(((uint)dOff)|0x80000000);          else            writer.Write(nOff);        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WriteDirectory,The following statement contains a magic number: for (int i = 0; i < n; i++){          int id = int.MinValue;          string name = null;          int nOff = dataHeap.BaseStream.Position+sizeOfDirectoryTree;          int dOff = k;          Directory subDir = directory.Entries[i] as Directory;          if (subDir != null){            id = subDir.ID;            name = subDir.Name;            if (level == 0)              k += this.SizeOfDirectory(subDir);            else              k += 16 + 8 * subDir.Entries.Count;          }else{            Win32Resource r = (Win32Resource)directory.Entries[i];            id = level == 0 ? r.TypeId : level == 1 ? r.Id : r.LanguageId;            name = level == 0 ? r.TypeName : level == 1 ? r.Name : null;            dataHeap.Write((int)(virtualAddressBase+sizeOfDirectoryTree+16+dataHeap.BaseStream.Position));            dataHeap.Write((int)r.Data.Length);            dataHeap.Write((int)r.CodePage);            dataHeap.Write((int)0);            dataHeap.Write(r.Data);          }          if (id >= 0)            writer.Write(id);          else{            if (name == null) name = "";            writer.Write(((uint)nOff)|0x80000000);            dataHeap.Write((ushort)name.Length);             dataHeap.Write(name.ToCharArray());  //REVIEW: what happens if the name contains chars that do not fit into a single utf8 code point?          }          if (subDir != null)            writer.Write(((uint)dOff)|0x80000000);          else            writer.Write(nOff);        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WriteDirectory,The following statement contains a magic number: for (int i = 0; i < n; i++){          int id = int.MinValue;          string name = null;          int nOff = dataHeap.BaseStream.Position+sizeOfDirectoryTree;          int dOff = k;          Directory subDir = directory.Entries[i] as Directory;          if (subDir != null){            id = subDir.ID;            name = subDir.Name;            if (level == 0)              k += this.SizeOfDirectory(subDir);            else              k += 16 + 8 * subDir.Entries.Count;          }else{            Win32Resource r = (Win32Resource)directory.Entries[i];            id = level == 0 ? r.TypeId : level == 1 ? r.Id : r.LanguageId;            name = level == 0 ? r.TypeName : level == 1 ? r.Name : null;            dataHeap.Write((int)(virtualAddressBase+sizeOfDirectoryTree+16+dataHeap.BaseStream.Position));            dataHeap.Write((int)r.Data.Length);            dataHeap.Write((int)r.CodePage);            dataHeap.Write((int)0);            dataHeap.Write(r.Data);          }          if (id >= 0)            writer.Write(id);          else{            if (name == null) name = "";            writer.Write(((uint)nOff)|0x80000000);            dataHeap.Write((ushort)name.Length);             dataHeap.Write(name.ToCharArray());  //REVIEW: what happens if the name contains chars that do not fit into a single utf8 code point?          }          if (subDir != null)            writer.Write(((uint)dOff)|0x80000000);          else            writer.Write(nOff);        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WriteDirectory,The following statement contains a magic number: k = offset + 16 + n * 8;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WriteDirectory,The following statement contains a magic number: k = offset + 16 + n * 8;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WriteDirectory,The following statement contains a magic number: for (int i = 0; i < n; i++){          Directory subDir = directory.Entries[i] as Directory;          if (subDir != null){            this.WriteDirectory(subDir' writer' k' level+1' sizeOfDirectoryTree' virtualAddressBase' dataHeap);            if (level == 0)              k += this.SizeOfDirectory(subDir);            else              k += 16 + 8 * subDir.Entries.Count;          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WriteDirectory,The following statement contains a magic number: for (int i = 0; i < n; i++){          Directory subDir = directory.Entries[i] as Directory;          if (subDir != null){            this.WriteDirectory(subDir' writer' k' level+1' sizeOfDirectoryTree' virtualAddressBase' dataHeap);            if (level == 0)              k += this.SizeOfDirectory(subDir);            else              k += 16 + 8 * subDir.Entries.Count;          }        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,SizeOfDirectory,The following statement contains a magic number: int size = 16 + 8 * n;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,SizeOfDirectory,The following statement contains a magic number: int size = 16 + 8 * n;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,SizeOfDirectory,The following statement contains a magic number: for (int i = 0; i < n; i++){          Directory subDir = directory.Entries[i] as Directory;          if (subDir != null)            size += 16 + 8 * subDir.Entries.Count;        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,SizeOfDirectory,The following statement contains a magic number: for (int i = 0; i < n; i++){          Directory subDir = directory.Entries[i] as Directory;          if (subDir != null)            size += 16 + 8 * subDir.Entries.Count;        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WriteNTHeader,The following statement contains a magic number: if ((this.peKind & PEKindFlags.Requires64bits) == 0){          ntHeader.magic = 0x10B; //PE32          ntHeader.machine = 0x014c; //I386        }else{          ntHeader.characteristics &= 0xFEFF; //Not 32-bit          ntHeader.characteristics |= 0x0020; //Can handle >2gb addresses          ntHeader.magic = 0x20B; //PE32+          if ((this.peKind & PEKindFlags.AMD) != 0)            ntHeader.machine = 0x8664; //AMD64          else            ntHeader.machine = 0x0200; //IA64          ntHeader.sizeOfOptionalHeader += 16;        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WriteSectionHeaders,The following statement contains a magic number: for (int i = 0' n = this.sectionHeaders.Length; i < n; i++){          SectionHeader hdr = sectionHeaders[i];          //^ assume hdr.name != null;          for (int j = 0' m = hdr.name.Length; j < 8; j++)            if (j < m) writer.Write(hdr.name[j]); else writer.Write((byte)0);          writer.Write(hdr.virtualSize);          writer.Write(hdr.virtualAddress);          writer.Write(hdr.sizeOfRawData);          writer.Write(hdr.pointerToRawData);          writer.Write(hdr.pointerToRelocations);          writer.Write(hdr.pointerToLinenumbers);          writer.Write(hdr.numberOfRelocations);          writer.Write(hdr.numberOfLinenumbers);          writer.Write(hdr.characteristics);        }
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WriteCLIHeader,The following statement contains a magic number: writer.Write((ushort)2);
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WriteCLIHeader,The following statement contains a magic number: if (this.UseGenerics)          writer.Write((ushort)5); //Violates the ECMA standard (25.3.3 of Partition II)' but apparently necessary        else          writer.Write((ushort)0);
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WriteCLIHeader,The following statement contains a magic number: if ((this.peKind & PEKindFlags.Requires32bits) != 0) hdr.flags |= 2;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WriteImportTableAndEntryPointStub,The following statement contains a magic number: while (pos % 4 != 0) {pos++; writer.Write((byte)0);}
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WriteImportTableAndEntryPointStub,The following statement contains a magic number: int ITLrva = ITrva + 40;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WriteImportTableAndEntryPointStub,The following statement contains a magic number: int rvasize = 12;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WriteImportTableAndEntryPointStub,The following statement contains a magic number: int hintRva = ITLrva + (use32bitAddresses ? 8 : 16);
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WriteImportTableAndEntryPointStub,The following statement contains a magic number: int hintRva = ITLrva + (use32bitAddresses ? 8 : 16);
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WriteImportTableAndEntryPointStub,The following statement contains a magic number: int nameRva = hintRva + 14;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WriteImportTableAndEntryPointStub,The following statement contains a magic number: int ITArva = nameRva + 14 +  // size of name of runtime dll                               4 + // size of entry point code 0000ff25                                rvasize;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WriteImportTableAndEntryPointStub,The following statement contains a magic number: int ITArva = nameRva + 14 +  // size of name of runtime dll                               4 + // size of entry point code 0000ff25                                rvasize;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WriteImportTableAndEntryPointStub,The following statement contains a magic number: this.ntHeader.addressOfEntryPoint = ITArva - rvasize - 2;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WriteImportTableAndEntryPointStub,The following statement contains a magic number: this.ntHeader.importTable.size = this.ntHeader.addressOfEntryPoint-ITrva-2;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WriteImportTableAndEntryPointStub,The following statement contains a magic number: this.ntHeader.importAddressTable.size = 8;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WriteImportTableAndEntryPointStub,The following statement contains a magic number: writer.BaseStream.Position += 20;
Magic Number,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WriteReference,The following statement contains a magic number: if (refSize == 2) writer.Write((short)index); else writer.Write(index);
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetUnderlyingTypeOfEnumNode,The following statement contains a magic number: for (int i = start; i < end; i++){          int ii = i;          if (fieldPtrs.Length > 0) ii = fieldPtrs[i-1].Field;          FieldRow fld = fieldDefs[ii-1];          if (fld.Field != null && !fld.Field.IsStatic){            underlyingType = fld.Field.Type;            break;          }          FieldFlags fieldFlags = (FieldFlags)fld.Flags;          if ((fieldFlags & FieldFlags.Static) == 0){            this.tables.GetSignatureLength(fld.Signature);            MemoryCursor sigReader = this.tables.GetNewCursor();                      GetAndCheckSignatureToken(6' sigReader);            underlyingType = this.ParseTypeSignature(sigReader);            break;          }        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,AddMoreStuffToParameters,The following statement contains a magic number: for (int i = start; i < end; i++){          ParamRow pr = pars[i-1];          if (pr.Sequence == 0 && method != null){            //The parameter entry with sequence 0 is used as a target for custom attributes that apply to the return value            method.ReturnAttributes = this.GetCustomAttributesFor((i << 5)|4);            if ((pr.Flags & (int)ParameterFlags.HasFieldMarshal) != 0)              method.ReturnTypeMarshallingInformation = this.GetMarshallingInformation((i << 1)|1);            this.AddMoreStuffToParameters(null' parameters' start+1' end);             return;          }          int j = pr.Sequence;          if (j < 1 || j > n) continue; //Bad metadata' ignore          if (parameters == null) continue;          Parameter par = parameters[j-1];          par.Attributes = this.GetCustomAttributesFor((i << 5)|4);          par.Flags = (ParameterFlags)pr.Flags;          if ((par.Flags & ParameterFlags.HasDefault) != 0)             par.DefaultValue = this.GetLiteral((i << 2)|1' par.Type);          if ((par.Flags & ParameterFlags.HasFieldMarshal) != 0)            par.MarshallingInformation = this.GetMarshallingInformation((i << 1)|1);          par.Name = tables.GetIdentifier(pr.Name);  #if ExtendedRuntime                  for (int k = 0' al = par.Attributes == null ? 0 : par.Attributes.Count; k < al; k++) {            if (par.Attributes[k].Type == ExtendedRuntimeTypes.NotNullAttribute) {              Reference r = par.Type as Reference;              if (r != null){                // need to make it a reference to a non-null type and not a non-null wrapper around the reference                // also *must* make it a new Reference.                OptionalModifier om = OptionalModifier.For(ExtendedRuntimeTypes.NonNullType' r.ElementType);                par.Type = om.GetReferenceType();              }else{                par.Type = OptionalModifier.For(ExtendedRuntimeTypes.NonNullType' par.Type);              }              // Someone putting an attribute directly on the "real" method is still a              // kind of out-of-band contract.              // This marking is the way to signal that any override or implementing method being compiled              // should not have its non-null annotations persisted as optional modifiers.              par.DeclaringMethod.HasOutOfBandContract = true;            } else if (par.Attributes[k].Type == ExtendedRuntimeTypes.NotNullArrayElementsAttribute) {              Stack s = new Stack();              Reference r = par.Type as Reference;              TypeNode t;              if (r != null) {                // need to make it a reference to an array of non-null type and not a non-null wrapper around the reference                t = r.ElementType;              }              else {                t = par.Type;              }              while (t is OptionalModifier) {                OptionalModifier om = t as OptionalModifier;                s.Push(om.Modifier);                t = om.ModifiedType;              }              ArrayType at = t as ArrayType;              if (at != null) { // just silently ignore if attribute is on a non-array type?                TypeNode newTypeForParameter;                OptionalModifier om = OptionalModifier.For(ExtendedRuntimeTypes.NonNullType' at.ElementType);                while (0 < s.Count) {                  om = OptionalModifier.For((TypeNode)s.Pop()' om);                }                // also *must* make it a new array type' can't set the ElementType.                newTypeForParameter = om.GetArrayType(1);                if (r != null) {                  // also *must* make it a new Reference' can't set the ElementType.                  newTypeForParameter = newTypeForParameter.GetReferenceType();                }                par.Type = newTypeForParameter;                // Someone putting an attribute directly on the "real" method is still a                // kind of out-of-band contract.                // This marking is the way to signal that any override or implementing method being compiled                // should not have its non-null annotations persisted as optional modifiers.                par.DeclaringMethod.HasOutOfBandContract = true;              }            }          }  #endif        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,AddMoreStuffToParameters,The following statement contains a magic number: for (int i = start; i < end; i++){          ParamRow pr = pars[i-1];          if (pr.Sequence == 0 && method != null){            //The parameter entry with sequence 0 is used as a target for custom attributes that apply to the return value            method.ReturnAttributes = this.GetCustomAttributesFor((i << 5)|4);            if ((pr.Flags & (int)ParameterFlags.HasFieldMarshal) != 0)              method.ReturnTypeMarshallingInformation = this.GetMarshallingInformation((i << 1)|1);            this.AddMoreStuffToParameters(null' parameters' start+1' end);             return;          }          int j = pr.Sequence;          if (j < 1 || j > n) continue; //Bad metadata' ignore          if (parameters == null) continue;          Parameter par = parameters[j-1];          par.Attributes = this.GetCustomAttributesFor((i << 5)|4);          par.Flags = (ParameterFlags)pr.Flags;          if ((par.Flags & ParameterFlags.HasDefault) != 0)             par.DefaultValue = this.GetLiteral((i << 2)|1' par.Type);          if ((par.Flags & ParameterFlags.HasFieldMarshal) != 0)            par.MarshallingInformation = this.GetMarshallingInformation((i << 1)|1);          par.Name = tables.GetIdentifier(pr.Name);  #if ExtendedRuntime                  for (int k = 0' al = par.Attributes == null ? 0 : par.Attributes.Count; k < al; k++) {            if (par.Attributes[k].Type == ExtendedRuntimeTypes.NotNullAttribute) {              Reference r = par.Type as Reference;              if (r != null){                // need to make it a reference to a non-null type and not a non-null wrapper around the reference                // also *must* make it a new Reference.                OptionalModifier om = OptionalModifier.For(ExtendedRuntimeTypes.NonNullType' r.ElementType);                par.Type = om.GetReferenceType();              }else{                par.Type = OptionalModifier.For(ExtendedRuntimeTypes.NonNullType' par.Type);              }              // Someone putting an attribute directly on the "real" method is still a              // kind of out-of-band contract.              // This marking is the way to signal that any override or implementing method being compiled              // should not have its non-null annotations persisted as optional modifiers.              par.DeclaringMethod.HasOutOfBandContract = true;            } else if (par.Attributes[k].Type == ExtendedRuntimeTypes.NotNullArrayElementsAttribute) {              Stack s = new Stack();              Reference r = par.Type as Reference;              TypeNode t;              if (r != null) {                // need to make it a reference to an array of non-null type and not a non-null wrapper around the reference                t = r.ElementType;              }              else {                t = par.Type;              }              while (t is OptionalModifier) {                OptionalModifier om = t as OptionalModifier;                s.Push(om.Modifier);                t = om.ModifiedType;              }              ArrayType at = t as ArrayType;              if (at != null) { // just silently ignore if attribute is on a non-array type?                TypeNode newTypeForParameter;                OptionalModifier om = OptionalModifier.For(ExtendedRuntimeTypes.NonNullType' at.ElementType);                while (0 < s.Count) {                  om = OptionalModifier.For((TypeNode)s.Pop()' om);                }                // also *must* make it a new array type' can't set the ElementType.                newTypeForParameter = om.GetArrayType(1);                if (r != null) {                  // also *must* make it a new Reference' can't set the ElementType.                  newTypeForParameter = newTypeForParameter.GetReferenceType();                }                par.Type = newTypeForParameter;                // Someone putting an attribute directly on the "real" method is still a                // kind of out-of-band contract.                // This marking is the way to signal that any override or implementing method being compiled                // should not have its non-null annotations persisted as optional modifiers.                par.DeclaringMethod.HasOutOfBandContract = true;              }            }          }  #endif        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,AddMoreStuffToParameters,The following statement contains a magic number: for (int i = start; i < end; i++){          ParamRow pr = pars[i-1];          if (pr.Sequence == 0 && method != null){            //The parameter entry with sequence 0 is used as a target for custom attributes that apply to the return value            method.ReturnAttributes = this.GetCustomAttributesFor((i << 5)|4);            if ((pr.Flags & (int)ParameterFlags.HasFieldMarshal) != 0)              method.ReturnTypeMarshallingInformation = this.GetMarshallingInformation((i << 1)|1);            this.AddMoreStuffToParameters(null' parameters' start+1' end);             return;          }          int j = pr.Sequence;          if (j < 1 || j > n) continue; //Bad metadata' ignore          if (parameters == null) continue;          Parameter par = parameters[j-1];          par.Attributes = this.GetCustomAttributesFor((i << 5)|4);          par.Flags = (ParameterFlags)pr.Flags;          if ((par.Flags & ParameterFlags.HasDefault) != 0)             par.DefaultValue = this.GetLiteral((i << 2)|1' par.Type);          if ((par.Flags & ParameterFlags.HasFieldMarshal) != 0)            par.MarshallingInformation = this.GetMarshallingInformation((i << 1)|1);          par.Name = tables.GetIdentifier(pr.Name);  #if ExtendedRuntime                  for (int k = 0' al = par.Attributes == null ? 0 : par.Attributes.Count; k < al; k++) {            if (par.Attributes[k].Type == ExtendedRuntimeTypes.NotNullAttribute) {              Reference r = par.Type as Reference;              if (r != null){                // need to make it a reference to a non-null type and not a non-null wrapper around the reference                // also *must* make it a new Reference.                OptionalModifier om = OptionalModifier.For(ExtendedRuntimeTypes.NonNullType' r.ElementType);                par.Type = om.GetReferenceType();              }else{                par.Type = OptionalModifier.For(ExtendedRuntimeTypes.NonNullType' par.Type);              }              // Someone putting an attribute directly on the "real" method is still a              // kind of out-of-band contract.              // This marking is the way to signal that any override or implementing method being compiled              // should not have its non-null annotations persisted as optional modifiers.              par.DeclaringMethod.HasOutOfBandContract = true;            } else if (par.Attributes[k].Type == ExtendedRuntimeTypes.NotNullArrayElementsAttribute) {              Stack s = new Stack();              Reference r = par.Type as Reference;              TypeNode t;              if (r != null) {                // need to make it a reference to an array of non-null type and not a non-null wrapper around the reference                t = r.ElementType;              }              else {                t = par.Type;              }              while (t is OptionalModifier) {                OptionalModifier om = t as OptionalModifier;                s.Push(om.Modifier);                t = om.ModifiedType;              }              ArrayType at = t as ArrayType;              if (at != null) { // just silently ignore if attribute is on a non-array type?                TypeNode newTypeForParameter;                OptionalModifier om = OptionalModifier.For(ExtendedRuntimeTypes.NonNullType' at.ElementType);                while (0 < s.Count) {                  om = OptionalModifier.For((TypeNode)s.Pop()' om);                }                // also *must* make it a new array type' can't set the ElementType.                newTypeForParameter = om.GetArrayType(1);                if (r != null) {                  // also *must* make it a new Reference' can't set the ElementType.                  newTypeForParameter = newTypeForParameter.GetReferenceType();                }                par.Type = newTypeForParameter;                // Someone putting an attribute directly on the "real" method is still a                // kind of out-of-band contract.                // This marking is the way to signal that any override or implementing method being compiled                // should not have its non-null annotations persisted as optional modifiers.                par.DeclaringMethod.HasOutOfBandContract = true;              }            }          }  #endif        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,AddMoreStuffToParameters,The following statement contains a magic number: for (int i = start; i < end; i++){          ParamRow pr = pars[i-1];          if (pr.Sequence == 0 && method != null){            //The parameter entry with sequence 0 is used as a target for custom attributes that apply to the return value            method.ReturnAttributes = this.GetCustomAttributesFor((i << 5)|4);            if ((pr.Flags & (int)ParameterFlags.HasFieldMarshal) != 0)              method.ReturnTypeMarshallingInformation = this.GetMarshallingInformation((i << 1)|1);            this.AddMoreStuffToParameters(null' parameters' start+1' end);             return;          }          int j = pr.Sequence;          if (j < 1 || j > n) continue; //Bad metadata' ignore          if (parameters == null) continue;          Parameter par = parameters[j-1];          par.Attributes = this.GetCustomAttributesFor((i << 5)|4);          par.Flags = (ParameterFlags)pr.Flags;          if ((par.Flags & ParameterFlags.HasDefault) != 0)             par.DefaultValue = this.GetLiteral((i << 2)|1' par.Type);          if ((par.Flags & ParameterFlags.HasFieldMarshal) != 0)            par.MarshallingInformation = this.GetMarshallingInformation((i << 1)|1);          par.Name = tables.GetIdentifier(pr.Name);  #if ExtendedRuntime                  for (int k = 0' al = par.Attributes == null ? 0 : par.Attributes.Count; k < al; k++) {            if (par.Attributes[k].Type == ExtendedRuntimeTypes.NotNullAttribute) {              Reference r = par.Type as Reference;              if (r != null){                // need to make it a reference to a non-null type and not a non-null wrapper around the reference                // also *must* make it a new Reference.                OptionalModifier om = OptionalModifier.For(ExtendedRuntimeTypes.NonNullType' r.ElementType);                par.Type = om.GetReferenceType();              }else{                par.Type = OptionalModifier.For(ExtendedRuntimeTypes.NonNullType' par.Type);              }              // Someone putting an attribute directly on the "real" method is still a              // kind of out-of-band contract.              // This marking is the way to signal that any override or implementing method being compiled              // should not have its non-null annotations persisted as optional modifiers.              par.DeclaringMethod.HasOutOfBandContract = true;            } else if (par.Attributes[k].Type == ExtendedRuntimeTypes.NotNullArrayElementsAttribute) {              Stack s = new Stack();              Reference r = par.Type as Reference;              TypeNode t;              if (r != null) {                // need to make it a reference to an array of non-null type and not a non-null wrapper around the reference                t = r.ElementType;              }              else {                t = par.Type;              }              while (t is OptionalModifier) {                OptionalModifier om = t as OptionalModifier;                s.Push(om.Modifier);                t = om.ModifiedType;              }              ArrayType at = t as ArrayType;              if (at != null) { // just silently ignore if attribute is on a non-array type?                TypeNode newTypeForParameter;                OptionalModifier om = OptionalModifier.For(ExtendedRuntimeTypes.NonNullType' at.ElementType);                while (0 < s.Count) {                  om = OptionalModifier.For((TypeNode)s.Pop()' om);                }                // also *must* make it a new array type' can't set the ElementType.                newTypeForParameter = om.GetArrayType(1);                if (r != null) {                  // also *must* make it a new Reference' can't set the ElementType.                  newTypeForParameter = newTypeForParameter.GetReferenceType();                }                par.Type = newTypeForParameter;                // Someone putting an attribute directly on the "real" method is still a                // kind of out-of-band contract.                // This marking is the way to signal that any override or implementing method being compiled                // should not have its non-null annotations persisted as optional modifiers.                par.DeclaringMethod.HasOutOfBandContract = true;              }            }          }  #endif        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,AddMoreStuffToParameters,The following statement contains a magic number: for (int i = start; i < end; i++){          ParamRow pr = pars[i-1];          if (pr.Sequence == 0 && method != null){            //The parameter entry with sequence 0 is used as a target for custom attributes that apply to the return value            method.ReturnAttributes = this.GetCustomAttributesFor((i << 5)|4);            if ((pr.Flags & (int)ParameterFlags.HasFieldMarshal) != 0)              method.ReturnTypeMarshallingInformation = this.GetMarshallingInformation((i << 1)|1);            this.AddMoreStuffToParameters(null' parameters' start+1' end);             return;          }          int j = pr.Sequence;          if (j < 1 || j > n) continue; //Bad metadata' ignore          if (parameters == null) continue;          Parameter par = parameters[j-1];          par.Attributes = this.GetCustomAttributesFor((i << 5)|4);          par.Flags = (ParameterFlags)pr.Flags;          if ((par.Flags & ParameterFlags.HasDefault) != 0)             par.DefaultValue = this.GetLiteral((i << 2)|1' par.Type);          if ((par.Flags & ParameterFlags.HasFieldMarshal) != 0)            par.MarshallingInformation = this.GetMarshallingInformation((i << 1)|1);          par.Name = tables.GetIdentifier(pr.Name);  #if ExtendedRuntime                  for (int k = 0' al = par.Attributes == null ? 0 : par.Attributes.Count; k < al; k++) {            if (par.Attributes[k].Type == ExtendedRuntimeTypes.NotNullAttribute) {              Reference r = par.Type as Reference;              if (r != null){                // need to make it a reference to a non-null type and not a non-null wrapper around the reference                // also *must* make it a new Reference.                OptionalModifier om = OptionalModifier.For(ExtendedRuntimeTypes.NonNullType' r.ElementType);                par.Type = om.GetReferenceType();              }else{                par.Type = OptionalModifier.For(ExtendedRuntimeTypes.NonNullType' par.Type);              }              // Someone putting an attribute directly on the "real" method is still a              // kind of out-of-band contract.              // This marking is the way to signal that any override or implementing method being compiled              // should not have its non-null annotations persisted as optional modifiers.              par.DeclaringMethod.HasOutOfBandContract = true;            } else if (par.Attributes[k].Type == ExtendedRuntimeTypes.NotNullArrayElementsAttribute) {              Stack s = new Stack();              Reference r = par.Type as Reference;              TypeNode t;              if (r != null) {                // need to make it a reference to an array of non-null type and not a non-null wrapper around the reference                t = r.ElementType;              }              else {                t = par.Type;              }              while (t is OptionalModifier) {                OptionalModifier om = t as OptionalModifier;                s.Push(om.Modifier);                t = om.ModifiedType;              }              ArrayType at = t as ArrayType;              if (at != null) { // just silently ignore if attribute is on a non-array type?                TypeNode newTypeForParameter;                OptionalModifier om = OptionalModifier.For(ExtendedRuntimeTypes.NonNullType' at.ElementType);                while (0 < s.Count) {                  om = OptionalModifier.For((TypeNode)s.Pop()' om);                }                // also *must* make it a new array type' can't set the ElementType.                newTypeForParameter = om.GetArrayType(1);                if (r != null) {                  // also *must* make it a new Reference' can't set the ElementType.                  newTypeForParameter = newTypeForParameter.GetReferenceType();                }                par.Type = newTypeForParameter;                // Someone putting an attribute directly on the "real" method is still a                // kind of out-of-band contract.                // This marking is the way to signal that any override or implementing method being compiled                // should not have its non-null annotations persisted as optional modifiers.                par.DeclaringMethod.HasOutOfBandContract = true;              }            }          }  #endif        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,AddPropertiesToType,The following statement contains a magic number: for (int i = start; i < end; i++){          int ii = i;          if (propertyPtrs.Length > 0) ii = propertyPtrs[i-1].Property;          PropertyRow prop = propertyDefs[ii-1];          Property property = new Property();          property.Attributes = this.GetCustomAttributesFor((ii << 5)|9);          property.DeclaringType = type;          property.Flags = (PropertyFlags)prop.Flags;          property.Name = tables.GetIdentifier(prop.Name);          if ((property.Flags & PropertyFlags.RTSpecialName) == 0 || property.Name.UniqueIdKey != StandardIds._Deleted.UniqueIdKey){            this.AddMethodsToProperty(ii' property);            type.members.Add(property);          }          //REVIEW: the signature seems to be redundant. Is there any point in retrieving it?        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,AddPropertiesToType,The following statement contains a magic number: for (int i = start; i < end; i++){          int ii = i;          if (propertyPtrs.Length > 0) ii = propertyPtrs[i-1].Property;          PropertyRow prop = propertyDefs[ii-1];          Property property = new Property();          property.Attributes = this.GetCustomAttributesFor((ii << 5)|9);          property.DeclaringType = type;          property.Flags = (PropertyFlags)prop.Flags;          property.Name = tables.GetIdentifier(prop.Name);          if ((property.Flags & PropertyFlags.RTSpecialName) == 0 || property.Name.UniqueIdKey != StandardIds._Deleted.UniqueIdKey){            this.AddMethodsToProperty(ii' property);            type.members.Add(property);          }          //REVIEW: the signature seems to be redundant. Is there any point in retrieving it?        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,AddMethodsToProperty,The following statement contains a magic number: bool sorted = (this.sortedTablesMask >> (int)TableIndices.MethodSemantics) % 2 == 1;
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,AddMethodsToProperty,The following statement contains a magic number: if (sorted){          while (i < j){            int k = (i+j) / 2;            if (methodSemantics[k].Association < codedPropIndex)              i = k+1;            else              j = k;          }          while (i > 0 && methodSemantics[i-1].Association == codedPropIndex) i--;        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,AddEventsToType,The following statement contains a magic number: for (int i = start; i < end; i++){          int ii = i;          if (eventPtrs.Length > 0) ii = eventPtrs[i].Event;          EventRow ev = eventDefs[ii-1];          Event evnt = new Event();          evnt.Attributes = this.GetCustomAttributesFor((ii << 5)|10);          evnt.DeclaringType = type;          evnt.Flags = (EventFlags)ev.Flags;          evnt.HandlerType = this.DecodeAndGetTypeDefOrRefOrSpec(ev.EventType);          evnt.Name = tables.GetIdentifier(ev.Name);          if ((evnt.Flags & EventFlags.RTSpecialName) == 0 || evnt.Name.UniqueIdKey != StandardIds._Deleted.UniqueIdKey){            this.AddMethodsToEvent(ii' evnt);            type.Members.Add(evnt);          }        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,AddEventsToType,The following statement contains a magic number: for (int i = start; i < end; i++){          int ii = i;          if (eventPtrs.Length > 0) ii = eventPtrs[i].Event;          EventRow ev = eventDefs[ii-1];          Event evnt = new Event();          evnt.Attributes = this.GetCustomAttributesFor((ii << 5)|10);          evnt.DeclaringType = type;          evnt.Flags = (EventFlags)ev.Flags;          evnt.HandlerType = this.DecodeAndGetTypeDefOrRefOrSpec(ev.EventType);          evnt.Name = tables.GetIdentifier(ev.Name);          if ((evnt.Flags & EventFlags.RTSpecialName) == 0 || evnt.Name.UniqueIdKey != StandardIds._Deleted.UniqueIdKey){            this.AddMethodsToEvent(ii' evnt);            type.Members.Add(evnt);          }        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,AddMethodsToEvent,The following statement contains a magic number: bool sorted = (this.sortedTablesMask >> (int)TableIndices.MethodSemantics) % 2 == 1;
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,AddMethodsToEvent,The following statement contains a magic number: if (sorted){          while (i < j){            int k = (i+j) / 2;            if (methodSemantics[k].Association < codedEventIndex)              i = k+1;            else              j = k;          }          while (i > 0 && methodSemantics[i-1].Association == codedEventIndex) i--;        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,TypeDefOrRefOrSpecIsClass,The following statement contains a magic number: switch(codedIndex & 0x3){          case 0x00 : return this.TypeDefIsClass(codedIndex >> 2);          case 0x01 : TypeNode t = this.GetTypeFromRef(codedIndex >> 2); return t is Class;          case 0x02 : return this.TypeSpecIsClass(codedIndex >> 2);        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,TypeDefOrRefOrSpecIsClass,The following statement contains a magic number: switch(codedIndex & 0x3){          case 0x00 : return this.TypeDefIsClass(codedIndex >> 2);          case 0x01 : TypeNode t = this.GetTypeFromRef(codedIndex >> 2); return t is Class;          case 0x02 : return this.TypeSpecIsClass(codedIndex >> 2);        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,TypeDefOrRefOrSpecIsClass,The following statement contains a magic number: switch(codedIndex & 0x3){          case 0x00 : return this.TypeDefIsClass(codedIndex >> 2);          case 0x01 : TypeNode t = this.GetTypeFromRef(codedIndex >> 2); return t is Class;          case 0x02 : return this.TypeSpecIsClass(codedIndex >> 2);        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,TypeDefOrRefOrSpecIsClassButNotValueTypeBaseClass,The following statement contains a magic number: switch (codedIndex & 0x3) {          case 0x00: return this.TypeDefIsClassButNotValueTypeBaseClass(codedIndex >> 2);          case 0x01:             TypeNode t = this.GetTypeFromRef(codedIndex >> 2);             return t != CoreSystemTypes.ValueType && t != CoreSystemTypes.Enum && t is Class;          case 0x02: return this.TypeSpecIsClass(codedIndex >> 2);        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,TypeDefOrRefOrSpecIsClassButNotValueTypeBaseClass,The following statement contains a magic number: switch (codedIndex & 0x3) {          case 0x00: return this.TypeDefIsClassButNotValueTypeBaseClass(codedIndex >> 2);          case 0x01:             TypeNode t = this.GetTypeFromRef(codedIndex >> 2);             return t != CoreSystemTypes.ValueType && t != CoreSystemTypes.Enum && t is Class;          case 0x02: return this.TypeSpecIsClass(codedIndex >> 2);        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,TypeDefOrRefOrSpecIsClassButNotValueTypeBaseClass,The following statement contains a magic number: switch (codedIndex & 0x3) {          case 0x00: return this.TypeDefIsClassButNotValueTypeBaseClass(codedIndex >> 2);          case 0x01:             TypeNode t = this.GetTypeFromRef(codedIndex >> 2);             return t != CoreSystemTypes.ValueType && t != CoreSystemTypes.Enum && t is Class;          case 0x02: return this.TypeSpecIsClass(codedIndex >> 2);        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,DecodeAndGetTypeDefOrRefOrSpec,The following statement contains a magic number: switch(codedIndex & 0x3){          case 0x00 : return this.GetTypeFromDef(codedIndex >> 2);          case 0x01 : return this.GetTypeFromRef(codedIndex >> 2);          case 0x02 : return this.GetTypeFromSpec(codedIndex >> 2);        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,DecodeAndGetTypeDefOrRefOrSpec,The following statement contains a magic number: switch(codedIndex & 0x3){          case 0x00 : return this.GetTypeFromDef(codedIndex >> 2);          case 0x01 : return this.GetTypeFromRef(codedIndex >> 2);          case 0x02 : return this.GetTypeFromSpec(codedIndex >> 2);        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,DecodeAndGetTypeDefOrRefOrSpec,The following statement contains a magic number: switch(codedIndex & 0x3){          case 0x00 : return this.GetTypeFromDef(codedIndex >> 2);          case 0x01 : return this.GetTypeFromRef(codedIndex >> 2);          case 0x02 : return this.GetTypeFromSpec(codedIndex >> 2);        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,DecodeAndGetTypeDefOrRefOrSpec,The following statement contains a magic number: switch(codedIndex & 0x3){          case 0x00 : return this.GetTypeFromDef(codedIndex >> 2);          case 0x01 : return this.GetTypeFromRef(codedIndex >> 2' expectStruct);          case 0x02 : return this.GetTypeFromSpec(codedIndex >> 2);        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,DecodeAndGetTypeDefOrRefOrSpec,The following statement contains a magic number: switch(codedIndex & 0x3){          case 0x00 : return this.GetTypeFromDef(codedIndex >> 2);          case 0x01 : return this.GetTypeFromRef(codedIndex >> 2' expectStruct);          case 0x02 : return this.GetTypeFromSpec(codedIndex >> 2);        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,DecodeAndGetTypeDefOrRefOrSpec,The following statement contains a magic number: switch(codedIndex & 0x3){          case 0x00 : return this.GetTypeFromDef(codedIndex >> 2);          case 0x01 : return this.GetTypeFromRef(codedIndex >> 2' expectStruct);          case 0x02 : return this.GetTypeFromSpec(codedIndex >> 2);        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetTypeIfNotGenericInstance,The following statement contains a magic number: switch(codedIndex & 0x3){          case 0x00 : return this.GetTypeFromDef(codedIndex >> 2);          case 0x01 : return this.GetTypeFromRef(codedIndex >> 2' false);        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetTypeIfNotGenericInstance,The following statement contains a magic number: switch(codedIndex & 0x3){          case 0x00 : return this.GetTypeFromDef(codedIndex >> 2);          case 0x01 : return this.GetTypeFromRef(codedIndex >> 2' false);        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetConstructorDefOrRef,The following statement contains a magic number: switch(codedIndex & 0x7){          case 0x02 : return this.GetMethodFromDef(codedIndex >> 3);           case 0x03 : return (Method)this.GetMemberFromRef(codedIndex >> 3' out varArgTypes);        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetConstructorDefOrRef,The following statement contains a magic number: switch(codedIndex & 0x7){          case 0x02 : return this.GetMethodFromDef(codedIndex >> 3);           case 0x03 : return (Method)this.GetMemberFromRef(codedIndex >> 3' out varArgTypes);        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetResources,The following statement contains a magic number: for (int i = 0; i < n; i++){          ManifestResourceRow mrr = manifestResourceTable[i];          Resource r = new Resource();          r.Name = this.tables.GetString(mrr.Name);          r.IsPublic = (mrr.Flags&7) == 1;          int impl = mrr.Implementation;          if (impl != 0){            switch(impl & 0x3){              case 0x0:                 string modName = this.tables.GetString(this.tables.FileTable[(impl >> 2)-1].Name);                if ((this.tables.FileTable[(impl >> 2)-1].Flags & (int)FileFlags.ContainsNoMetaData) != 0){                  r.DefiningModule = new Module();                  r.DefiningModule.Directory = module.Directory;                  r.DefiningModule.Location = Path.Combine(module.Directory'modName);                  r.DefiningModule.Name = modName;                  r.DefiningModule.Kind = ModuleKindFlags.ManifestResourceFile;                  r.DefiningModule.ContainingAssembly = module.ContainingAssembly;                  r.DefiningModule.HashValue = this.tables.GetBlob(this.tables.FileTable[(impl >> 2) - 1].HashValue);                } else {                  string modLocation = modName;                  r.DefiningModule = GetNestedModule(module' modName' ref modLocation);                }                break;              case 0x1:                 r.DefiningModule = this.tables.AssemblyRefTable[(impl >> 2)-1].AssemblyReference.Assembly;                break;            }          }else{            r.DefiningModule = module;            r.Data = this.tables.GetResourceData(mrr.Offset);          }          resources.Add(r);        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetResources,The following statement contains a magic number: for (int i = 0; i < n; i++){          ManifestResourceRow mrr = manifestResourceTable[i];          Resource r = new Resource();          r.Name = this.tables.GetString(mrr.Name);          r.IsPublic = (mrr.Flags&7) == 1;          int impl = mrr.Implementation;          if (impl != 0){            switch(impl & 0x3){              case 0x0:                 string modName = this.tables.GetString(this.tables.FileTable[(impl >> 2)-1].Name);                if ((this.tables.FileTable[(impl >> 2)-1].Flags & (int)FileFlags.ContainsNoMetaData) != 0){                  r.DefiningModule = new Module();                  r.DefiningModule.Directory = module.Directory;                  r.DefiningModule.Location = Path.Combine(module.Directory'modName);                  r.DefiningModule.Name = modName;                  r.DefiningModule.Kind = ModuleKindFlags.ManifestResourceFile;                  r.DefiningModule.ContainingAssembly = module.ContainingAssembly;                  r.DefiningModule.HashValue = this.tables.GetBlob(this.tables.FileTable[(impl >> 2) - 1].HashValue);                } else {                  string modLocation = modName;                  r.DefiningModule = GetNestedModule(module' modName' ref modLocation);                }                break;              case 0x1:                 r.DefiningModule = this.tables.AssemblyRefTable[(impl >> 2)-1].AssemblyReference.Assembly;                break;            }          }else{            r.DefiningModule = module;            r.Data = this.tables.GetResourceData(mrr.Offset);          }          resources.Add(r);        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetResources,The following statement contains a magic number: for (int i = 0; i < n; i++){          ManifestResourceRow mrr = manifestResourceTable[i];          Resource r = new Resource();          r.Name = this.tables.GetString(mrr.Name);          r.IsPublic = (mrr.Flags&7) == 1;          int impl = mrr.Implementation;          if (impl != 0){            switch(impl & 0x3){              case 0x0:                 string modName = this.tables.GetString(this.tables.FileTable[(impl >> 2)-1].Name);                if ((this.tables.FileTable[(impl >> 2)-1].Flags & (int)FileFlags.ContainsNoMetaData) != 0){                  r.DefiningModule = new Module();                  r.DefiningModule.Directory = module.Directory;                  r.DefiningModule.Location = Path.Combine(module.Directory'modName);                  r.DefiningModule.Name = modName;                  r.DefiningModule.Kind = ModuleKindFlags.ManifestResourceFile;                  r.DefiningModule.ContainingAssembly = module.ContainingAssembly;                  r.DefiningModule.HashValue = this.tables.GetBlob(this.tables.FileTable[(impl >> 2) - 1].HashValue);                } else {                  string modLocation = modName;                  r.DefiningModule = GetNestedModule(module' modName' ref modLocation);                }                break;              case 0x1:                 r.DefiningModule = this.tables.AssemblyRefTable[(impl >> 2)-1].AssemblyReference.Assembly;                break;            }          }else{            r.DefiningModule = module;            r.Data = this.tables.GetResourceData(mrr.Offset);          }          resources.Add(r);        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetResources,The following statement contains a magic number: for (int i = 0; i < n; i++){          ManifestResourceRow mrr = manifestResourceTable[i];          Resource r = new Resource();          r.Name = this.tables.GetString(mrr.Name);          r.IsPublic = (mrr.Flags&7) == 1;          int impl = mrr.Implementation;          if (impl != 0){            switch(impl & 0x3){              case 0x0:                 string modName = this.tables.GetString(this.tables.FileTable[(impl >> 2)-1].Name);                if ((this.tables.FileTable[(impl >> 2)-1].Flags & (int)FileFlags.ContainsNoMetaData) != 0){                  r.DefiningModule = new Module();                  r.DefiningModule.Directory = module.Directory;                  r.DefiningModule.Location = Path.Combine(module.Directory'modName);                  r.DefiningModule.Name = modName;                  r.DefiningModule.Kind = ModuleKindFlags.ManifestResourceFile;                  r.DefiningModule.ContainingAssembly = module.ContainingAssembly;                  r.DefiningModule.HashValue = this.tables.GetBlob(this.tables.FileTable[(impl >> 2) - 1].HashValue);                } else {                  string modLocation = modName;                  r.DefiningModule = GetNestedModule(module' modName' ref modLocation);                }                break;              case 0x1:                 r.DefiningModule = this.tables.AssemblyRefTable[(impl >> 2)-1].AssemblyReference.Assembly;                break;            }          }else{            r.DefiningModule = module;            r.Data = this.tables.GetResourceData(mrr.Offset);          }          resources.Add(r);        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetResources,The following statement contains a magic number: for (int i = 0; i < n; i++){          ManifestResourceRow mrr = manifestResourceTable[i];          Resource r = new Resource();          r.Name = this.tables.GetString(mrr.Name);          r.IsPublic = (mrr.Flags&7) == 1;          int impl = mrr.Implementation;          if (impl != 0){            switch(impl & 0x3){              case 0x0:                 string modName = this.tables.GetString(this.tables.FileTable[(impl >> 2)-1].Name);                if ((this.tables.FileTable[(impl >> 2)-1].Flags & (int)FileFlags.ContainsNoMetaData) != 0){                  r.DefiningModule = new Module();                  r.DefiningModule.Directory = module.Directory;                  r.DefiningModule.Location = Path.Combine(module.Directory'modName);                  r.DefiningModule.Name = modName;                  r.DefiningModule.Kind = ModuleKindFlags.ManifestResourceFile;                  r.DefiningModule.ContainingAssembly = module.ContainingAssembly;                  r.DefiningModule.HashValue = this.tables.GetBlob(this.tables.FileTable[(impl >> 2) - 1].HashValue);                } else {                  string modLocation = modName;                  r.DefiningModule = GetNestedModule(module' modName' ref modLocation);                }                break;              case 0x1:                 r.DefiningModule = this.tables.AssemblyRefTable[(impl >> 2)-1].AssemblyReference.Assembly;                break;            }          }else{            r.DefiningModule = module;            r.Data = this.tables.GetResourceData(mrr.Offset);          }          resources.Add(r);        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseArrayOrGenericType,The following statement contains a magic number: if (typeName[0] == ']'){ //Single dimensional array with zero lower bound          if (typeName.Length == 1) return rootType.GetArrayType(1);          if (typeName[1] == '[' && typeName.Length > 2)            return this.ParseArrayOrGenericType(typeName.Substring(2)' rootType.GetArrayType(1));          throw new InvalidMetadataException(ExceptionStrings.BadSerializedTypeName);        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseArrayOrGenericType,The following statement contains a magic number: if (typeName[0] == ']'){ //Single dimensional array with zero lower bound          if (typeName.Length == 1) return rootType.GetArrayType(1);          if (typeName[1] == '[' && typeName.Length > 2)            return this.ParseArrayOrGenericType(typeName.Substring(2)' rootType.GetArrayType(1));          throw new InvalidMetadataException(ExceptionStrings.BadSerializedTypeName);        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseArrayOrGenericType,The following statement contains a magic number: if (typeName[0] == '*'){ //Single dimensional array with unknown lower bound          if (typeName.Length > 1 && typeName[1] == ']'){            if (typeName.Length == 2) return rootType.GetArrayType(1' true);            if (typeName[2] == '[' && typeName.Length > 3)              return this.ParseArrayOrGenericType(typeName.Substring(3)' rootType.GetArrayType(1' true));          }          throw new InvalidMetadataException(ExceptionStrings.BadSerializedTypeName);        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseArrayOrGenericType,The following statement contains a magic number: if (typeName[0] == '*'){ //Single dimensional array with unknown lower bound          if (typeName.Length > 1 && typeName[1] == ']'){            if (typeName.Length == 2) return rootType.GetArrayType(1' true);            if (typeName[2] == '[' && typeName.Length > 3)              return this.ParseArrayOrGenericType(typeName.Substring(3)' rootType.GetArrayType(1' true));          }          throw new InvalidMetadataException(ExceptionStrings.BadSerializedTypeName);        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseArrayOrGenericType,The following statement contains a magic number: if (typeName[0] == '*'){ //Single dimensional array with unknown lower bound          if (typeName.Length > 1 && typeName[1] == ']'){            if (typeName.Length == 2) return rootType.GetArrayType(1' true);            if (typeName[2] == '[' && typeName.Length > 3)              return this.ParseArrayOrGenericType(typeName.Substring(3)' rootType.GetArrayType(1' true));          }          throw new InvalidMetadataException(ExceptionStrings.BadSerializedTypeName);        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseArrayOrGenericType,The following statement contains a magic number: if (typeName[0] == '*'){ //Single dimensional array with unknown lower bound          if (typeName.Length > 1 && typeName[1] == ']'){            if (typeName.Length == 2) return rootType.GetArrayType(1' true);            if (typeName[2] == '[' && typeName.Length > 3)              return this.ParseArrayOrGenericType(typeName.Substring(3)' rootType.GetArrayType(1' true));          }          throw new InvalidMetadataException(ExceptionStrings.BadSerializedTypeName);        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseArrayOrGenericType,The following statement contains a magic number: if (typeName[0] == '''){ //Muti dimensional array          int rank = 1;          while (rank < typeName.Length && typeName[rank] == ''') rank++;          if (rank < typeName.Length && typeName[rank] == ']') {            if (typeName.Length == rank+1) return rootType.GetArrayType(rank+1);            if (typeName[rank+1] == '[' && typeName.Length > rank+2)              return this.ParseArrayOrGenericType(typeName.Substring(rank+2)' rootType.GetArrayType(rank));          }          throw new InvalidMetadataException(ExceptionStrings.BadSerializedTypeName);        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseArrayOrGenericType,The following statement contains a magic number: if (typeName[0] == '''){ //Muti dimensional array          int rank = 1;          while (rank < typeName.Length && typeName[rank] == ''') rank++;          if (rank < typeName.Length && typeName[rank] == ']') {            if (typeName.Length == rank+1) return rootType.GetArrayType(rank+1);            if (typeName[rank+1] == '[' && typeName.Length > rank+2)              return this.ParseArrayOrGenericType(typeName.Substring(rank+2)' rootType.GetArrayType(rank));          }          throw new InvalidMetadataException(ExceptionStrings.BadSerializedTypeName);        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseArrayOrGenericType,The following statement contains a magic number: if (lastCharPos+1 < typeName.Length) {          //The generic type is complete' but there is yet more to the type          char ch = typeName[lastCharPos+1];          if (ch == '+') retVal = this.GetTypeFromSerializedName(typeName.Substring(lastCharPos+2)' retVal);          if (ch == '&') retVal = retVal.GetReferenceType();          if (ch == '*') retVal = retVal.GetPointerType();          if (ch == '[') retVal = this.ParseArrayOrGenericType(typeName.Substring(lastCharPos+2' typeName.Length-1-lastCharPos-1)' retVal);        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseArrayOrGenericType,The following statement contains a magic number: if (lastCharPos+1 < typeName.Length) {          //The generic type is complete' but there is yet more to the type          char ch = typeName[lastCharPos+1];          if (ch == '+') retVal = this.GetTypeFromSerializedName(typeName.Substring(lastCharPos+2)' retVal);          if (ch == '&') retVal = retVal.GetReferenceType();          if (ch == '*') retVal = retVal.GetPointerType();          if (ch == '[') retVal = this.ParseArrayOrGenericType(typeName.Substring(lastCharPos+2' typeName.Length-1-lastCharPos-1)' retVal);        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetCustomAttributesFor,The following statement contains a magic number: try{          if (this.tables.entryPointToken != 0)            module.EntryPoint = (Method)this.GetMemberFromToken(this.tables.entryPointToken);          else            module.EntryPoint = Module.NoSuchMethod;          if (module.NodeType == NodeType.Module) {            module.Attributes = this.GetCustomAttributesFor((1 << 5) | 7);            return;          }          AssemblyNode assembly = (AssemblyNode)module;          assembly.SecurityAttributes = this.GetSecurityAttributesFor((1 << 2)|2);          assembly.Attributes = this.GetCustomAttributesFor((1 << 5) | 14);          assembly.ModuleAttributes = this.GetCustomAttributesFor((1 << 5) | 7);  #if !FxCop        }catch(Exception e){          if (this.module == null) return;          if (this.module.MetadataImportErrors == null) this.module.MetadataImportErrors = new ArrayList();          this.module.MetadataImportErrors.Add(e);          module.Attributes = new AttributeList(0);        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetCustomAttributesFor,The following statement contains a magic number: try{          if (this.tables.entryPointToken != 0)            module.EntryPoint = (Method)this.GetMemberFromToken(this.tables.entryPointToken);          else            module.EntryPoint = Module.NoSuchMethod;          if (module.NodeType == NodeType.Module) {            module.Attributes = this.GetCustomAttributesFor((1 << 5) | 7);            return;          }          AssemblyNode assembly = (AssemblyNode)module;          assembly.SecurityAttributes = this.GetSecurityAttributesFor((1 << 2)|2);          assembly.Attributes = this.GetCustomAttributesFor((1 << 5) | 14);          assembly.ModuleAttributes = this.GetCustomAttributesFor((1 << 5) | 7);  #if !FxCop        }catch(Exception e){          if (this.module == null) return;          if (this.module.MetadataImportErrors == null) this.module.MetadataImportErrors = new ArrayList();          this.module.MetadataImportErrors.Add(e);          module.Attributes = new AttributeList(0);        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetCustomAttributesFor,The following statement contains a magic number: try{          if (this.tables.entryPointToken != 0)            module.EntryPoint = (Method)this.GetMemberFromToken(this.tables.entryPointToken);          else            module.EntryPoint = Module.NoSuchMethod;          if (module.NodeType == NodeType.Module) {            module.Attributes = this.GetCustomAttributesFor((1 << 5) | 7);            return;          }          AssemblyNode assembly = (AssemblyNode)module;          assembly.SecurityAttributes = this.GetSecurityAttributesFor((1 << 2)|2);          assembly.Attributes = this.GetCustomAttributesFor((1 << 5) | 14);          assembly.ModuleAttributes = this.GetCustomAttributesFor((1 << 5) | 7);  #if !FxCop        }catch(Exception e){          if (this.module == null) return;          if (this.module.MetadataImportErrors == null) this.module.MetadataImportErrors = new ArrayList();          this.module.MetadataImportErrors.Add(e);          module.Attributes = new AttributeList(0);        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetCustomAttributesFor,The following statement contains a magic number: try{          if (this.tables.entryPointToken != 0)            module.EntryPoint = (Method)this.GetMemberFromToken(this.tables.entryPointToken);          else            module.EntryPoint = Module.NoSuchMethod;          if (module.NodeType == NodeType.Module) {            module.Attributes = this.GetCustomAttributesFor((1 << 5) | 7);            return;          }          AssemblyNode assembly = (AssemblyNode)module;          assembly.SecurityAttributes = this.GetSecurityAttributesFor((1 << 2)|2);          assembly.Attributes = this.GetCustomAttributesFor((1 << 5) | 14);          assembly.ModuleAttributes = this.GetCustomAttributesFor((1 << 5) | 7);  #if !FxCop        }catch(Exception e){          if (this.module == null) return;          if (this.module.MetadataImportErrors == null) this.module.MetadataImportErrors = new ArrayList();          this.module.MetadataImportErrors.Add(e);          module.Attributes = new AttributeList(0);        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetCustomAttributesFor,The following statement contains a magic number: try{          if (this.tables.entryPointToken != 0)            module.EntryPoint = (Method)this.GetMemberFromToken(this.tables.entryPointToken);          else            module.EntryPoint = Module.NoSuchMethod;          if (module.NodeType == NodeType.Module) {            module.Attributes = this.GetCustomAttributesFor((1 << 5) | 7);            return;          }          AssemblyNode assembly = (AssemblyNode)module;          assembly.SecurityAttributes = this.GetSecurityAttributesFor((1 << 2)|2);          assembly.Attributes = this.GetCustomAttributesFor((1 << 5) | 14);          assembly.ModuleAttributes = this.GetCustomAttributesFor((1 << 5) | 7);  #if !FxCop        }catch(Exception e){          if (this.module == null) return;          if (this.module.MetadataImportErrors == null) this.module.MetadataImportErrors = new ArrayList();          this.module.MetadataImportErrors.Add(e);          module.Attributes = new AttributeList(0);        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetCustomAttributesFor,The following statement contains a magic number: try{          if (this.tables.entryPointToken != 0)            module.EntryPoint = (Method)this.GetMemberFromToken(this.tables.entryPointToken);          else            module.EntryPoint = Module.NoSuchMethod;          if (module.NodeType == NodeType.Module) {            module.Attributes = this.GetCustomAttributesFor((1 << 5) | 7);            return;          }          AssemblyNode assembly = (AssemblyNode)module;          assembly.SecurityAttributes = this.GetSecurityAttributesFor((1 << 2)|2);          assembly.Attributes = this.GetCustomAttributesFor((1 << 5) | 14);          assembly.ModuleAttributes = this.GetCustomAttributesFor((1 << 5) | 7);  #if !FxCop        }catch(Exception e){          if (this.module == null) return;          if (this.module.MetadataImportErrors == null) this.module.MetadataImportErrors = new ArrayList();          this.module.MetadataImportErrors.Add(e);          module.Attributes = new AttributeList(0);        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetCustomAttributesFor,The following statement contains a magic number: try{          if (this.tables.entryPointToken != 0)            module.EntryPoint = (Method)this.GetMemberFromToken(this.tables.entryPointToken);          else            module.EntryPoint = Module.NoSuchMethod;          if (module.NodeType == NodeType.Module) {            module.Attributes = this.GetCustomAttributesFor((1 << 5) | 7);            return;          }          AssemblyNode assembly = (AssemblyNode)module;          assembly.SecurityAttributes = this.GetSecurityAttributesFor((1 << 2)|2);          assembly.Attributes = this.GetCustomAttributesFor((1 << 5) | 14);          assembly.ModuleAttributes = this.GetCustomAttributesFor((1 << 5) | 7);  #if !FxCop        }catch(Exception e){          if (this.module == null) return;          if (this.module.MetadataImportErrors == null) this.module.MetadataImportErrors = new ArrayList();          this.module.MetadataImportErrors.Add(e);          module.Attributes = new AttributeList(0);        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetCustomAttributesFor,The following statement contains a magic number: try{          if (this.tables.entryPointToken != 0)            module.EntryPoint = (Method)this.GetMemberFromToken(this.tables.entryPointToken);          else            module.EntryPoint = Module.NoSuchMethod;          if (module.NodeType == NodeType.Module) {            module.Attributes = this.GetCustomAttributesFor((1 << 5) | 7);            return;          }          AssemblyNode assembly = (AssemblyNode)module;          assembly.SecurityAttributes = this.GetSecurityAttributesFor((1 << 2)|2);          assembly.Attributes = this.GetCustomAttributesFor((1 << 5) | 14);          assembly.ModuleAttributes = this.GetCustomAttributesFor((1 << 5) | 7);  #if !FxCop        }catch(Exception e){          if (this.module == null) return;          if (this.module.MetadataImportErrors == null) this.module.MetadataImportErrors = new ArrayList();          this.module.MetadataImportErrors.Add(e);          module.Attributes = new AttributeList(0);        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetCustomAttributesFor,The following statement contains a magic number: try{          int i = 0' n = customAttributes.Length' j = n-1;          if (n == 0) return attributes;          bool sorted = (this.sortedTablesMask >> (int)TableIndices.CustomAttribute) % 2 == 1;          if (sorted){            while (i < j){              int k = (i+j) / 2;              if (customAttributes[k].Parent < parentIndex)                i = k+1;              else                j = k;            }            while (i > 0 && customAttributes[i-1].Parent == parentIndex) i--;          }          for (; i < n; i++)            if (customAttributes[i].Parent == parentIndex)              attributes.Add(this.GetCustomAttribute(i));            else if (sorted)              break;  #if !FxCop        }catch(Exception e){          if (this.module == null) return attributes;          if (this.module.MetadataImportErrors == null) this.module.MetadataImportErrors = new ArrayList();          this.module.MetadataImportErrors.Add(e);        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetCustomAttributesFor,The following statement contains a magic number: try{          int i = 0' n = customAttributes.Length' j = n-1;          if (n == 0) return attributes;          bool sorted = (this.sortedTablesMask >> (int)TableIndices.CustomAttribute) % 2 == 1;          if (sorted){            while (i < j){              int k = (i+j) / 2;              if (customAttributes[k].Parent < parentIndex)                i = k+1;              else                j = k;            }            while (i > 0 && customAttributes[i-1].Parent == parentIndex) i--;          }          for (; i < n; i++)            if (customAttributes[i].Parent == parentIndex)              attributes.Add(this.GetCustomAttribute(i));            else if (sorted)              break;  #if !FxCop        }catch(Exception e){          if (this.module == null) return attributes;          if (this.module.MetadataImportErrors == null) this.module.MetadataImportErrors = new ArrayList();          this.module.MetadataImportErrors.Add(e);        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetSecurityAttributesFor,The following statement contains a magic number: try{          int i = 0' n = securityAttributes.Length' j = n-1;          if (n == 0) return attributes;          bool sorted = (this.sortedTablesMask >> (int)TableIndices.DeclSecurity) % 2 == 1;          if (sorted){            while (i < j){              int k = (i+j) / 2;              if (securityAttributes[k].Parent < parentIndex)                i = k+1;              else                j = k;            }            while (i > 0 && securityAttributes[i-1].Parent == parentIndex) i--;          }          for (; i < n; i++)            if (securityAttributes[i].Parent == parentIndex)              attributes.Add(this.GetSecurityAttribute(i));            else if (sorted)              break;  #if !FxCop        }catch(Exception e){          if (this.module == null) return attributes;          if (this.module.MetadataImportErrors == null) this.module.MetadataImportErrors = new ArrayList();          this.module.MetadataImportErrors.Add(e);        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetSecurityAttributesFor,The following statement contains a magic number: try{          int i = 0' n = securityAttributes.Length' j = n-1;          if (n == 0) return attributes;          bool sorted = (this.sortedTablesMask >> (int)TableIndices.DeclSecurity) % 2 == 1;          if (sorted){            while (i < j){              int k = (i+j) / 2;              if (securityAttributes[k].Parent < parentIndex)                i = k+1;              else                j = k;            }            while (i > 0 && securityAttributes[i-1].Parent == parentIndex) i--;          }          for (; i < n; i++)            if (securityAttributes[i].Parent == parentIndex)              attributes.Add(this.GetSecurityAttribute(i));            else if (sorted)              break;  #if !FxCop        }catch(Exception e){          if (this.module == null) return attributes;          if (this.module.MetadataImportErrors == null) this.module.MetadataImportErrors = new ArrayList();          this.module.MetadataImportErrors.Add(e);        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetTypeParameterConstraints,The following statement contains a magic number: bool sorted = (this.sortedTablesMask >> (int)TableIndices.GenericParam) % 2 == 1;
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetTypeParameterConstraints,The following statement contains a magic number: if (sorted){          while (i < j){            int k = (i+j) / 2;            if (genericParameters[k].Owner < parentIndex)              i = k+1;            else              j = k;          }          while (i > 0 && genericParameters[i-1].Owner == parentIndex) i--;        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetTypeParametersFor,The following statement contains a magic number: bool sorted = (this.sortedTablesMask >> (int)TableIndices.GenericParam) % 2 == 1;
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetTypeParametersFor,The following statement contains a magic number: if (sorted){          while (i < j){            int k = (i+j) / 2;            if (genericParameters[k].Owner < parentIndex)              i = k+1;            else              j = k;          }          while (i > 0 && genericParameters[i-1].Owner == parentIndex) i--;        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetGenericParameter,The following statement contains a magic number: bool sorted = (this.sortedTablesMask >> (int)TableIndices.GenericParamConstraint) % 2 == 1;
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetGenericParameter,The following statement contains a magic number: if (sorted){          while (i < j){            int k = (i+j) / 2;            if (genericParameterConstraints[k].Param < index)              i = k+1;            else              j = k;          }          while (i > 0 && genericParameterConstraints[i-1].Param == index) i--;        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetGenericParameterConstraints,The following statement contains a magic number: bool sorted = (this.sortedTablesMask >> (int)TableIndices.GenericParamConstraint) % 2 == 1;
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetGenericParameterConstraints,The following statement contains a magic number: if (sorted){          while (i < j){            int k = (i+j) / 2;            if (genericParameterConstraints[k].Param < index)              i = k+1;            else              j = k;          }          while (i > 0 && genericParameterConstraints[i-1].Param == index) i--;        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetFieldFromDef,The following statement contains a magic number: field.Attributes = this.GetCustomAttributesFor((i << 5)|1);
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetFieldFromDef,The following statement contains a magic number: GetAndCheckSignatureToken(6' sigReader);
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetFieldFromDef,The following statement contains a magic number: if ((field.Flags & FieldFlags.HasDefault) != 0)           field.DefaultValue = this.GetLiteral(i << 2' field.Type);
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetInitialData,The following statement contains a magic number: bool sorted = (this.sortedTablesMask >> (int)TableIndices.FieldRva) % 2 == 1;
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetInitialData,The following statement contains a magic number: if (sorted){          while (i < j){            int k = (i+j) / 2;            if (fieldRvaTable[k].Field < fieldIndex)              i = k+1;            else              j = k;          }        }else          for (; i < j; i++)            if (fieldRvaTable[i].Field == fieldIndex) break;
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetInitialData,The following statement contains a magic number: if (size <= 0){          switch (fieldType.typeCode){            case ElementType.Boolean: size = 1; break;            case ElementType.Char: size = 2; break;            case ElementType.Double: size = 8; break;            case ElementType.Int16: size = 2; break;            case ElementType.Int32: size = 4; break;            case ElementType.Int64: size = 8; break;            case ElementType.Int8: size = 1; break;            case ElementType.Single: size = 4; break;            case ElementType.UInt16: size = 2; break;            case ElementType.UInt32: size = 4; break;            case ElementType.UInt64: size = 8; break;            case ElementType.UInt8: size = 1; break;            default:              if (fieldType is Pointer || fieldType is FunctionPointer){                size = 4; break;              }              //TODO: this seems wrong              if (i < n-1)                size = fieldRvaTable[i+1].RVA - frr.RVA;              else if (targetSection != PESection.Text)                size = this.tables.GetOffsetToEndOfSection(frr.RVA);              break;          }        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetInitialData,The following statement contains a magic number: if (size <= 0){          switch (fieldType.typeCode){            case ElementType.Boolean: size = 1; break;            case ElementType.Char: size = 2; break;            case ElementType.Double: size = 8; break;            case ElementType.Int16: size = 2; break;            case ElementType.Int32: size = 4; break;            case ElementType.Int64: size = 8; break;            case ElementType.Int8: size = 1; break;            case ElementType.Single: size = 4; break;            case ElementType.UInt16: size = 2; break;            case ElementType.UInt32: size = 4; break;            case ElementType.UInt64: size = 8; break;            case ElementType.UInt8: size = 1; break;            default:              if (fieldType is Pointer || fieldType is FunctionPointer){                size = 4; break;              }              //TODO: this seems wrong              if (i < n-1)                size = fieldRvaTable[i+1].RVA - frr.RVA;              else if (targetSection != PESection.Text)                size = this.tables.GetOffsetToEndOfSection(frr.RVA);              break;          }        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetInitialData,The following statement contains a magic number: if (size <= 0){          switch (fieldType.typeCode){            case ElementType.Boolean: size = 1; break;            case ElementType.Char: size = 2; break;            case ElementType.Double: size = 8; break;            case ElementType.Int16: size = 2; break;            case ElementType.Int32: size = 4; break;            case ElementType.Int64: size = 8; break;            case ElementType.Int8: size = 1; break;            case ElementType.Single: size = 4; break;            case ElementType.UInt16: size = 2; break;            case ElementType.UInt32: size = 4; break;            case ElementType.UInt64: size = 8; break;            case ElementType.UInt8: size = 1; break;            default:              if (fieldType is Pointer || fieldType is FunctionPointer){                size = 4; break;              }              //TODO: this seems wrong              if (i < n-1)                size = fieldRvaTable[i+1].RVA - frr.RVA;              else if (targetSection != PESection.Text)                size = this.tables.GetOffsetToEndOfSection(frr.RVA);              break;          }        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetInitialData,The following statement contains a magic number: if (size <= 0){          switch (fieldType.typeCode){            case ElementType.Boolean: size = 1; break;            case ElementType.Char: size = 2; break;            case ElementType.Double: size = 8; break;            case ElementType.Int16: size = 2; break;            case ElementType.Int32: size = 4; break;            case ElementType.Int64: size = 8; break;            case ElementType.Int8: size = 1; break;            case ElementType.Single: size = 4; break;            case ElementType.UInt16: size = 2; break;            case ElementType.UInt32: size = 4; break;            case ElementType.UInt64: size = 8; break;            case ElementType.UInt8: size = 1; break;            default:              if (fieldType is Pointer || fieldType is FunctionPointer){                size = 4; break;              }              //TODO: this seems wrong              if (i < n-1)                size = fieldRvaTable[i+1].RVA - frr.RVA;              else if (targetSection != PESection.Text)                size = this.tables.GetOffsetToEndOfSection(frr.RVA);              break;          }        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetInitialData,The following statement contains a magic number: if (size <= 0){          switch (fieldType.typeCode){            case ElementType.Boolean: size = 1; break;            case ElementType.Char: size = 2; break;            case ElementType.Double: size = 8; break;            case ElementType.Int16: size = 2; break;            case ElementType.Int32: size = 4; break;            case ElementType.Int64: size = 8; break;            case ElementType.Int8: size = 1; break;            case ElementType.Single: size = 4; break;            case ElementType.UInt16: size = 2; break;            case ElementType.UInt32: size = 4; break;            case ElementType.UInt64: size = 8; break;            case ElementType.UInt8: size = 1; break;            default:              if (fieldType is Pointer || fieldType is FunctionPointer){                size = 4; break;              }              //TODO: this seems wrong              if (i < n-1)                size = fieldRvaTable[i+1].RVA - frr.RVA;              else if (targetSection != PESection.Text)                size = this.tables.GetOffsetToEndOfSection(frr.RVA);              break;          }        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetInitialData,The following statement contains a magic number: if (size <= 0){          switch (fieldType.typeCode){            case ElementType.Boolean: size = 1; break;            case ElementType.Char: size = 2; break;            case ElementType.Double: size = 8; break;            case ElementType.Int16: size = 2; break;            case ElementType.Int32: size = 4; break;            case ElementType.Int64: size = 8; break;            case ElementType.Int8: size = 1; break;            case ElementType.Single: size = 4; break;            case ElementType.UInt16: size = 2; break;            case ElementType.UInt32: size = 4; break;            case ElementType.UInt64: size = 8; break;            case ElementType.UInt8: size = 1; break;            default:              if (fieldType is Pointer || fieldType is FunctionPointer){                size = 4; break;              }              //TODO: this seems wrong              if (i < n-1)                size = fieldRvaTable[i+1].RVA - frr.RVA;              else if (targetSection != PESection.Text)                size = this.tables.GetOffsetToEndOfSection(frr.RVA);              break;          }        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetInitialData,The following statement contains a magic number: if (size <= 0){          switch (fieldType.typeCode){            case ElementType.Boolean: size = 1; break;            case ElementType.Char: size = 2; break;            case ElementType.Double: size = 8; break;            case ElementType.Int16: size = 2; break;            case ElementType.Int32: size = 4; break;            case ElementType.Int64: size = 8; break;            case ElementType.Int8: size = 1; break;            case ElementType.Single: size = 4; break;            case ElementType.UInt16: size = 2; break;            case ElementType.UInt32: size = 4; break;            case ElementType.UInt64: size = 8; break;            case ElementType.UInt8: size = 1; break;            default:              if (fieldType is Pointer || fieldType is FunctionPointer){                size = 4; break;              }              //TODO: this seems wrong              if (i < n-1)                size = fieldRvaTable[i+1].RVA - frr.RVA;              else if (targetSection != PESection.Text)                size = this.tables.GetOffsetToEndOfSection(frr.RVA);              break;          }        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetInitialData,The following statement contains a magic number: if (size <= 0){          switch (fieldType.typeCode){            case ElementType.Boolean: size = 1; break;            case ElementType.Char: size = 2; break;            case ElementType.Double: size = 8; break;            case ElementType.Int16: size = 2; break;            case ElementType.Int32: size = 4; break;            case ElementType.Int64: size = 8; break;            case ElementType.Int8: size = 1; break;            case ElementType.Single: size = 4; break;            case ElementType.UInt16: size = 2; break;            case ElementType.UInt32: size = 4; break;            case ElementType.UInt64: size = 8; break;            case ElementType.UInt8: size = 1; break;            default:              if (fieldType is Pointer || fieldType is FunctionPointer){                size = 4; break;              }              //TODO: this seems wrong              if (i < n-1)                size = fieldRvaTable[i+1].RVA - frr.RVA;              else if (targetSection != PESection.Text)                size = this.tables.GetOffsetToEndOfSection(frr.RVA);              break;          }        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetInitialData,The following statement contains a magic number: if (size <= 0){          switch (fieldType.typeCode){            case ElementType.Boolean: size = 1; break;            case ElementType.Char: size = 2; break;            case ElementType.Double: size = 8; break;            case ElementType.Int16: size = 2; break;            case ElementType.Int32: size = 4; break;            case ElementType.Int64: size = 8; break;            case ElementType.Int8: size = 1; break;            case ElementType.Single: size = 4; break;            case ElementType.UInt16: size = 2; break;            case ElementType.UInt32: size = 4; break;            case ElementType.UInt64: size = 8; break;            case ElementType.UInt8: size = 1; break;            default:              if (fieldType is Pointer || fieldType is FunctionPointer){                size = 4; break;              }              //TODO: this seems wrong              if (i < n-1)                size = fieldRvaTable[i+1].RVA - frr.RVA;              else if (targetSection != PESection.Text)                size = this.tables.GetOffsetToEndOfSection(frr.RVA);              break;          }        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetInitialData,The following statement contains a magic number: if (size <= 0){          switch (fieldType.typeCode){            case ElementType.Boolean: size = 1; break;            case ElementType.Char: size = 2; break;            case ElementType.Double: size = 8; break;            case ElementType.Int16: size = 2; break;            case ElementType.Int32: size = 4; break;            case ElementType.Int64: size = 8; break;            case ElementType.Int8: size = 1; break;            case ElementType.Single: size = 4; break;            case ElementType.UInt16: size = 2; break;            case ElementType.UInt32: size = 4; break;            case ElementType.UInt64: size = 8; break;            case ElementType.UInt8: size = 1; break;            default:              if (fieldType is Pointer || fieldType is FunctionPointer){                size = 4; break;              }              //TODO: this seems wrong              if (i < n-1)                size = fieldRvaTable[i+1].RVA - frr.RVA;              else if (targetSection != PESection.Text)                size = this.tables.GetOffsetToEndOfSection(frr.RVA);              break;          }        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetLocalSourceNames,The following statement contains a magic number: char[] nameBuffer = new char[100];
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetLocalSourceNames,The following statement contains a magic number: IntPtr[] subscopes = new IntPtr[100];
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetMarshallingInformation,The following statement contains a magic number: bool sorted = (this.sortedTablesMask >> (int)TableIndices.FieldMarshal) % 2 == 1;
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetMarshallingInformation,The following statement contains a magic number: if (sorted){          while (i < j){            int k = (i+j) / 2;            if (mtypes[k].Parent < parentCodedIndex)              i = k+1;            else              j = k;          }          while (i > 0 && mtypes[i-1].Parent == parentCodedIndex) i--;        }else          for (; i < j; i++)            if (mtypes[i].Parent == parentCodedIndex) break;
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetMarshallingInformation,The following statement contains a magic number: if (result.NativeType == NativeType.CustomMarshaler){          c.ReadUInt16(); //Skip over 0          result.Class = ReadSerString(c);          result.Cookie = ReadSerString(c);        }else if (blobSize > 1){          if (result.NativeType == NativeType.LPArray){            result.ElementType = (NativeType)c.ReadByte();            result.ParamIndex = -1;            int bytesRead = 2;            if (bytesRead < blobSize){              int pos = c.Position;              result.ParamIndex = c.ReadCompressedInt();              bytesRead += c.Position - pos;              if (bytesRead < blobSize){                pos = c.Position;                result.ElementSize = c.ReadCompressedInt();                bytesRead += c.Position - pos;                if (bytesRead < blobSize)                  result.NumberOfElements = c.ReadCompressedInt();              }            }          }else if (result.NativeType == NativeType.SafeArray){            result.ElementType = (NativeType)c.ReadByte(); //Actually a variant type. TODO: what about VT_VECTOR VT_ARRAY and VT_BYREF?            if (c.Position < initialPosition+blobSize-1)              result.Class = ReadSerString(c);          } else {            result.Size = c.ReadCompressedInt();            if (result.NativeType == NativeType.ByValArray) {              if (c.Position < initialPosition + blobSize)                 result.ElementType = (NativeType)c.ReadByte();              else                result.ElementType = NativeType.NotSpecified;            }          }        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetMethodFromDef,The following statement contains a magic number: if (declaringType == null){          int indx = index;          MethodPtrRow[] methodPtrs = this.tables.MethodPtrTable;          int n = methodPtrs.Length' i = 0' j = n-1;          bool sorted = (this.sortedTablesMask >> (int)TableIndices.MethodPtr) % 2 == 1;          if (sorted){            while (i < j){              int k = (i+j) / 2;              if (methodPtrs[k].Method < index)                i = k+1;              else                j = k;            }            while (i > 0 && methodPtrs[i-1].Method == index) i--;          }          for (; i < n; i++){            if (methodPtrs[i].Method == index){              indx = i+1; break;            }          }          TypeDefRow[] typeDefs = this.tables.TypeDefTable;          n = typeDefs.Length; i=0; j=n-1;          sorted = (this.sortedTablesMask >> (int)TableIndices.TypeDef) % 2 == 1;          if (sorted){            while (i < j){              int k = (i+j) / 2;              if (typeDefs[k].MethodList < indx)                i = k+1;              else                j = k;            }            j = i;            while (j < n-1 && typeDefs[j+1].MethodList == indx) j++;          }          for (; j >= 0; j--){            if (typeDefs[j].MethodList <= indx){              declaringType = this.GetTypeFromDef(j+1);              break;            }          }        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetMethodFromDef,The following statement contains a magic number: if (declaringType == null){          int indx = index;          MethodPtrRow[] methodPtrs = this.tables.MethodPtrTable;          int n = methodPtrs.Length' i = 0' j = n-1;          bool sorted = (this.sortedTablesMask >> (int)TableIndices.MethodPtr) % 2 == 1;          if (sorted){            while (i < j){              int k = (i+j) / 2;              if (methodPtrs[k].Method < index)                i = k+1;              else                j = k;            }            while (i > 0 && methodPtrs[i-1].Method == index) i--;          }          for (; i < n; i++){            if (methodPtrs[i].Method == index){              indx = i+1; break;            }          }          TypeDefRow[] typeDefs = this.tables.TypeDefTable;          n = typeDefs.Length; i=0; j=n-1;          sorted = (this.sortedTablesMask >> (int)TableIndices.TypeDef) % 2 == 1;          if (sorted){            while (i < j){              int k = (i+j) / 2;              if (typeDefs[k].MethodList < indx)                i = k+1;              else                j = k;            }            j = i;            while (j < n-1 && typeDefs[j+1].MethodList == indx) j++;          }          for (; j >= 0; j--){            if (typeDefs[j].MethodList <= indx){              declaringType = this.GetTypeFromDef(j+1);              break;            }          }        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetMethodFromDef,The following statement contains a magic number: if (declaringType == null){          int indx = index;          MethodPtrRow[] methodPtrs = this.tables.MethodPtrTable;          int n = methodPtrs.Length' i = 0' j = n-1;          bool sorted = (this.sortedTablesMask >> (int)TableIndices.MethodPtr) % 2 == 1;          if (sorted){            while (i < j){              int k = (i+j) / 2;              if (methodPtrs[k].Method < index)                i = k+1;              else                j = k;            }            while (i > 0 && methodPtrs[i-1].Method == index) i--;          }          for (; i < n; i++){            if (methodPtrs[i].Method == index){              indx = i+1; break;            }          }          TypeDefRow[] typeDefs = this.tables.TypeDefTable;          n = typeDefs.Length; i=0; j=n-1;          sorted = (this.sortedTablesMask >> (int)TableIndices.TypeDef) % 2 == 1;          if (sorted){            while (i < j){              int k = (i+j) / 2;              if (typeDefs[k].MethodList < indx)                i = k+1;              else                j = k;            }            j = i;            while (j < n-1 && typeDefs[j+1].MethodList == indx) j++;          }          for (; j >= 0; j--){            if (typeDefs[j].MethodList <= indx){              declaringType = this.GetTypeFromDef(j+1);              break;            }          }        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetMethodFromDef,The following statement contains a magic number: if (declaringType == null){          int indx = index;          MethodPtrRow[] methodPtrs = this.tables.MethodPtrTable;          int n = methodPtrs.Length' i = 0' j = n-1;          bool sorted = (this.sortedTablesMask >> (int)TableIndices.MethodPtr) % 2 == 1;          if (sorted){            while (i < j){              int k = (i+j) / 2;              if (methodPtrs[k].Method < index)                i = k+1;              else                j = k;            }            while (i > 0 && methodPtrs[i-1].Method == index) i--;          }          for (; i < n; i++){            if (methodPtrs[i].Method == index){              indx = i+1; break;            }          }          TypeDefRow[] typeDefs = this.tables.TypeDefTable;          n = typeDefs.Length; i=0; j=n-1;          sorted = (this.sortedTablesMask >> (int)TableIndices.TypeDef) % 2 == 1;          if (sorted){            while (i < j){              int k = (i+j) / 2;              if (typeDefs[k].MethodList < indx)                i = k+1;              else                j = k;            }            j = i;            while (j < n-1 && typeDefs[j+1].MethodList == indx) j++;          }          for (; j >= 0; j--){            if (typeDefs[j].MethodList <= indx){              declaringType = this.GetTypeFromDef(j+1);              break;            }          }        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetMethodFromDef,The following statement contains a magic number: if ((method.Flags & MethodFlags.PInvokeImpl) != 0){          ImplMapRow[] implMaps = this.tables.ImplMapTable;          int n = implMaps.Length' i = 0' j = n-1;          bool sorted = (this.sortedTablesMask >> (int)TableIndices.ImplMap) % 2 == 1;          if (sorted){            while (i < j){              int k = (i+j) / 2;              if ((implMaps[k].MemberForwarded >> 1) < index)                i = k+1;              else                j = k;            }            while (i > 0 && (implMaps[i-1].MemberForwarded>>1) == index) i--;          }          for (; i < n; i++){                      ImplMapRow imr = implMaps[i];            if (imr.MemberForwarded >> 1 == index){              method.PInvokeFlags = (PInvokeFlags)imr.MappingFlags;              method.PInvokeImportName = tables.GetString(imr.ImportName);              method.PInvokeModule = this.module.ModuleReferences[imr.ImportScope-1].Module;              break;            }          }        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetMethodFromDef,The following statement contains a magic number: if ((method.Flags & MethodFlags.PInvokeImpl) != 0){          ImplMapRow[] implMaps = this.tables.ImplMapTable;          int n = implMaps.Length' i = 0' j = n-1;          bool sorted = (this.sortedTablesMask >> (int)TableIndices.ImplMap) % 2 == 1;          if (sorted){            while (i < j){              int k = (i+j) / 2;              if ((implMaps[k].MemberForwarded >> 1) < index)                i = k+1;              else                j = k;            }            while (i > 0 && (implMaps[i-1].MemberForwarded>>1) == index) i--;          }          for (; i < n; i++){                      ImplMapRow imr = implMaps[i];            if (imr.MemberForwarded >> 1 == index){              method.PInvokeFlags = (PInvokeFlags)imr.MappingFlags;              method.PInvokeImportName = tables.GetString(imr.ImportName);              method.PInvokeModule = this.module.ModuleReferences[imr.ImportScope-1].Module;              break;            }          }        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetMethodAttributes,The following statement contains a magic number: try {          MetadataReader tables = this.tables;          int index = (int)handle;          MethodRow[] methodDefs = tables.MethodTable;          int n = methodDefs.Length;          if (index < 1 || index > n)            throw new System.ArgumentOutOfRangeException("handle"' ExceptionStrings.InvalidTypeTableIndex);          MethodRow md = methodDefs[index-1];          if (method != md.Method) throw new System.ArgumentOutOfRangeException("handle"' ExceptionStrings.InvalidTypeTableIndex);          //Get custom attributes             method.Attributes = this.GetCustomAttributesFor((index << 5)|0);          this.currentTypeParameters = savedCurrentTypeParameters;          this.currentMethodTypeParameters = savedCurrentMethodTypeParameters;          //Get security attributes          if ((method.Flags & MethodFlags.HasSecurity) != 0)            method.SecurityAttributes = this.GetSecurityAttributesFor((index << 2)|1);  #if !FxCop        } catch (Exception e) {          if (this.module != null) {            if (this.module.MetadataImportErrors == null) this.module.MetadataImportErrors = new ArrayList();            this.module.MetadataImportErrors.Add(e);          }          method.Attributes = new AttributeList(0);          this.currentTypeParameters = savedCurrentTypeParameters;          this.currentMethodTypeParameters = savedCurrentMethodTypeParameters;        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetMethodAttributes,The following statement contains a magic number: try {          MetadataReader tables = this.tables;          int index = (int)handle;          MethodRow[] methodDefs = tables.MethodTable;          int n = methodDefs.Length;          if (index < 1 || index > n)            throw new System.ArgumentOutOfRangeException("handle"' ExceptionStrings.InvalidTypeTableIndex);          MethodRow md = methodDefs[index-1];          if (method != md.Method) throw new System.ArgumentOutOfRangeException("handle"' ExceptionStrings.InvalidTypeTableIndex);          //Get custom attributes             method.Attributes = this.GetCustomAttributesFor((index << 5)|0);          this.currentTypeParameters = savedCurrentTypeParameters;          this.currentMethodTypeParameters = savedCurrentMethodTypeParameters;          //Get security attributes          if ((method.Flags & MethodFlags.HasSecurity) != 0)            method.SecurityAttributes = this.GetSecurityAttributesFor((index << 2)|1);  #if !FxCop        } catch (Exception e) {          if (this.module != null) {            if (this.module.MetadataImportErrors == null) this.module.MetadataImportErrors = new ArrayList();            this.module.MetadataImportErrors.Add(e);          }          method.Attributes = new AttributeList(0);          this.currentTypeParameters = savedCurrentTypeParameters;          this.currentMethodTypeParameters = savedCurrentMethodTypeParameters;        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetMemberFromToken,The following statement contains a magic number: switch ((TableIndices)(tok >> 24)){          case TableIndices.Field : member = this.GetFieldFromDef(tok & 0xFFFFFF); break;          case TableIndices.Method : member = this.GetMethodFromDef(tok & 0xFFFFFF); break;          case TableIndices.MemberRef : member = this.GetMemberFromRef(tok & 0xFFFFFF' out varArgTypes); break;          case TableIndices.TypeDef : member = this.GetTypeFromDef(tok & 0xFFFFFF); break;          case TableIndices.TypeRef : member = this.GetTypeFromRef(tok & 0xFFFFFF); break;          case TableIndices.TypeSpec : member = this.GetTypeFromSpec(tok & 0xFFFFFF); break;          case TableIndices.MethodSpec : member = this.GetMethodFromSpec(tok & 0xFFFFFF); break;          default: throw new InvalidMetadataException(ExceptionStrings.BadMemberToken);        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetMemberFromRef,The following statement contains a magic number: switch(codedIndex & 0x7){          case 0x00 : parent = this.GetTypeFromDef(codedIndex >> 3); break;          case 0x01 : parent = this.GetTypeFromRef(codedIndex >> 3); break;          case 0x02 : parent = this.GetTypeGlobalMemberContainerTypeFromModule(codedIndex >> 3); break;          case 0x03 : result = this.GetMethodFromDef(codedIndex >> 3);             if ((((Method)result).CallingConvention & CallingConventionFlags.VarArg) != 0){              MemoryCursor sRdr = this.tables.GetBlobCursor(mref.Signature);              sRdr.ReadByte(); //hdr              int pCount = sRdr.ReadCompressedInt();              this.ParseTypeSignature(sRdr); //rType              bool genParameterEncountered = false;              this.ParseParameterTypes(out varArgTypes' sRdr' pCount' ref genParameterEncountered);            }            goto done;          case 0x04 : parent = this.GetTypeFromSpec(codedIndex >> 3); break;          default: throw new InvalidMetadataException("");        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetMemberFromRef,The following statement contains a magic number: switch(codedIndex & 0x7){          case 0x00 : parent = this.GetTypeFromDef(codedIndex >> 3); break;          case 0x01 : parent = this.GetTypeFromRef(codedIndex >> 3); break;          case 0x02 : parent = this.GetTypeGlobalMemberContainerTypeFromModule(codedIndex >> 3); break;          case 0x03 : result = this.GetMethodFromDef(codedIndex >> 3);             if ((((Method)result).CallingConvention & CallingConventionFlags.VarArg) != 0){              MemoryCursor sRdr = this.tables.GetBlobCursor(mref.Signature);              sRdr.ReadByte(); //hdr              int pCount = sRdr.ReadCompressedInt();              this.ParseTypeSignature(sRdr); //rType              bool genParameterEncountered = false;              this.ParseParameterTypes(out varArgTypes' sRdr' pCount' ref genParameterEncountered);            }            goto done;          case 0x04 : parent = this.GetTypeFromSpec(codedIndex >> 3); break;          default: throw new InvalidMetadataException("");        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetMemberFromRef,The following statement contains a magic number: switch(codedIndex & 0x7){          case 0x00 : parent = this.GetTypeFromDef(codedIndex >> 3); break;          case 0x01 : parent = this.GetTypeFromRef(codedIndex >> 3); break;          case 0x02 : parent = this.GetTypeGlobalMemberContainerTypeFromModule(codedIndex >> 3); break;          case 0x03 : result = this.GetMethodFromDef(codedIndex >> 3);             if ((((Method)result).CallingConvention & CallingConventionFlags.VarArg) != 0){              MemoryCursor sRdr = this.tables.GetBlobCursor(mref.Signature);              sRdr.ReadByte(); //hdr              int pCount = sRdr.ReadCompressedInt();              this.ParseTypeSignature(sRdr); //rType              bool genParameterEncountered = false;              this.ParseParameterTypes(out varArgTypes' sRdr' pCount' ref genParameterEncountered);            }            goto done;          case 0x04 : parent = this.GetTypeFromSpec(codedIndex >> 3); break;          default: throw new InvalidMetadataException("");        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetMemberFromRef,The following statement contains a magic number: switch(codedIndex & 0x7){          case 0x00 : parent = this.GetTypeFromDef(codedIndex >> 3); break;          case 0x01 : parent = this.GetTypeFromRef(codedIndex >> 3); break;          case 0x02 : parent = this.GetTypeGlobalMemberContainerTypeFromModule(codedIndex >> 3); break;          case 0x03 : result = this.GetMethodFromDef(codedIndex >> 3);             if ((((Method)result).CallingConvention & CallingConventionFlags.VarArg) != 0){              MemoryCursor sRdr = this.tables.GetBlobCursor(mref.Signature);              sRdr.ReadByte(); //hdr              int pCount = sRdr.ReadCompressedInt();              this.ParseTypeSignature(sRdr); //rType              bool genParameterEncountered = false;              this.ParseParameterTypes(out varArgTypes' sRdr' pCount' ref genParameterEncountered);            }            goto done;          case 0x04 : parent = this.GetTypeFromSpec(codedIndex >> 3); break;          default: throw new InvalidMetadataException("");        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetMemberFromRef,The following statement contains a magic number: switch(codedIndex & 0x7){          case 0x00 : parent = this.GetTypeFromDef(codedIndex >> 3); break;          case 0x01 : parent = this.GetTypeFromRef(codedIndex >> 3); break;          case 0x02 : parent = this.GetTypeGlobalMemberContainerTypeFromModule(codedIndex >> 3); break;          case 0x03 : result = this.GetMethodFromDef(codedIndex >> 3);             if ((((Method)result).CallingConvention & CallingConventionFlags.VarArg) != 0){              MemoryCursor sRdr = this.tables.GetBlobCursor(mref.Signature);              sRdr.ReadByte(); //hdr              int pCount = sRdr.ReadCompressedInt();              this.ParseTypeSignature(sRdr); //rType              bool genParameterEncountered = false;              this.ParseParameterTypes(out varArgTypes' sRdr' pCount' ref genParameterEncountered);            }            goto done;          case 0x04 : parent = this.GetTypeFromSpec(codedIndex >> 3); break;          default: throw new InvalidMetadataException("");        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetMemberFromRef,The following statement contains a magic number: switch (header & 7){          case 1: callingConvention |= CallingConventionFlags.C; break;          case 2: callingConvention |= CallingConventionFlags.StandardCall; break;          case 3: callingConvention |= CallingConventionFlags.ThisCall; break;          case 4: callingConvention |= CallingConventionFlags.FastCall; break;          case 5: callingConvention |= CallingConventionFlags.VarArg; break;        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetMemberFromRef,The following statement contains a magic number: switch (header & 7){          case 1: callingConvention |= CallingConventionFlags.C; break;          case 2: callingConvention |= CallingConventionFlags.StandardCall; break;          case 3: callingConvention |= CallingConventionFlags.ThisCall; break;          case 4: callingConvention |= CallingConventionFlags.FastCall; break;          case 5: callingConvention |= CallingConventionFlags.VarArg; break;        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetMemberFromRef,The following statement contains a magic number: switch (header & 7){          case 1: callingConvention |= CallingConventionFlags.C; break;          case 2: callingConvention |= CallingConventionFlags.StandardCall; break;          case 3: callingConvention |= CallingConventionFlags.ThisCall; break;          case 4: callingConvention |= CallingConventionFlags.FastCall; break;          case 5: callingConvention |= CallingConventionFlags.VarArg; break;        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetMemberFromRef,The following statement contains a magic number: switch (header & 7){          case 1: callingConvention |= CallingConventionFlags.C; break;          case 2: callingConvention |= CallingConventionFlags.StandardCall; break;          case 3: callingConvention |= CallingConventionFlags.ThisCall; break;          case 4: callingConvention |= CallingConventionFlags.FastCall; break;          case 5: callingConvention |= CallingConventionFlags.VarArg; break;        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetMemberFromRef,The following statement contains a magic number: switch (header & 7){          case 1: callingConvention |= CallingConventionFlags.C; break;          case 2: callingConvention |= CallingConventionFlags.StandardCall; break;          case 3: callingConvention |= CallingConventionFlags.ThisCall; break;          case 4: callingConvention |= CallingConventionFlags.FastCall; break;          case 5: callingConvention |= CallingConventionFlags.VarArg; break;        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetNamespaces,The following statement contains a magic number: TrivialHashtable nsT = this.namespaceTable = new TrivialHashtable(n*2);
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetForwardedTypeFromName,The following statement contains a magic number: for (int i = 0' n = exportedTypes == null ? 0 : exportedTypes.Length; i < n; i++) {          ExportedTypeRow etr = exportedTypes[i];          if ((etr.Flags & (int)TypeFlags.Forwarder) == 0) continue;          if (this.tables.GetString(etr.TypeNamespace) != Namespace.Name ||              this.tables.GetString(etr.TypeName) != name.Name) continue;          int index = etr.Implementation >> 2;          AssemblyRefRow arr = this.tables.AssemblyRefTable[index - 1];          return arr.AssemblyReference.Assembly.GetType(Namespace' name);        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetTypeFromRef,The following statement contains a magic number: int index = resolutionScope >> 2;
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetTypeFromRef,The following statement contains a magic number: switch (resolutionScope & 0x3){          case 0:            declaringModule = this.module;            //^ assume declaringModule != null;            result = declaringModule.GetType(namesp' name);            //REVIEW: deal with case where ref is in same (multi-module) assembly' but not the current module? index == 0            break;          case 1:             declaringModule = this.tables.ModuleRefTable[index-1].Module;            if (declaringModule != null)              result = declaringModule.GetType(namesp' name);            break;           case 2:            declaringModule = this.tables.AssemblyRefTable[index-1].AssemblyReference.Assembly;            if (declaringModule != null)              result = declaringModule.GetType(namesp' name);            break;          case 3:             declaringType = this.GetTypeFromRef(index);            declaringModule = declaringType.DeclaringModule;            if (namesp == null || namesp.length == 0)              result = (TypeNode)declaringType.GetMembersNamed(name)[0];            else              result = (TypeNode)declaringType.GetMembersNamed(Identifier.For(namesp.Name+"."+name.Name))[0];            break;          default:             declaringModule = this.module;            break;        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetTypeFromRef,The following statement contains a magic number: switch (resolutionScope & 0x3){          case 0:            declaringModule = this.module;            //^ assume declaringModule != null;            result = declaringModule.GetType(namesp' name);            //REVIEW: deal with case where ref is in same (multi-module) assembly' but not the current module? index == 0            break;          case 1:             declaringModule = this.tables.ModuleRefTable[index-1].Module;            if (declaringModule != null)              result = declaringModule.GetType(namesp' name);            break;           case 2:            declaringModule = this.tables.AssemblyRefTable[index-1].AssemblyReference.Assembly;            if (declaringModule != null)              result = declaringModule.GetType(namesp' name);            break;          case 3:             declaringType = this.GetTypeFromRef(index);            declaringModule = declaringType.DeclaringModule;            if (namesp == null || namesp.length == 0)              result = (TypeNode)declaringType.GetMembersNamed(name)[0];            else              result = (TypeNode)declaringType.GetMembersNamed(Identifier.For(namesp.Name+"."+name.Name))[0];            break;          default:             declaringModule = this.module;            break;        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetTypeFromSpec,The following statement contains a magic number: AttributeList attributes = this.GetCustomAttributesFor((i << 5) | 13);
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetTypeFromSpec,The following statement contains a magic number: AttributeList attributes = this.GetCustomAttributesFor((i << 5) | 13);
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetTypeList,The following statement contains a magic number: for (int i = 0' n = exportedTypes.Length; i < n; i++){          ExportedTypeRow etr = exportedTypes[i];          Identifier nameSpace = Identifier.For(this.tables.GetString(etr.TypeNamespace));          Identifier typeName = Identifier.For(this.tables.GetString(etr.TypeName));          TypeNode exportedType = null;          switch (etr.Implementation & 0x3){            case 0:              string modName = this.tables.GetString(this.tables.FileTable[(etr.Implementation >> 2)-1].Name);              string modLocation = modName;              Module mod = GetNestedModule(assem' modName' ref modLocation);              if (mod == null){Debug.Assert(false); break;}              exportedType = mod.GetType(nameSpace' typeName);              if (exportedType == null){                HandleError(assem' String.Format(CultureInfo.CurrentCulture'                  ExceptionStrings.CouldNotFindExportedTypeInModule' nameSpace+"."+typeName' modLocation));                exportedType = new Class();                exportedType.Name = typeName;                exportedType.Namespace = nameSpace;                exportedType.Flags = TypeFlags.Class|TypeFlags.Public;                exportedType.DeclaringModule = mod;              }              break;            case 1:              AssemblyReference aref = this.tables.AssemblyRefTable[(etr.Implementation >> 2)-1].AssemblyReference;              if (aref == null){                HandleError(assem' ExceptionStrings.BadMetadataInExportTypeTableNoSuchAssemblyReference);                aref = new AssemblyReference("dummy assembly for bad reference");              }              AssemblyNode a = aref.Assembly;              if (a == null){Debug.Assert(false); continue;}              exportedType = a.GetType(nameSpace' typeName);              if (exportedType == null){                HandleError(assem' String.Format(CultureInfo.CurrentCulture'                   ExceptionStrings.CouldNotFindExportedTypeInAssembly' nameSpace+"."+typeName' a.StrongName));                exportedType = new Class();                exportedType.Name = typeName;                exportedType.Namespace = nameSpace;                exportedType.Flags = TypeFlags.Class|TypeFlags.Public;                exportedType.DeclaringModule = a;              }              break;            case 2:              TypeNode parentType = types[(etr.Implementation >> 2)-1];              if (parentType == null){                HandleError(assem' ExceptionStrings.BadMetadataInExportTypeTableNoSuchParentType);                parentType = new Class();                parentType.DeclaringModule = this.module;                parentType.Name = Identifier.For("Missing parent type");              }              exportedType = parentType.GetNestedType(typeName);              if (exportedType == null){                HandleError(assem' String.Format(CultureInfo.CurrentCulture'                  ExceptionStrings.CouldNotFindExportedNestedTypeInType' typeName' parentType.FullName));                exportedType = new Class();                exportedType.Name = typeName;                exportedType.Flags = TypeFlags.Class|TypeFlags.NestedPublic;                exportedType.DeclaringType = parentType;                exportedType.DeclaringModule = parentType.DeclaringModule;              }              break;          }          types.Add(exportedType);        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetTypeList,The following statement contains a magic number: for (int i = 0' n = exportedTypes.Length; i < n; i++){          ExportedTypeRow etr = exportedTypes[i];          Identifier nameSpace = Identifier.For(this.tables.GetString(etr.TypeNamespace));          Identifier typeName = Identifier.For(this.tables.GetString(etr.TypeName));          TypeNode exportedType = null;          switch (etr.Implementation & 0x3){            case 0:              string modName = this.tables.GetString(this.tables.FileTable[(etr.Implementation >> 2)-1].Name);              string modLocation = modName;              Module mod = GetNestedModule(assem' modName' ref modLocation);              if (mod == null){Debug.Assert(false); break;}              exportedType = mod.GetType(nameSpace' typeName);              if (exportedType == null){                HandleError(assem' String.Format(CultureInfo.CurrentCulture'                  ExceptionStrings.CouldNotFindExportedTypeInModule' nameSpace+"."+typeName' modLocation));                exportedType = new Class();                exportedType.Name = typeName;                exportedType.Namespace = nameSpace;                exportedType.Flags = TypeFlags.Class|TypeFlags.Public;                exportedType.DeclaringModule = mod;              }              break;            case 1:              AssemblyReference aref = this.tables.AssemblyRefTable[(etr.Implementation >> 2)-1].AssemblyReference;              if (aref == null){                HandleError(assem' ExceptionStrings.BadMetadataInExportTypeTableNoSuchAssemblyReference);                aref = new AssemblyReference("dummy assembly for bad reference");              }              AssemblyNode a = aref.Assembly;              if (a == null){Debug.Assert(false); continue;}              exportedType = a.GetType(nameSpace' typeName);              if (exportedType == null){                HandleError(assem' String.Format(CultureInfo.CurrentCulture'                   ExceptionStrings.CouldNotFindExportedTypeInAssembly' nameSpace+"."+typeName' a.StrongName));                exportedType = new Class();                exportedType.Name = typeName;                exportedType.Namespace = nameSpace;                exportedType.Flags = TypeFlags.Class|TypeFlags.Public;                exportedType.DeclaringModule = a;              }              break;            case 2:              TypeNode parentType = types[(etr.Implementation >> 2)-1];              if (parentType == null){                HandleError(assem' ExceptionStrings.BadMetadataInExportTypeTableNoSuchParentType);                parentType = new Class();                parentType.DeclaringModule = this.module;                parentType.Name = Identifier.For("Missing parent type");              }              exportedType = parentType.GetNestedType(typeName);              if (exportedType == null){                HandleError(assem' String.Format(CultureInfo.CurrentCulture'                  ExceptionStrings.CouldNotFindExportedNestedTypeInType' typeName' parentType.FullName));                exportedType = new Class();                exportedType.Name = typeName;                exportedType.Flags = TypeFlags.Class|TypeFlags.NestedPublic;                exportedType.DeclaringType = parentType;                exportedType.DeclaringModule = parentType.DeclaringModule;              }              break;          }          types.Add(exportedType);        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetTypeList,The following statement contains a magic number: for (int i = 0' n = exportedTypes.Length; i < n; i++){          ExportedTypeRow etr = exportedTypes[i];          Identifier nameSpace = Identifier.For(this.tables.GetString(etr.TypeNamespace));          Identifier typeName = Identifier.For(this.tables.GetString(etr.TypeName));          TypeNode exportedType = null;          switch (etr.Implementation & 0x3){            case 0:              string modName = this.tables.GetString(this.tables.FileTable[(etr.Implementation >> 2)-1].Name);              string modLocation = modName;              Module mod = GetNestedModule(assem' modName' ref modLocation);              if (mod == null){Debug.Assert(false); break;}              exportedType = mod.GetType(nameSpace' typeName);              if (exportedType == null){                HandleError(assem' String.Format(CultureInfo.CurrentCulture'                  ExceptionStrings.CouldNotFindExportedTypeInModule' nameSpace+"."+typeName' modLocation));                exportedType = new Class();                exportedType.Name = typeName;                exportedType.Namespace = nameSpace;                exportedType.Flags = TypeFlags.Class|TypeFlags.Public;                exportedType.DeclaringModule = mod;              }              break;            case 1:              AssemblyReference aref = this.tables.AssemblyRefTable[(etr.Implementation >> 2)-1].AssemblyReference;              if (aref == null){                HandleError(assem' ExceptionStrings.BadMetadataInExportTypeTableNoSuchAssemblyReference);                aref = new AssemblyReference("dummy assembly for bad reference");              }              AssemblyNode a = aref.Assembly;              if (a == null){Debug.Assert(false); continue;}              exportedType = a.GetType(nameSpace' typeName);              if (exportedType == null){                HandleError(assem' String.Format(CultureInfo.CurrentCulture'                   ExceptionStrings.CouldNotFindExportedTypeInAssembly' nameSpace+"."+typeName' a.StrongName));                exportedType = new Class();                exportedType.Name = typeName;                exportedType.Namespace = nameSpace;                exportedType.Flags = TypeFlags.Class|TypeFlags.Public;                exportedType.DeclaringModule = a;              }              break;            case 2:              TypeNode parentType = types[(etr.Implementation >> 2)-1];              if (parentType == null){                HandleError(assem' ExceptionStrings.BadMetadataInExportTypeTableNoSuchParentType);                parentType = new Class();                parentType.DeclaringModule = this.module;                parentType.Name = Identifier.For("Missing parent type");              }              exportedType = parentType.GetNestedType(typeName);              if (exportedType == null){                HandleError(assem' String.Format(CultureInfo.CurrentCulture'                  ExceptionStrings.CouldNotFindExportedNestedTypeInType' typeName' parentType.FullName));                exportedType = new Class();                exportedType.Name = typeName;                exportedType.Flags = TypeFlags.Class|TypeFlags.NestedPublic;                exportedType.DeclaringType = parentType;                exportedType.DeclaringModule = parentType.DeclaringModule;              }              break;          }          types.Add(exportedType);        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetTypeList,The following statement contains a magic number: for (int i = 0' n = exportedTypes.Length; i < n; i++){          ExportedTypeRow etr = exportedTypes[i];          Identifier nameSpace = Identifier.For(this.tables.GetString(etr.TypeNamespace));          Identifier typeName = Identifier.For(this.tables.GetString(etr.TypeName));          TypeNode exportedType = null;          switch (etr.Implementation & 0x3){            case 0:              string modName = this.tables.GetString(this.tables.FileTable[(etr.Implementation >> 2)-1].Name);              string modLocation = modName;              Module mod = GetNestedModule(assem' modName' ref modLocation);              if (mod == null){Debug.Assert(false); break;}              exportedType = mod.GetType(nameSpace' typeName);              if (exportedType == null){                HandleError(assem' String.Format(CultureInfo.CurrentCulture'                  ExceptionStrings.CouldNotFindExportedTypeInModule' nameSpace+"."+typeName' modLocation));                exportedType = new Class();                exportedType.Name = typeName;                exportedType.Namespace = nameSpace;                exportedType.Flags = TypeFlags.Class|TypeFlags.Public;                exportedType.DeclaringModule = mod;              }              break;            case 1:              AssemblyReference aref = this.tables.AssemblyRefTable[(etr.Implementation >> 2)-1].AssemblyReference;              if (aref == null){                HandleError(assem' ExceptionStrings.BadMetadataInExportTypeTableNoSuchAssemblyReference);                aref = new AssemblyReference("dummy assembly for bad reference");              }              AssemblyNode a = aref.Assembly;              if (a == null){Debug.Assert(false); continue;}              exportedType = a.GetType(nameSpace' typeName);              if (exportedType == null){                HandleError(assem' String.Format(CultureInfo.CurrentCulture'                   ExceptionStrings.CouldNotFindExportedTypeInAssembly' nameSpace+"."+typeName' a.StrongName));                exportedType = new Class();                exportedType.Name = typeName;                exportedType.Namespace = nameSpace;                exportedType.Flags = TypeFlags.Class|TypeFlags.Public;                exportedType.DeclaringModule = a;              }              break;            case 2:              TypeNode parentType = types[(etr.Implementation >> 2)-1];              if (parentType == null){                HandleError(assem' ExceptionStrings.BadMetadataInExportTypeTableNoSuchParentType);                parentType = new Class();                parentType.DeclaringModule = this.module;                parentType.Name = Identifier.For("Missing parent type");              }              exportedType = parentType.GetNestedType(typeName);              if (exportedType == null){                HandleError(assem' String.Format(CultureInfo.CurrentCulture'                  ExceptionStrings.CouldNotFindExportedNestedTypeInType' typeName' parentType.FullName));                exportedType = new Class();                exportedType.Name = typeName;                exportedType.Flags = TypeFlags.Class|TypeFlags.NestedPublic;                exportedType.DeclaringType = parentType;                exportedType.DeclaringModule = parentType.DeclaringModule;              }              break;          }          types.Add(exportedType);        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetTypeAttributes,The following statement contains a magic number: try{          MetadataReader tables = this.tables;          int typeTableIndex = (int)handle;          TypeDefRow[] typeDefs = tables.TypeDefTable;          int n = typeDefs.Length;          if (typeTableIndex < 1 || typeTableIndex > n)             throw new System.ArgumentOutOfRangeException("handle"' ExceptionStrings.InvalidTypeTableIndex);          TypeDefRow td = typeDefs[typeTableIndex-1];          if (type != td.Type) throw new System.ArgumentOutOfRangeException("handle"' ExceptionStrings.InvalidTypeTableIndex);          //Get custom attributes             type.Attributes = this.GetCustomAttributesFor((typeTableIndex << 5)|3);          this.currentTypeParameters = savedCurrentTypeParameters;          //Get security attributes          if ((type.Flags & TypeFlags.HasSecurity) != 0)            type.SecurityAttributes = this.GetSecurityAttributesFor((typeTableIndex << 2)|0);  #if !FxCop        }catch(Exception e){          if (this.module != null){            if (this.module.MetadataImportErrors == null) this.module.MetadataImportErrors = new ArrayList();            this.module.MetadataImportErrors.Add(e);          }          type.Attributes = new AttributeList(0);          this.currentTypeParameters = savedCurrentTypeParameters;        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetTypeAttributes,The following statement contains a magic number: try{          MetadataReader tables = this.tables;          int typeTableIndex = (int)handle;          TypeDefRow[] typeDefs = tables.TypeDefTable;          int n = typeDefs.Length;          if (typeTableIndex < 1 || typeTableIndex > n)             throw new System.ArgumentOutOfRangeException("handle"' ExceptionStrings.InvalidTypeTableIndex);          TypeDefRow td = typeDefs[typeTableIndex-1];          if (type != td.Type) throw new System.ArgumentOutOfRangeException("handle"' ExceptionStrings.InvalidTypeTableIndex);          //Get custom attributes             type.Attributes = this.GetCustomAttributesFor((typeTableIndex << 5)|3);          this.currentTypeParameters = savedCurrentTypeParameters;          //Get security attributes          if ((type.Flags & TypeFlags.HasSecurity) != 0)            type.SecurityAttributes = this.GetSecurityAttributesFor((typeTableIndex << 2)|0);  #if !FxCop        }catch(Exception e){          if (this.module != null){            if (this.module.MetadataImportErrors == null) this.module.MetadataImportErrors = new ArrayList();            this.module.MetadataImportErrors.Add(e);          }          type.Attributes = new AttributeList(0);          this.currentTypeParameters = savedCurrentTypeParameters;        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetTypeAttributes,The following statement contains a magic number: try{          MetadataReader tables = this.tables;          int typeTableIndex = (int)handle;          TypeDefRow[] typeDefs = tables.TypeDefTable;          int n = typeDefs.Length;          if (typeTableIndex < 1 || typeTableIndex > n)             throw new System.ArgumentOutOfRangeException("handle"' ExceptionStrings.InvalidTypeTableIndex);          TypeDefRow td = typeDefs[typeTableIndex-1];          if (type != td.Type) throw new System.ArgumentOutOfRangeException("handle"' ExceptionStrings.InvalidTypeTableIndex);          //Get custom attributes             type.Attributes = this.GetCustomAttributesFor((typeTableIndex << 5)|3);          this.currentTypeParameters = savedCurrentTypeParameters;          //Get security attributes          if ((type.Flags & TypeFlags.HasSecurity) != 0)            type.SecurityAttributes = this.GetSecurityAttributesFor((typeTableIndex << 2)|0);  #if !FxCop        }catch(Exception e){          if (this.module != null){            if (this.module.MetadataImportErrors == null) this.module.MetadataImportErrors = new ArrayList();            this.module.MetadataImportErrors.Add(e);          }          type.Attributes = new AttributeList(0);          this.currentTypeParameters = savedCurrentTypeParameters;        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetTypeParameterAttributes,The following statement contains a magic number: try {          MetadataReader tables = this.tables;          int genericParamIndex = (int)handle;          GenericParamRow[] genParDefs = tables.GenericParamTable;          int n = genParDefs.Length;          if (genericParamIndex < 1 || genericParamIndex > n)            throw new System.ArgumentOutOfRangeException("handle"' ExceptionStrings.InvalidTypeTableIndex);          GenericParamRow td = genParDefs[genericParamIndex-1];          //Get custom attributes             type.Attributes = this.GetCustomAttributesFor((genericParamIndex << 5)|19);          this.currentTypeParameters = savedCurrentTypeParameters;  #if !FxCop        } catch (Exception e) {          if (this.module != null) {            if (this.module.MetadataImportErrors == null) this.module.MetadataImportErrors = new ArrayList();            this.module.MetadataImportErrors.Add(e);          }          type.Attributes = new AttributeList(0);          this.currentTypeParameters = savedCurrentTypeParameters;        }
Magic Number,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetTypeParameterAttributes,The following statement contains a magic number: try {          MetadataReader tables = this.tables;          int genericParamIndex = (int)handle;          GenericParamRow[] genParDefs = tables.GenericParamTable;          int n = genParDefs.Length;          if (genericParamIndex < 1 || genericParamIndex > n)            throw new System.ArgumentOutOfRangeException("handle"' ExceptionStrings.InvalidTypeTableIndex);          GenericParamRow td = genParDefs[genericParamIndex-1];          //Get custom attributes             type.Attributes = this.GetCustomAttributesFor((genericParamIndex << 5)|19);          this.currentTypeParameters = savedCurrentTypeParameters;  #if !FxCop        } catch (Exception e) {          if (this.module != null) {            if (this.module.MetadataImportErrors == null) this.module.MetadataImportErrors = new ArrayList();            this.module.MetadataImportErrors.Add(e);          }          type.Attributes = new AttributeList(0);          this.currentTypeParameters = savedCurrentTypeParameters;        }
Magic Number,Microsoft.Cci.Metadata,ILParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseHeader,The following statement contains a magic number: if ((header & 0x3) == 2){          this.size = header >> 2;          this.bodyReader = this.reader.tables.GetNewCursor();          this.reader.tables.Skip(size);        }else{              method.InitLocals = (header & 0x10) != 0;          byte header2 = this.reader.tables.GetByte();          int fatHeaderSize = header2 >> 4;          if (fatHeaderSize == 2) return;          if (fatHeaderSize != 3) throw new InvalidMetadataException(ExceptionStrings.InvalidFatMethodHeader);          this.reader.tables.Skip(2); //Skip over maxstack. No need to remember it.          this.size = this.reader.tables.GetInt32();          int localIndex = this.reader.tables.GetInt32();          this.bodyReader = this.reader.tables.GetNewCursor();          this.reader.tables.Skip(size);          this.reader.tables.AlignTo32BitBoundary();          while ((header & 0x8) != 0){            header = this.reader.tables.GetByte();            if ((header & 3) != 1) throw new InvalidMetadataException(ExceptionStrings.BadMethodHeaderSection);            if ((header & 0x80) != 0) throw new InvalidMetadataException(ExceptionStrings.TooManyMethodHeaderSections);            this.ParseExceptionHandlerEntry((header & 0x40) == 0);          }          Hashtable localSourceNames = new Hashtable();  #if UseSingularityPDB          if (this.reader.getDebugSymbols && this.reader.pdbFunctions != null) {            PdbFunction pdbFunc = this.reader.GetPdbFunction(0x6000000|(uint)methodIndex);            if (pdbFunc != null)              this.GetLocalNames(pdbFunc.scopes' localSourceNames);          }  #elif !ROTOR          if (this.reader.getDebugSymbols && this.reader.debugReader != null){            ISymUnmanagedMethod methodInfo = null;            try{              try{                this.reader.debugReader.GetMethod(0x6000000|(uint)methodIndex' ref methodInfo);                if (methodInfo != null){                  ISymUnmanagedScope rootScope = methodInfo.GetRootScope();                  try{                    this.reader.GetLocalSourceNames(rootScope' localSourceNames);                  }                  finally{                    if (rootScope != null)                      Marshal.ReleaseComObject(rootScope);                  }                }              }              catch (COMException){              }              catch (InvalidCastException){              }              catch (System.Runtime.InteropServices.InvalidComObjectException){}                        }            finally{              if (methodInfo != null)                Marshal.ReleaseComObject(methodInfo);            }          }  #endif          this.reader.GetLocals(localIndex' this.locals' localSourceNames);        }
Magic Number,Microsoft.Cci.Metadata,ILParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseHeader,The following statement contains a magic number: if ((header & 0x3) == 2){          this.size = header >> 2;          this.bodyReader = this.reader.tables.GetNewCursor();          this.reader.tables.Skip(size);        }else{              method.InitLocals = (header & 0x10) != 0;          byte header2 = this.reader.tables.GetByte();          int fatHeaderSize = header2 >> 4;          if (fatHeaderSize == 2) return;          if (fatHeaderSize != 3) throw new InvalidMetadataException(ExceptionStrings.InvalidFatMethodHeader);          this.reader.tables.Skip(2); //Skip over maxstack. No need to remember it.          this.size = this.reader.tables.GetInt32();          int localIndex = this.reader.tables.GetInt32();          this.bodyReader = this.reader.tables.GetNewCursor();          this.reader.tables.Skip(size);          this.reader.tables.AlignTo32BitBoundary();          while ((header & 0x8) != 0){            header = this.reader.tables.GetByte();            if ((header & 3) != 1) throw new InvalidMetadataException(ExceptionStrings.BadMethodHeaderSection);            if ((header & 0x80) != 0) throw new InvalidMetadataException(ExceptionStrings.TooManyMethodHeaderSections);            this.ParseExceptionHandlerEntry((header & 0x40) == 0);          }          Hashtable localSourceNames = new Hashtable();  #if UseSingularityPDB          if (this.reader.getDebugSymbols && this.reader.pdbFunctions != null) {            PdbFunction pdbFunc = this.reader.GetPdbFunction(0x6000000|(uint)methodIndex);            if (pdbFunc != null)              this.GetLocalNames(pdbFunc.scopes' localSourceNames);          }  #elif !ROTOR          if (this.reader.getDebugSymbols && this.reader.debugReader != null){            ISymUnmanagedMethod methodInfo = null;            try{              try{                this.reader.debugReader.GetMethod(0x6000000|(uint)methodIndex' ref methodInfo);                if (methodInfo != null){                  ISymUnmanagedScope rootScope = methodInfo.GetRootScope();                  try{                    this.reader.GetLocalSourceNames(rootScope' localSourceNames);                  }                  finally{                    if (rootScope != null)                      Marshal.ReleaseComObject(rootScope);                  }                }              }              catch (COMException){              }              catch (InvalidCastException){              }              catch (System.Runtime.InteropServices.InvalidComObjectException){}                        }            finally{              if (methodInfo != null)                Marshal.ReleaseComObject(methodInfo);            }          }  #endif          this.reader.GetLocals(localIndex' this.locals' localSourceNames);        }
Magic Number,Microsoft.Cci.Metadata,ILParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseHeader,The following statement contains a magic number: if ((header & 0x3) == 2){          this.size = header >> 2;          this.bodyReader = this.reader.tables.GetNewCursor();          this.reader.tables.Skip(size);        }else{              method.InitLocals = (header & 0x10) != 0;          byte header2 = this.reader.tables.GetByte();          int fatHeaderSize = header2 >> 4;          if (fatHeaderSize == 2) return;          if (fatHeaderSize != 3) throw new InvalidMetadataException(ExceptionStrings.InvalidFatMethodHeader);          this.reader.tables.Skip(2); //Skip over maxstack. No need to remember it.          this.size = this.reader.tables.GetInt32();          int localIndex = this.reader.tables.GetInt32();          this.bodyReader = this.reader.tables.GetNewCursor();          this.reader.tables.Skip(size);          this.reader.tables.AlignTo32BitBoundary();          while ((header & 0x8) != 0){            header = this.reader.tables.GetByte();            if ((header & 3) != 1) throw new InvalidMetadataException(ExceptionStrings.BadMethodHeaderSection);            if ((header & 0x80) != 0) throw new InvalidMetadataException(ExceptionStrings.TooManyMethodHeaderSections);            this.ParseExceptionHandlerEntry((header & 0x40) == 0);          }          Hashtable localSourceNames = new Hashtable();  #if UseSingularityPDB          if (this.reader.getDebugSymbols && this.reader.pdbFunctions != null) {            PdbFunction pdbFunc = this.reader.GetPdbFunction(0x6000000|(uint)methodIndex);            if (pdbFunc != null)              this.GetLocalNames(pdbFunc.scopes' localSourceNames);          }  #elif !ROTOR          if (this.reader.getDebugSymbols && this.reader.debugReader != null){            ISymUnmanagedMethod methodInfo = null;            try{              try{                this.reader.debugReader.GetMethod(0x6000000|(uint)methodIndex' ref methodInfo);                if (methodInfo != null){                  ISymUnmanagedScope rootScope = methodInfo.GetRootScope();                  try{                    this.reader.GetLocalSourceNames(rootScope' localSourceNames);                  }                  finally{                    if (rootScope != null)                      Marshal.ReleaseComObject(rootScope);                  }                }              }              catch (COMException){              }              catch (InvalidCastException){              }              catch (System.Runtime.InteropServices.InvalidComObjectException){}                        }            finally{              if (methodInfo != null)                Marshal.ReleaseComObject(methodInfo);            }          }  #endif          this.reader.GetLocals(localIndex' this.locals' localSourceNames);        }
Magic Number,Microsoft.Cci.Metadata,ILParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseHeader,The following statement contains a magic number: if ((header & 0x3) == 2){          this.size = header >> 2;          this.bodyReader = this.reader.tables.GetNewCursor();          this.reader.tables.Skip(size);        }else{              method.InitLocals = (header & 0x10) != 0;          byte header2 = this.reader.tables.GetByte();          int fatHeaderSize = header2 >> 4;          if (fatHeaderSize == 2) return;          if (fatHeaderSize != 3) throw new InvalidMetadataException(ExceptionStrings.InvalidFatMethodHeader);          this.reader.tables.Skip(2); //Skip over maxstack. No need to remember it.          this.size = this.reader.tables.GetInt32();          int localIndex = this.reader.tables.GetInt32();          this.bodyReader = this.reader.tables.GetNewCursor();          this.reader.tables.Skip(size);          this.reader.tables.AlignTo32BitBoundary();          while ((header & 0x8) != 0){            header = this.reader.tables.GetByte();            if ((header & 3) != 1) throw new InvalidMetadataException(ExceptionStrings.BadMethodHeaderSection);            if ((header & 0x80) != 0) throw new InvalidMetadataException(ExceptionStrings.TooManyMethodHeaderSections);            this.ParseExceptionHandlerEntry((header & 0x40) == 0);          }          Hashtable localSourceNames = new Hashtable();  #if UseSingularityPDB          if (this.reader.getDebugSymbols && this.reader.pdbFunctions != null) {            PdbFunction pdbFunc = this.reader.GetPdbFunction(0x6000000|(uint)methodIndex);            if (pdbFunc != null)              this.GetLocalNames(pdbFunc.scopes' localSourceNames);          }  #elif !ROTOR          if (this.reader.getDebugSymbols && this.reader.debugReader != null){            ISymUnmanagedMethod methodInfo = null;            try{              try{                this.reader.debugReader.GetMethod(0x6000000|(uint)methodIndex' ref methodInfo);                if (methodInfo != null){                  ISymUnmanagedScope rootScope = methodInfo.GetRootScope();                  try{                    this.reader.GetLocalSourceNames(rootScope' localSourceNames);                  }                  finally{                    if (rootScope != null)                      Marshal.ReleaseComObject(rootScope);                  }                }              }              catch (COMException){              }              catch (InvalidCastException){              }              catch (System.Runtime.InteropServices.InvalidComObjectException){}                        }            finally{              if (methodInfo != null)                Marshal.ReleaseComObject(methodInfo);            }          }  #endif          this.reader.GetLocals(localIndex' this.locals' localSourceNames);        }
Magic Number,Microsoft.Cci.Metadata,ILParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseHeader,The following statement contains a magic number: if ((header & 0x3) == 2){          this.size = header >> 2;          this.bodyReader = this.reader.tables.GetNewCursor();          this.reader.tables.Skip(size);        }else{              method.InitLocals = (header & 0x10) != 0;          byte header2 = this.reader.tables.GetByte();          int fatHeaderSize = header2 >> 4;          if (fatHeaderSize == 2) return;          if (fatHeaderSize != 3) throw new InvalidMetadataException(ExceptionStrings.InvalidFatMethodHeader);          this.reader.tables.Skip(2); //Skip over maxstack. No need to remember it.          this.size = this.reader.tables.GetInt32();          int localIndex = this.reader.tables.GetInt32();          this.bodyReader = this.reader.tables.GetNewCursor();          this.reader.tables.Skip(size);          this.reader.tables.AlignTo32BitBoundary();          while ((header & 0x8) != 0){            header = this.reader.tables.GetByte();            if ((header & 3) != 1) throw new InvalidMetadataException(ExceptionStrings.BadMethodHeaderSection);            if ((header & 0x80) != 0) throw new InvalidMetadataException(ExceptionStrings.TooManyMethodHeaderSections);            this.ParseExceptionHandlerEntry((header & 0x40) == 0);          }          Hashtable localSourceNames = new Hashtable();  #if UseSingularityPDB          if (this.reader.getDebugSymbols && this.reader.pdbFunctions != null) {            PdbFunction pdbFunc = this.reader.GetPdbFunction(0x6000000|(uint)methodIndex);            if (pdbFunc != null)              this.GetLocalNames(pdbFunc.scopes' localSourceNames);          }  #elif !ROTOR          if (this.reader.getDebugSymbols && this.reader.debugReader != null){            ISymUnmanagedMethod methodInfo = null;            try{              try{                this.reader.debugReader.GetMethod(0x6000000|(uint)methodIndex' ref methodInfo);                if (methodInfo != null){                  ISymUnmanagedScope rootScope = methodInfo.GetRootScope();                  try{                    this.reader.GetLocalSourceNames(rootScope' localSourceNames);                  }                  finally{                    if (rootScope != null)                      Marshal.ReleaseComObject(rootScope);                  }                }              }              catch (COMException){              }              catch (InvalidCastException){              }              catch (System.Runtime.InteropServices.InvalidComObjectException){}                        }            finally{              if (methodInfo != null)                Marshal.ReleaseComObject(methodInfo);            }          }  #endif          this.reader.GetLocals(localIndex' this.locals' localSourceNames);        }
Magic Number,Microsoft.Cci.Metadata,ILParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseHeader,The following statement contains a magic number: if ((header & 0x3) == 2){          this.size = header >> 2;          this.bodyReader = this.reader.tables.GetNewCursor();          this.reader.tables.Skip(size);        }else{              method.InitLocals = (header & 0x10) != 0;          byte header2 = this.reader.tables.GetByte();          int fatHeaderSize = header2 >> 4;          if (fatHeaderSize == 2) return;          if (fatHeaderSize != 3) throw new InvalidMetadataException(ExceptionStrings.InvalidFatMethodHeader);          this.reader.tables.Skip(2); //Skip over maxstack. No need to remember it.          this.size = this.reader.tables.GetInt32();          int localIndex = this.reader.tables.GetInt32();          this.bodyReader = this.reader.tables.GetNewCursor();          this.reader.tables.Skip(size);          this.reader.tables.AlignTo32BitBoundary();          while ((header & 0x8) != 0){            header = this.reader.tables.GetByte();            if ((header & 3) != 1) throw new InvalidMetadataException(ExceptionStrings.BadMethodHeaderSection);            if ((header & 0x80) != 0) throw new InvalidMetadataException(ExceptionStrings.TooManyMethodHeaderSections);            this.ParseExceptionHandlerEntry((header & 0x40) == 0);          }          Hashtable localSourceNames = new Hashtable();  #if UseSingularityPDB          if (this.reader.getDebugSymbols && this.reader.pdbFunctions != null) {            PdbFunction pdbFunc = this.reader.GetPdbFunction(0x6000000|(uint)methodIndex);            if (pdbFunc != null)              this.GetLocalNames(pdbFunc.scopes' localSourceNames);          }  #elif !ROTOR          if (this.reader.getDebugSymbols && this.reader.debugReader != null){            ISymUnmanagedMethod methodInfo = null;            try{              try{                this.reader.debugReader.GetMethod(0x6000000|(uint)methodIndex' ref methodInfo);                if (methodInfo != null){                  ISymUnmanagedScope rootScope = methodInfo.GetRootScope();                  try{                    this.reader.GetLocalSourceNames(rootScope' localSourceNames);                  }                  finally{                    if (rootScope != null)                      Marshal.ReleaseComObject(rootScope);                  }                }              }              catch (COMException){              }              catch (InvalidCastException){              }              catch (System.Runtime.InteropServices.InvalidComObjectException){}                        }            finally{              if (methodInfo != null)                Marshal.ReleaseComObject(methodInfo);            }          }  #endif          this.reader.GetLocals(localIndex' this.locals' localSourceNames);        }
Magic Number,Microsoft.Cci.Metadata,ILParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseHeader,The following statement contains a magic number: if ((header & 0x3) == 2){          this.size = header >> 2;          this.bodyReader = this.reader.tables.GetNewCursor();          this.reader.tables.Skip(size);        }else{              method.InitLocals = (header & 0x10) != 0;          byte header2 = this.reader.tables.GetByte();          int fatHeaderSize = header2 >> 4;          if (fatHeaderSize == 2) return;          if (fatHeaderSize != 3) throw new InvalidMetadataException(ExceptionStrings.InvalidFatMethodHeader);          this.reader.tables.Skip(2); //Skip over maxstack. No need to remember it.          this.size = this.reader.tables.GetInt32();          int localIndex = this.reader.tables.GetInt32();          this.bodyReader = this.reader.tables.GetNewCursor();          this.reader.tables.Skip(size);          this.reader.tables.AlignTo32BitBoundary();          while ((header & 0x8) != 0){            header = this.reader.tables.GetByte();            if ((header & 3) != 1) throw new InvalidMetadataException(ExceptionStrings.BadMethodHeaderSection);            if ((header & 0x80) != 0) throw new InvalidMetadataException(ExceptionStrings.TooManyMethodHeaderSections);            this.ParseExceptionHandlerEntry((header & 0x40) == 0);          }          Hashtable localSourceNames = new Hashtable();  #if UseSingularityPDB          if (this.reader.getDebugSymbols && this.reader.pdbFunctions != null) {            PdbFunction pdbFunc = this.reader.GetPdbFunction(0x6000000|(uint)methodIndex);            if (pdbFunc != null)              this.GetLocalNames(pdbFunc.scopes' localSourceNames);          }  #elif !ROTOR          if (this.reader.getDebugSymbols && this.reader.debugReader != null){            ISymUnmanagedMethod methodInfo = null;            try{              try{                this.reader.debugReader.GetMethod(0x6000000|(uint)methodIndex' ref methodInfo);                if (methodInfo != null){                  ISymUnmanagedScope rootScope = methodInfo.GetRootScope();                  try{                    this.reader.GetLocalSourceNames(rootScope' localSourceNames);                  }                  finally{                    if (rootScope != null)                      Marshal.ReleaseComObject(rootScope);                  }                }              }              catch (COMException){              }              catch (InvalidCastException){              }              catch (System.Runtime.InteropServices.InvalidComObjectException){}                        }            finally{              if (methodInfo != null)                Marshal.ReleaseComObject(methodInfo);            }          }  #endif          this.reader.GetLocals(localIndex' this.locals' localSourceNames);        }
Magic Number,Microsoft.Cci.Metadata,ILParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetInt16,The following statement contains a magic number: this.counter += 2;
Magic Number,Microsoft.Cci.Metadata,ILParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetInt32,The following statement contains a magic number: this.counter += 4;
Magic Number,Microsoft.Cci.Metadata,ILParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetInt64,The following statement contains a magic number: this.counter += 8;
Magic Number,Microsoft.Cci.Metadata,ILParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetSingle,The following statement contains a magic number: this.counter += 4;
Magic Number,Microsoft.Cci.Metadata,ILParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetDouble,The following statement contains a magic number: this.counter += 8;
Magic Number,Microsoft.Cci.Metadata,ILParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetOpCode,The following statement contains a magic number: if (result == (int)OpCode.Prefix1)          result = result << 8 | this.GetByte();
Magic Number,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseExceptionHandlerEntry,The following statement contains a magic number: if (smallSection)          n = dataSize / 12;        else          n = (dataSize + (n << 8)) / 24;
Magic Number,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseExceptionHandlerEntry,The following statement contains a magic number: if (smallSection)          n = dataSize / 12;        else          n = (dataSize + (n << 8)) / 24;
Magic Number,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseExceptionHandlerEntry,The following statement contains a magic number: if (smallSection)          n = dataSize / 12;        else          n = (dataSize + (n << 8)) / 24;
Magic Number,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true){          bool isStatement = false;          startingAddress = this.counter+1; //Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  #if FxCop || ILOFFSETS          this.ilOffset = this.counter;          this.opCode = this.GetOpCode();  #else          OpCode opCode = this.GetOpCode();  #endif  #if FxCop          if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){            expr.sourceContext = sourceContext;            expr.ILOffset = this.ilOffset;            this.operandStack.Push(expr);          }  #endif          switch (opCode){            case OpCode.Nop: statement = new Statement(NodeType.Nop); goto done;            case OpCode.Break: statement = new Statement(NodeType.DebugBreak); goto done;            case OpCode.Ldarg_0: expr = this.Parameters(0); break;            case OpCode.Ldarg_1: expr = this.Parameters(1); break;            case OpCode.Ldarg_2: expr = this.Parameters(2); break;            case OpCode.Ldarg_3: expr = this.Parameters(3); break;            case OpCode.Ldloc_0: expr = this.locals[0]; break;            case OpCode.Ldloc_1: expr = this.locals[1]; break;            case OpCode.Ldloc_2: expr = this.locals[2]; break;            case OpCode.Ldloc_3: expr = this.locals[3]; break;            case OpCode.Stloc_0: statement = new AssignmentStatement(this.locals[0]' PopOperand()); goto done;            case OpCode.Stloc_1: statement = new AssignmentStatement(this.locals[1]' PopOperand()); goto done;            case OpCode.Stloc_2: statement = new AssignmentStatement(this.locals[2]' PopOperand()); goto done;            case OpCode.Stloc_3: statement = new AssignmentStatement(this.locals[3]' PopOperand()); goto done;            case OpCode.Ldarg_S: expr = this.Parameters(this.GetByte()); break;            case OpCode.Ldarga_S: expr = SetType(new UnaryExpression(this.Parameters(this.GetByte())' NodeType.AddressOf)); break;            case OpCode.Starg_S: statement = new AssignmentStatement(this.Parameters(this.GetByte())' PopOperand()); goto done;            case OpCode.Ldloc_S: expr = this.locals[this.GetByte()]; break;            case OpCode.Ldloca_S: expr = SetType(new UnaryExpression(this.locals[this.GetByte()]' NodeType.AddressOf)); break;            case OpCode.Stloc_S: statement = new AssignmentStatement(this.locals[this.GetByte()]' PopOperand()); goto done;            case OpCode.Ldnull: expr = new Literal(null' CoreSystemTypes.Object); break;            case OpCode.Ldc_I4_M1: expr = new Literal(-1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_0: expr = new Literal(0' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_1: expr = new Literal(1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_2: expr = new Literal(2' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_3: expr = new Literal(3' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_4: expr = new Literal(4' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_5: expr = new Literal(5' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_6: expr = new Literal(6' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_7: expr = new Literal(7' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_8: expr = new Literal(8' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_S: expr = new Literal((int)this.GetSByte()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4: expr = new Literal(this.GetInt32()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I8: expr = new Literal(this.GetInt64()' CoreSystemTypes.Int64); break;            case OpCode.Ldc_R4: expr = new Literal(this.GetSingle()' CoreSystemTypes.Single); break;            case OpCode.Ldc_R8: expr = new Literal(this.GetDouble()' CoreSystemTypes.Double); break;            case OpCode.Dup: statement = new ExpressionStatement(new Expression(NodeType.Dup)); goto done;            case OpCode.Pop: statement = new ExpressionStatement(new UnaryExpression(PopOperand()' NodeType.Pop)); goto done;            case OpCode.Jmp: expr = this.ParseCall(NodeType.Jmp' out isStatement); if (isStatement) goto done; break;            case OpCode.Call: expr = this.ParseCall(NodeType.Call' out isStatement); if (isStatement) goto done; break;            case OpCode.Calli: expr = this.ParseCalli(out isStatement); if (isStatement) goto done; break;            case OpCode.Ret:              Expression retVal = BodyParser.TypeIsVoid(this.method.ReturnType) ? null : PopOperand();              statement = new Return(retVal);               transferStatement = true; goto done;            case OpCode.Br_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false); transferStatement = true; goto done;            case OpCode.Brfalse_S: statement = this.ParseBranch(NodeType.LogicalNot' 1' true' false); transferStatement = true; goto done;            case OpCode.Brtrue_S: statement = this.ParseBranch(NodeType.Nop' 1' true' false); transferStatement = true; goto done;            case OpCode.Beq_S: statement = this.ParseBranch(NodeType.Eq' 2' true' false); transferStatement = true; goto done;            case OpCode.Bge_S: statement = this.ParseBranch(NodeType.Ge' 2' true' false); transferStatement = true; goto done;            case OpCode.Bgt_S: statement = this.ParseBranch(NodeType.Gt' 2' true' false); transferStatement = true; goto done;            case OpCode.Ble_S: statement = this.ParseBranch(NodeType.Le' 2' true' false); transferStatement = true; goto done;            case OpCode.Blt_S: statement = this.ParseBranch(NodeType.Lt' 2' true' false); transferStatement = true; goto done;            case OpCode.Bne_Un_S: statement = this.ParseBranch(NodeType.Ne' 2' true' true); transferStatement = true; goto done;            case OpCode.Bge_Un_S: statement = this.ParseBranch(NodeType.Ge' 2' true' true); transferStatement = true; goto done;            case OpCode.Bgt_Un_S: statement = this.ParseBranch(NodeType.Gt' 2' true' true); transferStatement = true; goto done;            case OpCode.Ble_Un_S: statement = this.ParseBranch(NodeType.Le' 2' true' true); transferStatement = true; goto done;            case OpCode.Blt_Un_S: statement = this.ParseBranch(NodeType.Lt' 2' true' true); transferStatement = true; goto done;            case OpCode.Br: statement = this.ParseBranch(NodeType.Nop' 0' false' false); transferStatement = true; goto done;            case OpCode.Brfalse: statement = this.ParseBranch(NodeType.LogicalNot' 1' false' false); transferStatement = true; goto done;            case OpCode.Brtrue: statement = this.ParseBranch(NodeType.Nop' 1' false' false); transferStatement = true; goto done;            case OpCode.Beq: statement = this.ParseBranch(NodeType.Eq' 2' false' false); transferStatement = true; goto done;            case OpCode.Bge: statement = this.ParseBranch(NodeType.Ge' 2' false' false); transferStatement = true; goto done;            case OpCode.Bgt: statement = this.ParseBranch(NodeType.Gt' 2' false' false); transferStatement = true; goto done;            case OpCode.Ble: statement = this.ParseBranch(NodeType.Le' 2' false' false); transferStatement = true; goto done;            case OpCode.Blt: statement = this.ParseBranch(NodeType.Lt' 2' false' false); transferStatement = true; goto done;            case OpCode.Bne_Un: statement = this.ParseBranch(NodeType.Ne' 2' false' true); transferStatement = true; goto done;            case OpCode.Bge_Un: statement = this.ParseBranch(NodeType.Ge' 2' false' true); transferStatement = true; goto done;            case OpCode.Bgt_Un: statement = this.ParseBranch(NodeType.Gt' 2' false' true); transferStatement = true; goto done;            case OpCode.Ble_Un: statement = this.ParseBranch(NodeType.Le' 2' false' true); transferStatement = true; goto done;            case OpCode.Blt_Un: statement = this.ParseBranch(NodeType.Lt' 2' false' true); transferStatement = true; goto done;            case OpCode.Switch: statement = this.ParseSwitchInstruction(); transferStatement = true; goto done;            case OpCode.Ldind_I1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int64' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I: expr = new AddressDereference(PopOperand()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Single' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Double' this.isVolatile' this.alignment); break;            case OpCode.Ldind_Ref: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Object' this.isVolatile' this.alignment); break;            case OpCode.Stind_Ref: statement = this.ParseStoreIndirect(CoreSystemTypes.Object); goto done;            case OpCode.Stind_I1: statement = this.ParseStoreIndirect(CoreSystemTypes.Int8); goto done;            case OpCode.Stind_I2: statement = this.ParseStoreIndirect(CoreSystemTypes.Int16); goto done;            case OpCode.Stind_I4: statement = this.ParseStoreIndirect(CoreSystemTypes.Int32); goto done;            case OpCode.Stind_I8: statement = this.ParseStoreIndirect(CoreSystemTypes.Int64); goto done;            case OpCode.Stind_R4: statement = this.ParseStoreIndirect(CoreSystemTypes.Single); goto done;            case OpCode.Stind_R8: statement = this.ParseStoreIndirect(CoreSystemTypes.Double); goto done;            case OpCode.Add: expr = this.ParseBinaryOperation(NodeType.Add); break;            case OpCode.Sub: expr = this.ParseBinaryOperation(NodeType.Sub); break;            case OpCode.Mul: expr = this.ParseBinaryOperation(NodeType.Mul); break;            case OpCode.Div: expr = this.ParseBinaryOperation(NodeType.Div); break;            case OpCode.Div_Un: expr = this.ParseBinaryOperation(NodeType.Div_Un); break;            case OpCode.Rem: expr = this.ParseBinaryOperation(NodeType.Rem); break;            case OpCode.Rem_Un: expr = this.ParseBinaryOperation(NodeType.Rem_Un); break;            case OpCode.And: expr = this.ParseBinaryOperation(NodeType.And); break;            case OpCode.Or: expr = this.ParseBinaryOperation(NodeType.Or); break;            case OpCode.Xor: expr = this.ParseBinaryOperation(NodeType.Xor); break;            case OpCode.Shl: expr = this.ParseBinaryOperation(NodeType.Shl); break;            case OpCode.Shr: expr = this.ParseBinaryOperation(NodeType.Shr); break;            case OpCode.Shr_Un: expr = this.ParseBinaryOperation(NodeType.Shr_Un); break;            case OpCode.Neg: expr = this.ParseUnaryOperation(NodeType.Neg); break;            case OpCode.Not: expr = this.ParseUnaryOperation(NodeType.Not); break;            case OpCode.Conv_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_R4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R4' CoreSystemTypes.Single); break;            case OpCode.Conv_R8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R8' CoreSystemTypes.Double); break;            case OpCode.Conv_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U8' CoreSystemTypes.UInt64); break;            case OpCode.Callvirt: expr = this.ParseCall(NodeType.Callvirt' out isStatement); if (isStatement) goto done; break;            case OpCode.Cpobj: statement = this.ParseCopyObject(); goto done;            case OpCode.Ldobj: expr = new AddressDereference(PopOperand()' (TypeNode)this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldstr: expr = new Literal(this.GetStringFromToken()' CoreSystemTypes.String); break;            case OpCode.Newobj: expr = this.ParseConstruct(); break;            case OpCode.Castclass: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Castclass); break;            case OpCode.Isinst: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Isinst); break;            case OpCode.Conv_R_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R_Un' CoreSystemTypes.Double); break;            case OpCode.Unbox: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Unbox); break;            case OpCode.Throw: statement = new Throw(PopOperand()); transferStatement = true; goto done;            case OpCode.Ldfld:               expr = new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment);              break;            case OpCode.Ldflda:               expr = SetType(new UnaryExpression(new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf));               break;            case OpCode.Stfld: statement = this.ParseStoreField(); goto done;            case OpCode.Ldsfld: expr = new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldsflda: expr = SetType(new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf)); break;            case OpCode.Stsfld: statement = new AssignmentStatement(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' PopOperand()); goto done;            case OpCode.Stobj: statement = this.ParseStoreIndirect((TypeNode)this.GetMemberFromToken()); goto done;            case OpCode.Conv_Ovf_I1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_I2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_I4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_I8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_U2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_U4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_U8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64); break;            case OpCode.Conv_Ovf_I_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr); break;            case OpCode.Box:               TypeNode t = (TypeNode)this.GetMemberFromToken();              TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;              expr = new BinaryExpression(PopOperand()' new Literal(t' CoreSystemTypes.Type)' NodeType.Box' bt); break;            case OpCode.Newarr: expr = this.ParseNewArray(); break;            case OpCode.Ldlen: expr = new UnaryExpression(PopOperand()' NodeType.Ldlen' CoreSystemTypes.UIntPtr); break;            case OpCode.Ldelema: expr = this.ParseArrayElementLoadAddress(); break;            case OpCode.Ldelem_I1:             case OpCode.Ldelem_U1:             case OpCode.Ldelem_I2:             case OpCode.Ldelem_U2:             case OpCode.Ldelem_I4:             case OpCode.Ldelem_U4:             case OpCode.Ldelem_I8:             case OpCode.Ldelem_I:             case OpCode.Ldelem_R4:             case OpCode.Ldelem_R8:             case OpCode.Ldelem_Ref: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem_I:            case OpCode.Stelem_I1:            case OpCode.Stelem_I2:            case OpCode.Stelem_I4:            case OpCode.Stelem_I8:            case OpCode.Stelem_R4:            case OpCode.Stelem_R8:            case OpCode.Stelem_Ref: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Ldelem: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Unbox_Any: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.UnboxAny); break;            case OpCode.Conv_Ovf_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64); break;            case OpCode.Refanyval: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr); break;            case OpCode.Ckfinite: expr = this.ParseUnaryOperation(NodeType.Ckfinite); break;            case OpCode.Mkrefany: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference); break;            case OpCode.Ldtoken: expr = ParseLoadRuntimeMetadataToken(); break;            case OpCode.Conv_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Add_Ovf: expr = this.ParseBinaryOperation(NodeType.Add_Ovf); break;            case OpCode.Add_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Add_Ovf_Un); break;            case OpCode.Mul_Ovf: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf); break;            case OpCode.Mul_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf_Un); break;            case OpCode.Sub_Ovf: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf); break;            case OpCode.Sub_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf_Un); break;            case OpCode.Endfinally: statement = new EndFinally(); transferStatement = true; goto done;            case OpCode.Leave: statement = this.ParseBranch(NodeType.Nop' 0' false' false' true); transferStatement = true; goto done;            case OpCode.Leave_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false' true); transferStatement = true; goto done;            case OpCode.Stind_I: statement = this.ParseStoreIndirect(CoreSystemTypes.IntPtr); goto done;            case OpCode.Conv_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Arglist: expr = new Expression(NodeType.Arglist' CoreSystemTypes.ArgIterator); break;            case OpCode.Ceq: expr = this.ParseBinaryComparison(NodeType.Ceq); break;            case OpCode.Cgt: expr = this.ParseBinaryComparison(NodeType.Cgt); break;            case OpCode.Cgt_Un: expr = this.ParseBinaryComparison(NodeType.Cgt_Un); break;            case OpCode.Clt: expr = this.ParseBinaryComparison(NodeType.Clt); break;            case OpCode.Clt_Un: expr = this.ParseBinaryComparison(NodeType.Clt_Un); break;            case OpCode.Ldftn: expr = new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldvirtftn: expr = new BinaryExpression(PopOperand()' new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldarg: expr = this.Parameters((ushort)this.GetInt16()); break;            case OpCode.Ldarga: expr = SetType(new UnaryExpression(this.Parameters((ushort)this.GetInt16())' NodeType.AddressOf)); break;            case OpCode.Starg: statement = new AssignmentStatement(this.Parameters((ushort)this.GetInt16())' PopOperand()); goto done;            case OpCode.Ldloc: expr = this.locals[(ushort)this.GetInt16()]; break;            case OpCode.Ldloca: expr = SetType(new UnaryExpression(this.locals[(ushort)this.GetInt16()]' NodeType.AddressOf)); break;            case OpCode.Stloc: statement = new AssignmentStatement(this.locals[(ushort)this.GetInt16()]' PopOperand()); goto done;            case OpCode.Localloc: expr = new UnaryExpression(PopOperand()' NodeType.Localloc' CoreSystemTypes.Void); break;            case OpCode.Endfilter: statement = new EndFilter(PopOperand()); transferStatement = true; goto done;            case OpCode.Unaligned_: this.alignment = this.GetByte(); continue;            case OpCode.Volatile_: this.isVolatile = true; continue;            case OpCode.Tail_: this.isTailCall = true; continue;            case OpCode.Initobj: statement = this.ParseInitObject(); goto done;            case OpCode.Constrained_: this.constraint = this.GetMemberFromToken() as TypeNode; continue;            case OpCode.Cpblk: expr = this.ParseTernaryOperation(NodeType.Cpblk); goto done;            case OpCode.Initblk: expr = this.ParseTernaryOperation(NodeType.Initblk); goto done;            case OpCode.Rethrow: statement = new Throw(null); statement.NodeType = NodeType.Rethrow; transferStatement = true; goto done;            case OpCode.Sizeof: expr = new UnaryExpression(new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32); break;            case OpCode.Refanytype: expr = new UnaryExpression(PopOperand()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle); break;            case OpCode.Readonly_: this.isReadOnly = true; continue;            default: throw new InvalidMetadataException(ExceptionStrings.UnknownOpCode);          }          if (this.blockMap[this.counter+1] != null){            transferStatement = true; //Falls through to the next basic block' so implicitly a "transfer" statement            goto done;          }          //^ assume expr != null;  #if FxCop          expr.sourceContext = sourceContext;  #endif  #if FxCop || ILOFFSETS          expr.ILOffset = this.ilOffset;  #endif          this.operandStack.Push(expr);          this.isReadOnly = false;          this.isVolatile = false;          this.isTailCall = false;                  this.alignment = -1;        }
Magic Number,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true){          bool isStatement = false;          startingAddress = this.counter+1; //Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  #if FxCop || ILOFFSETS          this.ilOffset = this.counter;          this.opCode = this.GetOpCode();  #else          OpCode opCode = this.GetOpCode();  #endif  #if FxCop          if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){            expr.sourceContext = sourceContext;            expr.ILOffset = this.ilOffset;            this.operandStack.Push(expr);          }  #endif          switch (opCode){            case OpCode.Nop: statement = new Statement(NodeType.Nop); goto done;            case OpCode.Break: statement = new Statement(NodeType.DebugBreak); goto done;            case OpCode.Ldarg_0: expr = this.Parameters(0); break;            case OpCode.Ldarg_1: expr = this.Parameters(1); break;            case OpCode.Ldarg_2: expr = this.Parameters(2); break;            case OpCode.Ldarg_3: expr = this.Parameters(3); break;            case OpCode.Ldloc_0: expr = this.locals[0]; break;            case OpCode.Ldloc_1: expr = this.locals[1]; break;            case OpCode.Ldloc_2: expr = this.locals[2]; break;            case OpCode.Ldloc_3: expr = this.locals[3]; break;            case OpCode.Stloc_0: statement = new AssignmentStatement(this.locals[0]' PopOperand()); goto done;            case OpCode.Stloc_1: statement = new AssignmentStatement(this.locals[1]' PopOperand()); goto done;            case OpCode.Stloc_2: statement = new AssignmentStatement(this.locals[2]' PopOperand()); goto done;            case OpCode.Stloc_3: statement = new AssignmentStatement(this.locals[3]' PopOperand()); goto done;            case OpCode.Ldarg_S: expr = this.Parameters(this.GetByte()); break;            case OpCode.Ldarga_S: expr = SetType(new UnaryExpression(this.Parameters(this.GetByte())' NodeType.AddressOf)); break;            case OpCode.Starg_S: statement = new AssignmentStatement(this.Parameters(this.GetByte())' PopOperand()); goto done;            case OpCode.Ldloc_S: expr = this.locals[this.GetByte()]; break;            case OpCode.Ldloca_S: expr = SetType(new UnaryExpression(this.locals[this.GetByte()]' NodeType.AddressOf)); break;            case OpCode.Stloc_S: statement = new AssignmentStatement(this.locals[this.GetByte()]' PopOperand()); goto done;            case OpCode.Ldnull: expr = new Literal(null' CoreSystemTypes.Object); break;            case OpCode.Ldc_I4_M1: expr = new Literal(-1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_0: expr = new Literal(0' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_1: expr = new Literal(1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_2: expr = new Literal(2' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_3: expr = new Literal(3' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_4: expr = new Literal(4' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_5: expr = new Literal(5' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_6: expr = new Literal(6' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_7: expr = new Literal(7' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_8: expr = new Literal(8' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_S: expr = new Literal((int)this.GetSByte()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4: expr = new Literal(this.GetInt32()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I8: expr = new Literal(this.GetInt64()' CoreSystemTypes.Int64); break;            case OpCode.Ldc_R4: expr = new Literal(this.GetSingle()' CoreSystemTypes.Single); break;            case OpCode.Ldc_R8: expr = new Literal(this.GetDouble()' CoreSystemTypes.Double); break;            case OpCode.Dup: statement = new ExpressionStatement(new Expression(NodeType.Dup)); goto done;            case OpCode.Pop: statement = new ExpressionStatement(new UnaryExpression(PopOperand()' NodeType.Pop)); goto done;            case OpCode.Jmp: expr = this.ParseCall(NodeType.Jmp' out isStatement); if (isStatement) goto done; break;            case OpCode.Call: expr = this.ParseCall(NodeType.Call' out isStatement); if (isStatement) goto done; break;            case OpCode.Calli: expr = this.ParseCalli(out isStatement); if (isStatement) goto done; break;            case OpCode.Ret:              Expression retVal = BodyParser.TypeIsVoid(this.method.ReturnType) ? null : PopOperand();              statement = new Return(retVal);               transferStatement = true; goto done;            case OpCode.Br_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false); transferStatement = true; goto done;            case OpCode.Brfalse_S: statement = this.ParseBranch(NodeType.LogicalNot' 1' true' false); transferStatement = true; goto done;            case OpCode.Brtrue_S: statement = this.ParseBranch(NodeType.Nop' 1' true' false); transferStatement = true; goto done;            case OpCode.Beq_S: statement = this.ParseBranch(NodeType.Eq' 2' true' false); transferStatement = true; goto done;            case OpCode.Bge_S: statement = this.ParseBranch(NodeType.Ge' 2' true' false); transferStatement = true; goto done;            case OpCode.Bgt_S: statement = this.ParseBranch(NodeType.Gt' 2' true' false); transferStatement = true; goto done;            case OpCode.Ble_S: statement = this.ParseBranch(NodeType.Le' 2' true' false); transferStatement = true; goto done;            case OpCode.Blt_S: statement = this.ParseBranch(NodeType.Lt' 2' true' false); transferStatement = true; goto done;            case OpCode.Bne_Un_S: statement = this.ParseBranch(NodeType.Ne' 2' true' true); transferStatement = true; goto done;            case OpCode.Bge_Un_S: statement = this.ParseBranch(NodeType.Ge' 2' true' true); transferStatement = true; goto done;            case OpCode.Bgt_Un_S: statement = this.ParseBranch(NodeType.Gt' 2' true' true); transferStatement = true; goto done;            case OpCode.Ble_Un_S: statement = this.ParseBranch(NodeType.Le' 2' true' true); transferStatement = true; goto done;            case OpCode.Blt_Un_S: statement = this.ParseBranch(NodeType.Lt' 2' true' true); transferStatement = true; goto done;            case OpCode.Br: statement = this.ParseBranch(NodeType.Nop' 0' false' false); transferStatement = true; goto done;            case OpCode.Brfalse: statement = this.ParseBranch(NodeType.LogicalNot' 1' false' false); transferStatement = true; goto done;            case OpCode.Brtrue: statement = this.ParseBranch(NodeType.Nop' 1' false' false); transferStatement = true; goto done;            case OpCode.Beq: statement = this.ParseBranch(NodeType.Eq' 2' false' false); transferStatement = true; goto done;            case OpCode.Bge: statement = this.ParseBranch(NodeType.Ge' 2' false' false); transferStatement = true; goto done;            case OpCode.Bgt: statement = this.ParseBranch(NodeType.Gt' 2' false' false); transferStatement = true; goto done;            case OpCode.Ble: statement = this.ParseBranch(NodeType.Le' 2' false' false); transferStatement = true; goto done;            case OpCode.Blt: statement = this.ParseBranch(NodeType.Lt' 2' false' false); transferStatement = true; goto done;            case OpCode.Bne_Un: statement = this.ParseBranch(NodeType.Ne' 2' false' true); transferStatement = true; goto done;            case OpCode.Bge_Un: statement = this.ParseBranch(NodeType.Ge' 2' false' true); transferStatement = true; goto done;            case OpCode.Bgt_Un: statement = this.ParseBranch(NodeType.Gt' 2' false' true); transferStatement = true; goto done;            case OpCode.Ble_Un: statement = this.ParseBranch(NodeType.Le' 2' false' true); transferStatement = true; goto done;            case OpCode.Blt_Un: statement = this.ParseBranch(NodeType.Lt' 2' false' true); transferStatement = true; goto done;            case OpCode.Switch: statement = this.ParseSwitchInstruction(); transferStatement = true; goto done;            case OpCode.Ldind_I1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int64' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I: expr = new AddressDereference(PopOperand()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Single' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Double' this.isVolatile' this.alignment); break;            case OpCode.Ldind_Ref: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Object' this.isVolatile' this.alignment); break;            case OpCode.Stind_Ref: statement = this.ParseStoreIndirect(CoreSystemTypes.Object); goto done;            case OpCode.Stind_I1: statement = this.ParseStoreIndirect(CoreSystemTypes.Int8); goto done;            case OpCode.Stind_I2: statement = this.ParseStoreIndirect(CoreSystemTypes.Int16); goto done;            case OpCode.Stind_I4: statement = this.ParseStoreIndirect(CoreSystemTypes.Int32); goto done;            case OpCode.Stind_I8: statement = this.ParseStoreIndirect(CoreSystemTypes.Int64); goto done;            case OpCode.Stind_R4: statement = this.ParseStoreIndirect(CoreSystemTypes.Single); goto done;            case OpCode.Stind_R8: statement = this.ParseStoreIndirect(CoreSystemTypes.Double); goto done;            case OpCode.Add: expr = this.ParseBinaryOperation(NodeType.Add); break;            case OpCode.Sub: expr = this.ParseBinaryOperation(NodeType.Sub); break;            case OpCode.Mul: expr = this.ParseBinaryOperation(NodeType.Mul); break;            case OpCode.Div: expr = this.ParseBinaryOperation(NodeType.Div); break;            case OpCode.Div_Un: expr = this.ParseBinaryOperation(NodeType.Div_Un); break;            case OpCode.Rem: expr = this.ParseBinaryOperation(NodeType.Rem); break;            case OpCode.Rem_Un: expr = this.ParseBinaryOperation(NodeType.Rem_Un); break;            case OpCode.And: expr = this.ParseBinaryOperation(NodeType.And); break;            case OpCode.Or: expr = this.ParseBinaryOperation(NodeType.Or); break;            case OpCode.Xor: expr = this.ParseBinaryOperation(NodeType.Xor); break;            case OpCode.Shl: expr = this.ParseBinaryOperation(NodeType.Shl); break;            case OpCode.Shr: expr = this.ParseBinaryOperation(NodeType.Shr); break;            case OpCode.Shr_Un: expr = this.ParseBinaryOperation(NodeType.Shr_Un); break;            case OpCode.Neg: expr = this.ParseUnaryOperation(NodeType.Neg); break;            case OpCode.Not: expr = this.ParseUnaryOperation(NodeType.Not); break;            case OpCode.Conv_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_R4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R4' CoreSystemTypes.Single); break;            case OpCode.Conv_R8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R8' CoreSystemTypes.Double); break;            case OpCode.Conv_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U8' CoreSystemTypes.UInt64); break;            case OpCode.Callvirt: expr = this.ParseCall(NodeType.Callvirt' out isStatement); if (isStatement) goto done; break;            case OpCode.Cpobj: statement = this.ParseCopyObject(); goto done;            case OpCode.Ldobj: expr = new AddressDereference(PopOperand()' (TypeNode)this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldstr: expr = new Literal(this.GetStringFromToken()' CoreSystemTypes.String); break;            case OpCode.Newobj: expr = this.ParseConstruct(); break;            case OpCode.Castclass: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Castclass); break;            case OpCode.Isinst: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Isinst); break;            case OpCode.Conv_R_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R_Un' CoreSystemTypes.Double); break;            case OpCode.Unbox: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Unbox); break;            case OpCode.Throw: statement = new Throw(PopOperand()); transferStatement = true; goto done;            case OpCode.Ldfld:               expr = new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment);              break;            case OpCode.Ldflda:               expr = SetType(new UnaryExpression(new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf));               break;            case OpCode.Stfld: statement = this.ParseStoreField(); goto done;            case OpCode.Ldsfld: expr = new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldsflda: expr = SetType(new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf)); break;            case OpCode.Stsfld: statement = new AssignmentStatement(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' PopOperand()); goto done;            case OpCode.Stobj: statement = this.ParseStoreIndirect((TypeNode)this.GetMemberFromToken()); goto done;            case OpCode.Conv_Ovf_I1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_I2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_I4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_I8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_U2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_U4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_U8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64); break;            case OpCode.Conv_Ovf_I_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr); break;            case OpCode.Box:               TypeNode t = (TypeNode)this.GetMemberFromToken();              TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;              expr = new BinaryExpression(PopOperand()' new Literal(t' CoreSystemTypes.Type)' NodeType.Box' bt); break;            case OpCode.Newarr: expr = this.ParseNewArray(); break;            case OpCode.Ldlen: expr = new UnaryExpression(PopOperand()' NodeType.Ldlen' CoreSystemTypes.UIntPtr); break;            case OpCode.Ldelema: expr = this.ParseArrayElementLoadAddress(); break;            case OpCode.Ldelem_I1:             case OpCode.Ldelem_U1:             case OpCode.Ldelem_I2:             case OpCode.Ldelem_U2:             case OpCode.Ldelem_I4:             case OpCode.Ldelem_U4:             case OpCode.Ldelem_I8:             case OpCode.Ldelem_I:             case OpCode.Ldelem_R4:             case OpCode.Ldelem_R8:             case OpCode.Ldelem_Ref: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem_I:            case OpCode.Stelem_I1:            case OpCode.Stelem_I2:            case OpCode.Stelem_I4:            case OpCode.Stelem_I8:            case OpCode.Stelem_R4:            case OpCode.Stelem_R8:            case OpCode.Stelem_Ref: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Ldelem: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Unbox_Any: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.UnboxAny); break;            case OpCode.Conv_Ovf_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64); break;            case OpCode.Refanyval: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr); break;            case OpCode.Ckfinite: expr = this.ParseUnaryOperation(NodeType.Ckfinite); break;            case OpCode.Mkrefany: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference); break;            case OpCode.Ldtoken: expr = ParseLoadRuntimeMetadataToken(); break;            case OpCode.Conv_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Add_Ovf: expr = this.ParseBinaryOperation(NodeType.Add_Ovf); break;            case OpCode.Add_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Add_Ovf_Un); break;            case OpCode.Mul_Ovf: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf); break;            case OpCode.Mul_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf_Un); break;            case OpCode.Sub_Ovf: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf); break;            case OpCode.Sub_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf_Un); break;            case OpCode.Endfinally: statement = new EndFinally(); transferStatement = true; goto done;            case OpCode.Leave: statement = this.ParseBranch(NodeType.Nop' 0' false' false' true); transferStatement = true; goto done;            case OpCode.Leave_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false' true); transferStatement = true; goto done;            case OpCode.Stind_I: statement = this.ParseStoreIndirect(CoreSystemTypes.IntPtr); goto done;            case OpCode.Conv_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Arglist: expr = new Expression(NodeType.Arglist' CoreSystemTypes.ArgIterator); break;            case OpCode.Ceq: expr = this.ParseBinaryComparison(NodeType.Ceq); break;            case OpCode.Cgt: expr = this.ParseBinaryComparison(NodeType.Cgt); break;            case OpCode.Cgt_Un: expr = this.ParseBinaryComparison(NodeType.Cgt_Un); break;            case OpCode.Clt: expr = this.ParseBinaryComparison(NodeType.Clt); break;            case OpCode.Clt_Un: expr = this.ParseBinaryComparison(NodeType.Clt_Un); break;            case OpCode.Ldftn: expr = new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldvirtftn: expr = new BinaryExpression(PopOperand()' new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldarg: expr = this.Parameters((ushort)this.GetInt16()); break;            case OpCode.Ldarga: expr = SetType(new UnaryExpression(this.Parameters((ushort)this.GetInt16())' NodeType.AddressOf)); break;            case OpCode.Starg: statement = new AssignmentStatement(this.Parameters((ushort)this.GetInt16())' PopOperand()); goto done;            case OpCode.Ldloc: expr = this.locals[(ushort)this.GetInt16()]; break;            case OpCode.Ldloca: expr = SetType(new UnaryExpression(this.locals[(ushort)this.GetInt16()]' NodeType.AddressOf)); break;            case OpCode.Stloc: statement = new AssignmentStatement(this.locals[(ushort)this.GetInt16()]' PopOperand()); goto done;            case OpCode.Localloc: expr = new UnaryExpression(PopOperand()' NodeType.Localloc' CoreSystemTypes.Void); break;            case OpCode.Endfilter: statement = new EndFilter(PopOperand()); transferStatement = true; goto done;            case OpCode.Unaligned_: this.alignment = this.GetByte(); continue;            case OpCode.Volatile_: this.isVolatile = true; continue;            case OpCode.Tail_: this.isTailCall = true; continue;            case OpCode.Initobj: statement = this.ParseInitObject(); goto done;            case OpCode.Constrained_: this.constraint = this.GetMemberFromToken() as TypeNode; continue;            case OpCode.Cpblk: expr = this.ParseTernaryOperation(NodeType.Cpblk); goto done;            case OpCode.Initblk: expr = this.ParseTernaryOperation(NodeType.Initblk); goto done;            case OpCode.Rethrow: statement = new Throw(null); statement.NodeType = NodeType.Rethrow; transferStatement = true; goto done;            case OpCode.Sizeof: expr = new UnaryExpression(new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32); break;            case OpCode.Refanytype: expr = new UnaryExpression(PopOperand()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle); break;            case OpCode.Readonly_: this.isReadOnly = true; continue;            default: throw new InvalidMetadataException(ExceptionStrings.UnknownOpCode);          }          if (this.blockMap[this.counter+1] != null){            transferStatement = true; //Falls through to the next basic block' so implicitly a "transfer" statement            goto done;          }          //^ assume expr != null;  #if FxCop          expr.sourceContext = sourceContext;  #endif  #if FxCop || ILOFFSETS          expr.ILOffset = this.ilOffset;  #endif          this.operandStack.Push(expr);          this.isReadOnly = false;          this.isVolatile = false;          this.isTailCall = false;                  this.alignment = -1;        }
Magic Number,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true){          bool isStatement = false;          startingAddress = this.counter+1; //Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  #if FxCop || ILOFFSETS          this.ilOffset = this.counter;          this.opCode = this.GetOpCode();  #else          OpCode opCode = this.GetOpCode();  #endif  #if FxCop          if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){            expr.sourceContext = sourceContext;            expr.ILOffset = this.ilOffset;            this.operandStack.Push(expr);          }  #endif          switch (opCode){            case OpCode.Nop: statement = new Statement(NodeType.Nop); goto done;            case OpCode.Break: statement = new Statement(NodeType.DebugBreak); goto done;            case OpCode.Ldarg_0: expr = this.Parameters(0); break;            case OpCode.Ldarg_1: expr = this.Parameters(1); break;            case OpCode.Ldarg_2: expr = this.Parameters(2); break;            case OpCode.Ldarg_3: expr = this.Parameters(3); break;            case OpCode.Ldloc_0: expr = this.locals[0]; break;            case OpCode.Ldloc_1: expr = this.locals[1]; break;            case OpCode.Ldloc_2: expr = this.locals[2]; break;            case OpCode.Ldloc_3: expr = this.locals[3]; break;            case OpCode.Stloc_0: statement = new AssignmentStatement(this.locals[0]' PopOperand()); goto done;            case OpCode.Stloc_1: statement = new AssignmentStatement(this.locals[1]' PopOperand()); goto done;            case OpCode.Stloc_2: statement = new AssignmentStatement(this.locals[2]' PopOperand()); goto done;            case OpCode.Stloc_3: statement = new AssignmentStatement(this.locals[3]' PopOperand()); goto done;            case OpCode.Ldarg_S: expr = this.Parameters(this.GetByte()); break;            case OpCode.Ldarga_S: expr = SetType(new UnaryExpression(this.Parameters(this.GetByte())' NodeType.AddressOf)); break;            case OpCode.Starg_S: statement = new AssignmentStatement(this.Parameters(this.GetByte())' PopOperand()); goto done;            case OpCode.Ldloc_S: expr = this.locals[this.GetByte()]; break;            case OpCode.Ldloca_S: expr = SetType(new UnaryExpression(this.locals[this.GetByte()]' NodeType.AddressOf)); break;            case OpCode.Stloc_S: statement = new AssignmentStatement(this.locals[this.GetByte()]' PopOperand()); goto done;            case OpCode.Ldnull: expr = new Literal(null' CoreSystemTypes.Object); break;            case OpCode.Ldc_I4_M1: expr = new Literal(-1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_0: expr = new Literal(0' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_1: expr = new Literal(1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_2: expr = new Literal(2' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_3: expr = new Literal(3' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_4: expr = new Literal(4' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_5: expr = new Literal(5' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_6: expr = new Literal(6' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_7: expr = new Literal(7' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_8: expr = new Literal(8' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_S: expr = new Literal((int)this.GetSByte()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4: expr = new Literal(this.GetInt32()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I8: expr = new Literal(this.GetInt64()' CoreSystemTypes.Int64); break;            case OpCode.Ldc_R4: expr = new Literal(this.GetSingle()' CoreSystemTypes.Single); break;            case OpCode.Ldc_R8: expr = new Literal(this.GetDouble()' CoreSystemTypes.Double); break;            case OpCode.Dup: statement = new ExpressionStatement(new Expression(NodeType.Dup)); goto done;            case OpCode.Pop: statement = new ExpressionStatement(new UnaryExpression(PopOperand()' NodeType.Pop)); goto done;            case OpCode.Jmp: expr = this.ParseCall(NodeType.Jmp' out isStatement); if (isStatement) goto done; break;            case OpCode.Call: expr = this.ParseCall(NodeType.Call' out isStatement); if (isStatement) goto done; break;            case OpCode.Calli: expr = this.ParseCalli(out isStatement); if (isStatement) goto done; break;            case OpCode.Ret:              Expression retVal = BodyParser.TypeIsVoid(this.method.ReturnType) ? null : PopOperand();              statement = new Return(retVal);               transferStatement = true; goto done;            case OpCode.Br_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false); transferStatement = true; goto done;            case OpCode.Brfalse_S: statement = this.ParseBranch(NodeType.LogicalNot' 1' true' false); transferStatement = true; goto done;            case OpCode.Brtrue_S: statement = this.ParseBranch(NodeType.Nop' 1' true' false); transferStatement = true; goto done;            case OpCode.Beq_S: statement = this.ParseBranch(NodeType.Eq' 2' true' false); transferStatement = true; goto done;            case OpCode.Bge_S: statement = this.ParseBranch(NodeType.Ge' 2' true' false); transferStatement = true; goto done;            case OpCode.Bgt_S: statement = this.ParseBranch(NodeType.Gt' 2' true' false); transferStatement = true; goto done;            case OpCode.Ble_S: statement = this.ParseBranch(NodeType.Le' 2' true' false); transferStatement = true; goto done;            case OpCode.Blt_S: statement = this.ParseBranch(NodeType.Lt' 2' true' false); transferStatement = true; goto done;            case OpCode.Bne_Un_S: statement = this.ParseBranch(NodeType.Ne' 2' true' true); transferStatement = true; goto done;            case OpCode.Bge_Un_S: statement = this.ParseBranch(NodeType.Ge' 2' true' true); transferStatement = true; goto done;            case OpCode.Bgt_Un_S: statement = this.ParseBranch(NodeType.Gt' 2' true' true); transferStatement = true; goto done;            case OpCode.Ble_Un_S: statement = this.ParseBranch(NodeType.Le' 2' true' true); transferStatement = true; goto done;            case OpCode.Blt_Un_S: statement = this.ParseBranch(NodeType.Lt' 2' true' true); transferStatement = true; goto done;            case OpCode.Br: statement = this.ParseBranch(NodeType.Nop' 0' false' false); transferStatement = true; goto done;            case OpCode.Brfalse: statement = this.ParseBranch(NodeType.LogicalNot' 1' false' false); transferStatement = true; goto done;            case OpCode.Brtrue: statement = this.ParseBranch(NodeType.Nop' 1' false' false); transferStatement = true; goto done;            case OpCode.Beq: statement = this.ParseBranch(NodeType.Eq' 2' false' false); transferStatement = true; goto done;            case OpCode.Bge: statement = this.ParseBranch(NodeType.Ge' 2' false' false); transferStatement = true; goto done;            case OpCode.Bgt: statement = this.ParseBranch(NodeType.Gt' 2' false' false); transferStatement = true; goto done;            case OpCode.Ble: statement = this.ParseBranch(NodeType.Le' 2' false' false); transferStatement = true; goto done;            case OpCode.Blt: statement = this.ParseBranch(NodeType.Lt' 2' false' false); transferStatement = true; goto done;            case OpCode.Bne_Un: statement = this.ParseBranch(NodeType.Ne' 2' false' true); transferStatement = true; goto done;            case OpCode.Bge_Un: statement = this.ParseBranch(NodeType.Ge' 2' false' true); transferStatement = true; goto done;            case OpCode.Bgt_Un: statement = this.ParseBranch(NodeType.Gt' 2' false' true); transferStatement = true; goto done;            case OpCode.Ble_Un: statement = this.ParseBranch(NodeType.Le' 2' false' true); transferStatement = true; goto done;            case OpCode.Blt_Un: statement = this.ParseBranch(NodeType.Lt' 2' false' true); transferStatement = true; goto done;            case OpCode.Switch: statement = this.ParseSwitchInstruction(); transferStatement = true; goto done;            case OpCode.Ldind_I1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int64' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I: expr = new AddressDereference(PopOperand()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Single' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Double' this.isVolatile' this.alignment); break;            case OpCode.Ldind_Ref: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Object' this.isVolatile' this.alignment); break;            case OpCode.Stind_Ref: statement = this.ParseStoreIndirect(CoreSystemTypes.Object); goto done;            case OpCode.Stind_I1: statement = this.ParseStoreIndirect(CoreSystemTypes.Int8); goto done;            case OpCode.Stind_I2: statement = this.ParseStoreIndirect(CoreSystemTypes.Int16); goto done;            case OpCode.Stind_I4: statement = this.ParseStoreIndirect(CoreSystemTypes.Int32); goto done;            case OpCode.Stind_I8: statement = this.ParseStoreIndirect(CoreSystemTypes.Int64); goto done;            case OpCode.Stind_R4: statement = this.ParseStoreIndirect(CoreSystemTypes.Single); goto done;            case OpCode.Stind_R8: statement = this.ParseStoreIndirect(CoreSystemTypes.Double); goto done;            case OpCode.Add: expr = this.ParseBinaryOperation(NodeType.Add); break;            case OpCode.Sub: expr = this.ParseBinaryOperation(NodeType.Sub); break;            case OpCode.Mul: expr = this.ParseBinaryOperation(NodeType.Mul); break;            case OpCode.Div: expr = this.ParseBinaryOperation(NodeType.Div); break;            case OpCode.Div_Un: expr = this.ParseBinaryOperation(NodeType.Div_Un); break;            case OpCode.Rem: expr = this.ParseBinaryOperation(NodeType.Rem); break;            case OpCode.Rem_Un: expr = this.ParseBinaryOperation(NodeType.Rem_Un); break;            case OpCode.And: expr = this.ParseBinaryOperation(NodeType.And); break;            case OpCode.Or: expr = this.ParseBinaryOperation(NodeType.Or); break;            case OpCode.Xor: expr = this.ParseBinaryOperation(NodeType.Xor); break;            case OpCode.Shl: expr = this.ParseBinaryOperation(NodeType.Shl); break;            case OpCode.Shr: expr = this.ParseBinaryOperation(NodeType.Shr); break;            case OpCode.Shr_Un: expr = this.ParseBinaryOperation(NodeType.Shr_Un); break;            case OpCode.Neg: expr = this.ParseUnaryOperation(NodeType.Neg); break;            case OpCode.Not: expr = this.ParseUnaryOperation(NodeType.Not); break;            case OpCode.Conv_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_R4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R4' CoreSystemTypes.Single); break;            case OpCode.Conv_R8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R8' CoreSystemTypes.Double); break;            case OpCode.Conv_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U8' CoreSystemTypes.UInt64); break;            case OpCode.Callvirt: expr = this.ParseCall(NodeType.Callvirt' out isStatement); if (isStatement) goto done; break;            case OpCode.Cpobj: statement = this.ParseCopyObject(); goto done;            case OpCode.Ldobj: expr = new AddressDereference(PopOperand()' (TypeNode)this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldstr: expr = new Literal(this.GetStringFromToken()' CoreSystemTypes.String); break;            case OpCode.Newobj: expr = this.ParseConstruct(); break;            case OpCode.Castclass: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Castclass); break;            case OpCode.Isinst: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Isinst); break;            case OpCode.Conv_R_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R_Un' CoreSystemTypes.Double); break;            case OpCode.Unbox: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Unbox); break;            case OpCode.Throw: statement = new Throw(PopOperand()); transferStatement = true; goto done;            case OpCode.Ldfld:               expr = new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment);              break;            case OpCode.Ldflda:               expr = SetType(new UnaryExpression(new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf));               break;            case OpCode.Stfld: statement = this.ParseStoreField(); goto done;            case OpCode.Ldsfld: expr = new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldsflda: expr = SetType(new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf)); break;            case OpCode.Stsfld: statement = new AssignmentStatement(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' PopOperand()); goto done;            case OpCode.Stobj: statement = this.ParseStoreIndirect((TypeNode)this.GetMemberFromToken()); goto done;            case OpCode.Conv_Ovf_I1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_I2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_I4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_I8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_U2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_U4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_U8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64); break;            case OpCode.Conv_Ovf_I_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr); break;            case OpCode.Box:               TypeNode t = (TypeNode)this.GetMemberFromToken();              TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;              expr = new BinaryExpression(PopOperand()' new Literal(t' CoreSystemTypes.Type)' NodeType.Box' bt); break;            case OpCode.Newarr: expr = this.ParseNewArray(); break;            case OpCode.Ldlen: expr = new UnaryExpression(PopOperand()' NodeType.Ldlen' CoreSystemTypes.UIntPtr); break;            case OpCode.Ldelema: expr = this.ParseArrayElementLoadAddress(); break;            case OpCode.Ldelem_I1:             case OpCode.Ldelem_U1:             case OpCode.Ldelem_I2:             case OpCode.Ldelem_U2:             case OpCode.Ldelem_I4:             case OpCode.Ldelem_U4:             case OpCode.Ldelem_I8:             case OpCode.Ldelem_I:             case OpCode.Ldelem_R4:             case OpCode.Ldelem_R8:             case OpCode.Ldelem_Ref: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem_I:            case OpCode.Stelem_I1:            case OpCode.Stelem_I2:            case OpCode.Stelem_I4:            case OpCode.Stelem_I8:            case OpCode.Stelem_R4:            case OpCode.Stelem_R8:            case OpCode.Stelem_Ref: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Ldelem: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Unbox_Any: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.UnboxAny); break;            case OpCode.Conv_Ovf_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64); break;            case OpCode.Refanyval: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr); break;            case OpCode.Ckfinite: expr = this.ParseUnaryOperation(NodeType.Ckfinite); break;            case OpCode.Mkrefany: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference); break;            case OpCode.Ldtoken: expr = ParseLoadRuntimeMetadataToken(); break;            case OpCode.Conv_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Add_Ovf: expr = this.ParseBinaryOperation(NodeType.Add_Ovf); break;            case OpCode.Add_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Add_Ovf_Un); break;            case OpCode.Mul_Ovf: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf); break;            case OpCode.Mul_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf_Un); break;            case OpCode.Sub_Ovf: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf); break;            case OpCode.Sub_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf_Un); break;            case OpCode.Endfinally: statement = new EndFinally(); transferStatement = true; goto done;            case OpCode.Leave: statement = this.ParseBranch(NodeType.Nop' 0' false' false' true); transferStatement = true; goto done;            case OpCode.Leave_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false' true); transferStatement = true; goto done;            case OpCode.Stind_I: statement = this.ParseStoreIndirect(CoreSystemTypes.IntPtr); goto done;            case OpCode.Conv_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Arglist: expr = new Expression(NodeType.Arglist' CoreSystemTypes.ArgIterator); break;            case OpCode.Ceq: expr = this.ParseBinaryComparison(NodeType.Ceq); break;            case OpCode.Cgt: expr = this.ParseBinaryComparison(NodeType.Cgt); break;            case OpCode.Cgt_Un: expr = this.ParseBinaryComparison(NodeType.Cgt_Un); break;            case OpCode.Clt: expr = this.ParseBinaryComparison(NodeType.Clt); break;            case OpCode.Clt_Un: expr = this.ParseBinaryComparison(NodeType.Clt_Un); break;            case OpCode.Ldftn: expr = new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldvirtftn: expr = new BinaryExpression(PopOperand()' new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldarg: expr = this.Parameters((ushort)this.GetInt16()); break;            case OpCode.Ldarga: expr = SetType(new UnaryExpression(this.Parameters((ushort)this.GetInt16())' NodeType.AddressOf)); break;            case OpCode.Starg: statement = new AssignmentStatement(this.Parameters((ushort)this.GetInt16())' PopOperand()); goto done;            case OpCode.Ldloc: expr = this.locals[(ushort)this.GetInt16()]; break;            case OpCode.Ldloca: expr = SetType(new UnaryExpression(this.locals[(ushort)this.GetInt16()]' NodeType.AddressOf)); break;            case OpCode.Stloc: statement = new AssignmentStatement(this.locals[(ushort)this.GetInt16()]' PopOperand()); goto done;            case OpCode.Localloc: expr = new UnaryExpression(PopOperand()' NodeType.Localloc' CoreSystemTypes.Void); break;            case OpCode.Endfilter: statement = new EndFilter(PopOperand()); transferStatement = true; goto done;            case OpCode.Unaligned_: this.alignment = this.GetByte(); continue;            case OpCode.Volatile_: this.isVolatile = true; continue;            case OpCode.Tail_: this.isTailCall = true; continue;            case OpCode.Initobj: statement = this.ParseInitObject(); goto done;            case OpCode.Constrained_: this.constraint = this.GetMemberFromToken() as TypeNode; continue;            case OpCode.Cpblk: expr = this.ParseTernaryOperation(NodeType.Cpblk); goto done;            case OpCode.Initblk: expr = this.ParseTernaryOperation(NodeType.Initblk); goto done;            case OpCode.Rethrow: statement = new Throw(null); statement.NodeType = NodeType.Rethrow; transferStatement = true; goto done;            case OpCode.Sizeof: expr = new UnaryExpression(new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32); break;            case OpCode.Refanytype: expr = new UnaryExpression(PopOperand()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle); break;            case OpCode.Readonly_: this.isReadOnly = true; continue;            default: throw new InvalidMetadataException(ExceptionStrings.UnknownOpCode);          }          if (this.blockMap[this.counter+1] != null){            transferStatement = true; //Falls through to the next basic block' so implicitly a "transfer" statement            goto done;          }          //^ assume expr != null;  #if FxCop          expr.sourceContext = sourceContext;  #endif  #if FxCop || ILOFFSETS          expr.ILOffset = this.ilOffset;  #endif          this.operandStack.Push(expr);          this.isReadOnly = false;          this.isVolatile = false;          this.isTailCall = false;                  this.alignment = -1;        }
Magic Number,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true){          bool isStatement = false;          startingAddress = this.counter+1; //Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  #if FxCop || ILOFFSETS          this.ilOffset = this.counter;          this.opCode = this.GetOpCode();  #else          OpCode opCode = this.GetOpCode();  #endif  #if FxCop          if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){            expr.sourceContext = sourceContext;            expr.ILOffset = this.ilOffset;            this.operandStack.Push(expr);          }  #endif          switch (opCode){            case OpCode.Nop: statement = new Statement(NodeType.Nop); goto done;            case OpCode.Break: statement = new Statement(NodeType.DebugBreak); goto done;            case OpCode.Ldarg_0: expr = this.Parameters(0); break;            case OpCode.Ldarg_1: expr = this.Parameters(1); break;            case OpCode.Ldarg_2: expr = this.Parameters(2); break;            case OpCode.Ldarg_3: expr = this.Parameters(3); break;            case OpCode.Ldloc_0: expr = this.locals[0]; break;            case OpCode.Ldloc_1: expr = this.locals[1]; break;            case OpCode.Ldloc_2: expr = this.locals[2]; break;            case OpCode.Ldloc_3: expr = this.locals[3]; break;            case OpCode.Stloc_0: statement = new AssignmentStatement(this.locals[0]' PopOperand()); goto done;            case OpCode.Stloc_1: statement = new AssignmentStatement(this.locals[1]' PopOperand()); goto done;            case OpCode.Stloc_2: statement = new AssignmentStatement(this.locals[2]' PopOperand()); goto done;            case OpCode.Stloc_3: statement = new AssignmentStatement(this.locals[3]' PopOperand()); goto done;            case OpCode.Ldarg_S: expr = this.Parameters(this.GetByte()); break;            case OpCode.Ldarga_S: expr = SetType(new UnaryExpression(this.Parameters(this.GetByte())' NodeType.AddressOf)); break;            case OpCode.Starg_S: statement = new AssignmentStatement(this.Parameters(this.GetByte())' PopOperand()); goto done;            case OpCode.Ldloc_S: expr = this.locals[this.GetByte()]; break;            case OpCode.Ldloca_S: expr = SetType(new UnaryExpression(this.locals[this.GetByte()]' NodeType.AddressOf)); break;            case OpCode.Stloc_S: statement = new AssignmentStatement(this.locals[this.GetByte()]' PopOperand()); goto done;            case OpCode.Ldnull: expr = new Literal(null' CoreSystemTypes.Object); break;            case OpCode.Ldc_I4_M1: expr = new Literal(-1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_0: expr = new Literal(0' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_1: expr = new Literal(1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_2: expr = new Literal(2' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_3: expr = new Literal(3' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_4: expr = new Literal(4' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_5: expr = new Literal(5' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_6: expr = new Literal(6' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_7: expr = new Literal(7' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_8: expr = new Literal(8' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_S: expr = new Literal((int)this.GetSByte()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4: expr = new Literal(this.GetInt32()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I8: expr = new Literal(this.GetInt64()' CoreSystemTypes.Int64); break;            case OpCode.Ldc_R4: expr = new Literal(this.GetSingle()' CoreSystemTypes.Single); break;            case OpCode.Ldc_R8: expr = new Literal(this.GetDouble()' CoreSystemTypes.Double); break;            case OpCode.Dup: statement = new ExpressionStatement(new Expression(NodeType.Dup)); goto done;            case OpCode.Pop: statement = new ExpressionStatement(new UnaryExpression(PopOperand()' NodeType.Pop)); goto done;            case OpCode.Jmp: expr = this.ParseCall(NodeType.Jmp' out isStatement); if (isStatement) goto done; break;            case OpCode.Call: expr = this.ParseCall(NodeType.Call' out isStatement); if (isStatement) goto done; break;            case OpCode.Calli: expr = this.ParseCalli(out isStatement); if (isStatement) goto done; break;            case OpCode.Ret:              Expression retVal = BodyParser.TypeIsVoid(this.method.ReturnType) ? null : PopOperand();              statement = new Return(retVal);               transferStatement = true; goto done;            case OpCode.Br_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false); transferStatement = true; goto done;            case OpCode.Brfalse_S: statement = this.ParseBranch(NodeType.LogicalNot' 1' true' false); transferStatement = true; goto done;            case OpCode.Brtrue_S: statement = this.ParseBranch(NodeType.Nop' 1' true' false); transferStatement = true; goto done;            case OpCode.Beq_S: statement = this.ParseBranch(NodeType.Eq' 2' true' false); transferStatement = true; goto done;            case OpCode.Bge_S: statement = this.ParseBranch(NodeType.Ge' 2' true' false); transferStatement = true; goto done;            case OpCode.Bgt_S: statement = this.ParseBranch(NodeType.Gt' 2' true' false); transferStatement = true; goto done;            case OpCode.Ble_S: statement = this.ParseBranch(NodeType.Le' 2' true' false); transferStatement = true; goto done;            case OpCode.Blt_S: statement = this.ParseBranch(NodeType.Lt' 2' true' false); transferStatement = true; goto done;            case OpCode.Bne_Un_S: statement = this.ParseBranch(NodeType.Ne' 2' true' true); transferStatement = true; goto done;            case OpCode.Bge_Un_S: statement = this.ParseBranch(NodeType.Ge' 2' true' true); transferStatement = true; goto done;            case OpCode.Bgt_Un_S: statement = this.ParseBranch(NodeType.Gt' 2' true' true); transferStatement = true; goto done;            case OpCode.Ble_Un_S: statement = this.ParseBranch(NodeType.Le' 2' true' true); transferStatement = true; goto done;            case OpCode.Blt_Un_S: statement = this.ParseBranch(NodeType.Lt' 2' true' true); transferStatement = true; goto done;            case OpCode.Br: statement = this.ParseBranch(NodeType.Nop' 0' false' false); transferStatement = true; goto done;            case OpCode.Brfalse: statement = this.ParseBranch(NodeType.LogicalNot' 1' false' false); transferStatement = true; goto done;            case OpCode.Brtrue: statement = this.ParseBranch(NodeType.Nop' 1' false' false); transferStatement = true; goto done;            case OpCode.Beq: statement = this.ParseBranch(NodeType.Eq' 2' false' false); transferStatement = true; goto done;            case OpCode.Bge: statement = this.ParseBranch(NodeType.Ge' 2' false' false); transferStatement = true; goto done;            case OpCode.Bgt: statement = this.ParseBranch(NodeType.Gt' 2' false' false); transferStatement = true; goto done;            case OpCode.Ble: statement = this.ParseBranch(NodeType.Le' 2' false' false); transferStatement = true; goto done;            case OpCode.Blt: statement = this.ParseBranch(NodeType.Lt' 2' false' false); transferStatement = true; goto done;            case OpCode.Bne_Un: statement = this.ParseBranch(NodeType.Ne' 2' false' true); transferStatement = true; goto done;            case OpCode.Bge_Un: statement = this.ParseBranch(NodeType.Ge' 2' false' true); transferStatement = true; goto done;            case OpCode.Bgt_Un: statement = this.ParseBranch(NodeType.Gt' 2' false' true); transferStatement = true; goto done;            case OpCode.Ble_Un: statement = this.ParseBranch(NodeType.Le' 2' false' true); transferStatement = true; goto done;            case OpCode.Blt_Un: statement = this.ParseBranch(NodeType.Lt' 2' false' true); transferStatement = true; goto done;            case OpCode.Switch: statement = this.ParseSwitchInstruction(); transferStatement = true; goto done;            case OpCode.Ldind_I1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int64' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I: expr = new AddressDereference(PopOperand()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Single' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Double' this.isVolatile' this.alignment); break;            case OpCode.Ldind_Ref: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Object' this.isVolatile' this.alignment); break;            case OpCode.Stind_Ref: statement = this.ParseStoreIndirect(CoreSystemTypes.Object); goto done;            case OpCode.Stind_I1: statement = this.ParseStoreIndirect(CoreSystemTypes.Int8); goto done;            case OpCode.Stind_I2: statement = this.ParseStoreIndirect(CoreSystemTypes.Int16); goto done;            case OpCode.Stind_I4: statement = this.ParseStoreIndirect(CoreSystemTypes.Int32); goto done;            case OpCode.Stind_I8: statement = this.ParseStoreIndirect(CoreSystemTypes.Int64); goto done;            case OpCode.Stind_R4: statement = this.ParseStoreIndirect(CoreSystemTypes.Single); goto done;            case OpCode.Stind_R8: statement = this.ParseStoreIndirect(CoreSystemTypes.Double); goto done;            case OpCode.Add: expr = this.ParseBinaryOperation(NodeType.Add); break;            case OpCode.Sub: expr = this.ParseBinaryOperation(NodeType.Sub); break;            case OpCode.Mul: expr = this.ParseBinaryOperation(NodeType.Mul); break;            case OpCode.Div: expr = this.ParseBinaryOperation(NodeType.Div); break;            case OpCode.Div_Un: expr = this.ParseBinaryOperation(NodeType.Div_Un); break;            case OpCode.Rem: expr = this.ParseBinaryOperation(NodeType.Rem); break;            case OpCode.Rem_Un: expr = this.ParseBinaryOperation(NodeType.Rem_Un); break;            case OpCode.And: expr = this.ParseBinaryOperation(NodeType.And); break;            case OpCode.Or: expr = this.ParseBinaryOperation(NodeType.Or); break;            case OpCode.Xor: expr = this.ParseBinaryOperation(NodeType.Xor); break;            case OpCode.Shl: expr = this.ParseBinaryOperation(NodeType.Shl); break;            case OpCode.Shr: expr = this.ParseBinaryOperation(NodeType.Shr); break;            case OpCode.Shr_Un: expr = this.ParseBinaryOperation(NodeType.Shr_Un); break;            case OpCode.Neg: expr = this.ParseUnaryOperation(NodeType.Neg); break;            case OpCode.Not: expr = this.ParseUnaryOperation(NodeType.Not); break;            case OpCode.Conv_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_R4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R4' CoreSystemTypes.Single); break;            case OpCode.Conv_R8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R8' CoreSystemTypes.Double); break;            case OpCode.Conv_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U8' CoreSystemTypes.UInt64); break;            case OpCode.Callvirt: expr = this.ParseCall(NodeType.Callvirt' out isStatement); if (isStatement) goto done; break;            case OpCode.Cpobj: statement = this.ParseCopyObject(); goto done;            case OpCode.Ldobj: expr = new AddressDereference(PopOperand()' (TypeNode)this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldstr: expr = new Literal(this.GetStringFromToken()' CoreSystemTypes.String); break;            case OpCode.Newobj: expr = this.ParseConstruct(); break;            case OpCode.Castclass: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Castclass); break;            case OpCode.Isinst: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Isinst); break;            case OpCode.Conv_R_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R_Un' CoreSystemTypes.Double); break;            case OpCode.Unbox: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Unbox); break;            case OpCode.Throw: statement = new Throw(PopOperand()); transferStatement = true; goto done;            case OpCode.Ldfld:               expr = new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment);              break;            case OpCode.Ldflda:               expr = SetType(new UnaryExpression(new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf));               break;            case OpCode.Stfld: statement = this.ParseStoreField(); goto done;            case OpCode.Ldsfld: expr = new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldsflda: expr = SetType(new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf)); break;            case OpCode.Stsfld: statement = new AssignmentStatement(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' PopOperand()); goto done;            case OpCode.Stobj: statement = this.ParseStoreIndirect((TypeNode)this.GetMemberFromToken()); goto done;            case OpCode.Conv_Ovf_I1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_I2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_I4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_I8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_U2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_U4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_U8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64); break;            case OpCode.Conv_Ovf_I_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr); break;            case OpCode.Box:               TypeNode t = (TypeNode)this.GetMemberFromToken();              TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;              expr = new BinaryExpression(PopOperand()' new Literal(t' CoreSystemTypes.Type)' NodeType.Box' bt); break;            case OpCode.Newarr: expr = this.ParseNewArray(); break;            case OpCode.Ldlen: expr = new UnaryExpression(PopOperand()' NodeType.Ldlen' CoreSystemTypes.UIntPtr); break;            case OpCode.Ldelema: expr = this.ParseArrayElementLoadAddress(); break;            case OpCode.Ldelem_I1:             case OpCode.Ldelem_U1:             case OpCode.Ldelem_I2:             case OpCode.Ldelem_U2:             case OpCode.Ldelem_I4:             case OpCode.Ldelem_U4:             case OpCode.Ldelem_I8:             case OpCode.Ldelem_I:             case OpCode.Ldelem_R4:             case OpCode.Ldelem_R8:             case OpCode.Ldelem_Ref: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem_I:            case OpCode.Stelem_I1:            case OpCode.Stelem_I2:            case OpCode.Stelem_I4:            case OpCode.Stelem_I8:            case OpCode.Stelem_R4:            case OpCode.Stelem_R8:            case OpCode.Stelem_Ref: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Ldelem: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Unbox_Any: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.UnboxAny); break;            case OpCode.Conv_Ovf_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64); break;            case OpCode.Refanyval: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr); break;            case OpCode.Ckfinite: expr = this.ParseUnaryOperation(NodeType.Ckfinite); break;            case OpCode.Mkrefany: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference); break;            case OpCode.Ldtoken: expr = ParseLoadRuntimeMetadataToken(); break;            case OpCode.Conv_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Add_Ovf: expr = this.ParseBinaryOperation(NodeType.Add_Ovf); break;            case OpCode.Add_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Add_Ovf_Un); break;            case OpCode.Mul_Ovf: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf); break;            case OpCode.Mul_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf_Un); break;            case OpCode.Sub_Ovf: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf); break;            case OpCode.Sub_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf_Un); break;            case OpCode.Endfinally: statement = new EndFinally(); transferStatement = true; goto done;            case OpCode.Leave: statement = this.ParseBranch(NodeType.Nop' 0' false' false' true); transferStatement = true; goto done;            case OpCode.Leave_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false' true); transferStatement = true; goto done;            case OpCode.Stind_I: statement = this.ParseStoreIndirect(CoreSystemTypes.IntPtr); goto done;            case OpCode.Conv_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Arglist: expr = new Expression(NodeType.Arglist' CoreSystemTypes.ArgIterator); break;            case OpCode.Ceq: expr = this.ParseBinaryComparison(NodeType.Ceq); break;            case OpCode.Cgt: expr = this.ParseBinaryComparison(NodeType.Cgt); break;            case OpCode.Cgt_Un: expr = this.ParseBinaryComparison(NodeType.Cgt_Un); break;            case OpCode.Clt: expr = this.ParseBinaryComparison(NodeType.Clt); break;            case OpCode.Clt_Un: expr = this.ParseBinaryComparison(NodeType.Clt_Un); break;            case OpCode.Ldftn: expr = new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldvirtftn: expr = new BinaryExpression(PopOperand()' new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldarg: expr = this.Parameters((ushort)this.GetInt16()); break;            case OpCode.Ldarga: expr = SetType(new UnaryExpression(this.Parameters((ushort)this.GetInt16())' NodeType.AddressOf)); break;            case OpCode.Starg: statement = new AssignmentStatement(this.Parameters((ushort)this.GetInt16())' PopOperand()); goto done;            case OpCode.Ldloc: expr = this.locals[(ushort)this.GetInt16()]; break;            case OpCode.Ldloca: expr = SetType(new UnaryExpression(this.locals[(ushort)this.GetInt16()]' NodeType.AddressOf)); break;            case OpCode.Stloc: statement = new AssignmentStatement(this.locals[(ushort)this.GetInt16()]' PopOperand()); goto done;            case OpCode.Localloc: expr = new UnaryExpression(PopOperand()' NodeType.Localloc' CoreSystemTypes.Void); break;            case OpCode.Endfilter: statement = new EndFilter(PopOperand()); transferStatement = true; goto done;            case OpCode.Unaligned_: this.alignment = this.GetByte(); continue;            case OpCode.Volatile_: this.isVolatile = true; continue;            case OpCode.Tail_: this.isTailCall = true; continue;            case OpCode.Initobj: statement = this.ParseInitObject(); goto done;            case OpCode.Constrained_: this.constraint = this.GetMemberFromToken() as TypeNode; continue;            case OpCode.Cpblk: expr = this.ParseTernaryOperation(NodeType.Cpblk); goto done;            case OpCode.Initblk: expr = this.ParseTernaryOperation(NodeType.Initblk); goto done;            case OpCode.Rethrow: statement = new Throw(null); statement.NodeType = NodeType.Rethrow; transferStatement = true; goto done;            case OpCode.Sizeof: expr = new UnaryExpression(new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32); break;            case OpCode.Refanytype: expr = new UnaryExpression(PopOperand()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle); break;            case OpCode.Readonly_: this.isReadOnly = true; continue;            default: throw new InvalidMetadataException(ExceptionStrings.UnknownOpCode);          }          if (this.blockMap[this.counter+1] != null){            transferStatement = true; //Falls through to the next basic block' so implicitly a "transfer" statement            goto done;          }          //^ assume expr != null;  #if FxCop          expr.sourceContext = sourceContext;  #endif  #if FxCop || ILOFFSETS          expr.ILOffset = this.ilOffset;  #endif          this.operandStack.Push(expr);          this.isReadOnly = false;          this.isVolatile = false;          this.isTailCall = false;                  this.alignment = -1;        }
Magic Number,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true){          bool isStatement = false;          startingAddress = this.counter+1; //Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  #if FxCop || ILOFFSETS          this.ilOffset = this.counter;          this.opCode = this.GetOpCode();  #else          OpCode opCode = this.GetOpCode();  #endif  #if FxCop          if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){            expr.sourceContext = sourceContext;            expr.ILOffset = this.ilOffset;            this.operandStack.Push(expr);          }  #endif          switch (opCode){            case OpCode.Nop: statement = new Statement(NodeType.Nop); goto done;            case OpCode.Break: statement = new Statement(NodeType.DebugBreak); goto done;            case OpCode.Ldarg_0: expr = this.Parameters(0); break;            case OpCode.Ldarg_1: expr = this.Parameters(1); break;            case OpCode.Ldarg_2: expr = this.Parameters(2); break;            case OpCode.Ldarg_3: expr = this.Parameters(3); break;            case OpCode.Ldloc_0: expr = this.locals[0]; break;            case OpCode.Ldloc_1: expr = this.locals[1]; break;            case OpCode.Ldloc_2: expr = this.locals[2]; break;            case OpCode.Ldloc_3: expr = this.locals[3]; break;            case OpCode.Stloc_0: statement = new AssignmentStatement(this.locals[0]' PopOperand()); goto done;            case OpCode.Stloc_1: statement = new AssignmentStatement(this.locals[1]' PopOperand()); goto done;            case OpCode.Stloc_2: statement = new AssignmentStatement(this.locals[2]' PopOperand()); goto done;            case OpCode.Stloc_3: statement = new AssignmentStatement(this.locals[3]' PopOperand()); goto done;            case OpCode.Ldarg_S: expr = this.Parameters(this.GetByte()); break;            case OpCode.Ldarga_S: expr = SetType(new UnaryExpression(this.Parameters(this.GetByte())' NodeType.AddressOf)); break;            case OpCode.Starg_S: statement = new AssignmentStatement(this.Parameters(this.GetByte())' PopOperand()); goto done;            case OpCode.Ldloc_S: expr = this.locals[this.GetByte()]; break;            case OpCode.Ldloca_S: expr = SetType(new UnaryExpression(this.locals[this.GetByte()]' NodeType.AddressOf)); break;            case OpCode.Stloc_S: statement = new AssignmentStatement(this.locals[this.GetByte()]' PopOperand()); goto done;            case OpCode.Ldnull: expr = new Literal(null' CoreSystemTypes.Object); break;            case OpCode.Ldc_I4_M1: expr = new Literal(-1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_0: expr = new Literal(0' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_1: expr = new Literal(1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_2: expr = new Literal(2' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_3: expr = new Literal(3' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_4: expr = new Literal(4' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_5: expr = new Literal(5' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_6: expr = new Literal(6' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_7: expr = new Literal(7' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_8: expr = new Literal(8' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_S: expr = new Literal((int)this.GetSByte()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4: expr = new Literal(this.GetInt32()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I8: expr = new Literal(this.GetInt64()' CoreSystemTypes.Int64); break;            case OpCode.Ldc_R4: expr = new Literal(this.GetSingle()' CoreSystemTypes.Single); break;            case OpCode.Ldc_R8: expr = new Literal(this.GetDouble()' CoreSystemTypes.Double); break;            case OpCode.Dup: statement = new ExpressionStatement(new Expression(NodeType.Dup)); goto done;            case OpCode.Pop: statement = new ExpressionStatement(new UnaryExpression(PopOperand()' NodeType.Pop)); goto done;            case OpCode.Jmp: expr = this.ParseCall(NodeType.Jmp' out isStatement); if (isStatement) goto done; break;            case OpCode.Call: expr = this.ParseCall(NodeType.Call' out isStatement); if (isStatement) goto done; break;            case OpCode.Calli: expr = this.ParseCalli(out isStatement); if (isStatement) goto done; break;            case OpCode.Ret:              Expression retVal = BodyParser.TypeIsVoid(this.method.ReturnType) ? null : PopOperand();              statement = new Return(retVal);               transferStatement = true; goto done;            case OpCode.Br_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false); transferStatement = true; goto done;            case OpCode.Brfalse_S: statement = this.ParseBranch(NodeType.LogicalNot' 1' true' false); transferStatement = true; goto done;            case OpCode.Brtrue_S: statement = this.ParseBranch(NodeType.Nop' 1' true' false); transferStatement = true; goto done;            case OpCode.Beq_S: statement = this.ParseBranch(NodeType.Eq' 2' true' false); transferStatement = true; goto done;            case OpCode.Bge_S: statement = this.ParseBranch(NodeType.Ge' 2' true' false); transferStatement = true; goto done;            case OpCode.Bgt_S: statement = this.ParseBranch(NodeType.Gt' 2' true' false); transferStatement = true; goto done;            case OpCode.Ble_S: statement = this.ParseBranch(NodeType.Le' 2' true' false); transferStatement = true; goto done;            case OpCode.Blt_S: statement = this.ParseBranch(NodeType.Lt' 2' true' false); transferStatement = true; goto done;            case OpCode.Bne_Un_S: statement = this.ParseBranch(NodeType.Ne' 2' true' true); transferStatement = true; goto done;            case OpCode.Bge_Un_S: statement = this.ParseBranch(NodeType.Ge' 2' true' true); transferStatement = true; goto done;            case OpCode.Bgt_Un_S: statement = this.ParseBranch(NodeType.Gt' 2' true' true); transferStatement = true; goto done;            case OpCode.Ble_Un_S: statement = this.ParseBranch(NodeType.Le' 2' true' true); transferStatement = true; goto done;            case OpCode.Blt_Un_S: statement = this.ParseBranch(NodeType.Lt' 2' true' true); transferStatement = true; goto done;            case OpCode.Br: statement = this.ParseBranch(NodeType.Nop' 0' false' false); transferStatement = true; goto done;            case OpCode.Brfalse: statement = this.ParseBranch(NodeType.LogicalNot' 1' false' false); transferStatement = true; goto done;            case OpCode.Brtrue: statement = this.ParseBranch(NodeType.Nop' 1' false' false); transferStatement = true; goto done;            case OpCode.Beq: statement = this.ParseBranch(NodeType.Eq' 2' false' false); transferStatement = true; goto done;            case OpCode.Bge: statement = this.ParseBranch(NodeType.Ge' 2' false' false); transferStatement = true; goto done;            case OpCode.Bgt: statement = this.ParseBranch(NodeType.Gt' 2' false' false); transferStatement = true; goto done;            case OpCode.Ble: statement = this.ParseBranch(NodeType.Le' 2' false' false); transferStatement = true; goto done;            case OpCode.Blt: statement = this.ParseBranch(NodeType.Lt' 2' false' false); transferStatement = true; goto done;            case OpCode.Bne_Un: statement = this.ParseBranch(NodeType.Ne' 2' false' true); transferStatement = true; goto done;            case OpCode.Bge_Un: statement = this.ParseBranch(NodeType.Ge' 2' false' true); transferStatement = true; goto done;            case OpCode.Bgt_Un: statement = this.ParseBranch(NodeType.Gt' 2' false' true); transferStatement = true; goto done;            case OpCode.Ble_Un: statement = this.ParseBranch(NodeType.Le' 2' false' true); transferStatement = true; goto done;            case OpCode.Blt_Un: statement = this.ParseBranch(NodeType.Lt' 2' false' true); transferStatement = true; goto done;            case OpCode.Switch: statement = this.ParseSwitchInstruction(); transferStatement = true; goto done;            case OpCode.Ldind_I1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int64' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I: expr = new AddressDereference(PopOperand()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Single' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Double' this.isVolatile' this.alignment); break;            case OpCode.Ldind_Ref: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Object' this.isVolatile' this.alignment); break;            case OpCode.Stind_Ref: statement = this.ParseStoreIndirect(CoreSystemTypes.Object); goto done;            case OpCode.Stind_I1: statement = this.ParseStoreIndirect(CoreSystemTypes.Int8); goto done;            case OpCode.Stind_I2: statement = this.ParseStoreIndirect(CoreSystemTypes.Int16); goto done;            case OpCode.Stind_I4: statement = this.ParseStoreIndirect(CoreSystemTypes.Int32); goto done;            case OpCode.Stind_I8: statement = this.ParseStoreIndirect(CoreSystemTypes.Int64); goto done;            case OpCode.Stind_R4: statement = this.ParseStoreIndirect(CoreSystemTypes.Single); goto done;            case OpCode.Stind_R8: statement = this.ParseStoreIndirect(CoreSystemTypes.Double); goto done;            case OpCode.Add: expr = this.ParseBinaryOperation(NodeType.Add); break;            case OpCode.Sub: expr = this.ParseBinaryOperation(NodeType.Sub); break;            case OpCode.Mul: expr = this.ParseBinaryOperation(NodeType.Mul); break;            case OpCode.Div: expr = this.ParseBinaryOperation(NodeType.Div); break;            case OpCode.Div_Un: expr = this.ParseBinaryOperation(NodeType.Div_Un); break;            case OpCode.Rem: expr = this.ParseBinaryOperation(NodeType.Rem); break;            case OpCode.Rem_Un: expr = this.ParseBinaryOperation(NodeType.Rem_Un); break;            case OpCode.And: expr = this.ParseBinaryOperation(NodeType.And); break;            case OpCode.Or: expr = this.ParseBinaryOperation(NodeType.Or); break;            case OpCode.Xor: expr = this.ParseBinaryOperation(NodeType.Xor); break;            case OpCode.Shl: expr = this.ParseBinaryOperation(NodeType.Shl); break;            case OpCode.Shr: expr = this.ParseBinaryOperation(NodeType.Shr); break;            case OpCode.Shr_Un: expr = this.ParseBinaryOperation(NodeType.Shr_Un); break;            case OpCode.Neg: expr = this.ParseUnaryOperation(NodeType.Neg); break;            case OpCode.Not: expr = this.ParseUnaryOperation(NodeType.Not); break;            case OpCode.Conv_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_R4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R4' CoreSystemTypes.Single); break;            case OpCode.Conv_R8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R8' CoreSystemTypes.Double); break;            case OpCode.Conv_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U8' CoreSystemTypes.UInt64); break;            case OpCode.Callvirt: expr = this.ParseCall(NodeType.Callvirt' out isStatement); if (isStatement) goto done; break;            case OpCode.Cpobj: statement = this.ParseCopyObject(); goto done;            case OpCode.Ldobj: expr = new AddressDereference(PopOperand()' (TypeNode)this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldstr: expr = new Literal(this.GetStringFromToken()' CoreSystemTypes.String); break;            case OpCode.Newobj: expr = this.ParseConstruct(); break;            case OpCode.Castclass: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Castclass); break;            case OpCode.Isinst: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Isinst); break;            case OpCode.Conv_R_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R_Un' CoreSystemTypes.Double); break;            case OpCode.Unbox: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Unbox); break;            case OpCode.Throw: statement = new Throw(PopOperand()); transferStatement = true; goto done;            case OpCode.Ldfld:               expr = new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment);              break;            case OpCode.Ldflda:               expr = SetType(new UnaryExpression(new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf));               break;            case OpCode.Stfld: statement = this.ParseStoreField(); goto done;            case OpCode.Ldsfld: expr = new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldsflda: expr = SetType(new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf)); break;            case OpCode.Stsfld: statement = new AssignmentStatement(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' PopOperand()); goto done;            case OpCode.Stobj: statement = this.ParseStoreIndirect((TypeNode)this.GetMemberFromToken()); goto done;            case OpCode.Conv_Ovf_I1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_I2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_I4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_I8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_U2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_U4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_U8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64); break;            case OpCode.Conv_Ovf_I_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr); break;            case OpCode.Box:               TypeNode t = (TypeNode)this.GetMemberFromToken();              TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;              expr = new BinaryExpression(PopOperand()' new Literal(t' CoreSystemTypes.Type)' NodeType.Box' bt); break;            case OpCode.Newarr: expr = this.ParseNewArray(); break;            case OpCode.Ldlen: expr = new UnaryExpression(PopOperand()' NodeType.Ldlen' CoreSystemTypes.UIntPtr); break;            case OpCode.Ldelema: expr = this.ParseArrayElementLoadAddress(); break;            case OpCode.Ldelem_I1:             case OpCode.Ldelem_U1:             case OpCode.Ldelem_I2:             case OpCode.Ldelem_U2:             case OpCode.Ldelem_I4:             case OpCode.Ldelem_U4:             case OpCode.Ldelem_I8:             case OpCode.Ldelem_I:             case OpCode.Ldelem_R4:             case OpCode.Ldelem_R8:             case OpCode.Ldelem_Ref: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem_I:            case OpCode.Stelem_I1:            case OpCode.Stelem_I2:            case OpCode.Stelem_I4:            case OpCode.Stelem_I8:            case OpCode.Stelem_R4:            case OpCode.Stelem_R8:            case OpCode.Stelem_Ref: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Ldelem: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Unbox_Any: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.UnboxAny); break;            case OpCode.Conv_Ovf_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64); break;            case OpCode.Refanyval: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr); break;            case OpCode.Ckfinite: expr = this.ParseUnaryOperation(NodeType.Ckfinite); break;            case OpCode.Mkrefany: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference); break;            case OpCode.Ldtoken: expr = ParseLoadRuntimeMetadataToken(); break;            case OpCode.Conv_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Add_Ovf: expr = this.ParseBinaryOperation(NodeType.Add_Ovf); break;            case OpCode.Add_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Add_Ovf_Un); break;            case OpCode.Mul_Ovf: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf); break;            case OpCode.Mul_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf_Un); break;            case OpCode.Sub_Ovf: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf); break;            case OpCode.Sub_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf_Un); break;            case OpCode.Endfinally: statement = new EndFinally(); transferStatement = true; goto done;            case OpCode.Leave: statement = this.ParseBranch(NodeType.Nop' 0' false' false' true); transferStatement = true; goto done;            case OpCode.Leave_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false' true); transferStatement = true; goto done;            case OpCode.Stind_I: statement = this.ParseStoreIndirect(CoreSystemTypes.IntPtr); goto done;            case OpCode.Conv_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Arglist: expr = new Expression(NodeType.Arglist' CoreSystemTypes.ArgIterator); break;            case OpCode.Ceq: expr = this.ParseBinaryComparison(NodeType.Ceq); break;            case OpCode.Cgt: expr = this.ParseBinaryComparison(NodeType.Cgt); break;            case OpCode.Cgt_Un: expr = this.ParseBinaryComparison(NodeType.Cgt_Un); break;            case OpCode.Clt: expr = this.ParseBinaryComparison(NodeType.Clt); break;            case OpCode.Clt_Un: expr = this.ParseBinaryComparison(NodeType.Clt_Un); break;            case OpCode.Ldftn: expr = new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldvirtftn: expr = new BinaryExpression(PopOperand()' new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldarg: expr = this.Parameters((ushort)this.GetInt16()); break;            case OpCode.Ldarga: expr = SetType(new UnaryExpression(this.Parameters((ushort)this.GetInt16())' NodeType.AddressOf)); break;            case OpCode.Starg: statement = new AssignmentStatement(this.Parameters((ushort)this.GetInt16())' PopOperand()); goto done;            case OpCode.Ldloc: expr = this.locals[(ushort)this.GetInt16()]; break;            case OpCode.Ldloca: expr = SetType(new UnaryExpression(this.locals[(ushort)this.GetInt16()]' NodeType.AddressOf)); break;            case OpCode.Stloc: statement = new AssignmentStatement(this.locals[(ushort)this.GetInt16()]' PopOperand()); goto done;            case OpCode.Localloc: expr = new UnaryExpression(PopOperand()' NodeType.Localloc' CoreSystemTypes.Void); break;            case OpCode.Endfilter: statement = new EndFilter(PopOperand()); transferStatement = true; goto done;            case OpCode.Unaligned_: this.alignment = this.GetByte(); continue;            case OpCode.Volatile_: this.isVolatile = true; continue;            case OpCode.Tail_: this.isTailCall = true; continue;            case OpCode.Initobj: statement = this.ParseInitObject(); goto done;            case OpCode.Constrained_: this.constraint = this.GetMemberFromToken() as TypeNode; continue;            case OpCode.Cpblk: expr = this.ParseTernaryOperation(NodeType.Cpblk); goto done;            case OpCode.Initblk: expr = this.ParseTernaryOperation(NodeType.Initblk); goto done;            case OpCode.Rethrow: statement = new Throw(null); statement.NodeType = NodeType.Rethrow; transferStatement = true; goto done;            case OpCode.Sizeof: expr = new UnaryExpression(new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32); break;            case OpCode.Refanytype: expr = new UnaryExpression(PopOperand()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle); break;            case OpCode.Readonly_: this.isReadOnly = true; continue;            default: throw new InvalidMetadataException(ExceptionStrings.UnknownOpCode);          }          if (this.blockMap[this.counter+1] != null){            transferStatement = true; //Falls through to the next basic block' so implicitly a "transfer" statement            goto done;          }          //^ assume expr != null;  #if FxCop          expr.sourceContext = sourceContext;  #endif  #if FxCop || ILOFFSETS          expr.ILOffset = this.ilOffset;  #endif          this.operandStack.Push(expr);          this.isReadOnly = false;          this.isVolatile = false;          this.isTailCall = false;                  this.alignment = -1;        }
Magic Number,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true){          bool isStatement = false;          startingAddress = this.counter+1; //Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  #if FxCop || ILOFFSETS          this.ilOffset = this.counter;          this.opCode = this.GetOpCode();  #else          OpCode opCode = this.GetOpCode();  #endif  #if FxCop          if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){            expr.sourceContext = sourceContext;            expr.ILOffset = this.ilOffset;            this.operandStack.Push(expr);          }  #endif          switch (opCode){            case OpCode.Nop: statement = new Statement(NodeType.Nop); goto done;            case OpCode.Break: statement = new Statement(NodeType.DebugBreak); goto done;            case OpCode.Ldarg_0: expr = this.Parameters(0); break;            case OpCode.Ldarg_1: expr = this.Parameters(1); break;            case OpCode.Ldarg_2: expr = this.Parameters(2); break;            case OpCode.Ldarg_3: expr = this.Parameters(3); break;            case OpCode.Ldloc_0: expr = this.locals[0]; break;            case OpCode.Ldloc_1: expr = this.locals[1]; break;            case OpCode.Ldloc_2: expr = this.locals[2]; break;            case OpCode.Ldloc_3: expr = this.locals[3]; break;            case OpCode.Stloc_0: statement = new AssignmentStatement(this.locals[0]' PopOperand()); goto done;            case OpCode.Stloc_1: statement = new AssignmentStatement(this.locals[1]' PopOperand()); goto done;            case OpCode.Stloc_2: statement = new AssignmentStatement(this.locals[2]' PopOperand()); goto done;            case OpCode.Stloc_3: statement = new AssignmentStatement(this.locals[3]' PopOperand()); goto done;            case OpCode.Ldarg_S: expr = this.Parameters(this.GetByte()); break;            case OpCode.Ldarga_S: expr = SetType(new UnaryExpression(this.Parameters(this.GetByte())' NodeType.AddressOf)); break;            case OpCode.Starg_S: statement = new AssignmentStatement(this.Parameters(this.GetByte())' PopOperand()); goto done;            case OpCode.Ldloc_S: expr = this.locals[this.GetByte()]; break;            case OpCode.Ldloca_S: expr = SetType(new UnaryExpression(this.locals[this.GetByte()]' NodeType.AddressOf)); break;            case OpCode.Stloc_S: statement = new AssignmentStatement(this.locals[this.GetByte()]' PopOperand()); goto done;            case OpCode.Ldnull: expr = new Literal(null' CoreSystemTypes.Object); break;            case OpCode.Ldc_I4_M1: expr = new Literal(-1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_0: expr = new Literal(0' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_1: expr = new Literal(1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_2: expr = new Literal(2' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_3: expr = new Literal(3' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_4: expr = new Literal(4' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_5: expr = new Literal(5' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_6: expr = new Literal(6' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_7: expr = new Literal(7' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_8: expr = new Literal(8' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_S: expr = new Literal((int)this.GetSByte()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4: expr = new Literal(this.GetInt32()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I8: expr = new Literal(this.GetInt64()' CoreSystemTypes.Int64); break;            case OpCode.Ldc_R4: expr = new Literal(this.GetSingle()' CoreSystemTypes.Single); break;            case OpCode.Ldc_R8: expr = new Literal(this.GetDouble()' CoreSystemTypes.Double); break;            case OpCode.Dup: statement = new ExpressionStatement(new Expression(NodeType.Dup)); goto done;            case OpCode.Pop: statement = new ExpressionStatement(new UnaryExpression(PopOperand()' NodeType.Pop)); goto done;            case OpCode.Jmp: expr = this.ParseCall(NodeType.Jmp' out isStatement); if (isStatement) goto done; break;            case OpCode.Call: expr = this.ParseCall(NodeType.Call' out isStatement); if (isStatement) goto done; break;            case OpCode.Calli: expr = this.ParseCalli(out isStatement); if (isStatement) goto done; break;            case OpCode.Ret:              Expression retVal = BodyParser.TypeIsVoid(this.method.ReturnType) ? null : PopOperand();              statement = new Return(retVal);               transferStatement = true; goto done;            case OpCode.Br_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false); transferStatement = true; goto done;            case OpCode.Brfalse_S: statement = this.ParseBranch(NodeType.LogicalNot' 1' true' false); transferStatement = true; goto done;            case OpCode.Brtrue_S: statement = this.ParseBranch(NodeType.Nop' 1' true' false); transferStatement = true; goto done;            case OpCode.Beq_S: statement = this.ParseBranch(NodeType.Eq' 2' true' false); transferStatement = true; goto done;            case OpCode.Bge_S: statement = this.ParseBranch(NodeType.Ge' 2' true' false); transferStatement = true; goto done;            case OpCode.Bgt_S: statement = this.ParseBranch(NodeType.Gt' 2' true' false); transferStatement = true; goto done;            case OpCode.Ble_S: statement = this.ParseBranch(NodeType.Le' 2' true' false); transferStatement = true; goto done;            case OpCode.Blt_S: statement = this.ParseBranch(NodeType.Lt' 2' true' false); transferStatement = true; goto done;            case OpCode.Bne_Un_S: statement = this.ParseBranch(NodeType.Ne' 2' true' true); transferStatement = true; goto done;            case OpCode.Bge_Un_S: statement = this.ParseBranch(NodeType.Ge' 2' true' true); transferStatement = true; goto done;            case OpCode.Bgt_Un_S: statement = this.ParseBranch(NodeType.Gt' 2' true' true); transferStatement = true; goto done;            case OpCode.Ble_Un_S: statement = this.ParseBranch(NodeType.Le' 2' true' true); transferStatement = true; goto done;            case OpCode.Blt_Un_S: statement = this.ParseBranch(NodeType.Lt' 2' true' true); transferStatement = true; goto done;            case OpCode.Br: statement = this.ParseBranch(NodeType.Nop' 0' false' false); transferStatement = true; goto done;            case OpCode.Brfalse: statement = this.ParseBranch(NodeType.LogicalNot' 1' false' false); transferStatement = true; goto done;            case OpCode.Brtrue: statement = this.ParseBranch(NodeType.Nop' 1' false' false); transferStatement = true; goto done;            case OpCode.Beq: statement = this.ParseBranch(NodeType.Eq' 2' false' false); transferStatement = true; goto done;            case OpCode.Bge: statement = this.ParseBranch(NodeType.Ge' 2' false' false); transferStatement = true; goto done;            case OpCode.Bgt: statement = this.ParseBranch(NodeType.Gt' 2' false' false); transferStatement = true; goto done;            case OpCode.Ble: statement = this.ParseBranch(NodeType.Le' 2' false' false); transferStatement = true; goto done;            case OpCode.Blt: statement = this.ParseBranch(NodeType.Lt' 2' false' false); transferStatement = true; goto done;            case OpCode.Bne_Un: statement = this.ParseBranch(NodeType.Ne' 2' false' true); transferStatement = true; goto done;            case OpCode.Bge_Un: statement = this.ParseBranch(NodeType.Ge' 2' false' true); transferStatement = true; goto done;            case OpCode.Bgt_Un: statement = this.ParseBranch(NodeType.Gt' 2' false' true); transferStatement = true; goto done;            case OpCode.Ble_Un: statement = this.ParseBranch(NodeType.Le' 2' false' true); transferStatement = true; goto done;            case OpCode.Blt_Un: statement = this.ParseBranch(NodeType.Lt' 2' false' true); transferStatement = true; goto done;            case OpCode.Switch: statement = this.ParseSwitchInstruction(); transferStatement = true; goto done;            case OpCode.Ldind_I1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int64' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I: expr = new AddressDereference(PopOperand()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Single' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Double' this.isVolatile' this.alignment); break;            case OpCode.Ldind_Ref: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Object' this.isVolatile' this.alignment); break;            case OpCode.Stind_Ref: statement = this.ParseStoreIndirect(CoreSystemTypes.Object); goto done;            case OpCode.Stind_I1: statement = this.ParseStoreIndirect(CoreSystemTypes.Int8); goto done;            case OpCode.Stind_I2: statement = this.ParseStoreIndirect(CoreSystemTypes.Int16); goto done;            case OpCode.Stind_I4: statement = this.ParseStoreIndirect(CoreSystemTypes.Int32); goto done;            case OpCode.Stind_I8: statement = this.ParseStoreIndirect(CoreSystemTypes.Int64); goto done;            case OpCode.Stind_R4: statement = this.ParseStoreIndirect(CoreSystemTypes.Single); goto done;            case OpCode.Stind_R8: statement = this.ParseStoreIndirect(CoreSystemTypes.Double); goto done;            case OpCode.Add: expr = this.ParseBinaryOperation(NodeType.Add); break;            case OpCode.Sub: expr = this.ParseBinaryOperation(NodeType.Sub); break;            case OpCode.Mul: expr = this.ParseBinaryOperation(NodeType.Mul); break;            case OpCode.Div: expr = this.ParseBinaryOperation(NodeType.Div); break;            case OpCode.Div_Un: expr = this.ParseBinaryOperation(NodeType.Div_Un); break;            case OpCode.Rem: expr = this.ParseBinaryOperation(NodeType.Rem); break;            case OpCode.Rem_Un: expr = this.ParseBinaryOperation(NodeType.Rem_Un); break;            case OpCode.And: expr = this.ParseBinaryOperation(NodeType.And); break;            case OpCode.Or: expr = this.ParseBinaryOperation(NodeType.Or); break;            case OpCode.Xor: expr = this.ParseBinaryOperation(NodeType.Xor); break;            case OpCode.Shl: expr = this.ParseBinaryOperation(NodeType.Shl); break;            case OpCode.Shr: expr = this.ParseBinaryOperation(NodeType.Shr); break;            case OpCode.Shr_Un: expr = this.ParseBinaryOperation(NodeType.Shr_Un); break;            case OpCode.Neg: expr = this.ParseUnaryOperation(NodeType.Neg); break;            case OpCode.Not: expr = this.ParseUnaryOperation(NodeType.Not); break;            case OpCode.Conv_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_R4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R4' CoreSystemTypes.Single); break;            case OpCode.Conv_R8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R8' CoreSystemTypes.Double); break;            case OpCode.Conv_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U8' CoreSystemTypes.UInt64); break;            case OpCode.Callvirt: expr = this.ParseCall(NodeType.Callvirt' out isStatement); if (isStatement) goto done; break;            case OpCode.Cpobj: statement = this.ParseCopyObject(); goto done;            case OpCode.Ldobj: expr = new AddressDereference(PopOperand()' (TypeNode)this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldstr: expr = new Literal(this.GetStringFromToken()' CoreSystemTypes.String); break;            case OpCode.Newobj: expr = this.ParseConstruct(); break;            case OpCode.Castclass: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Castclass); break;            case OpCode.Isinst: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Isinst); break;            case OpCode.Conv_R_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R_Un' CoreSystemTypes.Double); break;            case OpCode.Unbox: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Unbox); break;            case OpCode.Throw: statement = new Throw(PopOperand()); transferStatement = true; goto done;            case OpCode.Ldfld:               expr = new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment);              break;            case OpCode.Ldflda:               expr = SetType(new UnaryExpression(new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf));               break;            case OpCode.Stfld: statement = this.ParseStoreField(); goto done;            case OpCode.Ldsfld: expr = new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldsflda: expr = SetType(new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf)); break;            case OpCode.Stsfld: statement = new AssignmentStatement(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' PopOperand()); goto done;            case OpCode.Stobj: statement = this.ParseStoreIndirect((TypeNode)this.GetMemberFromToken()); goto done;            case OpCode.Conv_Ovf_I1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_I2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_I4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_I8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_U2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_U4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_U8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64); break;            case OpCode.Conv_Ovf_I_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr); break;            case OpCode.Box:               TypeNode t = (TypeNode)this.GetMemberFromToken();              TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;              expr = new BinaryExpression(PopOperand()' new Literal(t' CoreSystemTypes.Type)' NodeType.Box' bt); break;            case OpCode.Newarr: expr = this.ParseNewArray(); break;            case OpCode.Ldlen: expr = new UnaryExpression(PopOperand()' NodeType.Ldlen' CoreSystemTypes.UIntPtr); break;            case OpCode.Ldelema: expr = this.ParseArrayElementLoadAddress(); break;            case OpCode.Ldelem_I1:             case OpCode.Ldelem_U1:             case OpCode.Ldelem_I2:             case OpCode.Ldelem_U2:             case OpCode.Ldelem_I4:             case OpCode.Ldelem_U4:             case OpCode.Ldelem_I8:             case OpCode.Ldelem_I:             case OpCode.Ldelem_R4:             case OpCode.Ldelem_R8:             case OpCode.Ldelem_Ref: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem_I:            case OpCode.Stelem_I1:            case OpCode.Stelem_I2:            case OpCode.Stelem_I4:            case OpCode.Stelem_I8:            case OpCode.Stelem_R4:            case OpCode.Stelem_R8:            case OpCode.Stelem_Ref: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Ldelem: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Unbox_Any: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.UnboxAny); break;            case OpCode.Conv_Ovf_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64); break;            case OpCode.Refanyval: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr); break;            case OpCode.Ckfinite: expr = this.ParseUnaryOperation(NodeType.Ckfinite); break;            case OpCode.Mkrefany: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference); break;            case OpCode.Ldtoken: expr = ParseLoadRuntimeMetadataToken(); break;            case OpCode.Conv_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Add_Ovf: expr = this.ParseBinaryOperation(NodeType.Add_Ovf); break;            case OpCode.Add_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Add_Ovf_Un); break;            case OpCode.Mul_Ovf: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf); break;            case OpCode.Mul_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf_Un); break;            case OpCode.Sub_Ovf: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf); break;            case OpCode.Sub_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf_Un); break;            case OpCode.Endfinally: statement = new EndFinally(); transferStatement = true; goto done;            case OpCode.Leave: statement = this.ParseBranch(NodeType.Nop' 0' false' false' true); transferStatement = true; goto done;            case OpCode.Leave_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false' true); transferStatement = true; goto done;            case OpCode.Stind_I: statement = this.ParseStoreIndirect(CoreSystemTypes.IntPtr); goto done;            case OpCode.Conv_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Arglist: expr = new Expression(NodeType.Arglist' CoreSystemTypes.ArgIterator); break;            case OpCode.Ceq: expr = this.ParseBinaryComparison(NodeType.Ceq); break;            case OpCode.Cgt: expr = this.ParseBinaryComparison(NodeType.Cgt); break;            case OpCode.Cgt_Un: expr = this.ParseBinaryComparison(NodeType.Cgt_Un); break;            case OpCode.Clt: expr = this.ParseBinaryComparison(NodeType.Clt); break;            case OpCode.Clt_Un: expr = this.ParseBinaryComparison(NodeType.Clt_Un); break;            case OpCode.Ldftn: expr = new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldvirtftn: expr = new BinaryExpression(PopOperand()' new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldarg: expr = this.Parameters((ushort)this.GetInt16()); break;            case OpCode.Ldarga: expr = SetType(new UnaryExpression(this.Parameters((ushort)this.GetInt16())' NodeType.AddressOf)); break;            case OpCode.Starg: statement = new AssignmentStatement(this.Parameters((ushort)this.GetInt16())' PopOperand()); goto done;            case OpCode.Ldloc: expr = this.locals[(ushort)this.GetInt16()]; break;            case OpCode.Ldloca: expr = SetType(new UnaryExpression(this.locals[(ushort)this.GetInt16()]' NodeType.AddressOf)); break;            case OpCode.Stloc: statement = new AssignmentStatement(this.locals[(ushort)this.GetInt16()]' PopOperand()); goto done;            case OpCode.Localloc: expr = new UnaryExpression(PopOperand()' NodeType.Localloc' CoreSystemTypes.Void); break;            case OpCode.Endfilter: statement = new EndFilter(PopOperand()); transferStatement = true; goto done;            case OpCode.Unaligned_: this.alignment = this.GetByte(); continue;            case OpCode.Volatile_: this.isVolatile = true; continue;            case OpCode.Tail_: this.isTailCall = true; continue;            case OpCode.Initobj: statement = this.ParseInitObject(); goto done;            case OpCode.Constrained_: this.constraint = this.GetMemberFromToken() as TypeNode; continue;            case OpCode.Cpblk: expr = this.ParseTernaryOperation(NodeType.Cpblk); goto done;            case OpCode.Initblk: expr = this.ParseTernaryOperation(NodeType.Initblk); goto done;            case OpCode.Rethrow: statement = new Throw(null); statement.NodeType = NodeType.Rethrow; transferStatement = true; goto done;            case OpCode.Sizeof: expr = new UnaryExpression(new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32); break;            case OpCode.Refanytype: expr = new UnaryExpression(PopOperand()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle); break;            case OpCode.Readonly_: this.isReadOnly = true; continue;            default: throw new InvalidMetadataException(ExceptionStrings.UnknownOpCode);          }          if (this.blockMap[this.counter+1] != null){            transferStatement = true; //Falls through to the next basic block' so implicitly a "transfer" statement            goto done;          }          //^ assume expr != null;  #if FxCop          expr.sourceContext = sourceContext;  #endif  #if FxCop || ILOFFSETS          expr.ILOffset = this.ilOffset;  #endif          this.operandStack.Push(expr);          this.isReadOnly = false;          this.isVolatile = false;          this.isTailCall = false;                  this.alignment = -1;        }
Magic Number,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true){          bool isStatement = false;          startingAddress = this.counter+1; //Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  #if FxCop || ILOFFSETS          this.ilOffset = this.counter;          this.opCode = this.GetOpCode();  #else          OpCode opCode = this.GetOpCode();  #endif  #if FxCop          if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){            expr.sourceContext = sourceContext;            expr.ILOffset = this.ilOffset;            this.operandStack.Push(expr);          }  #endif          switch (opCode){            case OpCode.Nop: statement = new Statement(NodeType.Nop); goto done;            case OpCode.Break: statement = new Statement(NodeType.DebugBreak); goto done;            case OpCode.Ldarg_0: expr = this.Parameters(0); break;            case OpCode.Ldarg_1: expr = this.Parameters(1); break;            case OpCode.Ldarg_2: expr = this.Parameters(2); break;            case OpCode.Ldarg_3: expr = this.Parameters(3); break;            case OpCode.Ldloc_0: expr = this.locals[0]; break;            case OpCode.Ldloc_1: expr = this.locals[1]; break;            case OpCode.Ldloc_2: expr = this.locals[2]; break;            case OpCode.Ldloc_3: expr = this.locals[3]; break;            case OpCode.Stloc_0: statement = new AssignmentStatement(this.locals[0]' PopOperand()); goto done;            case OpCode.Stloc_1: statement = new AssignmentStatement(this.locals[1]' PopOperand()); goto done;            case OpCode.Stloc_2: statement = new AssignmentStatement(this.locals[2]' PopOperand()); goto done;            case OpCode.Stloc_3: statement = new AssignmentStatement(this.locals[3]' PopOperand()); goto done;            case OpCode.Ldarg_S: expr = this.Parameters(this.GetByte()); break;            case OpCode.Ldarga_S: expr = SetType(new UnaryExpression(this.Parameters(this.GetByte())' NodeType.AddressOf)); break;            case OpCode.Starg_S: statement = new AssignmentStatement(this.Parameters(this.GetByte())' PopOperand()); goto done;            case OpCode.Ldloc_S: expr = this.locals[this.GetByte()]; break;            case OpCode.Ldloca_S: expr = SetType(new UnaryExpression(this.locals[this.GetByte()]' NodeType.AddressOf)); break;            case OpCode.Stloc_S: statement = new AssignmentStatement(this.locals[this.GetByte()]' PopOperand()); goto done;            case OpCode.Ldnull: expr = new Literal(null' CoreSystemTypes.Object); break;            case OpCode.Ldc_I4_M1: expr = new Literal(-1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_0: expr = new Literal(0' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_1: expr = new Literal(1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_2: expr = new Literal(2' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_3: expr = new Literal(3' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_4: expr = new Literal(4' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_5: expr = new Literal(5' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_6: expr = new Literal(6' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_7: expr = new Literal(7' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_8: expr = new Literal(8' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_S: expr = new Literal((int)this.GetSByte()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4: expr = new Literal(this.GetInt32()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I8: expr = new Literal(this.GetInt64()' CoreSystemTypes.Int64); break;            case OpCode.Ldc_R4: expr = new Literal(this.GetSingle()' CoreSystemTypes.Single); break;            case OpCode.Ldc_R8: expr = new Literal(this.GetDouble()' CoreSystemTypes.Double); break;            case OpCode.Dup: statement = new ExpressionStatement(new Expression(NodeType.Dup)); goto done;            case OpCode.Pop: statement = new ExpressionStatement(new UnaryExpression(PopOperand()' NodeType.Pop)); goto done;            case OpCode.Jmp: expr = this.ParseCall(NodeType.Jmp' out isStatement); if (isStatement) goto done; break;            case OpCode.Call: expr = this.ParseCall(NodeType.Call' out isStatement); if (isStatement) goto done; break;            case OpCode.Calli: expr = this.ParseCalli(out isStatement); if (isStatement) goto done; break;            case OpCode.Ret:              Expression retVal = BodyParser.TypeIsVoid(this.method.ReturnType) ? null : PopOperand();              statement = new Return(retVal);               transferStatement = true; goto done;            case OpCode.Br_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false); transferStatement = true; goto done;            case OpCode.Brfalse_S: statement = this.ParseBranch(NodeType.LogicalNot' 1' true' false); transferStatement = true; goto done;            case OpCode.Brtrue_S: statement = this.ParseBranch(NodeType.Nop' 1' true' false); transferStatement = true; goto done;            case OpCode.Beq_S: statement = this.ParseBranch(NodeType.Eq' 2' true' false); transferStatement = true; goto done;            case OpCode.Bge_S: statement = this.ParseBranch(NodeType.Ge' 2' true' false); transferStatement = true; goto done;            case OpCode.Bgt_S: statement = this.ParseBranch(NodeType.Gt' 2' true' false); transferStatement = true; goto done;            case OpCode.Ble_S: statement = this.ParseBranch(NodeType.Le' 2' true' false); transferStatement = true; goto done;            case OpCode.Blt_S: statement = this.ParseBranch(NodeType.Lt' 2' true' false); transferStatement = true; goto done;            case OpCode.Bne_Un_S: statement = this.ParseBranch(NodeType.Ne' 2' true' true); transferStatement = true; goto done;            case OpCode.Bge_Un_S: statement = this.ParseBranch(NodeType.Ge' 2' true' true); transferStatement = true; goto done;            case OpCode.Bgt_Un_S: statement = this.ParseBranch(NodeType.Gt' 2' true' true); transferStatement = true; goto done;            case OpCode.Ble_Un_S: statement = this.ParseBranch(NodeType.Le' 2' true' true); transferStatement = true; goto done;            case OpCode.Blt_Un_S: statement = this.ParseBranch(NodeType.Lt' 2' true' true); transferStatement = true; goto done;            case OpCode.Br: statement = this.ParseBranch(NodeType.Nop' 0' false' false); transferStatement = true; goto done;            case OpCode.Brfalse: statement = this.ParseBranch(NodeType.LogicalNot' 1' false' false); transferStatement = true; goto done;            case OpCode.Brtrue: statement = this.ParseBranch(NodeType.Nop' 1' false' false); transferStatement = true; goto done;            case OpCode.Beq: statement = this.ParseBranch(NodeType.Eq' 2' false' false); transferStatement = true; goto done;            case OpCode.Bge: statement = this.ParseBranch(NodeType.Ge' 2' false' false); transferStatement = true; goto done;            case OpCode.Bgt: statement = this.ParseBranch(NodeType.Gt' 2' false' false); transferStatement = true; goto done;            case OpCode.Ble: statement = this.ParseBranch(NodeType.Le' 2' false' false); transferStatement = true; goto done;            case OpCode.Blt: statement = this.ParseBranch(NodeType.Lt' 2' false' false); transferStatement = true; goto done;            case OpCode.Bne_Un: statement = this.ParseBranch(NodeType.Ne' 2' false' true); transferStatement = true; goto done;            case OpCode.Bge_Un: statement = this.ParseBranch(NodeType.Ge' 2' false' true); transferStatement = true; goto done;            case OpCode.Bgt_Un: statement = this.ParseBranch(NodeType.Gt' 2' false' true); transferStatement = true; goto done;            case OpCode.Ble_Un: statement = this.ParseBranch(NodeType.Le' 2' false' true); transferStatement = true; goto done;            case OpCode.Blt_Un: statement = this.ParseBranch(NodeType.Lt' 2' false' true); transferStatement = true; goto done;            case OpCode.Switch: statement = this.ParseSwitchInstruction(); transferStatement = true; goto done;            case OpCode.Ldind_I1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int64' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I: expr = new AddressDereference(PopOperand()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Single' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Double' this.isVolatile' this.alignment); break;            case OpCode.Ldind_Ref: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Object' this.isVolatile' this.alignment); break;            case OpCode.Stind_Ref: statement = this.ParseStoreIndirect(CoreSystemTypes.Object); goto done;            case OpCode.Stind_I1: statement = this.ParseStoreIndirect(CoreSystemTypes.Int8); goto done;            case OpCode.Stind_I2: statement = this.ParseStoreIndirect(CoreSystemTypes.Int16); goto done;            case OpCode.Stind_I4: statement = this.ParseStoreIndirect(CoreSystemTypes.Int32); goto done;            case OpCode.Stind_I8: statement = this.ParseStoreIndirect(CoreSystemTypes.Int64); goto done;            case OpCode.Stind_R4: statement = this.ParseStoreIndirect(CoreSystemTypes.Single); goto done;            case OpCode.Stind_R8: statement = this.ParseStoreIndirect(CoreSystemTypes.Double); goto done;            case OpCode.Add: expr = this.ParseBinaryOperation(NodeType.Add); break;            case OpCode.Sub: expr = this.ParseBinaryOperation(NodeType.Sub); break;            case OpCode.Mul: expr = this.ParseBinaryOperation(NodeType.Mul); break;            case OpCode.Div: expr = this.ParseBinaryOperation(NodeType.Div); break;            case OpCode.Div_Un: expr = this.ParseBinaryOperation(NodeType.Div_Un); break;            case OpCode.Rem: expr = this.ParseBinaryOperation(NodeType.Rem); break;            case OpCode.Rem_Un: expr = this.ParseBinaryOperation(NodeType.Rem_Un); break;            case OpCode.And: expr = this.ParseBinaryOperation(NodeType.And); break;            case OpCode.Or: expr = this.ParseBinaryOperation(NodeType.Or); break;            case OpCode.Xor: expr = this.ParseBinaryOperation(NodeType.Xor); break;            case OpCode.Shl: expr = this.ParseBinaryOperation(NodeType.Shl); break;            case OpCode.Shr: expr = this.ParseBinaryOperation(NodeType.Shr); break;            case OpCode.Shr_Un: expr = this.ParseBinaryOperation(NodeType.Shr_Un); break;            case OpCode.Neg: expr = this.ParseUnaryOperation(NodeType.Neg); break;            case OpCode.Not: expr = this.ParseUnaryOperation(NodeType.Not); break;            case OpCode.Conv_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_R4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R4' CoreSystemTypes.Single); break;            case OpCode.Conv_R8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R8' CoreSystemTypes.Double); break;            case OpCode.Conv_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U8' CoreSystemTypes.UInt64); break;            case OpCode.Callvirt: expr = this.ParseCall(NodeType.Callvirt' out isStatement); if (isStatement) goto done; break;            case OpCode.Cpobj: statement = this.ParseCopyObject(); goto done;            case OpCode.Ldobj: expr = new AddressDereference(PopOperand()' (TypeNode)this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldstr: expr = new Literal(this.GetStringFromToken()' CoreSystemTypes.String); break;            case OpCode.Newobj: expr = this.ParseConstruct(); break;            case OpCode.Castclass: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Castclass); break;            case OpCode.Isinst: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Isinst); break;            case OpCode.Conv_R_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R_Un' CoreSystemTypes.Double); break;            case OpCode.Unbox: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Unbox); break;            case OpCode.Throw: statement = new Throw(PopOperand()); transferStatement = true; goto done;            case OpCode.Ldfld:               expr = new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment);              break;            case OpCode.Ldflda:               expr = SetType(new UnaryExpression(new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf));               break;            case OpCode.Stfld: statement = this.ParseStoreField(); goto done;            case OpCode.Ldsfld: expr = new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldsflda: expr = SetType(new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf)); break;            case OpCode.Stsfld: statement = new AssignmentStatement(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' PopOperand()); goto done;            case OpCode.Stobj: statement = this.ParseStoreIndirect((TypeNode)this.GetMemberFromToken()); goto done;            case OpCode.Conv_Ovf_I1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_I2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_I4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_I8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_U2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_U4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_U8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64); break;            case OpCode.Conv_Ovf_I_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr); break;            case OpCode.Box:               TypeNode t = (TypeNode)this.GetMemberFromToken();              TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;              expr = new BinaryExpression(PopOperand()' new Literal(t' CoreSystemTypes.Type)' NodeType.Box' bt); break;            case OpCode.Newarr: expr = this.ParseNewArray(); break;            case OpCode.Ldlen: expr = new UnaryExpression(PopOperand()' NodeType.Ldlen' CoreSystemTypes.UIntPtr); break;            case OpCode.Ldelema: expr = this.ParseArrayElementLoadAddress(); break;            case OpCode.Ldelem_I1:             case OpCode.Ldelem_U1:             case OpCode.Ldelem_I2:             case OpCode.Ldelem_U2:             case OpCode.Ldelem_I4:             case OpCode.Ldelem_U4:             case OpCode.Ldelem_I8:             case OpCode.Ldelem_I:             case OpCode.Ldelem_R4:             case OpCode.Ldelem_R8:             case OpCode.Ldelem_Ref: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem_I:            case OpCode.Stelem_I1:            case OpCode.Stelem_I2:            case OpCode.Stelem_I4:            case OpCode.Stelem_I8:            case OpCode.Stelem_R4:            case OpCode.Stelem_R8:            case OpCode.Stelem_Ref: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Ldelem: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Unbox_Any: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.UnboxAny); break;            case OpCode.Conv_Ovf_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64); break;            case OpCode.Refanyval: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr); break;            case OpCode.Ckfinite: expr = this.ParseUnaryOperation(NodeType.Ckfinite); break;            case OpCode.Mkrefany: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference); break;            case OpCode.Ldtoken: expr = ParseLoadRuntimeMetadataToken(); break;            case OpCode.Conv_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Add_Ovf: expr = this.ParseBinaryOperation(NodeType.Add_Ovf); break;            case OpCode.Add_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Add_Ovf_Un); break;            case OpCode.Mul_Ovf: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf); break;            case OpCode.Mul_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf_Un); break;            case OpCode.Sub_Ovf: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf); break;            case OpCode.Sub_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf_Un); break;            case OpCode.Endfinally: statement = new EndFinally(); transferStatement = true; goto done;            case OpCode.Leave: statement = this.ParseBranch(NodeType.Nop' 0' false' false' true); transferStatement = true; goto done;            case OpCode.Leave_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false' true); transferStatement = true; goto done;            case OpCode.Stind_I: statement = this.ParseStoreIndirect(CoreSystemTypes.IntPtr); goto done;            case OpCode.Conv_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Arglist: expr = new Expression(NodeType.Arglist' CoreSystemTypes.ArgIterator); break;            case OpCode.Ceq: expr = this.ParseBinaryComparison(NodeType.Ceq); break;            case OpCode.Cgt: expr = this.ParseBinaryComparison(NodeType.Cgt); break;            case OpCode.Cgt_Un: expr = this.ParseBinaryComparison(NodeType.Cgt_Un); break;            case OpCode.Clt: expr = this.ParseBinaryComparison(NodeType.Clt); break;            case OpCode.Clt_Un: expr = this.ParseBinaryComparison(NodeType.Clt_Un); break;            case OpCode.Ldftn: expr = new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldvirtftn: expr = new BinaryExpression(PopOperand()' new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldarg: expr = this.Parameters((ushort)this.GetInt16()); break;            case OpCode.Ldarga: expr = SetType(new UnaryExpression(this.Parameters((ushort)this.GetInt16())' NodeType.AddressOf)); break;            case OpCode.Starg: statement = new AssignmentStatement(this.Parameters((ushort)this.GetInt16())' PopOperand()); goto done;            case OpCode.Ldloc: expr = this.locals[(ushort)this.GetInt16()]; break;            case OpCode.Ldloca: expr = SetType(new UnaryExpression(this.locals[(ushort)this.GetInt16()]' NodeType.AddressOf)); break;            case OpCode.Stloc: statement = new AssignmentStatement(this.locals[(ushort)this.GetInt16()]' PopOperand()); goto done;            case OpCode.Localloc: expr = new UnaryExpression(PopOperand()' NodeType.Localloc' CoreSystemTypes.Void); break;            case OpCode.Endfilter: statement = new EndFilter(PopOperand()); transferStatement = true; goto done;            case OpCode.Unaligned_: this.alignment = this.GetByte(); continue;            case OpCode.Volatile_: this.isVolatile = true; continue;            case OpCode.Tail_: this.isTailCall = true; continue;            case OpCode.Initobj: statement = this.ParseInitObject(); goto done;            case OpCode.Constrained_: this.constraint = this.GetMemberFromToken() as TypeNode; continue;            case OpCode.Cpblk: expr = this.ParseTernaryOperation(NodeType.Cpblk); goto done;            case OpCode.Initblk: expr = this.ParseTernaryOperation(NodeType.Initblk); goto done;            case OpCode.Rethrow: statement = new Throw(null); statement.NodeType = NodeType.Rethrow; transferStatement = true; goto done;            case OpCode.Sizeof: expr = new UnaryExpression(new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32); break;            case OpCode.Refanytype: expr = new UnaryExpression(PopOperand()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle); break;            case OpCode.Readonly_: this.isReadOnly = true; continue;            default: throw new InvalidMetadataException(ExceptionStrings.UnknownOpCode);          }          if (this.blockMap[this.counter+1] != null){            transferStatement = true; //Falls through to the next basic block' so implicitly a "transfer" statement            goto done;          }          //^ assume expr != null;  #if FxCop          expr.sourceContext = sourceContext;  #endif  #if FxCop || ILOFFSETS          expr.ILOffset = this.ilOffset;  #endif          this.operandStack.Push(expr);          this.isReadOnly = false;          this.isVolatile = false;          this.isTailCall = false;                  this.alignment = -1;        }
Magic Number,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true){          bool isStatement = false;          startingAddress = this.counter+1; //Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  #if FxCop || ILOFFSETS          this.ilOffset = this.counter;          this.opCode = this.GetOpCode();  #else          OpCode opCode = this.GetOpCode();  #endif  #if FxCop          if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){            expr.sourceContext = sourceContext;            expr.ILOffset = this.ilOffset;            this.operandStack.Push(expr);          }  #endif          switch (opCode){            case OpCode.Nop: statement = new Statement(NodeType.Nop); goto done;            case OpCode.Break: statement = new Statement(NodeType.DebugBreak); goto done;            case OpCode.Ldarg_0: expr = this.Parameters(0); break;            case OpCode.Ldarg_1: expr = this.Parameters(1); break;            case OpCode.Ldarg_2: expr = this.Parameters(2); break;            case OpCode.Ldarg_3: expr = this.Parameters(3); break;            case OpCode.Ldloc_0: expr = this.locals[0]; break;            case OpCode.Ldloc_1: expr = this.locals[1]; break;            case OpCode.Ldloc_2: expr = this.locals[2]; break;            case OpCode.Ldloc_3: expr = this.locals[3]; break;            case OpCode.Stloc_0: statement = new AssignmentStatement(this.locals[0]' PopOperand()); goto done;            case OpCode.Stloc_1: statement = new AssignmentStatement(this.locals[1]' PopOperand()); goto done;            case OpCode.Stloc_2: statement = new AssignmentStatement(this.locals[2]' PopOperand()); goto done;            case OpCode.Stloc_3: statement = new AssignmentStatement(this.locals[3]' PopOperand()); goto done;            case OpCode.Ldarg_S: expr = this.Parameters(this.GetByte()); break;            case OpCode.Ldarga_S: expr = SetType(new UnaryExpression(this.Parameters(this.GetByte())' NodeType.AddressOf)); break;            case OpCode.Starg_S: statement = new AssignmentStatement(this.Parameters(this.GetByte())' PopOperand()); goto done;            case OpCode.Ldloc_S: expr = this.locals[this.GetByte()]; break;            case OpCode.Ldloca_S: expr = SetType(new UnaryExpression(this.locals[this.GetByte()]' NodeType.AddressOf)); break;            case OpCode.Stloc_S: statement = new AssignmentStatement(this.locals[this.GetByte()]' PopOperand()); goto done;            case OpCode.Ldnull: expr = new Literal(null' CoreSystemTypes.Object); break;            case OpCode.Ldc_I4_M1: expr = new Literal(-1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_0: expr = new Literal(0' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_1: expr = new Literal(1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_2: expr = new Literal(2' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_3: expr = new Literal(3' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_4: expr = new Literal(4' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_5: expr = new Literal(5' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_6: expr = new Literal(6' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_7: expr = new Literal(7' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_8: expr = new Literal(8' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_S: expr = new Literal((int)this.GetSByte()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4: expr = new Literal(this.GetInt32()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I8: expr = new Literal(this.GetInt64()' CoreSystemTypes.Int64); break;            case OpCode.Ldc_R4: expr = new Literal(this.GetSingle()' CoreSystemTypes.Single); break;            case OpCode.Ldc_R8: expr = new Literal(this.GetDouble()' CoreSystemTypes.Double); break;            case OpCode.Dup: statement = new ExpressionStatement(new Expression(NodeType.Dup)); goto done;            case OpCode.Pop: statement = new ExpressionStatement(new UnaryExpression(PopOperand()' NodeType.Pop)); goto done;            case OpCode.Jmp: expr = this.ParseCall(NodeType.Jmp' out isStatement); if (isStatement) goto done; break;            case OpCode.Call: expr = this.ParseCall(NodeType.Call' out isStatement); if (isStatement) goto done; break;            case OpCode.Calli: expr = this.ParseCalli(out isStatement); if (isStatement) goto done; break;            case OpCode.Ret:              Expression retVal = BodyParser.TypeIsVoid(this.method.ReturnType) ? null : PopOperand();              statement = new Return(retVal);               transferStatement = true; goto done;            case OpCode.Br_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false); transferStatement = true; goto done;            case OpCode.Brfalse_S: statement = this.ParseBranch(NodeType.LogicalNot' 1' true' false); transferStatement = true; goto done;            case OpCode.Brtrue_S: statement = this.ParseBranch(NodeType.Nop' 1' true' false); transferStatement = true; goto done;            case OpCode.Beq_S: statement = this.ParseBranch(NodeType.Eq' 2' true' false); transferStatement = true; goto done;            case OpCode.Bge_S: statement = this.ParseBranch(NodeType.Ge' 2' true' false); transferStatement = true; goto done;            case OpCode.Bgt_S: statement = this.ParseBranch(NodeType.Gt' 2' true' false); transferStatement = true; goto done;            case OpCode.Ble_S: statement = this.ParseBranch(NodeType.Le' 2' true' false); transferStatement = true; goto done;            case OpCode.Blt_S: statement = this.ParseBranch(NodeType.Lt' 2' true' false); transferStatement = true; goto done;            case OpCode.Bne_Un_S: statement = this.ParseBranch(NodeType.Ne' 2' true' true); transferStatement = true; goto done;            case OpCode.Bge_Un_S: statement = this.ParseBranch(NodeType.Ge' 2' true' true); transferStatement = true; goto done;            case OpCode.Bgt_Un_S: statement = this.ParseBranch(NodeType.Gt' 2' true' true); transferStatement = true; goto done;            case OpCode.Ble_Un_S: statement = this.ParseBranch(NodeType.Le' 2' true' true); transferStatement = true; goto done;            case OpCode.Blt_Un_S: statement = this.ParseBranch(NodeType.Lt' 2' true' true); transferStatement = true; goto done;            case OpCode.Br: statement = this.ParseBranch(NodeType.Nop' 0' false' false); transferStatement = true; goto done;            case OpCode.Brfalse: statement = this.ParseBranch(NodeType.LogicalNot' 1' false' false); transferStatement = true; goto done;            case OpCode.Brtrue: statement = this.ParseBranch(NodeType.Nop' 1' false' false); transferStatement = true; goto done;            case OpCode.Beq: statement = this.ParseBranch(NodeType.Eq' 2' false' false); transferStatement = true; goto done;            case OpCode.Bge: statement = this.ParseBranch(NodeType.Ge' 2' false' false); transferStatement = true; goto done;            case OpCode.Bgt: statement = this.ParseBranch(NodeType.Gt' 2' false' false); transferStatement = true; goto done;            case OpCode.Ble: statement = this.ParseBranch(NodeType.Le' 2' false' false); transferStatement = true; goto done;            case OpCode.Blt: statement = this.ParseBranch(NodeType.Lt' 2' false' false); transferStatement = true; goto done;            case OpCode.Bne_Un: statement = this.ParseBranch(NodeType.Ne' 2' false' true); transferStatement = true; goto done;            case OpCode.Bge_Un: statement = this.ParseBranch(NodeType.Ge' 2' false' true); transferStatement = true; goto done;            case OpCode.Bgt_Un: statement = this.ParseBranch(NodeType.Gt' 2' false' true); transferStatement = true; goto done;            case OpCode.Ble_Un: statement = this.ParseBranch(NodeType.Le' 2' false' true); transferStatement = true; goto done;            case OpCode.Blt_Un: statement = this.ParseBranch(NodeType.Lt' 2' false' true); transferStatement = true; goto done;            case OpCode.Switch: statement = this.ParseSwitchInstruction(); transferStatement = true; goto done;            case OpCode.Ldind_I1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int64' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I: expr = new AddressDereference(PopOperand()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Single' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Double' this.isVolatile' this.alignment); break;            case OpCode.Ldind_Ref: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Object' this.isVolatile' this.alignment); break;            case OpCode.Stind_Ref: statement = this.ParseStoreIndirect(CoreSystemTypes.Object); goto done;            case OpCode.Stind_I1: statement = this.ParseStoreIndirect(CoreSystemTypes.Int8); goto done;            case OpCode.Stind_I2: statement = this.ParseStoreIndirect(CoreSystemTypes.Int16); goto done;            case OpCode.Stind_I4: statement = this.ParseStoreIndirect(CoreSystemTypes.Int32); goto done;            case OpCode.Stind_I8: statement = this.ParseStoreIndirect(CoreSystemTypes.Int64); goto done;            case OpCode.Stind_R4: statement = this.ParseStoreIndirect(CoreSystemTypes.Single); goto done;            case OpCode.Stind_R8: statement = this.ParseStoreIndirect(CoreSystemTypes.Double); goto done;            case OpCode.Add: expr = this.ParseBinaryOperation(NodeType.Add); break;            case OpCode.Sub: expr = this.ParseBinaryOperation(NodeType.Sub); break;            case OpCode.Mul: expr = this.ParseBinaryOperation(NodeType.Mul); break;            case OpCode.Div: expr = this.ParseBinaryOperation(NodeType.Div); break;            case OpCode.Div_Un: expr = this.ParseBinaryOperation(NodeType.Div_Un); break;            case OpCode.Rem: expr = this.ParseBinaryOperation(NodeType.Rem); break;            case OpCode.Rem_Un: expr = this.ParseBinaryOperation(NodeType.Rem_Un); break;            case OpCode.And: expr = this.ParseBinaryOperation(NodeType.And); break;            case OpCode.Or: expr = this.ParseBinaryOperation(NodeType.Or); break;            case OpCode.Xor: expr = this.ParseBinaryOperation(NodeType.Xor); break;            case OpCode.Shl: expr = this.ParseBinaryOperation(NodeType.Shl); break;            case OpCode.Shr: expr = this.ParseBinaryOperation(NodeType.Shr); break;            case OpCode.Shr_Un: expr = this.ParseBinaryOperation(NodeType.Shr_Un); break;            case OpCode.Neg: expr = this.ParseUnaryOperation(NodeType.Neg); break;            case OpCode.Not: expr = this.ParseUnaryOperation(NodeType.Not); break;            case OpCode.Conv_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_R4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R4' CoreSystemTypes.Single); break;            case OpCode.Conv_R8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R8' CoreSystemTypes.Double); break;            case OpCode.Conv_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U8' CoreSystemTypes.UInt64); break;            case OpCode.Callvirt: expr = this.ParseCall(NodeType.Callvirt' out isStatement); if (isStatement) goto done; break;            case OpCode.Cpobj: statement = this.ParseCopyObject(); goto done;            case OpCode.Ldobj: expr = new AddressDereference(PopOperand()' (TypeNode)this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldstr: expr = new Literal(this.GetStringFromToken()' CoreSystemTypes.String); break;            case OpCode.Newobj: expr = this.ParseConstruct(); break;            case OpCode.Castclass: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Castclass); break;            case OpCode.Isinst: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Isinst); break;            case OpCode.Conv_R_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R_Un' CoreSystemTypes.Double); break;            case OpCode.Unbox: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Unbox); break;            case OpCode.Throw: statement = new Throw(PopOperand()); transferStatement = true; goto done;            case OpCode.Ldfld:               expr = new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment);              break;            case OpCode.Ldflda:               expr = SetType(new UnaryExpression(new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf));               break;            case OpCode.Stfld: statement = this.ParseStoreField(); goto done;            case OpCode.Ldsfld: expr = new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldsflda: expr = SetType(new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf)); break;            case OpCode.Stsfld: statement = new AssignmentStatement(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' PopOperand()); goto done;            case OpCode.Stobj: statement = this.ParseStoreIndirect((TypeNode)this.GetMemberFromToken()); goto done;            case OpCode.Conv_Ovf_I1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_I2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_I4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_I8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_U2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_U4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_U8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64); break;            case OpCode.Conv_Ovf_I_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr); break;            case OpCode.Box:               TypeNode t = (TypeNode)this.GetMemberFromToken();              TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;              expr = new BinaryExpression(PopOperand()' new Literal(t' CoreSystemTypes.Type)' NodeType.Box' bt); break;            case OpCode.Newarr: expr = this.ParseNewArray(); break;            case OpCode.Ldlen: expr = new UnaryExpression(PopOperand()' NodeType.Ldlen' CoreSystemTypes.UIntPtr); break;            case OpCode.Ldelema: expr = this.ParseArrayElementLoadAddress(); break;            case OpCode.Ldelem_I1:             case OpCode.Ldelem_U1:             case OpCode.Ldelem_I2:             case OpCode.Ldelem_U2:             case OpCode.Ldelem_I4:             case OpCode.Ldelem_U4:             case OpCode.Ldelem_I8:             case OpCode.Ldelem_I:             case OpCode.Ldelem_R4:             case OpCode.Ldelem_R8:             case OpCode.Ldelem_Ref: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem_I:            case OpCode.Stelem_I1:            case OpCode.Stelem_I2:            case OpCode.Stelem_I4:            case OpCode.Stelem_I8:            case OpCode.Stelem_R4:            case OpCode.Stelem_R8:            case OpCode.Stelem_Ref: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Ldelem: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Unbox_Any: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.UnboxAny); break;            case OpCode.Conv_Ovf_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64); break;            case OpCode.Refanyval: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr); break;            case OpCode.Ckfinite: expr = this.ParseUnaryOperation(NodeType.Ckfinite); break;            case OpCode.Mkrefany: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference); break;            case OpCode.Ldtoken: expr = ParseLoadRuntimeMetadataToken(); break;            case OpCode.Conv_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Add_Ovf: expr = this.ParseBinaryOperation(NodeType.Add_Ovf); break;            case OpCode.Add_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Add_Ovf_Un); break;            case OpCode.Mul_Ovf: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf); break;            case OpCode.Mul_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf_Un); break;            case OpCode.Sub_Ovf: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf); break;            case OpCode.Sub_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf_Un); break;            case OpCode.Endfinally: statement = new EndFinally(); transferStatement = true; goto done;            case OpCode.Leave: statement = this.ParseBranch(NodeType.Nop' 0' false' false' true); transferStatement = true; goto done;            case OpCode.Leave_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false' true); transferStatement = true; goto done;            case OpCode.Stind_I: statement = this.ParseStoreIndirect(CoreSystemTypes.IntPtr); goto done;            case OpCode.Conv_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Arglist: expr = new Expression(NodeType.Arglist' CoreSystemTypes.ArgIterator); break;            case OpCode.Ceq: expr = this.ParseBinaryComparison(NodeType.Ceq); break;            case OpCode.Cgt: expr = this.ParseBinaryComparison(NodeType.Cgt); break;            case OpCode.Cgt_Un: expr = this.ParseBinaryComparison(NodeType.Cgt_Un); break;            case OpCode.Clt: expr = this.ParseBinaryComparison(NodeType.Clt); break;            case OpCode.Clt_Un: expr = this.ParseBinaryComparison(NodeType.Clt_Un); break;            case OpCode.Ldftn: expr = new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldvirtftn: expr = new BinaryExpression(PopOperand()' new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldarg: expr = this.Parameters((ushort)this.GetInt16()); break;            case OpCode.Ldarga: expr = SetType(new UnaryExpression(this.Parameters((ushort)this.GetInt16())' NodeType.AddressOf)); break;            case OpCode.Starg: statement = new AssignmentStatement(this.Parameters((ushort)this.GetInt16())' PopOperand()); goto done;            case OpCode.Ldloc: expr = this.locals[(ushort)this.GetInt16()]; break;            case OpCode.Ldloca: expr = SetType(new UnaryExpression(this.locals[(ushort)this.GetInt16()]' NodeType.AddressOf)); break;            case OpCode.Stloc: statement = new AssignmentStatement(this.locals[(ushort)this.GetInt16()]' PopOperand()); goto done;            case OpCode.Localloc: expr = new UnaryExpression(PopOperand()' NodeType.Localloc' CoreSystemTypes.Void); break;            case OpCode.Endfilter: statement = new EndFilter(PopOperand()); transferStatement = true; goto done;            case OpCode.Unaligned_: this.alignment = this.GetByte(); continue;            case OpCode.Volatile_: this.isVolatile = true; continue;            case OpCode.Tail_: this.isTailCall = true; continue;            case OpCode.Initobj: statement = this.ParseInitObject(); goto done;            case OpCode.Constrained_: this.constraint = this.GetMemberFromToken() as TypeNode; continue;            case OpCode.Cpblk: expr = this.ParseTernaryOperation(NodeType.Cpblk); goto done;            case OpCode.Initblk: expr = this.ParseTernaryOperation(NodeType.Initblk); goto done;            case OpCode.Rethrow: statement = new Throw(null); statement.NodeType = NodeType.Rethrow; transferStatement = true; goto done;            case OpCode.Sizeof: expr = new UnaryExpression(new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32); break;            case OpCode.Refanytype: expr = new UnaryExpression(PopOperand()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle); break;            case OpCode.Readonly_: this.isReadOnly = true; continue;            default: throw new InvalidMetadataException(ExceptionStrings.UnknownOpCode);          }          if (this.blockMap[this.counter+1] != null){            transferStatement = true; //Falls through to the next basic block' so implicitly a "transfer" statement            goto done;          }          //^ assume expr != null;  #if FxCop          expr.sourceContext = sourceContext;  #endif  #if FxCop || ILOFFSETS          expr.ILOffset = this.ilOffset;  #endif          this.operandStack.Push(expr);          this.isReadOnly = false;          this.isVolatile = false;          this.isTailCall = false;                  this.alignment = -1;        }
Magic Number,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true){          bool isStatement = false;          startingAddress = this.counter+1; //Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  #if FxCop || ILOFFSETS          this.ilOffset = this.counter;          this.opCode = this.GetOpCode();  #else          OpCode opCode = this.GetOpCode();  #endif  #if FxCop          if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){            expr.sourceContext = sourceContext;            expr.ILOffset = this.ilOffset;            this.operandStack.Push(expr);          }  #endif          switch (opCode){            case OpCode.Nop: statement = new Statement(NodeType.Nop); goto done;            case OpCode.Break: statement = new Statement(NodeType.DebugBreak); goto done;            case OpCode.Ldarg_0: expr = this.Parameters(0); break;            case OpCode.Ldarg_1: expr = this.Parameters(1); break;            case OpCode.Ldarg_2: expr = this.Parameters(2); break;            case OpCode.Ldarg_3: expr = this.Parameters(3); break;            case OpCode.Ldloc_0: expr = this.locals[0]; break;            case OpCode.Ldloc_1: expr = this.locals[1]; break;            case OpCode.Ldloc_2: expr = this.locals[2]; break;            case OpCode.Ldloc_3: expr = this.locals[3]; break;            case OpCode.Stloc_0: statement = new AssignmentStatement(this.locals[0]' PopOperand()); goto done;            case OpCode.Stloc_1: statement = new AssignmentStatement(this.locals[1]' PopOperand()); goto done;            case OpCode.Stloc_2: statement = new AssignmentStatement(this.locals[2]' PopOperand()); goto done;            case OpCode.Stloc_3: statement = new AssignmentStatement(this.locals[3]' PopOperand()); goto done;            case OpCode.Ldarg_S: expr = this.Parameters(this.GetByte()); break;            case OpCode.Ldarga_S: expr = SetType(new UnaryExpression(this.Parameters(this.GetByte())' NodeType.AddressOf)); break;            case OpCode.Starg_S: statement = new AssignmentStatement(this.Parameters(this.GetByte())' PopOperand()); goto done;            case OpCode.Ldloc_S: expr = this.locals[this.GetByte()]; break;            case OpCode.Ldloca_S: expr = SetType(new UnaryExpression(this.locals[this.GetByte()]' NodeType.AddressOf)); break;            case OpCode.Stloc_S: statement = new AssignmentStatement(this.locals[this.GetByte()]' PopOperand()); goto done;            case OpCode.Ldnull: expr = new Literal(null' CoreSystemTypes.Object); break;            case OpCode.Ldc_I4_M1: expr = new Literal(-1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_0: expr = new Literal(0' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_1: expr = new Literal(1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_2: expr = new Literal(2' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_3: expr = new Literal(3' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_4: expr = new Literal(4' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_5: expr = new Literal(5' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_6: expr = new Literal(6' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_7: expr = new Literal(7' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_8: expr = new Literal(8' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_S: expr = new Literal((int)this.GetSByte()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4: expr = new Literal(this.GetInt32()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I8: expr = new Literal(this.GetInt64()' CoreSystemTypes.Int64); break;            case OpCode.Ldc_R4: expr = new Literal(this.GetSingle()' CoreSystemTypes.Single); break;            case OpCode.Ldc_R8: expr = new Literal(this.GetDouble()' CoreSystemTypes.Double); break;            case OpCode.Dup: statement = new ExpressionStatement(new Expression(NodeType.Dup)); goto done;            case OpCode.Pop: statement = new ExpressionStatement(new UnaryExpression(PopOperand()' NodeType.Pop)); goto done;            case OpCode.Jmp: expr = this.ParseCall(NodeType.Jmp' out isStatement); if (isStatement) goto done; break;            case OpCode.Call: expr = this.ParseCall(NodeType.Call' out isStatement); if (isStatement) goto done; break;            case OpCode.Calli: expr = this.ParseCalli(out isStatement); if (isStatement) goto done; break;            case OpCode.Ret:              Expression retVal = BodyParser.TypeIsVoid(this.method.ReturnType) ? null : PopOperand();              statement = new Return(retVal);               transferStatement = true; goto done;            case OpCode.Br_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false); transferStatement = true; goto done;            case OpCode.Brfalse_S: statement = this.ParseBranch(NodeType.LogicalNot' 1' true' false); transferStatement = true; goto done;            case OpCode.Brtrue_S: statement = this.ParseBranch(NodeType.Nop' 1' true' false); transferStatement = true; goto done;            case OpCode.Beq_S: statement = this.ParseBranch(NodeType.Eq' 2' true' false); transferStatement = true; goto done;            case OpCode.Bge_S: statement = this.ParseBranch(NodeType.Ge' 2' true' false); transferStatement = true; goto done;            case OpCode.Bgt_S: statement = this.ParseBranch(NodeType.Gt' 2' true' false); transferStatement = true; goto done;            case OpCode.Ble_S: statement = this.ParseBranch(NodeType.Le' 2' true' false); transferStatement = true; goto done;            case OpCode.Blt_S: statement = this.ParseBranch(NodeType.Lt' 2' true' false); transferStatement = true; goto done;            case OpCode.Bne_Un_S: statement = this.ParseBranch(NodeType.Ne' 2' true' true); transferStatement = true; goto done;            case OpCode.Bge_Un_S: statement = this.ParseBranch(NodeType.Ge' 2' true' true); transferStatement = true; goto done;            case OpCode.Bgt_Un_S: statement = this.ParseBranch(NodeType.Gt' 2' true' true); transferStatement = true; goto done;            case OpCode.Ble_Un_S: statement = this.ParseBranch(NodeType.Le' 2' true' true); transferStatement = true; goto done;            case OpCode.Blt_Un_S: statement = this.ParseBranch(NodeType.Lt' 2' true' true); transferStatement = true; goto done;            case OpCode.Br: statement = this.ParseBranch(NodeType.Nop' 0' false' false); transferStatement = true; goto done;            case OpCode.Brfalse: statement = this.ParseBranch(NodeType.LogicalNot' 1' false' false); transferStatement = true; goto done;            case OpCode.Brtrue: statement = this.ParseBranch(NodeType.Nop' 1' false' false); transferStatement = true; goto done;            case OpCode.Beq: statement = this.ParseBranch(NodeType.Eq' 2' false' false); transferStatement = true; goto done;            case OpCode.Bge: statement = this.ParseBranch(NodeType.Ge' 2' false' false); transferStatement = true; goto done;            case OpCode.Bgt: statement = this.ParseBranch(NodeType.Gt' 2' false' false); transferStatement = true; goto done;            case OpCode.Ble: statement = this.ParseBranch(NodeType.Le' 2' false' false); transferStatement = true; goto done;            case OpCode.Blt: statement = this.ParseBranch(NodeType.Lt' 2' false' false); transferStatement = true; goto done;            case OpCode.Bne_Un: statement = this.ParseBranch(NodeType.Ne' 2' false' true); transferStatement = true; goto done;            case OpCode.Bge_Un: statement = this.ParseBranch(NodeType.Ge' 2' false' true); transferStatement = true; goto done;            case OpCode.Bgt_Un: statement = this.ParseBranch(NodeType.Gt' 2' false' true); transferStatement = true; goto done;            case OpCode.Ble_Un: statement = this.ParseBranch(NodeType.Le' 2' false' true); transferStatement = true; goto done;            case OpCode.Blt_Un: statement = this.ParseBranch(NodeType.Lt' 2' false' true); transferStatement = true; goto done;            case OpCode.Switch: statement = this.ParseSwitchInstruction(); transferStatement = true; goto done;            case OpCode.Ldind_I1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int64' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I: expr = new AddressDereference(PopOperand()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Single' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Double' this.isVolatile' this.alignment); break;            case OpCode.Ldind_Ref: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Object' this.isVolatile' this.alignment); break;            case OpCode.Stind_Ref: statement = this.ParseStoreIndirect(CoreSystemTypes.Object); goto done;            case OpCode.Stind_I1: statement = this.ParseStoreIndirect(CoreSystemTypes.Int8); goto done;            case OpCode.Stind_I2: statement = this.ParseStoreIndirect(CoreSystemTypes.Int16); goto done;            case OpCode.Stind_I4: statement = this.ParseStoreIndirect(CoreSystemTypes.Int32); goto done;            case OpCode.Stind_I8: statement = this.ParseStoreIndirect(CoreSystemTypes.Int64); goto done;            case OpCode.Stind_R4: statement = this.ParseStoreIndirect(CoreSystemTypes.Single); goto done;            case OpCode.Stind_R8: statement = this.ParseStoreIndirect(CoreSystemTypes.Double); goto done;            case OpCode.Add: expr = this.ParseBinaryOperation(NodeType.Add); break;            case OpCode.Sub: expr = this.ParseBinaryOperation(NodeType.Sub); break;            case OpCode.Mul: expr = this.ParseBinaryOperation(NodeType.Mul); break;            case OpCode.Div: expr = this.ParseBinaryOperation(NodeType.Div); break;            case OpCode.Div_Un: expr = this.ParseBinaryOperation(NodeType.Div_Un); break;            case OpCode.Rem: expr = this.ParseBinaryOperation(NodeType.Rem); break;            case OpCode.Rem_Un: expr = this.ParseBinaryOperation(NodeType.Rem_Un); break;            case OpCode.And: expr = this.ParseBinaryOperation(NodeType.And); break;            case OpCode.Or: expr = this.ParseBinaryOperation(NodeType.Or); break;            case OpCode.Xor: expr = this.ParseBinaryOperation(NodeType.Xor); break;            case OpCode.Shl: expr = this.ParseBinaryOperation(NodeType.Shl); break;            case OpCode.Shr: expr = this.ParseBinaryOperation(NodeType.Shr); break;            case OpCode.Shr_Un: expr = this.ParseBinaryOperation(NodeType.Shr_Un); break;            case OpCode.Neg: expr = this.ParseUnaryOperation(NodeType.Neg); break;            case OpCode.Not: expr = this.ParseUnaryOperation(NodeType.Not); break;            case OpCode.Conv_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_R4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R4' CoreSystemTypes.Single); break;            case OpCode.Conv_R8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R8' CoreSystemTypes.Double); break;            case OpCode.Conv_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U8' CoreSystemTypes.UInt64); break;            case OpCode.Callvirt: expr = this.ParseCall(NodeType.Callvirt' out isStatement); if (isStatement) goto done; break;            case OpCode.Cpobj: statement = this.ParseCopyObject(); goto done;            case OpCode.Ldobj: expr = new AddressDereference(PopOperand()' (TypeNode)this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldstr: expr = new Literal(this.GetStringFromToken()' CoreSystemTypes.String); break;            case OpCode.Newobj: expr = this.ParseConstruct(); break;            case OpCode.Castclass: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Castclass); break;            case OpCode.Isinst: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Isinst); break;            case OpCode.Conv_R_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R_Un' CoreSystemTypes.Double); break;            case OpCode.Unbox: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Unbox); break;            case OpCode.Throw: statement = new Throw(PopOperand()); transferStatement = true; goto done;            case OpCode.Ldfld:               expr = new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment);              break;            case OpCode.Ldflda:               expr = SetType(new UnaryExpression(new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf));               break;            case OpCode.Stfld: statement = this.ParseStoreField(); goto done;            case OpCode.Ldsfld: expr = new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldsflda: expr = SetType(new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf)); break;            case OpCode.Stsfld: statement = new AssignmentStatement(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' PopOperand()); goto done;            case OpCode.Stobj: statement = this.ParseStoreIndirect((TypeNode)this.GetMemberFromToken()); goto done;            case OpCode.Conv_Ovf_I1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_I2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_I4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_I8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_U2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_U4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_U8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64); break;            case OpCode.Conv_Ovf_I_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr); break;            case OpCode.Box:               TypeNode t = (TypeNode)this.GetMemberFromToken();              TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;              expr = new BinaryExpression(PopOperand()' new Literal(t' CoreSystemTypes.Type)' NodeType.Box' bt); break;            case OpCode.Newarr: expr = this.ParseNewArray(); break;            case OpCode.Ldlen: expr = new UnaryExpression(PopOperand()' NodeType.Ldlen' CoreSystemTypes.UIntPtr); break;            case OpCode.Ldelema: expr = this.ParseArrayElementLoadAddress(); break;            case OpCode.Ldelem_I1:             case OpCode.Ldelem_U1:             case OpCode.Ldelem_I2:             case OpCode.Ldelem_U2:             case OpCode.Ldelem_I4:             case OpCode.Ldelem_U4:             case OpCode.Ldelem_I8:             case OpCode.Ldelem_I:             case OpCode.Ldelem_R4:             case OpCode.Ldelem_R8:             case OpCode.Ldelem_Ref: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem_I:            case OpCode.Stelem_I1:            case OpCode.Stelem_I2:            case OpCode.Stelem_I4:            case OpCode.Stelem_I8:            case OpCode.Stelem_R4:            case OpCode.Stelem_R8:            case OpCode.Stelem_Ref: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Ldelem: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Unbox_Any: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.UnboxAny); break;            case OpCode.Conv_Ovf_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64); break;            case OpCode.Refanyval: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr); break;            case OpCode.Ckfinite: expr = this.ParseUnaryOperation(NodeType.Ckfinite); break;            case OpCode.Mkrefany: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference); break;            case OpCode.Ldtoken: expr = ParseLoadRuntimeMetadataToken(); break;            case OpCode.Conv_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Add_Ovf: expr = this.ParseBinaryOperation(NodeType.Add_Ovf); break;            case OpCode.Add_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Add_Ovf_Un); break;            case OpCode.Mul_Ovf: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf); break;            case OpCode.Mul_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf_Un); break;            case OpCode.Sub_Ovf: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf); break;            case OpCode.Sub_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf_Un); break;            case OpCode.Endfinally: statement = new EndFinally(); transferStatement = true; goto done;            case OpCode.Leave: statement = this.ParseBranch(NodeType.Nop' 0' false' false' true); transferStatement = true; goto done;            case OpCode.Leave_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false' true); transferStatement = true; goto done;            case OpCode.Stind_I: statement = this.ParseStoreIndirect(CoreSystemTypes.IntPtr); goto done;            case OpCode.Conv_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Arglist: expr = new Expression(NodeType.Arglist' CoreSystemTypes.ArgIterator); break;            case OpCode.Ceq: expr = this.ParseBinaryComparison(NodeType.Ceq); break;            case OpCode.Cgt: expr = this.ParseBinaryComparison(NodeType.Cgt); break;            case OpCode.Cgt_Un: expr = this.ParseBinaryComparison(NodeType.Cgt_Un); break;            case OpCode.Clt: expr = this.ParseBinaryComparison(NodeType.Clt); break;            case OpCode.Clt_Un: expr = this.ParseBinaryComparison(NodeType.Clt_Un); break;            case OpCode.Ldftn: expr = new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldvirtftn: expr = new BinaryExpression(PopOperand()' new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldarg: expr = this.Parameters((ushort)this.GetInt16()); break;            case OpCode.Ldarga: expr = SetType(new UnaryExpression(this.Parameters((ushort)this.GetInt16())' NodeType.AddressOf)); break;            case OpCode.Starg: statement = new AssignmentStatement(this.Parameters((ushort)this.GetInt16())' PopOperand()); goto done;            case OpCode.Ldloc: expr = this.locals[(ushort)this.GetInt16()]; break;            case OpCode.Ldloca: expr = SetType(new UnaryExpression(this.locals[(ushort)this.GetInt16()]' NodeType.AddressOf)); break;            case OpCode.Stloc: statement = new AssignmentStatement(this.locals[(ushort)this.GetInt16()]' PopOperand()); goto done;            case OpCode.Localloc: expr = new UnaryExpression(PopOperand()' NodeType.Localloc' CoreSystemTypes.Void); break;            case OpCode.Endfilter: statement = new EndFilter(PopOperand()); transferStatement = true; goto done;            case OpCode.Unaligned_: this.alignment = this.GetByte(); continue;            case OpCode.Volatile_: this.isVolatile = true; continue;            case OpCode.Tail_: this.isTailCall = true; continue;            case OpCode.Initobj: statement = this.ParseInitObject(); goto done;            case OpCode.Constrained_: this.constraint = this.GetMemberFromToken() as TypeNode; continue;            case OpCode.Cpblk: expr = this.ParseTernaryOperation(NodeType.Cpblk); goto done;            case OpCode.Initblk: expr = this.ParseTernaryOperation(NodeType.Initblk); goto done;            case OpCode.Rethrow: statement = new Throw(null); statement.NodeType = NodeType.Rethrow; transferStatement = true; goto done;            case OpCode.Sizeof: expr = new UnaryExpression(new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32); break;            case OpCode.Refanytype: expr = new UnaryExpression(PopOperand()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle); break;            case OpCode.Readonly_: this.isReadOnly = true; continue;            default: throw new InvalidMetadataException(ExceptionStrings.UnknownOpCode);          }          if (this.blockMap[this.counter+1] != null){            transferStatement = true; //Falls through to the next basic block' so implicitly a "transfer" statement            goto done;          }          //^ assume expr != null;  #if FxCop          expr.sourceContext = sourceContext;  #endif  #if FxCop || ILOFFSETS          expr.ILOffset = this.ilOffset;  #endif          this.operandStack.Push(expr);          this.isReadOnly = false;          this.isVolatile = false;          this.isTailCall = false;                  this.alignment = -1;        }
Magic Number,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true){          bool isStatement = false;          startingAddress = this.counter+1; //Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  #if FxCop || ILOFFSETS          this.ilOffset = this.counter;          this.opCode = this.GetOpCode();  #else          OpCode opCode = this.GetOpCode();  #endif  #if FxCop          if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){            expr.sourceContext = sourceContext;            expr.ILOffset = this.ilOffset;            this.operandStack.Push(expr);          }  #endif          switch (opCode){            case OpCode.Nop: statement = new Statement(NodeType.Nop); goto done;            case OpCode.Break: statement = new Statement(NodeType.DebugBreak); goto done;            case OpCode.Ldarg_0: expr = this.Parameters(0); break;            case OpCode.Ldarg_1: expr = this.Parameters(1); break;            case OpCode.Ldarg_2: expr = this.Parameters(2); break;            case OpCode.Ldarg_3: expr = this.Parameters(3); break;            case OpCode.Ldloc_0: expr = this.locals[0]; break;            case OpCode.Ldloc_1: expr = this.locals[1]; break;            case OpCode.Ldloc_2: expr = this.locals[2]; break;            case OpCode.Ldloc_3: expr = this.locals[3]; break;            case OpCode.Stloc_0: statement = new AssignmentStatement(this.locals[0]' PopOperand()); goto done;            case OpCode.Stloc_1: statement = new AssignmentStatement(this.locals[1]' PopOperand()); goto done;            case OpCode.Stloc_2: statement = new AssignmentStatement(this.locals[2]' PopOperand()); goto done;            case OpCode.Stloc_3: statement = new AssignmentStatement(this.locals[3]' PopOperand()); goto done;            case OpCode.Ldarg_S: expr = this.Parameters(this.GetByte()); break;            case OpCode.Ldarga_S: expr = SetType(new UnaryExpression(this.Parameters(this.GetByte())' NodeType.AddressOf)); break;            case OpCode.Starg_S: statement = new AssignmentStatement(this.Parameters(this.GetByte())' PopOperand()); goto done;            case OpCode.Ldloc_S: expr = this.locals[this.GetByte()]; break;            case OpCode.Ldloca_S: expr = SetType(new UnaryExpression(this.locals[this.GetByte()]' NodeType.AddressOf)); break;            case OpCode.Stloc_S: statement = new AssignmentStatement(this.locals[this.GetByte()]' PopOperand()); goto done;            case OpCode.Ldnull: expr = new Literal(null' CoreSystemTypes.Object); break;            case OpCode.Ldc_I4_M1: expr = new Literal(-1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_0: expr = new Literal(0' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_1: expr = new Literal(1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_2: expr = new Literal(2' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_3: expr = new Literal(3' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_4: expr = new Literal(4' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_5: expr = new Literal(5' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_6: expr = new Literal(6' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_7: expr = new Literal(7' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_8: expr = new Literal(8' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_S: expr = new Literal((int)this.GetSByte()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4: expr = new Literal(this.GetInt32()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I8: expr = new Literal(this.GetInt64()' CoreSystemTypes.Int64); break;            case OpCode.Ldc_R4: expr = new Literal(this.GetSingle()' CoreSystemTypes.Single); break;            case OpCode.Ldc_R8: expr = new Literal(this.GetDouble()' CoreSystemTypes.Double); break;            case OpCode.Dup: statement = new ExpressionStatement(new Expression(NodeType.Dup)); goto done;            case OpCode.Pop: statement = new ExpressionStatement(new UnaryExpression(PopOperand()' NodeType.Pop)); goto done;            case OpCode.Jmp: expr = this.ParseCall(NodeType.Jmp' out isStatement); if (isStatement) goto done; break;            case OpCode.Call: expr = this.ParseCall(NodeType.Call' out isStatement); if (isStatement) goto done; break;            case OpCode.Calli: expr = this.ParseCalli(out isStatement); if (isStatement) goto done; break;            case OpCode.Ret:              Expression retVal = BodyParser.TypeIsVoid(this.method.ReturnType) ? null : PopOperand();              statement = new Return(retVal);               transferStatement = true; goto done;            case OpCode.Br_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false); transferStatement = true; goto done;            case OpCode.Brfalse_S: statement = this.ParseBranch(NodeType.LogicalNot' 1' true' false); transferStatement = true; goto done;            case OpCode.Brtrue_S: statement = this.ParseBranch(NodeType.Nop' 1' true' false); transferStatement = true; goto done;            case OpCode.Beq_S: statement = this.ParseBranch(NodeType.Eq' 2' true' false); transferStatement = true; goto done;            case OpCode.Bge_S: statement = this.ParseBranch(NodeType.Ge' 2' true' false); transferStatement = true; goto done;            case OpCode.Bgt_S: statement = this.ParseBranch(NodeType.Gt' 2' true' false); transferStatement = true; goto done;            case OpCode.Ble_S: statement = this.ParseBranch(NodeType.Le' 2' true' false); transferStatement = true; goto done;            case OpCode.Blt_S: statement = this.ParseBranch(NodeType.Lt' 2' true' false); transferStatement = true; goto done;            case OpCode.Bne_Un_S: statement = this.ParseBranch(NodeType.Ne' 2' true' true); transferStatement = true; goto done;            case OpCode.Bge_Un_S: statement = this.ParseBranch(NodeType.Ge' 2' true' true); transferStatement = true; goto done;            case OpCode.Bgt_Un_S: statement = this.ParseBranch(NodeType.Gt' 2' true' true); transferStatement = true; goto done;            case OpCode.Ble_Un_S: statement = this.ParseBranch(NodeType.Le' 2' true' true); transferStatement = true; goto done;            case OpCode.Blt_Un_S: statement = this.ParseBranch(NodeType.Lt' 2' true' true); transferStatement = true; goto done;            case OpCode.Br: statement = this.ParseBranch(NodeType.Nop' 0' false' false); transferStatement = true; goto done;            case OpCode.Brfalse: statement = this.ParseBranch(NodeType.LogicalNot' 1' false' false); transferStatement = true; goto done;            case OpCode.Brtrue: statement = this.ParseBranch(NodeType.Nop' 1' false' false); transferStatement = true; goto done;            case OpCode.Beq: statement = this.ParseBranch(NodeType.Eq' 2' false' false); transferStatement = true; goto done;            case OpCode.Bge: statement = this.ParseBranch(NodeType.Ge' 2' false' false); transferStatement = true; goto done;            case OpCode.Bgt: statement = this.ParseBranch(NodeType.Gt' 2' false' false); transferStatement = true; goto done;            case OpCode.Ble: statement = this.ParseBranch(NodeType.Le' 2' false' false); transferStatement = true; goto done;            case OpCode.Blt: statement = this.ParseBranch(NodeType.Lt' 2' false' false); transferStatement = true; goto done;            case OpCode.Bne_Un: statement = this.ParseBranch(NodeType.Ne' 2' false' true); transferStatement = true; goto done;            case OpCode.Bge_Un: statement = this.ParseBranch(NodeType.Ge' 2' false' true); transferStatement = true; goto done;            case OpCode.Bgt_Un: statement = this.ParseBranch(NodeType.Gt' 2' false' true); transferStatement = true; goto done;            case OpCode.Ble_Un: statement = this.ParseBranch(NodeType.Le' 2' false' true); transferStatement = true; goto done;            case OpCode.Blt_Un: statement = this.ParseBranch(NodeType.Lt' 2' false' true); transferStatement = true; goto done;            case OpCode.Switch: statement = this.ParseSwitchInstruction(); transferStatement = true; goto done;            case OpCode.Ldind_I1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int64' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I: expr = new AddressDereference(PopOperand()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Single' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Double' this.isVolatile' this.alignment); break;            case OpCode.Ldind_Ref: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Object' this.isVolatile' this.alignment); break;            case OpCode.Stind_Ref: statement = this.ParseStoreIndirect(CoreSystemTypes.Object); goto done;            case OpCode.Stind_I1: statement = this.ParseStoreIndirect(CoreSystemTypes.Int8); goto done;            case OpCode.Stind_I2: statement = this.ParseStoreIndirect(CoreSystemTypes.Int16); goto done;            case OpCode.Stind_I4: statement = this.ParseStoreIndirect(CoreSystemTypes.Int32); goto done;            case OpCode.Stind_I8: statement = this.ParseStoreIndirect(CoreSystemTypes.Int64); goto done;            case OpCode.Stind_R4: statement = this.ParseStoreIndirect(CoreSystemTypes.Single); goto done;            case OpCode.Stind_R8: statement = this.ParseStoreIndirect(CoreSystemTypes.Double); goto done;            case OpCode.Add: expr = this.ParseBinaryOperation(NodeType.Add); break;            case OpCode.Sub: expr = this.ParseBinaryOperation(NodeType.Sub); break;            case OpCode.Mul: expr = this.ParseBinaryOperation(NodeType.Mul); break;            case OpCode.Div: expr = this.ParseBinaryOperation(NodeType.Div); break;            case OpCode.Div_Un: expr = this.ParseBinaryOperation(NodeType.Div_Un); break;            case OpCode.Rem: expr = this.ParseBinaryOperation(NodeType.Rem); break;            case OpCode.Rem_Un: expr = this.ParseBinaryOperation(NodeType.Rem_Un); break;            case OpCode.And: expr = this.ParseBinaryOperation(NodeType.And); break;            case OpCode.Or: expr = this.ParseBinaryOperation(NodeType.Or); break;            case OpCode.Xor: expr = this.ParseBinaryOperation(NodeType.Xor); break;            case OpCode.Shl: expr = this.ParseBinaryOperation(NodeType.Shl); break;            case OpCode.Shr: expr = this.ParseBinaryOperation(NodeType.Shr); break;            case OpCode.Shr_Un: expr = this.ParseBinaryOperation(NodeType.Shr_Un); break;            case OpCode.Neg: expr = this.ParseUnaryOperation(NodeType.Neg); break;            case OpCode.Not: expr = this.ParseUnaryOperation(NodeType.Not); break;            case OpCode.Conv_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_R4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R4' CoreSystemTypes.Single); break;            case OpCode.Conv_R8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R8' CoreSystemTypes.Double); break;            case OpCode.Conv_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U8' CoreSystemTypes.UInt64); break;            case OpCode.Callvirt: expr = this.ParseCall(NodeType.Callvirt' out isStatement); if (isStatement) goto done; break;            case OpCode.Cpobj: statement = this.ParseCopyObject(); goto done;            case OpCode.Ldobj: expr = new AddressDereference(PopOperand()' (TypeNode)this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldstr: expr = new Literal(this.GetStringFromToken()' CoreSystemTypes.String); break;            case OpCode.Newobj: expr = this.ParseConstruct(); break;            case OpCode.Castclass: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Castclass); break;            case OpCode.Isinst: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Isinst); break;            case OpCode.Conv_R_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R_Un' CoreSystemTypes.Double); break;            case OpCode.Unbox: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Unbox); break;            case OpCode.Throw: statement = new Throw(PopOperand()); transferStatement = true; goto done;            case OpCode.Ldfld:               expr = new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment);              break;            case OpCode.Ldflda:               expr = SetType(new UnaryExpression(new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf));               break;            case OpCode.Stfld: statement = this.ParseStoreField(); goto done;            case OpCode.Ldsfld: expr = new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldsflda: expr = SetType(new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf)); break;            case OpCode.Stsfld: statement = new AssignmentStatement(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' PopOperand()); goto done;            case OpCode.Stobj: statement = this.ParseStoreIndirect((TypeNode)this.GetMemberFromToken()); goto done;            case OpCode.Conv_Ovf_I1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_I2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_I4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_I8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_U2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_U4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_U8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64); break;            case OpCode.Conv_Ovf_I_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr); break;            case OpCode.Box:               TypeNode t = (TypeNode)this.GetMemberFromToken();              TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;              expr = new BinaryExpression(PopOperand()' new Literal(t' CoreSystemTypes.Type)' NodeType.Box' bt); break;            case OpCode.Newarr: expr = this.ParseNewArray(); break;            case OpCode.Ldlen: expr = new UnaryExpression(PopOperand()' NodeType.Ldlen' CoreSystemTypes.UIntPtr); break;            case OpCode.Ldelema: expr = this.ParseArrayElementLoadAddress(); break;            case OpCode.Ldelem_I1:             case OpCode.Ldelem_U1:             case OpCode.Ldelem_I2:             case OpCode.Ldelem_U2:             case OpCode.Ldelem_I4:             case OpCode.Ldelem_U4:             case OpCode.Ldelem_I8:             case OpCode.Ldelem_I:             case OpCode.Ldelem_R4:             case OpCode.Ldelem_R8:             case OpCode.Ldelem_Ref: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem_I:            case OpCode.Stelem_I1:            case OpCode.Stelem_I2:            case OpCode.Stelem_I4:            case OpCode.Stelem_I8:            case OpCode.Stelem_R4:            case OpCode.Stelem_R8:            case OpCode.Stelem_Ref: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Ldelem: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Unbox_Any: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.UnboxAny); break;            case OpCode.Conv_Ovf_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64); break;            case OpCode.Refanyval: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr); break;            case OpCode.Ckfinite: expr = this.ParseUnaryOperation(NodeType.Ckfinite); break;            case OpCode.Mkrefany: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference); break;            case OpCode.Ldtoken: expr = ParseLoadRuntimeMetadataToken(); break;            case OpCode.Conv_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Add_Ovf: expr = this.ParseBinaryOperation(NodeType.Add_Ovf); break;            case OpCode.Add_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Add_Ovf_Un); break;            case OpCode.Mul_Ovf: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf); break;            case OpCode.Mul_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf_Un); break;            case OpCode.Sub_Ovf: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf); break;            case OpCode.Sub_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf_Un); break;            case OpCode.Endfinally: statement = new EndFinally(); transferStatement = true; goto done;            case OpCode.Leave: statement = this.ParseBranch(NodeType.Nop' 0' false' false' true); transferStatement = true; goto done;            case OpCode.Leave_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false' true); transferStatement = true; goto done;            case OpCode.Stind_I: statement = this.ParseStoreIndirect(CoreSystemTypes.IntPtr); goto done;            case OpCode.Conv_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Arglist: expr = new Expression(NodeType.Arglist' CoreSystemTypes.ArgIterator); break;            case OpCode.Ceq: expr = this.ParseBinaryComparison(NodeType.Ceq); break;            case OpCode.Cgt: expr = this.ParseBinaryComparison(NodeType.Cgt); break;            case OpCode.Cgt_Un: expr = this.ParseBinaryComparison(NodeType.Cgt_Un); break;            case OpCode.Clt: expr = this.ParseBinaryComparison(NodeType.Clt); break;            case OpCode.Clt_Un: expr = this.ParseBinaryComparison(NodeType.Clt_Un); break;            case OpCode.Ldftn: expr = new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldvirtftn: expr = new BinaryExpression(PopOperand()' new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldarg: expr = this.Parameters((ushort)this.GetInt16()); break;            case OpCode.Ldarga: expr = SetType(new UnaryExpression(this.Parameters((ushort)this.GetInt16())' NodeType.AddressOf)); break;            case OpCode.Starg: statement = new AssignmentStatement(this.Parameters((ushort)this.GetInt16())' PopOperand()); goto done;            case OpCode.Ldloc: expr = this.locals[(ushort)this.GetInt16()]; break;            case OpCode.Ldloca: expr = SetType(new UnaryExpression(this.locals[(ushort)this.GetInt16()]' NodeType.AddressOf)); break;            case OpCode.Stloc: statement = new AssignmentStatement(this.locals[(ushort)this.GetInt16()]' PopOperand()); goto done;            case OpCode.Localloc: expr = new UnaryExpression(PopOperand()' NodeType.Localloc' CoreSystemTypes.Void); break;            case OpCode.Endfilter: statement = new EndFilter(PopOperand()); transferStatement = true; goto done;            case OpCode.Unaligned_: this.alignment = this.GetByte(); continue;            case OpCode.Volatile_: this.isVolatile = true; continue;            case OpCode.Tail_: this.isTailCall = true; continue;            case OpCode.Initobj: statement = this.ParseInitObject(); goto done;            case OpCode.Constrained_: this.constraint = this.GetMemberFromToken() as TypeNode; continue;            case OpCode.Cpblk: expr = this.ParseTernaryOperation(NodeType.Cpblk); goto done;            case OpCode.Initblk: expr = this.ParseTernaryOperation(NodeType.Initblk); goto done;            case OpCode.Rethrow: statement = new Throw(null); statement.NodeType = NodeType.Rethrow; transferStatement = true; goto done;            case OpCode.Sizeof: expr = new UnaryExpression(new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32); break;            case OpCode.Refanytype: expr = new UnaryExpression(PopOperand()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle); break;            case OpCode.Readonly_: this.isReadOnly = true; continue;            default: throw new InvalidMetadataException(ExceptionStrings.UnknownOpCode);          }          if (this.blockMap[this.counter+1] != null){            transferStatement = true; //Falls through to the next basic block' so implicitly a "transfer" statement            goto done;          }          //^ assume expr != null;  #if FxCop          expr.sourceContext = sourceContext;  #endif  #if FxCop || ILOFFSETS          expr.ILOffset = this.ilOffset;  #endif          this.operandStack.Push(expr);          this.isReadOnly = false;          this.isVolatile = false;          this.isTailCall = false;                  this.alignment = -1;        }
Magic Number,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true){          bool isStatement = false;          startingAddress = this.counter+1; //Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  #if FxCop || ILOFFSETS          this.ilOffset = this.counter;          this.opCode = this.GetOpCode();  #else          OpCode opCode = this.GetOpCode();  #endif  #if FxCop          if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){            expr.sourceContext = sourceContext;            expr.ILOffset = this.ilOffset;            this.operandStack.Push(expr);          }  #endif          switch (opCode){            case OpCode.Nop: statement = new Statement(NodeType.Nop); goto done;            case OpCode.Break: statement = new Statement(NodeType.DebugBreak); goto done;            case OpCode.Ldarg_0: expr = this.Parameters(0); break;            case OpCode.Ldarg_1: expr = this.Parameters(1); break;            case OpCode.Ldarg_2: expr = this.Parameters(2); break;            case OpCode.Ldarg_3: expr = this.Parameters(3); break;            case OpCode.Ldloc_0: expr = this.locals[0]; break;            case OpCode.Ldloc_1: expr = this.locals[1]; break;            case OpCode.Ldloc_2: expr = this.locals[2]; break;            case OpCode.Ldloc_3: expr = this.locals[3]; break;            case OpCode.Stloc_0: statement = new AssignmentStatement(this.locals[0]' PopOperand()); goto done;            case OpCode.Stloc_1: statement = new AssignmentStatement(this.locals[1]' PopOperand()); goto done;            case OpCode.Stloc_2: statement = new AssignmentStatement(this.locals[2]' PopOperand()); goto done;            case OpCode.Stloc_3: statement = new AssignmentStatement(this.locals[3]' PopOperand()); goto done;            case OpCode.Ldarg_S: expr = this.Parameters(this.GetByte()); break;            case OpCode.Ldarga_S: expr = SetType(new UnaryExpression(this.Parameters(this.GetByte())' NodeType.AddressOf)); break;            case OpCode.Starg_S: statement = new AssignmentStatement(this.Parameters(this.GetByte())' PopOperand()); goto done;            case OpCode.Ldloc_S: expr = this.locals[this.GetByte()]; break;            case OpCode.Ldloca_S: expr = SetType(new UnaryExpression(this.locals[this.GetByte()]' NodeType.AddressOf)); break;            case OpCode.Stloc_S: statement = new AssignmentStatement(this.locals[this.GetByte()]' PopOperand()); goto done;            case OpCode.Ldnull: expr = new Literal(null' CoreSystemTypes.Object); break;            case OpCode.Ldc_I4_M1: expr = new Literal(-1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_0: expr = new Literal(0' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_1: expr = new Literal(1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_2: expr = new Literal(2' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_3: expr = new Literal(3' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_4: expr = new Literal(4' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_5: expr = new Literal(5' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_6: expr = new Literal(6' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_7: expr = new Literal(7' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_8: expr = new Literal(8' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_S: expr = new Literal((int)this.GetSByte()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4: expr = new Literal(this.GetInt32()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I8: expr = new Literal(this.GetInt64()' CoreSystemTypes.Int64); break;            case OpCode.Ldc_R4: expr = new Literal(this.GetSingle()' CoreSystemTypes.Single); break;            case OpCode.Ldc_R8: expr = new Literal(this.GetDouble()' CoreSystemTypes.Double); break;            case OpCode.Dup: statement = new ExpressionStatement(new Expression(NodeType.Dup)); goto done;            case OpCode.Pop: statement = new ExpressionStatement(new UnaryExpression(PopOperand()' NodeType.Pop)); goto done;            case OpCode.Jmp: expr = this.ParseCall(NodeType.Jmp' out isStatement); if (isStatement) goto done; break;            case OpCode.Call: expr = this.ParseCall(NodeType.Call' out isStatement); if (isStatement) goto done; break;            case OpCode.Calli: expr = this.ParseCalli(out isStatement); if (isStatement) goto done; break;            case OpCode.Ret:              Expression retVal = BodyParser.TypeIsVoid(this.method.ReturnType) ? null : PopOperand();              statement = new Return(retVal);               transferStatement = true; goto done;            case OpCode.Br_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false); transferStatement = true; goto done;            case OpCode.Brfalse_S: statement = this.ParseBranch(NodeType.LogicalNot' 1' true' false); transferStatement = true; goto done;            case OpCode.Brtrue_S: statement = this.ParseBranch(NodeType.Nop' 1' true' false); transferStatement = true; goto done;            case OpCode.Beq_S: statement = this.ParseBranch(NodeType.Eq' 2' true' false); transferStatement = true; goto done;            case OpCode.Bge_S: statement = this.ParseBranch(NodeType.Ge' 2' true' false); transferStatement = true; goto done;            case OpCode.Bgt_S: statement = this.ParseBranch(NodeType.Gt' 2' true' false); transferStatement = true; goto done;            case OpCode.Ble_S: statement = this.ParseBranch(NodeType.Le' 2' true' false); transferStatement = true; goto done;            case OpCode.Blt_S: statement = this.ParseBranch(NodeType.Lt' 2' true' false); transferStatement = true; goto done;            case OpCode.Bne_Un_S: statement = this.ParseBranch(NodeType.Ne' 2' true' true); transferStatement = true; goto done;            case OpCode.Bge_Un_S: statement = this.ParseBranch(NodeType.Ge' 2' true' true); transferStatement = true; goto done;            case OpCode.Bgt_Un_S: statement = this.ParseBranch(NodeType.Gt' 2' true' true); transferStatement = true; goto done;            case OpCode.Ble_Un_S: statement = this.ParseBranch(NodeType.Le' 2' true' true); transferStatement = true; goto done;            case OpCode.Blt_Un_S: statement = this.ParseBranch(NodeType.Lt' 2' true' true); transferStatement = true; goto done;            case OpCode.Br: statement = this.ParseBranch(NodeType.Nop' 0' false' false); transferStatement = true; goto done;            case OpCode.Brfalse: statement = this.ParseBranch(NodeType.LogicalNot' 1' false' false); transferStatement = true; goto done;            case OpCode.Brtrue: statement = this.ParseBranch(NodeType.Nop' 1' false' false); transferStatement = true; goto done;            case OpCode.Beq: statement = this.ParseBranch(NodeType.Eq' 2' false' false); transferStatement = true; goto done;            case OpCode.Bge: statement = this.ParseBranch(NodeType.Ge' 2' false' false); transferStatement = true; goto done;            case OpCode.Bgt: statement = this.ParseBranch(NodeType.Gt' 2' false' false); transferStatement = true; goto done;            case OpCode.Ble: statement = this.ParseBranch(NodeType.Le' 2' false' false); transferStatement = true; goto done;            case OpCode.Blt: statement = this.ParseBranch(NodeType.Lt' 2' false' false); transferStatement = true; goto done;            case OpCode.Bne_Un: statement = this.ParseBranch(NodeType.Ne' 2' false' true); transferStatement = true; goto done;            case OpCode.Bge_Un: statement = this.ParseBranch(NodeType.Ge' 2' false' true); transferStatement = true; goto done;            case OpCode.Bgt_Un: statement = this.ParseBranch(NodeType.Gt' 2' false' true); transferStatement = true; goto done;            case OpCode.Ble_Un: statement = this.ParseBranch(NodeType.Le' 2' false' true); transferStatement = true; goto done;            case OpCode.Blt_Un: statement = this.ParseBranch(NodeType.Lt' 2' false' true); transferStatement = true; goto done;            case OpCode.Switch: statement = this.ParseSwitchInstruction(); transferStatement = true; goto done;            case OpCode.Ldind_I1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int64' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I: expr = new AddressDereference(PopOperand()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Single' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Double' this.isVolatile' this.alignment); break;            case OpCode.Ldind_Ref: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Object' this.isVolatile' this.alignment); break;            case OpCode.Stind_Ref: statement = this.ParseStoreIndirect(CoreSystemTypes.Object); goto done;            case OpCode.Stind_I1: statement = this.ParseStoreIndirect(CoreSystemTypes.Int8); goto done;            case OpCode.Stind_I2: statement = this.ParseStoreIndirect(CoreSystemTypes.Int16); goto done;            case OpCode.Stind_I4: statement = this.ParseStoreIndirect(CoreSystemTypes.Int32); goto done;            case OpCode.Stind_I8: statement = this.ParseStoreIndirect(CoreSystemTypes.Int64); goto done;            case OpCode.Stind_R4: statement = this.ParseStoreIndirect(CoreSystemTypes.Single); goto done;            case OpCode.Stind_R8: statement = this.ParseStoreIndirect(CoreSystemTypes.Double); goto done;            case OpCode.Add: expr = this.ParseBinaryOperation(NodeType.Add); break;            case OpCode.Sub: expr = this.ParseBinaryOperation(NodeType.Sub); break;            case OpCode.Mul: expr = this.ParseBinaryOperation(NodeType.Mul); break;            case OpCode.Div: expr = this.ParseBinaryOperation(NodeType.Div); break;            case OpCode.Div_Un: expr = this.ParseBinaryOperation(NodeType.Div_Un); break;            case OpCode.Rem: expr = this.ParseBinaryOperation(NodeType.Rem); break;            case OpCode.Rem_Un: expr = this.ParseBinaryOperation(NodeType.Rem_Un); break;            case OpCode.And: expr = this.ParseBinaryOperation(NodeType.And); break;            case OpCode.Or: expr = this.ParseBinaryOperation(NodeType.Or); break;            case OpCode.Xor: expr = this.ParseBinaryOperation(NodeType.Xor); break;            case OpCode.Shl: expr = this.ParseBinaryOperation(NodeType.Shl); break;            case OpCode.Shr: expr = this.ParseBinaryOperation(NodeType.Shr); break;            case OpCode.Shr_Un: expr = this.ParseBinaryOperation(NodeType.Shr_Un); break;            case OpCode.Neg: expr = this.ParseUnaryOperation(NodeType.Neg); break;            case OpCode.Not: expr = this.ParseUnaryOperation(NodeType.Not); break;            case OpCode.Conv_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_R4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R4' CoreSystemTypes.Single); break;            case OpCode.Conv_R8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R8' CoreSystemTypes.Double); break;            case OpCode.Conv_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U8' CoreSystemTypes.UInt64); break;            case OpCode.Callvirt: expr = this.ParseCall(NodeType.Callvirt' out isStatement); if (isStatement) goto done; break;            case OpCode.Cpobj: statement = this.ParseCopyObject(); goto done;            case OpCode.Ldobj: expr = new AddressDereference(PopOperand()' (TypeNode)this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldstr: expr = new Literal(this.GetStringFromToken()' CoreSystemTypes.String); break;            case OpCode.Newobj: expr = this.ParseConstruct(); break;            case OpCode.Castclass: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Castclass); break;            case OpCode.Isinst: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Isinst); break;            case OpCode.Conv_R_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R_Un' CoreSystemTypes.Double); break;            case OpCode.Unbox: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Unbox); break;            case OpCode.Throw: statement = new Throw(PopOperand()); transferStatement = true; goto done;            case OpCode.Ldfld:               expr = new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment);              break;            case OpCode.Ldflda:               expr = SetType(new UnaryExpression(new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf));               break;            case OpCode.Stfld: statement = this.ParseStoreField(); goto done;            case OpCode.Ldsfld: expr = new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldsflda: expr = SetType(new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf)); break;            case OpCode.Stsfld: statement = new AssignmentStatement(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' PopOperand()); goto done;            case OpCode.Stobj: statement = this.ParseStoreIndirect((TypeNode)this.GetMemberFromToken()); goto done;            case OpCode.Conv_Ovf_I1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_I2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_I4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_I8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_U2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_U4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_U8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64); break;            case OpCode.Conv_Ovf_I_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr); break;            case OpCode.Box:               TypeNode t = (TypeNode)this.GetMemberFromToken();              TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;              expr = new BinaryExpression(PopOperand()' new Literal(t' CoreSystemTypes.Type)' NodeType.Box' bt); break;            case OpCode.Newarr: expr = this.ParseNewArray(); break;            case OpCode.Ldlen: expr = new UnaryExpression(PopOperand()' NodeType.Ldlen' CoreSystemTypes.UIntPtr); break;            case OpCode.Ldelema: expr = this.ParseArrayElementLoadAddress(); break;            case OpCode.Ldelem_I1:             case OpCode.Ldelem_U1:             case OpCode.Ldelem_I2:             case OpCode.Ldelem_U2:             case OpCode.Ldelem_I4:             case OpCode.Ldelem_U4:             case OpCode.Ldelem_I8:             case OpCode.Ldelem_I:             case OpCode.Ldelem_R4:             case OpCode.Ldelem_R8:             case OpCode.Ldelem_Ref: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem_I:            case OpCode.Stelem_I1:            case OpCode.Stelem_I2:            case OpCode.Stelem_I4:            case OpCode.Stelem_I8:            case OpCode.Stelem_R4:            case OpCode.Stelem_R8:            case OpCode.Stelem_Ref: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Ldelem: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Unbox_Any: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.UnboxAny); break;            case OpCode.Conv_Ovf_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64); break;            case OpCode.Refanyval: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr); break;            case OpCode.Ckfinite: expr = this.ParseUnaryOperation(NodeType.Ckfinite); break;            case OpCode.Mkrefany: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference); break;            case OpCode.Ldtoken: expr = ParseLoadRuntimeMetadataToken(); break;            case OpCode.Conv_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Add_Ovf: expr = this.ParseBinaryOperation(NodeType.Add_Ovf); break;            case OpCode.Add_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Add_Ovf_Un); break;            case OpCode.Mul_Ovf: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf); break;            case OpCode.Mul_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf_Un); break;            case OpCode.Sub_Ovf: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf); break;            case OpCode.Sub_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf_Un); break;            case OpCode.Endfinally: statement = new EndFinally(); transferStatement = true; goto done;            case OpCode.Leave: statement = this.ParseBranch(NodeType.Nop' 0' false' false' true); transferStatement = true; goto done;            case OpCode.Leave_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false' true); transferStatement = true; goto done;            case OpCode.Stind_I: statement = this.ParseStoreIndirect(CoreSystemTypes.IntPtr); goto done;            case OpCode.Conv_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Arglist: expr = new Expression(NodeType.Arglist' CoreSystemTypes.ArgIterator); break;            case OpCode.Ceq: expr = this.ParseBinaryComparison(NodeType.Ceq); break;            case OpCode.Cgt: expr = this.ParseBinaryComparison(NodeType.Cgt); break;            case OpCode.Cgt_Un: expr = this.ParseBinaryComparison(NodeType.Cgt_Un); break;            case OpCode.Clt: expr = this.ParseBinaryComparison(NodeType.Clt); break;            case OpCode.Clt_Un: expr = this.ParseBinaryComparison(NodeType.Clt_Un); break;            case OpCode.Ldftn: expr = new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldvirtftn: expr = new BinaryExpression(PopOperand()' new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldarg: expr = this.Parameters((ushort)this.GetInt16()); break;            case OpCode.Ldarga: expr = SetType(new UnaryExpression(this.Parameters((ushort)this.GetInt16())' NodeType.AddressOf)); break;            case OpCode.Starg: statement = new AssignmentStatement(this.Parameters((ushort)this.GetInt16())' PopOperand()); goto done;            case OpCode.Ldloc: expr = this.locals[(ushort)this.GetInt16()]; break;            case OpCode.Ldloca: expr = SetType(new UnaryExpression(this.locals[(ushort)this.GetInt16()]' NodeType.AddressOf)); break;            case OpCode.Stloc: statement = new AssignmentStatement(this.locals[(ushort)this.GetInt16()]' PopOperand()); goto done;            case OpCode.Localloc: expr = new UnaryExpression(PopOperand()' NodeType.Localloc' CoreSystemTypes.Void); break;            case OpCode.Endfilter: statement = new EndFilter(PopOperand()); transferStatement = true; goto done;            case OpCode.Unaligned_: this.alignment = this.GetByte(); continue;            case OpCode.Volatile_: this.isVolatile = true; continue;            case OpCode.Tail_: this.isTailCall = true; continue;            case OpCode.Initobj: statement = this.ParseInitObject(); goto done;            case OpCode.Constrained_: this.constraint = this.GetMemberFromToken() as TypeNode; continue;            case OpCode.Cpblk: expr = this.ParseTernaryOperation(NodeType.Cpblk); goto done;            case OpCode.Initblk: expr = this.ParseTernaryOperation(NodeType.Initblk); goto done;            case OpCode.Rethrow: statement = new Throw(null); statement.NodeType = NodeType.Rethrow; transferStatement = true; goto done;            case OpCode.Sizeof: expr = new UnaryExpression(new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32); break;            case OpCode.Refanytype: expr = new UnaryExpression(PopOperand()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle); break;            case OpCode.Readonly_: this.isReadOnly = true; continue;            default: throw new InvalidMetadataException(ExceptionStrings.UnknownOpCode);          }          if (this.blockMap[this.counter+1] != null){            transferStatement = true; //Falls through to the next basic block' so implicitly a "transfer" statement            goto done;          }          //^ assume expr != null;  #if FxCop          expr.sourceContext = sourceContext;  #endif  #if FxCop || ILOFFSETS          expr.ILOffset = this.ilOffset;  #endif          this.operandStack.Push(expr);          this.isReadOnly = false;          this.isVolatile = false;          this.isTailCall = false;                  this.alignment = -1;        }
Magic Number,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true){          bool isStatement = false;          startingAddress = this.counter+1; //Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  #if FxCop || ILOFFSETS          this.ilOffset = this.counter;          this.opCode = this.GetOpCode();  #else          OpCode opCode = this.GetOpCode();  #endif  #if FxCop          if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){            expr.sourceContext = sourceContext;            expr.ILOffset = this.ilOffset;            this.operandStack.Push(expr);          }  #endif          switch (opCode){            case OpCode.Nop: statement = new Statement(NodeType.Nop); goto done;            case OpCode.Break: statement = new Statement(NodeType.DebugBreak); goto done;            case OpCode.Ldarg_0: expr = this.Parameters(0); break;            case OpCode.Ldarg_1: expr = this.Parameters(1); break;            case OpCode.Ldarg_2: expr = this.Parameters(2); break;            case OpCode.Ldarg_3: expr = this.Parameters(3); break;            case OpCode.Ldloc_0: expr = this.locals[0]; break;            case OpCode.Ldloc_1: expr = this.locals[1]; break;            case OpCode.Ldloc_2: expr = this.locals[2]; break;            case OpCode.Ldloc_3: expr = this.locals[3]; break;            case OpCode.Stloc_0: statement = new AssignmentStatement(this.locals[0]' PopOperand()); goto done;            case OpCode.Stloc_1: statement = new AssignmentStatement(this.locals[1]' PopOperand()); goto done;            case OpCode.Stloc_2: statement = new AssignmentStatement(this.locals[2]' PopOperand()); goto done;            case OpCode.Stloc_3: statement = new AssignmentStatement(this.locals[3]' PopOperand()); goto done;            case OpCode.Ldarg_S: expr = this.Parameters(this.GetByte()); break;            case OpCode.Ldarga_S: expr = SetType(new UnaryExpression(this.Parameters(this.GetByte())' NodeType.AddressOf)); break;            case OpCode.Starg_S: statement = new AssignmentStatement(this.Parameters(this.GetByte())' PopOperand()); goto done;            case OpCode.Ldloc_S: expr = this.locals[this.GetByte()]; break;            case OpCode.Ldloca_S: expr = SetType(new UnaryExpression(this.locals[this.GetByte()]' NodeType.AddressOf)); break;            case OpCode.Stloc_S: statement = new AssignmentStatement(this.locals[this.GetByte()]' PopOperand()); goto done;            case OpCode.Ldnull: expr = new Literal(null' CoreSystemTypes.Object); break;            case OpCode.Ldc_I4_M1: expr = new Literal(-1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_0: expr = new Literal(0' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_1: expr = new Literal(1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_2: expr = new Literal(2' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_3: expr = new Literal(3' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_4: expr = new Literal(4' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_5: expr = new Literal(5' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_6: expr = new Literal(6' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_7: expr = new Literal(7' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_8: expr = new Literal(8' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_S: expr = new Literal((int)this.GetSByte()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4: expr = new Literal(this.GetInt32()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I8: expr = new Literal(this.GetInt64()' CoreSystemTypes.Int64); break;            case OpCode.Ldc_R4: expr = new Literal(this.GetSingle()' CoreSystemTypes.Single); break;            case OpCode.Ldc_R8: expr = new Literal(this.GetDouble()' CoreSystemTypes.Double); break;            case OpCode.Dup: statement = new ExpressionStatement(new Expression(NodeType.Dup)); goto done;            case OpCode.Pop: statement = new ExpressionStatement(new UnaryExpression(PopOperand()' NodeType.Pop)); goto done;            case OpCode.Jmp: expr = this.ParseCall(NodeType.Jmp' out isStatement); if (isStatement) goto done; break;            case OpCode.Call: expr = this.ParseCall(NodeType.Call' out isStatement); if (isStatement) goto done; break;            case OpCode.Calli: expr = this.ParseCalli(out isStatement); if (isStatement) goto done; break;            case OpCode.Ret:              Expression retVal = BodyParser.TypeIsVoid(this.method.ReturnType) ? null : PopOperand();              statement = new Return(retVal);               transferStatement = true; goto done;            case OpCode.Br_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false); transferStatement = true; goto done;            case OpCode.Brfalse_S: statement = this.ParseBranch(NodeType.LogicalNot' 1' true' false); transferStatement = true; goto done;            case OpCode.Brtrue_S: statement = this.ParseBranch(NodeType.Nop' 1' true' false); transferStatement = true; goto done;            case OpCode.Beq_S: statement = this.ParseBranch(NodeType.Eq' 2' true' false); transferStatement = true; goto done;            case OpCode.Bge_S: statement = this.ParseBranch(NodeType.Ge' 2' true' false); transferStatement = true; goto done;            case OpCode.Bgt_S: statement = this.ParseBranch(NodeType.Gt' 2' true' false); transferStatement = true; goto done;            case OpCode.Ble_S: statement = this.ParseBranch(NodeType.Le' 2' true' false); transferStatement = true; goto done;            case OpCode.Blt_S: statement = this.ParseBranch(NodeType.Lt' 2' true' false); transferStatement = true; goto done;            case OpCode.Bne_Un_S: statement = this.ParseBranch(NodeType.Ne' 2' true' true); transferStatement = true; goto done;            case OpCode.Bge_Un_S: statement = this.ParseBranch(NodeType.Ge' 2' true' true); transferStatement = true; goto done;            case OpCode.Bgt_Un_S: statement = this.ParseBranch(NodeType.Gt' 2' true' true); transferStatement = true; goto done;            case OpCode.Ble_Un_S: statement = this.ParseBranch(NodeType.Le' 2' true' true); transferStatement = true; goto done;            case OpCode.Blt_Un_S: statement = this.ParseBranch(NodeType.Lt' 2' true' true); transferStatement = true; goto done;            case OpCode.Br: statement = this.ParseBranch(NodeType.Nop' 0' false' false); transferStatement = true; goto done;            case OpCode.Brfalse: statement = this.ParseBranch(NodeType.LogicalNot' 1' false' false); transferStatement = true; goto done;            case OpCode.Brtrue: statement = this.ParseBranch(NodeType.Nop' 1' false' false); transferStatement = true; goto done;            case OpCode.Beq: statement = this.ParseBranch(NodeType.Eq' 2' false' false); transferStatement = true; goto done;            case OpCode.Bge: statement = this.ParseBranch(NodeType.Ge' 2' false' false); transferStatement = true; goto done;            case OpCode.Bgt: statement = this.ParseBranch(NodeType.Gt' 2' false' false); transferStatement = true; goto done;            case OpCode.Ble: statement = this.ParseBranch(NodeType.Le' 2' false' false); transferStatement = true; goto done;            case OpCode.Blt: statement = this.ParseBranch(NodeType.Lt' 2' false' false); transferStatement = true; goto done;            case OpCode.Bne_Un: statement = this.ParseBranch(NodeType.Ne' 2' false' true); transferStatement = true; goto done;            case OpCode.Bge_Un: statement = this.ParseBranch(NodeType.Ge' 2' false' true); transferStatement = true; goto done;            case OpCode.Bgt_Un: statement = this.ParseBranch(NodeType.Gt' 2' false' true); transferStatement = true; goto done;            case OpCode.Ble_Un: statement = this.ParseBranch(NodeType.Le' 2' false' true); transferStatement = true; goto done;            case OpCode.Blt_Un: statement = this.ParseBranch(NodeType.Lt' 2' false' true); transferStatement = true; goto done;            case OpCode.Switch: statement = this.ParseSwitchInstruction(); transferStatement = true; goto done;            case OpCode.Ldind_I1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int64' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I: expr = new AddressDereference(PopOperand()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Single' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Double' this.isVolatile' this.alignment); break;            case OpCode.Ldind_Ref: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Object' this.isVolatile' this.alignment); break;            case OpCode.Stind_Ref: statement = this.ParseStoreIndirect(CoreSystemTypes.Object); goto done;            case OpCode.Stind_I1: statement = this.ParseStoreIndirect(CoreSystemTypes.Int8); goto done;            case OpCode.Stind_I2: statement = this.ParseStoreIndirect(CoreSystemTypes.Int16); goto done;            case OpCode.Stind_I4: statement = this.ParseStoreIndirect(CoreSystemTypes.Int32); goto done;            case OpCode.Stind_I8: statement = this.ParseStoreIndirect(CoreSystemTypes.Int64); goto done;            case OpCode.Stind_R4: statement = this.ParseStoreIndirect(CoreSystemTypes.Single); goto done;            case OpCode.Stind_R8: statement = this.ParseStoreIndirect(CoreSystemTypes.Double); goto done;            case OpCode.Add: expr = this.ParseBinaryOperation(NodeType.Add); break;            case OpCode.Sub: expr = this.ParseBinaryOperation(NodeType.Sub); break;            case OpCode.Mul: expr = this.ParseBinaryOperation(NodeType.Mul); break;            case OpCode.Div: expr = this.ParseBinaryOperation(NodeType.Div); break;            case OpCode.Div_Un: expr = this.ParseBinaryOperation(NodeType.Div_Un); break;            case OpCode.Rem: expr = this.ParseBinaryOperation(NodeType.Rem); break;            case OpCode.Rem_Un: expr = this.ParseBinaryOperation(NodeType.Rem_Un); break;            case OpCode.And: expr = this.ParseBinaryOperation(NodeType.And); break;            case OpCode.Or: expr = this.ParseBinaryOperation(NodeType.Or); break;            case OpCode.Xor: expr = this.ParseBinaryOperation(NodeType.Xor); break;            case OpCode.Shl: expr = this.ParseBinaryOperation(NodeType.Shl); break;            case OpCode.Shr: expr = this.ParseBinaryOperation(NodeType.Shr); break;            case OpCode.Shr_Un: expr = this.ParseBinaryOperation(NodeType.Shr_Un); break;            case OpCode.Neg: expr = this.ParseUnaryOperation(NodeType.Neg); break;            case OpCode.Not: expr = this.ParseUnaryOperation(NodeType.Not); break;            case OpCode.Conv_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_R4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R4' CoreSystemTypes.Single); break;            case OpCode.Conv_R8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R8' CoreSystemTypes.Double); break;            case OpCode.Conv_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U8' CoreSystemTypes.UInt64); break;            case OpCode.Callvirt: expr = this.ParseCall(NodeType.Callvirt' out isStatement); if (isStatement) goto done; break;            case OpCode.Cpobj: statement = this.ParseCopyObject(); goto done;            case OpCode.Ldobj: expr = new AddressDereference(PopOperand()' (TypeNode)this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldstr: expr = new Literal(this.GetStringFromToken()' CoreSystemTypes.String); break;            case OpCode.Newobj: expr = this.ParseConstruct(); break;            case OpCode.Castclass: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Castclass); break;            case OpCode.Isinst: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Isinst); break;            case OpCode.Conv_R_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R_Un' CoreSystemTypes.Double); break;            case OpCode.Unbox: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Unbox); break;            case OpCode.Throw: statement = new Throw(PopOperand()); transferStatement = true; goto done;            case OpCode.Ldfld:               expr = new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment);              break;            case OpCode.Ldflda:               expr = SetType(new UnaryExpression(new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf));               break;            case OpCode.Stfld: statement = this.ParseStoreField(); goto done;            case OpCode.Ldsfld: expr = new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldsflda: expr = SetType(new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf)); break;            case OpCode.Stsfld: statement = new AssignmentStatement(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' PopOperand()); goto done;            case OpCode.Stobj: statement = this.ParseStoreIndirect((TypeNode)this.GetMemberFromToken()); goto done;            case OpCode.Conv_Ovf_I1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_I2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_I4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_I8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_U2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_U4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_U8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64); break;            case OpCode.Conv_Ovf_I_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr); break;            case OpCode.Box:               TypeNode t = (TypeNode)this.GetMemberFromToken();              TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;              expr = new BinaryExpression(PopOperand()' new Literal(t' CoreSystemTypes.Type)' NodeType.Box' bt); break;            case OpCode.Newarr: expr = this.ParseNewArray(); break;            case OpCode.Ldlen: expr = new UnaryExpression(PopOperand()' NodeType.Ldlen' CoreSystemTypes.UIntPtr); break;            case OpCode.Ldelema: expr = this.ParseArrayElementLoadAddress(); break;            case OpCode.Ldelem_I1:             case OpCode.Ldelem_U1:             case OpCode.Ldelem_I2:             case OpCode.Ldelem_U2:             case OpCode.Ldelem_I4:             case OpCode.Ldelem_U4:             case OpCode.Ldelem_I8:             case OpCode.Ldelem_I:             case OpCode.Ldelem_R4:             case OpCode.Ldelem_R8:             case OpCode.Ldelem_Ref: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem_I:            case OpCode.Stelem_I1:            case OpCode.Stelem_I2:            case OpCode.Stelem_I4:            case OpCode.Stelem_I8:            case OpCode.Stelem_R4:            case OpCode.Stelem_R8:            case OpCode.Stelem_Ref: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Ldelem: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Unbox_Any: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.UnboxAny); break;            case OpCode.Conv_Ovf_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64); break;            case OpCode.Refanyval: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr); break;            case OpCode.Ckfinite: expr = this.ParseUnaryOperation(NodeType.Ckfinite); break;            case OpCode.Mkrefany: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference); break;            case OpCode.Ldtoken: expr = ParseLoadRuntimeMetadataToken(); break;            case OpCode.Conv_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Add_Ovf: expr = this.ParseBinaryOperation(NodeType.Add_Ovf); break;            case OpCode.Add_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Add_Ovf_Un); break;            case OpCode.Mul_Ovf: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf); break;            case OpCode.Mul_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf_Un); break;            case OpCode.Sub_Ovf: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf); break;            case OpCode.Sub_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf_Un); break;            case OpCode.Endfinally: statement = new EndFinally(); transferStatement = true; goto done;            case OpCode.Leave: statement = this.ParseBranch(NodeType.Nop' 0' false' false' true); transferStatement = true; goto done;            case OpCode.Leave_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false' true); transferStatement = true; goto done;            case OpCode.Stind_I: statement = this.ParseStoreIndirect(CoreSystemTypes.IntPtr); goto done;            case OpCode.Conv_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Arglist: expr = new Expression(NodeType.Arglist' CoreSystemTypes.ArgIterator); break;            case OpCode.Ceq: expr = this.ParseBinaryComparison(NodeType.Ceq); break;            case OpCode.Cgt: expr = this.ParseBinaryComparison(NodeType.Cgt); break;            case OpCode.Cgt_Un: expr = this.ParseBinaryComparison(NodeType.Cgt_Un); break;            case OpCode.Clt: expr = this.ParseBinaryComparison(NodeType.Clt); break;            case OpCode.Clt_Un: expr = this.ParseBinaryComparison(NodeType.Clt_Un); break;            case OpCode.Ldftn: expr = new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldvirtftn: expr = new BinaryExpression(PopOperand()' new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldarg: expr = this.Parameters((ushort)this.GetInt16()); break;            case OpCode.Ldarga: expr = SetType(new UnaryExpression(this.Parameters((ushort)this.GetInt16())' NodeType.AddressOf)); break;            case OpCode.Starg: statement = new AssignmentStatement(this.Parameters((ushort)this.GetInt16())' PopOperand()); goto done;            case OpCode.Ldloc: expr = this.locals[(ushort)this.GetInt16()]; break;            case OpCode.Ldloca: expr = SetType(new UnaryExpression(this.locals[(ushort)this.GetInt16()]' NodeType.AddressOf)); break;            case OpCode.Stloc: statement = new AssignmentStatement(this.locals[(ushort)this.GetInt16()]' PopOperand()); goto done;            case OpCode.Localloc: expr = new UnaryExpression(PopOperand()' NodeType.Localloc' CoreSystemTypes.Void); break;            case OpCode.Endfilter: statement = new EndFilter(PopOperand()); transferStatement = true; goto done;            case OpCode.Unaligned_: this.alignment = this.GetByte(); continue;            case OpCode.Volatile_: this.isVolatile = true; continue;            case OpCode.Tail_: this.isTailCall = true; continue;            case OpCode.Initobj: statement = this.ParseInitObject(); goto done;            case OpCode.Constrained_: this.constraint = this.GetMemberFromToken() as TypeNode; continue;            case OpCode.Cpblk: expr = this.ParseTernaryOperation(NodeType.Cpblk); goto done;            case OpCode.Initblk: expr = this.ParseTernaryOperation(NodeType.Initblk); goto done;            case OpCode.Rethrow: statement = new Throw(null); statement.NodeType = NodeType.Rethrow; transferStatement = true; goto done;            case OpCode.Sizeof: expr = new UnaryExpression(new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32); break;            case OpCode.Refanytype: expr = new UnaryExpression(PopOperand()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle); break;            case OpCode.Readonly_: this.isReadOnly = true; continue;            default: throw new InvalidMetadataException(ExceptionStrings.UnknownOpCode);          }          if (this.blockMap[this.counter+1] != null){            transferStatement = true; //Falls through to the next basic block' so implicitly a "transfer" statement            goto done;          }          //^ assume expr != null;  #if FxCop          expr.sourceContext = sourceContext;  #endif  #if FxCop || ILOFFSETS          expr.ILOffset = this.ilOffset;  #endif          this.operandStack.Push(expr);          this.isReadOnly = false;          this.isVolatile = false;          this.isTailCall = false;                  this.alignment = -1;        }
Magic Number,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true){          bool isStatement = false;          startingAddress = this.counter+1; //Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  #if FxCop || ILOFFSETS          this.ilOffset = this.counter;          this.opCode = this.GetOpCode();  #else          OpCode opCode = this.GetOpCode();  #endif  #if FxCop          if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){            expr.sourceContext = sourceContext;            expr.ILOffset = this.ilOffset;            this.operandStack.Push(expr);          }  #endif          switch (opCode){            case OpCode.Nop: statement = new Statement(NodeType.Nop); goto done;            case OpCode.Break: statement = new Statement(NodeType.DebugBreak); goto done;            case OpCode.Ldarg_0: expr = this.Parameters(0); break;            case OpCode.Ldarg_1: expr = this.Parameters(1); break;            case OpCode.Ldarg_2: expr = this.Parameters(2); break;            case OpCode.Ldarg_3: expr = this.Parameters(3); break;            case OpCode.Ldloc_0: expr = this.locals[0]; break;            case OpCode.Ldloc_1: expr = this.locals[1]; break;            case OpCode.Ldloc_2: expr = this.locals[2]; break;            case OpCode.Ldloc_3: expr = this.locals[3]; break;            case OpCode.Stloc_0: statement = new AssignmentStatement(this.locals[0]' PopOperand()); goto done;            case OpCode.Stloc_1: statement = new AssignmentStatement(this.locals[1]' PopOperand()); goto done;            case OpCode.Stloc_2: statement = new AssignmentStatement(this.locals[2]' PopOperand()); goto done;            case OpCode.Stloc_3: statement = new AssignmentStatement(this.locals[3]' PopOperand()); goto done;            case OpCode.Ldarg_S: expr = this.Parameters(this.GetByte()); break;            case OpCode.Ldarga_S: expr = SetType(new UnaryExpression(this.Parameters(this.GetByte())' NodeType.AddressOf)); break;            case OpCode.Starg_S: statement = new AssignmentStatement(this.Parameters(this.GetByte())' PopOperand()); goto done;            case OpCode.Ldloc_S: expr = this.locals[this.GetByte()]; break;            case OpCode.Ldloca_S: expr = SetType(new UnaryExpression(this.locals[this.GetByte()]' NodeType.AddressOf)); break;            case OpCode.Stloc_S: statement = new AssignmentStatement(this.locals[this.GetByte()]' PopOperand()); goto done;            case OpCode.Ldnull: expr = new Literal(null' CoreSystemTypes.Object); break;            case OpCode.Ldc_I4_M1: expr = new Literal(-1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_0: expr = new Literal(0' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_1: expr = new Literal(1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_2: expr = new Literal(2' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_3: expr = new Literal(3' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_4: expr = new Literal(4' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_5: expr = new Literal(5' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_6: expr = new Literal(6' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_7: expr = new Literal(7' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_8: expr = new Literal(8' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_S: expr = new Literal((int)this.GetSByte()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4: expr = new Literal(this.GetInt32()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I8: expr = new Literal(this.GetInt64()' CoreSystemTypes.Int64); break;            case OpCode.Ldc_R4: expr = new Literal(this.GetSingle()' CoreSystemTypes.Single); break;            case OpCode.Ldc_R8: expr = new Literal(this.GetDouble()' CoreSystemTypes.Double); break;            case OpCode.Dup: statement = new ExpressionStatement(new Expression(NodeType.Dup)); goto done;            case OpCode.Pop: statement = new ExpressionStatement(new UnaryExpression(PopOperand()' NodeType.Pop)); goto done;            case OpCode.Jmp: expr = this.ParseCall(NodeType.Jmp' out isStatement); if (isStatement) goto done; break;            case OpCode.Call: expr = this.ParseCall(NodeType.Call' out isStatement); if (isStatement) goto done; break;            case OpCode.Calli: expr = this.ParseCalli(out isStatement); if (isStatement) goto done; break;            case OpCode.Ret:              Expression retVal = BodyParser.TypeIsVoid(this.method.ReturnType) ? null : PopOperand();              statement = new Return(retVal);               transferStatement = true; goto done;            case OpCode.Br_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false); transferStatement = true; goto done;            case OpCode.Brfalse_S: statement = this.ParseBranch(NodeType.LogicalNot' 1' true' false); transferStatement = true; goto done;            case OpCode.Brtrue_S: statement = this.ParseBranch(NodeType.Nop' 1' true' false); transferStatement = true; goto done;            case OpCode.Beq_S: statement = this.ParseBranch(NodeType.Eq' 2' true' false); transferStatement = true; goto done;            case OpCode.Bge_S: statement = this.ParseBranch(NodeType.Ge' 2' true' false); transferStatement = true; goto done;            case OpCode.Bgt_S: statement = this.ParseBranch(NodeType.Gt' 2' true' false); transferStatement = true; goto done;            case OpCode.Ble_S: statement = this.ParseBranch(NodeType.Le' 2' true' false); transferStatement = true; goto done;            case OpCode.Blt_S: statement = this.ParseBranch(NodeType.Lt' 2' true' false); transferStatement = true; goto done;            case OpCode.Bne_Un_S: statement = this.ParseBranch(NodeType.Ne' 2' true' true); transferStatement = true; goto done;            case OpCode.Bge_Un_S: statement = this.ParseBranch(NodeType.Ge' 2' true' true); transferStatement = true; goto done;            case OpCode.Bgt_Un_S: statement = this.ParseBranch(NodeType.Gt' 2' true' true); transferStatement = true; goto done;            case OpCode.Ble_Un_S: statement = this.ParseBranch(NodeType.Le' 2' true' true); transferStatement = true; goto done;            case OpCode.Blt_Un_S: statement = this.ParseBranch(NodeType.Lt' 2' true' true); transferStatement = true; goto done;            case OpCode.Br: statement = this.ParseBranch(NodeType.Nop' 0' false' false); transferStatement = true; goto done;            case OpCode.Brfalse: statement = this.ParseBranch(NodeType.LogicalNot' 1' false' false); transferStatement = true; goto done;            case OpCode.Brtrue: statement = this.ParseBranch(NodeType.Nop' 1' false' false); transferStatement = true; goto done;            case OpCode.Beq: statement = this.ParseBranch(NodeType.Eq' 2' false' false); transferStatement = true; goto done;            case OpCode.Bge: statement = this.ParseBranch(NodeType.Ge' 2' false' false); transferStatement = true; goto done;            case OpCode.Bgt: statement = this.ParseBranch(NodeType.Gt' 2' false' false); transferStatement = true; goto done;            case OpCode.Ble: statement = this.ParseBranch(NodeType.Le' 2' false' false); transferStatement = true; goto done;            case OpCode.Blt: statement = this.ParseBranch(NodeType.Lt' 2' false' false); transferStatement = true; goto done;            case OpCode.Bne_Un: statement = this.ParseBranch(NodeType.Ne' 2' false' true); transferStatement = true; goto done;            case OpCode.Bge_Un: statement = this.ParseBranch(NodeType.Ge' 2' false' true); transferStatement = true; goto done;            case OpCode.Bgt_Un: statement = this.ParseBranch(NodeType.Gt' 2' false' true); transferStatement = true; goto done;            case OpCode.Ble_Un: statement = this.ParseBranch(NodeType.Le' 2' false' true); transferStatement = true; goto done;            case OpCode.Blt_Un: statement = this.ParseBranch(NodeType.Lt' 2' false' true); transferStatement = true; goto done;            case OpCode.Switch: statement = this.ParseSwitchInstruction(); transferStatement = true; goto done;            case OpCode.Ldind_I1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int64' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I: expr = new AddressDereference(PopOperand()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Single' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Double' this.isVolatile' this.alignment); break;            case OpCode.Ldind_Ref: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Object' this.isVolatile' this.alignment); break;            case OpCode.Stind_Ref: statement = this.ParseStoreIndirect(CoreSystemTypes.Object); goto done;            case OpCode.Stind_I1: statement = this.ParseStoreIndirect(CoreSystemTypes.Int8); goto done;            case OpCode.Stind_I2: statement = this.ParseStoreIndirect(CoreSystemTypes.Int16); goto done;            case OpCode.Stind_I4: statement = this.ParseStoreIndirect(CoreSystemTypes.Int32); goto done;            case OpCode.Stind_I8: statement = this.ParseStoreIndirect(CoreSystemTypes.Int64); goto done;            case OpCode.Stind_R4: statement = this.ParseStoreIndirect(CoreSystemTypes.Single); goto done;            case OpCode.Stind_R8: statement = this.ParseStoreIndirect(CoreSystemTypes.Double); goto done;            case OpCode.Add: expr = this.ParseBinaryOperation(NodeType.Add); break;            case OpCode.Sub: expr = this.ParseBinaryOperation(NodeType.Sub); break;            case OpCode.Mul: expr = this.ParseBinaryOperation(NodeType.Mul); break;            case OpCode.Div: expr = this.ParseBinaryOperation(NodeType.Div); break;            case OpCode.Div_Un: expr = this.ParseBinaryOperation(NodeType.Div_Un); break;            case OpCode.Rem: expr = this.ParseBinaryOperation(NodeType.Rem); break;            case OpCode.Rem_Un: expr = this.ParseBinaryOperation(NodeType.Rem_Un); break;            case OpCode.And: expr = this.ParseBinaryOperation(NodeType.And); break;            case OpCode.Or: expr = this.ParseBinaryOperation(NodeType.Or); break;            case OpCode.Xor: expr = this.ParseBinaryOperation(NodeType.Xor); break;            case OpCode.Shl: expr = this.ParseBinaryOperation(NodeType.Shl); break;            case OpCode.Shr: expr = this.ParseBinaryOperation(NodeType.Shr); break;            case OpCode.Shr_Un: expr = this.ParseBinaryOperation(NodeType.Shr_Un); break;            case OpCode.Neg: expr = this.ParseUnaryOperation(NodeType.Neg); break;            case OpCode.Not: expr = this.ParseUnaryOperation(NodeType.Not); break;            case OpCode.Conv_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_R4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R4' CoreSystemTypes.Single); break;            case OpCode.Conv_R8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R8' CoreSystemTypes.Double); break;            case OpCode.Conv_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U8' CoreSystemTypes.UInt64); break;            case OpCode.Callvirt: expr = this.ParseCall(NodeType.Callvirt' out isStatement); if (isStatement) goto done; break;            case OpCode.Cpobj: statement = this.ParseCopyObject(); goto done;            case OpCode.Ldobj: expr = new AddressDereference(PopOperand()' (TypeNode)this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldstr: expr = new Literal(this.GetStringFromToken()' CoreSystemTypes.String); break;            case OpCode.Newobj: expr = this.ParseConstruct(); break;            case OpCode.Castclass: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Castclass); break;            case OpCode.Isinst: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Isinst); break;            case OpCode.Conv_R_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R_Un' CoreSystemTypes.Double); break;            case OpCode.Unbox: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Unbox); break;            case OpCode.Throw: statement = new Throw(PopOperand()); transferStatement = true; goto done;            case OpCode.Ldfld:               expr = new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment);              break;            case OpCode.Ldflda:               expr = SetType(new UnaryExpression(new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf));               break;            case OpCode.Stfld: statement = this.ParseStoreField(); goto done;            case OpCode.Ldsfld: expr = new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldsflda: expr = SetType(new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf)); break;            case OpCode.Stsfld: statement = new AssignmentStatement(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' PopOperand()); goto done;            case OpCode.Stobj: statement = this.ParseStoreIndirect((TypeNode)this.GetMemberFromToken()); goto done;            case OpCode.Conv_Ovf_I1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_I2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_I4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_I8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_U2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_U4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_U8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64); break;            case OpCode.Conv_Ovf_I_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr); break;            case OpCode.Box:               TypeNode t = (TypeNode)this.GetMemberFromToken();              TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;              expr = new BinaryExpression(PopOperand()' new Literal(t' CoreSystemTypes.Type)' NodeType.Box' bt); break;            case OpCode.Newarr: expr = this.ParseNewArray(); break;            case OpCode.Ldlen: expr = new UnaryExpression(PopOperand()' NodeType.Ldlen' CoreSystemTypes.UIntPtr); break;            case OpCode.Ldelema: expr = this.ParseArrayElementLoadAddress(); break;            case OpCode.Ldelem_I1:             case OpCode.Ldelem_U1:             case OpCode.Ldelem_I2:             case OpCode.Ldelem_U2:             case OpCode.Ldelem_I4:             case OpCode.Ldelem_U4:             case OpCode.Ldelem_I8:             case OpCode.Ldelem_I:             case OpCode.Ldelem_R4:             case OpCode.Ldelem_R8:             case OpCode.Ldelem_Ref: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem_I:            case OpCode.Stelem_I1:            case OpCode.Stelem_I2:            case OpCode.Stelem_I4:            case OpCode.Stelem_I8:            case OpCode.Stelem_R4:            case OpCode.Stelem_R8:            case OpCode.Stelem_Ref: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Ldelem: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Unbox_Any: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.UnboxAny); break;            case OpCode.Conv_Ovf_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64); break;            case OpCode.Refanyval: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr); break;            case OpCode.Ckfinite: expr = this.ParseUnaryOperation(NodeType.Ckfinite); break;            case OpCode.Mkrefany: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference); break;            case OpCode.Ldtoken: expr = ParseLoadRuntimeMetadataToken(); break;            case OpCode.Conv_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Add_Ovf: expr = this.ParseBinaryOperation(NodeType.Add_Ovf); break;            case OpCode.Add_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Add_Ovf_Un); break;            case OpCode.Mul_Ovf: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf); break;            case OpCode.Mul_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf_Un); break;            case OpCode.Sub_Ovf: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf); break;            case OpCode.Sub_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf_Un); break;            case OpCode.Endfinally: statement = new EndFinally(); transferStatement = true; goto done;            case OpCode.Leave: statement = this.ParseBranch(NodeType.Nop' 0' false' false' true); transferStatement = true; goto done;            case OpCode.Leave_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false' true); transferStatement = true; goto done;            case OpCode.Stind_I: statement = this.ParseStoreIndirect(CoreSystemTypes.IntPtr); goto done;            case OpCode.Conv_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Arglist: expr = new Expression(NodeType.Arglist' CoreSystemTypes.ArgIterator); break;            case OpCode.Ceq: expr = this.ParseBinaryComparison(NodeType.Ceq); break;            case OpCode.Cgt: expr = this.ParseBinaryComparison(NodeType.Cgt); break;            case OpCode.Cgt_Un: expr = this.ParseBinaryComparison(NodeType.Cgt_Un); break;            case OpCode.Clt: expr = this.ParseBinaryComparison(NodeType.Clt); break;            case OpCode.Clt_Un: expr = this.ParseBinaryComparison(NodeType.Clt_Un); break;            case OpCode.Ldftn: expr = new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldvirtftn: expr = new BinaryExpression(PopOperand()' new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldarg: expr = this.Parameters((ushort)this.GetInt16()); break;            case OpCode.Ldarga: expr = SetType(new UnaryExpression(this.Parameters((ushort)this.GetInt16())' NodeType.AddressOf)); break;            case OpCode.Starg: statement = new AssignmentStatement(this.Parameters((ushort)this.GetInt16())' PopOperand()); goto done;            case OpCode.Ldloc: expr = this.locals[(ushort)this.GetInt16()]; break;            case OpCode.Ldloca: expr = SetType(new UnaryExpression(this.locals[(ushort)this.GetInt16()]' NodeType.AddressOf)); break;            case OpCode.Stloc: statement = new AssignmentStatement(this.locals[(ushort)this.GetInt16()]' PopOperand()); goto done;            case OpCode.Localloc: expr = new UnaryExpression(PopOperand()' NodeType.Localloc' CoreSystemTypes.Void); break;            case OpCode.Endfilter: statement = new EndFilter(PopOperand()); transferStatement = true; goto done;            case OpCode.Unaligned_: this.alignment = this.GetByte(); continue;            case OpCode.Volatile_: this.isVolatile = true; continue;            case OpCode.Tail_: this.isTailCall = true; continue;            case OpCode.Initobj: statement = this.ParseInitObject(); goto done;            case OpCode.Constrained_: this.constraint = this.GetMemberFromToken() as TypeNode; continue;            case OpCode.Cpblk: expr = this.ParseTernaryOperation(NodeType.Cpblk); goto done;            case OpCode.Initblk: expr = this.ParseTernaryOperation(NodeType.Initblk); goto done;            case OpCode.Rethrow: statement = new Throw(null); statement.NodeType = NodeType.Rethrow; transferStatement = true; goto done;            case OpCode.Sizeof: expr = new UnaryExpression(new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32); break;            case OpCode.Refanytype: expr = new UnaryExpression(PopOperand()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle); break;            case OpCode.Readonly_: this.isReadOnly = true; continue;            default: throw new InvalidMetadataException(ExceptionStrings.UnknownOpCode);          }          if (this.blockMap[this.counter+1] != null){            transferStatement = true; //Falls through to the next basic block' so implicitly a "transfer" statement            goto done;          }          //^ assume expr != null;  #if FxCop          expr.sourceContext = sourceContext;  #endif  #if FxCop || ILOFFSETS          expr.ILOffset = this.ilOffset;  #endif          this.operandStack.Push(expr);          this.isReadOnly = false;          this.isVolatile = false;          this.isTailCall = false;                  this.alignment = -1;        }
Magic Number,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true){          bool isStatement = false;          startingAddress = this.counter+1; //Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  #if FxCop || ILOFFSETS          this.ilOffset = this.counter;          this.opCode = this.GetOpCode();  #else          OpCode opCode = this.GetOpCode();  #endif  #if FxCop          if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){            expr.sourceContext = sourceContext;            expr.ILOffset = this.ilOffset;            this.operandStack.Push(expr);          }  #endif          switch (opCode){            case OpCode.Nop: statement = new Statement(NodeType.Nop); goto done;            case OpCode.Break: statement = new Statement(NodeType.DebugBreak); goto done;            case OpCode.Ldarg_0: expr = this.Parameters(0); break;            case OpCode.Ldarg_1: expr = this.Parameters(1); break;            case OpCode.Ldarg_2: expr = this.Parameters(2); break;            case OpCode.Ldarg_3: expr = this.Parameters(3); break;            case OpCode.Ldloc_0: expr = this.locals[0]; break;            case OpCode.Ldloc_1: expr = this.locals[1]; break;            case OpCode.Ldloc_2: expr = this.locals[2]; break;            case OpCode.Ldloc_3: expr = this.locals[3]; break;            case OpCode.Stloc_0: statement = new AssignmentStatement(this.locals[0]' PopOperand()); goto done;            case OpCode.Stloc_1: statement = new AssignmentStatement(this.locals[1]' PopOperand()); goto done;            case OpCode.Stloc_2: statement = new AssignmentStatement(this.locals[2]' PopOperand()); goto done;            case OpCode.Stloc_3: statement = new AssignmentStatement(this.locals[3]' PopOperand()); goto done;            case OpCode.Ldarg_S: expr = this.Parameters(this.GetByte()); break;            case OpCode.Ldarga_S: expr = SetType(new UnaryExpression(this.Parameters(this.GetByte())' NodeType.AddressOf)); break;            case OpCode.Starg_S: statement = new AssignmentStatement(this.Parameters(this.GetByte())' PopOperand()); goto done;            case OpCode.Ldloc_S: expr = this.locals[this.GetByte()]; break;            case OpCode.Ldloca_S: expr = SetType(new UnaryExpression(this.locals[this.GetByte()]' NodeType.AddressOf)); break;            case OpCode.Stloc_S: statement = new AssignmentStatement(this.locals[this.GetByte()]' PopOperand()); goto done;            case OpCode.Ldnull: expr = new Literal(null' CoreSystemTypes.Object); break;            case OpCode.Ldc_I4_M1: expr = new Literal(-1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_0: expr = new Literal(0' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_1: expr = new Literal(1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_2: expr = new Literal(2' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_3: expr = new Literal(3' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_4: expr = new Literal(4' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_5: expr = new Literal(5' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_6: expr = new Literal(6' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_7: expr = new Literal(7' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_8: expr = new Literal(8' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_S: expr = new Literal((int)this.GetSByte()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4: expr = new Literal(this.GetInt32()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I8: expr = new Literal(this.GetInt64()' CoreSystemTypes.Int64); break;            case OpCode.Ldc_R4: expr = new Literal(this.GetSingle()' CoreSystemTypes.Single); break;            case OpCode.Ldc_R8: expr = new Literal(this.GetDouble()' CoreSystemTypes.Double); break;            case OpCode.Dup: statement = new ExpressionStatement(new Expression(NodeType.Dup)); goto done;            case OpCode.Pop: statement = new ExpressionStatement(new UnaryExpression(PopOperand()' NodeType.Pop)); goto done;            case OpCode.Jmp: expr = this.ParseCall(NodeType.Jmp' out isStatement); if (isStatement) goto done; break;            case OpCode.Call: expr = this.ParseCall(NodeType.Call' out isStatement); if (isStatement) goto done; break;            case OpCode.Calli: expr = this.ParseCalli(out isStatement); if (isStatement) goto done; break;            case OpCode.Ret:              Expression retVal = BodyParser.TypeIsVoid(this.method.ReturnType) ? null : PopOperand();              statement = new Return(retVal);               transferStatement = true; goto done;            case OpCode.Br_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false); transferStatement = true; goto done;            case OpCode.Brfalse_S: statement = this.ParseBranch(NodeType.LogicalNot' 1' true' false); transferStatement = true; goto done;            case OpCode.Brtrue_S: statement = this.ParseBranch(NodeType.Nop' 1' true' false); transferStatement = true; goto done;            case OpCode.Beq_S: statement = this.ParseBranch(NodeType.Eq' 2' true' false); transferStatement = true; goto done;            case OpCode.Bge_S: statement = this.ParseBranch(NodeType.Ge' 2' true' false); transferStatement = true; goto done;            case OpCode.Bgt_S: statement = this.ParseBranch(NodeType.Gt' 2' true' false); transferStatement = true; goto done;            case OpCode.Ble_S: statement = this.ParseBranch(NodeType.Le' 2' true' false); transferStatement = true; goto done;            case OpCode.Blt_S: statement = this.ParseBranch(NodeType.Lt' 2' true' false); transferStatement = true; goto done;            case OpCode.Bne_Un_S: statement = this.ParseBranch(NodeType.Ne' 2' true' true); transferStatement = true; goto done;            case OpCode.Bge_Un_S: statement = this.ParseBranch(NodeType.Ge' 2' true' true); transferStatement = true; goto done;            case OpCode.Bgt_Un_S: statement = this.ParseBranch(NodeType.Gt' 2' true' true); transferStatement = true; goto done;            case OpCode.Ble_Un_S: statement = this.ParseBranch(NodeType.Le' 2' true' true); transferStatement = true; goto done;            case OpCode.Blt_Un_S: statement = this.ParseBranch(NodeType.Lt' 2' true' true); transferStatement = true; goto done;            case OpCode.Br: statement = this.ParseBranch(NodeType.Nop' 0' false' false); transferStatement = true; goto done;            case OpCode.Brfalse: statement = this.ParseBranch(NodeType.LogicalNot' 1' false' false); transferStatement = true; goto done;            case OpCode.Brtrue: statement = this.ParseBranch(NodeType.Nop' 1' false' false); transferStatement = true; goto done;            case OpCode.Beq: statement = this.ParseBranch(NodeType.Eq' 2' false' false); transferStatement = true; goto done;            case OpCode.Bge: statement = this.ParseBranch(NodeType.Ge' 2' false' false); transferStatement = true; goto done;            case OpCode.Bgt: statement = this.ParseBranch(NodeType.Gt' 2' false' false); transferStatement = true; goto done;            case OpCode.Ble: statement = this.ParseBranch(NodeType.Le' 2' false' false); transferStatement = true; goto done;            case OpCode.Blt: statement = this.ParseBranch(NodeType.Lt' 2' false' false); transferStatement = true; goto done;            case OpCode.Bne_Un: statement = this.ParseBranch(NodeType.Ne' 2' false' true); transferStatement = true; goto done;            case OpCode.Bge_Un: statement = this.ParseBranch(NodeType.Ge' 2' false' true); transferStatement = true; goto done;            case OpCode.Bgt_Un: statement = this.ParseBranch(NodeType.Gt' 2' false' true); transferStatement = true; goto done;            case OpCode.Ble_Un: statement = this.ParseBranch(NodeType.Le' 2' false' true); transferStatement = true; goto done;            case OpCode.Blt_Un: statement = this.ParseBranch(NodeType.Lt' 2' false' true); transferStatement = true; goto done;            case OpCode.Switch: statement = this.ParseSwitchInstruction(); transferStatement = true; goto done;            case OpCode.Ldind_I1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int64' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I: expr = new AddressDereference(PopOperand()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Single' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Double' this.isVolatile' this.alignment); break;            case OpCode.Ldind_Ref: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Object' this.isVolatile' this.alignment); break;            case OpCode.Stind_Ref: statement = this.ParseStoreIndirect(CoreSystemTypes.Object); goto done;            case OpCode.Stind_I1: statement = this.ParseStoreIndirect(CoreSystemTypes.Int8); goto done;            case OpCode.Stind_I2: statement = this.ParseStoreIndirect(CoreSystemTypes.Int16); goto done;            case OpCode.Stind_I4: statement = this.ParseStoreIndirect(CoreSystemTypes.Int32); goto done;            case OpCode.Stind_I8: statement = this.ParseStoreIndirect(CoreSystemTypes.Int64); goto done;            case OpCode.Stind_R4: statement = this.ParseStoreIndirect(CoreSystemTypes.Single); goto done;            case OpCode.Stind_R8: statement = this.ParseStoreIndirect(CoreSystemTypes.Double); goto done;            case OpCode.Add: expr = this.ParseBinaryOperation(NodeType.Add); break;            case OpCode.Sub: expr = this.ParseBinaryOperation(NodeType.Sub); break;            case OpCode.Mul: expr = this.ParseBinaryOperation(NodeType.Mul); break;            case OpCode.Div: expr = this.ParseBinaryOperation(NodeType.Div); break;            case OpCode.Div_Un: expr = this.ParseBinaryOperation(NodeType.Div_Un); break;            case OpCode.Rem: expr = this.ParseBinaryOperation(NodeType.Rem); break;            case OpCode.Rem_Un: expr = this.ParseBinaryOperation(NodeType.Rem_Un); break;            case OpCode.And: expr = this.ParseBinaryOperation(NodeType.And); break;            case OpCode.Or: expr = this.ParseBinaryOperation(NodeType.Or); break;            case OpCode.Xor: expr = this.ParseBinaryOperation(NodeType.Xor); break;            case OpCode.Shl: expr = this.ParseBinaryOperation(NodeType.Shl); break;            case OpCode.Shr: expr = this.ParseBinaryOperation(NodeType.Shr); break;            case OpCode.Shr_Un: expr = this.ParseBinaryOperation(NodeType.Shr_Un); break;            case OpCode.Neg: expr = this.ParseUnaryOperation(NodeType.Neg); break;            case OpCode.Not: expr = this.ParseUnaryOperation(NodeType.Not); break;            case OpCode.Conv_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_R4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R4' CoreSystemTypes.Single); break;            case OpCode.Conv_R8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R8' CoreSystemTypes.Double); break;            case OpCode.Conv_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U8' CoreSystemTypes.UInt64); break;            case OpCode.Callvirt: expr = this.ParseCall(NodeType.Callvirt' out isStatement); if (isStatement) goto done; break;            case OpCode.Cpobj: statement = this.ParseCopyObject(); goto done;            case OpCode.Ldobj: expr = new AddressDereference(PopOperand()' (TypeNode)this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldstr: expr = new Literal(this.GetStringFromToken()' CoreSystemTypes.String); break;            case OpCode.Newobj: expr = this.ParseConstruct(); break;            case OpCode.Castclass: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Castclass); break;            case OpCode.Isinst: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Isinst); break;            case OpCode.Conv_R_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R_Un' CoreSystemTypes.Double); break;            case OpCode.Unbox: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Unbox); break;            case OpCode.Throw: statement = new Throw(PopOperand()); transferStatement = true; goto done;            case OpCode.Ldfld:               expr = new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment);              break;            case OpCode.Ldflda:               expr = SetType(new UnaryExpression(new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf));               break;            case OpCode.Stfld: statement = this.ParseStoreField(); goto done;            case OpCode.Ldsfld: expr = new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldsflda: expr = SetType(new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf)); break;            case OpCode.Stsfld: statement = new AssignmentStatement(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' PopOperand()); goto done;            case OpCode.Stobj: statement = this.ParseStoreIndirect((TypeNode)this.GetMemberFromToken()); goto done;            case OpCode.Conv_Ovf_I1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_I2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_I4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_I8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_U2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_U4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_U8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64); break;            case OpCode.Conv_Ovf_I_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr); break;            case OpCode.Box:               TypeNode t = (TypeNode)this.GetMemberFromToken();              TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;              expr = new BinaryExpression(PopOperand()' new Literal(t' CoreSystemTypes.Type)' NodeType.Box' bt); break;            case OpCode.Newarr: expr = this.ParseNewArray(); break;            case OpCode.Ldlen: expr = new UnaryExpression(PopOperand()' NodeType.Ldlen' CoreSystemTypes.UIntPtr); break;            case OpCode.Ldelema: expr = this.ParseArrayElementLoadAddress(); break;            case OpCode.Ldelem_I1:             case OpCode.Ldelem_U1:             case OpCode.Ldelem_I2:             case OpCode.Ldelem_U2:             case OpCode.Ldelem_I4:             case OpCode.Ldelem_U4:             case OpCode.Ldelem_I8:             case OpCode.Ldelem_I:             case OpCode.Ldelem_R4:             case OpCode.Ldelem_R8:             case OpCode.Ldelem_Ref: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem_I:            case OpCode.Stelem_I1:            case OpCode.Stelem_I2:            case OpCode.Stelem_I4:            case OpCode.Stelem_I8:            case OpCode.Stelem_R4:            case OpCode.Stelem_R8:            case OpCode.Stelem_Ref: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Ldelem: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Unbox_Any: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.UnboxAny); break;            case OpCode.Conv_Ovf_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64); break;            case OpCode.Refanyval: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr); break;            case OpCode.Ckfinite: expr = this.ParseUnaryOperation(NodeType.Ckfinite); break;            case OpCode.Mkrefany: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference); break;            case OpCode.Ldtoken: expr = ParseLoadRuntimeMetadataToken(); break;            case OpCode.Conv_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Add_Ovf: expr = this.ParseBinaryOperation(NodeType.Add_Ovf); break;            case OpCode.Add_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Add_Ovf_Un); break;            case OpCode.Mul_Ovf: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf); break;            case OpCode.Mul_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf_Un); break;            case OpCode.Sub_Ovf: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf); break;            case OpCode.Sub_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf_Un); break;            case OpCode.Endfinally: statement = new EndFinally(); transferStatement = true; goto done;            case OpCode.Leave: statement = this.ParseBranch(NodeType.Nop' 0' false' false' true); transferStatement = true; goto done;            case OpCode.Leave_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false' true); transferStatement = true; goto done;            case OpCode.Stind_I: statement = this.ParseStoreIndirect(CoreSystemTypes.IntPtr); goto done;            case OpCode.Conv_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Arglist: expr = new Expression(NodeType.Arglist' CoreSystemTypes.ArgIterator); break;            case OpCode.Ceq: expr = this.ParseBinaryComparison(NodeType.Ceq); break;            case OpCode.Cgt: expr = this.ParseBinaryComparison(NodeType.Cgt); break;            case OpCode.Cgt_Un: expr = this.ParseBinaryComparison(NodeType.Cgt_Un); break;            case OpCode.Clt: expr = this.ParseBinaryComparison(NodeType.Clt); break;            case OpCode.Clt_Un: expr = this.ParseBinaryComparison(NodeType.Clt_Un); break;            case OpCode.Ldftn: expr = new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldvirtftn: expr = new BinaryExpression(PopOperand()' new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldarg: expr = this.Parameters((ushort)this.GetInt16()); break;            case OpCode.Ldarga: expr = SetType(new UnaryExpression(this.Parameters((ushort)this.GetInt16())' NodeType.AddressOf)); break;            case OpCode.Starg: statement = new AssignmentStatement(this.Parameters((ushort)this.GetInt16())' PopOperand()); goto done;            case OpCode.Ldloc: expr = this.locals[(ushort)this.GetInt16()]; break;            case OpCode.Ldloca: expr = SetType(new UnaryExpression(this.locals[(ushort)this.GetInt16()]' NodeType.AddressOf)); break;            case OpCode.Stloc: statement = new AssignmentStatement(this.locals[(ushort)this.GetInt16()]' PopOperand()); goto done;            case OpCode.Localloc: expr = new UnaryExpression(PopOperand()' NodeType.Localloc' CoreSystemTypes.Void); break;            case OpCode.Endfilter: statement = new EndFilter(PopOperand()); transferStatement = true; goto done;            case OpCode.Unaligned_: this.alignment = this.GetByte(); continue;            case OpCode.Volatile_: this.isVolatile = true; continue;            case OpCode.Tail_: this.isTailCall = true; continue;            case OpCode.Initobj: statement = this.ParseInitObject(); goto done;            case OpCode.Constrained_: this.constraint = this.GetMemberFromToken() as TypeNode; continue;            case OpCode.Cpblk: expr = this.ParseTernaryOperation(NodeType.Cpblk); goto done;            case OpCode.Initblk: expr = this.ParseTernaryOperation(NodeType.Initblk); goto done;            case OpCode.Rethrow: statement = new Throw(null); statement.NodeType = NodeType.Rethrow; transferStatement = true; goto done;            case OpCode.Sizeof: expr = new UnaryExpression(new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32); break;            case OpCode.Refanytype: expr = new UnaryExpression(PopOperand()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle); break;            case OpCode.Readonly_: this.isReadOnly = true; continue;            default: throw new InvalidMetadataException(ExceptionStrings.UnknownOpCode);          }          if (this.blockMap[this.counter+1] != null){            transferStatement = true; //Falls through to the next basic block' so implicitly a "transfer" statement            goto done;          }          //^ assume expr != null;  #if FxCop          expr.sourceContext = sourceContext;  #endif  #if FxCop || ILOFFSETS          expr.ILOffset = this.ilOffset;  #endif          this.operandStack.Push(expr);          this.isReadOnly = false;          this.isVolatile = false;          this.isTailCall = false;                  this.alignment = -1;        }
Magic Number,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true){          bool isStatement = false;          startingAddress = this.counter+1; //Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  #if FxCop || ILOFFSETS          this.ilOffset = this.counter;          this.opCode = this.GetOpCode();  #else          OpCode opCode = this.GetOpCode();  #endif  #if FxCop          if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){            expr.sourceContext = sourceContext;            expr.ILOffset = this.ilOffset;            this.operandStack.Push(expr);          }  #endif          switch (opCode){            case OpCode.Nop: statement = new Statement(NodeType.Nop); goto done;            case OpCode.Break: statement = new Statement(NodeType.DebugBreak); goto done;            case OpCode.Ldarg_0: expr = this.Parameters(0); break;            case OpCode.Ldarg_1: expr = this.Parameters(1); break;            case OpCode.Ldarg_2: expr = this.Parameters(2); break;            case OpCode.Ldarg_3: expr = this.Parameters(3); break;            case OpCode.Ldloc_0: expr = this.locals[0]; break;            case OpCode.Ldloc_1: expr = this.locals[1]; break;            case OpCode.Ldloc_2: expr = this.locals[2]; break;            case OpCode.Ldloc_3: expr = this.locals[3]; break;            case OpCode.Stloc_0: statement = new AssignmentStatement(this.locals[0]' PopOperand()); goto done;            case OpCode.Stloc_1: statement = new AssignmentStatement(this.locals[1]' PopOperand()); goto done;            case OpCode.Stloc_2: statement = new AssignmentStatement(this.locals[2]' PopOperand()); goto done;            case OpCode.Stloc_3: statement = new AssignmentStatement(this.locals[3]' PopOperand()); goto done;            case OpCode.Ldarg_S: expr = this.Parameters(this.GetByte()); break;            case OpCode.Ldarga_S: expr = SetType(new UnaryExpression(this.Parameters(this.GetByte())' NodeType.AddressOf)); break;            case OpCode.Starg_S: statement = new AssignmentStatement(this.Parameters(this.GetByte())' PopOperand()); goto done;            case OpCode.Ldloc_S: expr = this.locals[this.GetByte()]; break;            case OpCode.Ldloca_S: expr = SetType(new UnaryExpression(this.locals[this.GetByte()]' NodeType.AddressOf)); break;            case OpCode.Stloc_S: statement = new AssignmentStatement(this.locals[this.GetByte()]' PopOperand()); goto done;            case OpCode.Ldnull: expr = new Literal(null' CoreSystemTypes.Object); break;            case OpCode.Ldc_I4_M1: expr = new Literal(-1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_0: expr = new Literal(0' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_1: expr = new Literal(1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_2: expr = new Literal(2' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_3: expr = new Literal(3' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_4: expr = new Literal(4' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_5: expr = new Literal(5' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_6: expr = new Literal(6' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_7: expr = new Literal(7' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_8: expr = new Literal(8' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_S: expr = new Literal((int)this.GetSByte()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4: expr = new Literal(this.GetInt32()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I8: expr = new Literal(this.GetInt64()' CoreSystemTypes.Int64); break;            case OpCode.Ldc_R4: expr = new Literal(this.GetSingle()' CoreSystemTypes.Single); break;            case OpCode.Ldc_R8: expr = new Literal(this.GetDouble()' CoreSystemTypes.Double); break;            case OpCode.Dup: statement = new ExpressionStatement(new Expression(NodeType.Dup)); goto done;            case OpCode.Pop: statement = new ExpressionStatement(new UnaryExpression(PopOperand()' NodeType.Pop)); goto done;            case OpCode.Jmp: expr = this.ParseCall(NodeType.Jmp' out isStatement); if (isStatement) goto done; break;            case OpCode.Call: expr = this.ParseCall(NodeType.Call' out isStatement); if (isStatement) goto done; break;            case OpCode.Calli: expr = this.ParseCalli(out isStatement); if (isStatement) goto done; break;            case OpCode.Ret:              Expression retVal = BodyParser.TypeIsVoid(this.method.ReturnType) ? null : PopOperand();              statement = new Return(retVal);               transferStatement = true; goto done;            case OpCode.Br_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false); transferStatement = true; goto done;            case OpCode.Brfalse_S: statement = this.ParseBranch(NodeType.LogicalNot' 1' true' false); transferStatement = true; goto done;            case OpCode.Brtrue_S: statement = this.ParseBranch(NodeType.Nop' 1' true' false); transferStatement = true; goto done;            case OpCode.Beq_S: statement = this.ParseBranch(NodeType.Eq' 2' true' false); transferStatement = true; goto done;            case OpCode.Bge_S: statement = this.ParseBranch(NodeType.Ge' 2' true' false); transferStatement = true; goto done;            case OpCode.Bgt_S: statement = this.ParseBranch(NodeType.Gt' 2' true' false); transferStatement = true; goto done;            case OpCode.Ble_S: statement = this.ParseBranch(NodeType.Le' 2' true' false); transferStatement = true; goto done;            case OpCode.Blt_S: statement = this.ParseBranch(NodeType.Lt' 2' true' false); transferStatement = true; goto done;            case OpCode.Bne_Un_S: statement = this.ParseBranch(NodeType.Ne' 2' true' true); transferStatement = true; goto done;            case OpCode.Bge_Un_S: statement = this.ParseBranch(NodeType.Ge' 2' true' true); transferStatement = true; goto done;            case OpCode.Bgt_Un_S: statement = this.ParseBranch(NodeType.Gt' 2' true' true); transferStatement = true; goto done;            case OpCode.Ble_Un_S: statement = this.ParseBranch(NodeType.Le' 2' true' true); transferStatement = true; goto done;            case OpCode.Blt_Un_S: statement = this.ParseBranch(NodeType.Lt' 2' true' true); transferStatement = true; goto done;            case OpCode.Br: statement = this.ParseBranch(NodeType.Nop' 0' false' false); transferStatement = true; goto done;            case OpCode.Brfalse: statement = this.ParseBranch(NodeType.LogicalNot' 1' false' false); transferStatement = true; goto done;            case OpCode.Brtrue: statement = this.ParseBranch(NodeType.Nop' 1' false' false); transferStatement = true; goto done;            case OpCode.Beq: statement = this.ParseBranch(NodeType.Eq' 2' false' false); transferStatement = true; goto done;            case OpCode.Bge: statement = this.ParseBranch(NodeType.Ge' 2' false' false); transferStatement = true; goto done;            case OpCode.Bgt: statement = this.ParseBranch(NodeType.Gt' 2' false' false); transferStatement = true; goto done;            case OpCode.Ble: statement = this.ParseBranch(NodeType.Le' 2' false' false); transferStatement = true; goto done;            case OpCode.Blt: statement = this.ParseBranch(NodeType.Lt' 2' false' false); transferStatement = true; goto done;            case OpCode.Bne_Un: statement = this.ParseBranch(NodeType.Ne' 2' false' true); transferStatement = true; goto done;            case OpCode.Bge_Un: statement = this.ParseBranch(NodeType.Ge' 2' false' true); transferStatement = true; goto done;            case OpCode.Bgt_Un: statement = this.ParseBranch(NodeType.Gt' 2' false' true); transferStatement = true; goto done;            case OpCode.Ble_Un: statement = this.ParseBranch(NodeType.Le' 2' false' true); transferStatement = true; goto done;            case OpCode.Blt_Un: statement = this.ParseBranch(NodeType.Lt' 2' false' true); transferStatement = true; goto done;            case OpCode.Switch: statement = this.ParseSwitchInstruction(); transferStatement = true; goto done;            case OpCode.Ldind_I1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int64' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I: expr = new AddressDereference(PopOperand()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Single' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Double' this.isVolatile' this.alignment); break;            case OpCode.Ldind_Ref: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Object' this.isVolatile' this.alignment); break;            case OpCode.Stind_Ref: statement = this.ParseStoreIndirect(CoreSystemTypes.Object); goto done;            case OpCode.Stind_I1: statement = this.ParseStoreIndirect(CoreSystemTypes.Int8); goto done;            case OpCode.Stind_I2: statement = this.ParseStoreIndirect(CoreSystemTypes.Int16); goto done;            case OpCode.Stind_I4: statement = this.ParseStoreIndirect(CoreSystemTypes.Int32); goto done;            case OpCode.Stind_I8: statement = this.ParseStoreIndirect(CoreSystemTypes.Int64); goto done;            case OpCode.Stind_R4: statement = this.ParseStoreIndirect(CoreSystemTypes.Single); goto done;            case OpCode.Stind_R8: statement = this.ParseStoreIndirect(CoreSystemTypes.Double); goto done;            case OpCode.Add: expr = this.ParseBinaryOperation(NodeType.Add); break;            case OpCode.Sub: expr = this.ParseBinaryOperation(NodeType.Sub); break;            case OpCode.Mul: expr = this.ParseBinaryOperation(NodeType.Mul); break;            case OpCode.Div: expr = this.ParseBinaryOperation(NodeType.Div); break;            case OpCode.Div_Un: expr = this.ParseBinaryOperation(NodeType.Div_Un); break;            case OpCode.Rem: expr = this.ParseBinaryOperation(NodeType.Rem); break;            case OpCode.Rem_Un: expr = this.ParseBinaryOperation(NodeType.Rem_Un); break;            case OpCode.And: expr = this.ParseBinaryOperation(NodeType.And); break;            case OpCode.Or: expr = this.ParseBinaryOperation(NodeType.Or); break;            case OpCode.Xor: expr = this.ParseBinaryOperation(NodeType.Xor); break;            case OpCode.Shl: expr = this.ParseBinaryOperation(NodeType.Shl); break;            case OpCode.Shr: expr = this.ParseBinaryOperation(NodeType.Shr); break;            case OpCode.Shr_Un: expr = this.ParseBinaryOperation(NodeType.Shr_Un); break;            case OpCode.Neg: expr = this.ParseUnaryOperation(NodeType.Neg); break;            case OpCode.Not: expr = this.ParseUnaryOperation(NodeType.Not); break;            case OpCode.Conv_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_R4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R4' CoreSystemTypes.Single); break;            case OpCode.Conv_R8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R8' CoreSystemTypes.Double); break;            case OpCode.Conv_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U8' CoreSystemTypes.UInt64); break;            case OpCode.Callvirt: expr = this.ParseCall(NodeType.Callvirt' out isStatement); if (isStatement) goto done; break;            case OpCode.Cpobj: statement = this.ParseCopyObject(); goto done;            case OpCode.Ldobj: expr = new AddressDereference(PopOperand()' (TypeNode)this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldstr: expr = new Literal(this.GetStringFromToken()' CoreSystemTypes.String); break;            case OpCode.Newobj: expr = this.ParseConstruct(); break;            case OpCode.Castclass: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Castclass); break;            case OpCode.Isinst: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Isinst); break;            case OpCode.Conv_R_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R_Un' CoreSystemTypes.Double); break;            case OpCode.Unbox: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Unbox); break;            case OpCode.Throw: statement = new Throw(PopOperand()); transferStatement = true; goto done;            case OpCode.Ldfld:               expr = new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment);              break;            case OpCode.Ldflda:               expr = SetType(new UnaryExpression(new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf));               break;            case OpCode.Stfld: statement = this.ParseStoreField(); goto done;            case OpCode.Ldsfld: expr = new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldsflda: expr = SetType(new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf)); break;            case OpCode.Stsfld: statement = new AssignmentStatement(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' PopOperand()); goto done;            case OpCode.Stobj: statement = this.ParseStoreIndirect((TypeNode)this.GetMemberFromToken()); goto done;            case OpCode.Conv_Ovf_I1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_I2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_I4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_I8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_U2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_U4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_U8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64); break;            case OpCode.Conv_Ovf_I_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr); break;            case OpCode.Box:               TypeNode t = (TypeNode)this.GetMemberFromToken();              TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;              expr = new BinaryExpression(PopOperand()' new Literal(t' CoreSystemTypes.Type)' NodeType.Box' bt); break;            case OpCode.Newarr: expr = this.ParseNewArray(); break;            case OpCode.Ldlen: expr = new UnaryExpression(PopOperand()' NodeType.Ldlen' CoreSystemTypes.UIntPtr); break;            case OpCode.Ldelema: expr = this.ParseArrayElementLoadAddress(); break;            case OpCode.Ldelem_I1:             case OpCode.Ldelem_U1:             case OpCode.Ldelem_I2:             case OpCode.Ldelem_U2:             case OpCode.Ldelem_I4:             case OpCode.Ldelem_U4:             case OpCode.Ldelem_I8:             case OpCode.Ldelem_I:             case OpCode.Ldelem_R4:             case OpCode.Ldelem_R8:             case OpCode.Ldelem_Ref: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem_I:            case OpCode.Stelem_I1:            case OpCode.Stelem_I2:            case OpCode.Stelem_I4:            case OpCode.Stelem_I8:            case OpCode.Stelem_R4:            case OpCode.Stelem_R8:            case OpCode.Stelem_Ref: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Ldelem: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Unbox_Any: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.UnboxAny); break;            case OpCode.Conv_Ovf_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64); break;            case OpCode.Refanyval: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr); break;            case OpCode.Ckfinite: expr = this.ParseUnaryOperation(NodeType.Ckfinite); break;            case OpCode.Mkrefany: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference); break;            case OpCode.Ldtoken: expr = ParseLoadRuntimeMetadataToken(); break;            case OpCode.Conv_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Add_Ovf: expr = this.ParseBinaryOperation(NodeType.Add_Ovf); break;            case OpCode.Add_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Add_Ovf_Un); break;            case OpCode.Mul_Ovf: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf); break;            case OpCode.Mul_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf_Un); break;            case OpCode.Sub_Ovf: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf); break;            case OpCode.Sub_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf_Un); break;            case OpCode.Endfinally: statement = new EndFinally(); transferStatement = true; goto done;            case OpCode.Leave: statement = this.ParseBranch(NodeType.Nop' 0' false' false' true); transferStatement = true; goto done;            case OpCode.Leave_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false' true); transferStatement = true; goto done;            case OpCode.Stind_I: statement = this.ParseStoreIndirect(CoreSystemTypes.IntPtr); goto done;            case OpCode.Conv_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Arglist: expr = new Expression(NodeType.Arglist' CoreSystemTypes.ArgIterator); break;            case OpCode.Ceq: expr = this.ParseBinaryComparison(NodeType.Ceq); break;            case OpCode.Cgt: expr = this.ParseBinaryComparison(NodeType.Cgt); break;            case OpCode.Cgt_Un: expr = this.ParseBinaryComparison(NodeType.Cgt_Un); break;            case OpCode.Clt: expr = this.ParseBinaryComparison(NodeType.Clt); break;            case OpCode.Clt_Un: expr = this.ParseBinaryComparison(NodeType.Clt_Un); break;            case OpCode.Ldftn: expr = new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldvirtftn: expr = new BinaryExpression(PopOperand()' new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldarg: expr = this.Parameters((ushort)this.GetInt16()); break;            case OpCode.Ldarga: expr = SetType(new UnaryExpression(this.Parameters((ushort)this.GetInt16())' NodeType.AddressOf)); break;            case OpCode.Starg: statement = new AssignmentStatement(this.Parameters((ushort)this.GetInt16())' PopOperand()); goto done;            case OpCode.Ldloc: expr = this.locals[(ushort)this.GetInt16()]; break;            case OpCode.Ldloca: expr = SetType(new UnaryExpression(this.locals[(ushort)this.GetInt16()]' NodeType.AddressOf)); break;            case OpCode.Stloc: statement = new AssignmentStatement(this.locals[(ushort)this.GetInt16()]' PopOperand()); goto done;            case OpCode.Localloc: expr = new UnaryExpression(PopOperand()' NodeType.Localloc' CoreSystemTypes.Void); break;            case OpCode.Endfilter: statement = new EndFilter(PopOperand()); transferStatement = true; goto done;            case OpCode.Unaligned_: this.alignment = this.GetByte(); continue;            case OpCode.Volatile_: this.isVolatile = true; continue;            case OpCode.Tail_: this.isTailCall = true; continue;            case OpCode.Initobj: statement = this.ParseInitObject(); goto done;            case OpCode.Constrained_: this.constraint = this.GetMemberFromToken() as TypeNode; continue;            case OpCode.Cpblk: expr = this.ParseTernaryOperation(NodeType.Cpblk); goto done;            case OpCode.Initblk: expr = this.ParseTernaryOperation(NodeType.Initblk); goto done;            case OpCode.Rethrow: statement = new Throw(null); statement.NodeType = NodeType.Rethrow; transferStatement = true; goto done;            case OpCode.Sizeof: expr = new UnaryExpression(new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32); break;            case OpCode.Refanytype: expr = new UnaryExpression(PopOperand()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle); break;            case OpCode.Readonly_: this.isReadOnly = true; continue;            default: throw new InvalidMetadataException(ExceptionStrings.UnknownOpCode);          }          if (this.blockMap[this.counter+1] != null){            transferStatement = true; //Falls through to the next basic block' so implicitly a "transfer" statement            goto done;          }          //^ assume expr != null;  #if FxCop          expr.sourceContext = sourceContext;  #endif  #if FxCop || ILOFFSETS          expr.ILOffset = this.ilOffset;  #endif          this.operandStack.Push(expr);          this.isReadOnly = false;          this.isVolatile = false;          this.isTailCall = false;                  this.alignment = -1;        }
Magic Number,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true){          bool isStatement = false;          startingAddress = this.counter+1; //Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  #if FxCop || ILOFFSETS          this.ilOffset = this.counter;          this.opCode = this.GetOpCode();  #else          OpCode opCode = this.GetOpCode();  #endif  #if FxCop          if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){            expr.sourceContext = sourceContext;            expr.ILOffset = this.ilOffset;            this.operandStack.Push(expr);          }  #endif          switch (opCode){            case OpCode.Nop: statement = new Statement(NodeType.Nop); goto done;            case OpCode.Break: statement = new Statement(NodeType.DebugBreak); goto done;            case OpCode.Ldarg_0: expr = this.Parameters(0); break;            case OpCode.Ldarg_1: expr = this.Parameters(1); break;            case OpCode.Ldarg_2: expr = this.Parameters(2); break;            case OpCode.Ldarg_3: expr = this.Parameters(3); break;            case OpCode.Ldloc_0: expr = this.locals[0]; break;            case OpCode.Ldloc_1: expr = this.locals[1]; break;            case OpCode.Ldloc_2: expr = this.locals[2]; break;            case OpCode.Ldloc_3: expr = this.locals[3]; break;            case OpCode.Stloc_0: statement = new AssignmentStatement(this.locals[0]' PopOperand()); goto done;            case OpCode.Stloc_1: statement = new AssignmentStatement(this.locals[1]' PopOperand()); goto done;            case OpCode.Stloc_2: statement = new AssignmentStatement(this.locals[2]' PopOperand()); goto done;            case OpCode.Stloc_3: statement = new AssignmentStatement(this.locals[3]' PopOperand()); goto done;            case OpCode.Ldarg_S: expr = this.Parameters(this.GetByte()); break;            case OpCode.Ldarga_S: expr = SetType(new UnaryExpression(this.Parameters(this.GetByte())' NodeType.AddressOf)); break;            case OpCode.Starg_S: statement = new AssignmentStatement(this.Parameters(this.GetByte())' PopOperand()); goto done;            case OpCode.Ldloc_S: expr = this.locals[this.GetByte()]; break;            case OpCode.Ldloca_S: expr = SetType(new UnaryExpression(this.locals[this.GetByte()]' NodeType.AddressOf)); break;            case OpCode.Stloc_S: statement = new AssignmentStatement(this.locals[this.GetByte()]' PopOperand()); goto done;            case OpCode.Ldnull: expr = new Literal(null' CoreSystemTypes.Object); break;            case OpCode.Ldc_I4_M1: expr = new Literal(-1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_0: expr = new Literal(0' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_1: expr = new Literal(1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_2: expr = new Literal(2' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_3: expr = new Literal(3' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_4: expr = new Literal(4' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_5: expr = new Literal(5' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_6: expr = new Literal(6' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_7: expr = new Literal(7' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_8: expr = new Literal(8' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_S: expr = new Literal((int)this.GetSByte()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4: expr = new Literal(this.GetInt32()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I8: expr = new Literal(this.GetInt64()' CoreSystemTypes.Int64); break;            case OpCode.Ldc_R4: expr = new Literal(this.GetSingle()' CoreSystemTypes.Single); break;            case OpCode.Ldc_R8: expr = new Literal(this.GetDouble()' CoreSystemTypes.Double); break;            case OpCode.Dup: statement = new ExpressionStatement(new Expression(NodeType.Dup)); goto done;            case OpCode.Pop: statement = new ExpressionStatement(new UnaryExpression(PopOperand()' NodeType.Pop)); goto done;            case OpCode.Jmp: expr = this.ParseCall(NodeType.Jmp' out isStatement); if (isStatement) goto done; break;            case OpCode.Call: expr = this.ParseCall(NodeType.Call' out isStatement); if (isStatement) goto done; break;            case OpCode.Calli: expr = this.ParseCalli(out isStatement); if (isStatement) goto done; break;            case OpCode.Ret:              Expression retVal = BodyParser.TypeIsVoid(this.method.ReturnType) ? null : PopOperand();              statement = new Return(retVal);               transferStatement = true; goto done;            case OpCode.Br_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false); transferStatement = true; goto done;            case OpCode.Brfalse_S: statement = this.ParseBranch(NodeType.LogicalNot' 1' true' false); transferStatement = true; goto done;            case OpCode.Brtrue_S: statement = this.ParseBranch(NodeType.Nop' 1' true' false); transferStatement = true; goto done;            case OpCode.Beq_S: statement = this.ParseBranch(NodeType.Eq' 2' true' false); transferStatement = true; goto done;            case OpCode.Bge_S: statement = this.ParseBranch(NodeType.Ge' 2' true' false); transferStatement = true; goto done;            case OpCode.Bgt_S: statement = this.ParseBranch(NodeType.Gt' 2' true' false); transferStatement = true; goto done;            case OpCode.Ble_S: statement = this.ParseBranch(NodeType.Le' 2' true' false); transferStatement = true; goto done;            case OpCode.Blt_S: statement = this.ParseBranch(NodeType.Lt' 2' true' false); transferStatement = true; goto done;            case OpCode.Bne_Un_S: statement = this.ParseBranch(NodeType.Ne' 2' true' true); transferStatement = true; goto done;            case OpCode.Bge_Un_S: statement = this.ParseBranch(NodeType.Ge' 2' true' true); transferStatement = true; goto done;            case OpCode.Bgt_Un_S: statement = this.ParseBranch(NodeType.Gt' 2' true' true); transferStatement = true; goto done;            case OpCode.Ble_Un_S: statement = this.ParseBranch(NodeType.Le' 2' true' true); transferStatement = true; goto done;            case OpCode.Blt_Un_S: statement = this.ParseBranch(NodeType.Lt' 2' true' true); transferStatement = true; goto done;            case OpCode.Br: statement = this.ParseBranch(NodeType.Nop' 0' false' false); transferStatement = true; goto done;            case OpCode.Brfalse: statement = this.ParseBranch(NodeType.LogicalNot' 1' false' false); transferStatement = true; goto done;            case OpCode.Brtrue: statement = this.ParseBranch(NodeType.Nop' 1' false' false); transferStatement = true; goto done;            case OpCode.Beq: statement = this.ParseBranch(NodeType.Eq' 2' false' false); transferStatement = true; goto done;            case OpCode.Bge: statement = this.ParseBranch(NodeType.Ge' 2' false' false); transferStatement = true; goto done;            case OpCode.Bgt: statement = this.ParseBranch(NodeType.Gt' 2' false' false); transferStatement = true; goto done;            case OpCode.Ble: statement = this.ParseBranch(NodeType.Le' 2' false' false); transferStatement = true; goto done;            case OpCode.Blt: statement = this.ParseBranch(NodeType.Lt' 2' false' false); transferStatement = true; goto done;            case OpCode.Bne_Un: statement = this.ParseBranch(NodeType.Ne' 2' false' true); transferStatement = true; goto done;            case OpCode.Bge_Un: statement = this.ParseBranch(NodeType.Ge' 2' false' true); transferStatement = true; goto done;            case OpCode.Bgt_Un: statement = this.ParseBranch(NodeType.Gt' 2' false' true); transferStatement = true; goto done;            case OpCode.Ble_Un: statement = this.ParseBranch(NodeType.Le' 2' false' true); transferStatement = true; goto done;            case OpCode.Blt_Un: statement = this.ParseBranch(NodeType.Lt' 2' false' true); transferStatement = true; goto done;            case OpCode.Switch: statement = this.ParseSwitchInstruction(); transferStatement = true; goto done;            case OpCode.Ldind_I1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int64' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I: expr = new AddressDereference(PopOperand()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Single' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Double' this.isVolatile' this.alignment); break;            case OpCode.Ldind_Ref: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Object' this.isVolatile' this.alignment); break;            case OpCode.Stind_Ref: statement = this.ParseStoreIndirect(CoreSystemTypes.Object); goto done;            case OpCode.Stind_I1: statement = this.ParseStoreIndirect(CoreSystemTypes.Int8); goto done;            case OpCode.Stind_I2: statement = this.ParseStoreIndirect(CoreSystemTypes.Int16); goto done;            case OpCode.Stind_I4: statement = this.ParseStoreIndirect(CoreSystemTypes.Int32); goto done;            case OpCode.Stind_I8: statement = this.ParseStoreIndirect(CoreSystemTypes.Int64); goto done;            case OpCode.Stind_R4: statement = this.ParseStoreIndirect(CoreSystemTypes.Single); goto done;            case OpCode.Stind_R8: statement = this.ParseStoreIndirect(CoreSystemTypes.Double); goto done;            case OpCode.Add: expr = this.ParseBinaryOperation(NodeType.Add); break;            case OpCode.Sub: expr = this.ParseBinaryOperation(NodeType.Sub); break;            case OpCode.Mul: expr = this.ParseBinaryOperation(NodeType.Mul); break;            case OpCode.Div: expr = this.ParseBinaryOperation(NodeType.Div); break;            case OpCode.Div_Un: expr = this.ParseBinaryOperation(NodeType.Div_Un); break;            case OpCode.Rem: expr = this.ParseBinaryOperation(NodeType.Rem); break;            case OpCode.Rem_Un: expr = this.ParseBinaryOperation(NodeType.Rem_Un); break;            case OpCode.And: expr = this.ParseBinaryOperation(NodeType.And); break;            case OpCode.Or: expr = this.ParseBinaryOperation(NodeType.Or); break;            case OpCode.Xor: expr = this.ParseBinaryOperation(NodeType.Xor); break;            case OpCode.Shl: expr = this.ParseBinaryOperation(NodeType.Shl); break;            case OpCode.Shr: expr = this.ParseBinaryOperation(NodeType.Shr); break;            case OpCode.Shr_Un: expr = this.ParseBinaryOperation(NodeType.Shr_Un); break;            case OpCode.Neg: expr = this.ParseUnaryOperation(NodeType.Neg); break;            case OpCode.Not: expr = this.ParseUnaryOperation(NodeType.Not); break;            case OpCode.Conv_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_R4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R4' CoreSystemTypes.Single); break;            case OpCode.Conv_R8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R8' CoreSystemTypes.Double); break;            case OpCode.Conv_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U8' CoreSystemTypes.UInt64); break;            case OpCode.Callvirt: expr = this.ParseCall(NodeType.Callvirt' out isStatement); if (isStatement) goto done; break;            case OpCode.Cpobj: statement = this.ParseCopyObject(); goto done;            case OpCode.Ldobj: expr = new AddressDereference(PopOperand()' (TypeNode)this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldstr: expr = new Literal(this.GetStringFromToken()' CoreSystemTypes.String); break;            case OpCode.Newobj: expr = this.ParseConstruct(); break;            case OpCode.Castclass: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Castclass); break;            case OpCode.Isinst: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Isinst); break;            case OpCode.Conv_R_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R_Un' CoreSystemTypes.Double); break;            case OpCode.Unbox: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Unbox); break;            case OpCode.Throw: statement = new Throw(PopOperand()); transferStatement = true; goto done;            case OpCode.Ldfld:               expr = new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment);              break;            case OpCode.Ldflda:               expr = SetType(new UnaryExpression(new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf));               break;            case OpCode.Stfld: statement = this.ParseStoreField(); goto done;            case OpCode.Ldsfld: expr = new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldsflda: expr = SetType(new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf)); break;            case OpCode.Stsfld: statement = new AssignmentStatement(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' PopOperand()); goto done;            case OpCode.Stobj: statement = this.ParseStoreIndirect((TypeNode)this.GetMemberFromToken()); goto done;            case OpCode.Conv_Ovf_I1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_I2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_I4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_I8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_U2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_U4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_U8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64); break;            case OpCode.Conv_Ovf_I_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr); break;            case OpCode.Box:               TypeNode t = (TypeNode)this.GetMemberFromToken();              TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;              expr = new BinaryExpression(PopOperand()' new Literal(t' CoreSystemTypes.Type)' NodeType.Box' bt); break;            case OpCode.Newarr: expr = this.ParseNewArray(); break;            case OpCode.Ldlen: expr = new UnaryExpression(PopOperand()' NodeType.Ldlen' CoreSystemTypes.UIntPtr); break;            case OpCode.Ldelema: expr = this.ParseArrayElementLoadAddress(); break;            case OpCode.Ldelem_I1:             case OpCode.Ldelem_U1:             case OpCode.Ldelem_I2:             case OpCode.Ldelem_U2:             case OpCode.Ldelem_I4:             case OpCode.Ldelem_U4:             case OpCode.Ldelem_I8:             case OpCode.Ldelem_I:             case OpCode.Ldelem_R4:             case OpCode.Ldelem_R8:             case OpCode.Ldelem_Ref: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem_I:            case OpCode.Stelem_I1:            case OpCode.Stelem_I2:            case OpCode.Stelem_I4:            case OpCode.Stelem_I8:            case OpCode.Stelem_R4:            case OpCode.Stelem_R8:            case OpCode.Stelem_Ref: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Ldelem: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Unbox_Any: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.UnboxAny); break;            case OpCode.Conv_Ovf_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64); break;            case OpCode.Refanyval: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr); break;            case OpCode.Ckfinite: expr = this.ParseUnaryOperation(NodeType.Ckfinite); break;            case OpCode.Mkrefany: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference); break;            case OpCode.Ldtoken: expr = ParseLoadRuntimeMetadataToken(); break;            case OpCode.Conv_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Add_Ovf: expr = this.ParseBinaryOperation(NodeType.Add_Ovf); break;            case OpCode.Add_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Add_Ovf_Un); break;            case OpCode.Mul_Ovf: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf); break;            case OpCode.Mul_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf_Un); break;            case OpCode.Sub_Ovf: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf); break;            case OpCode.Sub_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf_Un); break;            case OpCode.Endfinally: statement = new EndFinally(); transferStatement = true; goto done;            case OpCode.Leave: statement = this.ParseBranch(NodeType.Nop' 0' false' false' true); transferStatement = true; goto done;            case OpCode.Leave_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false' true); transferStatement = true; goto done;            case OpCode.Stind_I: statement = this.ParseStoreIndirect(CoreSystemTypes.IntPtr); goto done;            case OpCode.Conv_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Arglist: expr = new Expression(NodeType.Arglist' CoreSystemTypes.ArgIterator); break;            case OpCode.Ceq: expr = this.ParseBinaryComparison(NodeType.Ceq); break;            case OpCode.Cgt: expr = this.ParseBinaryComparison(NodeType.Cgt); break;            case OpCode.Cgt_Un: expr = this.ParseBinaryComparison(NodeType.Cgt_Un); break;            case OpCode.Clt: expr = this.ParseBinaryComparison(NodeType.Clt); break;            case OpCode.Clt_Un: expr = this.ParseBinaryComparison(NodeType.Clt_Un); break;            case OpCode.Ldftn: expr = new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldvirtftn: expr = new BinaryExpression(PopOperand()' new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldarg: expr = this.Parameters((ushort)this.GetInt16()); break;            case OpCode.Ldarga: expr = SetType(new UnaryExpression(this.Parameters((ushort)this.GetInt16())' NodeType.AddressOf)); break;            case OpCode.Starg: statement = new AssignmentStatement(this.Parameters((ushort)this.GetInt16())' PopOperand()); goto done;            case OpCode.Ldloc: expr = this.locals[(ushort)this.GetInt16()]; break;            case OpCode.Ldloca: expr = SetType(new UnaryExpression(this.locals[(ushort)this.GetInt16()]' NodeType.AddressOf)); break;            case OpCode.Stloc: statement = new AssignmentStatement(this.locals[(ushort)this.GetInt16()]' PopOperand()); goto done;            case OpCode.Localloc: expr = new UnaryExpression(PopOperand()' NodeType.Localloc' CoreSystemTypes.Void); break;            case OpCode.Endfilter: statement = new EndFilter(PopOperand()); transferStatement = true; goto done;            case OpCode.Unaligned_: this.alignment = this.GetByte(); continue;            case OpCode.Volatile_: this.isVolatile = true; continue;            case OpCode.Tail_: this.isTailCall = true; continue;            case OpCode.Initobj: statement = this.ParseInitObject(); goto done;            case OpCode.Constrained_: this.constraint = this.GetMemberFromToken() as TypeNode; continue;            case OpCode.Cpblk: expr = this.ParseTernaryOperation(NodeType.Cpblk); goto done;            case OpCode.Initblk: expr = this.ParseTernaryOperation(NodeType.Initblk); goto done;            case OpCode.Rethrow: statement = new Throw(null); statement.NodeType = NodeType.Rethrow; transferStatement = true; goto done;            case OpCode.Sizeof: expr = new UnaryExpression(new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32); break;            case OpCode.Refanytype: expr = new UnaryExpression(PopOperand()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle); break;            case OpCode.Readonly_: this.isReadOnly = true; continue;            default: throw new InvalidMetadataException(ExceptionStrings.UnknownOpCode);          }          if (this.blockMap[this.counter+1] != null){            transferStatement = true; //Falls through to the next basic block' so implicitly a "transfer" statement            goto done;          }          //^ assume expr != null;  #if FxCop          expr.sourceContext = sourceContext;  #endif  #if FxCop || ILOFFSETS          expr.ILOffset = this.ilOffset;  #endif          this.operandStack.Push(expr);          this.isReadOnly = false;          this.isVolatile = false;          this.isTailCall = false;                  this.alignment = -1;        }
Magic Number,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true){          bool isStatement = false;          startingAddress = this.counter+1; //Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  #if FxCop || ILOFFSETS          this.ilOffset = this.counter;          this.opCode = this.GetOpCode();  #else          OpCode opCode = this.GetOpCode();  #endif  #if FxCop          if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){            expr.sourceContext = sourceContext;            expr.ILOffset = this.ilOffset;            this.operandStack.Push(expr);          }  #endif          switch (opCode){            case OpCode.Nop: statement = new Statement(NodeType.Nop); goto done;            case OpCode.Break: statement = new Statement(NodeType.DebugBreak); goto done;            case OpCode.Ldarg_0: expr = this.Parameters(0); break;            case OpCode.Ldarg_1: expr = this.Parameters(1); break;            case OpCode.Ldarg_2: expr = this.Parameters(2); break;            case OpCode.Ldarg_3: expr = this.Parameters(3); break;            case OpCode.Ldloc_0: expr = this.locals[0]; break;            case OpCode.Ldloc_1: expr = this.locals[1]; break;            case OpCode.Ldloc_2: expr = this.locals[2]; break;            case OpCode.Ldloc_3: expr = this.locals[3]; break;            case OpCode.Stloc_0: statement = new AssignmentStatement(this.locals[0]' PopOperand()); goto done;            case OpCode.Stloc_1: statement = new AssignmentStatement(this.locals[1]' PopOperand()); goto done;            case OpCode.Stloc_2: statement = new AssignmentStatement(this.locals[2]' PopOperand()); goto done;            case OpCode.Stloc_3: statement = new AssignmentStatement(this.locals[3]' PopOperand()); goto done;            case OpCode.Ldarg_S: expr = this.Parameters(this.GetByte()); break;            case OpCode.Ldarga_S: expr = SetType(new UnaryExpression(this.Parameters(this.GetByte())' NodeType.AddressOf)); break;            case OpCode.Starg_S: statement = new AssignmentStatement(this.Parameters(this.GetByte())' PopOperand()); goto done;            case OpCode.Ldloc_S: expr = this.locals[this.GetByte()]; break;            case OpCode.Ldloca_S: expr = SetType(new UnaryExpression(this.locals[this.GetByte()]' NodeType.AddressOf)); break;            case OpCode.Stloc_S: statement = new AssignmentStatement(this.locals[this.GetByte()]' PopOperand()); goto done;            case OpCode.Ldnull: expr = new Literal(null' CoreSystemTypes.Object); break;            case OpCode.Ldc_I4_M1: expr = new Literal(-1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_0: expr = new Literal(0' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_1: expr = new Literal(1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_2: expr = new Literal(2' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_3: expr = new Literal(3' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_4: expr = new Literal(4' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_5: expr = new Literal(5' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_6: expr = new Literal(6' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_7: expr = new Literal(7' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_8: expr = new Literal(8' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_S: expr = new Literal((int)this.GetSByte()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4: expr = new Literal(this.GetInt32()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I8: expr = new Literal(this.GetInt64()' CoreSystemTypes.Int64); break;            case OpCode.Ldc_R4: expr = new Literal(this.GetSingle()' CoreSystemTypes.Single); break;            case OpCode.Ldc_R8: expr = new Literal(this.GetDouble()' CoreSystemTypes.Double); break;            case OpCode.Dup: statement = new ExpressionStatement(new Expression(NodeType.Dup)); goto done;            case OpCode.Pop: statement = new ExpressionStatement(new UnaryExpression(PopOperand()' NodeType.Pop)); goto done;            case OpCode.Jmp: expr = this.ParseCall(NodeType.Jmp' out isStatement); if (isStatement) goto done; break;            case OpCode.Call: expr = this.ParseCall(NodeType.Call' out isStatement); if (isStatement) goto done; break;            case OpCode.Calli: expr = this.ParseCalli(out isStatement); if (isStatement) goto done; break;            case OpCode.Ret:              Expression retVal = BodyParser.TypeIsVoid(this.method.ReturnType) ? null : PopOperand();              statement = new Return(retVal);               transferStatement = true; goto done;            case OpCode.Br_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false); transferStatement = true; goto done;            case OpCode.Brfalse_S: statement = this.ParseBranch(NodeType.LogicalNot' 1' true' false); transferStatement = true; goto done;            case OpCode.Brtrue_S: statement = this.ParseBranch(NodeType.Nop' 1' true' false); transferStatement = true; goto done;            case OpCode.Beq_S: statement = this.ParseBranch(NodeType.Eq' 2' true' false); transferStatement = true; goto done;            case OpCode.Bge_S: statement = this.ParseBranch(NodeType.Ge' 2' true' false); transferStatement = true; goto done;            case OpCode.Bgt_S: statement = this.ParseBranch(NodeType.Gt' 2' true' false); transferStatement = true; goto done;            case OpCode.Ble_S: statement = this.ParseBranch(NodeType.Le' 2' true' false); transferStatement = true; goto done;            case OpCode.Blt_S: statement = this.ParseBranch(NodeType.Lt' 2' true' false); transferStatement = true; goto done;            case OpCode.Bne_Un_S: statement = this.ParseBranch(NodeType.Ne' 2' true' true); transferStatement = true; goto done;            case OpCode.Bge_Un_S: statement = this.ParseBranch(NodeType.Ge' 2' true' true); transferStatement = true; goto done;            case OpCode.Bgt_Un_S: statement = this.ParseBranch(NodeType.Gt' 2' true' true); transferStatement = true; goto done;            case OpCode.Ble_Un_S: statement = this.ParseBranch(NodeType.Le' 2' true' true); transferStatement = true; goto done;            case OpCode.Blt_Un_S: statement = this.ParseBranch(NodeType.Lt' 2' true' true); transferStatement = true; goto done;            case OpCode.Br: statement = this.ParseBranch(NodeType.Nop' 0' false' false); transferStatement = true; goto done;            case OpCode.Brfalse: statement = this.ParseBranch(NodeType.LogicalNot' 1' false' false); transferStatement = true; goto done;            case OpCode.Brtrue: statement = this.ParseBranch(NodeType.Nop' 1' false' false); transferStatement = true; goto done;            case OpCode.Beq: statement = this.ParseBranch(NodeType.Eq' 2' false' false); transferStatement = true; goto done;            case OpCode.Bge: statement = this.ParseBranch(NodeType.Ge' 2' false' false); transferStatement = true; goto done;            case OpCode.Bgt: statement = this.ParseBranch(NodeType.Gt' 2' false' false); transferStatement = true; goto done;            case OpCode.Ble: statement = this.ParseBranch(NodeType.Le' 2' false' false); transferStatement = true; goto done;            case OpCode.Blt: statement = this.ParseBranch(NodeType.Lt' 2' false' false); transferStatement = true; goto done;            case OpCode.Bne_Un: statement = this.ParseBranch(NodeType.Ne' 2' false' true); transferStatement = true; goto done;            case OpCode.Bge_Un: statement = this.ParseBranch(NodeType.Ge' 2' false' true); transferStatement = true; goto done;            case OpCode.Bgt_Un: statement = this.ParseBranch(NodeType.Gt' 2' false' true); transferStatement = true; goto done;            case OpCode.Ble_Un: statement = this.ParseBranch(NodeType.Le' 2' false' true); transferStatement = true; goto done;            case OpCode.Blt_Un: statement = this.ParseBranch(NodeType.Lt' 2' false' true); transferStatement = true; goto done;            case OpCode.Switch: statement = this.ParseSwitchInstruction(); transferStatement = true; goto done;            case OpCode.Ldind_I1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int64' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I: expr = new AddressDereference(PopOperand()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Single' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Double' this.isVolatile' this.alignment); break;            case OpCode.Ldind_Ref: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Object' this.isVolatile' this.alignment); break;            case OpCode.Stind_Ref: statement = this.ParseStoreIndirect(CoreSystemTypes.Object); goto done;            case OpCode.Stind_I1: statement = this.ParseStoreIndirect(CoreSystemTypes.Int8); goto done;            case OpCode.Stind_I2: statement = this.ParseStoreIndirect(CoreSystemTypes.Int16); goto done;            case OpCode.Stind_I4: statement = this.ParseStoreIndirect(CoreSystemTypes.Int32); goto done;            case OpCode.Stind_I8: statement = this.ParseStoreIndirect(CoreSystemTypes.Int64); goto done;            case OpCode.Stind_R4: statement = this.ParseStoreIndirect(CoreSystemTypes.Single); goto done;            case OpCode.Stind_R8: statement = this.ParseStoreIndirect(CoreSystemTypes.Double); goto done;            case OpCode.Add: expr = this.ParseBinaryOperation(NodeType.Add); break;            case OpCode.Sub: expr = this.ParseBinaryOperation(NodeType.Sub); break;            case OpCode.Mul: expr = this.ParseBinaryOperation(NodeType.Mul); break;            case OpCode.Div: expr = this.ParseBinaryOperation(NodeType.Div); break;            case OpCode.Div_Un: expr = this.ParseBinaryOperation(NodeType.Div_Un); break;            case OpCode.Rem: expr = this.ParseBinaryOperation(NodeType.Rem); break;            case OpCode.Rem_Un: expr = this.ParseBinaryOperation(NodeType.Rem_Un); break;            case OpCode.And: expr = this.ParseBinaryOperation(NodeType.And); break;            case OpCode.Or: expr = this.ParseBinaryOperation(NodeType.Or); break;            case OpCode.Xor: expr = this.ParseBinaryOperation(NodeType.Xor); break;            case OpCode.Shl: expr = this.ParseBinaryOperation(NodeType.Shl); break;            case OpCode.Shr: expr = this.ParseBinaryOperation(NodeType.Shr); break;            case OpCode.Shr_Un: expr = this.ParseBinaryOperation(NodeType.Shr_Un); break;            case OpCode.Neg: expr = this.ParseUnaryOperation(NodeType.Neg); break;            case OpCode.Not: expr = this.ParseUnaryOperation(NodeType.Not); break;            case OpCode.Conv_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_R4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R4' CoreSystemTypes.Single); break;            case OpCode.Conv_R8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R8' CoreSystemTypes.Double); break;            case OpCode.Conv_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U8' CoreSystemTypes.UInt64); break;            case OpCode.Callvirt: expr = this.ParseCall(NodeType.Callvirt' out isStatement); if (isStatement) goto done; break;            case OpCode.Cpobj: statement = this.ParseCopyObject(); goto done;            case OpCode.Ldobj: expr = new AddressDereference(PopOperand()' (TypeNode)this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldstr: expr = new Literal(this.GetStringFromToken()' CoreSystemTypes.String); break;            case OpCode.Newobj: expr = this.ParseConstruct(); break;            case OpCode.Castclass: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Castclass); break;            case OpCode.Isinst: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Isinst); break;            case OpCode.Conv_R_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R_Un' CoreSystemTypes.Double); break;            case OpCode.Unbox: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Unbox); break;            case OpCode.Throw: statement = new Throw(PopOperand()); transferStatement = true; goto done;            case OpCode.Ldfld:               expr = new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment);              break;            case OpCode.Ldflda:               expr = SetType(new UnaryExpression(new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf));               break;            case OpCode.Stfld: statement = this.ParseStoreField(); goto done;            case OpCode.Ldsfld: expr = new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldsflda: expr = SetType(new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf)); break;            case OpCode.Stsfld: statement = new AssignmentStatement(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' PopOperand()); goto done;            case OpCode.Stobj: statement = this.ParseStoreIndirect((TypeNode)this.GetMemberFromToken()); goto done;            case OpCode.Conv_Ovf_I1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_I2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_I4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_I8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_U2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_U4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_U8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64); break;            case OpCode.Conv_Ovf_I_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr); break;            case OpCode.Box:               TypeNode t = (TypeNode)this.GetMemberFromToken();              TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;              expr = new BinaryExpression(PopOperand()' new Literal(t' CoreSystemTypes.Type)' NodeType.Box' bt); break;            case OpCode.Newarr: expr = this.ParseNewArray(); break;            case OpCode.Ldlen: expr = new UnaryExpression(PopOperand()' NodeType.Ldlen' CoreSystemTypes.UIntPtr); break;            case OpCode.Ldelema: expr = this.ParseArrayElementLoadAddress(); break;            case OpCode.Ldelem_I1:             case OpCode.Ldelem_U1:             case OpCode.Ldelem_I2:             case OpCode.Ldelem_U2:             case OpCode.Ldelem_I4:             case OpCode.Ldelem_U4:             case OpCode.Ldelem_I8:             case OpCode.Ldelem_I:             case OpCode.Ldelem_R4:             case OpCode.Ldelem_R8:             case OpCode.Ldelem_Ref: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem_I:            case OpCode.Stelem_I1:            case OpCode.Stelem_I2:            case OpCode.Stelem_I4:            case OpCode.Stelem_I8:            case OpCode.Stelem_R4:            case OpCode.Stelem_R8:            case OpCode.Stelem_Ref: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Ldelem: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Unbox_Any: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.UnboxAny); break;            case OpCode.Conv_Ovf_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64); break;            case OpCode.Refanyval: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr); break;            case OpCode.Ckfinite: expr = this.ParseUnaryOperation(NodeType.Ckfinite); break;            case OpCode.Mkrefany: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference); break;            case OpCode.Ldtoken: expr = ParseLoadRuntimeMetadataToken(); break;            case OpCode.Conv_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Add_Ovf: expr = this.ParseBinaryOperation(NodeType.Add_Ovf); break;            case OpCode.Add_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Add_Ovf_Un); break;            case OpCode.Mul_Ovf: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf); break;            case OpCode.Mul_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf_Un); break;            case OpCode.Sub_Ovf: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf); break;            case OpCode.Sub_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf_Un); break;            case OpCode.Endfinally: statement = new EndFinally(); transferStatement = true; goto done;            case OpCode.Leave: statement = this.ParseBranch(NodeType.Nop' 0' false' false' true); transferStatement = true; goto done;            case OpCode.Leave_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false' true); transferStatement = true; goto done;            case OpCode.Stind_I: statement = this.ParseStoreIndirect(CoreSystemTypes.IntPtr); goto done;            case OpCode.Conv_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Arglist: expr = new Expression(NodeType.Arglist' CoreSystemTypes.ArgIterator); break;            case OpCode.Ceq: expr = this.ParseBinaryComparison(NodeType.Ceq); break;            case OpCode.Cgt: expr = this.ParseBinaryComparison(NodeType.Cgt); break;            case OpCode.Cgt_Un: expr = this.ParseBinaryComparison(NodeType.Cgt_Un); break;            case OpCode.Clt: expr = this.ParseBinaryComparison(NodeType.Clt); break;            case OpCode.Clt_Un: expr = this.ParseBinaryComparison(NodeType.Clt_Un); break;            case OpCode.Ldftn: expr = new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldvirtftn: expr = new BinaryExpression(PopOperand()' new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldarg: expr = this.Parameters((ushort)this.GetInt16()); break;            case OpCode.Ldarga: expr = SetType(new UnaryExpression(this.Parameters((ushort)this.GetInt16())' NodeType.AddressOf)); break;            case OpCode.Starg: statement = new AssignmentStatement(this.Parameters((ushort)this.GetInt16())' PopOperand()); goto done;            case OpCode.Ldloc: expr = this.locals[(ushort)this.GetInt16()]; break;            case OpCode.Ldloca: expr = SetType(new UnaryExpression(this.locals[(ushort)this.GetInt16()]' NodeType.AddressOf)); break;            case OpCode.Stloc: statement = new AssignmentStatement(this.locals[(ushort)this.GetInt16()]' PopOperand()); goto done;            case OpCode.Localloc: expr = new UnaryExpression(PopOperand()' NodeType.Localloc' CoreSystemTypes.Void); break;            case OpCode.Endfilter: statement = new EndFilter(PopOperand()); transferStatement = true; goto done;            case OpCode.Unaligned_: this.alignment = this.GetByte(); continue;            case OpCode.Volatile_: this.isVolatile = true; continue;            case OpCode.Tail_: this.isTailCall = true; continue;            case OpCode.Initobj: statement = this.ParseInitObject(); goto done;            case OpCode.Constrained_: this.constraint = this.GetMemberFromToken() as TypeNode; continue;            case OpCode.Cpblk: expr = this.ParseTernaryOperation(NodeType.Cpblk); goto done;            case OpCode.Initblk: expr = this.ParseTernaryOperation(NodeType.Initblk); goto done;            case OpCode.Rethrow: statement = new Throw(null); statement.NodeType = NodeType.Rethrow; transferStatement = true; goto done;            case OpCode.Sizeof: expr = new UnaryExpression(new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32); break;            case OpCode.Refanytype: expr = new UnaryExpression(PopOperand()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle); break;            case OpCode.Readonly_: this.isReadOnly = true; continue;            default: throw new InvalidMetadataException(ExceptionStrings.UnknownOpCode);          }          if (this.blockMap[this.counter+1] != null){            transferStatement = true; //Falls through to the next basic block' so implicitly a "transfer" statement            goto done;          }          //^ assume expr != null;  #if FxCop          expr.sourceContext = sourceContext;  #endif  #if FxCop || ILOFFSETS          expr.ILOffset = this.ilOffset;  #endif          this.operandStack.Push(expr);          this.isReadOnly = false;          this.isVolatile = false;          this.isTailCall = false;                  this.alignment = -1;        }
Magic Number,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true){          bool isStatement = false;          startingAddress = this.counter+1; //Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  #if FxCop || ILOFFSETS          this.ilOffset = this.counter;          this.opCode = this.GetOpCode();  #else          OpCode opCode = this.GetOpCode();  #endif  #if FxCop          if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){            expr.sourceContext = sourceContext;            expr.ILOffset = this.ilOffset;            this.operandStack.Push(expr);          }  #endif          switch (opCode){            case OpCode.Nop: statement = new Statement(NodeType.Nop); goto done;            case OpCode.Break: statement = new Statement(NodeType.DebugBreak); goto done;            case OpCode.Ldarg_0: expr = this.Parameters(0); break;            case OpCode.Ldarg_1: expr = this.Parameters(1); break;            case OpCode.Ldarg_2: expr = this.Parameters(2); break;            case OpCode.Ldarg_3: expr = this.Parameters(3); break;            case OpCode.Ldloc_0: expr = this.locals[0]; break;            case OpCode.Ldloc_1: expr = this.locals[1]; break;            case OpCode.Ldloc_2: expr = this.locals[2]; break;            case OpCode.Ldloc_3: expr = this.locals[3]; break;            case OpCode.Stloc_0: statement = new AssignmentStatement(this.locals[0]' PopOperand()); goto done;            case OpCode.Stloc_1: statement = new AssignmentStatement(this.locals[1]' PopOperand()); goto done;            case OpCode.Stloc_2: statement = new AssignmentStatement(this.locals[2]' PopOperand()); goto done;            case OpCode.Stloc_3: statement = new AssignmentStatement(this.locals[3]' PopOperand()); goto done;            case OpCode.Ldarg_S: expr = this.Parameters(this.GetByte()); break;            case OpCode.Ldarga_S: expr = SetType(new UnaryExpression(this.Parameters(this.GetByte())' NodeType.AddressOf)); break;            case OpCode.Starg_S: statement = new AssignmentStatement(this.Parameters(this.GetByte())' PopOperand()); goto done;            case OpCode.Ldloc_S: expr = this.locals[this.GetByte()]; break;            case OpCode.Ldloca_S: expr = SetType(new UnaryExpression(this.locals[this.GetByte()]' NodeType.AddressOf)); break;            case OpCode.Stloc_S: statement = new AssignmentStatement(this.locals[this.GetByte()]' PopOperand()); goto done;            case OpCode.Ldnull: expr = new Literal(null' CoreSystemTypes.Object); break;            case OpCode.Ldc_I4_M1: expr = new Literal(-1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_0: expr = new Literal(0' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_1: expr = new Literal(1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_2: expr = new Literal(2' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_3: expr = new Literal(3' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_4: expr = new Literal(4' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_5: expr = new Literal(5' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_6: expr = new Literal(6' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_7: expr = new Literal(7' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_8: expr = new Literal(8' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_S: expr = new Literal((int)this.GetSByte()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4: expr = new Literal(this.GetInt32()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I8: expr = new Literal(this.GetInt64()' CoreSystemTypes.Int64); break;            case OpCode.Ldc_R4: expr = new Literal(this.GetSingle()' CoreSystemTypes.Single); break;            case OpCode.Ldc_R8: expr = new Literal(this.GetDouble()' CoreSystemTypes.Double); break;            case OpCode.Dup: statement = new ExpressionStatement(new Expression(NodeType.Dup)); goto done;            case OpCode.Pop: statement = new ExpressionStatement(new UnaryExpression(PopOperand()' NodeType.Pop)); goto done;            case OpCode.Jmp: expr = this.ParseCall(NodeType.Jmp' out isStatement); if (isStatement) goto done; break;            case OpCode.Call: expr = this.ParseCall(NodeType.Call' out isStatement); if (isStatement) goto done; break;            case OpCode.Calli: expr = this.ParseCalli(out isStatement); if (isStatement) goto done; break;            case OpCode.Ret:              Expression retVal = BodyParser.TypeIsVoid(this.method.ReturnType) ? null : PopOperand();              statement = new Return(retVal);               transferStatement = true; goto done;            case OpCode.Br_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false); transferStatement = true; goto done;            case OpCode.Brfalse_S: statement = this.ParseBranch(NodeType.LogicalNot' 1' true' false); transferStatement = true; goto done;            case OpCode.Brtrue_S: statement = this.ParseBranch(NodeType.Nop' 1' true' false); transferStatement = true; goto done;            case OpCode.Beq_S: statement = this.ParseBranch(NodeType.Eq' 2' true' false); transferStatement = true; goto done;            case OpCode.Bge_S: statement = this.ParseBranch(NodeType.Ge' 2' true' false); transferStatement = true; goto done;            case OpCode.Bgt_S: statement = this.ParseBranch(NodeType.Gt' 2' true' false); transferStatement = true; goto done;            case OpCode.Ble_S: statement = this.ParseBranch(NodeType.Le' 2' true' false); transferStatement = true; goto done;            case OpCode.Blt_S: statement = this.ParseBranch(NodeType.Lt' 2' true' false); transferStatement = true; goto done;            case OpCode.Bne_Un_S: statement = this.ParseBranch(NodeType.Ne' 2' true' true); transferStatement = true; goto done;            case OpCode.Bge_Un_S: statement = this.ParseBranch(NodeType.Ge' 2' true' true); transferStatement = true; goto done;            case OpCode.Bgt_Un_S: statement = this.ParseBranch(NodeType.Gt' 2' true' true); transferStatement = true; goto done;            case OpCode.Ble_Un_S: statement = this.ParseBranch(NodeType.Le' 2' true' true); transferStatement = true; goto done;            case OpCode.Blt_Un_S: statement = this.ParseBranch(NodeType.Lt' 2' true' true); transferStatement = true; goto done;            case OpCode.Br: statement = this.ParseBranch(NodeType.Nop' 0' false' false); transferStatement = true; goto done;            case OpCode.Brfalse: statement = this.ParseBranch(NodeType.LogicalNot' 1' false' false); transferStatement = true; goto done;            case OpCode.Brtrue: statement = this.ParseBranch(NodeType.Nop' 1' false' false); transferStatement = true; goto done;            case OpCode.Beq: statement = this.ParseBranch(NodeType.Eq' 2' false' false); transferStatement = true; goto done;            case OpCode.Bge: statement = this.ParseBranch(NodeType.Ge' 2' false' false); transferStatement = true; goto done;            case OpCode.Bgt: statement = this.ParseBranch(NodeType.Gt' 2' false' false); transferStatement = true; goto done;            case OpCode.Ble: statement = this.ParseBranch(NodeType.Le' 2' false' false); transferStatement = true; goto done;            case OpCode.Blt: statement = this.ParseBranch(NodeType.Lt' 2' false' false); transferStatement = true; goto done;            case OpCode.Bne_Un: statement = this.ParseBranch(NodeType.Ne' 2' false' true); transferStatement = true; goto done;            case OpCode.Bge_Un: statement = this.ParseBranch(NodeType.Ge' 2' false' true); transferStatement = true; goto done;            case OpCode.Bgt_Un: statement = this.ParseBranch(NodeType.Gt' 2' false' true); transferStatement = true; goto done;            case OpCode.Ble_Un: statement = this.ParseBranch(NodeType.Le' 2' false' true); transferStatement = true; goto done;            case OpCode.Blt_Un: statement = this.ParseBranch(NodeType.Lt' 2' false' true); transferStatement = true; goto done;            case OpCode.Switch: statement = this.ParseSwitchInstruction(); transferStatement = true; goto done;            case OpCode.Ldind_I1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int64' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I: expr = new AddressDereference(PopOperand()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Single' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Double' this.isVolatile' this.alignment); break;            case OpCode.Ldind_Ref: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Object' this.isVolatile' this.alignment); break;            case OpCode.Stind_Ref: statement = this.ParseStoreIndirect(CoreSystemTypes.Object); goto done;            case OpCode.Stind_I1: statement = this.ParseStoreIndirect(CoreSystemTypes.Int8); goto done;            case OpCode.Stind_I2: statement = this.ParseStoreIndirect(CoreSystemTypes.Int16); goto done;            case OpCode.Stind_I4: statement = this.ParseStoreIndirect(CoreSystemTypes.Int32); goto done;            case OpCode.Stind_I8: statement = this.ParseStoreIndirect(CoreSystemTypes.Int64); goto done;            case OpCode.Stind_R4: statement = this.ParseStoreIndirect(CoreSystemTypes.Single); goto done;            case OpCode.Stind_R8: statement = this.ParseStoreIndirect(CoreSystemTypes.Double); goto done;            case OpCode.Add: expr = this.ParseBinaryOperation(NodeType.Add); break;            case OpCode.Sub: expr = this.ParseBinaryOperation(NodeType.Sub); break;            case OpCode.Mul: expr = this.ParseBinaryOperation(NodeType.Mul); break;            case OpCode.Div: expr = this.ParseBinaryOperation(NodeType.Div); break;            case OpCode.Div_Un: expr = this.ParseBinaryOperation(NodeType.Div_Un); break;            case OpCode.Rem: expr = this.ParseBinaryOperation(NodeType.Rem); break;            case OpCode.Rem_Un: expr = this.ParseBinaryOperation(NodeType.Rem_Un); break;            case OpCode.And: expr = this.ParseBinaryOperation(NodeType.And); break;            case OpCode.Or: expr = this.ParseBinaryOperation(NodeType.Or); break;            case OpCode.Xor: expr = this.ParseBinaryOperation(NodeType.Xor); break;            case OpCode.Shl: expr = this.ParseBinaryOperation(NodeType.Shl); break;            case OpCode.Shr: expr = this.ParseBinaryOperation(NodeType.Shr); break;            case OpCode.Shr_Un: expr = this.ParseBinaryOperation(NodeType.Shr_Un); break;            case OpCode.Neg: expr = this.ParseUnaryOperation(NodeType.Neg); break;            case OpCode.Not: expr = this.ParseUnaryOperation(NodeType.Not); break;            case OpCode.Conv_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_R4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R4' CoreSystemTypes.Single); break;            case OpCode.Conv_R8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R8' CoreSystemTypes.Double); break;            case OpCode.Conv_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U8' CoreSystemTypes.UInt64); break;            case OpCode.Callvirt: expr = this.ParseCall(NodeType.Callvirt' out isStatement); if (isStatement) goto done; break;            case OpCode.Cpobj: statement = this.ParseCopyObject(); goto done;            case OpCode.Ldobj: expr = new AddressDereference(PopOperand()' (TypeNode)this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldstr: expr = new Literal(this.GetStringFromToken()' CoreSystemTypes.String); break;            case OpCode.Newobj: expr = this.ParseConstruct(); break;            case OpCode.Castclass: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Castclass); break;            case OpCode.Isinst: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Isinst); break;            case OpCode.Conv_R_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R_Un' CoreSystemTypes.Double); break;            case OpCode.Unbox: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Unbox); break;            case OpCode.Throw: statement = new Throw(PopOperand()); transferStatement = true; goto done;            case OpCode.Ldfld:               expr = new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment);              break;            case OpCode.Ldflda:               expr = SetType(new UnaryExpression(new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf));               break;            case OpCode.Stfld: statement = this.ParseStoreField(); goto done;            case OpCode.Ldsfld: expr = new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldsflda: expr = SetType(new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf)); break;            case OpCode.Stsfld: statement = new AssignmentStatement(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' PopOperand()); goto done;            case OpCode.Stobj: statement = this.ParseStoreIndirect((TypeNode)this.GetMemberFromToken()); goto done;            case OpCode.Conv_Ovf_I1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_I2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_I4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_I8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_U2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_U4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_U8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64); break;            case OpCode.Conv_Ovf_I_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr); break;            case OpCode.Box:               TypeNode t = (TypeNode)this.GetMemberFromToken();              TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;              expr = new BinaryExpression(PopOperand()' new Literal(t' CoreSystemTypes.Type)' NodeType.Box' bt); break;            case OpCode.Newarr: expr = this.ParseNewArray(); break;            case OpCode.Ldlen: expr = new UnaryExpression(PopOperand()' NodeType.Ldlen' CoreSystemTypes.UIntPtr); break;            case OpCode.Ldelema: expr = this.ParseArrayElementLoadAddress(); break;            case OpCode.Ldelem_I1:             case OpCode.Ldelem_U1:             case OpCode.Ldelem_I2:             case OpCode.Ldelem_U2:             case OpCode.Ldelem_I4:             case OpCode.Ldelem_U4:             case OpCode.Ldelem_I8:             case OpCode.Ldelem_I:             case OpCode.Ldelem_R4:             case OpCode.Ldelem_R8:             case OpCode.Ldelem_Ref: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem_I:            case OpCode.Stelem_I1:            case OpCode.Stelem_I2:            case OpCode.Stelem_I4:            case OpCode.Stelem_I8:            case OpCode.Stelem_R4:            case OpCode.Stelem_R8:            case OpCode.Stelem_Ref: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Ldelem: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Unbox_Any: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.UnboxAny); break;            case OpCode.Conv_Ovf_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64); break;            case OpCode.Refanyval: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr); break;            case OpCode.Ckfinite: expr = this.ParseUnaryOperation(NodeType.Ckfinite); break;            case OpCode.Mkrefany: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference); break;            case OpCode.Ldtoken: expr = ParseLoadRuntimeMetadataToken(); break;            case OpCode.Conv_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Add_Ovf: expr = this.ParseBinaryOperation(NodeType.Add_Ovf); break;            case OpCode.Add_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Add_Ovf_Un); break;            case OpCode.Mul_Ovf: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf); break;            case OpCode.Mul_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf_Un); break;            case OpCode.Sub_Ovf: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf); break;            case OpCode.Sub_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf_Un); break;            case OpCode.Endfinally: statement = new EndFinally(); transferStatement = true; goto done;            case OpCode.Leave: statement = this.ParseBranch(NodeType.Nop' 0' false' false' true); transferStatement = true; goto done;            case OpCode.Leave_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false' true); transferStatement = true; goto done;            case OpCode.Stind_I: statement = this.ParseStoreIndirect(CoreSystemTypes.IntPtr); goto done;            case OpCode.Conv_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Arglist: expr = new Expression(NodeType.Arglist' CoreSystemTypes.ArgIterator); break;            case OpCode.Ceq: expr = this.ParseBinaryComparison(NodeType.Ceq); break;            case OpCode.Cgt: expr = this.ParseBinaryComparison(NodeType.Cgt); break;            case OpCode.Cgt_Un: expr = this.ParseBinaryComparison(NodeType.Cgt_Un); break;            case OpCode.Clt: expr = this.ParseBinaryComparison(NodeType.Clt); break;            case OpCode.Clt_Un: expr = this.ParseBinaryComparison(NodeType.Clt_Un); break;            case OpCode.Ldftn: expr = new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldvirtftn: expr = new BinaryExpression(PopOperand()' new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldarg: expr = this.Parameters((ushort)this.GetInt16()); break;            case OpCode.Ldarga: expr = SetType(new UnaryExpression(this.Parameters((ushort)this.GetInt16())' NodeType.AddressOf)); break;            case OpCode.Starg: statement = new AssignmentStatement(this.Parameters((ushort)this.GetInt16())' PopOperand()); goto done;            case OpCode.Ldloc: expr = this.locals[(ushort)this.GetInt16()]; break;            case OpCode.Ldloca: expr = SetType(new UnaryExpression(this.locals[(ushort)this.GetInt16()]' NodeType.AddressOf)); break;            case OpCode.Stloc: statement = new AssignmentStatement(this.locals[(ushort)this.GetInt16()]' PopOperand()); goto done;            case OpCode.Localloc: expr = new UnaryExpression(PopOperand()' NodeType.Localloc' CoreSystemTypes.Void); break;            case OpCode.Endfilter: statement = new EndFilter(PopOperand()); transferStatement = true; goto done;            case OpCode.Unaligned_: this.alignment = this.GetByte(); continue;            case OpCode.Volatile_: this.isVolatile = true; continue;            case OpCode.Tail_: this.isTailCall = true; continue;            case OpCode.Initobj: statement = this.ParseInitObject(); goto done;            case OpCode.Constrained_: this.constraint = this.GetMemberFromToken() as TypeNode; continue;            case OpCode.Cpblk: expr = this.ParseTernaryOperation(NodeType.Cpblk); goto done;            case OpCode.Initblk: expr = this.ParseTernaryOperation(NodeType.Initblk); goto done;            case OpCode.Rethrow: statement = new Throw(null); statement.NodeType = NodeType.Rethrow; transferStatement = true; goto done;            case OpCode.Sizeof: expr = new UnaryExpression(new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32); break;            case OpCode.Refanytype: expr = new UnaryExpression(PopOperand()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle); break;            case OpCode.Readonly_: this.isReadOnly = true; continue;            default: throw new InvalidMetadataException(ExceptionStrings.UnknownOpCode);          }          if (this.blockMap[this.counter+1] != null){            transferStatement = true; //Falls through to the next basic block' so implicitly a "transfer" statement            goto done;          }          //^ assume expr != null;  #if FxCop          expr.sourceContext = sourceContext;  #endif  #if FxCop || ILOFFSETS          expr.ILOffset = this.ilOffset;  #endif          this.operandStack.Push(expr);          this.isReadOnly = false;          this.isVolatile = false;          this.isTailCall = false;                  this.alignment = -1;        }
Magic Number,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true){          bool isStatement = false;          startingAddress = this.counter+1; //Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  #if FxCop || ILOFFSETS          this.ilOffset = this.counter;          this.opCode = this.GetOpCode();  #else          OpCode opCode = this.GetOpCode();  #endif  #if FxCop          if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){            expr.sourceContext = sourceContext;            expr.ILOffset = this.ilOffset;            this.operandStack.Push(expr);          }  #endif          switch (opCode){            case OpCode.Nop: statement = new Statement(NodeType.Nop); goto done;            case OpCode.Break: statement = new Statement(NodeType.DebugBreak); goto done;            case OpCode.Ldarg_0: expr = this.Parameters(0); break;            case OpCode.Ldarg_1: expr = this.Parameters(1); break;            case OpCode.Ldarg_2: expr = this.Parameters(2); break;            case OpCode.Ldarg_3: expr = this.Parameters(3); break;            case OpCode.Ldloc_0: expr = this.locals[0]; break;            case OpCode.Ldloc_1: expr = this.locals[1]; break;            case OpCode.Ldloc_2: expr = this.locals[2]; break;            case OpCode.Ldloc_3: expr = this.locals[3]; break;            case OpCode.Stloc_0: statement = new AssignmentStatement(this.locals[0]' PopOperand()); goto done;            case OpCode.Stloc_1: statement = new AssignmentStatement(this.locals[1]' PopOperand()); goto done;            case OpCode.Stloc_2: statement = new AssignmentStatement(this.locals[2]' PopOperand()); goto done;            case OpCode.Stloc_3: statement = new AssignmentStatement(this.locals[3]' PopOperand()); goto done;            case OpCode.Ldarg_S: expr = this.Parameters(this.GetByte()); break;            case OpCode.Ldarga_S: expr = SetType(new UnaryExpression(this.Parameters(this.GetByte())' NodeType.AddressOf)); break;            case OpCode.Starg_S: statement = new AssignmentStatement(this.Parameters(this.GetByte())' PopOperand()); goto done;            case OpCode.Ldloc_S: expr = this.locals[this.GetByte()]; break;            case OpCode.Ldloca_S: expr = SetType(new UnaryExpression(this.locals[this.GetByte()]' NodeType.AddressOf)); break;            case OpCode.Stloc_S: statement = new AssignmentStatement(this.locals[this.GetByte()]' PopOperand()); goto done;            case OpCode.Ldnull: expr = new Literal(null' CoreSystemTypes.Object); break;            case OpCode.Ldc_I4_M1: expr = new Literal(-1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_0: expr = new Literal(0' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_1: expr = new Literal(1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_2: expr = new Literal(2' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_3: expr = new Literal(3' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_4: expr = new Literal(4' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_5: expr = new Literal(5' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_6: expr = new Literal(6' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_7: expr = new Literal(7' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_8: expr = new Literal(8' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_S: expr = new Literal((int)this.GetSByte()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4: expr = new Literal(this.GetInt32()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I8: expr = new Literal(this.GetInt64()' CoreSystemTypes.Int64); break;            case OpCode.Ldc_R4: expr = new Literal(this.GetSingle()' CoreSystemTypes.Single); break;            case OpCode.Ldc_R8: expr = new Literal(this.GetDouble()' CoreSystemTypes.Double); break;            case OpCode.Dup: statement = new ExpressionStatement(new Expression(NodeType.Dup)); goto done;            case OpCode.Pop: statement = new ExpressionStatement(new UnaryExpression(PopOperand()' NodeType.Pop)); goto done;            case OpCode.Jmp: expr = this.ParseCall(NodeType.Jmp' out isStatement); if (isStatement) goto done; break;            case OpCode.Call: expr = this.ParseCall(NodeType.Call' out isStatement); if (isStatement) goto done; break;            case OpCode.Calli: expr = this.ParseCalli(out isStatement); if (isStatement) goto done; break;            case OpCode.Ret:              Expression retVal = BodyParser.TypeIsVoid(this.method.ReturnType) ? null : PopOperand();              statement = new Return(retVal);               transferStatement = true; goto done;            case OpCode.Br_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false); transferStatement = true; goto done;            case OpCode.Brfalse_S: statement = this.ParseBranch(NodeType.LogicalNot' 1' true' false); transferStatement = true; goto done;            case OpCode.Brtrue_S: statement = this.ParseBranch(NodeType.Nop' 1' true' false); transferStatement = true; goto done;            case OpCode.Beq_S: statement = this.ParseBranch(NodeType.Eq' 2' true' false); transferStatement = true; goto done;            case OpCode.Bge_S: statement = this.ParseBranch(NodeType.Ge' 2' true' false); transferStatement = true; goto done;            case OpCode.Bgt_S: statement = this.ParseBranch(NodeType.Gt' 2' true' false); transferStatement = true; goto done;            case OpCode.Ble_S: statement = this.ParseBranch(NodeType.Le' 2' true' false); transferStatement = true; goto done;            case OpCode.Blt_S: statement = this.ParseBranch(NodeType.Lt' 2' true' false); transferStatement = true; goto done;            case OpCode.Bne_Un_S: statement = this.ParseBranch(NodeType.Ne' 2' true' true); transferStatement = true; goto done;            case OpCode.Bge_Un_S: statement = this.ParseBranch(NodeType.Ge' 2' true' true); transferStatement = true; goto done;            case OpCode.Bgt_Un_S: statement = this.ParseBranch(NodeType.Gt' 2' true' true); transferStatement = true; goto done;            case OpCode.Ble_Un_S: statement = this.ParseBranch(NodeType.Le' 2' true' true); transferStatement = true; goto done;            case OpCode.Blt_Un_S: statement = this.ParseBranch(NodeType.Lt' 2' true' true); transferStatement = true; goto done;            case OpCode.Br: statement = this.ParseBranch(NodeType.Nop' 0' false' false); transferStatement = true; goto done;            case OpCode.Brfalse: statement = this.ParseBranch(NodeType.LogicalNot' 1' false' false); transferStatement = true; goto done;            case OpCode.Brtrue: statement = this.ParseBranch(NodeType.Nop' 1' false' false); transferStatement = true; goto done;            case OpCode.Beq: statement = this.ParseBranch(NodeType.Eq' 2' false' false); transferStatement = true; goto done;            case OpCode.Bge: statement = this.ParseBranch(NodeType.Ge' 2' false' false); transferStatement = true; goto done;            case OpCode.Bgt: statement = this.ParseBranch(NodeType.Gt' 2' false' false); transferStatement = true; goto done;            case OpCode.Ble: statement = this.ParseBranch(NodeType.Le' 2' false' false); transferStatement = true; goto done;            case OpCode.Blt: statement = this.ParseBranch(NodeType.Lt' 2' false' false); transferStatement = true; goto done;            case OpCode.Bne_Un: statement = this.ParseBranch(NodeType.Ne' 2' false' true); transferStatement = true; goto done;            case OpCode.Bge_Un: statement = this.ParseBranch(NodeType.Ge' 2' false' true); transferStatement = true; goto done;            case OpCode.Bgt_Un: statement = this.ParseBranch(NodeType.Gt' 2' false' true); transferStatement = true; goto done;            case OpCode.Ble_Un: statement = this.ParseBranch(NodeType.Le' 2' false' true); transferStatement = true; goto done;            case OpCode.Blt_Un: statement = this.ParseBranch(NodeType.Lt' 2' false' true); transferStatement = true; goto done;            case OpCode.Switch: statement = this.ParseSwitchInstruction(); transferStatement = true; goto done;            case OpCode.Ldind_I1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int64' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I: expr = new AddressDereference(PopOperand()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Single' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Double' this.isVolatile' this.alignment); break;            case OpCode.Ldind_Ref: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Object' this.isVolatile' this.alignment); break;            case OpCode.Stind_Ref: statement = this.ParseStoreIndirect(CoreSystemTypes.Object); goto done;            case OpCode.Stind_I1: statement = this.ParseStoreIndirect(CoreSystemTypes.Int8); goto done;            case OpCode.Stind_I2: statement = this.ParseStoreIndirect(CoreSystemTypes.Int16); goto done;            case OpCode.Stind_I4: statement = this.ParseStoreIndirect(CoreSystemTypes.Int32); goto done;            case OpCode.Stind_I8: statement = this.ParseStoreIndirect(CoreSystemTypes.Int64); goto done;            case OpCode.Stind_R4: statement = this.ParseStoreIndirect(CoreSystemTypes.Single); goto done;            case OpCode.Stind_R8: statement = this.ParseStoreIndirect(CoreSystemTypes.Double); goto done;            case OpCode.Add: expr = this.ParseBinaryOperation(NodeType.Add); break;            case OpCode.Sub: expr = this.ParseBinaryOperation(NodeType.Sub); break;            case OpCode.Mul: expr = this.ParseBinaryOperation(NodeType.Mul); break;            case OpCode.Div: expr = this.ParseBinaryOperation(NodeType.Div); break;            case OpCode.Div_Un: expr = this.ParseBinaryOperation(NodeType.Div_Un); break;            case OpCode.Rem: expr = this.ParseBinaryOperation(NodeType.Rem); break;            case OpCode.Rem_Un: expr = this.ParseBinaryOperation(NodeType.Rem_Un); break;            case OpCode.And: expr = this.ParseBinaryOperation(NodeType.And); break;            case OpCode.Or: expr = this.ParseBinaryOperation(NodeType.Or); break;            case OpCode.Xor: expr = this.ParseBinaryOperation(NodeType.Xor); break;            case OpCode.Shl: expr = this.ParseBinaryOperation(NodeType.Shl); break;            case OpCode.Shr: expr = this.ParseBinaryOperation(NodeType.Shr); break;            case OpCode.Shr_Un: expr = this.ParseBinaryOperation(NodeType.Shr_Un); break;            case OpCode.Neg: expr = this.ParseUnaryOperation(NodeType.Neg); break;            case OpCode.Not: expr = this.ParseUnaryOperation(NodeType.Not); break;            case OpCode.Conv_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_R4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R4' CoreSystemTypes.Single); break;            case OpCode.Conv_R8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R8' CoreSystemTypes.Double); break;            case OpCode.Conv_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U8' CoreSystemTypes.UInt64); break;            case OpCode.Callvirt: expr = this.ParseCall(NodeType.Callvirt' out isStatement); if (isStatement) goto done; break;            case OpCode.Cpobj: statement = this.ParseCopyObject(); goto done;            case OpCode.Ldobj: expr = new AddressDereference(PopOperand()' (TypeNode)this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldstr: expr = new Literal(this.GetStringFromToken()' CoreSystemTypes.String); break;            case OpCode.Newobj: expr = this.ParseConstruct(); break;            case OpCode.Castclass: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Castclass); break;            case OpCode.Isinst: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Isinst); break;            case OpCode.Conv_R_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R_Un' CoreSystemTypes.Double); break;            case OpCode.Unbox: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Unbox); break;            case OpCode.Throw: statement = new Throw(PopOperand()); transferStatement = true; goto done;            case OpCode.Ldfld:               expr = new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment);              break;            case OpCode.Ldflda:               expr = SetType(new UnaryExpression(new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf));               break;            case OpCode.Stfld: statement = this.ParseStoreField(); goto done;            case OpCode.Ldsfld: expr = new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldsflda: expr = SetType(new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf)); break;            case OpCode.Stsfld: statement = new AssignmentStatement(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' PopOperand()); goto done;            case OpCode.Stobj: statement = this.ParseStoreIndirect((TypeNode)this.GetMemberFromToken()); goto done;            case OpCode.Conv_Ovf_I1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_I2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_I4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_I8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_U2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_U4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_U8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64); break;            case OpCode.Conv_Ovf_I_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr); break;            case OpCode.Box:               TypeNode t = (TypeNode)this.GetMemberFromToken();              TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;              expr = new BinaryExpression(PopOperand()' new Literal(t' CoreSystemTypes.Type)' NodeType.Box' bt); break;            case OpCode.Newarr: expr = this.ParseNewArray(); break;            case OpCode.Ldlen: expr = new UnaryExpression(PopOperand()' NodeType.Ldlen' CoreSystemTypes.UIntPtr); break;            case OpCode.Ldelema: expr = this.ParseArrayElementLoadAddress(); break;            case OpCode.Ldelem_I1:             case OpCode.Ldelem_U1:             case OpCode.Ldelem_I2:             case OpCode.Ldelem_U2:             case OpCode.Ldelem_I4:             case OpCode.Ldelem_U4:             case OpCode.Ldelem_I8:             case OpCode.Ldelem_I:             case OpCode.Ldelem_R4:             case OpCode.Ldelem_R8:             case OpCode.Ldelem_Ref: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem_I:            case OpCode.Stelem_I1:            case OpCode.Stelem_I2:            case OpCode.Stelem_I4:            case OpCode.Stelem_I8:            case OpCode.Stelem_R4:            case OpCode.Stelem_R8:            case OpCode.Stelem_Ref: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Ldelem: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Unbox_Any: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.UnboxAny); break;            case OpCode.Conv_Ovf_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64); break;            case OpCode.Refanyval: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr); break;            case OpCode.Ckfinite: expr = this.ParseUnaryOperation(NodeType.Ckfinite); break;            case OpCode.Mkrefany: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference); break;            case OpCode.Ldtoken: expr = ParseLoadRuntimeMetadataToken(); break;            case OpCode.Conv_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Add_Ovf: expr = this.ParseBinaryOperation(NodeType.Add_Ovf); break;            case OpCode.Add_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Add_Ovf_Un); break;            case OpCode.Mul_Ovf: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf); break;            case OpCode.Mul_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf_Un); break;            case OpCode.Sub_Ovf: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf); break;            case OpCode.Sub_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf_Un); break;            case OpCode.Endfinally: statement = new EndFinally(); transferStatement = true; goto done;            case OpCode.Leave: statement = this.ParseBranch(NodeType.Nop' 0' false' false' true); transferStatement = true; goto done;            case OpCode.Leave_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false' true); transferStatement = true; goto done;            case OpCode.Stind_I: statement = this.ParseStoreIndirect(CoreSystemTypes.IntPtr); goto done;            case OpCode.Conv_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Arglist: expr = new Expression(NodeType.Arglist' CoreSystemTypes.ArgIterator); break;            case OpCode.Ceq: expr = this.ParseBinaryComparison(NodeType.Ceq); break;            case OpCode.Cgt: expr = this.ParseBinaryComparison(NodeType.Cgt); break;            case OpCode.Cgt_Un: expr = this.ParseBinaryComparison(NodeType.Cgt_Un); break;            case OpCode.Clt: expr = this.ParseBinaryComparison(NodeType.Clt); break;            case OpCode.Clt_Un: expr = this.ParseBinaryComparison(NodeType.Clt_Un); break;            case OpCode.Ldftn: expr = new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldvirtftn: expr = new BinaryExpression(PopOperand()' new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldarg: expr = this.Parameters((ushort)this.GetInt16()); break;            case OpCode.Ldarga: expr = SetType(new UnaryExpression(this.Parameters((ushort)this.GetInt16())' NodeType.AddressOf)); break;            case OpCode.Starg: statement = new AssignmentStatement(this.Parameters((ushort)this.GetInt16())' PopOperand()); goto done;            case OpCode.Ldloc: expr = this.locals[(ushort)this.GetInt16()]; break;            case OpCode.Ldloca: expr = SetType(new UnaryExpression(this.locals[(ushort)this.GetInt16()]' NodeType.AddressOf)); break;            case OpCode.Stloc: statement = new AssignmentStatement(this.locals[(ushort)this.GetInt16()]' PopOperand()); goto done;            case OpCode.Localloc: expr = new UnaryExpression(PopOperand()' NodeType.Localloc' CoreSystemTypes.Void); break;            case OpCode.Endfilter: statement = new EndFilter(PopOperand()); transferStatement = true; goto done;            case OpCode.Unaligned_: this.alignment = this.GetByte(); continue;            case OpCode.Volatile_: this.isVolatile = true; continue;            case OpCode.Tail_: this.isTailCall = true; continue;            case OpCode.Initobj: statement = this.ParseInitObject(); goto done;            case OpCode.Constrained_: this.constraint = this.GetMemberFromToken() as TypeNode; continue;            case OpCode.Cpblk: expr = this.ParseTernaryOperation(NodeType.Cpblk); goto done;            case OpCode.Initblk: expr = this.ParseTernaryOperation(NodeType.Initblk); goto done;            case OpCode.Rethrow: statement = new Throw(null); statement.NodeType = NodeType.Rethrow; transferStatement = true; goto done;            case OpCode.Sizeof: expr = new UnaryExpression(new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32); break;            case OpCode.Refanytype: expr = new UnaryExpression(PopOperand()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle); break;            case OpCode.Readonly_: this.isReadOnly = true; continue;            default: throw new InvalidMetadataException(ExceptionStrings.UnknownOpCode);          }          if (this.blockMap[this.counter+1] != null){            transferStatement = true; //Falls through to the next basic block' so implicitly a "transfer" statement            goto done;          }          //^ assume expr != null;  #if FxCop          expr.sourceContext = sourceContext;  #endif  #if FxCop || ILOFFSETS          expr.ILOffset = this.ilOffset;  #endif          this.operandStack.Push(expr);          this.isReadOnly = false;          this.isVolatile = false;          this.isTailCall = false;                  this.alignment = -1;        }
Magic Number,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true){          bool isStatement = false;          startingAddress = this.counter+1; //Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  #if FxCop || ILOFFSETS          this.ilOffset = this.counter;          this.opCode = this.GetOpCode();  #else          OpCode opCode = this.GetOpCode();  #endif  #if FxCop          if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){            expr.sourceContext = sourceContext;            expr.ILOffset = this.ilOffset;            this.operandStack.Push(expr);          }  #endif          switch (opCode){            case OpCode.Nop: statement = new Statement(NodeType.Nop); goto done;            case OpCode.Break: statement = new Statement(NodeType.DebugBreak); goto done;            case OpCode.Ldarg_0: expr = this.Parameters(0); break;            case OpCode.Ldarg_1: expr = this.Parameters(1); break;            case OpCode.Ldarg_2: expr = this.Parameters(2); break;            case OpCode.Ldarg_3: expr = this.Parameters(3); break;            case OpCode.Ldloc_0: expr = this.locals[0]; break;            case OpCode.Ldloc_1: expr = this.locals[1]; break;            case OpCode.Ldloc_2: expr = this.locals[2]; break;            case OpCode.Ldloc_3: expr = this.locals[3]; break;            case OpCode.Stloc_0: statement = new AssignmentStatement(this.locals[0]' PopOperand()); goto done;            case OpCode.Stloc_1: statement = new AssignmentStatement(this.locals[1]' PopOperand()); goto done;            case OpCode.Stloc_2: statement = new AssignmentStatement(this.locals[2]' PopOperand()); goto done;            case OpCode.Stloc_3: statement = new AssignmentStatement(this.locals[3]' PopOperand()); goto done;            case OpCode.Ldarg_S: expr = this.Parameters(this.GetByte()); break;            case OpCode.Ldarga_S: expr = SetType(new UnaryExpression(this.Parameters(this.GetByte())' NodeType.AddressOf)); break;            case OpCode.Starg_S: statement = new AssignmentStatement(this.Parameters(this.GetByte())' PopOperand()); goto done;            case OpCode.Ldloc_S: expr = this.locals[this.GetByte()]; break;            case OpCode.Ldloca_S: expr = SetType(new UnaryExpression(this.locals[this.GetByte()]' NodeType.AddressOf)); break;            case OpCode.Stloc_S: statement = new AssignmentStatement(this.locals[this.GetByte()]' PopOperand()); goto done;            case OpCode.Ldnull: expr = new Literal(null' CoreSystemTypes.Object); break;            case OpCode.Ldc_I4_M1: expr = new Literal(-1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_0: expr = new Literal(0' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_1: expr = new Literal(1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_2: expr = new Literal(2' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_3: expr = new Literal(3' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_4: expr = new Literal(4' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_5: expr = new Literal(5' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_6: expr = new Literal(6' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_7: expr = new Literal(7' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_8: expr = new Literal(8' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_S: expr = new Literal((int)this.GetSByte()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4: expr = new Literal(this.GetInt32()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I8: expr = new Literal(this.GetInt64()' CoreSystemTypes.Int64); break;            case OpCode.Ldc_R4: expr = new Literal(this.GetSingle()' CoreSystemTypes.Single); break;            case OpCode.Ldc_R8: expr = new Literal(this.GetDouble()' CoreSystemTypes.Double); break;            case OpCode.Dup: statement = new ExpressionStatement(new Expression(NodeType.Dup)); goto done;            case OpCode.Pop: statement = new ExpressionStatement(new UnaryExpression(PopOperand()' NodeType.Pop)); goto done;            case OpCode.Jmp: expr = this.ParseCall(NodeType.Jmp' out isStatement); if (isStatement) goto done; break;            case OpCode.Call: expr = this.ParseCall(NodeType.Call' out isStatement); if (isStatement) goto done; break;            case OpCode.Calli: expr = this.ParseCalli(out isStatement); if (isStatement) goto done; break;            case OpCode.Ret:              Expression retVal = BodyParser.TypeIsVoid(this.method.ReturnType) ? null : PopOperand();              statement = new Return(retVal);               transferStatement = true; goto done;            case OpCode.Br_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false); transferStatement = true; goto done;            case OpCode.Brfalse_S: statement = this.ParseBranch(NodeType.LogicalNot' 1' true' false); transferStatement = true; goto done;            case OpCode.Brtrue_S: statement = this.ParseBranch(NodeType.Nop' 1' true' false); transferStatement = true; goto done;            case OpCode.Beq_S: statement = this.ParseBranch(NodeType.Eq' 2' true' false); transferStatement = true; goto done;            case OpCode.Bge_S: statement = this.ParseBranch(NodeType.Ge' 2' true' false); transferStatement = true; goto done;            case OpCode.Bgt_S: statement = this.ParseBranch(NodeType.Gt' 2' true' false); transferStatement = true; goto done;            case OpCode.Ble_S: statement = this.ParseBranch(NodeType.Le' 2' true' false); transferStatement = true; goto done;            case OpCode.Blt_S: statement = this.ParseBranch(NodeType.Lt' 2' true' false); transferStatement = true; goto done;            case OpCode.Bne_Un_S: statement = this.ParseBranch(NodeType.Ne' 2' true' true); transferStatement = true; goto done;            case OpCode.Bge_Un_S: statement = this.ParseBranch(NodeType.Ge' 2' true' true); transferStatement = true; goto done;            case OpCode.Bgt_Un_S: statement = this.ParseBranch(NodeType.Gt' 2' true' true); transferStatement = true; goto done;            case OpCode.Ble_Un_S: statement = this.ParseBranch(NodeType.Le' 2' true' true); transferStatement = true; goto done;            case OpCode.Blt_Un_S: statement = this.ParseBranch(NodeType.Lt' 2' true' true); transferStatement = true; goto done;            case OpCode.Br: statement = this.ParseBranch(NodeType.Nop' 0' false' false); transferStatement = true; goto done;            case OpCode.Brfalse: statement = this.ParseBranch(NodeType.LogicalNot' 1' false' false); transferStatement = true; goto done;            case OpCode.Brtrue: statement = this.ParseBranch(NodeType.Nop' 1' false' false); transferStatement = true; goto done;            case OpCode.Beq: statement = this.ParseBranch(NodeType.Eq' 2' false' false); transferStatement = true; goto done;            case OpCode.Bge: statement = this.ParseBranch(NodeType.Ge' 2' false' false); transferStatement = true; goto done;            case OpCode.Bgt: statement = this.ParseBranch(NodeType.Gt' 2' false' false); transferStatement = true; goto done;            case OpCode.Ble: statement = this.ParseBranch(NodeType.Le' 2' false' false); transferStatement = true; goto done;            case OpCode.Blt: statement = this.ParseBranch(NodeType.Lt' 2' false' false); transferStatement = true; goto done;            case OpCode.Bne_Un: statement = this.ParseBranch(NodeType.Ne' 2' false' true); transferStatement = true; goto done;            case OpCode.Bge_Un: statement = this.ParseBranch(NodeType.Ge' 2' false' true); transferStatement = true; goto done;            case OpCode.Bgt_Un: statement = this.ParseBranch(NodeType.Gt' 2' false' true); transferStatement = true; goto done;            case OpCode.Ble_Un: statement = this.ParseBranch(NodeType.Le' 2' false' true); transferStatement = true; goto done;            case OpCode.Blt_Un: statement = this.ParseBranch(NodeType.Lt' 2' false' true); transferStatement = true; goto done;            case OpCode.Switch: statement = this.ParseSwitchInstruction(); transferStatement = true; goto done;            case OpCode.Ldind_I1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int64' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I: expr = new AddressDereference(PopOperand()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Single' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Double' this.isVolatile' this.alignment); break;            case OpCode.Ldind_Ref: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Object' this.isVolatile' this.alignment); break;            case OpCode.Stind_Ref: statement = this.ParseStoreIndirect(CoreSystemTypes.Object); goto done;            case OpCode.Stind_I1: statement = this.ParseStoreIndirect(CoreSystemTypes.Int8); goto done;            case OpCode.Stind_I2: statement = this.ParseStoreIndirect(CoreSystemTypes.Int16); goto done;            case OpCode.Stind_I4: statement = this.ParseStoreIndirect(CoreSystemTypes.Int32); goto done;            case OpCode.Stind_I8: statement = this.ParseStoreIndirect(CoreSystemTypes.Int64); goto done;            case OpCode.Stind_R4: statement = this.ParseStoreIndirect(CoreSystemTypes.Single); goto done;            case OpCode.Stind_R8: statement = this.ParseStoreIndirect(CoreSystemTypes.Double); goto done;            case OpCode.Add: expr = this.ParseBinaryOperation(NodeType.Add); break;            case OpCode.Sub: expr = this.ParseBinaryOperation(NodeType.Sub); break;            case OpCode.Mul: expr = this.ParseBinaryOperation(NodeType.Mul); break;            case OpCode.Div: expr = this.ParseBinaryOperation(NodeType.Div); break;            case OpCode.Div_Un: expr = this.ParseBinaryOperation(NodeType.Div_Un); break;            case OpCode.Rem: expr = this.ParseBinaryOperation(NodeType.Rem); break;            case OpCode.Rem_Un: expr = this.ParseBinaryOperation(NodeType.Rem_Un); break;            case OpCode.And: expr = this.ParseBinaryOperation(NodeType.And); break;            case OpCode.Or: expr = this.ParseBinaryOperation(NodeType.Or); break;            case OpCode.Xor: expr = this.ParseBinaryOperation(NodeType.Xor); break;            case OpCode.Shl: expr = this.ParseBinaryOperation(NodeType.Shl); break;            case OpCode.Shr: expr = this.ParseBinaryOperation(NodeType.Shr); break;            case OpCode.Shr_Un: expr = this.ParseBinaryOperation(NodeType.Shr_Un); break;            case OpCode.Neg: expr = this.ParseUnaryOperation(NodeType.Neg); break;            case OpCode.Not: expr = this.ParseUnaryOperation(NodeType.Not); break;            case OpCode.Conv_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_R4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R4' CoreSystemTypes.Single); break;            case OpCode.Conv_R8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R8' CoreSystemTypes.Double); break;            case OpCode.Conv_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U8' CoreSystemTypes.UInt64); break;            case OpCode.Callvirt: expr = this.ParseCall(NodeType.Callvirt' out isStatement); if (isStatement) goto done; break;            case OpCode.Cpobj: statement = this.ParseCopyObject(); goto done;            case OpCode.Ldobj: expr = new AddressDereference(PopOperand()' (TypeNode)this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldstr: expr = new Literal(this.GetStringFromToken()' CoreSystemTypes.String); break;            case OpCode.Newobj: expr = this.ParseConstruct(); break;            case OpCode.Castclass: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Castclass); break;            case OpCode.Isinst: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Isinst); break;            case OpCode.Conv_R_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R_Un' CoreSystemTypes.Double); break;            case OpCode.Unbox: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Unbox); break;            case OpCode.Throw: statement = new Throw(PopOperand()); transferStatement = true; goto done;            case OpCode.Ldfld:               expr = new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment);              break;            case OpCode.Ldflda:               expr = SetType(new UnaryExpression(new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf));               break;            case OpCode.Stfld: statement = this.ParseStoreField(); goto done;            case OpCode.Ldsfld: expr = new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldsflda: expr = SetType(new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf)); break;            case OpCode.Stsfld: statement = new AssignmentStatement(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' PopOperand()); goto done;            case OpCode.Stobj: statement = this.ParseStoreIndirect((TypeNode)this.GetMemberFromToken()); goto done;            case OpCode.Conv_Ovf_I1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_I2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_I4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_I8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_U2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_U4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_U8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64); break;            case OpCode.Conv_Ovf_I_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr); break;            case OpCode.Box:               TypeNode t = (TypeNode)this.GetMemberFromToken();              TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;              expr = new BinaryExpression(PopOperand()' new Literal(t' CoreSystemTypes.Type)' NodeType.Box' bt); break;            case OpCode.Newarr: expr = this.ParseNewArray(); break;            case OpCode.Ldlen: expr = new UnaryExpression(PopOperand()' NodeType.Ldlen' CoreSystemTypes.UIntPtr); break;            case OpCode.Ldelema: expr = this.ParseArrayElementLoadAddress(); break;            case OpCode.Ldelem_I1:             case OpCode.Ldelem_U1:             case OpCode.Ldelem_I2:             case OpCode.Ldelem_U2:             case OpCode.Ldelem_I4:             case OpCode.Ldelem_U4:             case OpCode.Ldelem_I8:             case OpCode.Ldelem_I:             case OpCode.Ldelem_R4:             case OpCode.Ldelem_R8:             case OpCode.Ldelem_Ref: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem_I:            case OpCode.Stelem_I1:            case OpCode.Stelem_I2:            case OpCode.Stelem_I4:            case OpCode.Stelem_I8:            case OpCode.Stelem_R4:            case OpCode.Stelem_R8:            case OpCode.Stelem_Ref: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Ldelem: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Unbox_Any: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.UnboxAny); break;            case OpCode.Conv_Ovf_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64); break;            case OpCode.Refanyval: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr); break;            case OpCode.Ckfinite: expr = this.ParseUnaryOperation(NodeType.Ckfinite); break;            case OpCode.Mkrefany: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference); break;            case OpCode.Ldtoken: expr = ParseLoadRuntimeMetadataToken(); break;            case OpCode.Conv_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Add_Ovf: expr = this.ParseBinaryOperation(NodeType.Add_Ovf); break;            case OpCode.Add_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Add_Ovf_Un); break;            case OpCode.Mul_Ovf: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf); break;            case OpCode.Mul_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf_Un); break;            case OpCode.Sub_Ovf: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf); break;            case OpCode.Sub_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf_Un); break;            case OpCode.Endfinally: statement = new EndFinally(); transferStatement = true; goto done;            case OpCode.Leave: statement = this.ParseBranch(NodeType.Nop' 0' false' false' true); transferStatement = true; goto done;            case OpCode.Leave_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false' true); transferStatement = true; goto done;            case OpCode.Stind_I: statement = this.ParseStoreIndirect(CoreSystemTypes.IntPtr); goto done;            case OpCode.Conv_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Arglist: expr = new Expression(NodeType.Arglist' CoreSystemTypes.ArgIterator); break;            case OpCode.Ceq: expr = this.ParseBinaryComparison(NodeType.Ceq); break;            case OpCode.Cgt: expr = this.ParseBinaryComparison(NodeType.Cgt); break;            case OpCode.Cgt_Un: expr = this.ParseBinaryComparison(NodeType.Cgt_Un); break;            case OpCode.Clt: expr = this.ParseBinaryComparison(NodeType.Clt); break;            case OpCode.Clt_Un: expr = this.ParseBinaryComparison(NodeType.Clt_Un); break;            case OpCode.Ldftn: expr = new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldvirtftn: expr = new BinaryExpression(PopOperand()' new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldarg: expr = this.Parameters((ushort)this.GetInt16()); break;            case OpCode.Ldarga: expr = SetType(new UnaryExpression(this.Parameters((ushort)this.GetInt16())' NodeType.AddressOf)); break;            case OpCode.Starg: statement = new AssignmentStatement(this.Parameters((ushort)this.GetInt16())' PopOperand()); goto done;            case OpCode.Ldloc: expr = this.locals[(ushort)this.GetInt16()]; break;            case OpCode.Ldloca: expr = SetType(new UnaryExpression(this.locals[(ushort)this.GetInt16()]' NodeType.AddressOf)); break;            case OpCode.Stloc: statement = new AssignmentStatement(this.locals[(ushort)this.GetInt16()]' PopOperand()); goto done;            case OpCode.Localloc: expr = new UnaryExpression(PopOperand()' NodeType.Localloc' CoreSystemTypes.Void); break;            case OpCode.Endfilter: statement = new EndFilter(PopOperand()); transferStatement = true; goto done;            case OpCode.Unaligned_: this.alignment = this.GetByte(); continue;            case OpCode.Volatile_: this.isVolatile = true; continue;            case OpCode.Tail_: this.isTailCall = true; continue;            case OpCode.Initobj: statement = this.ParseInitObject(); goto done;            case OpCode.Constrained_: this.constraint = this.GetMemberFromToken() as TypeNode; continue;            case OpCode.Cpblk: expr = this.ParseTernaryOperation(NodeType.Cpblk); goto done;            case OpCode.Initblk: expr = this.ParseTernaryOperation(NodeType.Initblk); goto done;            case OpCode.Rethrow: statement = new Throw(null); statement.NodeType = NodeType.Rethrow; transferStatement = true; goto done;            case OpCode.Sizeof: expr = new UnaryExpression(new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32); break;            case OpCode.Refanytype: expr = new UnaryExpression(PopOperand()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle); break;            case OpCode.Readonly_: this.isReadOnly = true; continue;            default: throw new InvalidMetadataException(ExceptionStrings.UnknownOpCode);          }          if (this.blockMap[this.counter+1] != null){            transferStatement = true; //Falls through to the next basic block' so implicitly a "transfer" statement            goto done;          }          //^ assume expr != null;  #if FxCop          expr.sourceContext = sourceContext;  #endif  #if FxCop || ILOFFSETS          expr.ILOffset = this.ilOffset;  #endif          this.operandStack.Push(expr);          this.isReadOnly = false;          this.isVolatile = false;          this.isTailCall = false;                  this.alignment = -1;        }
Magic Number,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true){          bool isStatement = false;          startingAddress = this.counter+1; //Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  #if FxCop || ILOFFSETS          this.ilOffset = this.counter;          this.opCode = this.GetOpCode();  #else          OpCode opCode = this.GetOpCode();  #endif  #if FxCop          if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){            expr.sourceContext = sourceContext;            expr.ILOffset = this.ilOffset;            this.operandStack.Push(expr);          }  #endif          switch (opCode){            case OpCode.Nop: statement = new Statement(NodeType.Nop); goto done;            case OpCode.Break: statement = new Statement(NodeType.DebugBreak); goto done;            case OpCode.Ldarg_0: expr = this.Parameters(0); break;            case OpCode.Ldarg_1: expr = this.Parameters(1); break;            case OpCode.Ldarg_2: expr = this.Parameters(2); break;            case OpCode.Ldarg_3: expr = this.Parameters(3); break;            case OpCode.Ldloc_0: expr = this.locals[0]; break;            case OpCode.Ldloc_1: expr = this.locals[1]; break;            case OpCode.Ldloc_2: expr = this.locals[2]; break;            case OpCode.Ldloc_3: expr = this.locals[3]; break;            case OpCode.Stloc_0: statement = new AssignmentStatement(this.locals[0]' PopOperand()); goto done;            case OpCode.Stloc_1: statement = new AssignmentStatement(this.locals[1]' PopOperand()); goto done;            case OpCode.Stloc_2: statement = new AssignmentStatement(this.locals[2]' PopOperand()); goto done;            case OpCode.Stloc_3: statement = new AssignmentStatement(this.locals[3]' PopOperand()); goto done;            case OpCode.Ldarg_S: expr = this.Parameters(this.GetByte()); break;            case OpCode.Ldarga_S: expr = SetType(new UnaryExpression(this.Parameters(this.GetByte())' NodeType.AddressOf)); break;            case OpCode.Starg_S: statement = new AssignmentStatement(this.Parameters(this.GetByte())' PopOperand()); goto done;            case OpCode.Ldloc_S: expr = this.locals[this.GetByte()]; break;            case OpCode.Ldloca_S: expr = SetType(new UnaryExpression(this.locals[this.GetByte()]' NodeType.AddressOf)); break;            case OpCode.Stloc_S: statement = new AssignmentStatement(this.locals[this.GetByte()]' PopOperand()); goto done;            case OpCode.Ldnull: expr = new Literal(null' CoreSystemTypes.Object); break;            case OpCode.Ldc_I4_M1: expr = new Literal(-1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_0: expr = new Literal(0' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_1: expr = new Literal(1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_2: expr = new Literal(2' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_3: expr = new Literal(3' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_4: expr = new Literal(4' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_5: expr = new Literal(5' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_6: expr = new Literal(6' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_7: expr = new Literal(7' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_8: expr = new Literal(8' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_S: expr = new Literal((int)this.GetSByte()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4: expr = new Literal(this.GetInt32()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I8: expr = new Literal(this.GetInt64()' CoreSystemTypes.Int64); break;            case OpCode.Ldc_R4: expr = new Literal(this.GetSingle()' CoreSystemTypes.Single); break;            case OpCode.Ldc_R8: expr = new Literal(this.GetDouble()' CoreSystemTypes.Double); break;            case OpCode.Dup: statement = new ExpressionStatement(new Expression(NodeType.Dup)); goto done;            case OpCode.Pop: statement = new ExpressionStatement(new UnaryExpression(PopOperand()' NodeType.Pop)); goto done;            case OpCode.Jmp: expr = this.ParseCall(NodeType.Jmp' out isStatement); if (isStatement) goto done; break;            case OpCode.Call: expr = this.ParseCall(NodeType.Call' out isStatement); if (isStatement) goto done; break;            case OpCode.Calli: expr = this.ParseCalli(out isStatement); if (isStatement) goto done; break;            case OpCode.Ret:              Expression retVal = BodyParser.TypeIsVoid(this.method.ReturnType) ? null : PopOperand();              statement = new Return(retVal);               transferStatement = true; goto done;            case OpCode.Br_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false); transferStatement = true; goto done;            case OpCode.Brfalse_S: statement = this.ParseBranch(NodeType.LogicalNot' 1' true' false); transferStatement = true; goto done;            case OpCode.Brtrue_S: statement = this.ParseBranch(NodeType.Nop' 1' true' false); transferStatement = true; goto done;            case OpCode.Beq_S: statement = this.ParseBranch(NodeType.Eq' 2' true' false); transferStatement = true; goto done;            case OpCode.Bge_S: statement = this.ParseBranch(NodeType.Ge' 2' true' false); transferStatement = true; goto done;            case OpCode.Bgt_S: statement = this.ParseBranch(NodeType.Gt' 2' true' false); transferStatement = true; goto done;            case OpCode.Ble_S: statement = this.ParseBranch(NodeType.Le' 2' true' false); transferStatement = true; goto done;            case OpCode.Blt_S: statement = this.ParseBranch(NodeType.Lt' 2' true' false); transferStatement = true; goto done;            case OpCode.Bne_Un_S: statement = this.ParseBranch(NodeType.Ne' 2' true' true); transferStatement = true; goto done;            case OpCode.Bge_Un_S: statement = this.ParseBranch(NodeType.Ge' 2' true' true); transferStatement = true; goto done;            case OpCode.Bgt_Un_S: statement = this.ParseBranch(NodeType.Gt' 2' true' true); transferStatement = true; goto done;            case OpCode.Ble_Un_S: statement = this.ParseBranch(NodeType.Le' 2' true' true); transferStatement = true; goto done;            case OpCode.Blt_Un_S: statement = this.ParseBranch(NodeType.Lt' 2' true' true); transferStatement = true; goto done;            case OpCode.Br: statement = this.ParseBranch(NodeType.Nop' 0' false' false); transferStatement = true; goto done;            case OpCode.Brfalse: statement = this.ParseBranch(NodeType.LogicalNot' 1' false' false); transferStatement = true; goto done;            case OpCode.Brtrue: statement = this.ParseBranch(NodeType.Nop' 1' false' false); transferStatement = true; goto done;            case OpCode.Beq: statement = this.ParseBranch(NodeType.Eq' 2' false' false); transferStatement = true; goto done;            case OpCode.Bge: statement = this.ParseBranch(NodeType.Ge' 2' false' false); transferStatement = true; goto done;            case OpCode.Bgt: statement = this.ParseBranch(NodeType.Gt' 2' false' false); transferStatement = true; goto done;            case OpCode.Ble: statement = this.ParseBranch(NodeType.Le' 2' false' false); transferStatement = true; goto done;            case OpCode.Blt: statement = this.ParseBranch(NodeType.Lt' 2' false' false); transferStatement = true; goto done;            case OpCode.Bne_Un: statement = this.ParseBranch(NodeType.Ne' 2' false' true); transferStatement = true; goto done;            case OpCode.Bge_Un: statement = this.ParseBranch(NodeType.Ge' 2' false' true); transferStatement = true; goto done;            case OpCode.Bgt_Un: statement = this.ParseBranch(NodeType.Gt' 2' false' true); transferStatement = true; goto done;            case OpCode.Ble_Un: statement = this.ParseBranch(NodeType.Le' 2' false' true); transferStatement = true; goto done;            case OpCode.Blt_Un: statement = this.ParseBranch(NodeType.Lt' 2' false' true); transferStatement = true; goto done;            case OpCode.Switch: statement = this.ParseSwitchInstruction(); transferStatement = true; goto done;            case OpCode.Ldind_I1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int64' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I: expr = new AddressDereference(PopOperand()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Single' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Double' this.isVolatile' this.alignment); break;            case OpCode.Ldind_Ref: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Object' this.isVolatile' this.alignment); break;            case OpCode.Stind_Ref: statement = this.ParseStoreIndirect(CoreSystemTypes.Object); goto done;            case OpCode.Stind_I1: statement = this.ParseStoreIndirect(CoreSystemTypes.Int8); goto done;            case OpCode.Stind_I2: statement = this.ParseStoreIndirect(CoreSystemTypes.Int16); goto done;            case OpCode.Stind_I4: statement = this.ParseStoreIndirect(CoreSystemTypes.Int32); goto done;            case OpCode.Stind_I8: statement = this.ParseStoreIndirect(CoreSystemTypes.Int64); goto done;            case OpCode.Stind_R4: statement = this.ParseStoreIndirect(CoreSystemTypes.Single); goto done;            case OpCode.Stind_R8: statement = this.ParseStoreIndirect(CoreSystemTypes.Double); goto done;            case OpCode.Add: expr = this.ParseBinaryOperation(NodeType.Add); break;            case OpCode.Sub: expr = this.ParseBinaryOperation(NodeType.Sub); break;            case OpCode.Mul: expr = this.ParseBinaryOperation(NodeType.Mul); break;            case OpCode.Div: expr = this.ParseBinaryOperation(NodeType.Div); break;            case OpCode.Div_Un: expr = this.ParseBinaryOperation(NodeType.Div_Un); break;            case OpCode.Rem: expr = this.ParseBinaryOperation(NodeType.Rem); break;            case OpCode.Rem_Un: expr = this.ParseBinaryOperation(NodeType.Rem_Un); break;            case OpCode.And: expr = this.ParseBinaryOperation(NodeType.And); break;            case OpCode.Or: expr = this.ParseBinaryOperation(NodeType.Or); break;            case OpCode.Xor: expr = this.ParseBinaryOperation(NodeType.Xor); break;            case OpCode.Shl: expr = this.ParseBinaryOperation(NodeType.Shl); break;            case OpCode.Shr: expr = this.ParseBinaryOperation(NodeType.Shr); break;            case OpCode.Shr_Un: expr = this.ParseBinaryOperation(NodeType.Shr_Un); break;            case OpCode.Neg: expr = this.ParseUnaryOperation(NodeType.Neg); break;            case OpCode.Not: expr = this.ParseUnaryOperation(NodeType.Not); break;            case OpCode.Conv_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_R4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R4' CoreSystemTypes.Single); break;            case OpCode.Conv_R8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R8' CoreSystemTypes.Double); break;            case OpCode.Conv_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U8' CoreSystemTypes.UInt64); break;            case OpCode.Callvirt: expr = this.ParseCall(NodeType.Callvirt' out isStatement); if (isStatement) goto done; break;            case OpCode.Cpobj: statement = this.ParseCopyObject(); goto done;            case OpCode.Ldobj: expr = new AddressDereference(PopOperand()' (TypeNode)this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldstr: expr = new Literal(this.GetStringFromToken()' CoreSystemTypes.String); break;            case OpCode.Newobj: expr = this.ParseConstruct(); break;            case OpCode.Castclass: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Castclass); break;            case OpCode.Isinst: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Isinst); break;            case OpCode.Conv_R_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R_Un' CoreSystemTypes.Double); break;            case OpCode.Unbox: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Unbox); break;            case OpCode.Throw: statement = new Throw(PopOperand()); transferStatement = true; goto done;            case OpCode.Ldfld:               expr = new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment);              break;            case OpCode.Ldflda:               expr = SetType(new UnaryExpression(new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf));               break;            case OpCode.Stfld: statement = this.ParseStoreField(); goto done;            case OpCode.Ldsfld: expr = new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldsflda: expr = SetType(new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf)); break;            case OpCode.Stsfld: statement = new AssignmentStatement(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' PopOperand()); goto done;            case OpCode.Stobj: statement = this.ParseStoreIndirect((TypeNode)this.GetMemberFromToken()); goto done;            case OpCode.Conv_Ovf_I1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_I2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_I4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_I8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_U2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_U4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_U8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64); break;            case OpCode.Conv_Ovf_I_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr); break;            case OpCode.Box:               TypeNode t = (TypeNode)this.GetMemberFromToken();              TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;              expr = new BinaryExpression(PopOperand()' new Literal(t' CoreSystemTypes.Type)' NodeType.Box' bt); break;            case OpCode.Newarr: expr = this.ParseNewArray(); break;            case OpCode.Ldlen: expr = new UnaryExpression(PopOperand()' NodeType.Ldlen' CoreSystemTypes.UIntPtr); break;            case OpCode.Ldelema: expr = this.ParseArrayElementLoadAddress(); break;            case OpCode.Ldelem_I1:             case OpCode.Ldelem_U1:             case OpCode.Ldelem_I2:             case OpCode.Ldelem_U2:             case OpCode.Ldelem_I4:             case OpCode.Ldelem_U4:             case OpCode.Ldelem_I8:             case OpCode.Ldelem_I:             case OpCode.Ldelem_R4:             case OpCode.Ldelem_R8:             case OpCode.Ldelem_Ref: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem_I:            case OpCode.Stelem_I1:            case OpCode.Stelem_I2:            case OpCode.Stelem_I4:            case OpCode.Stelem_I8:            case OpCode.Stelem_R4:            case OpCode.Stelem_R8:            case OpCode.Stelem_Ref: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Ldelem: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Unbox_Any: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.UnboxAny); break;            case OpCode.Conv_Ovf_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64); break;            case OpCode.Refanyval: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr); break;            case OpCode.Ckfinite: expr = this.ParseUnaryOperation(NodeType.Ckfinite); break;            case OpCode.Mkrefany: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference); break;            case OpCode.Ldtoken: expr = ParseLoadRuntimeMetadataToken(); break;            case OpCode.Conv_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Add_Ovf: expr = this.ParseBinaryOperation(NodeType.Add_Ovf); break;            case OpCode.Add_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Add_Ovf_Un); break;            case OpCode.Mul_Ovf: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf); break;            case OpCode.Mul_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf_Un); break;            case OpCode.Sub_Ovf: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf); break;            case OpCode.Sub_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf_Un); break;            case OpCode.Endfinally: statement = new EndFinally(); transferStatement = true; goto done;            case OpCode.Leave: statement = this.ParseBranch(NodeType.Nop' 0' false' false' true); transferStatement = true; goto done;            case OpCode.Leave_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false' true); transferStatement = true; goto done;            case OpCode.Stind_I: statement = this.ParseStoreIndirect(CoreSystemTypes.IntPtr); goto done;            case OpCode.Conv_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Arglist: expr = new Expression(NodeType.Arglist' CoreSystemTypes.ArgIterator); break;            case OpCode.Ceq: expr = this.ParseBinaryComparison(NodeType.Ceq); break;            case OpCode.Cgt: expr = this.ParseBinaryComparison(NodeType.Cgt); break;            case OpCode.Cgt_Un: expr = this.ParseBinaryComparison(NodeType.Cgt_Un); break;            case OpCode.Clt: expr = this.ParseBinaryComparison(NodeType.Clt); break;            case OpCode.Clt_Un: expr = this.ParseBinaryComparison(NodeType.Clt_Un); break;            case OpCode.Ldftn: expr = new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldvirtftn: expr = new BinaryExpression(PopOperand()' new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldarg: expr = this.Parameters((ushort)this.GetInt16()); break;            case OpCode.Ldarga: expr = SetType(new UnaryExpression(this.Parameters((ushort)this.GetInt16())' NodeType.AddressOf)); break;            case OpCode.Starg: statement = new AssignmentStatement(this.Parameters((ushort)this.GetInt16())' PopOperand()); goto done;            case OpCode.Ldloc: expr = this.locals[(ushort)this.GetInt16()]; break;            case OpCode.Ldloca: expr = SetType(new UnaryExpression(this.locals[(ushort)this.GetInt16()]' NodeType.AddressOf)); break;            case OpCode.Stloc: statement = new AssignmentStatement(this.locals[(ushort)this.GetInt16()]' PopOperand()); goto done;            case OpCode.Localloc: expr = new UnaryExpression(PopOperand()' NodeType.Localloc' CoreSystemTypes.Void); break;            case OpCode.Endfilter: statement = new EndFilter(PopOperand()); transferStatement = true; goto done;            case OpCode.Unaligned_: this.alignment = this.GetByte(); continue;            case OpCode.Volatile_: this.isVolatile = true; continue;            case OpCode.Tail_: this.isTailCall = true; continue;            case OpCode.Initobj: statement = this.ParseInitObject(); goto done;            case OpCode.Constrained_: this.constraint = this.GetMemberFromToken() as TypeNode; continue;            case OpCode.Cpblk: expr = this.ParseTernaryOperation(NodeType.Cpblk); goto done;            case OpCode.Initblk: expr = this.ParseTernaryOperation(NodeType.Initblk); goto done;            case OpCode.Rethrow: statement = new Throw(null); statement.NodeType = NodeType.Rethrow; transferStatement = true; goto done;            case OpCode.Sizeof: expr = new UnaryExpression(new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32); break;            case OpCode.Refanytype: expr = new UnaryExpression(PopOperand()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle); break;            case OpCode.Readonly_: this.isReadOnly = true; continue;            default: throw new InvalidMetadataException(ExceptionStrings.UnknownOpCode);          }          if (this.blockMap[this.counter+1] != null){            transferStatement = true; //Falls through to the next basic block' so implicitly a "transfer" statement            goto done;          }          //^ assume expr != null;  #if FxCop          expr.sourceContext = sourceContext;  #endif  #if FxCop || ILOFFSETS          expr.ILOffset = this.ilOffset;  #endif          this.operandStack.Push(expr);          this.isReadOnly = false;          this.isVolatile = false;          this.isTailCall = false;                  this.alignment = -1;        }
Magic Number,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true){          bool isStatement = false;          startingAddress = this.counter+1; //Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  #if FxCop || ILOFFSETS          this.ilOffset = this.counter;          this.opCode = this.GetOpCode();  #else          OpCode opCode = this.GetOpCode();  #endif  #if FxCop          if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){            expr.sourceContext = sourceContext;            expr.ILOffset = this.ilOffset;            this.operandStack.Push(expr);          }  #endif          switch (opCode){            case OpCode.Nop: statement = new Statement(NodeType.Nop); goto done;            case OpCode.Break: statement = new Statement(NodeType.DebugBreak); goto done;            case OpCode.Ldarg_0: expr = this.Parameters(0); break;            case OpCode.Ldarg_1: expr = this.Parameters(1); break;            case OpCode.Ldarg_2: expr = this.Parameters(2); break;            case OpCode.Ldarg_3: expr = this.Parameters(3); break;            case OpCode.Ldloc_0: expr = this.locals[0]; break;            case OpCode.Ldloc_1: expr = this.locals[1]; break;            case OpCode.Ldloc_2: expr = this.locals[2]; break;            case OpCode.Ldloc_3: expr = this.locals[3]; break;            case OpCode.Stloc_0: statement = new AssignmentStatement(this.locals[0]' PopOperand()); goto done;            case OpCode.Stloc_1: statement = new AssignmentStatement(this.locals[1]' PopOperand()); goto done;            case OpCode.Stloc_2: statement = new AssignmentStatement(this.locals[2]' PopOperand()); goto done;            case OpCode.Stloc_3: statement = new AssignmentStatement(this.locals[3]' PopOperand()); goto done;            case OpCode.Ldarg_S: expr = this.Parameters(this.GetByte()); break;            case OpCode.Ldarga_S: expr = SetType(new UnaryExpression(this.Parameters(this.GetByte())' NodeType.AddressOf)); break;            case OpCode.Starg_S: statement = new AssignmentStatement(this.Parameters(this.GetByte())' PopOperand()); goto done;            case OpCode.Ldloc_S: expr = this.locals[this.GetByte()]; break;            case OpCode.Ldloca_S: expr = SetType(new UnaryExpression(this.locals[this.GetByte()]' NodeType.AddressOf)); break;            case OpCode.Stloc_S: statement = new AssignmentStatement(this.locals[this.GetByte()]' PopOperand()); goto done;            case OpCode.Ldnull: expr = new Literal(null' CoreSystemTypes.Object); break;            case OpCode.Ldc_I4_M1: expr = new Literal(-1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_0: expr = new Literal(0' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_1: expr = new Literal(1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_2: expr = new Literal(2' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_3: expr = new Literal(3' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_4: expr = new Literal(4' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_5: expr = new Literal(5' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_6: expr = new Literal(6' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_7: expr = new Literal(7' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_8: expr = new Literal(8' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_S: expr = new Literal((int)this.GetSByte()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4: expr = new Literal(this.GetInt32()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I8: expr = new Literal(this.GetInt64()' CoreSystemTypes.Int64); break;            case OpCode.Ldc_R4: expr = new Literal(this.GetSingle()' CoreSystemTypes.Single); break;            case OpCode.Ldc_R8: expr = new Literal(this.GetDouble()' CoreSystemTypes.Double); break;            case OpCode.Dup: statement = new ExpressionStatement(new Expression(NodeType.Dup)); goto done;            case OpCode.Pop: statement = new ExpressionStatement(new UnaryExpression(PopOperand()' NodeType.Pop)); goto done;            case OpCode.Jmp: expr = this.ParseCall(NodeType.Jmp' out isStatement); if (isStatement) goto done; break;            case OpCode.Call: expr = this.ParseCall(NodeType.Call' out isStatement); if (isStatement) goto done; break;            case OpCode.Calli: expr = this.ParseCalli(out isStatement); if (isStatement) goto done; break;            case OpCode.Ret:              Expression retVal = BodyParser.TypeIsVoid(this.method.ReturnType) ? null : PopOperand();              statement = new Return(retVal);               transferStatement = true; goto done;            case OpCode.Br_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false); transferStatement = true; goto done;            case OpCode.Brfalse_S: statement = this.ParseBranch(NodeType.LogicalNot' 1' true' false); transferStatement = true; goto done;            case OpCode.Brtrue_S: statement = this.ParseBranch(NodeType.Nop' 1' true' false); transferStatement = true; goto done;            case OpCode.Beq_S: statement = this.ParseBranch(NodeType.Eq' 2' true' false); transferStatement = true; goto done;            case OpCode.Bge_S: statement = this.ParseBranch(NodeType.Ge' 2' true' false); transferStatement = true; goto done;            case OpCode.Bgt_S: statement = this.ParseBranch(NodeType.Gt' 2' true' false); transferStatement = true; goto done;            case OpCode.Ble_S: statement = this.ParseBranch(NodeType.Le' 2' true' false); transferStatement = true; goto done;            case OpCode.Blt_S: statement = this.ParseBranch(NodeType.Lt' 2' true' false); transferStatement = true; goto done;            case OpCode.Bne_Un_S: statement = this.ParseBranch(NodeType.Ne' 2' true' true); transferStatement = true; goto done;            case OpCode.Bge_Un_S: statement = this.ParseBranch(NodeType.Ge' 2' true' true); transferStatement = true; goto done;            case OpCode.Bgt_Un_S: statement = this.ParseBranch(NodeType.Gt' 2' true' true); transferStatement = true; goto done;            case OpCode.Ble_Un_S: statement = this.ParseBranch(NodeType.Le' 2' true' true); transferStatement = true; goto done;            case OpCode.Blt_Un_S: statement = this.ParseBranch(NodeType.Lt' 2' true' true); transferStatement = true; goto done;            case OpCode.Br: statement = this.ParseBranch(NodeType.Nop' 0' false' false); transferStatement = true; goto done;            case OpCode.Brfalse: statement = this.ParseBranch(NodeType.LogicalNot' 1' false' false); transferStatement = true; goto done;            case OpCode.Brtrue: statement = this.ParseBranch(NodeType.Nop' 1' false' false); transferStatement = true; goto done;            case OpCode.Beq: statement = this.ParseBranch(NodeType.Eq' 2' false' false); transferStatement = true; goto done;            case OpCode.Bge: statement = this.ParseBranch(NodeType.Ge' 2' false' false); transferStatement = true; goto done;            case OpCode.Bgt: statement = this.ParseBranch(NodeType.Gt' 2' false' false); transferStatement = true; goto done;            case OpCode.Ble: statement = this.ParseBranch(NodeType.Le' 2' false' false); transferStatement = true; goto done;            case OpCode.Blt: statement = this.ParseBranch(NodeType.Lt' 2' false' false); transferStatement = true; goto done;            case OpCode.Bne_Un: statement = this.ParseBranch(NodeType.Ne' 2' false' true); transferStatement = true; goto done;            case OpCode.Bge_Un: statement = this.ParseBranch(NodeType.Ge' 2' false' true); transferStatement = true; goto done;            case OpCode.Bgt_Un: statement = this.ParseBranch(NodeType.Gt' 2' false' true); transferStatement = true; goto done;            case OpCode.Ble_Un: statement = this.ParseBranch(NodeType.Le' 2' false' true); transferStatement = true; goto done;            case OpCode.Blt_Un: statement = this.ParseBranch(NodeType.Lt' 2' false' true); transferStatement = true; goto done;            case OpCode.Switch: statement = this.ParseSwitchInstruction(); transferStatement = true; goto done;            case OpCode.Ldind_I1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int64' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I: expr = new AddressDereference(PopOperand()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Single' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Double' this.isVolatile' this.alignment); break;            case OpCode.Ldind_Ref: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Object' this.isVolatile' this.alignment); break;            case OpCode.Stind_Ref: statement = this.ParseStoreIndirect(CoreSystemTypes.Object); goto done;            case OpCode.Stind_I1: statement = this.ParseStoreIndirect(CoreSystemTypes.Int8); goto done;            case OpCode.Stind_I2: statement = this.ParseStoreIndirect(CoreSystemTypes.Int16); goto done;            case OpCode.Stind_I4: statement = this.ParseStoreIndirect(CoreSystemTypes.Int32); goto done;            case OpCode.Stind_I8: statement = this.ParseStoreIndirect(CoreSystemTypes.Int64); goto done;            case OpCode.Stind_R4: statement = this.ParseStoreIndirect(CoreSystemTypes.Single); goto done;            case OpCode.Stind_R8: statement = this.ParseStoreIndirect(CoreSystemTypes.Double); goto done;            case OpCode.Add: expr = this.ParseBinaryOperation(NodeType.Add); break;            case OpCode.Sub: expr = this.ParseBinaryOperation(NodeType.Sub); break;            case OpCode.Mul: expr = this.ParseBinaryOperation(NodeType.Mul); break;            case OpCode.Div: expr = this.ParseBinaryOperation(NodeType.Div); break;            case OpCode.Div_Un: expr = this.ParseBinaryOperation(NodeType.Div_Un); break;            case OpCode.Rem: expr = this.ParseBinaryOperation(NodeType.Rem); break;            case OpCode.Rem_Un: expr = this.ParseBinaryOperation(NodeType.Rem_Un); break;            case OpCode.And: expr = this.ParseBinaryOperation(NodeType.And); break;            case OpCode.Or: expr = this.ParseBinaryOperation(NodeType.Or); break;            case OpCode.Xor: expr = this.ParseBinaryOperation(NodeType.Xor); break;            case OpCode.Shl: expr = this.ParseBinaryOperation(NodeType.Shl); break;            case OpCode.Shr: expr = this.ParseBinaryOperation(NodeType.Shr); break;            case OpCode.Shr_Un: expr = this.ParseBinaryOperation(NodeType.Shr_Un); break;            case OpCode.Neg: expr = this.ParseUnaryOperation(NodeType.Neg); break;            case OpCode.Not: expr = this.ParseUnaryOperation(NodeType.Not); break;            case OpCode.Conv_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_R4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R4' CoreSystemTypes.Single); break;            case OpCode.Conv_R8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R8' CoreSystemTypes.Double); break;            case OpCode.Conv_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U8' CoreSystemTypes.UInt64); break;            case OpCode.Callvirt: expr = this.ParseCall(NodeType.Callvirt' out isStatement); if (isStatement) goto done; break;            case OpCode.Cpobj: statement = this.ParseCopyObject(); goto done;            case OpCode.Ldobj: expr = new AddressDereference(PopOperand()' (TypeNode)this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldstr: expr = new Literal(this.GetStringFromToken()' CoreSystemTypes.String); break;            case OpCode.Newobj: expr = this.ParseConstruct(); break;            case OpCode.Castclass: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Castclass); break;            case OpCode.Isinst: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Isinst); break;            case OpCode.Conv_R_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R_Un' CoreSystemTypes.Double); break;            case OpCode.Unbox: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Unbox); break;            case OpCode.Throw: statement = new Throw(PopOperand()); transferStatement = true; goto done;            case OpCode.Ldfld:               expr = new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment);              break;            case OpCode.Ldflda:               expr = SetType(new UnaryExpression(new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf));               break;            case OpCode.Stfld: statement = this.ParseStoreField(); goto done;            case OpCode.Ldsfld: expr = new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldsflda: expr = SetType(new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf)); break;            case OpCode.Stsfld: statement = new AssignmentStatement(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' PopOperand()); goto done;            case OpCode.Stobj: statement = this.ParseStoreIndirect((TypeNode)this.GetMemberFromToken()); goto done;            case OpCode.Conv_Ovf_I1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_I2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_I4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_I8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_U2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_U4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_U8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64); break;            case OpCode.Conv_Ovf_I_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr); break;            case OpCode.Box:               TypeNode t = (TypeNode)this.GetMemberFromToken();              TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;              expr = new BinaryExpression(PopOperand()' new Literal(t' CoreSystemTypes.Type)' NodeType.Box' bt); break;            case OpCode.Newarr: expr = this.ParseNewArray(); break;            case OpCode.Ldlen: expr = new UnaryExpression(PopOperand()' NodeType.Ldlen' CoreSystemTypes.UIntPtr); break;            case OpCode.Ldelema: expr = this.ParseArrayElementLoadAddress(); break;            case OpCode.Ldelem_I1:             case OpCode.Ldelem_U1:             case OpCode.Ldelem_I2:             case OpCode.Ldelem_U2:             case OpCode.Ldelem_I4:             case OpCode.Ldelem_U4:             case OpCode.Ldelem_I8:             case OpCode.Ldelem_I:             case OpCode.Ldelem_R4:             case OpCode.Ldelem_R8:             case OpCode.Ldelem_Ref: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem_I:            case OpCode.Stelem_I1:            case OpCode.Stelem_I2:            case OpCode.Stelem_I4:            case OpCode.Stelem_I8:            case OpCode.Stelem_R4:            case OpCode.Stelem_R8:            case OpCode.Stelem_Ref: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Ldelem: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Unbox_Any: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.UnboxAny); break;            case OpCode.Conv_Ovf_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64); break;            case OpCode.Refanyval: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr); break;            case OpCode.Ckfinite: expr = this.ParseUnaryOperation(NodeType.Ckfinite); break;            case OpCode.Mkrefany: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference); break;            case OpCode.Ldtoken: expr = ParseLoadRuntimeMetadataToken(); break;            case OpCode.Conv_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Add_Ovf: expr = this.ParseBinaryOperation(NodeType.Add_Ovf); break;            case OpCode.Add_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Add_Ovf_Un); break;            case OpCode.Mul_Ovf: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf); break;            case OpCode.Mul_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf_Un); break;            case OpCode.Sub_Ovf: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf); break;            case OpCode.Sub_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf_Un); break;            case OpCode.Endfinally: statement = new EndFinally(); transferStatement = true; goto done;            case OpCode.Leave: statement = this.ParseBranch(NodeType.Nop' 0' false' false' true); transferStatement = true; goto done;            case OpCode.Leave_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false' true); transferStatement = true; goto done;            case OpCode.Stind_I: statement = this.ParseStoreIndirect(CoreSystemTypes.IntPtr); goto done;            case OpCode.Conv_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Arglist: expr = new Expression(NodeType.Arglist' CoreSystemTypes.ArgIterator); break;            case OpCode.Ceq: expr = this.ParseBinaryComparison(NodeType.Ceq); break;            case OpCode.Cgt: expr = this.ParseBinaryComparison(NodeType.Cgt); break;            case OpCode.Cgt_Un: expr = this.ParseBinaryComparison(NodeType.Cgt_Un); break;            case OpCode.Clt: expr = this.ParseBinaryComparison(NodeType.Clt); break;            case OpCode.Clt_Un: expr = this.ParseBinaryComparison(NodeType.Clt_Un); break;            case OpCode.Ldftn: expr = new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldvirtftn: expr = new BinaryExpression(PopOperand()' new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldarg: expr = this.Parameters((ushort)this.GetInt16()); break;            case OpCode.Ldarga: expr = SetType(new UnaryExpression(this.Parameters((ushort)this.GetInt16())' NodeType.AddressOf)); break;            case OpCode.Starg: statement = new AssignmentStatement(this.Parameters((ushort)this.GetInt16())' PopOperand()); goto done;            case OpCode.Ldloc: expr = this.locals[(ushort)this.GetInt16()]; break;            case OpCode.Ldloca: expr = SetType(new UnaryExpression(this.locals[(ushort)this.GetInt16()]' NodeType.AddressOf)); break;            case OpCode.Stloc: statement = new AssignmentStatement(this.locals[(ushort)this.GetInt16()]' PopOperand()); goto done;            case OpCode.Localloc: expr = new UnaryExpression(PopOperand()' NodeType.Localloc' CoreSystemTypes.Void); break;            case OpCode.Endfilter: statement = new EndFilter(PopOperand()); transferStatement = true; goto done;            case OpCode.Unaligned_: this.alignment = this.GetByte(); continue;            case OpCode.Volatile_: this.isVolatile = true; continue;            case OpCode.Tail_: this.isTailCall = true; continue;            case OpCode.Initobj: statement = this.ParseInitObject(); goto done;            case OpCode.Constrained_: this.constraint = this.GetMemberFromToken() as TypeNode; continue;            case OpCode.Cpblk: expr = this.ParseTernaryOperation(NodeType.Cpblk); goto done;            case OpCode.Initblk: expr = this.ParseTernaryOperation(NodeType.Initblk); goto done;            case OpCode.Rethrow: statement = new Throw(null); statement.NodeType = NodeType.Rethrow; transferStatement = true; goto done;            case OpCode.Sizeof: expr = new UnaryExpression(new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32); break;            case OpCode.Refanytype: expr = new UnaryExpression(PopOperand()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle); break;            case OpCode.Readonly_: this.isReadOnly = true; continue;            default: throw new InvalidMetadataException(ExceptionStrings.UnknownOpCode);          }          if (this.blockMap[this.counter+1] != null){            transferStatement = true; //Falls through to the next basic block' so implicitly a "transfer" statement            goto done;          }          //^ assume expr != null;  #if FxCop          expr.sourceContext = sourceContext;  #endif  #if FxCop || ILOFFSETS          expr.ILOffset = this.ilOffset;  #endif          this.operandStack.Push(expr);          this.isReadOnly = false;          this.isVolatile = false;          this.isTailCall = false;                  this.alignment = -1;        }
Magic Number,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true){          bool isStatement = false;          startingAddress = this.counter+1; //Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  #if FxCop || ILOFFSETS          this.ilOffset = this.counter;          this.opCode = this.GetOpCode();  #else          OpCode opCode = this.GetOpCode();  #endif  #if FxCop          if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){            expr.sourceContext = sourceContext;            expr.ILOffset = this.ilOffset;            this.operandStack.Push(expr);          }  #endif          switch (opCode){            case OpCode.Nop: statement = new Statement(NodeType.Nop); goto done;            case OpCode.Break: statement = new Statement(NodeType.DebugBreak); goto done;            case OpCode.Ldarg_0: expr = this.Parameters(0); break;            case OpCode.Ldarg_1: expr = this.Parameters(1); break;            case OpCode.Ldarg_2: expr = this.Parameters(2); break;            case OpCode.Ldarg_3: expr = this.Parameters(3); break;            case OpCode.Ldloc_0: expr = this.locals[0]; break;            case OpCode.Ldloc_1: expr = this.locals[1]; break;            case OpCode.Ldloc_2: expr = this.locals[2]; break;            case OpCode.Ldloc_3: expr = this.locals[3]; break;            case OpCode.Stloc_0: statement = new AssignmentStatement(this.locals[0]' PopOperand()); goto done;            case OpCode.Stloc_1: statement = new AssignmentStatement(this.locals[1]' PopOperand()); goto done;            case OpCode.Stloc_2: statement = new AssignmentStatement(this.locals[2]' PopOperand()); goto done;            case OpCode.Stloc_3: statement = new AssignmentStatement(this.locals[3]' PopOperand()); goto done;            case OpCode.Ldarg_S: expr = this.Parameters(this.GetByte()); break;            case OpCode.Ldarga_S: expr = SetType(new UnaryExpression(this.Parameters(this.GetByte())' NodeType.AddressOf)); break;            case OpCode.Starg_S: statement = new AssignmentStatement(this.Parameters(this.GetByte())' PopOperand()); goto done;            case OpCode.Ldloc_S: expr = this.locals[this.GetByte()]; break;            case OpCode.Ldloca_S: expr = SetType(new UnaryExpression(this.locals[this.GetByte()]' NodeType.AddressOf)); break;            case OpCode.Stloc_S: statement = new AssignmentStatement(this.locals[this.GetByte()]' PopOperand()); goto done;            case OpCode.Ldnull: expr = new Literal(null' CoreSystemTypes.Object); break;            case OpCode.Ldc_I4_M1: expr = new Literal(-1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_0: expr = new Literal(0' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_1: expr = new Literal(1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_2: expr = new Literal(2' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_3: expr = new Literal(3' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_4: expr = new Literal(4' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_5: expr = new Literal(5' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_6: expr = new Literal(6' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_7: expr = new Literal(7' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_8: expr = new Literal(8' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_S: expr = new Literal((int)this.GetSByte()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4: expr = new Literal(this.GetInt32()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I8: expr = new Literal(this.GetInt64()' CoreSystemTypes.Int64); break;            case OpCode.Ldc_R4: expr = new Literal(this.GetSingle()' CoreSystemTypes.Single); break;            case OpCode.Ldc_R8: expr = new Literal(this.GetDouble()' CoreSystemTypes.Double); break;            case OpCode.Dup: statement = new ExpressionStatement(new Expression(NodeType.Dup)); goto done;            case OpCode.Pop: statement = new ExpressionStatement(new UnaryExpression(PopOperand()' NodeType.Pop)); goto done;            case OpCode.Jmp: expr = this.ParseCall(NodeType.Jmp' out isStatement); if (isStatement) goto done; break;            case OpCode.Call: expr = this.ParseCall(NodeType.Call' out isStatement); if (isStatement) goto done; break;            case OpCode.Calli: expr = this.ParseCalli(out isStatement); if (isStatement) goto done; break;            case OpCode.Ret:              Expression retVal = BodyParser.TypeIsVoid(this.method.ReturnType) ? null : PopOperand();              statement = new Return(retVal);               transferStatement = true; goto done;            case OpCode.Br_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false); transferStatement = true; goto done;            case OpCode.Brfalse_S: statement = this.ParseBranch(NodeType.LogicalNot' 1' true' false); transferStatement = true; goto done;            case OpCode.Brtrue_S: statement = this.ParseBranch(NodeType.Nop' 1' true' false); transferStatement = true; goto done;            case OpCode.Beq_S: statement = this.ParseBranch(NodeType.Eq' 2' true' false); transferStatement = true; goto done;            case OpCode.Bge_S: statement = this.ParseBranch(NodeType.Ge' 2' true' false); transferStatement = true; goto done;            case OpCode.Bgt_S: statement = this.ParseBranch(NodeType.Gt' 2' true' false); transferStatement = true; goto done;            case OpCode.Ble_S: statement = this.ParseBranch(NodeType.Le' 2' true' false); transferStatement = true; goto done;            case OpCode.Blt_S: statement = this.ParseBranch(NodeType.Lt' 2' true' false); transferStatement = true; goto done;            case OpCode.Bne_Un_S: statement = this.ParseBranch(NodeType.Ne' 2' true' true); transferStatement = true; goto done;            case OpCode.Bge_Un_S: statement = this.ParseBranch(NodeType.Ge' 2' true' true); transferStatement = true; goto done;            case OpCode.Bgt_Un_S: statement = this.ParseBranch(NodeType.Gt' 2' true' true); transferStatement = true; goto done;            case OpCode.Ble_Un_S: statement = this.ParseBranch(NodeType.Le' 2' true' true); transferStatement = true; goto done;            case OpCode.Blt_Un_S: statement = this.ParseBranch(NodeType.Lt' 2' true' true); transferStatement = true; goto done;            case OpCode.Br: statement = this.ParseBranch(NodeType.Nop' 0' false' false); transferStatement = true; goto done;            case OpCode.Brfalse: statement = this.ParseBranch(NodeType.LogicalNot' 1' false' false); transferStatement = true; goto done;            case OpCode.Brtrue: statement = this.ParseBranch(NodeType.Nop' 1' false' false); transferStatement = true; goto done;            case OpCode.Beq: statement = this.ParseBranch(NodeType.Eq' 2' false' false); transferStatement = true; goto done;            case OpCode.Bge: statement = this.ParseBranch(NodeType.Ge' 2' false' false); transferStatement = true; goto done;            case OpCode.Bgt: statement = this.ParseBranch(NodeType.Gt' 2' false' false); transferStatement = true; goto done;            case OpCode.Ble: statement = this.ParseBranch(NodeType.Le' 2' false' false); transferStatement = true; goto done;            case OpCode.Blt: statement = this.ParseBranch(NodeType.Lt' 2' false' false); transferStatement = true; goto done;            case OpCode.Bne_Un: statement = this.ParseBranch(NodeType.Ne' 2' false' true); transferStatement = true; goto done;            case OpCode.Bge_Un: statement = this.ParseBranch(NodeType.Ge' 2' false' true); transferStatement = true; goto done;            case OpCode.Bgt_Un: statement = this.ParseBranch(NodeType.Gt' 2' false' true); transferStatement = true; goto done;            case OpCode.Ble_Un: statement = this.ParseBranch(NodeType.Le' 2' false' true); transferStatement = true; goto done;            case OpCode.Blt_Un: statement = this.ParseBranch(NodeType.Lt' 2' false' true); transferStatement = true; goto done;            case OpCode.Switch: statement = this.ParseSwitchInstruction(); transferStatement = true; goto done;            case OpCode.Ldind_I1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int64' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I: expr = new AddressDereference(PopOperand()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Single' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Double' this.isVolatile' this.alignment); break;            case OpCode.Ldind_Ref: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Object' this.isVolatile' this.alignment); break;            case OpCode.Stind_Ref: statement = this.ParseStoreIndirect(CoreSystemTypes.Object); goto done;            case OpCode.Stind_I1: statement = this.ParseStoreIndirect(CoreSystemTypes.Int8); goto done;            case OpCode.Stind_I2: statement = this.ParseStoreIndirect(CoreSystemTypes.Int16); goto done;            case OpCode.Stind_I4: statement = this.ParseStoreIndirect(CoreSystemTypes.Int32); goto done;            case OpCode.Stind_I8: statement = this.ParseStoreIndirect(CoreSystemTypes.Int64); goto done;            case OpCode.Stind_R4: statement = this.ParseStoreIndirect(CoreSystemTypes.Single); goto done;            case OpCode.Stind_R8: statement = this.ParseStoreIndirect(CoreSystemTypes.Double); goto done;            case OpCode.Add: expr = this.ParseBinaryOperation(NodeType.Add); break;            case OpCode.Sub: expr = this.ParseBinaryOperation(NodeType.Sub); break;            case OpCode.Mul: expr = this.ParseBinaryOperation(NodeType.Mul); break;            case OpCode.Div: expr = this.ParseBinaryOperation(NodeType.Div); break;            case OpCode.Div_Un: expr = this.ParseBinaryOperation(NodeType.Div_Un); break;            case OpCode.Rem: expr = this.ParseBinaryOperation(NodeType.Rem); break;            case OpCode.Rem_Un: expr = this.ParseBinaryOperation(NodeType.Rem_Un); break;            case OpCode.And: expr = this.ParseBinaryOperation(NodeType.And); break;            case OpCode.Or: expr = this.ParseBinaryOperation(NodeType.Or); break;            case OpCode.Xor: expr = this.ParseBinaryOperation(NodeType.Xor); break;            case OpCode.Shl: expr = this.ParseBinaryOperation(NodeType.Shl); break;            case OpCode.Shr: expr = this.ParseBinaryOperation(NodeType.Shr); break;            case OpCode.Shr_Un: expr = this.ParseBinaryOperation(NodeType.Shr_Un); break;            case OpCode.Neg: expr = this.ParseUnaryOperation(NodeType.Neg); break;            case OpCode.Not: expr = this.ParseUnaryOperation(NodeType.Not); break;            case OpCode.Conv_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_R4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R4' CoreSystemTypes.Single); break;            case OpCode.Conv_R8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R8' CoreSystemTypes.Double); break;            case OpCode.Conv_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U8' CoreSystemTypes.UInt64); break;            case OpCode.Callvirt: expr = this.ParseCall(NodeType.Callvirt' out isStatement); if (isStatement) goto done; break;            case OpCode.Cpobj: statement = this.ParseCopyObject(); goto done;            case OpCode.Ldobj: expr = new AddressDereference(PopOperand()' (TypeNode)this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldstr: expr = new Literal(this.GetStringFromToken()' CoreSystemTypes.String); break;            case OpCode.Newobj: expr = this.ParseConstruct(); break;            case OpCode.Castclass: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Castclass); break;            case OpCode.Isinst: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Isinst); break;            case OpCode.Conv_R_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R_Un' CoreSystemTypes.Double); break;            case OpCode.Unbox: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Unbox); break;            case OpCode.Throw: statement = new Throw(PopOperand()); transferStatement = true; goto done;            case OpCode.Ldfld:               expr = new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment);              break;            case OpCode.Ldflda:               expr = SetType(new UnaryExpression(new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf));               break;            case OpCode.Stfld: statement = this.ParseStoreField(); goto done;            case OpCode.Ldsfld: expr = new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldsflda: expr = SetType(new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf)); break;            case OpCode.Stsfld: statement = new AssignmentStatement(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' PopOperand()); goto done;            case OpCode.Stobj: statement = this.ParseStoreIndirect((TypeNode)this.GetMemberFromToken()); goto done;            case OpCode.Conv_Ovf_I1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_I2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_I4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_I8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_U2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_U4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_U8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64); break;            case OpCode.Conv_Ovf_I_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr); break;            case OpCode.Box:               TypeNode t = (TypeNode)this.GetMemberFromToken();              TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;              expr = new BinaryExpression(PopOperand()' new Literal(t' CoreSystemTypes.Type)' NodeType.Box' bt); break;            case OpCode.Newarr: expr = this.ParseNewArray(); break;            case OpCode.Ldlen: expr = new UnaryExpression(PopOperand()' NodeType.Ldlen' CoreSystemTypes.UIntPtr); break;            case OpCode.Ldelema: expr = this.ParseArrayElementLoadAddress(); break;            case OpCode.Ldelem_I1:             case OpCode.Ldelem_U1:             case OpCode.Ldelem_I2:             case OpCode.Ldelem_U2:             case OpCode.Ldelem_I4:             case OpCode.Ldelem_U4:             case OpCode.Ldelem_I8:             case OpCode.Ldelem_I:             case OpCode.Ldelem_R4:             case OpCode.Ldelem_R8:             case OpCode.Ldelem_Ref: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem_I:            case OpCode.Stelem_I1:            case OpCode.Stelem_I2:            case OpCode.Stelem_I4:            case OpCode.Stelem_I8:            case OpCode.Stelem_R4:            case OpCode.Stelem_R8:            case OpCode.Stelem_Ref: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Ldelem: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Unbox_Any: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.UnboxAny); break;            case OpCode.Conv_Ovf_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64); break;            case OpCode.Refanyval: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr); break;            case OpCode.Ckfinite: expr = this.ParseUnaryOperation(NodeType.Ckfinite); break;            case OpCode.Mkrefany: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference); break;            case OpCode.Ldtoken: expr = ParseLoadRuntimeMetadataToken(); break;            case OpCode.Conv_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Add_Ovf: expr = this.ParseBinaryOperation(NodeType.Add_Ovf); break;            case OpCode.Add_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Add_Ovf_Un); break;            case OpCode.Mul_Ovf: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf); break;            case OpCode.Mul_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf_Un); break;            case OpCode.Sub_Ovf: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf); break;            case OpCode.Sub_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf_Un); break;            case OpCode.Endfinally: statement = new EndFinally(); transferStatement = true; goto done;            case OpCode.Leave: statement = this.ParseBranch(NodeType.Nop' 0' false' false' true); transferStatement = true; goto done;            case OpCode.Leave_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false' true); transferStatement = true; goto done;            case OpCode.Stind_I: statement = this.ParseStoreIndirect(CoreSystemTypes.IntPtr); goto done;            case OpCode.Conv_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Arglist: expr = new Expression(NodeType.Arglist' CoreSystemTypes.ArgIterator); break;            case OpCode.Ceq: expr = this.ParseBinaryComparison(NodeType.Ceq); break;            case OpCode.Cgt: expr = this.ParseBinaryComparison(NodeType.Cgt); break;            case OpCode.Cgt_Un: expr = this.ParseBinaryComparison(NodeType.Cgt_Un); break;            case OpCode.Clt: expr = this.ParseBinaryComparison(NodeType.Clt); break;            case OpCode.Clt_Un: expr = this.ParseBinaryComparison(NodeType.Clt_Un); break;            case OpCode.Ldftn: expr = new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldvirtftn: expr = new BinaryExpression(PopOperand()' new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldarg: expr = this.Parameters((ushort)this.GetInt16()); break;            case OpCode.Ldarga: expr = SetType(new UnaryExpression(this.Parameters((ushort)this.GetInt16())' NodeType.AddressOf)); break;            case OpCode.Starg: statement = new AssignmentStatement(this.Parameters((ushort)this.GetInt16())' PopOperand()); goto done;            case OpCode.Ldloc: expr = this.locals[(ushort)this.GetInt16()]; break;            case OpCode.Ldloca: expr = SetType(new UnaryExpression(this.locals[(ushort)this.GetInt16()]' NodeType.AddressOf)); break;            case OpCode.Stloc: statement = new AssignmentStatement(this.locals[(ushort)this.GetInt16()]' PopOperand()); goto done;            case OpCode.Localloc: expr = new UnaryExpression(PopOperand()' NodeType.Localloc' CoreSystemTypes.Void); break;            case OpCode.Endfilter: statement = new EndFilter(PopOperand()); transferStatement = true; goto done;            case OpCode.Unaligned_: this.alignment = this.GetByte(); continue;            case OpCode.Volatile_: this.isVolatile = true; continue;            case OpCode.Tail_: this.isTailCall = true; continue;            case OpCode.Initobj: statement = this.ParseInitObject(); goto done;            case OpCode.Constrained_: this.constraint = this.GetMemberFromToken() as TypeNode; continue;            case OpCode.Cpblk: expr = this.ParseTernaryOperation(NodeType.Cpblk); goto done;            case OpCode.Initblk: expr = this.ParseTernaryOperation(NodeType.Initblk); goto done;            case OpCode.Rethrow: statement = new Throw(null); statement.NodeType = NodeType.Rethrow; transferStatement = true; goto done;            case OpCode.Sizeof: expr = new UnaryExpression(new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32); break;            case OpCode.Refanytype: expr = new UnaryExpression(PopOperand()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle); break;            case OpCode.Readonly_: this.isReadOnly = true; continue;            default: throw new InvalidMetadataException(ExceptionStrings.UnknownOpCode);          }          if (this.blockMap[this.counter+1] != null){            transferStatement = true; //Falls through to the next basic block' so implicitly a "transfer" statement            goto done;          }          //^ assume expr != null;  #if FxCop          expr.sourceContext = sourceContext;  #endif  #if FxCop || ILOFFSETS          expr.ILOffset = this.ilOffset;  #endif          this.operandStack.Push(expr);          this.isReadOnly = false;          this.isVolatile = false;          this.isTailCall = false;                  this.alignment = -1;        }
Magic Number,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true){          bool isStatement = false;          startingAddress = this.counter+1; //Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  #if FxCop || ILOFFSETS          this.ilOffset = this.counter;          this.opCode = this.GetOpCode();  #else          OpCode opCode = this.GetOpCode();  #endif  #if FxCop          if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){            expr.sourceContext = sourceContext;            expr.ILOffset = this.ilOffset;            this.operandStack.Push(expr);          }  #endif          switch (opCode){            case OpCode.Nop: statement = new Statement(NodeType.Nop); goto done;            case OpCode.Break: statement = new Statement(NodeType.DebugBreak); goto done;            case OpCode.Ldarg_0: expr = this.Parameters(0); break;            case OpCode.Ldarg_1: expr = this.Parameters(1); break;            case OpCode.Ldarg_2: expr = this.Parameters(2); break;            case OpCode.Ldarg_3: expr = this.Parameters(3); break;            case OpCode.Ldloc_0: expr = this.locals[0]; break;            case OpCode.Ldloc_1: expr = this.locals[1]; break;            case OpCode.Ldloc_2: expr = this.locals[2]; break;            case OpCode.Ldloc_3: expr = this.locals[3]; break;            case OpCode.Stloc_0: statement = new AssignmentStatement(this.locals[0]' PopOperand()); goto done;            case OpCode.Stloc_1: statement = new AssignmentStatement(this.locals[1]' PopOperand()); goto done;            case OpCode.Stloc_2: statement = new AssignmentStatement(this.locals[2]' PopOperand()); goto done;            case OpCode.Stloc_3: statement = new AssignmentStatement(this.locals[3]' PopOperand()); goto done;            case OpCode.Ldarg_S: expr = this.Parameters(this.GetByte()); break;            case OpCode.Ldarga_S: expr = SetType(new UnaryExpression(this.Parameters(this.GetByte())' NodeType.AddressOf)); break;            case OpCode.Starg_S: statement = new AssignmentStatement(this.Parameters(this.GetByte())' PopOperand()); goto done;            case OpCode.Ldloc_S: expr = this.locals[this.GetByte()]; break;            case OpCode.Ldloca_S: expr = SetType(new UnaryExpression(this.locals[this.GetByte()]' NodeType.AddressOf)); break;            case OpCode.Stloc_S: statement = new AssignmentStatement(this.locals[this.GetByte()]' PopOperand()); goto done;            case OpCode.Ldnull: expr = new Literal(null' CoreSystemTypes.Object); break;            case OpCode.Ldc_I4_M1: expr = new Literal(-1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_0: expr = new Literal(0' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_1: expr = new Literal(1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_2: expr = new Literal(2' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_3: expr = new Literal(3' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_4: expr = new Literal(4' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_5: expr = new Literal(5' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_6: expr = new Literal(6' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_7: expr = new Literal(7' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_8: expr = new Literal(8' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_S: expr = new Literal((int)this.GetSByte()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4: expr = new Literal(this.GetInt32()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I8: expr = new Literal(this.GetInt64()' CoreSystemTypes.Int64); break;            case OpCode.Ldc_R4: expr = new Literal(this.GetSingle()' CoreSystemTypes.Single); break;            case OpCode.Ldc_R8: expr = new Literal(this.GetDouble()' CoreSystemTypes.Double); break;            case OpCode.Dup: statement = new ExpressionStatement(new Expression(NodeType.Dup)); goto done;            case OpCode.Pop: statement = new ExpressionStatement(new UnaryExpression(PopOperand()' NodeType.Pop)); goto done;            case OpCode.Jmp: expr = this.ParseCall(NodeType.Jmp' out isStatement); if (isStatement) goto done; break;            case OpCode.Call: expr = this.ParseCall(NodeType.Call' out isStatement); if (isStatement) goto done; break;            case OpCode.Calli: expr = this.ParseCalli(out isStatement); if (isStatement) goto done; break;            case OpCode.Ret:              Expression retVal = BodyParser.TypeIsVoid(this.method.ReturnType) ? null : PopOperand();              statement = new Return(retVal);               transferStatement = true; goto done;            case OpCode.Br_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false); transferStatement = true; goto done;            case OpCode.Brfalse_S: statement = this.ParseBranch(NodeType.LogicalNot' 1' true' false); transferStatement = true; goto done;            case OpCode.Brtrue_S: statement = this.ParseBranch(NodeType.Nop' 1' true' false); transferStatement = true; goto done;            case OpCode.Beq_S: statement = this.ParseBranch(NodeType.Eq' 2' true' false); transferStatement = true; goto done;            case OpCode.Bge_S: statement = this.ParseBranch(NodeType.Ge' 2' true' false); transferStatement = true; goto done;            case OpCode.Bgt_S: statement = this.ParseBranch(NodeType.Gt' 2' true' false); transferStatement = true; goto done;            case OpCode.Ble_S: statement = this.ParseBranch(NodeType.Le' 2' true' false); transferStatement = true; goto done;            case OpCode.Blt_S: statement = this.ParseBranch(NodeType.Lt' 2' true' false); transferStatement = true; goto done;            case OpCode.Bne_Un_S: statement = this.ParseBranch(NodeType.Ne' 2' true' true); transferStatement = true; goto done;            case OpCode.Bge_Un_S: statement = this.ParseBranch(NodeType.Ge' 2' true' true); transferStatement = true; goto done;            case OpCode.Bgt_Un_S: statement = this.ParseBranch(NodeType.Gt' 2' true' true); transferStatement = true; goto done;            case OpCode.Ble_Un_S: statement = this.ParseBranch(NodeType.Le' 2' true' true); transferStatement = true; goto done;            case OpCode.Blt_Un_S: statement = this.ParseBranch(NodeType.Lt' 2' true' true); transferStatement = true; goto done;            case OpCode.Br: statement = this.ParseBranch(NodeType.Nop' 0' false' false); transferStatement = true; goto done;            case OpCode.Brfalse: statement = this.ParseBranch(NodeType.LogicalNot' 1' false' false); transferStatement = true; goto done;            case OpCode.Brtrue: statement = this.ParseBranch(NodeType.Nop' 1' false' false); transferStatement = true; goto done;            case OpCode.Beq: statement = this.ParseBranch(NodeType.Eq' 2' false' false); transferStatement = true; goto done;            case OpCode.Bge: statement = this.ParseBranch(NodeType.Ge' 2' false' false); transferStatement = true; goto done;            case OpCode.Bgt: statement = this.ParseBranch(NodeType.Gt' 2' false' false); transferStatement = true; goto done;            case OpCode.Ble: statement = this.ParseBranch(NodeType.Le' 2' false' false); transferStatement = true; goto done;            case OpCode.Blt: statement = this.ParseBranch(NodeType.Lt' 2' false' false); transferStatement = true; goto done;            case OpCode.Bne_Un: statement = this.ParseBranch(NodeType.Ne' 2' false' true); transferStatement = true; goto done;            case OpCode.Bge_Un: statement = this.ParseBranch(NodeType.Ge' 2' false' true); transferStatement = true; goto done;            case OpCode.Bgt_Un: statement = this.ParseBranch(NodeType.Gt' 2' false' true); transferStatement = true; goto done;            case OpCode.Ble_Un: statement = this.ParseBranch(NodeType.Le' 2' false' true); transferStatement = true; goto done;            case OpCode.Blt_Un: statement = this.ParseBranch(NodeType.Lt' 2' false' true); transferStatement = true; goto done;            case OpCode.Switch: statement = this.ParseSwitchInstruction(); transferStatement = true; goto done;            case OpCode.Ldind_I1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int64' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I: expr = new AddressDereference(PopOperand()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Single' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Double' this.isVolatile' this.alignment); break;            case OpCode.Ldind_Ref: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Object' this.isVolatile' this.alignment); break;            case OpCode.Stind_Ref: statement = this.ParseStoreIndirect(CoreSystemTypes.Object); goto done;            case OpCode.Stind_I1: statement = this.ParseStoreIndirect(CoreSystemTypes.Int8); goto done;            case OpCode.Stind_I2: statement = this.ParseStoreIndirect(CoreSystemTypes.Int16); goto done;            case OpCode.Stind_I4: statement = this.ParseStoreIndirect(CoreSystemTypes.Int32); goto done;            case OpCode.Stind_I8: statement = this.ParseStoreIndirect(CoreSystemTypes.Int64); goto done;            case OpCode.Stind_R4: statement = this.ParseStoreIndirect(CoreSystemTypes.Single); goto done;            case OpCode.Stind_R8: statement = this.ParseStoreIndirect(CoreSystemTypes.Double); goto done;            case OpCode.Add: expr = this.ParseBinaryOperation(NodeType.Add); break;            case OpCode.Sub: expr = this.ParseBinaryOperation(NodeType.Sub); break;            case OpCode.Mul: expr = this.ParseBinaryOperation(NodeType.Mul); break;            case OpCode.Div: expr = this.ParseBinaryOperation(NodeType.Div); break;            case OpCode.Div_Un: expr = this.ParseBinaryOperation(NodeType.Div_Un); break;            case OpCode.Rem: expr = this.ParseBinaryOperation(NodeType.Rem); break;            case OpCode.Rem_Un: expr = this.ParseBinaryOperation(NodeType.Rem_Un); break;            case OpCode.And: expr = this.ParseBinaryOperation(NodeType.And); break;            case OpCode.Or: expr = this.ParseBinaryOperation(NodeType.Or); break;            case OpCode.Xor: expr = this.ParseBinaryOperation(NodeType.Xor); break;            case OpCode.Shl: expr = this.ParseBinaryOperation(NodeType.Shl); break;            case OpCode.Shr: expr = this.ParseBinaryOperation(NodeType.Shr); break;            case OpCode.Shr_Un: expr = this.ParseBinaryOperation(NodeType.Shr_Un); break;            case OpCode.Neg: expr = this.ParseUnaryOperation(NodeType.Neg); break;            case OpCode.Not: expr = this.ParseUnaryOperation(NodeType.Not); break;            case OpCode.Conv_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_R4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R4' CoreSystemTypes.Single); break;            case OpCode.Conv_R8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R8' CoreSystemTypes.Double); break;            case OpCode.Conv_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U8' CoreSystemTypes.UInt64); break;            case OpCode.Callvirt: expr = this.ParseCall(NodeType.Callvirt' out isStatement); if (isStatement) goto done; break;            case OpCode.Cpobj: statement = this.ParseCopyObject(); goto done;            case OpCode.Ldobj: expr = new AddressDereference(PopOperand()' (TypeNode)this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldstr: expr = new Literal(this.GetStringFromToken()' CoreSystemTypes.String); break;            case OpCode.Newobj: expr = this.ParseConstruct(); break;            case OpCode.Castclass: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Castclass); break;            case OpCode.Isinst: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Isinst); break;            case OpCode.Conv_R_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R_Un' CoreSystemTypes.Double); break;            case OpCode.Unbox: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Unbox); break;            case OpCode.Throw: statement = new Throw(PopOperand()); transferStatement = true; goto done;            case OpCode.Ldfld:               expr = new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment);              break;            case OpCode.Ldflda:               expr = SetType(new UnaryExpression(new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf));               break;            case OpCode.Stfld: statement = this.ParseStoreField(); goto done;            case OpCode.Ldsfld: expr = new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldsflda: expr = SetType(new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf)); break;            case OpCode.Stsfld: statement = new AssignmentStatement(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' PopOperand()); goto done;            case OpCode.Stobj: statement = this.ParseStoreIndirect((TypeNode)this.GetMemberFromToken()); goto done;            case OpCode.Conv_Ovf_I1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_I2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_I4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_I8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_U2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_U4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_U8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64); break;            case OpCode.Conv_Ovf_I_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr); break;            case OpCode.Box:               TypeNode t = (TypeNode)this.GetMemberFromToken();              TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;              expr = new BinaryExpression(PopOperand()' new Literal(t' CoreSystemTypes.Type)' NodeType.Box' bt); break;            case OpCode.Newarr: expr = this.ParseNewArray(); break;            case OpCode.Ldlen: expr = new UnaryExpression(PopOperand()' NodeType.Ldlen' CoreSystemTypes.UIntPtr); break;            case OpCode.Ldelema: expr = this.ParseArrayElementLoadAddress(); break;            case OpCode.Ldelem_I1:             case OpCode.Ldelem_U1:             case OpCode.Ldelem_I2:             case OpCode.Ldelem_U2:             case OpCode.Ldelem_I4:             case OpCode.Ldelem_U4:             case OpCode.Ldelem_I8:             case OpCode.Ldelem_I:             case OpCode.Ldelem_R4:             case OpCode.Ldelem_R8:             case OpCode.Ldelem_Ref: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem_I:            case OpCode.Stelem_I1:            case OpCode.Stelem_I2:            case OpCode.Stelem_I4:            case OpCode.Stelem_I8:            case OpCode.Stelem_R4:            case OpCode.Stelem_R8:            case OpCode.Stelem_Ref: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Ldelem: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Unbox_Any: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.UnboxAny); break;            case OpCode.Conv_Ovf_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64); break;            case OpCode.Refanyval: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr); break;            case OpCode.Ckfinite: expr = this.ParseUnaryOperation(NodeType.Ckfinite); break;            case OpCode.Mkrefany: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference); break;            case OpCode.Ldtoken: expr = ParseLoadRuntimeMetadataToken(); break;            case OpCode.Conv_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Add_Ovf: expr = this.ParseBinaryOperation(NodeType.Add_Ovf); break;            case OpCode.Add_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Add_Ovf_Un); break;            case OpCode.Mul_Ovf: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf); break;            case OpCode.Mul_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf_Un); break;            case OpCode.Sub_Ovf: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf); break;            case OpCode.Sub_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf_Un); break;            case OpCode.Endfinally: statement = new EndFinally(); transferStatement = true; goto done;            case OpCode.Leave: statement = this.ParseBranch(NodeType.Nop' 0' false' false' true); transferStatement = true; goto done;            case OpCode.Leave_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false' true); transferStatement = true; goto done;            case OpCode.Stind_I: statement = this.ParseStoreIndirect(CoreSystemTypes.IntPtr); goto done;            case OpCode.Conv_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Arglist: expr = new Expression(NodeType.Arglist' CoreSystemTypes.ArgIterator); break;            case OpCode.Ceq: expr = this.ParseBinaryComparison(NodeType.Ceq); break;            case OpCode.Cgt: expr = this.ParseBinaryComparison(NodeType.Cgt); break;            case OpCode.Cgt_Un: expr = this.ParseBinaryComparison(NodeType.Cgt_Un); break;            case OpCode.Clt: expr = this.ParseBinaryComparison(NodeType.Clt); break;            case OpCode.Clt_Un: expr = this.ParseBinaryComparison(NodeType.Clt_Un); break;            case OpCode.Ldftn: expr = new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldvirtftn: expr = new BinaryExpression(PopOperand()' new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldarg: expr = this.Parameters((ushort)this.GetInt16()); break;            case OpCode.Ldarga: expr = SetType(new UnaryExpression(this.Parameters((ushort)this.GetInt16())' NodeType.AddressOf)); break;            case OpCode.Starg: statement = new AssignmentStatement(this.Parameters((ushort)this.GetInt16())' PopOperand()); goto done;            case OpCode.Ldloc: expr = this.locals[(ushort)this.GetInt16()]; break;            case OpCode.Ldloca: expr = SetType(new UnaryExpression(this.locals[(ushort)this.GetInt16()]' NodeType.AddressOf)); break;            case OpCode.Stloc: statement = new AssignmentStatement(this.locals[(ushort)this.GetInt16()]' PopOperand()); goto done;            case OpCode.Localloc: expr = new UnaryExpression(PopOperand()' NodeType.Localloc' CoreSystemTypes.Void); break;            case OpCode.Endfilter: statement = new EndFilter(PopOperand()); transferStatement = true; goto done;            case OpCode.Unaligned_: this.alignment = this.GetByte(); continue;            case OpCode.Volatile_: this.isVolatile = true; continue;            case OpCode.Tail_: this.isTailCall = true; continue;            case OpCode.Initobj: statement = this.ParseInitObject(); goto done;            case OpCode.Constrained_: this.constraint = this.GetMemberFromToken() as TypeNode; continue;            case OpCode.Cpblk: expr = this.ParseTernaryOperation(NodeType.Cpblk); goto done;            case OpCode.Initblk: expr = this.ParseTernaryOperation(NodeType.Initblk); goto done;            case OpCode.Rethrow: statement = new Throw(null); statement.NodeType = NodeType.Rethrow; transferStatement = true; goto done;            case OpCode.Sizeof: expr = new UnaryExpression(new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32); break;            case OpCode.Refanytype: expr = new UnaryExpression(PopOperand()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle); break;            case OpCode.Readonly_: this.isReadOnly = true; continue;            default: throw new InvalidMetadataException(ExceptionStrings.UnknownOpCode);          }          if (this.blockMap[this.counter+1] != null){            transferStatement = true; //Falls through to the next basic block' so implicitly a "transfer" statement            goto done;          }          //^ assume expr != null;  #if FxCop          expr.sourceContext = sourceContext;  #endif  #if FxCop || ILOFFSETS          expr.ILOffset = this.ilOffset;  #endif          this.operandStack.Push(expr);          this.isReadOnly = false;          this.isVolatile = false;          this.isTailCall = false;                  this.alignment = -1;        }
Magic Number,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true){          bool isStatement = false;          startingAddress = this.counter+1; //Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  #if FxCop || ILOFFSETS          this.ilOffset = this.counter;          this.opCode = this.GetOpCode();  #else          OpCode opCode = this.GetOpCode();  #endif  #if FxCop          if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){            expr.sourceContext = sourceContext;            expr.ILOffset = this.ilOffset;            this.operandStack.Push(expr);          }  #endif          switch (opCode){            case OpCode.Nop: statement = new Statement(NodeType.Nop); goto done;            case OpCode.Break: statement = new Statement(NodeType.DebugBreak); goto done;            case OpCode.Ldarg_0: expr = this.Parameters(0); break;            case OpCode.Ldarg_1: expr = this.Parameters(1); break;            case OpCode.Ldarg_2: expr = this.Parameters(2); break;            case OpCode.Ldarg_3: expr = this.Parameters(3); break;            case OpCode.Ldloc_0: expr = this.locals[0]; break;            case OpCode.Ldloc_1: expr = this.locals[1]; break;            case OpCode.Ldloc_2: expr = this.locals[2]; break;            case OpCode.Ldloc_3: expr = this.locals[3]; break;            case OpCode.Stloc_0: statement = new AssignmentStatement(this.locals[0]' PopOperand()); goto done;            case OpCode.Stloc_1: statement = new AssignmentStatement(this.locals[1]' PopOperand()); goto done;            case OpCode.Stloc_2: statement = new AssignmentStatement(this.locals[2]' PopOperand()); goto done;            case OpCode.Stloc_3: statement = new AssignmentStatement(this.locals[3]' PopOperand()); goto done;            case OpCode.Ldarg_S: expr = this.Parameters(this.GetByte()); break;            case OpCode.Ldarga_S: expr = SetType(new UnaryExpression(this.Parameters(this.GetByte())' NodeType.AddressOf)); break;            case OpCode.Starg_S: statement = new AssignmentStatement(this.Parameters(this.GetByte())' PopOperand()); goto done;            case OpCode.Ldloc_S: expr = this.locals[this.GetByte()]; break;            case OpCode.Ldloca_S: expr = SetType(new UnaryExpression(this.locals[this.GetByte()]' NodeType.AddressOf)); break;            case OpCode.Stloc_S: statement = new AssignmentStatement(this.locals[this.GetByte()]' PopOperand()); goto done;            case OpCode.Ldnull: expr = new Literal(null' CoreSystemTypes.Object); break;            case OpCode.Ldc_I4_M1: expr = new Literal(-1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_0: expr = new Literal(0' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_1: expr = new Literal(1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_2: expr = new Literal(2' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_3: expr = new Literal(3' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_4: expr = new Literal(4' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_5: expr = new Literal(5' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_6: expr = new Literal(6' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_7: expr = new Literal(7' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_8: expr = new Literal(8' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_S: expr = new Literal((int)this.GetSByte()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4: expr = new Literal(this.GetInt32()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I8: expr = new Literal(this.GetInt64()' CoreSystemTypes.Int64); break;            case OpCode.Ldc_R4: expr = new Literal(this.GetSingle()' CoreSystemTypes.Single); break;            case OpCode.Ldc_R8: expr = new Literal(this.GetDouble()' CoreSystemTypes.Double); break;            case OpCode.Dup: statement = new ExpressionStatement(new Expression(NodeType.Dup)); goto done;            case OpCode.Pop: statement = new ExpressionStatement(new UnaryExpression(PopOperand()' NodeType.Pop)); goto done;            case OpCode.Jmp: expr = this.ParseCall(NodeType.Jmp' out isStatement); if (isStatement) goto done; break;            case OpCode.Call: expr = this.ParseCall(NodeType.Call' out isStatement); if (isStatement) goto done; break;            case OpCode.Calli: expr = this.ParseCalli(out isStatement); if (isStatement) goto done; break;            case OpCode.Ret:              Expression retVal = BodyParser.TypeIsVoid(this.method.ReturnType) ? null : PopOperand();              statement = new Return(retVal);               transferStatement = true; goto done;            case OpCode.Br_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false); transferStatement = true; goto done;            case OpCode.Brfalse_S: statement = this.ParseBranch(NodeType.LogicalNot' 1' true' false); transferStatement = true; goto done;            case OpCode.Brtrue_S: statement = this.ParseBranch(NodeType.Nop' 1' true' false); transferStatement = true; goto done;            case OpCode.Beq_S: statement = this.ParseBranch(NodeType.Eq' 2' true' false); transferStatement = true; goto done;            case OpCode.Bge_S: statement = this.ParseBranch(NodeType.Ge' 2' true' false); transferStatement = true; goto done;            case OpCode.Bgt_S: statement = this.ParseBranch(NodeType.Gt' 2' true' false); transferStatement = true; goto done;            case OpCode.Ble_S: statement = this.ParseBranch(NodeType.Le' 2' true' false); transferStatement = true; goto done;            case OpCode.Blt_S: statement = this.ParseBranch(NodeType.Lt' 2' true' false); transferStatement = true; goto done;            case OpCode.Bne_Un_S: statement = this.ParseBranch(NodeType.Ne' 2' true' true); transferStatement = true; goto done;            case OpCode.Bge_Un_S: statement = this.ParseBranch(NodeType.Ge' 2' true' true); transferStatement = true; goto done;            case OpCode.Bgt_Un_S: statement = this.ParseBranch(NodeType.Gt' 2' true' true); transferStatement = true; goto done;            case OpCode.Ble_Un_S: statement = this.ParseBranch(NodeType.Le' 2' true' true); transferStatement = true; goto done;            case OpCode.Blt_Un_S: statement = this.ParseBranch(NodeType.Lt' 2' true' true); transferStatement = true; goto done;            case OpCode.Br: statement = this.ParseBranch(NodeType.Nop' 0' false' false); transferStatement = true; goto done;            case OpCode.Brfalse: statement = this.ParseBranch(NodeType.LogicalNot' 1' false' false); transferStatement = true; goto done;            case OpCode.Brtrue: statement = this.ParseBranch(NodeType.Nop' 1' false' false); transferStatement = true; goto done;            case OpCode.Beq: statement = this.ParseBranch(NodeType.Eq' 2' false' false); transferStatement = true; goto done;            case OpCode.Bge: statement = this.ParseBranch(NodeType.Ge' 2' false' false); transferStatement = true; goto done;            case OpCode.Bgt: statement = this.ParseBranch(NodeType.Gt' 2' false' false); transferStatement = true; goto done;            case OpCode.Ble: statement = this.ParseBranch(NodeType.Le' 2' false' false); transferStatement = true; goto done;            case OpCode.Blt: statement = this.ParseBranch(NodeType.Lt' 2' false' false); transferStatement = true; goto done;            case OpCode.Bne_Un: statement = this.ParseBranch(NodeType.Ne' 2' false' true); transferStatement = true; goto done;            case OpCode.Bge_Un: statement = this.ParseBranch(NodeType.Ge' 2' false' true); transferStatement = true; goto done;            case OpCode.Bgt_Un: statement = this.ParseBranch(NodeType.Gt' 2' false' true); transferStatement = true; goto done;            case OpCode.Ble_Un: statement = this.ParseBranch(NodeType.Le' 2' false' true); transferStatement = true; goto done;            case OpCode.Blt_Un: statement = this.ParseBranch(NodeType.Lt' 2' false' true); transferStatement = true; goto done;            case OpCode.Switch: statement = this.ParseSwitchInstruction(); transferStatement = true; goto done;            case OpCode.Ldind_I1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int64' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I: expr = new AddressDereference(PopOperand()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Single' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Double' this.isVolatile' this.alignment); break;            case OpCode.Ldind_Ref: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Object' this.isVolatile' this.alignment); break;            case OpCode.Stind_Ref: statement = this.ParseStoreIndirect(CoreSystemTypes.Object); goto done;            case OpCode.Stind_I1: statement = this.ParseStoreIndirect(CoreSystemTypes.Int8); goto done;            case OpCode.Stind_I2: statement = this.ParseStoreIndirect(CoreSystemTypes.Int16); goto done;            case OpCode.Stind_I4: statement = this.ParseStoreIndirect(CoreSystemTypes.Int32); goto done;            case OpCode.Stind_I8: statement = this.ParseStoreIndirect(CoreSystemTypes.Int64); goto done;            case OpCode.Stind_R4: statement = this.ParseStoreIndirect(CoreSystemTypes.Single); goto done;            case OpCode.Stind_R8: statement = this.ParseStoreIndirect(CoreSystemTypes.Double); goto done;            case OpCode.Add: expr = this.ParseBinaryOperation(NodeType.Add); break;            case OpCode.Sub: expr = this.ParseBinaryOperation(NodeType.Sub); break;            case OpCode.Mul: expr = this.ParseBinaryOperation(NodeType.Mul); break;            case OpCode.Div: expr = this.ParseBinaryOperation(NodeType.Div); break;            case OpCode.Div_Un: expr = this.ParseBinaryOperation(NodeType.Div_Un); break;            case OpCode.Rem: expr = this.ParseBinaryOperation(NodeType.Rem); break;            case OpCode.Rem_Un: expr = this.ParseBinaryOperation(NodeType.Rem_Un); break;            case OpCode.And: expr = this.ParseBinaryOperation(NodeType.And); break;            case OpCode.Or: expr = this.ParseBinaryOperation(NodeType.Or); break;            case OpCode.Xor: expr = this.ParseBinaryOperation(NodeType.Xor); break;            case OpCode.Shl: expr = this.ParseBinaryOperation(NodeType.Shl); break;            case OpCode.Shr: expr = this.ParseBinaryOperation(NodeType.Shr); break;            case OpCode.Shr_Un: expr = this.ParseBinaryOperation(NodeType.Shr_Un); break;            case OpCode.Neg: expr = this.ParseUnaryOperation(NodeType.Neg); break;            case OpCode.Not: expr = this.ParseUnaryOperation(NodeType.Not); break;            case OpCode.Conv_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_R4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R4' CoreSystemTypes.Single); break;            case OpCode.Conv_R8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R8' CoreSystemTypes.Double); break;            case OpCode.Conv_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U8' CoreSystemTypes.UInt64); break;            case OpCode.Callvirt: expr = this.ParseCall(NodeType.Callvirt' out isStatement); if (isStatement) goto done; break;            case OpCode.Cpobj: statement = this.ParseCopyObject(); goto done;            case OpCode.Ldobj: expr = new AddressDereference(PopOperand()' (TypeNode)this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldstr: expr = new Literal(this.GetStringFromToken()' CoreSystemTypes.String); break;            case OpCode.Newobj: expr = this.ParseConstruct(); break;            case OpCode.Castclass: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Castclass); break;            case OpCode.Isinst: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Isinst); break;            case OpCode.Conv_R_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R_Un' CoreSystemTypes.Double); break;            case OpCode.Unbox: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Unbox); break;            case OpCode.Throw: statement = new Throw(PopOperand()); transferStatement = true; goto done;            case OpCode.Ldfld:               expr = new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment);              break;            case OpCode.Ldflda:               expr = SetType(new UnaryExpression(new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf));               break;            case OpCode.Stfld: statement = this.ParseStoreField(); goto done;            case OpCode.Ldsfld: expr = new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldsflda: expr = SetType(new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf)); break;            case OpCode.Stsfld: statement = new AssignmentStatement(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' PopOperand()); goto done;            case OpCode.Stobj: statement = this.ParseStoreIndirect((TypeNode)this.GetMemberFromToken()); goto done;            case OpCode.Conv_Ovf_I1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_I2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_I4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_I8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_U2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_U4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_U8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64); break;            case OpCode.Conv_Ovf_I_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr); break;            case OpCode.Box:               TypeNode t = (TypeNode)this.GetMemberFromToken();              TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;              expr = new BinaryExpression(PopOperand()' new Literal(t' CoreSystemTypes.Type)' NodeType.Box' bt); break;            case OpCode.Newarr: expr = this.ParseNewArray(); break;            case OpCode.Ldlen: expr = new UnaryExpression(PopOperand()' NodeType.Ldlen' CoreSystemTypes.UIntPtr); break;            case OpCode.Ldelema: expr = this.ParseArrayElementLoadAddress(); break;            case OpCode.Ldelem_I1:             case OpCode.Ldelem_U1:             case OpCode.Ldelem_I2:             case OpCode.Ldelem_U2:             case OpCode.Ldelem_I4:             case OpCode.Ldelem_U4:             case OpCode.Ldelem_I8:             case OpCode.Ldelem_I:             case OpCode.Ldelem_R4:             case OpCode.Ldelem_R8:             case OpCode.Ldelem_Ref: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem_I:            case OpCode.Stelem_I1:            case OpCode.Stelem_I2:            case OpCode.Stelem_I4:            case OpCode.Stelem_I8:            case OpCode.Stelem_R4:            case OpCode.Stelem_R8:            case OpCode.Stelem_Ref: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Ldelem: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Unbox_Any: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.UnboxAny); break;            case OpCode.Conv_Ovf_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64); break;            case OpCode.Refanyval: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr); break;            case OpCode.Ckfinite: expr = this.ParseUnaryOperation(NodeType.Ckfinite); break;            case OpCode.Mkrefany: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference); break;            case OpCode.Ldtoken: expr = ParseLoadRuntimeMetadataToken(); break;            case OpCode.Conv_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Add_Ovf: expr = this.ParseBinaryOperation(NodeType.Add_Ovf); break;            case OpCode.Add_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Add_Ovf_Un); break;            case OpCode.Mul_Ovf: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf); break;            case OpCode.Mul_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf_Un); break;            case OpCode.Sub_Ovf: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf); break;            case OpCode.Sub_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf_Un); break;            case OpCode.Endfinally: statement = new EndFinally(); transferStatement = true; goto done;            case OpCode.Leave: statement = this.ParseBranch(NodeType.Nop' 0' false' false' true); transferStatement = true; goto done;            case OpCode.Leave_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false' true); transferStatement = true; goto done;            case OpCode.Stind_I: statement = this.ParseStoreIndirect(CoreSystemTypes.IntPtr); goto done;            case OpCode.Conv_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Arglist: expr = new Expression(NodeType.Arglist' CoreSystemTypes.ArgIterator); break;            case OpCode.Ceq: expr = this.ParseBinaryComparison(NodeType.Ceq); break;            case OpCode.Cgt: expr = this.ParseBinaryComparison(NodeType.Cgt); break;            case OpCode.Cgt_Un: expr = this.ParseBinaryComparison(NodeType.Cgt_Un); break;            case OpCode.Clt: expr = this.ParseBinaryComparison(NodeType.Clt); break;            case OpCode.Clt_Un: expr = this.ParseBinaryComparison(NodeType.Clt_Un); break;            case OpCode.Ldftn: expr = new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldvirtftn: expr = new BinaryExpression(PopOperand()' new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldarg: expr = this.Parameters((ushort)this.GetInt16()); break;            case OpCode.Ldarga: expr = SetType(new UnaryExpression(this.Parameters((ushort)this.GetInt16())' NodeType.AddressOf)); break;            case OpCode.Starg: statement = new AssignmentStatement(this.Parameters((ushort)this.GetInt16())' PopOperand()); goto done;            case OpCode.Ldloc: expr = this.locals[(ushort)this.GetInt16()]; break;            case OpCode.Ldloca: expr = SetType(new UnaryExpression(this.locals[(ushort)this.GetInt16()]' NodeType.AddressOf)); break;            case OpCode.Stloc: statement = new AssignmentStatement(this.locals[(ushort)this.GetInt16()]' PopOperand()); goto done;            case OpCode.Localloc: expr = new UnaryExpression(PopOperand()' NodeType.Localloc' CoreSystemTypes.Void); break;            case OpCode.Endfilter: statement = new EndFilter(PopOperand()); transferStatement = true; goto done;            case OpCode.Unaligned_: this.alignment = this.GetByte(); continue;            case OpCode.Volatile_: this.isVolatile = true; continue;            case OpCode.Tail_: this.isTailCall = true; continue;            case OpCode.Initobj: statement = this.ParseInitObject(); goto done;            case OpCode.Constrained_: this.constraint = this.GetMemberFromToken() as TypeNode; continue;            case OpCode.Cpblk: expr = this.ParseTernaryOperation(NodeType.Cpblk); goto done;            case OpCode.Initblk: expr = this.ParseTernaryOperation(NodeType.Initblk); goto done;            case OpCode.Rethrow: statement = new Throw(null); statement.NodeType = NodeType.Rethrow; transferStatement = true; goto done;            case OpCode.Sizeof: expr = new UnaryExpression(new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32); break;            case OpCode.Refanytype: expr = new UnaryExpression(PopOperand()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle); break;            case OpCode.Readonly_: this.isReadOnly = true; continue;            default: throw new InvalidMetadataException(ExceptionStrings.UnknownOpCode);          }          if (this.blockMap[this.counter+1] != null){            transferStatement = true; //Falls through to the next basic block' so implicitly a "transfer" statement            goto done;          }          //^ assume expr != null;  #if FxCop          expr.sourceContext = sourceContext;  #endif  #if FxCop || ILOFFSETS          expr.ILOffset = this.ilOffset;  #endif          this.operandStack.Push(expr);          this.isReadOnly = false;          this.isVolatile = false;          this.isTailCall = false;                  this.alignment = -1;        }
Magic Number,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true){          bool isStatement = false;          startingAddress = this.counter+1; //Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  #if FxCop || ILOFFSETS          this.ilOffset = this.counter;          this.opCode = this.GetOpCode();  #else          OpCode opCode = this.GetOpCode();  #endif  #if FxCop          if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){            expr.sourceContext = sourceContext;            expr.ILOffset = this.ilOffset;            this.operandStack.Push(expr);          }  #endif          switch (opCode){            case OpCode.Nop: statement = new Statement(NodeType.Nop); goto done;            case OpCode.Break: statement = new Statement(NodeType.DebugBreak); goto done;            case OpCode.Ldarg_0: expr = this.Parameters(0); break;            case OpCode.Ldarg_1: expr = this.Parameters(1); break;            case OpCode.Ldarg_2: expr = this.Parameters(2); break;            case OpCode.Ldarg_3: expr = this.Parameters(3); break;            case OpCode.Ldloc_0: expr = this.locals[0]; break;            case OpCode.Ldloc_1: expr = this.locals[1]; break;            case OpCode.Ldloc_2: expr = this.locals[2]; break;            case OpCode.Ldloc_3: expr = this.locals[3]; break;            case OpCode.Stloc_0: statement = new AssignmentStatement(this.locals[0]' PopOperand()); goto done;            case OpCode.Stloc_1: statement = new AssignmentStatement(this.locals[1]' PopOperand()); goto done;            case OpCode.Stloc_2: statement = new AssignmentStatement(this.locals[2]' PopOperand()); goto done;            case OpCode.Stloc_3: statement = new AssignmentStatement(this.locals[3]' PopOperand()); goto done;            case OpCode.Ldarg_S: expr = this.Parameters(this.GetByte()); break;            case OpCode.Ldarga_S: expr = SetType(new UnaryExpression(this.Parameters(this.GetByte())' NodeType.AddressOf)); break;            case OpCode.Starg_S: statement = new AssignmentStatement(this.Parameters(this.GetByte())' PopOperand()); goto done;            case OpCode.Ldloc_S: expr = this.locals[this.GetByte()]; break;            case OpCode.Ldloca_S: expr = SetType(new UnaryExpression(this.locals[this.GetByte()]' NodeType.AddressOf)); break;            case OpCode.Stloc_S: statement = new AssignmentStatement(this.locals[this.GetByte()]' PopOperand()); goto done;            case OpCode.Ldnull: expr = new Literal(null' CoreSystemTypes.Object); break;            case OpCode.Ldc_I4_M1: expr = new Literal(-1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_0: expr = new Literal(0' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_1: expr = new Literal(1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_2: expr = new Literal(2' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_3: expr = new Literal(3' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_4: expr = new Literal(4' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_5: expr = new Literal(5' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_6: expr = new Literal(6' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_7: expr = new Literal(7' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_8: expr = new Literal(8' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_S: expr = new Literal((int)this.GetSByte()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4: expr = new Literal(this.GetInt32()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I8: expr = new Literal(this.GetInt64()' CoreSystemTypes.Int64); break;            case OpCode.Ldc_R4: expr = new Literal(this.GetSingle()' CoreSystemTypes.Single); break;            case OpCode.Ldc_R8: expr = new Literal(this.GetDouble()' CoreSystemTypes.Double); break;            case OpCode.Dup: statement = new ExpressionStatement(new Expression(NodeType.Dup)); goto done;            case OpCode.Pop: statement = new ExpressionStatement(new UnaryExpression(PopOperand()' NodeType.Pop)); goto done;            case OpCode.Jmp: expr = this.ParseCall(NodeType.Jmp' out isStatement); if (isStatement) goto done; break;            case OpCode.Call: expr = this.ParseCall(NodeType.Call' out isStatement); if (isStatement) goto done; break;            case OpCode.Calli: expr = this.ParseCalli(out isStatement); if (isStatement) goto done; break;            case OpCode.Ret:              Expression retVal = BodyParser.TypeIsVoid(this.method.ReturnType) ? null : PopOperand();              statement = new Return(retVal);               transferStatement = true; goto done;            case OpCode.Br_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false); transferStatement = true; goto done;            case OpCode.Brfalse_S: statement = this.ParseBranch(NodeType.LogicalNot' 1' true' false); transferStatement = true; goto done;            case OpCode.Brtrue_S: statement = this.ParseBranch(NodeType.Nop' 1' true' false); transferStatement = true; goto done;            case OpCode.Beq_S: statement = this.ParseBranch(NodeType.Eq' 2' true' false); transferStatement = true; goto done;            case OpCode.Bge_S: statement = this.ParseBranch(NodeType.Ge' 2' true' false); transferStatement = true; goto done;            case OpCode.Bgt_S: statement = this.ParseBranch(NodeType.Gt' 2' true' false); transferStatement = true; goto done;            case OpCode.Ble_S: statement = this.ParseBranch(NodeType.Le' 2' true' false); transferStatement = true; goto done;            case OpCode.Blt_S: statement = this.ParseBranch(NodeType.Lt' 2' true' false); transferStatement = true; goto done;            case OpCode.Bne_Un_S: statement = this.ParseBranch(NodeType.Ne' 2' true' true); transferStatement = true; goto done;            case OpCode.Bge_Un_S: statement = this.ParseBranch(NodeType.Ge' 2' true' true); transferStatement = true; goto done;            case OpCode.Bgt_Un_S: statement = this.ParseBranch(NodeType.Gt' 2' true' true); transferStatement = true; goto done;            case OpCode.Ble_Un_S: statement = this.ParseBranch(NodeType.Le' 2' true' true); transferStatement = true; goto done;            case OpCode.Blt_Un_S: statement = this.ParseBranch(NodeType.Lt' 2' true' true); transferStatement = true; goto done;            case OpCode.Br: statement = this.ParseBranch(NodeType.Nop' 0' false' false); transferStatement = true; goto done;            case OpCode.Brfalse: statement = this.ParseBranch(NodeType.LogicalNot' 1' false' false); transferStatement = true; goto done;            case OpCode.Brtrue: statement = this.ParseBranch(NodeType.Nop' 1' false' false); transferStatement = true; goto done;            case OpCode.Beq: statement = this.ParseBranch(NodeType.Eq' 2' false' false); transferStatement = true; goto done;            case OpCode.Bge: statement = this.ParseBranch(NodeType.Ge' 2' false' false); transferStatement = true; goto done;            case OpCode.Bgt: statement = this.ParseBranch(NodeType.Gt' 2' false' false); transferStatement = true; goto done;            case OpCode.Ble: statement = this.ParseBranch(NodeType.Le' 2' false' false); transferStatement = true; goto done;            case OpCode.Blt: statement = this.ParseBranch(NodeType.Lt' 2' false' false); transferStatement = true; goto done;            case OpCode.Bne_Un: statement = this.ParseBranch(NodeType.Ne' 2' false' true); transferStatement = true; goto done;            case OpCode.Bge_Un: statement = this.ParseBranch(NodeType.Ge' 2' false' true); transferStatement = true; goto done;            case OpCode.Bgt_Un: statement = this.ParseBranch(NodeType.Gt' 2' false' true); transferStatement = true; goto done;            case OpCode.Ble_Un: statement = this.ParseBranch(NodeType.Le' 2' false' true); transferStatement = true; goto done;            case OpCode.Blt_Un: statement = this.ParseBranch(NodeType.Lt' 2' false' true); transferStatement = true; goto done;            case OpCode.Switch: statement = this.ParseSwitchInstruction(); transferStatement = true; goto done;            case OpCode.Ldind_I1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int64' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I: expr = new AddressDereference(PopOperand()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Single' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Double' this.isVolatile' this.alignment); break;            case OpCode.Ldind_Ref: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Object' this.isVolatile' this.alignment); break;            case OpCode.Stind_Ref: statement = this.ParseStoreIndirect(CoreSystemTypes.Object); goto done;            case OpCode.Stind_I1: statement = this.ParseStoreIndirect(CoreSystemTypes.Int8); goto done;            case OpCode.Stind_I2: statement = this.ParseStoreIndirect(CoreSystemTypes.Int16); goto done;            case OpCode.Stind_I4: statement = this.ParseStoreIndirect(CoreSystemTypes.Int32); goto done;            case OpCode.Stind_I8: statement = this.ParseStoreIndirect(CoreSystemTypes.Int64); goto done;            case OpCode.Stind_R4: statement = this.ParseStoreIndirect(CoreSystemTypes.Single); goto done;            case OpCode.Stind_R8: statement = this.ParseStoreIndirect(CoreSystemTypes.Double); goto done;            case OpCode.Add: expr = this.ParseBinaryOperation(NodeType.Add); break;            case OpCode.Sub: expr = this.ParseBinaryOperation(NodeType.Sub); break;            case OpCode.Mul: expr = this.ParseBinaryOperation(NodeType.Mul); break;            case OpCode.Div: expr = this.ParseBinaryOperation(NodeType.Div); break;            case OpCode.Div_Un: expr = this.ParseBinaryOperation(NodeType.Div_Un); break;            case OpCode.Rem: expr = this.ParseBinaryOperation(NodeType.Rem); break;            case OpCode.Rem_Un: expr = this.ParseBinaryOperation(NodeType.Rem_Un); break;            case OpCode.And: expr = this.ParseBinaryOperation(NodeType.And); break;            case OpCode.Or: expr = this.ParseBinaryOperation(NodeType.Or); break;            case OpCode.Xor: expr = this.ParseBinaryOperation(NodeType.Xor); break;            case OpCode.Shl: expr = this.ParseBinaryOperation(NodeType.Shl); break;            case OpCode.Shr: expr = this.ParseBinaryOperation(NodeType.Shr); break;            case OpCode.Shr_Un: expr = this.ParseBinaryOperation(NodeType.Shr_Un); break;            case OpCode.Neg: expr = this.ParseUnaryOperation(NodeType.Neg); break;            case OpCode.Not: expr = this.ParseUnaryOperation(NodeType.Not); break;            case OpCode.Conv_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_R4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R4' CoreSystemTypes.Single); break;            case OpCode.Conv_R8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R8' CoreSystemTypes.Double); break;            case OpCode.Conv_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U8' CoreSystemTypes.UInt64); break;            case OpCode.Callvirt: expr = this.ParseCall(NodeType.Callvirt' out isStatement); if (isStatement) goto done; break;            case OpCode.Cpobj: statement = this.ParseCopyObject(); goto done;            case OpCode.Ldobj: expr = new AddressDereference(PopOperand()' (TypeNode)this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldstr: expr = new Literal(this.GetStringFromToken()' CoreSystemTypes.String); break;            case OpCode.Newobj: expr = this.ParseConstruct(); break;            case OpCode.Castclass: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Castclass); break;            case OpCode.Isinst: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Isinst); break;            case OpCode.Conv_R_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R_Un' CoreSystemTypes.Double); break;            case OpCode.Unbox: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Unbox); break;            case OpCode.Throw: statement = new Throw(PopOperand()); transferStatement = true; goto done;            case OpCode.Ldfld:               expr = new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment);              break;            case OpCode.Ldflda:               expr = SetType(new UnaryExpression(new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf));               break;            case OpCode.Stfld: statement = this.ParseStoreField(); goto done;            case OpCode.Ldsfld: expr = new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldsflda: expr = SetType(new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf)); break;            case OpCode.Stsfld: statement = new AssignmentStatement(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' PopOperand()); goto done;            case OpCode.Stobj: statement = this.ParseStoreIndirect((TypeNode)this.GetMemberFromToken()); goto done;            case OpCode.Conv_Ovf_I1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_I2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_I4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_I8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_U2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_U4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_U8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64); break;            case OpCode.Conv_Ovf_I_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr); break;            case OpCode.Box:               TypeNode t = (TypeNode)this.GetMemberFromToken();              TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;              expr = new BinaryExpression(PopOperand()' new Literal(t' CoreSystemTypes.Type)' NodeType.Box' bt); break;            case OpCode.Newarr: expr = this.ParseNewArray(); break;            case OpCode.Ldlen: expr = new UnaryExpression(PopOperand()' NodeType.Ldlen' CoreSystemTypes.UIntPtr); break;            case OpCode.Ldelema: expr = this.ParseArrayElementLoadAddress(); break;            case OpCode.Ldelem_I1:             case OpCode.Ldelem_U1:             case OpCode.Ldelem_I2:             case OpCode.Ldelem_U2:             case OpCode.Ldelem_I4:             case OpCode.Ldelem_U4:             case OpCode.Ldelem_I8:             case OpCode.Ldelem_I:             case OpCode.Ldelem_R4:             case OpCode.Ldelem_R8:             case OpCode.Ldelem_Ref: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem_I:            case OpCode.Stelem_I1:            case OpCode.Stelem_I2:            case OpCode.Stelem_I4:            case OpCode.Stelem_I8:            case OpCode.Stelem_R4:            case OpCode.Stelem_R8:            case OpCode.Stelem_Ref: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Ldelem: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Unbox_Any: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.UnboxAny); break;            case OpCode.Conv_Ovf_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64); break;            case OpCode.Refanyval: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr); break;            case OpCode.Ckfinite: expr = this.ParseUnaryOperation(NodeType.Ckfinite); break;            case OpCode.Mkrefany: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference); break;            case OpCode.Ldtoken: expr = ParseLoadRuntimeMetadataToken(); break;            case OpCode.Conv_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Add_Ovf: expr = this.ParseBinaryOperation(NodeType.Add_Ovf); break;            case OpCode.Add_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Add_Ovf_Un); break;            case OpCode.Mul_Ovf: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf); break;            case OpCode.Mul_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf_Un); break;            case OpCode.Sub_Ovf: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf); break;            case OpCode.Sub_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf_Un); break;            case OpCode.Endfinally: statement = new EndFinally(); transferStatement = true; goto done;            case OpCode.Leave: statement = this.ParseBranch(NodeType.Nop' 0' false' false' true); transferStatement = true; goto done;            case OpCode.Leave_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false' true); transferStatement = true; goto done;            case OpCode.Stind_I: statement = this.ParseStoreIndirect(CoreSystemTypes.IntPtr); goto done;            case OpCode.Conv_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Arglist: expr = new Expression(NodeType.Arglist' CoreSystemTypes.ArgIterator); break;            case OpCode.Ceq: expr = this.ParseBinaryComparison(NodeType.Ceq); break;            case OpCode.Cgt: expr = this.ParseBinaryComparison(NodeType.Cgt); break;            case OpCode.Cgt_Un: expr = this.ParseBinaryComparison(NodeType.Cgt_Un); break;            case OpCode.Clt: expr = this.ParseBinaryComparison(NodeType.Clt); break;            case OpCode.Clt_Un: expr = this.ParseBinaryComparison(NodeType.Clt_Un); break;            case OpCode.Ldftn: expr = new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldvirtftn: expr = new BinaryExpression(PopOperand()' new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldarg: expr = this.Parameters((ushort)this.GetInt16()); break;            case OpCode.Ldarga: expr = SetType(new UnaryExpression(this.Parameters((ushort)this.GetInt16())' NodeType.AddressOf)); break;            case OpCode.Starg: statement = new AssignmentStatement(this.Parameters((ushort)this.GetInt16())' PopOperand()); goto done;            case OpCode.Ldloc: expr = this.locals[(ushort)this.GetInt16()]; break;            case OpCode.Ldloca: expr = SetType(new UnaryExpression(this.locals[(ushort)this.GetInt16()]' NodeType.AddressOf)); break;            case OpCode.Stloc: statement = new AssignmentStatement(this.locals[(ushort)this.GetInt16()]' PopOperand()); goto done;            case OpCode.Localloc: expr = new UnaryExpression(PopOperand()' NodeType.Localloc' CoreSystemTypes.Void); break;            case OpCode.Endfilter: statement = new EndFilter(PopOperand()); transferStatement = true; goto done;            case OpCode.Unaligned_: this.alignment = this.GetByte(); continue;            case OpCode.Volatile_: this.isVolatile = true; continue;            case OpCode.Tail_: this.isTailCall = true; continue;            case OpCode.Initobj: statement = this.ParseInitObject(); goto done;            case OpCode.Constrained_: this.constraint = this.GetMemberFromToken() as TypeNode; continue;            case OpCode.Cpblk: expr = this.ParseTernaryOperation(NodeType.Cpblk); goto done;            case OpCode.Initblk: expr = this.ParseTernaryOperation(NodeType.Initblk); goto done;            case OpCode.Rethrow: statement = new Throw(null); statement.NodeType = NodeType.Rethrow; transferStatement = true; goto done;            case OpCode.Sizeof: expr = new UnaryExpression(new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32); break;            case OpCode.Refanytype: expr = new UnaryExpression(PopOperand()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle); break;            case OpCode.Readonly_: this.isReadOnly = true; continue;            default: throw new InvalidMetadataException(ExceptionStrings.UnknownOpCode);          }          if (this.blockMap[this.counter+1] != null){            transferStatement = true; //Falls through to the next basic block' so implicitly a "transfer" statement            goto done;          }          //^ assume expr != null;  #if FxCop          expr.sourceContext = sourceContext;  #endif  #if FxCop || ILOFFSETS          expr.ILOffset = this.ilOffset;  #endif          this.operandStack.Push(expr);          this.isReadOnly = false;          this.isVolatile = false;          this.isTailCall = false;                  this.alignment = -1;        }
Magic Number,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true){          bool isStatement = false;          startingAddress = this.counter+1; //Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  #if FxCop || ILOFFSETS          this.ilOffset = this.counter;          this.opCode = this.GetOpCode();  #else          OpCode opCode = this.GetOpCode();  #endif  #if FxCop          if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){            expr.sourceContext = sourceContext;            expr.ILOffset = this.ilOffset;            this.operandStack.Push(expr);          }  #endif          switch (opCode){            case OpCode.Nop: statement = new Statement(NodeType.Nop); goto done;            case OpCode.Break: statement = new Statement(NodeType.DebugBreak); goto done;            case OpCode.Ldarg_0: expr = this.Parameters(0); break;            case OpCode.Ldarg_1: expr = this.Parameters(1); break;            case OpCode.Ldarg_2: expr = this.Parameters(2); break;            case OpCode.Ldarg_3: expr = this.Parameters(3); break;            case OpCode.Ldloc_0: expr = this.locals[0]; break;            case OpCode.Ldloc_1: expr = this.locals[1]; break;            case OpCode.Ldloc_2: expr = this.locals[2]; break;            case OpCode.Ldloc_3: expr = this.locals[3]; break;            case OpCode.Stloc_0: statement = new AssignmentStatement(this.locals[0]' PopOperand()); goto done;            case OpCode.Stloc_1: statement = new AssignmentStatement(this.locals[1]' PopOperand()); goto done;            case OpCode.Stloc_2: statement = new AssignmentStatement(this.locals[2]' PopOperand()); goto done;            case OpCode.Stloc_3: statement = new AssignmentStatement(this.locals[3]' PopOperand()); goto done;            case OpCode.Ldarg_S: expr = this.Parameters(this.GetByte()); break;            case OpCode.Ldarga_S: expr = SetType(new UnaryExpression(this.Parameters(this.GetByte())' NodeType.AddressOf)); break;            case OpCode.Starg_S: statement = new AssignmentStatement(this.Parameters(this.GetByte())' PopOperand()); goto done;            case OpCode.Ldloc_S: expr = this.locals[this.GetByte()]; break;            case OpCode.Ldloca_S: expr = SetType(new UnaryExpression(this.locals[this.GetByte()]' NodeType.AddressOf)); break;            case OpCode.Stloc_S: statement = new AssignmentStatement(this.locals[this.GetByte()]' PopOperand()); goto done;            case OpCode.Ldnull: expr = new Literal(null' CoreSystemTypes.Object); break;            case OpCode.Ldc_I4_M1: expr = new Literal(-1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_0: expr = new Literal(0' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_1: expr = new Literal(1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_2: expr = new Literal(2' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_3: expr = new Literal(3' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_4: expr = new Literal(4' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_5: expr = new Literal(5' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_6: expr = new Literal(6' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_7: expr = new Literal(7' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_8: expr = new Literal(8' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_S: expr = new Literal((int)this.GetSByte()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4: expr = new Literal(this.GetInt32()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I8: expr = new Literal(this.GetInt64()' CoreSystemTypes.Int64); break;            case OpCode.Ldc_R4: expr = new Literal(this.GetSingle()' CoreSystemTypes.Single); break;            case OpCode.Ldc_R8: expr = new Literal(this.GetDouble()' CoreSystemTypes.Double); break;            case OpCode.Dup: statement = new ExpressionStatement(new Expression(NodeType.Dup)); goto done;            case OpCode.Pop: statement = new ExpressionStatement(new UnaryExpression(PopOperand()' NodeType.Pop)); goto done;            case OpCode.Jmp: expr = this.ParseCall(NodeType.Jmp' out isStatement); if (isStatement) goto done; break;            case OpCode.Call: expr = this.ParseCall(NodeType.Call' out isStatement); if (isStatement) goto done; break;            case OpCode.Calli: expr = this.ParseCalli(out isStatement); if (isStatement) goto done; break;            case OpCode.Ret:              Expression retVal = BodyParser.TypeIsVoid(this.method.ReturnType) ? null : PopOperand();              statement = new Return(retVal);               transferStatement = true; goto done;            case OpCode.Br_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false); transferStatement = true; goto done;            case OpCode.Brfalse_S: statement = this.ParseBranch(NodeType.LogicalNot' 1' true' false); transferStatement = true; goto done;            case OpCode.Brtrue_S: statement = this.ParseBranch(NodeType.Nop' 1' true' false); transferStatement = true; goto done;            case OpCode.Beq_S: statement = this.ParseBranch(NodeType.Eq' 2' true' false); transferStatement = true; goto done;            case OpCode.Bge_S: statement = this.ParseBranch(NodeType.Ge' 2' true' false); transferStatement = true; goto done;            case OpCode.Bgt_S: statement = this.ParseBranch(NodeType.Gt' 2' true' false); transferStatement = true; goto done;            case OpCode.Ble_S: statement = this.ParseBranch(NodeType.Le' 2' true' false); transferStatement = true; goto done;            case OpCode.Blt_S: statement = this.ParseBranch(NodeType.Lt' 2' true' false); transferStatement = true; goto done;            case OpCode.Bne_Un_S: statement = this.ParseBranch(NodeType.Ne' 2' true' true); transferStatement = true; goto done;            case OpCode.Bge_Un_S: statement = this.ParseBranch(NodeType.Ge' 2' true' true); transferStatement = true; goto done;            case OpCode.Bgt_Un_S: statement = this.ParseBranch(NodeType.Gt' 2' true' true); transferStatement = true; goto done;            case OpCode.Ble_Un_S: statement = this.ParseBranch(NodeType.Le' 2' true' true); transferStatement = true; goto done;            case OpCode.Blt_Un_S: statement = this.ParseBranch(NodeType.Lt' 2' true' true); transferStatement = true; goto done;            case OpCode.Br: statement = this.ParseBranch(NodeType.Nop' 0' false' false); transferStatement = true; goto done;            case OpCode.Brfalse: statement = this.ParseBranch(NodeType.LogicalNot' 1' false' false); transferStatement = true; goto done;            case OpCode.Brtrue: statement = this.ParseBranch(NodeType.Nop' 1' false' false); transferStatement = true; goto done;            case OpCode.Beq: statement = this.ParseBranch(NodeType.Eq' 2' false' false); transferStatement = true; goto done;            case OpCode.Bge: statement = this.ParseBranch(NodeType.Ge' 2' false' false); transferStatement = true; goto done;            case OpCode.Bgt: statement = this.ParseBranch(NodeType.Gt' 2' false' false); transferStatement = true; goto done;            case OpCode.Ble: statement = this.ParseBranch(NodeType.Le' 2' false' false); transferStatement = true; goto done;            case OpCode.Blt: statement = this.ParseBranch(NodeType.Lt' 2' false' false); transferStatement = true; goto done;            case OpCode.Bne_Un: statement = this.ParseBranch(NodeType.Ne' 2' false' true); transferStatement = true; goto done;            case OpCode.Bge_Un: statement = this.ParseBranch(NodeType.Ge' 2' false' true); transferStatement = true; goto done;            case OpCode.Bgt_Un: statement = this.ParseBranch(NodeType.Gt' 2' false' true); transferStatement = true; goto done;            case OpCode.Ble_Un: statement = this.ParseBranch(NodeType.Le' 2' false' true); transferStatement = true; goto done;            case OpCode.Blt_Un: statement = this.ParseBranch(NodeType.Lt' 2' false' true); transferStatement = true; goto done;            case OpCode.Switch: statement = this.ParseSwitchInstruction(); transferStatement = true; goto done;            case OpCode.Ldind_I1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int64' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I: expr = new AddressDereference(PopOperand()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Single' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Double' this.isVolatile' this.alignment); break;            case OpCode.Ldind_Ref: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Object' this.isVolatile' this.alignment); break;            case OpCode.Stind_Ref: statement = this.ParseStoreIndirect(CoreSystemTypes.Object); goto done;            case OpCode.Stind_I1: statement = this.ParseStoreIndirect(CoreSystemTypes.Int8); goto done;            case OpCode.Stind_I2: statement = this.ParseStoreIndirect(CoreSystemTypes.Int16); goto done;            case OpCode.Stind_I4: statement = this.ParseStoreIndirect(CoreSystemTypes.Int32); goto done;            case OpCode.Stind_I8: statement = this.ParseStoreIndirect(CoreSystemTypes.Int64); goto done;            case OpCode.Stind_R4: statement = this.ParseStoreIndirect(CoreSystemTypes.Single); goto done;            case OpCode.Stind_R8: statement = this.ParseStoreIndirect(CoreSystemTypes.Double); goto done;            case OpCode.Add: expr = this.ParseBinaryOperation(NodeType.Add); break;            case OpCode.Sub: expr = this.ParseBinaryOperation(NodeType.Sub); break;            case OpCode.Mul: expr = this.ParseBinaryOperation(NodeType.Mul); break;            case OpCode.Div: expr = this.ParseBinaryOperation(NodeType.Div); break;            case OpCode.Div_Un: expr = this.ParseBinaryOperation(NodeType.Div_Un); break;            case OpCode.Rem: expr = this.ParseBinaryOperation(NodeType.Rem); break;            case OpCode.Rem_Un: expr = this.ParseBinaryOperation(NodeType.Rem_Un); break;            case OpCode.And: expr = this.ParseBinaryOperation(NodeType.And); break;            case OpCode.Or: expr = this.ParseBinaryOperation(NodeType.Or); break;            case OpCode.Xor: expr = this.ParseBinaryOperation(NodeType.Xor); break;            case OpCode.Shl: expr = this.ParseBinaryOperation(NodeType.Shl); break;            case OpCode.Shr: expr = this.ParseBinaryOperation(NodeType.Shr); break;            case OpCode.Shr_Un: expr = this.ParseBinaryOperation(NodeType.Shr_Un); break;            case OpCode.Neg: expr = this.ParseUnaryOperation(NodeType.Neg); break;            case OpCode.Not: expr = this.ParseUnaryOperation(NodeType.Not); break;            case OpCode.Conv_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_R4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R4' CoreSystemTypes.Single); break;            case OpCode.Conv_R8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R8' CoreSystemTypes.Double); break;            case OpCode.Conv_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U8' CoreSystemTypes.UInt64); break;            case OpCode.Callvirt: expr = this.ParseCall(NodeType.Callvirt' out isStatement); if (isStatement) goto done; break;            case OpCode.Cpobj: statement = this.ParseCopyObject(); goto done;            case OpCode.Ldobj: expr = new AddressDereference(PopOperand()' (TypeNode)this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldstr: expr = new Literal(this.GetStringFromToken()' CoreSystemTypes.String); break;            case OpCode.Newobj: expr = this.ParseConstruct(); break;            case OpCode.Castclass: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Castclass); break;            case OpCode.Isinst: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Isinst); break;            case OpCode.Conv_R_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R_Un' CoreSystemTypes.Double); break;            case OpCode.Unbox: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Unbox); break;            case OpCode.Throw: statement = new Throw(PopOperand()); transferStatement = true; goto done;            case OpCode.Ldfld:               expr = new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment);              break;            case OpCode.Ldflda:               expr = SetType(new UnaryExpression(new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf));               break;            case OpCode.Stfld: statement = this.ParseStoreField(); goto done;            case OpCode.Ldsfld: expr = new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldsflda: expr = SetType(new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf)); break;            case OpCode.Stsfld: statement = new AssignmentStatement(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' PopOperand()); goto done;            case OpCode.Stobj: statement = this.ParseStoreIndirect((TypeNode)this.GetMemberFromToken()); goto done;            case OpCode.Conv_Ovf_I1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_I2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_I4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_I8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_U2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_U4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_U8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64); break;            case OpCode.Conv_Ovf_I_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr); break;            case OpCode.Box:               TypeNode t = (TypeNode)this.GetMemberFromToken();              TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;              expr = new BinaryExpression(PopOperand()' new Literal(t' CoreSystemTypes.Type)' NodeType.Box' bt); break;            case OpCode.Newarr: expr = this.ParseNewArray(); break;            case OpCode.Ldlen: expr = new UnaryExpression(PopOperand()' NodeType.Ldlen' CoreSystemTypes.UIntPtr); break;            case OpCode.Ldelema: expr = this.ParseArrayElementLoadAddress(); break;            case OpCode.Ldelem_I1:             case OpCode.Ldelem_U1:             case OpCode.Ldelem_I2:             case OpCode.Ldelem_U2:             case OpCode.Ldelem_I4:             case OpCode.Ldelem_U4:             case OpCode.Ldelem_I8:             case OpCode.Ldelem_I:             case OpCode.Ldelem_R4:             case OpCode.Ldelem_R8:             case OpCode.Ldelem_Ref: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem_I:            case OpCode.Stelem_I1:            case OpCode.Stelem_I2:            case OpCode.Stelem_I4:            case OpCode.Stelem_I8:            case OpCode.Stelem_R4:            case OpCode.Stelem_R8:            case OpCode.Stelem_Ref: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Ldelem: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Unbox_Any: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.UnboxAny); break;            case OpCode.Conv_Ovf_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64); break;            case OpCode.Refanyval: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr); break;            case OpCode.Ckfinite: expr = this.ParseUnaryOperation(NodeType.Ckfinite); break;            case OpCode.Mkrefany: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference); break;            case OpCode.Ldtoken: expr = ParseLoadRuntimeMetadataToken(); break;            case OpCode.Conv_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Add_Ovf: expr = this.ParseBinaryOperation(NodeType.Add_Ovf); break;            case OpCode.Add_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Add_Ovf_Un); break;            case OpCode.Mul_Ovf: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf); break;            case OpCode.Mul_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf_Un); break;            case OpCode.Sub_Ovf: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf); break;            case OpCode.Sub_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf_Un); break;            case OpCode.Endfinally: statement = new EndFinally(); transferStatement = true; goto done;            case OpCode.Leave: statement = this.ParseBranch(NodeType.Nop' 0' false' false' true); transferStatement = true; goto done;            case OpCode.Leave_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false' true); transferStatement = true; goto done;            case OpCode.Stind_I: statement = this.ParseStoreIndirect(CoreSystemTypes.IntPtr); goto done;            case OpCode.Conv_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Arglist: expr = new Expression(NodeType.Arglist' CoreSystemTypes.ArgIterator); break;            case OpCode.Ceq: expr = this.ParseBinaryComparison(NodeType.Ceq); break;            case OpCode.Cgt: expr = this.ParseBinaryComparison(NodeType.Cgt); break;            case OpCode.Cgt_Un: expr = this.ParseBinaryComparison(NodeType.Cgt_Un); break;            case OpCode.Clt: expr = this.ParseBinaryComparison(NodeType.Clt); break;            case OpCode.Clt_Un: expr = this.ParseBinaryComparison(NodeType.Clt_Un); break;            case OpCode.Ldftn: expr = new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldvirtftn: expr = new BinaryExpression(PopOperand()' new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldarg: expr = this.Parameters((ushort)this.GetInt16()); break;            case OpCode.Ldarga: expr = SetType(new UnaryExpression(this.Parameters((ushort)this.GetInt16())' NodeType.AddressOf)); break;            case OpCode.Starg: statement = new AssignmentStatement(this.Parameters((ushort)this.GetInt16())' PopOperand()); goto done;            case OpCode.Ldloc: expr = this.locals[(ushort)this.GetInt16()]; break;            case OpCode.Ldloca: expr = SetType(new UnaryExpression(this.locals[(ushort)this.GetInt16()]' NodeType.AddressOf)); break;            case OpCode.Stloc: statement = new AssignmentStatement(this.locals[(ushort)this.GetInt16()]' PopOperand()); goto done;            case OpCode.Localloc: expr = new UnaryExpression(PopOperand()' NodeType.Localloc' CoreSystemTypes.Void); break;            case OpCode.Endfilter: statement = new EndFilter(PopOperand()); transferStatement = true; goto done;            case OpCode.Unaligned_: this.alignment = this.GetByte(); continue;            case OpCode.Volatile_: this.isVolatile = true; continue;            case OpCode.Tail_: this.isTailCall = true; continue;            case OpCode.Initobj: statement = this.ParseInitObject(); goto done;            case OpCode.Constrained_: this.constraint = this.GetMemberFromToken() as TypeNode; continue;            case OpCode.Cpblk: expr = this.ParseTernaryOperation(NodeType.Cpblk); goto done;            case OpCode.Initblk: expr = this.ParseTernaryOperation(NodeType.Initblk); goto done;            case OpCode.Rethrow: statement = new Throw(null); statement.NodeType = NodeType.Rethrow; transferStatement = true; goto done;            case OpCode.Sizeof: expr = new UnaryExpression(new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32); break;            case OpCode.Refanytype: expr = new UnaryExpression(PopOperand()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle); break;            case OpCode.Readonly_: this.isReadOnly = true; continue;            default: throw new InvalidMetadataException(ExceptionStrings.UnknownOpCode);          }          if (this.blockMap[this.counter+1] != null){            transferStatement = true; //Falls through to the next basic block' so implicitly a "transfer" statement            goto done;          }          //^ assume expr != null;  #if FxCop          expr.sourceContext = sourceContext;  #endif  #if FxCop || ILOFFSETS          expr.ILOffset = this.ilOffset;  #endif          this.operandStack.Push(expr);          this.isReadOnly = false;          this.isVolatile = false;          this.isTailCall = false;                  this.alignment = -1;        }
Magic Number,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true){          bool isStatement = false;          startingAddress = this.counter+1; //Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  #if FxCop || ILOFFSETS          this.ilOffset = this.counter;          this.opCode = this.GetOpCode();  #else          OpCode opCode = this.GetOpCode();  #endif  #if FxCop          if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){            expr.sourceContext = sourceContext;            expr.ILOffset = this.ilOffset;            this.operandStack.Push(expr);          }  #endif          switch (opCode){            case OpCode.Nop: statement = new Statement(NodeType.Nop); goto done;            case OpCode.Break: statement = new Statement(NodeType.DebugBreak); goto done;            case OpCode.Ldarg_0: expr = this.Parameters(0); break;            case OpCode.Ldarg_1: expr = this.Parameters(1); break;            case OpCode.Ldarg_2: expr = this.Parameters(2); break;            case OpCode.Ldarg_3: expr = this.Parameters(3); break;            case OpCode.Ldloc_0: expr = this.locals[0]; break;            case OpCode.Ldloc_1: expr = this.locals[1]; break;            case OpCode.Ldloc_2: expr = this.locals[2]; break;            case OpCode.Ldloc_3: expr = this.locals[3]; break;            case OpCode.Stloc_0: statement = new AssignmentStatement(this.locals[0]' PopOperand()); goto done;            case OpCode.Stloc_1: statement = new AssignmentStatement(this.locals[1]' PopOperand()); goto done;            case OpCode.Stloc_2: statement = new AssignmentStatement(this.locals[2]' PopOperand()); goto done;            case OpCode.Stloc_3: statement = new AssignmentStatement(this.locals[3]' PopOperand()); goto done;            case OpCode.Ldarg_S: expr = this.Parameters(this.GetByte()); break;            case OpCode.Ldarga_S: expr = SetType(new UnaryExpression(this.Parameters(this.GetByte())' NodeType.AddressOf)); break;            case OpCode.Starg_S: statement = new AssignmentStatement(this.Parameters(this.GetByte())' PopOperand()); goto done;            case OpCode.Ldloc_S: expr = this.locals[this.GetByte()]; break;            case OpCode.Ldloca_S: expr = SetType(new UnaryExpression(this.locals[this.GetByte()]' NodeType.AddressOf)); break;            case OpCode.Stloc_S: statement = new AssignmentStatement(this.locals[this.GetByte()]' PopOperand()); goto done;            case OpCode.Ldnull: expr = new Literal(null' CoreSystemTypes.Object); break;            case OpCode.Ldc_I4_M1: expr = new Literal(-1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_0: expr = new Literal(0' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_1: expr = new Literal(1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_2: expr = new Literal(2' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_3: expr = new Literal(3' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_4: expr = new Literal(4' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_5: expr = new Literal(5' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_6: expr = new Literal(6' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_7: expr = new Literal(7' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_8: expr = new Literal(8' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_S: expr = new Literal((int)this.GetSByte()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4: expr = new Literal(this.GetInt32()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I8: expr = new Literal(this.GetInt64()' CoreSystemTypes.Int64); break;            case OpCode.Ldc_R4: expr = new Literal(this.GetSingle()' CoreSystemTypes.Single); break;            case OpCode.Ldc_R8: expr = new Literal(this.GetDouble()' CoreSystemTypes.Double); break;            case OpCode.Dup: statement = new ExpressionStatement(new Expression(NodeType.Dup)); goto done;            case OpCode.Pop: statement = new ExpressionStatement(new UnaryExpression(PopOperand()' NodeType.Pop)); goto done;            case OpCode.Jmp: expr = this.ParseCall(NodeType.Jmp' out isStatement); if (isStatement) goto done; break;            case OpCode.Call: expr = this.ParseCall(NodeType.Call' out isStatement); if (isStatement) goto done; break;            case OpCode.Calli: expr = this.ParseCalli(out isStatement); if (isStatement) goto done; break;            case OpCode.Ret:              Expression retVal = BodyParser.TypeIsVoid(this.method.ReturnType) ? null : PopOperand();              statement = new Return(retVal);               transferStatement = true; goto done;            case OpCode.Br_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false); transferStatement = true; goto done;            case OpCode.Brfalse_S: statement = this.ParseBranch(NodeType.LogicalNot' 1' true' false); transferStatement = true; goto done;            case OpCode.Brtrue_S: statement = this.ParseBranch(NodeType.Nop' 1' true' false); transferStatement = true; goto done;            case OpCode.Beq_S: statement = this.ParseBranch(NodeType.Eq' 2' true' false); transferStatement = true; goto done;            case OpCode.Bge_S: statement = this.ParseBranch(NodeType.Ge' 2' true' false); transferStatement = true; goto done;            case OpCode.Bgt_S: statement = this.ParseBranch(NodeType.Gt' 2' true' false); transferStatement = true; goto done;            case OpCode.Ble_S: statement = this.ParseBranch(NodeType.Le' 2' true' false); transferStatement = true; goto done;            case OpCode.Blt_S: statement = this.ParseBranch(NodeType.Lt' 2' true' false); transferStatement = true; goto done;            case OpCode.Bne_Un_S: statement = this.ParseBranch(NodeType.Ne' 2' true' true); transferStatement = true; goto done;            case OpCode.Bge_Un_S: statement = this.ParseBranch(NodeType.Ge' 2' true' true); transferStatement = true; goto done;            case OpCode.Bgt_Un_S: statement = this.ParseBranch(NodeType.Gt' 2' true' true); transferStatement = true; goto done;            case OpCode.Ble_Un_S: statement = this.ParseBranch(NodeType.Le' 2' true' true); transferStatement = true; goto done;            case OpCode.Blt_Un_S: statement = this.ParseBranch(NodeType.Lt' 2' true' true); transferStatement = true; goto done;            case OpCode.Br: statement = this.ParseBranch(NodeType.Nop' 0' false' false); transferStatement = true; goto done;            case OpCode.Brfalse: statement = this.ParseBranch(NodeType.LogicalNot' 1' false' false); transferStatement = true; goto done;            case OpCode.Brtrue: statement = this.ParseBranch(NodeType.Nop' 1' false' false); transferStatement = true; goto done;            case OpCode.Beq: statement = this.ParseBranch(NodeType.Eq' 2' false' false); transferStatement = true; goto done;            case OpCode.Bge: statement = this.ParseBranch(NodeType.Ge' 2' false' false); transferStatement = true; goto done;            case OpCode.Bgt: statement = this.ParseBranch(NodeType.Gt' 2' false' false); transferStatement = true; goto done;            case OpCode.Ble: statement = this.ParseBranch(NodeType.Le' 2' false' false); transferStatement = true; goto done;            case OpCode.Blt: statement = this.ParseBranch(NodeType.Lt' 2' false' false); transferStatement = true; goto done;            case OpCode.Bne_Un: statement = this.ParseBranch(NodeType.Ne' 2' false' true); transferStatement = true; goto done;            case OpCode.Bge_Un: statement = this.ParseBranch(NodeType.Ge' 2' false' true); transferStatement = true; goto done;            case OpCode.Bgt_Un: statement = this.ParseBranch(NodeType.Gt' 2' false' true); transferStatement = true; goto done;            case OpCode.Ble_Un: statement = this.ParseBranch(NodeType.Le' 2' false' true); transferStatement = true; goto done;            case OpCode.Blt_Un: statement = this.ParseBranch(NodeType.Lt' 2' false' true); transferStatement = true; goto done;            case OpCode.Switch: statement = this.ParseSwitchInstruction(); transferStatement = true; goto done;            case OpCode.Ldind_I1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int64' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I: expr = new AddressDereference(PopOperand()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Single' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Double' this.isVolatile' this.alignment); break;            case OpCode.Ldind_Ref: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Object' this.isVolatile' this.alignment); break;            case OpCode.Stind_Ref: statement = this.ParseStoreIndirect(CoreSystemTypes.Object); goto done;            case OpCode.Stind_I1: statement = this.ParseStoreIndirect(CoreSystemTypes.Int8); goto done;            case OpCode.Stind_I2: statement = this.ParseStoreIndirect(CoreSystemTypes.Int16); goto done;            case OpCode.Stind_I4: statement = this.ParseStoreIndirect(CoreSystemTypes.Int32); goto done;            case OpCode.Stind_I8: statement = this.ParseStoreIndirect(CoreSystemTypes.Int64); goto done;            case OpCode.Stind_R4: statement = this.ParseStoreIndirect(CoreSystemTypes.Single); goto done;            case OpCode.Stind_R8: statement = this.ParseStoreIndirect(CoreSystemTypes.Double); goto done;            case OpCode.Add: expr = this.ParseBinaryOperation(NodeType.Add); break;            case OpCode.Sub: expr = this.ParseBinaryOperation(NodeType.Sub); break;            case OpCode.Mul: expr = this.ParseBinaryOperation(NodeType.Mul); break;            case OpCode.Div: expr = this.ParseBinaryOperation(NodeType.Div); break;            case OpCode.Div_Un: expr = this.ParseBinaryOperation(NodeType.Div_Un); break;            case OpCode.Rem: expr = this.ParseBinaryOperation(NodeType.Rem); break;            case OpCode.Rem_Un: expr = this.ParseBinaryOperation(NodeType.Rem_Un); break;            case OpCode.And: expr = this.ParseBinaryOperation(NodeType.And); break;            case OpCode.Or: expr = this.ParseBinaryOperation(NodeType.Or); break;            case OpCode.Xor: expr = this.ParseBinaryOperation(NodeType.Xor); break;            case OpCode.Shl: expr = this.ParseBinaryOperation(NodeType.Shl); break;            case OpCode.Shr: expr = this.ParseBinaryOperation(NodeType.Shr); break;            case OpCode.Shr_Un: expr = this.ParseBinaryOperation(NodeType.Shr_Un); break;            case OpCode.Neg: expr = this.ParseUnaryOperation(NodeType.Neg); break;            case OpCode.Not: expr = this.ParseUnaryOperation(NodeType.Not); break;            case OpCode.Conv_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_R4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R4' CoreSystemTypes.Single); break;            case OpCode.Conv_R8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R8' CoreSystemTypes.Double); break;            case OpCode.Conv_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U8' CoreSystemTypes.UInt64); break;            case OpCode.Callvirt: expr = this.ParseCall(NodeType.Callvirt' out isStatement); if (isStatement) goto done; break;            case OpCode.Cpobj: statement = this.ParseCopyObject(); goto done;            case OpCode.Ldobj: expr = new AddressDereference(PopOperand()' (TypeNode)this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldstr: expr = new Literal(this.GetStringFromToken()' CoreSystemTypes.String); break;            case OpCode.Newobj: expr = this.ParseConstruct(); break;            case OpCode.Castclass: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Castclass); break;            case OpCode.Isinst: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Isinst); break;            case OpCode.Conv_R_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R_Un' CoreSystemTypes.Double); break;            case OpCode.Unbox: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Unbox); break;            case OpCode.Throw: statement = new Throw(PopOperand()); transferStatement = true; goto done;            case OpCode.Ldfld:               expr = new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment);              break;            case OpCode.Ldflda:               expr = SetType(new UnaryExpression(new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf));               break;            case OpCode.Stfld: statement = this.ParseStoreField(); goto done;            case OpCode.Ldsfld: expr = new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldsflda: expr = SetType(new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf)); break;            case OpCode.Stsfld: statement = new AssignmentStatement(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' PopOperand()); goto done;            case OpCode.Stobj: statement = this.ParseStoreIndirect((TypeNode)this.GetMemberFromToken()); goto done;            case OpCode.Conv_Ovf_I1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_I2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_I4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_I8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_U2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_U4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_U8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64); break;            case OpCode.Conv_Ovf_I_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr); break;            case OpCode.Box:               TypeNode t = (TypeNode)this.GetMemberFromToken();              TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;              expr = new BinaryExpression(PopOperand()' new Literal(t' CoreSystemTypes.Type)' NodeType.Box' bt); break;            case OpCode.Newarr: expr = this.ParseNewArray(); break;            case OpCode.Ldlen: expr = new UnaryExpression(PopOperand()' NodeType.Ldlen' CoreSystemTypes.UIntPtr); break;            case OpCode.Ldelema: expr = this.ParseArrayElementLoadAddress(); break;            case OpCode.Ldelem_I1:             case OpCode.Ldelem_U1:             case OpCode.Ldelem_I2:             case OpCode.Ldelem_U2:             case OpCode.Ldelem_I4:             case OpCode.Ldelem_U4:             case OpCode.Ldelem_I8:             case OpCode.Ldelem_I:             case OpCode.Ldelem_R4:             case OpCode.Ldelem_R8:             case OpCode.Ldelem_Ref: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem_I:            case OpCode.Stelem_I1:            case OpCode.Stelem_I2:            case OpCode.Stelem_I4:            case OpCode.Stelem_I8:            case OpCode.Stelem_R4:            case OpCode.Stelem_R8:            case OpCode.Stelem_Ref: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Ldelem: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Unbox_Any: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.UnboxAny); break;            case OpCode.Conv_Ovf_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64); break;            case OpCode.Refanyval: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr); break;            case OpCode.Ckfinite: expr = this.ParseUnaryOperation(NodeType.Ckfinite); break;            case OpCode.Mkrefany: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference); break;            case OpCode.Ldtoken: expr = ParseLoadRuntimeMetadataToken(); break;            case OpCode.Conv_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Add_Ovf: expr = this.ParseBinaryOperation(NodeType.Add_Ovf); break;            case OpCode.Add_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Add_Ovf_Un); break;            case OpCode.Mul_Ovf: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf); break;            case OpCode.Mul_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf_Un); break;            case OpCode.Sub_Ovf: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf); break;            case OpCode.Sub_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf_Un); break;            case OpCode.Endfinally: statement = new EndFinally(); transferStatement = true; goto done;            case OpCode.Leave: statement = this.ParseBranch(NodeType.Nop' 0' false' false' true); transferStatement = true; goto done;            case OpCode.Leave_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false' true); transferStatement = true; goto done;            case OpCode.Stind_I: statement = this.ParseStoreIndirect(CoreSystemTypes.IntPtr); goto done;            case OpCode.Conv_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Arglist: expr = new Expression(NodeType.Arglist' CoreSystemTypes.ArgIterator); break;            case OpCode.Ceq: expr = this.ParseBinaryComparison(NodeType.Ceq); break;            case OpCode.Cgt: expr = this.ParseBinaryComparison(NodeType.Cgt); break;            case OpCode.Cgt_Un: expr = this.ParseBinaryComparison(NodeType.Cgt_Un); break;            case OpCode.Clt: expr = this.ParseBinaryComparison(NodeType.Clt); break;            case OpCode.Clt_Un: expr = this.ParseBinaryComparison(NodeType.Clt_Un); break;            case OpCode.Ldftn: expr = new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldvirtftn: expr = new BinaryExpression(PopOperand()' new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldarg: expr = this.Parameters((ushort)this.GetInt16()); break;            case OpCode.Ldarga: expr = SetType(new UnaryExpression(this.Parameters((ushort)this.GetInt16())' NodeType.AddressOf)); break;            case OpCode.Starg: statement = new AssignmentStatement(this.Parameters((ushort)this.GetInt16())' PopOperand()); goto done;            case OpCode.Ldloc: expr = this.locals[(ushort)this.GetInt16()]; break;            case OpCode.Ldloca: expr = SetType(new UnaryExpression(this.locals[(ushort)this.GetInt16()]' NodeType.AddressOf)); break;            case OpCode.Stloc: statement = new AssignmentStatement(this.locals[(ushort)this.GetInt16()]' PopOperand()); goto done;            case OpCode.Localloc: expr = new UnaryExpression(PopOperand()' NodeType.Localloc' CoreSystemTypes.Void); break;            case OpCode.Endfilter: statement = new EndFilter(PopOperand()); transferStatement = true; goto done;            case OpCode.Unaligned_: this.alignment = this.GetByte(); continue;            case OpCode.Volatile_: this.isVolatile = true; continue;            case OpCode.Tail_: this.isTailCall = true; continue;            case OpCode.Initobj: statement = this.ParseInitObject(); goto done;            case OpCode.Constrained_: this.constraint = this.GetMemberFromToken() as TypeNode; continue;            case OpCode.Cpblk: expr = this.ParseTernaryOperation(NodeType.Cpblk); goto done;            case OpCode.Initblk: expr = this.ParseTernaryOperation(NodeType.Initblk); goto done;            case OpCode.Rethrow: statement = new Throw(null); statement.NodeType = NodeType.Rethrow; transferStatement = true; goto done;            case OpCode.Sizeof: expr = new UnaryExpression(new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32); break;            case OpCode.Refanytype: expr = new UnaryExpression(PopOperand()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle); break;            case OpCode.Readonly_: this.isReadOnly = true; continue;            default: throw new InvalidMetadataException(ExceptionStrings.UnknownOpCode);          }          if (this.blockMap[this.counter+1] != null){            transferStatement = true; //Falls through to the next basic block' so implicitly a "transfer" statement            goto done;          }          //^ assume expr != null;  #if FxCop          expr.sourceContext = sourceContext;  #endif  #if FxCop || ILOFFSETS          expr.ILOffset = this.ilOffset;  #endif          this.operandStack.Push(expr);          this.isReadOnly = false;          this.isVolatile = false;          this.isTailCall = false;                  this.alignment = -1;        }
Magic Number,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true){          bool isStatement = false;          startingAddress = this.counter+1; //Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  #if FxCop || ILOFFSETS          this.ilOffset = this.counter;          this.opCode = this.GetOpCode();  #else          OpCode opCode = this.GetOpCode();  #endif  #if FxCop          if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){            expr.sourceContext = sourceContext;            expr.ILOffset = this.ilOffset;            this.operandStack.Push(expr);          }  #endif          switch (opCode){            case OpCode.Nop: statement = new Statement(NodeType.Nop); goto done;            case OpCode.Break: statement = new Statement(NodeType.DebugBreak); goto done;            case OpCode.Ldarg_0: expr = this.Parameters(0); break;            case OpCode.Ldarg_1: expr = this.Parameters(1); break;            case OpCode.Ldarg_2: expr = this.Parameters(2); break;            case OpCode.Ldarg_3: expr = this.Parameters(3); break;            case OpCode.Ldloc_0: expr = this.locals[0]; break;            case OpCode.Ldloc_1: expr = this.locals[1]; break;            case OpCode.Ldloc_2: expr = this.locals[2]; break;            case OpCode.Ldloc_3: expr = this.locals[3]; break;            case OpCode.Stloc_0: statement = new AssignmentStatement(this.locals[0]' PopOperand()); goto done;            case OpCode.Stloc_1: statement = new AssignmentStatement(this.locals[1]' PopOperand()); goto done;            case OpCode.Stloc_2: statement = new AssignmentStatement(this.locals[2]' PopOperand()); goto done;            case OpCode.Stloc_3: statement = new AssignmentStatement(this.locals[3]' PopOperand()); goto done;            case OpCode.Ldarg_S: expr = this.Parameters(this.GetByte()); break;            case OpCode.Ldarga_S: expr = SetType(new UnaryExpression(this.Parameters(this.GetByte())' NodeType.AddressOf)); break;            case OpCode.Starg_S: statement = new AssignmentStatement(this.Parameters(this.GetByte())' PopOperand()); goto done;            case OpCode.Ldloc_S: expr = this.locals[this.GetByte()]; break;            case OpCode.Ldloca_S: expr = SetType(new UnaryExpression(this.locals[this.GetByte()]' NodeType.AddressOf)); break;            case OpCode.Stloc_S: statement = new AssignmentStatement(this.locals[this.GetByte()]' PopOperand()); goto done;            case OpCode.Ldnull: expr = new Literal(null' CoreSystemTypes.Object); break;            case OpCode.Ldc_I4_M1: expr = new Literal(-1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_0: expr = new Literal(0' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_1: expr = new Literal(1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_2: expr = new Literal(2' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_3: expr = new Literal(3' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_4: expr = new Literal(4' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_5: expr = new Literal(5' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_6: expr = new Literal(6' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_7: expr = new Literal(7' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_8: expr = new Literal(8' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_S: expr = new Literal((int)this.GetSByte()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4: expr = new Literal(this.GetInt32()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I8: expr = new Literal(this.GetInt64()' CoreSystemTypes.Int64); break;            case OpCode.Ldc_R4: expr = new Literal(this.GetSingle()' CoreSystemTypes.Single); break;            case OpCode.Ldc_R8: expr = new Literal(this.GetDouble()' CoreSystemTypes.Double); break;            case OpCode.Dup: statement = new ExpressionStatement(new Expression(NodeType.Dup)); goto done;            case OpCode.Pop: statement = new ExpressionStatement(new UnaryExpression(PopOperand()' NodeType.Pop)); goto done;            case OpCode.Jmp: expr = this.ParseCall(NodeType.Jmp' out isStatement); if (isStatement) goto done; break;            case OpCode.Call: expr = this.ParseCall(NodeType.Call' out isStatement); if (isStatement) goto done; break;            case OpCode.Calli: expr = this.ParseCalli(out isStatement); if (isStatement) goto done; break;            case OpCode.Ret:              Expression retVal = BodyParser.TypeIsVoid(this.method.ReturnType) ? null : PopOperand();              statement = new Return(retVal);               transferStatement = true; goto done;            case OpCode.Br_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false); transferStatement = true; goto done;            case OpCode.Brfalse_S: statement = this.ParseBranch(NodeType.LogicalNot' 1' true' false); transferStatement = true; goto done;            case OpCode.Brtrue_S: statement = this.ParseBranch(NodeType.Nop' 1' true' false); transferStatement = true; goto done;            case OpCode.Beq_S: statement = this.ParseBranch(NodeType.Eq' 2' true' false); transferStatement = true; goto done;            case OpCode.Bge_S: statement = this.ParseBranch(NodeType.Ge' 2' true' false); transferStatement = true; goto done;            case OpCode.Bgt_S: statement = this.ParseBranch(NodeType.Gt' 2' true' false); transferStatement = true; goto done;            case OpCode.Ble_S: statement = this.ParseBranch(NodeType.Le' 2' true' false); transferStatement = true; goto done;            case OpCode.Blt_S: statement = this.ParseBranch(NodeType.Lt' 2' true' false); transferStatement = true; goto done;            case OpCode.Bne_Un_S: statement = this.ParseBranch(NodeType.Ne' 2' true' true); transferStatement = true; goto done;            case OpCode.Bge_Un_S: statement = this.ParseBranch(NodeType.Ge' 2' true' true); transferStatement = true; goto done;            case OpCode.Bgt_Un_S: statement = this.ParseBranch(NodeType.Gt' 2' true' true); transferStatement = true; goto done;            case OpCode.Ble_Un_S: statement = this.ParseBranch(NodeType.Le' 2' true' true); transferStatement = true; goto done;            case OpCode.Blt_Un_S: statement = this.ParseBranch(NodeType.Lt' 2' true' true); transferStatement = true; goto done;            case OpCode.Br: statement = this.ParseBranch(NodeType.Nop' 0' false' false); transferStatement = true; goto done;            case OpCode.Brfalse: statement = this.ParseBranch(NodeType.LogicalNot' 1' false' false); transferStatement = true; goto done;            case OpCode.Brtrue: statement = this.ParseBranch(NodeType.Nop' 1' false' false); transferStatement = true; goto done;            case OpCode.Beq: statement = this.ParseBranch(NodeType.Eq' 2' false' false); transferStatement = true; goto done;            case OpCode.Bge: statement = this.ParseBranch(NodeType.Ge' 2' false' false); transferStatement = true; goto done;            case OpCode.Bgt: statement = this.ParseBranch(NodeType.Gt' 2' false' false); transferStatement = true; goto done;            case OpCode.Ble: statement = this.ParseBranch(NodeType.Le' 2' false' false); transferStatement = true; goto done;            case OpCode.Blt: statement = this.ParseBranch(NodeType.Lt' 2' false' false); transferStatement = true; goto done;            case OpCode.Bne_Un: statement = this.ParseBranch(NodeType.Ne' 2' false' true); transferStatement = true; goto done;            case OpCode.Bge_Un: statement = this.ParseBranch(NodeType.Ge' 2' false' true); transferStatement = true; goto done;            case OpCode.Bgt_Un: statement = this.ParseBranch(NodeType.Gt' 2' false' true); transferStatement = true; goto done;            case OpCode.Ble_Un: statement = this.ParseBranch(NodeType.Le' 2' false' true); transferStatement = true; goto done;            case OpCode.Blt_Un: statement = this.ParseBranch(NodeType.Lt' 2' false' true); transferStatement = true; goto done;            case OpCode.Switch: statement = this.ParseSwitchInstruction(); transferStatement = true; goto done;            case OpCode.Ldind_I1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int64' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I: expr = new AddressDereference(PopOperand()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Single' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Double' this.isVolatile' this.alignment); break;            case OpCode.Ldind_Ref: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Object' this.isVolatile' this.alignment); break;            case OpCode.Stind_Ref: statement = this.ParseStoreIndirect(CoreSystemTypes.Object); goto done;            case OpCode.Stind_I1: statement = this.ParseStoreIndirect(CoreSystemTypes.Int8); goto done;            case OpCode.Stind_I2: statement = this.ParseStoreIndirect(CoreSystemTypes.Int16); goto done;            case OpCode.Stind_I4: statement = this.ParseStoreIndirect(CoreSystemTypes.Int32); goto done;            case OpCode.Stind_I8: statement = this.ParseStoreIndirect(CoreSystemTypes.Int64); goto done;            case OpCode.Stind_R4: statement = this.ParseStoreIndirect(CoreSystemTypes.Single); goto done;            case OpCode.Stind_R8: statement = this.ParseStoreIndirect(CoreSystemTypes.Double); goto done;            case OpCode.Add: expr = this.ParseBinaryOperation(NodeType.Add); break;            case OpCode.Sub: expr = this.ParseBinaryOperation(NodeType.Sub); break;            case OpCode.Mul: expr = this.ParseBinaryOperation(NodeType.Mul); break;            case OpCode.Div: expr = this.ParseBinaryOperation(NodeType.Div); break;            case OpCode.Div_Un: expr = this.ParseBinaryOperation(NodeType.Div_Un); break;            case OpCode.Rem: expr = this.ParseBinaryOperation(NodeType.Rem); break;            case OpCode.Rem_Un: expr = this.ParseBinaryOperation(NodeType.Rem_Un); break;            case OpCode.And: expr = this.ParseBinaryOperation(NodeType.And); break;            case OpCode.Or: expr = this.ParseBinaryOperation(NodeType.Or); break;            case OpCode.Xor: expr = this.ParseBinaryOperation(NodeType.Xor); break;            case OpCode.Shl: expr = this.ParseBinaryOperation(NodeType.Shl); break;            case OpCode.Shr: expr = this.ParseBinaryOperation(NodeType.Shr); break;            case OpCode.Shr_Un: expr = this.ParseBinaryOperation(NodeType.Shr_Un); break;            case OpCode.Neg: expr = this.ParseUnaryOperation(NodeType.Neg); break;            case OpCode.Not: expr = this.ParseUnaryOperation(NodeType.Not); break;            case OpCode.Conv_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_R4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R4' CoreSystemTypes.Single); break;            case OpCode.Conv_R8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R8' CoreSystemTypes.Double); break;            case OpCode.Conv_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U8' CoreSystemTypes.UInt64); break;            case OpCode.Callvirt: expr = this.ParseCall(NodeType.Callvirt' out isStatement); if (isStatement) goto done; break;            case OpCode.Cpobj: statement = this.ParseCopyObject(); goto done;            case OpCode.Ldobj: expr = new AddressDereference(PopOperand()' (TypeNode)this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldstr: expr = new Literal(this.GetStringFromToken()' CoreSystemTypes.String); break;            case OpCode.Newobj: expr = this.ParseConstruct(); break;            case OpCode.Castclass: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Castclass); break;            case OpCode.Isinst: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Isinst); break;            case OpCode.Conv_R_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R_Un' CoreSystemTypes.Double); break;            case OpCode.Unbox: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Unbox); break;            case OpCode.Throw: statement = new Throw(PopOperand()); transferStatement = true; goto done;            case OpCode.Ldfld:               expr = new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment);              break;            case OpCode.Ldflda:               expr = SetType(new UnaryExpression(new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf));               break;            case OpCode.Stfld: statement = this.ParseStoreField(); goto done;            case OpCode.Ldsfld: expr = new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldsflda: expr = SetType(new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf)); break;            case OpCode.Stsfld: statement = new AssignmentStatement(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' PopOperand()); goto done;            case OpCode.Stobj: statement = this.ParseStoreIndirect((TypeNode)this.GetMemberFromToken()); goto done;            case OpCode.Conv_Ovf_I1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_I2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_I4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_I8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_U2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_U4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_U8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64); break;            case OpCode.Conv_Ovf_I_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr); break;            case OpCode.Box:               TypeNode t = (TypeNode)this.GetMemberFromToken();              TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;              expr = new BinaryExpression(PopOperand()' new Literal(t' CoreSystemTypes.Type)' NodeType.Box' bt); break;            case OpCode.Newarr: expr = this.ParseNewArray(); break;            case OpCode.Ldlen: expr = new UnaryExpression(PopOperand()' NodeType.Ldlen' CoreSystemTypes.UIntPtr); break;            case OpCode.Ldelema: expr = this.ParseArrayElementLoadAddress(); break;            case OpCode.Ldelem_I1:             case OpCode.Ldelem_U1:             case OpCode.Ldelem_I2:             case OpCode.Ldelem_U2:             case OpCode.Ldelem_I4:             case OpCode.Ldelem_U4:             case OpCode.Ldelem_I8:             case OpCode.Ldelem_I:             case OpCode.Ldelem_R4:             case OpCode.Ldelem_R8:             case OpCode.Ldelem_Ref: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem_I:            case OpCode.Stelem_I1:            case OpCode.Stelem_I2:            case OpCode.Stelem_I4:            case OpCode.Stelem_I8:            case OpCode.Stelem_R4:            case OpCode.Stelem_R8:            case OpCode.Stelem_Ref: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Ldelem: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Unbox_Any: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.UnboxAny); break;            case OpCode.Conv_Ovf_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64); break;            case OpCode.Refanyval: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr); break;            case OpCode.Ckfinite: expr = this.ParseUnaryOperation(NodeType.Ckfinite); break;            case OpCode.Mkrefany: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference); break;            case OpCode.Ldtoken: expr = ParseLoadRuntimeMetadataToken(); break;            case OpCode.Conv_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Add_Ovf: expr = this.ParseBinaryOperation(NodeType.Add_Ovf); break;            case OpCode.Add_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Add_Ovf_Un); break;            case OpCode.Mul_Ovf: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf); break;            case OpCode.Mul_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf_Un); break;            case OpCode.Sub_Ovf: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf); break;            case OpCode.Sub_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf_Un); break;            case OpCode.Endfinally: statement = new EndFinally(); transferStatement = true; goto done;            case OpCode.Leave: statement = this.ParseBranch(NodeType.Nop' 0' false' false' true); transferStatement = true; goto done;            case OpCode.Leave_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false' true); transferStatement = true; goto done;            case OpCode.Stind_I: statement = this.ParseStoreIndirect(CoreSystemTypes.IntPtr); goto done;            case OpCode.Conv_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Arglist: expr = new Expression(NodeType.Arglist' CoreSystemTypes.ArgIterator); break;            case OpCode.Ceq: expr = this.ParseBinaryComparison(NodeType.Ceq); break;            case OpCode.Cgt: expr = this.ParseBinaryComparison(NodeType.Cgt); break;            case OpCode.Cgt_Un: expr = this.ParseBinaryComparison(NodeType.Cgt_Un); break;            case OpCode.Clt: expr = this.ParseBinaryComparison(NodeType.Clt); break;            case OpCode.Clt_Un: expr = this.ParseBinaryComparison(NodeType.Clt_Un); break;            case OpCode.Ldftn: expr = new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldvirtftn: expr = new BinaryExpression(PopOperand()' new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldarg: expr = this.Parameters((ushort)this.GetInt16()); break;            case OpCode.Ldarga: expr = SetType(new UnaryExpression(this.Parameters((ushort)this.GetInt16())' NodeType.AddressOf)); break;            case OpCode.Starg: statement = new AssignmentStatement(this.Parameters((ushort)this.GetInt16())' PopOperand()); goto done;            case OpCode.Ldloc: expr = this.locals[(ushort)this.GetInt16()]; break;            case OpCode.Ldloca: expr = SetType(new UnaryExpression(this.locals[(ushort)this.GetInt16()]' NodeType.AddressOf)); break;            case OpCode.Stloc: statement = new AssignmentStatement(this.locals[(ushort)this.GetInt16()]' PopOperand()); goto done;            case OpCode.Localloc: expr = new UnaryExpression(PopOperand()' NodeType.Localloc' CoreSystemTypes.Void); break;            case OpCode.Endfilter: statement = new EndFilter(PopOperand()); transferStatement = true; goto done;            case OpCode.Unaligned_: this.alignment = this.GetByte(); continue;            case OpCode.Volatile_: this.isVolatile = true; continue;            case OpCode.Tail_: this.isTailCall = true; continue;            case OpCode.Initobj: statement = this.ParseInitObject(); goto done;            case OpCode.Constrained_: this.constraint = this.GetMemberFromToken() as TypeNode; continue;            case OpCode.Cpblk: expr = this.ParseTernaryOperation(NodeType.Cpblk); goto done;            case OpCode.Initblk: expr = this.ParseTernaryOperation(NodeType.Initblk); goto done;            case OpCode.Rethrow: statement = new Throw(null); statement.NodeType = NodeType.Rethrow; transferStatement = true; goto done;            case OpCode.Sizeof: expr = new UnaryExpression(new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32); break;            case OpCode.Refanytype: expr = new UnaryExpression(PopOperand()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle); break;            case OpCode.Readonly_: this.isReadOnly = true; continue;            default: throw new InvalidMetadataException(ExceptionStrings.UnknownOpCode);          }          if (this.blockMap[this.counter+1] != null){            transferStatement = true; //Falls through to the next basic block' so implicitly a "transfer" statement            goto done;          }          //^ assume expr != null;  #if FxCop          expr.sourceContext = sourceContext;  #endif  #if FxCop || ILOFFSETS          expr.ILOffset = this.ilOffset;  #endif          this.operandStack.Push(expr);          this.isReadOnly = false;          this.isVolatile = false;          this.isTailCall = false;                  this.alignment = -1;        }
Magic Number,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true){          bool isStatement = false;          startingAddress = this.counter+1; //Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  #if FxCop || ILOFFSETS          this.ilOffset = this.counter;          this.opCode = this.GetOpCode();  #else          OpCode opCode = this.GetOpCode();  #endif  #if FxCop          if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){            expr.sourceContext = sourceContext;            expr.ILOffset = this.ilOffset;            this.operandStack.Push(expr);          }  #endif          switch (opCode){            case OpCode.Nop: statement = new Statement(NodeType.Nop); goto done;            case OpCode.Break: statement = new Statement(NodeType.DebugBreak); goto done;            case OpCode.Ldarg_0: expr = this.Parameters(0); break;            case OpCode.Ldarg_1: expr = this.Parameters(1); break;            case OpCode.Ldarg_2: expr = this.Parameters(2); break;            case OpCode.Ldarg_3: expr = this.Parameters(3); break;            case OpCode.Ldloc_0: expr = this.locals[0]; break;            case OpCode.Ldloc_1: expr = this.locals[1]; break;            case OpCode.Ldloc_2: expr = this.locals[2]; break;            case OpCode.Ldloc_3: expr = this.locals[3]; break;            case OpCode.Stloc_0: statement = new AssignmentStatement(this.locals[0]' PopOperand()); goto done;            case OpCode.Stloc_1: statement = new AssignmentStatement(this.locals[1]' PopOperand()); goto done;            case OpCode.Stloc_2: statement = new AssignmentStatement(this.locals[2]' PopOperand()); goto done;            case OpCode.Stloc_3: statement = new AssignmentStatement(this.locals[3]' PopOperand()); goto done;            case OpCode.Ldarg_S: expr = this.Parameters(this.GetByte()); break;            case OpCode.Ldarga_S: expr = SetType(new UnaryExpression(this.Parameters(this.GetByte())' NodeType.AddressOf)); break;            case OpCode.Starg_S: statement = new AssignmentStatement(this.Parameters(this.GetByte())' PopOperand()); goto done;            case OpCode.Ldloc_S: expr = this.locals[this.GetByte()]; break;            case OpCode.Ldloca_S: expr = SetType(new UnaryExpression(this.locals[this.GetByte()]' NodeType.AddressOf)); break;            case OpCode.Stloc_S: statement = new AssignmentStatement(this.locals[this.GetByte()]' PopOperand()); goto done;            case OpCode.Ldnull: expr = new Literal(null' CoreSystemTypes.Object); break;            case OpCode.Ldc_I4_M1: expr = new Literal(-1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_0: expr = new Literal(0' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_1: expr = new Literal(1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_2: expr = new Literal(2' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_3: expr = new Literal(3' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_4: expr = new Literal(4' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_5: expr = new Literal(5' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_6: expr = new Literal(6' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_7: expr = new Literal(7' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_8: expr = new Literal(8' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_S: expr = new Literal((int)this.GetSByte()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4: expr = new Literal(this.GetInt32()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I8: expr = new Literal(this.GetInt64()' CoreSystemTypes.Int64); break;            case OpCode.Ldc_R4: expr = new Literal(this.GetSingle()' CoreSystemTypes.Single); break;            case OpCode.Ldc_R8: expr = new Literal(this.GetDouble()' CoreSystemTypes.Double); break;            case OpCode.Dup: statement = new ExpressionStatement(new Expression(NodeType.Dup)); goto done;            case OpCode.Pop: statement = new ExpressionStatement(new UnaryExpression(PopOperand()' NodeType.Pop)); goto done;            case OpCode.Jmp: expr = this.ParseCall(NodeType.Jmp' out isStatement); if (isStatement) goto done; break;            case OpCode.Call: expr = this.ParseCall(NodeType.Call' out isStatement); if (isStatement) goto done; break;            case OpCode.Calli: expr = this.ParseCalli(out isStatement); if (isStatement) goto done; break;            case OpCode.Ret:              Expression retVal = BodyParser.TypeIsVoid(this.method.ReturnType) ? null : PopOperand();              statement = new Return(retVal);               transferStatement = true; goto done;            case OpCode.Br_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false); transferStatement = true; goto done;            case OpCode.Brfalse_S: statement = this.ParseBranch(NodeType.LogicalNot' 1' true' false); transferStatement = true; goto done;            case OpCode.Brtrue_S: statement = this.ParseBranch(NodeType.Nop' 1' true' false); transferStatement = true; goto done;            case OpCode.Beq_S: statement = this.ParseBranch(NodeType.Eq' 2' true' false); transferStatement = true; goto done;            case OpCode.Bge_S: statement = this.ParseBranch(NodeType.Ge' 2' true' false); transferStatement = true; goto done;            case OpCode.Bgt_S: statement = this.ParseBranch(NodeType.Gt' 2' true' false); transferStatement = true; goto done;            case OpCode.Ble_S: statement = this.ParseBranch(NodeType.Le' 2' true' false); transferStatement = true; goto done;            case OpCode.Blt_S: statement = this.ParseBranch(NodeType.Lt' 2' true' false); transferStatement = true; goto done;            case OpCode.Bne_Un_S: statement = this.ParseBranch(NodeType.Ne' 2' true' true); transferStatement = true; goto done;            case OpCode.Bge_Un_S: statement = this.ParseBranch(NodeType.Ge' 2' true' true); transferStatement = true; goto done;            case OpCode.Bgt_Un_S: statement = this.ParseBranch(NodeType.Gt' 2' true' true); transferStatement = true; goto done;            case OpCode.Ble_Un_S: statement = this.ParseBranch(NodeType.Le' 2' true' true); transferStatement = true; goto done;            case OpCode.Blt_Un_S: statement = this.ParseBranch(NodeType.Lt' 2' true' true); transferStatement = true; goto done;            case OpCode.Br: statement = this.ParseBranch(NodeType.Nop' 0' false' false); transferStatement = true; goto done;            case OpCode.Brfalse: statement = this.ParseBranch(NodeType.LogicalNot' 1' false' false); transferStatement = true; goto done;            case OpCode.Brtrue: statement = this.ParseBranch(NodeType.Nop' 1' false' false); transferStatement = true; goto done;            case OpCode.Beq: statement = this.ParseBranch(NodeType.Eq' 2' false' false); transferStatement = true; goto done;            case OpCode.Bge: statement = this.ParseBranch(NodeType.Ge' 2' false' false); transferStatement = true; goto done;            case OpCode.Bgt: statement = this.ParseBranch(NodeType.Gt' 2' false' false); transferStatement = true; goto done;            case OpCode.Ble: statement = this.ParseBranch(NodeType.Le' 2' false' false); transferStatement = true; goto done;            case OpCode.Blt: statement = this.ParseBranch(NodeType.Lt' 2' false' false); transferStatement = true; goto done;            case OpCode.Bne_Un: statement = this.ParseBranch(NodeType.Ne' 2' false' true); transferStatement = true; goto done;            case OpCode.Bge_Un: statement = this.ParseBranch(NodeType.Ge' 2' false' true); transferStatement = true; goto done;            case OpCode.Bgt_Un: statement = this.ParseBranch(NodeType.Gt' 2' false' true); transferStatement = true; goto done;            case OpCode.Ble_Un: statement = this.ParseBranch(NodeType.Le' 2' false' true); transferStatement = true; goto done;            case OpCode.Blt_Un: statement = this.ParseBranch(NodeType.Lt' 2' false' true); transferStatement = true; goto done;            case OpCode.Switch: statement = this.ParseSwitchInstruction(); transferStatement = true; goto done;            case OpCode.Ldind_I1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int64' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I: expr = new AddressDereference(PopOperand()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Single' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Double' this.isVolatile' this.alignment); break;            case OpCode.Ldind_Ref: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Object' this.isVolatile' this.alignment); break;            case OpCode.Stind_Ref: statement = this.ParseStoreIndirect(CoreSystemTypes.Object); goto done;            case OpCode.Stind_I1: statement = this.ParseStoreIndirect(CoreSystemTypes.Int8); goto done;            case OpCode.Stind_I2: statement = this.ParseStoreIndirect(CoreSystemTypes.Int16); goto done;            case OpCode.Stind_I4: statement = this.ParseStoreIndirect(CoreSystemTypes.Int32); goto done;            case OpCode.Stind_I8: statement = this.ParseStoreIndirect(CoreSystemTypes.Int64); goto done;            case OpCode.Stind_R4: statement = this.ParseStoreIndirect(CoreSystemTypes.Single); goto done;            case OpCode.Stind_R8: statement = this.ParseStoreIndirect(CoreSystemTypes.Double); goto done;            case OpCode.Add: expr = this.ParseBinaryOperation(NodeType.Add); break;            case OpCode.Sub: expr = this.ParseBinaryOperation(NodeType.Sub); break;            case OpCode.Mul: expr = this.ParseBinaryOperation(NodeType.Mul); break;            case OpCode.Div: expr = this.ParseBinaryOperation(NodeType.Div); break;            case OpCode.Div_Un: expr = this.ParseBinaryOperation(NodeType.Div_Un); break;            case OpCode.Rem: expr = this.ParseBinaryOperation(NodeType.Rem); break;            case OpCode.Rem_Un: expr = this.ParseBinaryOperation(NodeType.Rem_Un); break;            case OpCode.And: expr = this.ParseBinaryOperation(NodeType.And); break;            case OpCode.Or: expr = this.ParseBinaryOperation(NodeType.Or); break;            case OpCode.Xor: expr = this.ParseBinaryOperation(NodeType.Xor); break;            case OpCode.Shl: expr = this.ParseBinaryOperation(NodeType.Shl); break;            case OpCode.Shr: expr = this.ParseBinaryOperation(NodeType.Shr); break;            case OpCode.Shr_Un: expr = this.ParseBinaryOperation(NodeType.Shr_Un); break;            case OpCode.Neg: expr = this.ParseUnaryOperation(NodeType.Neg); break;            case OpCode.Not: expr = this.ParseUnaryOperation(NodeType.Not); break;            case OpCode.Conv_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_R4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R4' CoreSystemTypes.Single); break;            case OpCode.Conv_R8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R8' CoreSystemTypes.Double); break;            case OpCode.Conv_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U8' CoreSystemTypes.UInt64); break;            case OpCode.Callvirt: expr = this.ParseCall(NodeType.Callvirt' out isStatement); if (isStatement) goto done; break;            case OpCode.Cpobj: statement = this.ParseCopyObject(); goto done;            case OpCode.Ldobj: expr = new AddressDereference(PopOperand()' (TypeNode)this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldstr: expr = new Literal(this.GetStringFromToken()' CoreSystemTypes.String); break;            case OpCode.Newobj: expr = this.ParseConstruct(); break;            case OpCode.Castclass: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Castclass); break;            case OpCode.Isinst: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Isinst); break;            case OpCode.Conv_R_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R_Un' CoreSystemTypes.Double); break;            case OpCode.Unbox: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Unbox); break;            case OpCode.Throw: statement = new Throw(PopOperand()); transferStatement = true; goto done;            case OpCode.Ldfld:               expr = new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment);              break;            case OpCode.Ldflda:               expr = SetType(new UnaryExpression(new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf));               break;            case OpCode.Stfld: statement = this.ParseStoreField(); goto done;            case OpCode.Ldsfld: expr = new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldsflda: expr = SetType(new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf)); break;            case OpCode.Stsfld: statement = new AssignmentStatement(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' PopOperand()); goto done;            case OpCode.Stobj: statement = this.ParseStoreIndirect((TypeNode)this.GetMemberFromToken()); goto done;            case OpCode.Conv_Ovf_I1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_I2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_I4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_I8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_U2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_U4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_U8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64); break;            case OpCode.Conv_Ovf_I_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr); break;            case OpCode.Box:               TypeNode t = (TypeNode)this.GetMemberFromToken();              TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;              expr = new BinaryExpression(PopOperand()' new Literal(t' CoreSystemTypes.Type)' NodeType.Box' bt); break;            case OpCode.Newarr: expr = this.ParseNewArray(); break;            case OpCode.Ldlen: expr = new UnaryExpression(PopOperand()' NodeType.Ldlen' CoreSystemTypes.UIntPtr); break;            case OpCode.Ldelema: expr = this.ParseArrayElementLoadAddress(); break;            case OpCode.Ldelem_I1:             case OpCode.Ldelem_U1:             case OpCode.Ldelem_I2:             case OpCode.Ldelem_U2:             case OpCode.Ldelem_I4:             case OpCode.Ldelem_U4:             case OpCode.Ldelem_I8:             case OpCode.Ldelem_I:             case OpCode.Ldelem_R4:             case OpCode.Ldelem_R8:             case OpCode.Ldelem_Ref: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem_I:            case OpCode.Stelem_I1:            case OpCode.Stelem_I2:            case OpCode.Stelem_I4:            case OpCode.Stelem_I8:            case OpCode.Stelem_R4:            case OpCode.Stelem_R8:            case OpCode.Stelem_Ref: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Ldelem: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Unbox_Any: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.UnboxAny); break;            case OpCode.Conv_Ovf_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64); break;            case OpCode.Refanyval: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr); break;            case OpCode.Ckfinite: expr = this.ParseUnaryOperation(NodeType.Ckfinite); break;            case OpCode.Mkrefany: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference); break;            case OpCode.Ldtoken: expr = ParseLoadRuntimeMetadataToken(); break;            case OpCode.Conv_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Add_Ovf: expr = this.ParseBinaryOperation(NodeType.Add_Ovf); break;            case OpCode.Add_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Add_Ovf_Un); break;            case OpCode.Mul_Ovf: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf); break;            case OpCode.Mul_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf_Un); break;            case OpCode.Sub_Ovf: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf); break;            case OpCode.Sub_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf_Un); break;            case OpCode.Endfinally: statement = new EndFinally(); transferStatement = true; goto done;            case OpCode.Leave: statement = this.ParseBranch(NodeType.Nop' 0' false' false' true); transferStatement = true; goto done;            case OpCode.Leave_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false' true); transferStatement = true; goto done;            case OpCode.Stind_I: statement = this.ParseStoreIndirect(CoreSystemTypes.IntPtr); goto done;            case OpCode.Conv_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Arglist: expr = new Expression(NodeType.Arglist' CoreSystemTypes.ArgIterator); break;            case OpCode.Ceq: expr = this.ParseBinaryComparison(NodeType.Ceq); break;            case OpCode.Cgt: expr = this.ParseBinaryComparison(NodeType.Cgt); break;            case OpCode.Cgt_Un: expr = this.ParseBinaryComparison(NodeType.Cgt_Un); break;            case OpCode.Clt: expr = this.ParseBinaryComparison(NodeType.Clt); break;            case OpCode.Clt_Un: expr = this.ParseBinaryComparison(NodeType.Clt_Un); break;            case OpCode.Ldftn: expr = new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldvirtftn: expr = new BinaryExpression(PopOperand()' new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldarg: expr = this.Parameters((ushort)this.GetInt16()); break;            case OpCode.Ldarga: expr = SetType(new UnaryExpression(this.Parameters((ushort)this.GetInt16())' NodeType.AddressOf)); break;            case OpCode.Starg: statement = new AssignmentStatement(this.Parameters((ushort)this.GetInt16())' PopOperand()); goto done;            case OpCode.Ldloc: expr = this.locals[(ushort)this.GetInt16()]; break;            case OpCode.Ldloca: expr = SetType(new UnaryExpression(this.locals[(ushort)this.GetInt16()]' NodeType.AddressOf)); break;            case OpCode.Stloc: statement = new AssignmentStatement(this.locals[(ushort)this.GetInt16()]' PopOperand()); goto done;            case OpCode.Localloc: expr = new UnaryExpression(PopOperand()' NodeType.Localloc' CoreSystemTypes.Void); break;            case OpCode.Endfilter: statement = new EndFilter(PopOperand()); transferStatement = true; goto done;            case OpCode.Unaligned_: this.alignment = this.GetByte(); continue;            case OpCode.Volatile_: this.isVolatile = true; continue;            case OpCode.Tail_: this.isTailCall = true; continue;            case OpCode.Initobj: statement = this.ParseInitObject(); goto done;            case OpCode.Constrained_: this.constraint = this.GetMemberFromToken() as TypeNode; continue;            case OpCode.Cpblk: expr = this.ParseTernaryOperation(NodeType.Cpblk); goto done;            case OpCode.Initblk: expr = this.ParseTernaryOperation(NodeType.Initblk); goto done;            case OpCode.Rethrow: statement = new Throw(null); statement.NodeType = NodeType.Rethrow; transferStatement = true; goto done;            case OpCode.Sizeof: expr = new UnaryExpression(new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32); break;            case OpCode.Refanytype: expr = new UnaryExpression(PopOperand()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle); break;            case OpCode.Readonly_: this.isReadOnly = true; continue;            default: throw new InvalidMetadataException(ExceptionStrings.UnknownOpCode);          }          if (this.blockMap[this.counter+1] != null){            transferStatement = true; //Falls through to the next basic block' so implicitly a "transfer" statement            goto done;          }          //^ assume expr != null;  #if FxCop          expr.sourceContext = sourceContext;  #endif  #if FxCop || ILOFFSETS          expr.ILOffset = this.ilOffset;  #endif          this.operandStack.Push(expr);          this.isReadOnly = false;          this.isVolatile = false;          this.isTailCall = false;                  this.alignment = -1;        }
Magic Number,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true){          bool isStatement = false;          startingAddress = this.counter+1; //Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  #if FxCop || ILOFFSETS          this.ilOffset = this.counter;          this.opCode = this.GetOpCode();  #else          OpCode opCode = this.GetOpCode();  #endif  #if FxCop          if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){            expr.sourceContext = sourceContext;            expr.ILOffset = this.ilOffset;            this.operandStack.Push(expr);          }  #endif          switch (opCode){            case OpCode.Nop: statement = new Statement(NodeType.Nop); goto done;            case OpCode.Break: statement = new Statement(NodeType.DebugBreak); goto done;            case OpCode.Ldarg_0: expr = this.Parameters(0); break;            case OpCode.Ldarg_1: expr = this.Parameters(1); break;            case OpCode.Ldarg_2: expr = this.Parameters(2); break;            case OpCode.Ldarg_3: expr = this.Parameters(3); break;            case OpCode.Ldloc_0: expr = this.locals[0]; break;            case OpCode.Ldloc_1: expr = this.locals[1]; break;            case OpCode.Ldloc_2: expr = this.locals[2]; break;            case OpCode.Ldloc_3: expr = this.locals[3]; break;            case OpCode.Stloc_0: statement = new AssignmentStatement(this.locals[0]' PopOperand()); goto done;            case OpCode.Stloc_1: statement = new AssignmentStatement(this.locals[1]' PopOperand()); goto done;            case OpCode.Stloc_2: statement = new AssignmentStatement(this.locals[2]' PopOperand()); goto done;            case OpCode.Stloc_3: statement = new AssignmentStatement(this.locals[3]' PopOperand()); goto done;            case OpCode.Ldarg_S: expr = this.Parameters(this.GetByte()); break;            case OpCode.Ldarga_S: expr = SetType(new UnaryExpression(this.Parameters(this.GetByte())' NodeType.AddressOf)); break;            case OpCode.Starg_S: statement = new AssignmentStatement(this.Parameters(this.GetByte())' PopOperand()); goto done;            case OpCode.Ldloc_S: expr = this.locals[this.GetByte()]; break;            case OpCode.Ldloca_S: expr = SetType(new UnaryExpression(this.locals[this.GetByte()]' NodeType.AddressOf)); break;            case OpCode.Stloc_S: statement = new AssignmentStatement(this.locals[this.GetByte()]' PopOperand()); goto done;            case OpCode.Ldnull: expr = new Literal(null' CoreSystemTypes.Object); break;            case OpCode.Ldc_I4_M1: expr = new Literal(-1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_0: expr = new Literal(0' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_1: expr = new Literal(1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_2: expr = new Literal(2' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_3: expr = new Literal(3' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_4: expr = new Literal(4' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_5: expr = new Literal(5' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_6: expr = new Literal(6' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_7: expr = new Literal(7' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_8: expr = new Literal(8' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_S: expr = new Literal((int)this.GetSByte()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4: expr = new Literal(this.GetInt32()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I8: expr = new Literal(this.GetInt64()' CoreSystemTypes.Int64); break;            case OpCode.Ldc_R4: expr = new Literal(this.GetSingle()' CoreSystemTypes.Single); break;            case OpCode.Ldc_R8: expr = new Literal(this.GetDouble()' CoreSystemTypes.Double); break;            case OpCode.Dup: statement = new ExpressionStatement(new Expression(NodeType.Dup)); goto done;            case OpCode.Pop: statement = new ExpressionStatement(new UnaryExpression(PopOperand()' NodeType.Pop)); goto done;            case OpCode.Jmp: expr = this.ParseCall(NodeType.Jmp' out isStatement); if (isStatement) goto done; break;            case OpCode.Call: expr = this.ParseCall(NodeType.Call' out isStatement); if (isStatement) goto done; break;            case OpCode.Calli: expr = this.ParseCalli(out isStatement); if (isStatement) goto done; break;            case OpCode.Ret:              Expression retVal = BodyParser.TypeIsVoid(this.method.ReturnType) ? null : PopOperand();              statement = new Return(retVal);               transferStatement = true; goto done;            case OpCode.Br_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false); transferStatement = true; goto done;            case OpCode.Brfalse_S: statement = this.ParseBranch(NodeType.LogicalNot' 1' true' false); transferStatement = true; goto done;            case OpCode.Brtrue_S: statement = this.ParseBranch(NodeType.Nop' 1' true' false); transferStatement = true; goto done;            case OpCode.Beq_S: statement = this.ParseBranch(NodeType.Eq' 2' true' false); transferStatement = true; goto done;            case OpCode.Bge_S: statement = this.ParseBranch(NodeType.Ge' 2' true' false); transferStatement = true; goto done;            case OpCode.Bgt_S: statement = this.ParseBranch(NodeType.Gt' 2' true' false); transferStatement = true; goto done;            case OpCode.Ble_S: statement = this.ParseBranch(NodeType.Le' 2' true' false); transferStatement = true; goto done;            case OpCode.Blt_S: statement = this.ParseBranch(NodeType.Lt' 2' true' false); transferStatement = true; goto done;            case OpCode.Bne_Un_S: statement = this.ParseBranch(NodeType.Ne' 2' true' true); transferStatement = true; goto done;            case OpCode.Bge_Un_S: statement = this.ParseBranch(NodeType.Ge' 2' true' true); transferStatement = true; goto done;            case OpCode.Bgt_Un_S: statement = this.ParseBranch(NodeType.Gt' 2' true' true); transferStatement = true; goto done;            case OpCode.Ble_Un_S: statement = this.ParseBranch(NodeType.Le' 2' true' true); transferStatement = true; goto done;            case OpCode.Blt_Un_S: statement = this.ParseBranch(NodeType.Lt' 2' true' true); transferStatement = true; goto done;            case OpCode.Br: statement = this.ParseBranch(NodeType.Nop' 0' false' false); transferStatement = true; goto done;            case OpCode.Brfalse: statement = this.ParseBranch(NodeType.LogicalNot' 1' false' false); transferStatement = true; goto done;            case OpCode.Brtrue: statement = this.ParseBranch(NodeType.Nop' 1' false' false); transferStatement = true; goto done;            case OpCode.Beq: statement = this.ParseBranch(NodeType.Eq' 2' false' false); transferStatement = true; goto done;            case OpCode.Bge: statement = this.ParseBranch(NodeType.Ge' 2' false' false); transferStatement = true; goto done;            case OpCode.Bgt: statement = this.ParseBranch(NodeType.Gt' 2' false' false); transferStatement = true; goto done;            case OpCode.Ble: statement = this.ParseBranch(NodeType.Le' 2' false' false); transferStatement = true; goto done;            case OpCode.Blt: statement = this.ParseBranch(NodeType.Lt' 2' false' false); transferStatement = true; goto done;            case OpCode.Bne_Un: statement = this.ParseBranch(NodeType.Ne' 2' false' true); transferStatement = true; goto done;            case OpCode.Bge_Un: statement = this.ParseBranch(NodeType.Ge' 2' false' true); transferStatement = true; goto done;            case OpCode.Bgt_Un: statement = this.ParseBranch(NodeType.Gt' 2' false' true); transferStatement = true; goto done;            case OpCode.Ble_Un: statement = this.ParseBranch(NodeType.Le' 2' false' true); transferStatement = true; goto done;            case OpCode.Blt_Un: statement = this.ParseBranch(NodeType.Lt' 2' false' true); transferStatement = true; goto done;            case OpCode.Switch: statement = this.ParseSwitchInstruction(); transferStatement = true; goto done;            case OpCode.Ldind_I1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int64' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I: expr = new AddressDereference(PopOperand()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Single' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Double' this.isVolatile' this.alignment); break;            case OpCode.Ldind_Ref: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Object' this.isVolatile' this.alignment); break;            case OpCode.Stind_Ref: statement = this.ParseStoreIndirect(CoreSystemTypes.Object); goto done;            case OpCode.Stind_I1: statement = this.ParseStoreIndirect(CoreSystemTypes.Int8); goto done;            case OpCode.Stind_I2: statement = this.ParseStoreIndirect(CoreSystemTypes.Int16); goto done;            case OpCode.Stind_I4: statement = this.ParseStoreIndirect(CoreSystemTypes.Int32); goto done;            case OpCode.Stind_I8: statement = this.ParseStoreIndirect(CoreSystemTypes.Int64); goto done;            case OpCode.Stind_R4: statement = this.ParseStoreIndirect(CoreSystemTypes.Single); goto done;            case OpCode.Stind_R8: statement = this.ParseStoreIndirect(CoreSystemTypes.Double); goto done;            case OpCode.Add: expr = this.ParseBinaryOperation(NodeType.Add); break;            case OpCode.Sub: expr = this.ParseBinaryOperation(NodeType.Sub); break;            case OpCode.Mul: expr = this.ParseBinaryOperation(NodeType.Mul); break;            case OpCode.Div: expr = this.ParseBinaryOperation(NodeType.Div); break;            case OpCode.Div_Un: expr = this.ParseBinaryOperation(NodeType.Div_Un); break;            case OpCode.Rem: expr = this.ParseBinaryOperation(NodeType.Rem); break;            case OpCode.Rem_Un: expr = this.ParseBinaryOperation(NodeType.Rem_Un); break;            case OpCode.And: expr = this.ParseBinaryOperation(NodeType.And); break;            case OpCode.Or: expr = this.ParseBinaryOperation(NodeType.Or); break;            case OpCode.Xor: expr = this.ParseBinaryOperation(NodeType.Xor); break;            case OpCode.Shl: expr = this.ParseBinaryOperation(NodeType.Shl); break;            case OpCode.Shr: expr = this.ParseBinaryOperation(NodeType.Shr); break;            case OpCode.Shr_Un: expr = this.ParseBinaryOperation(NodeType.Shr_Un); break;            case OpCode.Neg: expr = this.ParseUnaryOperation(NodeType.Neg); break;            case OpCode.Not: expr = this.ParseUnaryOperation(NodeType.Not); break;            case OpCode.Conv_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_R4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R4' CoreSystemTypes.Single); break;            case OpCode.Conv_R8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R8' CoreSystemTypes.Double); break;            case OpCode.Conv_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U8' CoreSystemTypes.UInt64); break;            case OpCode.Callvirt: expr = this.ParseCall(NodeType.Callvirt' out isStatement); if (isStatement) goto done; break;            case OpCode.Cpobj: statement = this.ParseCopyObject(); goto done;            case OpCode.Ldobj: expr = new AddressDereference(PopOperand()' (TypeNode)this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldstr: expr = new Literal(this.GetStringFromToken()' CoreSystemTypes.String); break;            case OpCode.Newobj: expr = this.ParseConstruct(); break;            case OpCode.Castclass: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Castclass); break;            case OpCode.Isinst: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Isinst); break;            case OpCode.Conv_R_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R_Un' CoreSystemTypes.Double); break;            case OpCode.Unbox: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Unbox); break;            case OpCode.Throw: statement = new Throw(PopOperand()); transferStatement = true; goto done;            case OpCode.Ldfld:               expr = new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment);              break;            case OpCode.Ldflda:               expr = SetType(new UnaryExpression(new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf));               break;            case OpCode.Stfld: statement = this.ParseStoreField(); goto done;            case OpCode.Ldsfld: expr = new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldsflda: expr = SetType(new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf)); break;            case OpCode.Stsfld: statement = new AssignmentStatement(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' PopOperand()); goto done;            case OpCode.Stobj: statement = this.ParseStoreIndirect((TypeNode)this.GetMemberFromToken()); goto done;            case OpCode.Conv_Ovf_I1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_I2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_I4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_I8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_U2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_U4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_U8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64); break;            case OpCode.Conv_Ovf_I_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr); break;            case OpCode.Box:               TypeNode t = (TypeNode)this.GetMemberFromToken();              TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;              expr = new BinaryExpression(PopOperand()' new Literal(t' CoreSystemTypes.Type)' NodeType.Box' bt); break;            case OpCode.Newarr: expr = this.ParseNewArray(); break;            case OpCode.Ldlen: expr = new UnaryExpression(PopOperand()' NodeType.Ldlen' CoreSystemTypes.UIntPtr); break;            case OpCode.Ldelema: expr = this.ParseArrayElementLoadAddress(); break;            case OpCode.Ldelem_I1:             case OpCode.Ldelem_U1:             case OpCode.Ldelem_I2:             case OpCode.Ldelem_U2:             case OpCode.Ldelem_I4:             case OpCode.Ldelem_U4:             case OpCode.Ldelem_I8:             case OpCode.Ldelem_I:             case OpCode.Ldelem_R4:             case OpCode.Ldelem_R8:             case OpCode.Ldelem_Ref: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem_I:            case OpCode.Stelem_I1:            case OpCode.Stelem_I2:            case OpCode.Stelem_I4:            case OpCode.Stelem_I8:            case OpCode.Stelem_R4:            case OpCode.Stelem_R8:            case OpCode.Stelem_Ref: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Ldelem: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Unbox_Any: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.UnboxAny); break;            case OpCode.Conv_Ovf_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64); break;            case OpCode.Refanyval: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr); break;            case OpCode.Ckfinite: expr = this.ParseUnaryOperation(NodeType.Ckfinite); break;            case OpCode.Mkrefany: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference); break;            case OpCode.Ldtoken: expr = ParseLoadRuntimeMetadataToken(); break;            case OpCode.Conv_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Add_Ovf: expr = this.ParseBinaryOperation(NodeType.Add_Ovf); break;            case OpCode.Add_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Add_Ovf_Un); break;            case OpCode.Mul_Ovf: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf); break;            case OpCode.Mul_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf_Un); break;            case OpCode.Sub_Ovf: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf); break;            case OpCode.Sub_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf_Un); break;            case OpCode.Endfinally: statement = new EndFinally(); transferStatement = true; goto done;            case OpCode.Leave: statement = this.ParseBranch(NodeType.Nop' 0' false' false' true); transferStatement = true; goto done;            case OpCode.Leave_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false' true); transferStatement = true; goto done;            case OpCode.Stind_I: statement = this.ParseStoreIndirect(CoreSystemTypes.IntPtr); goto done;            case OpCode.Conv_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Arglist: expr = new Expression(NodeType.Arglist' CoreSystemTypes.ArgIterator); break;            case OpCode.Ceq: expr = this.ParseBinaryComparison(NodeType.Ceq); break;            case OpCode.Cgt: expr = this.ParseBinaryComparison(NodeType.Cgt); break;            case OpCode.Cgt_Un: expr = this.ParseBinaryComparison(NodeType.Cgt_Un); break;            case OpCode.Clt: expr = this.ParseBinaryComparison(NodeType.Clt); break;            case OpCode.Clt_Un: expr = this.ParseBinaryComparison(NodeType.Clt_Un); break;            case OpCode.Ldftn: expr = new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldvirtftn: expr = new BinaryExpression(PopOperand()' new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldarg: expr = this.Parameters((ushort)this.GetInt16()); break;            case OpCode.Ldarga: expr = SetType(new UnaryExpression(this.Parameters((ushort)this.GetInt16())' NodeType.AddressOf)); break;            case OpCode.Starg: statement = new AssignmentStatement(this.Parameters((ushort)this.GetInt16())' PopOperand()); goto done;            case OpCode.Ldloc: expr = this.locals[(ushort)this.GetInt16()]; break;            case OpCode.Ldloca: expr = SetType(new UnaryExpression(this.locals[(ushort)this.GetInt16()]' NodeType.AddressOf)); break;            case OpCode.Stloc: statement = new AssignmentStatement(this.locals[(ushort)this.GetInt16()]' PopOperand()); goto done;            case OpCode.Localloc: expr = new UnaryExpression(PopOperand()' NodeType.Localloc' CoreSystemTypes.Void); break;            case OpCode.Endfilter: statement = new EndFilter(PopOperand()); transferStatement = true; goto done;            case OpCode.Unaligned_: this.alignment = this.GetByte(); continue;            case OpCode.Volatile_: this.isVolatile = true; continue;            case OpCode.Tail_: this.isTailCall = true; continue;            case OpCode.Initobj: statement = this.ParseInitObject(); goto done;            case OpCode.Constrained_: this.constraint = this.GetMemberFromToken() as TypeNode; continue;            case OpCode.Cpblk: expr = this.ParseTernaryOperation(NodeType.Cpblk); goto done;            case OpCode.Initblk: expr = this.ParseTernaryOperation(NodeType.Initblk); goto done;            case OpCode.Rethrow: statement = new Throw(null); statement.NodeType = NodeType.Rethrow; transferStatement = true; goto done;            case OpCode.Sizeof: expr = new UnaryExpression(new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32); break;            case OpCode.Refanytype: expr = new UnaryExpression(PopOperand()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle); break;            case OpCode.Readonly_: this.isReadOnly = true; continue;            default: throw new InvalidMetadataException(ExceptionStrings.UnknownOpCode);          }          if (this.blockMap[this.counter+1] != null){            transferStatement = true; //Falls through to the next basic block' so implicitly a "transfer" statement            goto done;          }          //^ assume expr != null;  #if FxCop          expr.sourceContext = sourceContext;  #endif  #if FxCop || ILOFFSETS          expr.ILOffset = this.ilOffset;  #endif          this.operandStack.Push(expr);          this.isReadOnly = false;          this.isVolatile = false;          this.isTailCall = false;                  this.alignment = -1;        }
Magic Number,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true){          bool isStatement = false;          startingAddress = this.counter+1; //Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  #if FxCop || ILOFFSETS          this.ilOffset = this.counter;          this.opCode = this.GetOpCode();  #else          OpCode opCode = this.GetOpCode();  #endif  #if FxCop          if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){            expr.sourceContext = sourceContext;            expr.ILOffset = this.ilOffset;            this.operandStack.Push(expr);          }  #endif          switch (opCode){            case OpCode.Nop: statement = new Statement(NodeType.Nop); goto done;            case OpCode.Break: statement = new Statement(NodeType.DebugBreak); goto done;            case OpCode.Ldarg_0: expr = this.Parameters(0); break;            case OpCode.Ldarg_1: expr = this.Parameters(1); break;            case OpCode.Ldarg_2: expr = this.Parameters(2); break;            case OpCode.Ldarg_3: expr = this.Parameters(3); break;            case OpCode.Ldloc_0: expr = this.locals[0]; break;            case OpCode.Ldloc_1: expr = this.locals[1]; break;            case OpCode.Ldloc_2: expr = this.locals[2]; break;            case OpCode.Ldloc_3: expr = this.locals[3]; break;            case OpCode.Stloc_0: statement = new AssignmentStatement(this.locals[0]' PopOperand()); goto done;            case OpCode.Stloc_1: statement = new AssignmentStatement(this.locals[1]' PopOperand()); goto done;            case OpCode.Stloc_2: statement = new AssignmentStatement(this.locals[2]' PopOperand()); goto done;            case OpCode.Stloc_3: statement = new AssignmentStatement(this.locals[3]' PopOperand()); goto done;            case OpCode.Ldarg_S: expr = this.Parameters(this.GetByte()); break;            case OpCode.Ldarga_S: expr = SetType(new UnaryExpression(this.Parameters(this.GetByte())' NodeType.AddressOf)); break;            case OpCode.Starg_S: statement = new AssignmentStatement(this.Parameters(this.GetByte())' PopOperand()); goto done;            case OpCode.Ldloc_S: expr = this.locals[this.GetByte()]; break;            case OpCode.Ldloca_S: expr = SetType(new UnaryExpression(this.locals[this.GetByte()]' NodeType.AddressOf)); break;            case OpCode.Stloc_S: statement = new AssignmentStatement(this.locals[this.GetByte()]' PopOperand()); goto done;            case OpCode.Ldnull: expr = new Literal(null' CoreSystemTypes.Object); break;            case OpCode.Ldc_I4_M1: expr = new Literal(-1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_0: expr = new Literal(0' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_1: expr = new Literal(1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_2: expr = new Literal(2' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_3: expr = new Literal(3' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_4: expr = new Literal(4' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_5: expr = new Literal(5' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_6: expr = new Literal(6' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_7: expr = new Literal(7' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_8: expr = new Literal(8' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_S: expr = new Literal((int)this.GetSByte()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4: expr = new Literal(this.GetInt32()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I8: expr = new Literal(this.GetInt64()' CoreSystemTypes.Int64); break;            case OpCode.Ldc_R4: expr = new Literal(this.GetSingle()' CoreSystemTypes.Single); break;            case OpCode.Ldc_R8: expr = new Literal(this.GetDouble()' CoreSystemTypes.Double); break;            case OpCode.Dup: statement = new ExpressionStatement(new Expression(NodeType.Dup)); goto done;            case OpCode.Pop: statement = new ExpressionStatement(new UnaryExpression(PopOperand()' NodeType.Pop)); goto done;            case OpCode.Jmp: expr = this.ParseCall(NodeType.Jmp' out isStatement); if (isStatement) goto done; break;            case OpCode.Call: expr = this.ParseCall(NodeType.Call' out isStatement); if (isStatement) goto done; break;            case OpCode.Calli: expr = this.ParseCalli(out isStatement); if (isStatement) goto done; break;            case OpCode.Ret:              Expression retVal = BodyParser.TypeIsVoid(this.method.ReturnType) ? null : PopOperand();              statement = new Return(retVal);               transferStatement = true; goto done;            case OpCode.Br_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false); transferStatement = true; goto done;            case OpCode.Brfalse_S: statement = this.ParseBranch(NodeType.LogicalNot' 1' true' false); transferStatement = true; goto done;            case OpCode.Brtrue_S: statement = this.ParseBranch(NodeType.Nop' 1' true' false); transferStatement = true; goto done;            case OpCode.Beq_S: statement = this.ParseBranch(NodeType.Eq' 2' true' false); transferStatement = true; goto done;            case OpCode.Bge_S: statement = this.ParseBranch(NodeType.Ge' 2' true' false); transferStatement = true; goto done;            case OpCode.Bgt_S: statement = this.ParseBranch(NodeType.Gt' 2' true' false); transferStatement = true; goto done;            case OpCode.Ble_S: statement = this.ParseBranch(NodeType.Le' 2' true' false); transferStatement = true; goto done;            case OpCode.Blt_S: statement = this.ParseBranch(NodeType.Lt' 2' true' false); transferStatement = true; goto done;            case OpCode.Bne_Un_S: statement = this.ParseBranch(NodeType.Ne' 2' true' true); transferStatement = true; goto done;            case OpCode.Bge_Un_S: statement = this.ParseBranch(NodeType.Ge' 2' true' true); transferStatement = true; goto done;            case OpCode.Bgt_Un_S: statement = this.ParseBranch(NodeType.Gt' 2' true' true); transferStatement = true; goto done;            case OpCode.Ble_Un_S: statement = this.ParseBranch(NodeType.Le' 2' true' true); transferStatement = true; goto done;            case OpCode.Blt_Un_S: statement = this.ParseBranch(NodeType.Lt' 2' true' true); transferStatement = true; goto done;            case OpCode.Br: statement = this.ParseBranch(NodeType.Nop' 0' false' false); transferStatement = true; goto done;            case OpCode.Brfalse: statement = this.ParseBranch(NodeType.LogicalNot' 1' false' false); transferStatement = true; goto done;            case OpCode.Brtrue: statement = this.ParseBranch(NodeType.Nop' 1' false' false); transferStatement = true; goto done;            case OpCode.Beq: statement = this.ParseBranch(NodeType.Eq' 2' false' false); transferStatement = true; goto done;            case OpCode.Bge: statement = this.ParseBranch(NodeType.Ge' 2' false' false); transferStatement = true; goto done;            case OpCode.Bgt: statement = this.ParseBranch(NodeType.Gt' 2' false' false); transferStatement = true; goto done;            case OpCode.Ble: statement = this.ParseBranch(NodeType.Le' 2' false' false); transferStatement = true; goto done;            case OpCode.Blt: statement = this.ParseBranch(NodeType.Lt' 2' false' false); transferStatement = true; goto done;            case OpCode.Bne_Un: statement = this.ParseBranch(NodeType.Ne' 2' false' true); transferStatement = true; goto done;            case OpCode.Bge_Un: statement = this.ParseBranch(NodeType.Ge' 2' false' true); transferStatement = true; goto done;            case OpCode.Bgt_Un: statement = this.ParseBranch(NodeType.Gt' 2' false' true); transferStatement = true; goto done;            case OpCode.Ble_Un: statement = this.ParseBranch(NodeType.Le' 2' false' true); transferStatement = true; goto done;            case OpCode.Blt_Un: statement = this.ParseBranch(NodeType.Lt' 2' false' true); transferStatement = true; goto done;            case OpCode.Switch: statement = this.ParseSwitchInstruction(); transferStatement = true; goto done;            case OpCode.Ldind_I1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int64' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I: expr = new AddressDereference(PopOperand()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Single' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Double' this.isVolatile' this.alignment); break;            case OpCode.Ldind_Ref: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Object' this.isVolatile' this.alignment); break;            case OpCode.Stind_Ref: statement = this.ParseStoreIndirect(CoreSystemTypes.Object); goto done;            case OpCode.Stind_I1: statement = this.ParseStoreIndirect(CoreSystemTypes.Int8); goto done;            case OpCode.Stind_I2: statement = this.ParseStoreIndirect(CoreSystemTypes.Int16); goto done;            case OpCode.Stind_I4: statement = this.ParseStoreIndirect(CoreSystemTypes.Int32); goto done;            case OpCode.Stind_I8: statement = this.ParseStoreIndirect(CoreSystemTypes.Int64); goto done;            case OpCode.Stind_R4: statement = this.ParseStoreIndirect(CoreSystemTypes.Single); goto done;            case OpCode.Stind_R8: statement = this.ParseStoreIndirect(CoreSystemTypes.Double); goto done;            case OpCode.Add: expr = this.ParseBinaryOperation(NodeType.Add); break;            case OpCode.Sub: expr = this.ParseBinaryOperation(NodeType.Sub); break;            case OpCode.Mul: expr = this.ParseBinaryOperation(NodeType.Mul); break;            case OpCode.Div: expr = this.ParseBinaryOperation(NodeType.Div); break;            case OpCode.Div_Un: expr = this.ParseBinaryOperation(NodeType.Div_Un); break;            case OpCode.Rem: expr = this.ParseBinaryOperation(NodeType.Rem); break;            case OpCode.Rem_Un: expr = this.ParseBinaryOperation(NodeType.Rem_Un); break;            case OpCode.And: expr = this.ParseBinaryOperation(NodeType.And); break;            case OpCode.Or: expr = this.ParseBinaryOperation(NodeType.Or); break;            case OpCode.Xor: expr = this.ParseBinaryOperation(NodeType.Xor); break;            case OpCode.Shl: expr = this.ParseBinaryOperation(NodeType.Shl); break;            case OpCode.Shr: expr = this.ParseBinaryOperation(NodeType.Shr); break;            case OpCode.Shr_Un: expr = this.ParseBinaryOperation(NodeType.Shr_Un); break;            case OpCode.Neg: expr = this.ParseUnaryOperation(NodeType.Neg); break;            case OpCode.Not: expr = this.ParseUnaryOperation(NodeType.Not); break;            case OpCode.Conv_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_R4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R4' CoreSystemTypes.Single); break;            case OpCode.Conv_R8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R8' CoreSystemTypes.Double); break;            case OpCode.Conv_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U8' CoreSystemTypes.UInt64); break;            case OpCode.Callvirt: expr = this.ParseCall(NodeType.Callvirt' out isStatement); if (isStatement) goto done; break;            case OpCode.Cpobj: statement = this.ParseCopyObject(); goto done;            case OpCode.Ldobj: expr = new AddressDereference(PopOperand()' (TypeNode)this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldstr: expr = new Literal(this.GetStringFromToken()' CoreSystemTypes.String); break;            case OpCode.Newobj: expr = this.ParseConstruct(); break;            case OpCode.Castclass: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Castclass); break;            case OpCode.Isinst: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Isinst); break;            case OpCode.Conv_R_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R_Un' CoreSystemTypes.Double); break;            case OpCode.Unbox: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Unbox); break;            case OpCode.Throw: statement = new Throw(PopOperand()); transferStatement = true; goto done;            case OpCode.Ldfld:               expr = new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment);              break;            case OpCode.Ldflda:               expr = SetType(new UnaryExpression(new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf));               break;            case OpCode.Stfld: statement = this.ParseStoreField(); goto done;            case OpCode.Ldsfld: expr = new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldsflda: expr = SetType(new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf)); break;            case OpCode.Stsfld: statement = new AssignmentStatement(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' PopOperand()); goto done;            case OpCode.Stobj: statement = this.ParseStoreIndirect((TypeNode)this.GetMemberFromToken()); goto done;            case OpCode.Conv_Ovf_I1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_I2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_I4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_I8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_U2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_U4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_U8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64); break;            case OpCode.Conv_Ovf_I_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr); break;            case OpCode.Box:               TypeNode t = (TypeNode)this.GetMemberFromToken();              TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;              expr = new BinaryExpression(PopOperand()' new Literal(t' CoreSystemTypes.Type)' NodeType.Box' bt); break;            case OpCode.Newarr: expr = this.ParseNewArray(); break;            case OpCode.Ldlen: expr = new UnaryExpression(PopOperand()' NodeType.Ldlen' CoreSystemTypes.UIntPtr); break;            case OpCode.Ldelema: expr = this.ParseArrayElementLoadAddress(); break;            case OpCode.Ldelem_I1:             case OpCode.Ldelem_U1:             case OpCode.Ldelem_I2:             case OpCode.Ldelem_U2:             case OpCode.Ldelem_I4:             case OpCode.Ldelem_U4:             case OpCode.Ldelem_I8:             case OpCode.Ldelem_I:             case OpCode.Ldelem_R4:             case OpCode.Ldelem_R8:             case OpCode.Ldelem_Ref: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem_I:            case OpCode.Stelem_I1:            case OpCode.Stelem_I2:            case OpCode.Stelem_I4:            case OpCode.Stelem_I8:            case OpCode.Stelem_R4:            case OpCode.Stelem_R8:            case OpCode.Stelem_Ref: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Ldelem: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Unbox_Any: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.UnboxAny); break;            case OpCode.Conv_Ovf_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64); break;            case OpCode.Refanyval: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr); break;            case OpCode.Ckfinite: expr = this.ParseUnaryOperation(NodeType.Ckfinite); break;            case OpCode.Mkrefany: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference); break;            case OpCode.Ldtoken: expr = ParseLoadRuntimeMetadataToken(); break;            case OpCode.Conv_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Add_Ovf: expr = this.ParseBinaryOperation(NodeType.Add_Ovf); break;            case OpCode.Add_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Add_Ovf_Un); break;            case OpCode.Mul_Ovf: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf); break;            case OpCode.Mul_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf_Un); break;            case OpCode.Sub_Ovf: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf); break;            case OpCode.Sub_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf_Un); break;            case OpCode.Endfinally: statement = new EndFinally(); transferStatement = true; goto done;            case OpCode.Leave: statement = this.ParseBranch(NodeType.Nop' 0' false' false' true); transferStatement = true; goto done;            case OpCode.Leave_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false' true); transferStatement = true; goto done;            case OpCode.Stind_I: statement = this.ParseStoreIndirect(CoreSystemTypes.IntPtr); goto done;            case OpCode.Conv_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Arglist: expr = new Expression(NodeType.Arglist' CoreSystemTypes.ArgIterator); break;            case OpCode.Ceq: expr = this.ParseBinaryComparison(NodeType.Ceq); break;            case OpCode.Cgt: expr = this.ParseBinaryComparison(NodeType.Cgt); break;            case OpCode.Cgt_Un: expr = this.ParseBinaryComparison(NodeType.Cgt_Un); break;            case OpCode.Clt: expr = this.ParseBinaryComparison(NodeType.Clt); break;            case OpCode.Clt_Un: expr = this.ParseBinaryComparison(NodeType.Clt_Un); break;            case OpCode.Ldftn: expr = new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldvirtftn: expr = new BinaryExpression(PopOperand()' new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldarg: expr = this.Parameters((ushort)this.GetInt16()); break;            case OpCode.Ldarga: expr = SetType(new UnaryExpression(this.Parameters((ushort)this.GetInt16())' NodeType.AddressOf)); break;            case OpCode.Starg: statement = new AssignmentStatement(this.Parameters((ushort)this.GetInt16())' PopOperand()); goto done;            case OpCode.Ldloc: expr = this.locals[(ushort)this.GetInt16()]; break;            case OpCode.Ldloca: expr = SetType(new UnaryExpression(this.locals[(ushort)this.GetInt16()]' NodeType.AddressOf)); break;            case OpCode.Stloc: statement = new AssignmentStatement(this.locals[(ushort)this.GetInt16()]' PopOperand()); goto done;            case OpCode.Localloc: expr = new UnaryExpression(PopOperand()' NodeType.Localloc' CoreSystemTypes.Void); break;            case OpCode.Endfilter: statement = new EndFilter(PopOperand()); transferStatement = true; goto done;            case OpCode.Unaligned_: this.alignment = this.GetByte(); continue;            case OpCode.Volatile_: this.isVolatile = true; continue;            case OpCode.Tail_: this.isTailCall = true; continue;            case OpCode.Initobj: statement = this.ParseInitObject(); goto done;            case OpCode.Constrained_: this.constraint = this.GetMemberFromToken() as TypeNode; continue;            case OpCode.Cpblk: expr = this.ParseTernaryOperation(NodeType.Cpblk); goto done;            case OpCode.Initblk: expr = this.ParseTernaryOperation(NodeType.Initblk); goto done;            case OpCode.Rethrow: statement = new Throw(null); statement.NodeType = NodeType.Rethrow; transferStatement = true; goto done;            case OpCode.Sizeof: expr = new UnaryExpression(new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32); break;            case OpCode.Refanytype: expr = new UnaryExpression(PopOperand()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle); break;            case OpCode.Readonly_: this.isReadOnly = true; continue;            default: throw new InvalidMetadataException(ExceptionStrings.UnknownOpCode);          }          if (this.blockMap[this.counter+1] != null){            transferStatement = true; //Falls through to the next basic block' so implicitly a "transfer" statement            goto done;          }          //^ assume expr != null;  #if FxCop          expr.sourceContext = sourceContext;  #endif  #if FxCop || ILOFFSETS          expr.ILOffset = this.ilOffset;  #endif          this.operandStack.Push(expr);          this.isReadOnly = false;          this.isVolatile = false;          this.isTailCall = false;                  this.alignment = -1;        }
Magic Number,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseStatement,The following statement contains a magic number: while (true){          bool isStatement = false;          startingAddress = this.counter+1; //Add one so that it is never zero (the latter means no entry to the TrivialHashtable)  #if FxCop || ILOFFSETS          this.ilOffset = this.counter;          this.opCode = this.GetOpCode();  #else          OpCode opCode = this.GetOpCode();  #endif  #if FxCop          if (this.handlerMap.TryGetValue(this.ilOffset' out expr)){            expr.sourceContext = sourceContext;            expr.ILOffset = this.ilOffset;            this.operandStack.Push(expr);          }  #endif          switch (opCode){            case OpCode.Nop: statement = new Statement(NodeType.Nop); goto done;            case OpCode.Break: statement = new Statement(NodeType.DebugBreak); goto done;            case OpCode.Ldarg_0: expr = this.Parameters(0); break;            case OpCode.Ldarg_1: expr = this.Parameters(1); break;            case OpCode.Ldarg_2: expr = this.Parameters(2); break;            case OpCode.Ldarg_3: expr = this.Parameters(3); break;            case OpCode.Ldloc_0: expr = this.locals[0]; break;            case OpCode.Ldloc_1: expr = this.locals[1]; break;            case OpCode.Ldloc_2: expr = this.locals[2]; break;            case OpCode.Ldloc_3: expr = this.locals[3]; break;            case OpCode.Stloc_0: statement = new AssignmentStatement(this.locals[0]' PopOperand()); goto done;            case OpCode.Stloc_1: statement = new AssignmentStatement(this.locals[1]' PopOperand()); goto done;            case OpCode.Stloc_2: statement = new AssignmentStatement(this.locals[2]' PopOperand()); goto done;            case OpCode.Stloc_3: statement = new AssignmentStatement(this.locals[3]' PopOperand()); goto done;            case OpCode.Ldarg_S: expr = this.Parameters(this.GetByte()); break;            case OpCode.Ldarga_S: expr = SetType(new UnaryExpression(this.Parameters(this.GetByte())' NodeType.AddressOf)); break;            case OpCode.Starg_S: statement = new AssignmentStatement(this.Parameters(this.GetByte())' PopOperand()); goto done;            case OpCode.Ldloc_S: expr = this.locals[this.GetByte()]; break;            case OpCode.Ldloca_S: expr = SetType(new UnaryExpression(this.locals[this.GetByte()]' NodeType.AddressOf)); break;            case OpCode.Stloc_S: statement = new AssignmentStatement(this.locals[this.GetByte()]' PopOperand()); goto done;            case OpCode.Ldnull: expr = new Literal(null' CoreSystemTypes.Object); break;            case OpCode.Ldc_I4_M1: expr = new Literal(-1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_0: expr = new Literal(0' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_1: expr = new Literal(1' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_2: expr = new Literal(2' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_3: expr = new Literal(3' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_4: expr = new Literal(4' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_5: expr = new Literal(5' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_6: expr = new Literal(6' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_7: expr = new Literal(7' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_8: expr = new Literal(8' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4_S: expr = new Literal((int)this.GetSByte()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I4: expr = new Literal(this.GetInt32()' CoreSystemTypes.Int32); break;            case OpCode.Ldc_I8: expr = new Literal(this.GetInt64()' CoreSystemTypes.Int64); break;            case OpCode.Ldc_R4: expr = new Literal(this.GetSingle()' CoreSystemTypes.Single); break;            case OpCode.Ldc_R8: expr = new Literal(this.GetDouble()' CoreSystemTypes.Double); break;            case OpCode.Dup: statement = new ExpressionStatement(new Expression(NodeType.Dup)); goto done;            case OpCode.Pop: statement = new ExpressionStatement(new UnaryExpression(PopOperand()' NodeType.Pop)); goto done;            case OpCode.Jmp: expr = this.ParseCall(NodeType.Jmp' out isStatement); if (isStatement) goto done; break;            case OpCode.Call: expr = this.ParseCall(NodeType.Call' out isStatement); if (isStatement) goto done; break;            case OpCode.Calli: expr = this.ParseCalli(out isStatement); if (isStatement) goto done; break;            case OpCode.Ret:              Expression retVal = BodyParser.TypeIsVoid(this.method.ReturnType) ? null : PopOperand();              statement = new Return(retVal);               transferStatement = true; goto done;            case OpCode.Br_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false); transferStatement = true; goto done;            case OpCode.Brfalse_S: statement = this.ParseBranch(NodeType.LogicalNot' 1' true' false); transferStatement = true; goto done;            case OpCode.Brtrue_S: statement = this.ParseBranch(NodeType.Nop' 1' true' false); transferStatement = true; goto done;            case OpCode.Beq_S: statement = this.ParseBranch(NodeType.Eq' 2' true' false); transferStatement = true; goto done;            case OpCode.Bge_S: statement = this.ParseBranch(NodeType.Ge' 2' true' false); transferStatement = true; goto done;            case OpCode.Bgt_S: statement = this.ParseBranch(NodeType.Gt' 2' true' false); transferStatement = true; goto done;            case OpCode.Ble_S: statement = this.ParseBranch(NodeType.Le' 2' true' false); transferStatement = true; goto done;            case OpCode.Blt_S: statement = this.ParseBranch(NodeType.Lt' 2' true' false); transferStatement = true; goto done;            case OpCode.Bne_Un_S: statement = this.ParseBranch(NodeType.Ne' 2' true' true); transferStatement = true; goto done;            case OpCode.Bge_Un_S: statement = this.ParseBranch(NodeType.Ge' 2' true' true); transferStatement = true; goto done;            case OpCode.Bgt_Un_S: statement = this.ParseBranch(NodeType.Gt' 2' true' true); transferStatement = true; goto done;            case OpCode.Ble_Un_S: statement = this.ParseBranch(NodeType.Le' 2' true' true); transferStatement = true; goto done;            case OpCode.Blt_Un_S: statement = this.ParseBranch(NodeType.Lt' 2' true' true); transferStatement = true; goto done;            case OpCode.Br: statement = this.ParseBranch(NodeType.Nop' 0' false' false); transferStatement = true; goto done;            case OpCode.Brfalse: statement = this.ParseBranch(NodeType.LogicalNot' 1' false' false); transferStatement = true; goto done;            case OpCode.Brtrue: statement = this.ParseBranch(NodeType.Nop' 1' false' false); transferStatement = true; goto done;            case OpCode.Beq: statement = this.ParseBranch(NodeType.Eq' 2' false' false); transferStatement = true; goto done;            case OpCode.Bge: statement = this.ParseBranch(NodeType.Ge' 2' false' false); transferStatement = true; goto done;            case OpCode.Bgt: statement = this.ParseBranch(NodeType.Gt' 2' false' false); transferStatement = true; goto done;            case OpCode.Ble: statement = this.ParseBranch(NodeType.Le' 2' false' false); transferStatement = true; goto done;            case OpCode.Blt: statement = this.ParseBranch(NodeType.Lt' 2' false' false); transferStatement = true; goto done;            case OpCode.Bne_Un: statement = this.ParseBranch(NodeType.Ne' 2' false' true); transferStatement = true; goto done;            case OpCode.Bge_Un: statement = this.ParseBranch(NodeType.Ge' 2' false' true); transferStatement = true; goto done;            case OpCode.Bgt_Un: statement = this.ParseBranch(NodeType.Gt' 2' false' true); transferStatement = true; goto done;            case OpCode.Ble_Un: statement = this.ParseBranch(NodeType.Le' 2' false' true); transferStatement = true; goto done;            case OpCode.Blt_Un: statement = this.ParseBranch(NodeType.Lt' 2' false' true); transferStatement = true; goto done;            case OpCode.Switch: statement = this.ParseSwitchInstruction(); transferStatement = true; goto done;            case OpCode.Ldind_I1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U1: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt8' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U2: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt16' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_U4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.UInt32' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Int64' this.isVolatile' this.alignment); break;            case OpCode.Ldind_I: expr = new AddressDereference(PopOperand()' CoreSystemTypes.IntPtr' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R4: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Single' this.isVolatile' this.alignment); break;            case OpCode.Ldind_R8: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Double' this.isVolatile' this.alignment); break;            case OpCode.Ldind_Ref: expr = new AddressDereference(PopOperand()' CoreSystemTypes.Object' this.isVolatile' this.alignment); break;            case OpCode.Stind_Ref: statement = this.ParseStoreIndirect(CoreSystemTypes.Object); goto done;            case OpCode.Stind_I1: statement = this.ParseStoreIndirect(CoreSystemTypes.Int8); goto done;            case OpCode.Stind_I2: statement = this.ParseStoreIndirect(CoreSystemTypes.Int16); goto done;            case OpCode.Stind_I4: statement = this.ParseStoreIndirect(CoreSystemTypes.Int32); goto done;            case OpCode.Stind_I8: statement = this.ParseStoreIndirect(CoreSystemTypes.Int64); goto done;            case OpCode.Stind_R4: statement = this.ParseStoreIndirect(CoreSystemTypes.Single); goto done;            case OpCode.Stind_R8: statement = this.ParseStoreIndirect(CoreSystemTypes.Double); goto done;            case OpCode.Add: expr = this.ParseBinaryOperation(NodeType.Add); break;            case OpCode.Sub: expr = this.ParseBinaryOperation(NodeType.Sub); break;            case OpCode.Mul: expr = this.ParseBinaryOperation(NodeType.Mul); break;            case OpCode.Div: expr = this.ParseBinaryOperation(NodeType.Div); break;            case OpCode.Div_Un: expr = this.ParseBinaryOperation(NodeType.Div_Un); break;            case OpCode.Rem: expr = this.ParseBinaryOperation(NodeType.Rem); break;            case OpCode.Rem_Un: expr = this.ParseBinaryOperation(NodeType.Rem_Un); break;            case OpCode.And: expr = this.ParseBinaryOperation(NodeType.And); break;            case OpCode.Or: expr = this.ParseBinaryOperation(NodeType.Or); break;            case OpCode.Xor: expr = this.ParseBinaryOperation(NodeType.Xor); break;            case OpCode.Shl: expr = this.ParseBinaryOperation(NodeType.Shl); break;            case OpCode.Shr: expr = this.ParseBinaryOperation(NodeType.Shr); break;            case OpCode.Shr_Un: expr = this.ParseBinaryOperation(NodeType.Shr_Un); break;            case OpCode.Neg: expr = this.ParseUnaryOperation(NodeType.Neg); break;            case OpCode.Not: expr = this.ParseUnaryOperation(NodeType.Not); break;            case OpCode.Conv_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_R4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R4' CoreSystemTypes.Single); break;            case OpCode.Conv_R8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R8' CoreSystemTypes.Double); break;            case OpCode.Conv_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U8' CoreSystemTypes.UInt64); break;            case OpCode.Callvirt: expr = this.ParseCall(NodeType.Callvirt' out isStatement); if (isStatement) goto done; break;            case OpCode.Cpobj: statement = this.ParseCopyObject(); goto done;            case OpCode.Ldobj: expr = new AddressDereference(PopOperand()' (TypeNode)this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldstr: expr = new Literal(this.GetStringFromToken()' CoreSystemTypes.String); break;            case OpCode.Newobj: expr = this.ParseConstruct(); break;            case OpCode.Castclass: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Castclass); break;            case OpCode.Isinst: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Isinst); break;            case OpCode.Conv_R_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_R_Un' CoreSystemTypes.Double); break;            case OpCode.Unbox: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.Unbox); break;            case OpCode.Throw: statement = new Throw(PopOperand()); transferStatement = true; goto done;            case OpCode.Ldfld:               expr = new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment);              break;            case OpCode.Ldflda:               expr = SetType(new UnaryExpression(new MemberBinding(PopOperand()' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf));               break;            case OpCode.Stfld: statement = this.ParseStoreField(); goto done;            case OpCode.Ldsfld: expr = new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment); break;            case OpCode.Ldsflda: expr = SetType(new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' NodeType.AddressOf)); break;            case OpCode.Stsfld: statement = new AssignmentStatement(new MemberBinding(null' this.GetMemberFromToken()' this.isVolatile' this.alignment)' PopOperand()); goto done;            case OpCode.Stobj: statement = this.ParseStoreIndirect((TypeNode)this.GetMemberFromToken()); goto done;            case OpCode.Conv_Ovf_I1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1_Un' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_I2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2_Un' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_I4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4_Un' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_I8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8_Un' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U1_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1_Un' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_U2_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2_Un' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_U4_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4_Un' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_U8_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8_Un' CoreSystemTypes.UInt64); break;            case OpCode.Conv_Ovf_I_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I_Un' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U_Un: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U_Un' CoreSystemTypes.UIntPtr); break;            case OpCode.Box:               TypeNode t = (TypeNode)this.GetMemberFromToken();              TypeNode bt = t is EnumNode ? CoreSystemTypes.Enum : CoreSystemTypes.ValueType;              expr = new BinaryExpression(PopOperand()' new Literal(t' CoreSystemTypes.Type)' NodeType.Box' bt); break;            case OpCode.Newarr: expr = this.ParseNewArray(); break;            case OpCode.Ldlen: expr = new UnaryExpression(PopOperand()' NodeType.Ldlen' CoreSystemTypes.UIntPtr); break;            case OpCode.Ldelema: expr = this.ParseArrayElementLoadAddress(); break;            case OpCode.Ldelem_I1:             case OpCode.Ldelem_U1:             case OpCode.Ldelem_I2:             case OpCode.Ldelem_U2:             case OpCode.Ldelem_I4:             case OpCode.Ldelem_U4:             case OpCode.Ldelem_I8:             case OpCode.Ldelem_I:             case OpCode.Ldelem_R4:             case OpCode.Ldelem_R8:             case OpCode.Ldelem_Ref: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem_I:            case OpCode.Stelem_I1:            case OpCode.Stelem_I2:            case OpCode.Stelem_I4:            case OpCode.Stelem_I8:            case OpCode.Stelem_R4:            case OpCode.Stelem_R8:            case OpCode.Stelem_Ref: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Ldelem: expr = this.ParseArrayElementLoad(opCode' null); break;            case OpCode.Stelem: statement = this.ParseArrayElementAssignment(opCode); goto done;            case OpCode.Unbox_Any: expr = ParseTypeCheck(PopOperand()' (TypeNode)this.GetMemberFromToken()' NodeType.UnboxAny); break;            case OpCode.Conv_Ovf_I1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I1' CoreSystemTypes.Int8); break;            case OpCode.Conv_Ovf_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_Ovf_I2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I2' CoreSystemTypes.Int16); break;            case OpCode.Conv_Ovf_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_Ovf_I4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I4' CoreSystemTypes.Int32); break;            case OpCode.Conv_Ovf_U4: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U4' CoreSystemTypes.UInt32); break;            case OpCode.Conv_Ovf_I8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I8' CoreSystemTypes.Int64); break;            case OpCode.Conv_Ovf_U8: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U8' CoreSystemTypes.UInt64); break;            case OpCode.Refanyval: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Refanyval' CoreSystemTypes.IntPtr); break;            case OpCode.Ckfinite: expr = this.ParseUnaryOperation(NodeType.Ckfinite); break;            case OpCode.Mkrefany: expr = new BinaryExpression(PopOperand()' new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Mkrefany' CoreSystemTypes.DynamicallyTypedReference); break;            case OpCode.Ldtoken: expr = ParseLoadRuntimeMetadataToken(); break;            case OpCode.Conv_U2: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U2' CoreSystemTypes.UInt16); break;            case OpCode.Conv_U1: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U1' CoreSystemTypes.UInt8); break;            case OpCode.Conv_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_I: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_I' CoreSystemTypes.IntPtr); break;            case OpCode.Conv_Ovf_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_Ovf_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Add_Ovf: expr = this.ParseBinaryOperation(NodeType.Add_Ovf); break;            case OpCode.Add_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Add_Ovf_Un); break;            case OpCode.Mul_Ovf: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf); break;            case OpCode.Mul_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Mul_Ovf_Un); break;            case OpCode.Sub_Ovf: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf); break;            case OpCode.Sub_Ovf_Un: expr = this.ParseBinaryOperation(NodeType.Sub_Ovf_Un); break;            case OpCode.Endfinally: statement = new EndFinally(); transferStatement = true; goto done;            case OpCode.Leave: statement = this.ParseBranch(NodeType.Nop' 0' false' false' true); transferStatement = true; goto done;            case OpCode.Leave_S: statement = this.ParseBranch(NodeType.Nop' 0' true' false' true); transferStatement = true; goto done;            case OpCode.Stind_I: statement = this.ParseStoreIndirect(CoreSystemTypes.IntPtr); goto done;            case OpCode.Conv_U: expr = new UnaryExpression(PopOperand()' NodeType.Conv_U' CoreSystemTypes.UIntPtr); break;            case OpCode.Arglist: expr = new Expression(NodeType.Arglist' CoreSystemTypes.ArgIterator); break;            case OpCode.Ceq: expr = this.ParseBinaryComparison(NodeType.Ceq); break;            case OpCode.Cgt: expr = this.ParseBinaryComparison(NodeType.Cgt); break;            case OpCode.Cgt_Un: expr = this.ParseBinaryComparison(NodeType.Cgt_Un); break;            case OpCode.Clt: expr = this.ParseBinaryComparison(NodeType.Clt); break;            case OpCode.Clt_Un: expr = this.ParseBinaryComparison(NodeType.Clt_Un); break;            case OpCode.Ldftn: expr = new UnaryExpression(new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldvirtftn: expr = new BinaryExpression(PopOperand()' new MemberBinding(null' this.GetMemberFromToken())' NodeType.Ldvirtftn' CoreSystemTypes.IntPtr); break;            case OpCode.Ldarg: expr = this.Parameters((ushort)this.GetInt16()); break;            case OpCode.Ldarga: expr = SetType(new UnaryExpression(this.Parameters((ushort)this.GetInt16())' NodeType.AddressOf)); break;            case OpCode.Starg: statement = new AssignmentStatement(this.Parameters((ushort)this.GetInt16())' PopOperand()); goto done;            case OpCode.Ldloc: expr = this.locals[(ushort)this.GetInt16()]; break;            case OpCode.Ldloca: expr = SetType(new UnaryExpression(this.locals[(ushort)this.GetInt16()]' NodeType.AddressOf)); break;            case OpCode.Stloc: statement = new AssignmentStatement(this.locals[(ushort)this.GetInt16()]' PopOperand()); goto done;            case OpCode.Localloc: expr = new UnaryExpression(PopOperand()' NodeType.Localloc' CoreSystemTypes.Void); break;            case OpCode.Endfilter: statement = new EndFilter(PopOperand()); transferStatement = true; goto done;            case OpCode.Unaligned_: this.alignment = this.GetByte(); continue;            case OpCode.Volatile_: this.isVolatile = true; continue;            case OpCode.Tail_: this.isTailCall = true; continue;            case OpCode.Initobj: statement = this.ParseInitObject(); goto done;            case OpCode.Constrained_: this.constraint = this.GetMemberFromToken() as TypeNode; continue;            case OpCode.Cpblk: expr = this.ParseTernaryOperation(NodeType.Cpblk); goto done;            case OpCode.Initblk: expr = this.ParseTernaryOperation(NodeType.Initblk); goto done;            case OpCode.Rethrow: statement = new Throw(null); statement.NodeType = NodeType.Rethrow; transferStatement = true; goto done;            case OpCode.Sizeof: expr = new UnaryExpression(new Literal(this.GetMemberFromToken()' CoreSystemTypes.Type)' NodeType.Sizeof' CoreSystemTypes.Int32); break;            case OpCode.Refanytype: expr = new UnaryExpression(PopOperand()' NodeType.Refanytype' CoreSystemTypes.RuntimeTypeHandle); break;            case OpCode.Readonly_: this.isReadOnly = true; continue;            default: throw new InvalidMetadataException(ExceptionStrings.UnknownOpCode);          }          if (this.blockMap[this.counter+1] != null){            transferStatement = true; //Falls through to the next basic block' so implicitly a "transfer" statement            goto done;          }          //^ assume expr != null;  #if FxCop          expr.sourceContext = sourceContext;  #endif  #if FxCop || ILOFFSETS          expr.ILOffset = this.ilOffset;  #endif          this.operandStack.Push(expr);          this.isReadOnly = false;          this.isVolatile = false;          this.isTailCall = false;                  this.alignment = -1;        }
Magic Number,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseSwitchInstruction,The following statement contains a magic number: int offset = this.counter + numTargets*4;
Magic Number,Microsoft.Cci.Metadata,BodyParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,SkipSwitch,The following statement contains a magic number: int offset = this.counter + numCases*4;
Magic Number,Microsoft.Cci.Metadata,InstructionParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseExceptionHandlerEntry,The following statement contains a magic number: if (smallSection)          n = dataSize / 12;        else          n = (dataSize + (n << 8)) / 24;
Magic Number,Microsoft.Cci.Metadata,InstructionParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseExceptionHandlerEntry,The following statement contains a magic number: if (smallSection)          n = dataSize / 12;        else          n = (dataSize + (n << 8)) / 24;
Magic Number,Microsoft.Cci.Metadata,InstructionParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseExceptionHandlerEntry,The following statement contains a magic number: if (smallSection)          n = dataSize / 12;        else          n = (dataSize + (n << 8)) / 24;
Magic Number,Microsoft.Cci.Metadata,InstructionParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseExceptionHandlerEntry,The following statement contains a magic number: for (int i = 0; i < n; i++){          Instruction matchingInstruction;          int flags' tryOffset' tryLength' handlerOffset' handlerLength' tokenOrOffset;          if (smallSection){            flags = this.reader.tables.GetInt16();            tryOffset = this.reader.tables.GetUInt16();            tryLength = this.reader.tables.GetByte();            handlerOffset = this.reader.tables.GetUInt16();            handlerLength = this.reader.tables.GetByte();          }else{            flags = this.reader.tables.GetInt32();            tryOffset = this.reader.tables.GetInt32();            tryLength = this.reader.tables.GetInt32();            handlerOffset = this.reader.tables.GetInt32();            handlerLength = this.reader.tables.GetInt32();          }          tokenOrOffset = this.reader.tables.GetInt32();          if (tryMap[tryOffset+tryLength] == null){            matchingInstruction = this.AddInstruction(OpCode._Try' tryOffset' 5);            this.AddInstruction(OpCode._EndTry' tryOffset+tryLength' matchingInstruction' 3);            tryMap[tryOffset+tryLength] = String.Empty;          }          switch(flags){            case 0x00:               int pos = this.reader.tables.GetCurrentPosition();              TypeNode catchType = (TypeNode)this.reader.GetMemberFromToken(tokenOrOffset);              this.reader.tables.SetCurrentPosition(pos);              matchingInstruction = this.AddInstruction(OpCode._Catch' handlerOffset' catchType' 4);              this.AddInstruction(OpCode._EndHandler' handlerOffset+handlerLength' matchingInstruction' 2);              break;            case 0x01:              matchingInstruction = this.AddInstruction(OpCode._Filter' tokenOrOffset' 3);              this.AddInstruction(OpCode._EndFilter' handlerOffset' matchingInstruction' 1);              matchingInstruction = this.AddInstruction(OpCode._Catch' handlerOffset' 4);              this.AddInstruction(OpCode._EndHandler' handlerOffset+handlerLength' matchingInstruction' 2);              break;            case 0x02:              matchingInstruction = this.AddInstruction(OpCode._Finally' handlerOffset' 4);              this.AddInstruction(OpCode._EndHandler' handlerOffset+handlerLength' matchingInstruction' 2);              break;            case 0x04:              matchingInstruction = this.AddInstruction(OpCode._Fault' handlerOffset' 4);              this.AddInstruction(OpCode._EndHandler' handlerOffset+handlerLength' matchingInstruction' 2);              break;            default: throw new InvalidMetadataException(ExceptionStrings.BadExceptionHandlerType);          }        }
Magic Number,Microsoft.Cci.Metadata,InstructionParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseExceptionHandlerEntry,The following statement contains a magic number: for (int i = 0; i < n; i++){          Instruction matchingInstruction;          int flags' tryOffset' tryLength' handlerOffset' handlerLength' tokenOrOffset;          if (smallSection){            flags = this.reader.tables.GetInt16();            tryOffset = this.reader.tables.GetUInt16();            tryLength = this.reader.tables.GetByte();            handlerOffset = this.reader.tables.GetUInt16();            handlerLength = this.reader.tables.GetByte();          }else{            flags = this.reader.tables.GetInt32();            tryOffset = this.reader.tables.GetInt32();            tryLength = this.reader.tables.GetInt32();            handlerOffset = this.reader.tables.GetInt32();            handlerLength = this.reader.tables.GetInt32();          }          tokenOrOffset = this.reader.tables.GetInt32();          if (tryMap[tryOffset+tryLength] == null){            matchingInstruction = this.AddInstruction(OpCode._Try' tryOffset' 5);            this.AddInstruction(OpCode._EndTry' tryOffset+tryLength' matchingInstruction' 3);            tryMap[tryOffset+tryLength] = String.Empty;          }          switch(flags){            case 0x00:               int pos = this.reader.tables.GetCurrentPosition();              TypeNode catchType = (TypeNode)this.reader.GetMemberFromToken(tokenOrOffset);              this.reader.tables.SetCurrentPosition(pos);              matchingInstruction = this.AddInstruction(OpCode._Catch' handlerOffset' catchType' 4);              this.AddInstruction(OpCode._EndHandler' handlerOffset+handlerLength' matchingInstruction' 2);              break;            case 0x01:              matchingInstruction = this.AddInstruction(OpCode._Filter' tokenOrOffset' 3);              this.AddInstruction(OpCode._EndFilter' handlerOffset' matchingInstruction' 1);              matchingInstruction = this.AddInstruction(OpCode._Catch' handlerOffset' 4);              this.AddInstruction(OpCode._EndHandler' handlerOffset+handlerLength' matchingInstruction' 2);              break;            case 0x02:              matchingInstruction = this.AddInstruction(OpCode._Finally' handlerOffset' 4);              this.AddInstruction(OpCode._EndHandler' handlerOffset+handlerLength' matchingInstruction' 2);              break;            case 0x04:              matchingInstruction = this.AddInstruction(OpCode._Fault' handlerOffset' 4);              this.AddInstruction(OpCode._EndHandler' handlerOffset+handlerLength' matchingInstruction' 2);              break;            default: throw new InvalidMetadataException(ExceptionStrings.BadExceptionHandlerType);          }        }
Magic Number,Microsoft.Cci.Metadata,InstructionParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseExceptionHandlerEntry,The following statement contains a magic number: for (int i = 0; i < n; i++){          Instruction matchingInstruction;          int flags' tryOffset' tryLength' handlerOffset' handlerLength' tokenOrOffset;          if (smallSection){            flags = this.reader.tables.GetInt16();            tryOffset = this.reader.tables.GetUInt16();            tryLength = this.reader.tables.GetByte();            handlerOffset = this.reader.tables.GetUInt16();            handlerLength = this.reader.tables.GetByte();          }else{            flags = this.reader.tables.GetInt32();            tryOffset = this.reader.tables.GetInt32();            tryLength = this.reader.tables.GetInt32();            handlerOffset = this.reader.tables.GetInt32();            handlerLength = this.reader.tables.GetInt32();          }          tokenOrOffset = this.reader.tables.GetInt32();          if (tryMap[tryOffset+tryLength] == null){            matchingInstruction = this.AddInstruction(OpCode._Try' tryOffset' 5);            this.AddInstruction(OpCode._EndTry' tryOffset+tryLength' matchingInstruction' 3);            tryMap[tryOffset+tryLength] = String.Empty;          }          switch(flags){            case 0x00:               int pos = this.reader.tables.GetCurrentPosition();              TypeNode catchType = (TypeNode)this.reader.GetMemberFromToken(tokenOrOffset);              this.reader.tables.SetCurrentPosition(pos);              matchingInstruction = this.AddInstruction(OpCode._Catch' handlerOffset' catchType' 4);              this.AddInstruction(OpCode._EndHandler' handlerOffset+handlerLength' matchingInstruction' 2);              break;            case 0x01:              matchingInstruction = this.AddInstruction(OpCode._Filter' tokenOrOffset' 3);              this.AddInstruction(OpCode._EndFilter' handlerOffset' matchingInstruction' 1);              matchingInstruction = this.AddInstruction(OpCode._Catch' handlerOffset' 4);              this.AddInstruction(OpCode._EndHandler' handlerOffset+handlerLength' matchingInstruction' 2);              break;            case 0x02:              matchingInstruction = this.AddInstruction(OpCode._Finally' handlerOffset' 4);              this.AddInstruction(OpCode._EndHandler' handlerOffset+handlerLength' matchingInstruction' 2);              break;            case 0x04:              matchingInstruction = this.AddInstruction(OpCode._Fault' handlerOffset' 4);              this.AddInstruction(OpCode._EndHandler' handlerOffset+handlerLength' matchingInstruction' 2);              break;            default: throw new InvalidMetadataException(ExceptionStrings.BadExceptionHandlerType);          }        }
Magic Number,Microsoft.Cci.Metadata,InstructionParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseExceptionHandlerEntry,The following statement contains a magic number: for (int i = 0; i < n; i++){          Instruction matchingInstruction;          int flags' tryOffset' tryLength' handlerOffset' handlerLength' tokenOrOffset;          if (smallSection){            flags = this.reader.tables.GetInt16();            tryOffset = this.reader.tables.GetUInt16();            tryLength = this.reader.tables.GetByte();            handlerOffset = this.reader.tables.GetUInt16();            handlerLength = this.reader.tables.GetByte();          }else{            flags = this.reader.tables.GetInt32();            tryOffset = this.reader.tables.GetInt32();            tryLength = this.reader.tables.GetInt32();            handlerOffset = this.reader.tables.GetInt32();            handlerLength = this.reader.tables.GetInt32();          }          tokenOrOffset = this.reader.tables.GetInt32();          if (tryMap[tryOffset+tryLength] == null){            matchingInstruction = this.AddInstruction(OpCode._Try' tryOffset' 5);            this.AddInstruction(OpCode._EndTry' tryOffset+tryLength' matchingInstruction' 3);            tryMap[tryOffset+tryLength] = String.Empty;          }          switch(flags){            case 0x00:               int pos = this.reader.tables.GetCurrentPosition();              TypeNode catchType = (TypeNode)this.reader.GetMemberFromToken(tokenOrOffset);              this.reader.tables.SetCurrentPosition(pos);              matchingInstruction = this.AddInstruction(OpCode._Catch' handlerOffset' catchType' 4);              this.AddInstruction(OpCode._EndHandler' handlerOffset+handlerLength' matchingInstruction' 2);              break;            case 0x01:              matchingInstruction = this.AddInstruction(OpCode._Filter' tokenOrOffset' 3);              this.AddInstruction(OpCode._EndFilter' handlerOffset' matchingInstruction' 1);              matchingInstruction = this.AddInstruction(OpCode._Catch' handlerOffset' 4);              this.AddInstruction(OpCode._EndHandler' handlerOffset+handlerLength' matchingInstruction' 2);              break;            case 0x02:              matchingInstruction = this.AddInstruction(OpCode._Finally' handlerOffset' 4);              this.AddInstruction(OpCode._EndHandler' handlerOffset+handlerLength' matchingInstruction' 2);              break;            case 0x04:              matchingInstruction = this.AddInstruction(OpCode._Fault' handlerOffset' 4);              this.AddInstruction(OpCode._EndHandler' handlerOffset+handlerLength' matchingInstruction' 2);              break;            default: throw new InvalidMetadataException(ExceptionStrings.BadExceptionHandlerType);          }        }
Magic Number,Microsoft.Cci.Metadata,InstructionParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseExceptionHandlerEntry,The following statement contains a magic number: for (int i = 0; i < n; i++){          Instruction matchingInstruction;          int flags' tryOffset' tryLength' handlerOffset' handlerLength' tokenOrOffset;          if (smallSection){            flags = this.reader.tables.GetInt16();            tryOffset = this.reader.tables.GetUInt16();            tryLength = this.reader.tables.GetByte();            handlerOffset = this.reader.tables.GetUInt16();            handlerLength = this.reader.tables.GetByte();          }else{            flags = this.reader.tables.GetInt32();            tryOffset = this.reader.tables.GetInt32();            tryLength = this.reader.tables.GetInt32();            handlerOffset = this.reader.tables.GetInt32();            handlerLength = this.reader.tables.GetInt32();          }          tokenOrOffset = this.reader.tables.GetInt32();          if (tryMap[tryOffset+tryLength] == null){            matchingInstruction = this.AddInstruction(OpCode._Try' tryOffset' 5);            this.AddInstruction(OpCode._EndTry' tryOffset+tryLength' matchingInstruction' 3);            tryMap[tryOffset+tryLength] = String.Empty;          }          switch(flags){            case 0x00:               int pos = this.reader.tables.GetCurrentPosition();              TypeNode catchType = (TypeNode)this.reader.GetMemberFromToken(tokenOrOffset);              this.reader.tables.SetCurrentPosition(pos);              matchingInstruction = this.AddInstruction(OpCode._Catch' handlerOffset' catchType' 4);              this.AddInstruction(OpCode._EndHandler' handlerOffset+handlerLength' matchingInstruction' 2);              break;            case 0x01:              matchingInstruction = this.AddInstruction(OpCode._Filter' tokenOrOffset' 3);              this.AddInstruction(OpCode._EndFilter' handlerOffset' matchingInstruction' 1);              matchingInstruction = this.AddInstruction(OpCode._Catch' handlerOffset' 4);              this.AddInstruction(OpCode._EndHandler' handlerOffset+handlerLength' matchingInstruction' 2);              break;            case 0x02:              matchingInstruction = this.AddInstruction(OpCode._Finally' handlerOffset' 4);              this.AddInstruction(OpCode._EndHandler' handlerOffset+handlerLength' matchingInstruction' 2);              break;            case 0x04:              matchingInstruction = this.AddInstruction(OpCode._Fault' handlerOffset' 4);              this.AddInstruction(OpCode._EndHandler' handlerOffset+handlerLength' matchingInstruction' 2);              break;            default: throw new InvalidMetadataException(ExceptionStrings.BadExceptionHandlerType);          }        }
Magic Number,Microsoft.Cci.Metadata,InstructionParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseExceptionHandlerEntry,The following statement contains a magic number: for (int i = 0; i < n; i++){          Instruction matchingInstruction;          int flags' tryOffset' tryLength' handlerOffset' handlerLength' tokenOrOffset;          if (smallSection){            flags = this.reader.tables.GetInt16();            tryOffset = this.reader.tables.GetUInt16();            tryLength = this.reader.tables.GetByte();            handlerOffset = this.reader.tables.GetUInt16();            handlerLength = this.reader.tables.GetByte();          }else{            flags = this.reader.tables.GetInt32();            tryOffset = this.reader.tables.GetInt32();            tryLength = this.reader.tables.GetInt32();            handlerOffset = this.reader.tables.GetInt32();            handlerLength = this.reader.tables.GetInt32();          }          tokenOrOffset = this.reader.tables.GetInt32();          if (tryMap[tryOffset+tryLength] == null){            matchingInstruction = this.AddInstruction(OpCode._Try' tryOffset' 5);            this.AddInstruction(OpCode._EndTry' tryOffset+tryLength' matchingInstruction' 3);            tryMap[tryOffset+tryLength] = String.Empty;          }          switch(flags){            case 0x00:               int pos = this.reader.tables.GetCurrentPosition();              TypeNode catchType = (TypeNode)this.reader.GetMemberFromToken(tokenOrOffset);              this.reader.tables.SetCurrentPosition(pos);              matchingInstruction = this.AddInstruction(OpCode._Catch' handlerOffset' catchType' 4);              this.AddInstruction(OpCode._EndHandler' handlerOffset+handlerLength' matchingInstruction' 2);              break;            case 0x01:              matchingInstruction = this.AddInstruction(OpCode._Filter' tokenOrOffset' 3);              this.AddInstruction(OpCode._EndFilter' handlerOffset' matchingInstruction' 1);              matchingInstruction = this.AddInstruction(OpCode._Catch' handlerOffset' 4);              this.AddInstruction(OpCode._EndHandler' handlerOffset+handlerLength' matchingInstruction' 2);              break;            case 0x02:              matchingInstruction = this.AddInstruction(OpCode._Finally' handlerOffset' 4);              this.AddInstruction(OpCode._EndHandler' handlerOffset+handlerLength' matchingInstruction' 2);              break;            case 0x04:              matchingInstruction = this.AddInstruction(OpCode._Fault' handlerOffset' 4);              this.AddInstruction(OpCode._EndHandler' handlerOffset+handlerLength' matchingInstruction' 2);              break;            default: throw new InvalidMetadataException(ExceptionStrings.BadExceptionHandlerType);          }        }
Magic Number,Microsoft.Cci.Metadata,InstructionParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseExceptionHandlerEntry,The following statement contains a magic number: for (int i = 0; i < n; i++){          Instruction matchingInstruction;          int flags' tryOffset' tryLength' handlerOffset' handlerLength' tokenOrOffset;          if (smallSection){            flags = this.reader.tables.GetInt16();            tryOffset = this.reader.tables.GetUInt16();            tryLength = this.reader.tables.GetByte();            handlerOffset = this.reader.tables.GetUInt16();            handlerLength = this.reader.tables.GetByte();          }else{            flags = this.reader.tables.GetInt32();            tryOffset = this.reader.tables.GetInt32();            tryLength = this.reader.tables.GetInt32();            handlerOffset = this.reader.tables.GetInt32();            handlerLength = this.reader.tables.GetInt32();          }          tokenOrOffset = this.reader.tables.GetInt32();          if (tryMap[tryOffset+tryLength] == null){            matchingInstruction = this.AddInstruction(OpCode._Try' tryOffset' 5);            this.AddInstruction(OpCode._EndTry' tryOffset+tryLength' matchingInstruction' 3);            tryMap[tryOffset+tryLength] = String.Empty;          }          switch(flags){            case 0x00:               int pos = this.reader.tables.GetCurrentPosition();              TypeNode catchType = (TypeNode)this.reader.GetMemberFromToken(tokenOrOffset);              this.reader.tables.SetCurrentPosition(pos);              matchingInstruction = this.AddInstruction(OpCode._Catch' handlerOffset' catchType' 4);              this.AddInstruction(OpCode._EndHandler' handlerOffset+handlerLength' matchingInstruction' 2);              break;            case 0x01:              matchingInstruction = this.AddInstruction(OpCode._Filter' tokenOrOffset' 3);              this.AddInstruction(OpCode._EndFilter' handlerOffset' matchingInstruction' 1);              matchingInstruction = this.AddInstruction(OpCode._Catch' handlerOffset' 4);              this.AddInstruction(OpCode._EndHandler' handlerOffset+handlerLength' matchingInstruction' 2);              break;            case 0x02:              matchingInstruction = this.AddInstruction(OpCode._Finally' handlerOffset' 4);              this.AddInstruction(OpCode._EndHandler' handlerOffset+handlerLength' matchingInstruction' 2);              break;            case 0x04:              matchingInstruction = this.AddInstruction(OpCode._Fault' handlerOffset' 4);              this.AddInstruction(OpCode._EndHandler' handlerOffset+handlerLength' matchingInstruction' 2);              break;            default: throw new InvalidMetadataException(ExceptionStrings.BadExceptionHandlerType);          }        }
Magic Number,Microsoft.Cci.Metadata,InstructionParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseExceptionHandlerEntry,The following statement contains a magic number: for (int i = 0; i < n; i++){          Instruction matchingInstruction;          int flags' tryOffset' tryLength' handlerOffset' handlerLength' tokenOrOffset;          if (smallSection){            flags = this.reader.tables.GetInt16();            tryOffset = this.reader.tables.GetUInt16();            tryLength = this.reader.tables.GetByte();            handlerOffset = this.reader.tables.GetUInt16();            handlerLength = this.reader.tables.GetByte();          }else{            flags = this.reader.tables.GetInt32();            tryOffset = this.reader.tables.GetInt32();            tryLength = this.reader.tables.GetInt32();            handlerOffset = this.reader.tables.GetInt32();            handlerLength = this.reader.tables.GetInt32();          }          tokenOrOffset = this.reader.tables.GetInt32();          if (tryMap[tryOffset+tryLength] == null){            matchingInstruction = this.AddInstruction(OpCode._Try' tryOffset' 5);            this.AddInstruction(OpCode._EndTry' tryOffset+tryLength' matchingInstruction' 3);            tryMap[tryOffset+tryLength] = String.Empty;          }          switch(flags){            case 0x00:               int pos = this.reader.tables.GetCurrentPosition();              TypeNode catchType = (TypeNode)this.reader.GetMemberFromToken(tokenOrOffset);              this.reader.tables.SetCurrentPosition(pos);              matchingInstruction = this.AddInstruction(OpCode._Catch' handlerOffset' catchType' 4);              this.AddInstruction(OpCode._EndHandler' handlerOffset+handlerLength' matchingInstruction' 2);              break;            case 0x01:              matchingInstruction = this.AddInstruction(OpCode._Filter' tokenOrOffset' 3);              this.AddInstruction(OpCode._EndFilter' handlerOffset' matchingInstruction' 1);              matchingInstruction = this.AddInstruction(OpCode._Catch' handlerOffset' 4);              this.AddInstruction(OpCode._EndHandler' handlerOffset+handlerLength' matchingInstruction' 2);              break;            case 0x02:              matchingInstruction = this.AddInstruction(OpCode._Finally' handlerOffset' 4);              this.AddInstruction(OpCode._EndHandler' handlerOffset+handlerLength' matchingInstruction' 2);              break;            case 0x04:              matchingInstruction = this.AddInstruction(OpCode._Fault' handlerOffset' 4);              this.AddInstruction(OpCode._EndHandler' handlerOffset+handlerLength' matchingInstruction' 2);              break;            default: throw new InvalidMetadataException(ExceptionStrings.BadExceptionHandlerType);          }        }
Magic Number,Microsoft.Cci.Metadata,InstructionParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseExceptionHandlerEntry,The following statement contains a magic number: for (int i = 0; i < n; i++){          Instruction matchingInstruction;          int flags' tryOffset' tryLength' handlerOffset' handlerLength' tokenOrOffset;          if (smallSection){            flags = this.reader.tables.GetInt16();            tryOffset = this.reader.tables.GetUInt16();            tryLength = this.reader.tables.GetByte();            handlerOffset = this.reader.tables.GetUInt16();            handlerLength = this.reader.tables.GetByte();          }else{            flags = this.reader.tables.GetInt32();            tryOffset = this.reader.tables.GetInt32();            tryLength = this.reader.tables.GetInt32();            handlerOffset = this.reader.tables.GetInt32();            handlerLength = this.reader.tables.GetInt32();          }          tokenOrOffset = this.reader.tables.GetInt32();          if (tryMap[tryOffset+tryLength] == null){            matchingInstruction = this.AddInstruction(OpCode._Try' tryOffset' 5);            this.AddInstruction(OpCode._EndTry' tryOffset+tryLength' matchingInstruction' 3);            tryMap[tryOffset+tryLength] = String.Empty;          }          switch(flags){            case 0x00:               int pos = this.reader.tables.GetCurrentPosition();              TypeNode catchType = (TypeNode)this.reader.GetMemberFromToken(tokenOrOffset);              this.reader.tables.SetCurrentPosition(pos);              matchingInstruction = this.AddInstruction(OpCode._Catch' handlerOffset' catchType' 4);              this.AddInstruction(OpCode._EndHandler' handlerOffset+handlerLength' matchingInstruction' 2);              break;            case 0x01:              matchingInstruction = this.AddInstruction(OpCode._Filter' tokenOrOffset' 3);              this.AddInstruction(OpCode._EndFilter' handlerOffset' matchingInstruction' 1);              matchingInstruction = this.AddInstruction(OpCode._Catch' handlerOffset' 4);              this.AddInstruction(OpCode._EndHandler' handlerOffset+handlerLength' matchingInstruction' 2);              break;            case 0x02:              matchingInstruction = this.AddInstruction(OpCode._Finally' handlerOffset' 4);              this.AddInstruction(OpCode._EndHandler' handlerOffset+handlerLength' matchingInstruction' 2);              break;            case 0x04:              matchingInstruction = this.AddInstruction(OpCode._Fault' handlerOffset' 4);              this.AddInstruction(OpCode._EndHandler' handlerOffset+handlerLength' matchingInstruction' 2);              break;            default: throw new InvalidMetadataException(ExceptionStrings.BadExceptionHandlerType);          }        }
Magic Number,Microsoft.Cci.Metadata,InstructionParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseExceptionHandlerEntry,The following statement contains a magic number: for (int i = 0; i < n; i++){          Instruction matchingInstruction;          int flags' tryOffset' tryLength' handlerOffset' handlerLength' tokenOrOffset;          if (smallSection){            flags = this.reader.tables.GetInt16();            tryOffset = this.reader.tables.GetUInt16();            tryLength = this.reader.tables.GetByte();            handlerOffset = this.reader.tables.GetUInt16();            handlerLength = this.reader.tables.GetByte();          }else{            flags = this.reader.tables.GetInt32();            tryOffset = this.reader.tables.GetInt32();            tryLength = this.reader.tables.GetInt32();            handlerOffset = this.reader.tables.GetInt32();            handlerLength = this.reader.tables.GetInt32();          }          tokenOrOffset = this.reader.tables.GetInt32();          if (tryMap[tryOffset+tryLength] == null){            matchingInstruction = this.AddInstruction(OpCode._Try' tryOffset' 5);            this.AddInstruction(OpCode._EndTry' tryOffset+tryLength' matchingInstruction' 3);            tryMap[tryOffset+tryLength] = String.Empty;          }          switch(flags){            case 0x00:               int pos = this.reader.tables.GetCurrentPosition();              TypeNode catchType = (TypeNode)this.reader.GetMemberFromToken(tokenOrOffset);              this.reader.tables.SetCurrentPosition(pos);              matchingInstruction = this.AddInstruction(OpCode._Catch' handlerOffset' catchType' 4);              this.AddInstruction(OpCode._EndHandler' handlerOffset+handlerLength' matchingInstruction' 2);              break;            case 0x01:              matchingInstruction = this.AddInstruction(OpCode._Filter' tokenOrOffset' 3);              this.AddInstruction(OpCode._EndFilter' handlerOffset' matchingInstruction' 1);              matchingInstruction = this.AddInstruction(OpCode._Catch' handlerOffset' 4);              this.AddInstruction(OpCode._EndHandler' handlerOffset+handlerLength' matchingInstruction' 2);              break;            case 0x02:              matchingInstruction = this.AddInstruction(OpCode._Finally' handlerOffset' 4);              this.AddInstruction(OpCode._EndHandler' handlerOffset+handlerLength' matchingInstruction' 2);              break;            case 0x04:              matchingInstruction = this.AddInstruction(OpCode._Fault' handlerOffset' 4);              this.AddInstruction(OpCode._EndHandler' handlerOffset+handlerLength' matchingInstruction' 2);              break;            default: throw new InvalidMetadataException(ExceptionStrings.BadExceptionHandlerType);          }        }
Magic Number,Microsoft.Cci.Metadata,InstructionParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseExceptionHandlerEntry,The following statement contains a magic number: for (int i = 0; i < n; i++){          Instruction matchingInstruction;          int flags' tryOffset' tryLength' handlerOffset' handlerLength' tokenOrOffset;          if (smallSection){            flags = this.reader.tables.GetInt16();            tryOffset = this.reader.tables.GetUInt16();            tryLength = this.reader.tables.GetByte();            handlerOffset = this.reader.tables.GetUInt16();            handlerLength = this.reader.tables.GetByte();          }else{            flags = this.reader.tables.GetInt32();            tryOffset = this.reader.tables.GetInt32();            tryLength = this.reader.tables.GetInt32();            handlerOffset = this.reader.tables.GetInt32();            handlerLength = this.reader.tables.GetInt32();          }          tokenOrOffset = this.reader.tables.GetInt32();          if (tryMap[tryOffset+tryLength] == null){            matchingInstruction = this.AddInstruction(OpCode._Try' tryOffset' 5);            this.AddInstruction(OpCode._EndTry' tryOffset+tryLength' matchingInstruction' 3);            tryMap[tryOffset+tryLength] = String.Empty;          }          switch(flags){            case 0x00:               int pos = this.reader.tables.GetCurrentPosition();              TypeNode catchType = (TypeNode)this.reader.GetMemberFromToken(tokenOrOffset);              this.reader.tables.SetCurrentPosition(pos);              matchingInstruction = this.AddInstruction(OpCode._Catch' handlerOffset' catchType' 4);              this.AddInstruction(OpCode._EndHandler' handlerOffset+handlerLength' matchingInstruction' 2);              break;            case 0x01:              matchingInstruction = this.AddInstruction(OpCode._Filter' tokenOrOffset' 3);              this.AddInstruction(OpCode._EndFilter' handlerOffset' matchingInstruction' 1);              matchingInstruction = this.AddInstruction(OpCode._Catch' handlerOffset' 4);              this.AddInstruction(OpCode._EndHandler' handlerOffset+handlerLength' matchingInstruction' 2);              break;            case 0x02:              matchingInstruction = this.AddInstruction(OpCode._Finally' handlerOffset' 4);              this.AddInstruction(OpCode._EndHandler' handlerOffset+handlerLength' matchingInstruction' 2);              break;            case 0x04:              matchingInstruction = this.AddInstruction(OpCode._Fault' handlerOffset' 4);              this.AddInstruction(OpCode._EndHandler' handlerOffset+handlerLength' matchingInstruction' 2);              break;            default: throw new InvalidMetadataException(ExceptionStrings.BadExceptionHandlerType);          }        }
Magic Number,Microsoft.Cci.Metadata,InstructionParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,AddInstruction,The following statement contains a magic number: if (!instructionPriority.TryGetValue(priority' out instructions)) {           instructions = new InstructionList(2);           instructionPriority.Add(priority' instructions);        }
Magic Number,Microsoft.Cci.Metadata,InstructionParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseSwitchInstruction,The following statement contains a magic number: int offset = this.counter + numTargets*4;
Magic Number,Microsoft.Cci.Metadata,InstructionParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseInstruction,The following statement contains a magic number: switch(opCode){          case OpCode.Nop:          case OpCode.Break:             break;          case OpCode.Ldarg_0: value = this.Parameters(0); break;          case OpCode.Ldarg_1: value = this.Parameters(1); break;          case OpCode.Ldarg_2: value = this.Parameters(2); break;           case OpCode.Ldarg_3: value = this.Parameters(3); break;          case OpCode.Ldloc_0: value = this.locals[0]; break;          case OpCode.Ldloc_1: value = this.locals[1]; break;          case OpCode.Ldloc_2: value = this.locals[2]; break;          case OpCode.Ldloc_3: value = this.locals[3]; break;          case OpCode.Stloc_0: value = this.locals[0]; break;          case OpCode.Stloc_1: value = this.locals[1]; break;          case OpCode.Stloc_2: value = this.locals[2]; break;          case OpCode.Stloc_3: value = this.locals[3]; break;          case OpCode.Ldarg_S:            case OpCode.Ldarga_S:          case OpCode.Starg_S:            value = this.Parameters(this.GetByte()); break;          case OpCode.Ldloc_S:          case OpCode.Ldloca_S:          case OpCode.Stloc_S:            value = this.locals[this.GetByte()]; break;          case OpCode.Ldnull:             break;          case OpCode.Ldc_I4_M1: value = (Int32)(-1); break;          case OpCode.Ldc_I4_0: value = (Int32)0; break;          case OpCode.Ldc_I4_1: value = (Int32)1; break;          case OpCode.Ldc_I4_2: value = (Int32)2; break;          case OpCode.Ldc_I4_3: value = (Int32)3; break;          case OpCode.Ldc_I4_4: value = (Int32)4; break;          case OpCode.Ldc_I4_5: value = (Int32)5; break;          case OpCode.Ldc_I4_6: value = (Int32)6; break;          case OpCode.Ldc_I4_7: value = (Int32)7; break;          case OpCode.Ldc_I4_8: value = (Int32)8; break;          case OpCode.Ldc_I4_S: value = (Int32)this.GetSByte(); break;          case OpCode.Ldc_I4: value = this.GetInt32(); break;          case OpCode.Ldc_I8: value = this.GetInt64(); break;          case OpCode.Ldc_R4: value = this.GetSingle(); break;          case OpCode.Ldc_R8: value = this.GetDouble(); break;          case OpCode.Dup:          case OpCode.Pop:             break;          case OpCode.Jmp:           case OpCode.Call:            value = (Method)this.GetMemberFromToken(); break;          case OpCode.Calli:             value = (FunctionPointer)this.reader.GetCalliSignature(this.GetInt32()); break;          case OpCode.Ret: break;          case OpCode.Br_S:          case OpCode.Brfalse_S:          case OpCode.Brtrue_S:          case OpCode.Beq_S:          case OpCode.Bge_S:          case OpCode.Bgt_S:          case OpCode.Ble_S:          case OpCode.Blt_S:          case OpCode.Bne_Un_S:          case OpCode.Bge_Un_S:          case OpCode.Bgt_Un_S:          case OpCode.Ble_Un_S:          case OpCode.Blt_Un_S:            value = this.counter + 1 + this.GetSByte(); break;          case OpCode.Br:          case OpCode.Brfalse:          case OpCode.Brtrue:          case OpCode.Beq:          case OpCode.Bge:          case OpCode.Bgt:          case OpCode.Ble:          case OpCode.Blt:          case OpCode.Bne_Un:          case OpCode.Bge_Un:          case OpCode.Bgt_Un:          case OpCode.Ble_Un:          case OpCode.Blt_Un:            value = this.counter + 4 + this.GetInt32(); break;          case OpCode.Switch: value = this.ParseSwitchInstruction(); break;                  case OpCode.Ldind_I1:           case OpCode.Ldind_U1:          case OpCode.Ldind_I2:          case OpCode.Ldind_U2:          case OpCode.Ldind_I4:          case OpCode.Ldind_U4:          case OpCode.Ldind_I8:          case OpCode.Ldind_I:          case OpCode.Ldind_R4:          case OpCode.Ldind_R8:          case OpCode.Ldind_Ref:          case OpCode.Stind_Ref:          case OpCode.Stind_I1:          case OpCode.Stind_I2:          case OpCode.Stind_I4:          case OpCode.Stind_I8:          case OpCode.Stind_R4:          case OpCode.Stind_R8:          case OpCode.Add:          case OpCode.Sub:          case OpCode.Mul:          case OpCode.Div:          case OpCode.Div_Un:          case OpCode.Rem:          case OpCode.Rem_Un:          case OpCode.And:          case OpCode.Or:          case OpCode.Xor:          case OpCode.Shl:          case OpCode.Shr:          case OpCode.Shr_Un:          case OpCode.Neg:          case OpCode.Not:          case OpCode.Conv_I1:          case OpCode.Conv_I2:          case OpCode.Conv_I4:          case OpCode.Conv_I8:          case OpCode.Conv_R4:          case OpCode.Conv_R8:          case OpCode.Conv_U4:          case OpCode.Conv_U8:            break;          case OpCode.Callvirt: value = (Method)this.GetMemberFromToken(); break;          case OpCode.Cpobj:          case OpCode.Ldobj:             value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Ldstr: value = this.GetStringFromToken(); break;                    case OpCode.Newobj: value = (Method)this.GetMemberFromToken();break;          case OpCode.Castclass:          case OpCode.Isinst:             value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Conv_R_Un: break;                 case OpCode.Unbox: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Throw: break;          case OpCode.Ldfld:           case OpCode.Ldflda:          case OpCode.Stfld:          case OpCode.Ldsfld:          case OpCode.Ldsflda:          case OpCode.Stsfld:          case OpCode.Stobj:            value = this.GetMemberFromToken(); break;          case OpCode.Conv_Ovf_I1_Un:          case OpCode.Conv_Ovf_I2_Un:          case OpCode.Conv_Ovf_I4_Un:          case OpCode.Conv_Ovf_I8_Un:          case OpCode.Conv_Ovf_U1_Un:          case OpCode.Conv_Ovf_U2_Un:          case OpCode.Conv_Ovf_U4_Un:          case OpCode.Conv_Ovf_U8_Un:          case OpCode.Conv_Ovf_I_Un:          case OpCode.Conv_Ovf_U_Un:            break;          case OpCode.Box:          case OpCode.Newarr: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Ldlen: break;          case OpCode.Ldelema: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Ldelem_I1:          case OpCode.Ldelem_U1:          case OpCode.Ldelem_I2:          case OpCode.Ldelem_U2:          case OpCode.Ldelem_I4:          case OpCode.Ldelem_U4:          case OpCode.Ldelem_I8:          case OpCode.Ldelem_I:          case OpCode.Ldelem_R4:          case OpCode.Ldelem_R8:          case OpCode.Ldelem_Ref:           case OpCode.Stelem_I:          case OpCode.Stelem_I1:          case OpCode.Stelem_I2:          case OpCode.Stelem_I4:          case OpCode.Stelem_I8:          case OpCode.Stelem_R4:          case OpCode.Stelem_R8:          case OpCode.Stelem_Ref:            break;          case OpCode.Ldelem:             value = (TypeNode)this.GetMemberFromToken();            break;          case OpCode.Stelem: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Unbox_Any: value = this.GetMemberFromToken(); break;          case OpCode.Conv_Ovf_I1:          case OpCode.Conv_Ovf_U1:          case OpCode.Conv_Ovf_I2:          case OpCode.Conv_Ovf_U2:          case OpCode.Conv_Ovf_I4:          case OpCode.Conv_Ovf_U4:          case OpCode.Conv_Ovf_I8:          case OpCode.Conv_Ovf_U8:            break;          case OpCode.Refanyval: value = this.GetMemberFromToken(); break;          case OpCode.Ckfinite: break;          case OpCode.Mkrefany: value = this.GetMemberFromToken(); break;          case OpCode.Ldtoken: value = this.GetMemberFromToken(); break;          case OpCode.Conv_U2:          case OpCode.Conv_U1:          case OpCode.Conv_I:          case OpCode.Conv_Ovf_I:          case OpCode.Conv_Ovf_U:          case OpCode.Add_Ovf:          case OpCode.Add_Ovf_Un:          case OpCode.Mul_Ovf:          case OpCode.Mul_Ovf_Un:          case OpCode.Sub_Ovf:          case OpCode.Sub_Ovf_Un:          case OpCode.Endfinally:             break;          case OpCode.Leave:   value = this.counter + 4 + this.GetInt32(); break;           case OpCode.Leave_S: value = this.counter + 1 + this.GetSByte(); break;          case OpCode.Stind_I:          case OpCode.Conv_U:          case OpCode.Prefix7:          case OpCode.Prefix6:          case OpCode.Prefix5:          case OpCode.Prefix4:          case OpCode.Prefix3:          case OpCode.Prefix2:          case OpCode.Prefix1:          case OpCode.Arglist:          case OpCode.Ceq:          case OpCode.Cgt:          case OpCode.Cgt_Un:          case OpCode.Clt:          case OpCode.Clt_Un:            break;          case OpCode.Ldftn:          case OpCode.Ldvirtftn:            value = this.GetMemberFromToken(); break;          case OpCode.Ldarg:          case OpCode.Ldarga:          case OpCode.Starg:            value = this.Parameters(this.GetInt16()); break;          case OpCode.Ldloc:          case OpCode.Ldloca:          case OpCode.Stloc:            value = this.locals[this.GetInt16()]; break;          case OpCode.Localloc:          case OpCode.Endfilter:            break;          case OpCode.Unaligned_: value = this.GetByte(); break;          case OpCode.Volatile_:          case OpCode.Tail_:            break;          case OpCode.Initobj: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Constrained_: value = this.GetMemberFromToken() as TypeNode; break;          case OpCode.Cpblk:           case OpCode.Initblk:            break;          case OpCode.Rethrow:            break;          case OpCode.Sizeof: value = this.GetMemberFromToken(); break;          case OpCode.Refanytype:          case OpCode.Readonly_:            break;          default: throw new InvalidMetadataException(String.Format(CultureInfo.CurrentCulture'             ExceptionStrings.UnknownOpCodeEncountered' opCode.ToString("x")));        }
Magic Number,Microsoft.Cci.Metadata,InstructionParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseInstruction,The following statement contains a magic number: switch(opCode){          case OpCode.Nop:          case OpCode.Break:             break;          case OpCode.Ldarg_0: value = this.Parameters(0); break;          case OpCode.Ldarg_1: value = this.Parameters(1); break;          case OpCode.Ldarg_2: value = this.Parameters(2); break;           case OpCode.Ldarg_3: value = this.Parameters(3); break;          case OpCode.Ldloc_0: value = this.locals[0]; break;          case OpCode.Ldloc_1: value = this.locals[1]; break;          case OpCode.Ldloc_2: value = this.locals[2]; break;          case OpCode.Ldloc_3: value = this.locals[3]; break;          case OpCode.Stloc_0: value = this.locals[0]; break;          case OpCode.Stloc_1: value = this.locals[1]; break;          case OpCode.Stloc_2: value = this.locals[2]; break;          case OpCode.Stloc_3: value = this.locals[3]; break;          case OpCode.Ldarg_S:            case OpCode.Ldarga_S:          case OpCode.Starg_S:            value = this.Parameters(this.GetByte()); break;          case OpCode.Ldloc_S:          case OpCode.Ldloca_S:          case OpCode.Stloc_S:            value = this.locals[this.GetByte()]; break;          case OpCode.Ldnull:             break;          case OpCode.Ldc_I4_M1: value = (Int32)(-1); break;          case OpCode.Ldc_I4_0: value = (Int32)0; break;          case OpCode.Ldc_I4_1: value = (Int32)1; break;          case OpCode.Ldc_I4_2: value = (Int32)2; break;          case OpCode.Ldc_I4_3: value = (Int32)3; break;          case OpCode.Ldc_I4_4: value = (Int32)4; break;          case OpCode.Ldc_I4_5: value = (Int32)5; break;          case OpCode.Ldc_I4_6: value = (Int32)6; break;          case OpCode.Ldc_I4_7: value = (Int32)7; break;          case OpCode.Ldc_I4_8: value = (Int32)8; break;          case OpCode.Ldc_I4_S: value = (Int32)this.GetSByte(); break;          case OpCode.Ldc_I4: value = this.GetInt32(); break;          case OpCode.Ldc_I8: value = this.GetInt64(); break;          case OpCode.Ldc_R4: value = this.GetSingle(); break;          case OpCode.Ldc_R8: value = this.GetDouble(); break;          case OpCode.Dup:          case OpCode.Pop:             break;          case OpCode.Jmp:           case OpCode.Call:            value = (Method)this.GetMemberFromToken(); break;          case OpCode.Calli:             value = (FunctionPointer)this.reader.GetCalliSignature(this.GetInt32()); break;          case OpCode.Ret: break;          case OpCode.Br_S:          case OpCode.Brfalse_S:          case OpCode.Brtrue_S:          case OpCode.Beq_S:          case OpCode.Bge_S:          case OpCode.Bgt_S:          case OpCode.Ble_S:          case OpCode.Blt_S:          case OpCode.Bne_Un_S:          case OpCode.Bge_Un_S:          case OpCode.Bgt_Un_S:          case OpCode.Ble_Un_S:          case OpCode.Blt_Un_S:            value = this.counter + 1 + this.GetSByte(); break;          case OpCode.Br:          case OpCode.Brfalse:          case OpCode.Brtrue:          case OpCode.Beq:          case OpCode.Bge:          case OpCode.Bgt:          case OpCode.Ble:          case OpCode.Blt:          case OpCode.Bne_Un:          case OpCode.Bge_Un:          case OpCode.Bgt_Un:          case OpCode.Ble_Un:          case OpCode.Blt_Un:            value = this.counter + 4 + this.GetInt32(); break;          case OpCode.Switch: value = this.ParseSwitchInstruction(); break;                  case OpCode.Ldind_I1:           case OpCode.Ldind_U1:          case OpCode.Ldind_I2:          case OpCode.Ldind_U2:          case OpCode.Ldind_I4:          case OpCode.Ldind_U4:          case OpCode.Ldind_I8:          case OpCode.Ldind_I:          case OpCode.Ldind_R4:          case OpCode.Ldind_R8:          case OpCode.Ldind_Ref:          case OpCode.Stind_Ref:          case OpCode.Stind_I1:          case OpCode.Stind_I2:          case OpCode.Stind_I4:          case OpCode.Stind_I8:          case OpCode.Stind_R4:          case OpCode.Stind_R8:          case OpCode.Add:          case OpCode.Sub:          case OpCode.Mul:          case OpCode.Div:          case OpCode.Div_Un:          case OpCode.Rem:          case OpCode.Rem_Un:          case OpCode.And:          case OpCode.Or:          case OpCode.Xor:          case OpCode.Shl:          case OpCode.Shr:          case OpCode.Shr_Un:          case OpCode.Neg:          case OpCode.Not:          case OpCode.Conv_I1:          case OpCode.Conv_I2:          case OpCode.Conv_I4:          case OpCode.Conv_I8:          case OpCode.Conv_R4:          case OpCode.Conv_R8:          case OpCode.Conv_U4:          case OpCode.Conv_U8:            break;          case OpCode.Callvirt: value = (Method)this.GetMemberFromToken(); break;          case OpCode.Cpobj:          case OpCode.Ldobj:             value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Ldstr: value = this.GetStringFromToken(); break;                    case OpCode.Newobj: value = (Method)this.GetMemberFromToken();break;          case OpCode.Castclass:          case OpCode.Isinst:             value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Conv_R_Un: break;                 case OpCode.Unbox: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Throw: break;          case OpCode.Ldfld:           case OpCode.Ldflda:          case OpCode.Stfld:          case OpCode.Ldsfld:          case OpCode.Ldsflda:          case OpCode.Stsfld:          case OpCode.Stobj:            value = this.GetMemberFromToken(); break;          case OpCode.Conv_Ovf_I1_Un:          case OpCode.Conv_Ovf_I2_Un:          case OpCode.Conv_Ovf_I4_Un:          case OpCode.Conv_Ovf_I8_Un:          case OpCode.Conv_Ovf_U1_Un:          case OpCode.Conv_Ovf_U2_Un:          case OpCode.Conv_Ovf_U4_Un:          case OpCode.Conv_Ovf_U8_Un:          case OpCode.Conv_Ovf_I_Un:          case OpCode.Conv_Ovf_U_Un:            break;          case OpCode.Box:          case OpCode.Newarr: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Ldlen: break;          case OpCode.Ldelema: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Ldelem_I1:          case OpCode.Ldelem_U1:          case OpCode.Ldelem_I2:          case OpCode.Ldelem_U2:          case OpCode.Ldelem_I4:          case OpCode.Ldelem_U4:          case OpCode.Ldelem_I8:          case OpCode.Ldelem_I:          case OpCode.Ldelem_R4:          case OpCode.Ldelem_R8:          case OpCode.Ldelem_Ref:           case OpCode.Stelem_I:          case OpCode.Stelem_I1:          case OpCode.Stelem_I2:          case OpCode.Stelem_I4:          case OpCode.Stelem_I8:          case OpCode.Stelem_R4:          case OpCode.Stelem_R8:          case OpCode.Stelem_Ref:            break;          case OpCode.Ldelem:             value = (TypeNode)this.GetMemberFromToken();            break;          case OpCode.Stelem: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Unbox_Any: value = this.GetMemberFromToken(); break;          case OpCode.Conv_Ovf_I1:          case OpCode.Conv_Ovf_U1:          case OpCode.Conv_Ovf_I2:          case OpCode.Conv_Ovf_U2:          case OpCode.Conv_Ovf_I4:          case OpCode.Conv_Ovf_U4:          case OpCode.Conv_Ovf_I8:          case OpCode.Conv_Ovf_U8:            break;          case OpCode.Refanyval: value = this.GetMemberFromToken(); break;          case OpCode.Ckfinite: break;          case OpCode.Mkrefany: value = this.GetMemberFromToken(); break;          case OpCode.Ldtoken: value = this.GetMemberFromToken(); break;          case OpCode.Conv_U2:          case OpCode.Conv_U1:          case OpCode.Conv_I:          case OpCode.Conv_Ovf_I:          case OpCode.Conv_Ovf_U:          case OpCode.Add_Ovf:          case OpCode.Add_Ovf_Un:          case OpCode.Mul_Ovf:          case OpCode.Mul_Ovf_Un:          case OpCode.Sub_Ovf:          case OpCode.Sub_Ovf_Un:          case OpCode.Endfinally:             break;          case OpCode.Leave:   value = this.counter + 4 + this.GetInt32(); break;           case OpCode.Leave_S: value = this.counter + 1 + this.GetSByte(); break;          case OpCode.Stind_I:          case OpCode.Conv_U:          case OpCode.Prefix7:          case OpCode.Prefix6:          case OpCode.Prefix5:          case OpCode.Prefix4:          case OpCode.Prefix3:          case OpCode.Prefix2:          case OpCode.Prefix1:          case OpCode.Arglist:          case OpCode.Ceq:          case OpCode.Cgt:          case OpCode.Cgt_Un:          case OpCode.Clt:          case OpCode.Clt_Un:            break;          case OpCode.Ldftn:          case OpCode.Ldvirtftn:            value = this.GetMemberFromToken(); break;          case OpCode.Ldarg:          case OpCode.Ldarga:          case OpCode.Starg:            value = this.Parameters(this.GetInt16()); break;          case OpCode.Ldloc:          case OpCode.Ldloca:          case OpCode.Stloc:            value = this.locals[this.GetInt16()]; break;          case OpCode.Localloc:          case OpCode.Endfilter:            break;          case OpCode.Unaligned_: value = this.GetByte(); break;          case OpCode.Volatile_:          case OpCode.Tail_:            break;          case OpCode.Initobj: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Constrained_: value = this.GetMemberFromToken() as TypeNode; break;          case OpCode.Cpblk:           case OpCode.Initblk:            break;          case OpCode.Rethrow:            break;          case OpCode.Sizeof: value = this.GetMemberFromToken(); break;          case OpCode.Refanytype:          case OpCode.Readonly_:            break;          default: throw new InvalidMetadataException(String.Format(CultureInfo.CurrentCulture'             ExceptionStrings.UnknownOpCodeEncountered' opCode.ToString("x")));        }
Magic Number,Microsoft.Cci.Metadata,InstructionParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseInstruction,The following statement contains a magic number: switch(opCode){          case OpCode.Nop:          case OpCode.Break:             break;          case OpCode.Ldarg_0: value = this.Parameters(0); break;          case OpCode.Ldarg_1: value = this.Parameters(1); break;          case OpCode.Ldarg_2: value = this.Parameters(2); break;           case OpCode.Ldarg_3: value = this.Parameters(3); break;          case OpCode.Ldloc_0: value = this.locals[0]; break;          case OpCode.Ldloc_1: value = this.locals[1]; break;          case OpCode.Ldloc_2: value = this.locals[2]; break;          case OpCode.Ldloc_3: value = this.locals[3]; break;          case OpCode.Stloc_0: value = this.locals[0]; break;          case OpCode.Stloc_1: value = this.locals[1]; break;          case OpCode.Stloc_2: value = this.locals[2]; break;          case OpCode.Stloc_3: value = this.locals[3]; break;          case OpCode.Ldarg_S:            case OpCode.Ldarga_S:          case OpCode.Starg_S:            value = this.Parameters(this.GetByte()); break;          case OpCode.Ldloc_S:          case OpCode.Ldloca_S:          case OpCode.Stloc_S:            value = this.locals[this.GetByte()]; break;          case OpCode.Ldnull:             break;          case OpCode.Ldc_I4_M1: value = (Int32)(-1); break;          case OpCode.Ldc_I4_0: value = (Int32)0; break;          case OpCode.Ldc_I4_1: value = (Int32)1; break;          case OpCode.Ldc_I4_2: value = (Int32)2; break;          case OpCode.Ldc_I4_3: value = (Int32)3; break;          case OpCode.Ldc_I4_4: value = (Int32)4; break;          case OpCode.Ldc_I4_5: value = (Int32)5; break;          case OpCode.Ldc_I4_6: value = (Int32)6; break;          case OpCode.Ldc_I4_7: value = (Int32)7; break;          case OpCode.Ldc_I4_8: value = (Int32)8; break;          case OpCode.Ldc_I4_S: value = (Int32)this.GetSByte(); break;          case OpCode.Ldc_I4: value = this.GetInt32(); break;          case OpCode.Ldc_I8: value = this.GetInt64(); break;          case OpCode.Ldc_R4: value = this.GetSingle(); break;          case OpCode.Ldc_R8: value = this.GetDouble(); break;          case OpCode.Dup:          case OpCode.Pop:             break;          case OpCode.Jmp:           case OpCode.Call:            value = (Method)this.GetMemberFromToken(); break;          case OpCode.Calli:             value = (FunctionPointer)this.reader.GetCalliSignature(this.GetInt32()); break;          case OpCode.Ret: break;          case OpCode.Br_S:          case OpCode.Brfalse_S:          case OpCode.Brtrue_S:          case OpCode.Beq_S:          case OpCode.Bge_S:          case OpCode.Bgt_S:          case OpCode.Ble_S:          case OpCode.Blt_S:          case OpCode.Bne_Un_S:          case OpCode.Bge_Un_S:          case OpCode.Bgt_Un_S:          case OpCode.Ble_Un_S:          case OpCode.Blt_Un_S:            value = this.counter + 1 + this.GetSByte(); break;          case OpCode.Br:          case OpCode.Brfalse:          case OpCode.Brtrue:          case OpCode.Beq:          case OpCode.Bge:          case OpCode.Bgt:          case OpCode.Ble:          case OpCode.Blt:          case OpCode.Bne_Un:          case OpCode.Bge_Un:          case OpCode.Bgt_Un:          case OpCode.Ble_Un:          case OpCode.Blt_Un:            value = this.counter + 4 + this.GetInt32(); break;          case OpCode.Switch: value = this.ParseSwitchInstruction(); break;                  case OpCode.Ldind_I1:           case OpCode.Ldind_U1:          case OpCode.Ldind_I2:          case OpCode.Ldind_U2:          case OpCode.Ldind_I4:          case OpCode.Ldind_U4:          case OpCode.Ldind_I8:          case OpCode.Ldind_I:          case OpCode.Ldind_R4:          case OpCode.Ldind_R8:          case OpCode.Ldind_Ref:          case OpCode.Stind_Ref:          case OpCode.Stind_I1:          case OpCode.Stind_I2:          case OpCode.Stind_I4:          case OpCode.Stind_I8:          case OpCode.Stind_R4:          case OpCode.Stind_R8:          case OpCode.Add:          case OpCode.Sub:          case OpCode.Mul:          case OpCode.Div:          case OpCode.Div_Un:          case OpCode.Rem:          case OpCode.Rem_Un:          case OpCode.And:          case OpCode.Or:          case OpCode.Xor:          case OpCode.Shl:          case OpCode.Shr:          case OpCode.Shr_Un:          case OpCode.Neg:          case OpCode.Not:          case OpCode.Conv_I1:          case OpCode.Conv_I2:          case OpCode.Conv_I4:          case OpCode.Conv_I8:          case OpCode.Conv_R4:          case OpCode.Conv_R8:          case OpCode.Conv_U4:          case OpCode.Conv_U8:            break;          case OpCode.Callvirt: value = (Method)this.GetMemberFromToken(); break;          case OpCode.Cpobj:          case OpCode.Ldobj:             value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Ldstr: value = this.GetStringFromToken(); break;                    case OpCode.Newobj: value = (Method)this.GetMemberFromToken();break;          case OpCode.Castclass:          case OpCode.Isinst:             value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Conv_R_Un: break;                 case OpCode.Unbox: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Throw: break;          case OpCode.Ldfld:           case OpCode.Ldflda:          case OpCode.Stfld:          case OpCode.Ldsfld:          case OpCode.Ldsflda:          case OpCode.Stsfld:          case OpCode.Stobj:            value = this.GetMemberFromToken(); break;          case OpCode.Conv_Ovf_I1_Un:          case OpCode.Conv_Ovf_I2_Un:          case OpCode.Conv_Ovf_I4_Un:          case OpCode.Conv_Ovf_I8_Un:          case OpCode.Conv_Ovf_U1_Un:          case OpCode.Conv_Ovf_U2_Un:          case OpCode.Conv_Ovf_U4_Un:          case OpCode.Conv_Ovf_U8_Un:          case OpCode.Conv_Ovf_I_Un:          case OpCode.Conv_Ovf_U_Un:            break;          case OpCode.Box:          case OpCode.Newarr: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Ldlen: break;          case OpCode.Ldelema: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Ldelem_I1:          case OpCode.Ldelem_U1:          case OpCode.Ldelem_I2:          case OpCode.Ldelem_U2:          case OpCode.Ldelem_I4:          case OpCode.Ldelem_U4:          case OpCode.Ldelem_I8:          case OpCode.Ldelem_I:          case OpCode.Ldelem_R4:          case OpCode.Ldelem_R8:          case OpCode.Ldelem_Ref:           case OpCode.Stelem_I:          case OpCode.Stelem_I1:          case OpCode.Stelem_I2:          case OpCode.Stelem_I4:          case OpCode.Stelem_I8:          case OpCode.Stelem_R4:          case OpCode.Stelem_R8:          case OpCode.Stelem_Ref:            break;          case OpCode.Ldelem:             value = (TypeNode)this.GetMemberFromToken();            break;          case OpCode.Stelem: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Unbox_Any: value = this.GetMemberFromToken(); break;          case OpCode.Conv_Ovf_I1:          case OpCode.Conv_Ovf_U1:          case OpCode.Conv_Ovf_I2:          case OpCode.Conv_Ovf_U2:          case OpCode.Conv_Ovf_I4:          case OpCode.Conv_Ovf_U4:          case OpCode.Conv_Ovf_I8:          case OpCode.Conv_Ovf_U8:            break;          case OpCode.Refanyval: value = this.GetMemberFromToken(); break;          case OpCode.Ckfinite: break;          case OpCode.Mkrefany: value = this.GetMemberFromToken(); break;          case OpCode.Ldtoken: value = this.GetMemberFromToken(); break;          case OpCode.Conv_U2:          case OpCode.Conv_U1:          case OpCode.Conv_I:          case OpCode.Conv_Ovf_I:          case OpCode.Conv_Ovf_U:          case OpCode.Add_Ovf:          case OpCode.Add_Ovf_Un:          case OpCode.Mul_Ovf:          case OpCode.Mul_Ovf_Un:          case OpCode.Sub_Ovf:          case OpCode.Sub_Ovf_Un:          case OpCode.Endfinally:             break;          case OpCode.Leave:   value = this.counter + 4 + this.GetInt32(); break;           case OpCode.Leave_S: value = this.counter + 1 + this.GetSByte(); break;          case OpCode.Stind_I:          case OpCode.Conv_U:          case OpCode.Prefix7:          case OpCode.Prefix6:          case OpCode.Prefix5:          case OpCode.Prefix4:          case OpCode.Prefix3:          case OpCode.Prefix2:          case OpCode.Prefix1:          case OpCode.Arglist:          case OpCode.Ceq:          case OpCode.Cgt:          case OpCode.Cgt_Un:          case OpCode.Clt:          case OpCode.Clt_Un:            break;          case OpCode.Ldftn:          case OpCode.Ldvirtftn:            value = this.GetMemberFromToken(); break;          case OpCode.Ldarg:          case OpCode.Ldarga:          case OpCode.Starg:            value = this.Parameters(this.GetInt16()); break;          case OpCode.Ldloc:          case OpCode.Ldloca:          case OpCode.Stloc:            value = this.locals[this.GetInt16()]; break;          case OpCode.Localloc:          case OpCode.Endfilter:            break;          case OpCode.Unaligned_: value = this.GetByte(); break;          case OpCode.Volatile_:          case OpCode.Tail_:            break;          case OpCode.Initobj: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Constrained_: value = this.GetMemberFromToken() as TypeNode; break;          case OpCode.Cpblk:           case OpCode.Initblk:            break;          case OpCode.Rethrow:            break;          case OpCode.Sizeof: value = this.GetMemberFromToken(); break;          case OpCode.Refanytype:          case OpCode.Readonly_:            break;          default: throw new InvalidMetadataException(String.Format(CultureInfo.CurrentCulture'             ExceptionStrings.UnknownOpCodeEncountered' opCode.ToString("x")));        }
Magic Number,Microsoft.Cci.Metadata,InstructionParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseInstruction,The following statement contains a magic number: switch(opCode){          case OpCode.Nop:          case OpCode.Break:             break;          case OpCode.Ldarg_0: value = this.Parameters(0); break;          case OpCode.Ldarg_1: value = this.Parameters(1); break;          case OpCode.Ldarg_2: value = this.Parameters(2); break;           case OpCode.Ldarg_3: value = this.Parameters(3); break;          case OpCode.Ldloc_0: value = this.locals[0]; break;          case OpCode.Ldloc_1: value = this.locals[1]; break;          case OpCode.Ldloc_2: value = this.locals[2]; break;          case OpCode.Ldloc_3: value = this.locals[3]; break;          case OpCode.Stloc_0: value = this.locals[0]; break;          case OpCode.Stloc_1: value = this.locals[1]; break;          case OpCode.Stloc_2: value = this.locals[2]; break;          case OpCode.Stloc_3: value = this.locals[3]; break;          case OpCode.Ldarg_S:            case OpCode.Ldarga_S:          case OpCode.Starg_S:            value = this.Parameters(this.GetByte()); break;          case OpCode.Ldloc_S:          case OpCode.Ldloca_S:          case OpCode.Stloc_S:            value = this.locals[this.GetByte()]; break;          case OpCode.Ldnull:             break;          case OpCode.Ldc_I4_M1: value = (Int32)(-1); break;          case OpCode.Ldc_I4_0: value = (Int32)0; break;          case OpCode.Ldc_I4_1: value = (Int32)1; break;          case OpCode.Ldc_I4_2: value = (Int32)2; break;          case OpCode.Ldc_I4_3: value = (Int32)3; break;          case OpCode.Ldc_I4_4: value = (Int32)4; break;          case OpCode.Ldc_I4_5: value = (Int32)5; break;          case OpCode.Ldc_I4_6: value = (Int32)6; break;          case OpCode.Ldc_I4_7: value = (Int32)7; break;          case OpCode.Ldc_I4_8: value = (Int32)8; break;          case OpCode.Ldc_I4_S: value = (Int32)this.GetSByte(); break;          case OpCode.Ldc_I4: value = this.GetInt32(); break;          case OpCode.Ldc_I8: value = this.GetInt64(); break;          case OpCode.Ldc_R4: value = this.GetSingle(); break;          case OpCode.Ldc_R8: value = this.GetDouble(); break;          case OpCode.Dup:          case OpCode.Pop:             break;          case OpCode.Jmp:           case OpCode.Call:            value = (Method)this.GetMemberFromToken(); break;          case OpCode.Calli:             value = (FunctionPointer)this.reader.GetCalliSignature(this.GetInt32()); break;          case OpCode.Ret: break;          case OpCode.Br_S:          case OpCode.Brfalse_S:          case OpCode.Brtrue_S:          case OpCode.Beq_S:          case OpCode.Bge_S:          case OpCode.Bgt_S:          case OpCode.Ble_S:          case OpCode.Blt_S:          case OpCode.Bne_Un_S:          case OpCode.Bge_Un_S:          case OpCode.Bgt_Un_S:          case OpCode.Ble_Un_S:          case OpCode.Blt_Un_S:            value = this.counter + 1 + this.GetSByte(); break;          case OpCode.Br:          case OpCode.Brfalse:          case OpCode.Brtrue:          case OpCode.Beq:          case OpCode.Bge:          case OpCode.Bgt:          case OpCode.Ble:          case OpCode.Blt:          case OpCode.Bne_Un:          case OpCode.Bge_Un:          case OpCode.Bgt_Un:          case OpCode.Ble_Un:          case OpCode.Blt_Un:            value = this.counter + 4 + this.GetInt32(); break;          case OpCode.Switch: value = this.ParseSwitchInstruction(); break;                  case OpCode.Ldind_I1:           case OpCode.Ldind_U1:          case OpCode.Ldind_I2:          case OpCode.Ldind_U2:          case OpCode.Ldind_I4:          case OpCode.Ldind_U4:          case OpCode.Ldind_I8:          case OpCode.Ldind_I:          case OpCode.Ldind_R4:          case OpCode.Ldind_R8:          case OpCode.Ldind_Ref:          case OpCode.Stind_Ref:          case OpCode.Stind_I1:          case OpCode.Stind_I2:          case OpCode.Stind_I4:          case OpCode.Stind_I8:          case OpCode.Stind_R4:          case OpCode.Stind_R8:          case OpCode.Add:          case OpCode.Sub:          case OpCode.Mul:          case OpCode.Div:          case OpCode.Div_Un:          case OpCode.Rem:          case OpCode.Rem_Un:          case OpCode.And:          case OpCode.Or:          case OpCode.Xor:          case OpCode.Shl:          case OpCode.Shr:          case OpCode.Shr_Un:          case OpCode.Neg:          case OpCode.Not:          case OpCode.Conv_I1:          case OpCode.Conv_I2:          case OpCode.Conv_I4:          case OpCode.Conv_I8:          case OpCode.Conv_R4:          case OpCode.Conv_R8:          case OpCode.Conv_U4:          case OpCode.Conv_U8:            break;          case OpCode.Callvirt: value = (Method)this.GetMemberFromToken(); break;          case OpCode.Cpobj:          case OpCode.Ldobj:             value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Ldstr: value = this.GetStringFromToken(); break;                    case OpCode.Newobj: value = (Method)this.GetMemberFromToken();break;          case OpCode.Castclass:          case OpCode.Isinst:             value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Conv_R_Un: break;                 case OpCode.Unbox: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Throw: break;          case OpCode.Ldfld:           case OpCode.Ldflda:          case OpCode.Stfld:          case OpCode.Ldsfld:          case OpCode.Ldsflda:          case OpCode.Stsfld:          case OpCode.Stobj:            value = this.GetMemberFromToken(); break;          case OpCode.Conv_Ovf_I1_Un:          case OpCode.Conv_Ovf_I2_Un:          case OpCode.Conv_Ovf_I4_Un:          case OpCode.Conv_Ovf_I8_Un:          case OpCode.Conv_Ovf_U1_Un:          case OpCode.Conv_Ovf_U2_Un:          case OpCode.Conv_Ovf_U4_Un:          case OpCode.Conv_Ovf_U8_Un:          case OpCode.Conv_Ovf_I_Un:          case OpCode.Conv_Ovf_U_Un:            break;          case OpCode.Box:          case OpCode.Newarr: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Ldlen: break;          case OpCode.Ldelema: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Ldelem_I1:          case OpCode.Ldelem_U1:          case OpCode.Ldelem_I2:          case OpCode.Ldelem_U2:          case OpCode.Ldelem_I4:          case OpCode.Ldelem_U4:          case OpCode.Ldelem_I8:          case OpCode.Ldelem_I:          case OpCode.Ldelem_R4:          case OpCode.Ldelem_R8:          case OpCode.Ldelem_Ref:           case OpCode.Stelem_I:          case OpCode.Stelem_I1:          case OpCode.Stelem_I2:          case OpCode.Stelem_I4:          case OpCode.Stelem_I8:          case OpCode.Stelem_R4:          case OpCode.Stelem_R8:          case OpCode.Stelem_Ref:            break;          case OpCode.Ldelem:             value = (TypeNode)this.GetMemberFromToken();            break;          case OpCode.Stelem: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Unbox_Any: value = this.GetMemberFromToken(); break;          case OpCode.Conv_Ovf_I1:          case OpCode.Conv_Ovf_U1:          case OpCode.Conv_Ovf_I2:          case OpCode.Conv_Ovf_U2:          case OpCode.Conv_Ovf_I4:          case OpCode.Conv_Ovf_U4:          case OpCode.Conv_Ovf_I8:          case OpCode.Conv_Ovf_U8:            break;          case OpCode.Refanyval: value = this.GetMemberFromToken(); break;          case OpCode.Ckfinite: break;          case OpCode.Mkrefany: value = this.GetMemberFromToken(); break;          case OpCode.Ldtoken: value = this.GetMemberFromToken(); break;          case OpCode.Conv_U2:          case OpCode.Conv_U1:          case OpCode.Conv_I:          case OpCode.Conv_Ovf_I:          case OpCode.Conv_Ovf_U:          case OpCode.Add_Ovf:          case OpCode.Add_Ovf_Un:          case OpCode.Mul_Ovf:          case OpCode.Mul_Ovf_Un:          case OpCode.Sub_Ovf:          case OpCode.Sub_Ovf_Un:          case OpCode.Endfinally:             break;          case OpCode.Leave:   value = this.counter + 4 + this.GetInt32(); break;           case OpCode.Leave_S: value = this.counter + 1 + this.GetSByte(); break;          case OpCode.Stind_I:          case OpCode.Conv_U:          case OpCode.Prefix7:          case OpCode.Prefix6:          case OpCode.Prefix5:          case OpCode.Prefix4:          case OpCode.Prefix3:          case OpCode.Prefix2:          case OpCode.Prefix1:          case OpCode.Arglist:          case OpCode.Ceq:          case OpCode.Cgt:          case OpCode.Cgt_Un:          case OpCode.Clt:          case OpCode.Clt_Un:            break;          case OpCode.Ldftn:          case OpCode.Ldvirtftn:            value = this.GetMemberFromToken(); break;          case OpCode.Ldarg:          case OpCode.Ldarga:          case OpCode.Starg:            value = this.Parameters(this.GetInt16()); break;          case OpCode.Ldloc:          case OpCode.Ldloca:          case OpCode.Stloc:            value = this.locals[this.GetInt16()]; break;          case OpCode.Localloc:          case OpCode.Endfilter:            break;          case OpCode.Unaligned_: value = this.GetByte(); break;          case OpCode.Volatile_:          case OpCode.Tail_:            break;          case OpCode.Initobj: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Constrained_: value = this.GetMemberFromToken() as TypeNode; break;          case OpCode.Cpblk:           case OpCode.Initblk:            break;          case OpCode.Rethrow:            break;          case OpCode.Sizeof: value = this.GetMemberFromToken(); break;          case OpCode.Refanytype:          case OpCode.Readonly_:            break;          default: throw new InvalidMetadataException(String.Format(CultureInfo.CurrentCulture'             ExceptionStrings.UnknownOpCodeEncountered' opCode.ToString("x")));        }
Magic Number,Microsoft.Cci.Metadata,InstructionParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseInstruction,The following statement contains a magic number: switch(opCode){          case OpCode.Nop:          case OpCode.Break:             break;          case OpCode.Ldarg_0: value = this.Parameters(0); break;          case OpCode.Ldarg_1: value = this.Parameters(1); break;          case OpCode.Ldarg_2: value = this.Parameters(2); break;           case OpCode.Ldarg_3: value = this.Parameters(3); break;          case OpCode.Ldloc_0: value = this.locals[0]; break;          case OpCode.Ldloc_1: value = this.locals[1]; break;          case OpCode.Ldloc_2: value = this.locals[2]; break;          case OpCode.Ldloc_3: value = this.locals[3]; break;          case OpCode.Stloc_0: value = this.locals[0]; break;          case OpCode.Stloc_1: value = this.locals[1]; break;          case OpCode.Stloc_2: value = this.locals[2]; break;          case OpCode.Stloc_3: value = this.locals[3]; break;          case OpCode.Ldarg_S:            case OpCode.Ldarga_S:          case OpCode.Starg_S:            value = this.Parameters(this.GetByte()); break;          case OpCode.Ldloc_S:          case OpCode.Ldloca_S:          case OpCode.Stloc_S:            value = this.locals[this.GetByte()]; break;          case OpCode.Ldnull:             break;          case OpCode.Ldc_I4_M1: value = (Int32)(-1); break;          case OpCode.Ldc_I4_0: value = (Int32)0; break;          case OpCode.Ldc_I4_1: value = (Int32)1; break;          case OpCode.Ldc_I4_2: value = (Int32)2; break;          case OpCode.Ldc_I4_3: value = (Int32)3; break;          case OpCode.Ldc_I4_4: value = (Int32)4; break;          case OpCode.Ldc_I4_5: value = (Int32)5; break;          case OpCode.Ldc_I4_6: value = (Int32)6; break;          case OpCode.Ldc_I4_7: value = (Int32)7; break;          case OpCode.Ldc_I4_8: value = (Int32)8; break;          case OpCode.Ldc_I4_S: value = (Int32)this.GetSByte(); break;          case OpCode.Ldc_I4: value = this.GetInt32(); break;          case OpCode.Ldc_I8: value = this.GetInt64(); break;          case OpCode.Ldc_R4: value = this.GetSingle(); break;          case OpCode.Ldc_R8: value = this.GetDouble(); break;          case OpCode.Dup:          case OpCode.Pop:             break;          case OpCode.Jmp:           case OpCode.Call:            value = (Method)this.GetMemberFromToken(); break;          case OpCode.Calli:             value = (FunctionPointer)this.reader.GetCalliSignature(this.GetInt32()); break;          case OpCode.Ret: break;          case OpCode.Br_S:          case OpCode.Brfalse_S:          case OpCode.Brtrue_S:          case OpCode.Beq_S:          case OpCode.Bge_S:          case OpCode.Bgt_S:          case OpCode.Ble_S:          case OpCode.Blt_S:          case OpCode.Bne_Un_S:          case OpCode.Bge_Un_S:          case OpCode.Bgt_Un_S:          case OpCode.Ble_Un_S:          case OpCode.Blt_Un_S:            value = this.counter + 1 + this.GetSByte(); break;          case OpCode.Br:          case OpCode.Brfalse:          case OpCode.Brtrue:          case OpCode.Beq:          case OpCode.Bge:          case OpCode.Bgt:          case OpCode.Ble:          case OpCode.Blt:          case OpCode.Bne_Un:          case OpCode.Bge_Un:          case OpCode.Bgt_Un:          case OpCode.Ble_Un:          case OpCode.Blt_Un:            value = this.counter + 4 + this.GetInt32(); break;          case OpCode.Switch: value = this.ParseSwitchInstruction(); break;                  case OpCode.Ldind_I1:           case OpCode.Ldind_U1:          case OpCode.Ldind_I2:          case OpCode.Ldind_U2:          case OpCode.Ldind_I4:          case OpCode.Ldind_U4:          case OpCode.Ldind_I8:          case OpCode.Ldind_I:          case OpCode.Ldind_R4:          case OpCode.Ldind_R8:          case OpCode.Ldind_Ref:          case OpCode.Stind_Ref:          case OpCode.Stind_I1:          case OpCode.Stind_I2:          case OpCode.Stind_I4:          case OpCode.Stind_I8:          case OpCode.Stind_R4:          case OpCode.Stind_R8:          case OpCode.Add:          case OpCode.Sub:          case OpCode.Mul:          case OpCode.Div:          case OpCode.Div_Un:          case OpCode.Rem:          case OpCode.Rem_Un:          case OpCode.And:          case OpCode.Or:          case OpCode.Xor:          case OpCode.Shl:          case OpCode.Shr:          case OpCode.Shr_Un:          case OpCode.Neg:          case OpCode.Not:          case OpCode.Conv_I1:          case OpCode.Conv_I2:          case OpCode.Conv_I4:          case OpCode.Conv_I8:          case OpCode.Conv_R4:          case OpCode.Conv_R8:          case OpCode.Conv_U4:          case OpCode.Conv_U8:            break;          case OpCode.Callvirt: value = (Method)this.GetMemberFromToken(); break;          case OpCode.Cpobj:          case OpCode.Ldobj:             value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Ldstr: value = this.GetStringFromToken(); break;                    case OpCode.Newobj: value = (Method)this.GetMemberFromToken();break;          case OpCode.Castclass:          case OpCode.Isinst:             value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Conv_R_Un: break;                 case OpCode.Unbox: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Throw: break;          case OpCode.Ldfld:           case OpCode.Ldflda:          case OpCode.Stfld:          case OpCode.Ldsfld:          case OpCode.Ldsflda:          case OpCode.Stsfld:          case OpCode.Stobj:            value = this.GetMemberFromToken(); break;          case OpCode.Conv_Ovf_I1_Un:          case OpCode.Conv_Ovf_I2_Un:          case OpCode.Conv_Ovf_I4_Un:          case OpCode.Conv_Ovf_I8_Un:          case OpCode.Conv_Ovf_U1_Un:          case OpCode.Conv_Ovf_U2_Un:          case OpCode.Conv_Ovf_U4_Un:          case OpCode.Conv_Ovf_U8_Un:          case OpCode.Conv_Ovf_I_Un:          case OpCode.Conv_Ovf_U_Un:            break;          case OpCode.Box:          case OpCode.Newarr: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Ldlen: break;          case OpCode.Ldelema: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Ldelem_I1:          case OpCode.Ldelem_U1:          case OpCode.Ldelem_I2:          case OpCode.Ldelem_U2:          case OpCode.Ldelem_I4:          case OpCode.Ldelem_U4:          case OpCode.Ldelem_I8:          case OpCode.Ldelem_I:          case OpCode.Ldelem_R4:          case OpCode.Ldelem_R8:          case OpCode.Ldelem_Ref:           case OpCode.Stelem_I:          case OpCode.Stelem_I1:          case OpCode.Stelem_I2:          case OpCode.Stelem_I4:          case OpCode.Stelem_I8:          case OpCode.Stelem_R4:          case OpCode.Stelem_R8:          case OpCode.Stelem_Ref:            break;          case OpCode.Ldelem:             value = (TypeNode)this.GetMemberFromToken();            break;          case OpCode.Stelem: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Unbox_Any: value = this.GetMemberFromToken(); break;          case OpCode.Conv_Ovf_I1:          case OpCode.Conv_Ovf_U1:          case OpCode.Conv_Ovf_I2:          case OpCode.Conv_Ovf_U2:          case OpCode.Conv_Ovf_I4:          case OpCode.Conv_Ovf_U4:          case OpCode.Conv_Ovf_I8:          case OpCode.Conv_Ovf_U8:            break;          case OpCode.Refanyval: value = this.GetMemberFromToken(); break;          case OpCode.Ckfinite: break;          case OpCode.Mkrefany: value = this.GetMemberFromToken(); break;          case OpCode.Ldtoken: value = this.GetMemberFromToken(); break;          case OpCode.Conv_U2:          case OpCode.Conv_U1:          case OpCode.Conv_I:          case OpCode.Conv_Ovf_I:          case OpCode.Conv_Ovf_U:          case OpCode.Add_Ovf:          case OpCode.Add_Ovf_Un:          case OpCode.Mul_Ovf:          case OpCode.Mul_Ovf_Un:          case OpCode.Sub_Ovf:          case OpCode.Sub_Ovf_Un:          case OpCode.Endfinally:             break;          case OpCode.Leave:   value = this.counter + 4 + this.GetInt32(); break;           case OpCode.Leave_S: value = this.counter + 1 + this.GetSByte(); break;          case OpCode.Stind_I:          case OpCode.Conv_U:          case OpCode.Prefix7:          case OpCode.Prefix6:          case OpCode.Prefix5:          case OpCode.Prefix4:          case OpCode.Prefix3:          case OpCode.Prefix2:          case OpCode.Prefix1:          case OpCode.Arglist:          case OpCode.Ceq:          case OpCode.Cgt:          case OpCode.Cgt_Un:          case OpCode.Clt:          case OpCode.Clt_Un:            break;          case OpCode.Ldftn:          case OpCode.Ldvirtftn:            value = this.GetMemberFromToken(); break;          case OpCode.Ldarg:          case OpCode.Ldarga:          case OpCode.Starg:            value = this.Parameters(this.GetInt16()); break;          case OpCode.Ldloc:          case OpCode.Ldloca:          case OpCode.Stloc:            value = this.locals[this.GetInt16()]; break;          case OpCode.Localloc:          case OpCode.Endfilter:            break;          case OpCode.Unaligned_: value = this.GetByte(); break;          case OpCode.Volatile_:          case OpCode.Tail_:            break;          case OpCode.Initobj: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Constrained_: value = this.GetMemberFromToken() as TypeNode; break;          case OpCode.Cpblk:           case OpCode.Initblk:            break;          case OpCode.Rethrow:            break;          case OpCode.Sizeof: value = this.GetMemberFromToken(); break;          case OpCode.Refanytype:          case OpCode.Readonly_:            break;          default: throw new InvalidMetadataException(String.Format(CultureInfo.CurrentCulture'             ExceptionStrings.UnknownOpCodeEncountered' opCode.ToString("x")));        }
Magic Number,Microsoft.Cci.Metadata,InstructionParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseInstruction,The following statement contains a magic number: switch(opCode){          case OpCode.Nop:          case OpCode.Break:             break;          case OpCode.Ldarg_0: value = this.Parameters(0); break;          case OpCode.Ldarg_1: value = this.Parameters(1); break;          case OpCode.Ldarg_2: value = this.Parameters(2); break;           case OpCode.Ldarg_3: value = this.Parameters(3); break;          case OpCode.Ldloc_0: value = this.locals[0]; break;          case OpCode.Ldloc_1: value = this.locals[1]; break;          case OpCode.Ldloc_2: value = this.locals[2]; break;          case OpCode.Ldloc_3: value = this.locals[3]; break;          case OpCode.Stloc_0: value = this.locals[0]; break;          case OpCode.Stloc_1: value = this.locals[1]; break;          case OpCode.Stloc_2: value = this.locals[2]; break;          case OpCode.Stloc_3: value = this.locals[3]; break;          case OpCode.Ldarg_S:            case OpCode.Ldarga_S:          case OpCode.Starg_S:            value = this.Parameters(this.GetByte()); break;          case OpCode.Ldloc_S:          case OpCode.Ldloca_S:          case OpCode.Stloc_S:            value = this.locals[this.GetByte()]; break;          case OpCode.Ldnull:             break;          case OpCode.Ldc_I4_M1: value = (Int32)(-1); break;          case OpCode.Ldc_I4_0: value = (Int32)0; break;          case OpCode.Ldc_I4_1: value = (Int32)1; break;          case OpCode.Ldc_I4_2: value = (Int32)2; break;          case OpCode.Ldc_I4_3: value = (Int32)3; break;          case OpCode.Ldc_I4_4: value = (Int32)4; break;          case OpCode.Ldc_I4_5: value = (Int32)5; break;          case OpCode.Ldc_I4_6: value = (Int32)6; break;          case OpCode.Ldc_I4_7: value = (Int32)7; break;          case OpCode.Ldc_I4_8: value = (Int32)8; break;          case OpCode.Ldc_I4_S: value = (Int32)this.GetSByte(); break;          case OpCode.Ldc_I4: value = this.GetInt32(); break;          case OpCode.Ldc_I8: value = this.GetInt64(); break;          case OpCode.Ldc_R4: value = this.GetSingle(); break;          case OpCode.Ldc_R8: value = this.GetDouble(); break;          case OpCode.Dup:          case OpCode.Pop:             break;          case OpCode.Jmp:           case OpCode.Call:            value = (Method)this.GetMemberFromToken(); break;          case OpCode.Calli:             value = (FunctionPointer)this.reader.GetCalliSignature(this.GetInt32()); break;          case OpCode.Ret: break;          case OpCode.Br_S:          case OpCode.Brfalse_S:          case OpCode.Brtrue_S:          case OpCode.Beq_S:          case OpCode.Bge_S:          case OpCode.Bgt_S:          case OpCode.Ble_S:          case OpCode.Blt_S:          case OpCode.Bne_Un_S:          case OpCode.Bge_Un_S:          case OpCode.Bgt_Un_S:          case OpCode.Ble_Un_S:          case OpCode.Blt_Un_S:            value = this.counter + 1 + this.GetSByte(); break;          case OpCode.Br:          case OpCode.Brfalse:          case OpCode.Brtrue:          case OpCode.Beq:          case OpCode.Bge:          case OpCode.Bgt:          case OpCode.Ble:          case OpCode.Blt:          case OpCode.Bne_Un:          case OpCode.Bge_Un:          case OpCode.Bgt_Un:          case OpCode.Ble_Un:          case OpCode.Blt_Un:            value = this.counter + 4 + this.GetInt32(); break;          case OpCode.Switch: value = this.ParseSwitchInstruction(); break;                  case OpCode.Ldind_I1:           case OpCode.Ldind_U1:          case OpCode.Ldind_I2:          case OpCode.Ldind_U2:          case OpCode.Ldind_I4:          case OpCode.Ldind_U4:          case OpCode.Ldind_I8:          case OpCode.Ldind_I:          case OpCode.Ldind_R4:          case OpCode.Ldind_R8:          case OpCode.Ldind_Ref:          case OpCode.Stind_Ref:          case OpCode.Stind_I1:          case OpCode.Stind_I2:          case OpCode.Stind_I4:          case OpCode.Stind_I8:          case OpCode.Stind_R4:          case OpCode.Stind_R8:          case OpCode.Add:          case OpCode.Sub:          case OpCode.Mul:          case OpCode.Div:          case OpCode.Div_Un:          case OpCode.Rem:          case OpCode.Rem_Un:          case OpCode.And:          case OpCode.Or:          case OpCode.Xor:          case OpCode.Shl:          case OpCode.Shr:          case OpCode.Shr_Un:          case OpCode.Neg:          case OpCode.Not:          case OpCode.Conv_I1:          case OpCode.Conv_I2:          case OpCode.Conv_I4:          case OpCode.Conv_I8:          case OpCode.Conv_R4:          case OpCode.Conv_R8:          case OpCode.Conv_U4:          case OpCode.Conv_U8:            break;          case OpCode.Callvirt: value = (Method)this.GetMemberFromToken(); break;          case OpCode.Cpobj:          case OpCode.Ldobj:             value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Ldstr: value = this.GetStringFromToken(); break;                    case OpCode.Newobj: value = (Method)this.GetMemberFromToken();break;          case OpCode.Castclass:          case OpCode.Isinst:             value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Conv_R_Un: break;                 case OpCode.Unbox: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Throw: break;          case OpCode.Ldfld:           case OpCode.Ldflda:          case OpCode.Stfld:          case OpCode.Ldsfld:          case OpCode.Ldsflda:          case OpCode.Stsfld:          case OpCode.Stobj:            value = this.GetMemberFromToken(); break;          case OpCode.Conv_Ovf_I1_Un:          case OpCode.Conv_Ovf_I2_Un:          case OpCode.Conv_Ovf_I4_Un:          case OpCode.Conv_Ovf_I8_Un:          case OpCode.Conv_Ovf_U1_Un:          case OpCode.Conv_Ovf_U2_Un:          case OpCode.Conv_Ovf_U4_Un:          case OpCode.Conv_Ovf_U8_Un:          case OpCode.Conv_Ovf_I_Un:          case OpCode.Conv_Ovf_U_Un:            break;          case OpCode.Box:          case OpCode.Newarr: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Ldlen: break;          case OpCode.Ldelema: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Ldelem_I1:          case OpCode.Ldelem_U1:          case OpCode.Ldelem_I2:          case OpCode.Ldelem_U2:          case OpCode.Ldelem_I4:          case OpCode.Ldelem_U4:          case OpCode.Ldelem_I8:          case OpCode.Ldelem_I:          case OpCode.Ldelem_R4:          case OpCode.Ldelem_R8:          case OpCode.Ldelem_Ref:           case OpCode.Stelem_I:          case OpCode.Stelem_I1:          case OpCode.Stelem_I2:          case OpCode.Stelem_I4:          case OpCode.Stelem_I8:          case OpCode.Stelem_R4:          case OpCode.Stelem_R8:          case OpCode.Stelem_Ref:            break;          case OpCode.Ldelem:             value = (TypeNode)this.GetMemberFromToken();            break;          case OpCode.Stelem: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Unbox_Any: value = this.GetMemberFromToken(); break;          case OpCode.Conv_Ovf_I1:          case OpCode.Conv_Ovf_U1:          case OpCode.Conv_Ovf_I2:          case OpCode.Conv_Ovf_U2:          case OpCode.Conv_Ovf_I4:          case OpCode.Conv_Ovf_U4:          case OpCode.Conv_Ovf_I8:          case OpCode.Conv_Ovf_U8:            break;          case OpCode.Refanyval: value = this.GetMemberFromToken(); break;          case OpCode.Ckfinite: break;          case OpCode.Mkrefany: value = this.GetMemberFromToken(); break;          case OpCode.Ldtoken: value = this.GetMemberFromToken(); break;          case OpCode.Conv_U2:          case OpCode.Conv_U1:          case OpCode.Conv_I:          case OpCode.Conv_Ovf_I:          case OpCode.Conv_Ovf_U:          case OpCode.Add_Ovf:          case OpCode.Add_Ovf_Un:          case OpCode.Mul_Ovf:          case OpCode.Mul_Ovf_Un:          case OpCode.Sub_Ovf:          case OpCode.Sub_Ovf_Un:          case OpCode.Endfinally:             break;          case OpCode.Leave:   value = this.counter + 4 + this.GetInt32(); break;           case OpCode.Leave_S: value = this.counter + 1 + this.GetSByte(); break;          case OpCode.Stind_I:          case OpCode.Conv_U:          case OpCode.Prefix7:          case OpCode.Prefix6:          case OpCode.Prefix5:          case OpCode.Prefix4:          case OpCode.Prefix3:          case OpCode.Prefix2:          case OpCode.Prefix1:          case OpCode.Arglist:          case OpCode.Ceq:          case OpCode.Cgt:          case OpCode.Cgt_Un:          case OpCode.Clt:          case OpCode.Clt_Un:            break;          case OpCode.Ldftn:          case OpCode.Ldvirtftn:            value = this.GetMemberFromToken(); break;          case OpCode.Ldarg:          case OpCode.Ldarga:          case OpCode.Starg:            value = this.Parameters(this.GetInt16()); break;          case OpCode.Ldloc:          case OpCode.Ldloca:          case OpCode.Stloc:            value = this.locals[this.GetInt16()]; break;          case OpCode.Localloc:          case OpCode.Endfilter:            break;          case OpCode.Unaligned_: value = this.GetByte(); break;          case OpCode.Volatile_:          case OpCode.Tail_:            break;          case OpCode.Initobj: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Constrained_: value = this.GetMemberFromToken() as TypeNode; break;          case OpCode.Cpblk:           case OpCode.Initblk:            break;          case OpCode.Rethrow:            break;          case OpCode.Sizeof: value = this.GetMemberFromToken(); break;          case OpCode.Refanytype:          case OpCode.Readonly_:            break;          default: throw new InvalidMetadataException(String.Format(CultureInfo.CurrentCulture'             ExceptionStrings.UnknownOpCodeEncountered' opCode.ToString("x")));        }
Magic Number,Microsoft.Cci.Metadata,InstructionParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseInstruction,The following statement contains a magic number: switch(opCode){          case OpCode.Nop:          case OpCode.Break:             break;          case OpCode.Ldarg_0: value = this.Parameters(0); break;          case OpCode.Ldarg_1: value = this.Parameters(1); break;          case OpCode.Ldarg_2: value = this.Parameters(2); break;           case OpCode.Ldarg_3: value = this.Parameters(3); break;          case OpCode.Ldloc_0: value = this.locals[0]; break;          case OpCode.Ldloc_1: value = this.locals[1]; break;          case OpCode.Ldloc_2: value = this.locals[2]; break;          case OpCode.Ldloc_3: value = this.locals[3]; break;          case OpCode.Stloc_0: value = this.locals[0]; break;          case OpCode.Stloc_1: value = this.locals[1]; break;          case OpCode.Stloc_2: value = this.locals[2]; break;          case OpCode.Stloc_3: value = this.locals[3]; break;          case OpCode.Ldarg_S:            case OpCode.Ldarga_S:          case OpCode.Starg_S:            value = this.Parameters(this.GetByte()); break;          case OpCode.Ldloc_S:          case OpCode.Ldloca_S:          case OpCode.Stloc_S:            value = this.locals[this.GetByte()]; break;          case OpCode.Ldnull:             break;          case OpCode.Ldc_I4_M1: value = (Int32)(-1); break;          case OpCode.Ldc_I4_0: value = (Int32)0; break;          case OpCode.Ldc_I4_1: value = (Int32)1; break;          case OpCode.Ldc_I4_2: value = (Int32)2; break;          case OpCode.Ldc_I4_3: value = (Int32)3; break;          case OpCode.Ldc_I4_4: value = (Int32)4; break;          case OpCode.Ldc_I4_5: value = (Int32)5; break;          case OpCode.Ldc_I4_6: value = (Int32)6; break;          case OpCode.Ldc_I4_7: value = (Int32)7; break;          case OpCode.Ldc_I4_8: value = (Int32)8; break;          case OpCode.Ldc_I4_S: value = (Int32)this.GetSByte(); break;          case OpCode.Ldc_I4: value = this.GetInt32(); break;          case OpCode.Ldc_I8: value = this.GetInt64(); break;          case OpCode.Ldc_R4: value = this.GetSingle(); break;          case OpCode.Ldc_R8: value = this.GetDouble(); break;          case OpCode.Dup:          case OpCode.Pop:             break;          case OpCode.Jmp:           case OpCode.Call:            value = (Method)this.GetMemberFromToken(); break;          case OpCode.Calli:             value = (FunctionPointer)this.reader.GetCalliSignature(this.GetInt32()); break;          case OpCode.Ret: break;          case OpCode.Br_S:          case OpCode.Brfalse_S:          case OpCode.Brtrue_S:          case OpCode.Beq_S:          case OpCode.Bge_S:          case OpCode.Bgt_S:          case OpCode.Ble_S:          case OpCode.Blt_S:          case OpCode.Bne_Un_S:          case OpCode.Bge_Un_S:          case OpCode.Bgt_Un_S:          case OpCode.Ble_Un_S:          case OpCode.Blt_Un_S:            value = this.counter + 1 + this.GetSByte(); break;          case OpCode.Br:          case OpCode.Brfalse:          case OpCode.Brtrue:          case OpCode.Beq:          case OpCode.Bge:          case OpCode.Bgt:          case OpCode.Ble:          case OpCode.Blt:          case OpCode.Bne_Un:          case OpCode.Bge_Un:          case OpCode.Bgt_Un:          case OpCode.Ble_Un:          case OpCode.Blt_Un:            value = this.counter + 4 + this.GetInt32(); break;          case OpCode.Switch: value = this.ParseSwitchInstruction(); break;                  case OpCode.Ldind_I1:           case OpCode.Ldind_U1:          case OpCode.Ldind_I2:          case OpCode.Ldind_U2:          case OpCode.Ldind_I4:          case OpCode.Ldind_U4:          case OpCode.Ldind_I8:          case OpCode.Ldind_I:          case OpCode.Ldind_R4:          case OpCode.Ldind_R8:          case OpCode.Ldind_Ref:          case OpCode.Stind_Ref:          case OpCode.Stind_I1:          case OpCode.Stind_I2:          case OpCode.Stind_I4:          case OpCode.Stind_I8:          case OpCode.Stind_R4:          case OpCode.Stind_R8:          case OpCode.Add:          case OpCode.Sub:          case OpCode.Mul:          case OpCode.Div:          case OpCode.Div_Un:          case OpCode.Rem:          case OpCode.Rem_Un:          case OpCode.And:          case OpCode.Or:          case OpCode.Xor:          case OpCode.Shl:          case OpCode.Shr:          case OpCode.Shr_Un:          case OpCode.Neg:          case OpCode.Not:          case OpCode.Conv_I1:          case OpCode.Conv_I2:          case OpCode.Conv_I4:          case OpCode.Conv_I8:          case OpCode.Conv_R4:          case OpCode.Conv_R8:          case OpCode.Conv_U4:          case OpCode.Conv_U8:            break;          case OpCode.Callvirt: value = (Method)this.GetMemberFromToken(); break;          case OpCode.Cpobj:          case OpCode.Ldobj:             value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Ldstr: value = this.GetStringFromToken(); break;                    case OpCode.Newobj: value = (Method)this.GetMemberFromToken();break;          case OpCode.Castclass:          case OpCode.Isinst:             value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Conv_R_Un: break;                 case OpCode.Unbox: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Throw: break;          case OpCode.Ldfld:           case OpCode.Ldflda:          case OpCode.Stfld:          case OpCode.Ldsfld:          case OpCode.Ldsflda:          case OpCode.Stsfld:          case OpCode.Stobj:            value = this.GetMemberFromToken(); break;          case OpCode.Conv_Ovf_I1_Un:          case OpCode.Conv_Ovf_I2_Un:          case OpCode.Conv_Ovf_I4_Un:          case OpCode.Conv_Ovf_I8_Un:          case OpCode.Conv_Ovf_U1_Un:          case OpCode.Conv_Ovf_U2_Un:          case OpCode.Conv_Ovf_U4_Un:          case OpCode.Conv_Ovf_U8_Un:          case OpCode.Conv_Ovf_I_Un:          case OpCode.Conv_Ovf_U_Un:            break;          case OpCode.Box:          case OpCode.Newarr: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Ldlen: break;          case OpCode.Ldelema: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Ldelem_I1:          case OpCode.Ldelem_U1:          case OpCode.Ldelem_I2:          case OpCode.Ldelem_U2:          case OpCode.Ldelem_I4:          case OpCode.Ldelem_U4:          case OpCode.Ldelem_I8:          case OpCode.Ldelem_I:          case OpCode.Ldelem_R4:          case OpCode.Ldelem_R8:          case OpCode.Ldelem_Ref:           case OpCode.Stelem_I:          case OpCode.Stelem_I1:          case OpCode.Stelem_I2:          case OpCode.Stelem_I4:          case OpCode.Stelem_I8:          case OpCode.Stelem_R4:          case OpCode.Stelem_R8:          case OpCode.Stelem_Ref:            break;          case OpCode.Ldelem:             value = (TypeNode)this.GetMemberFromToken();            break;          case OpCode.Stelem: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Unbox_Any: value = this.GetMemberFromToken(); break;          case OpCode.Conv_Ovf_I1:          case OpCode.Conv_Ovf_U1:          case OpCode.Conv_Ovf_I2:          case OpCode.Conv_Ovf_U2:          case OpCode.Conv_Ovf_I4:          case OpCode.Conv_Ovf_U4:          case OpCode.Conv_Ovf_I8:          case OpCode.Conv_Ovf_U8:            break;          case OpCode.Refanyval: value = this.GetMemberFromToken(); break;          case OpCode.Ckfinite: break;          case OpCode.Mkrefany: value = this.GetMemberFromToken(); break;          case OpCode.Ldtoken: value = this.GetMemberFromToken(); break;          case OpCode.Conv_U2:          case OpCode.Conv_U1:          case OpCode.Conv_I:          case OpCode.Conv_Ovf_I:          case OpCode.Conv_Ovf_U:          case OpCode.Add_Ovf:          case OpCode.Add_Ovf_Un:          case OpCode.Mul_Ovf:          case OpCode.Mul_Ovf_Un:          case OpCode.Sub_Ovf:          case OpCode.Sub_Ovf_Un:          case OpCode.Endfinally:             break;          case OpCode.Leave:   value = this.counter + 4 + this.GetInt32(); break;           case OpCode.Leave_S: value = this.counter + 1 + this.GetSByte(); break;          case OpCode.Stind_I:          case OpCode.Conv_U:          case OpCode.Prefix7:          case OpCode.Prefix6:          case OpCode.Prefix5:          case OpCode.Prefix4:          case OpCode.Prefix3:          case OpCode.Prefix2:          case OpCode.Prefix1:          case OpCode.Arglist:          case OpCode.Ceq:          case OpCode.Cgt:          case OpCode.Cgt_Un:          case OpCode.Clt:          case OpCode.Clt_Un:            break;          case OpCode.Ldftn:          case OpCode.Ldvirtftn:            value = this.GetMemberFromToken(); break;          case OpCode.Ldarg:          case OpCode.Ldarga:          case OpCode.Starg:            value = this.Parameters(this.GetInt16()); break;          case OpCode.Ldloc:          case OpCode.Ldloca:          case OpCode.Stloc:            value = this.locals[this.GetInt16()]; break;          case OpCode.Localloc:          case OpCode.Endfilter:            break;          case OpCode.Unaligned_: value = this.GetByte(); break;          case OpCode.Volatile_:          case OpCode.Tail_:            break;          case OpCode.Initobj: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Constrained_: value = this.GetMemberFromToken() as TypeNode; break;          case OpCode.Cpblk:           case OpCode.Initblk:            break;          case OpCode.Rethrow:            break;          case OpCode.Sizeof: value = this.GetMemberFromToken(); break;          case OpCode.Refanytype:          case OpCode.Readonly_:            break;          default: throw new InvalidMetadataException(String.Format(CultureInfo.CurrentCulture'             ExceptionStrings.UnknownOpCodeEncountered' opCode.ToString("x")));        }
Magic Number,Microsoft.Cci.Metadata,InstructionParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseInstruction,The following statement contains a magic number: switch(opCode){          case OpCode.Nop:          case OpCode.Break:             break;          case OpCode.Ldarg_0: value = this.Parameters(0); break;          case OpCode.Ldarg_1: value = this.Parameters(1); break;          case OpCode.Ldarg_2: value = this.Parameters(2); break;           case OpCode.Ldarg_3: value = this.Parameters(3); break;          case OpCode.Ldloc_0: value = this.locals[0]; break;          case OpCode.Ldloc_1: value = this.locals[1]; break;          case OpCode.Ldloc_2: value = this.locals[2]; break;          case OpCode.Ldloc_3: value = this.locals[3]; break;          case OpCode.Stloc_0: value = this.locals[0]; break;          case OpCode.Stloc_1: value = this.locals[1]; break;          case OpCode.Stloc_2: value = this.locals[2]; break;          case OpCode.Stloc_3: value = this.locals[3]; break;          case OpCode.Ldarg_S:            case OpCode.Ldarga_S:          case OpCode.Starg_S:            value = this.Parameters(this.GetByte()); break;          case OpCode.Ldloc_S:          case OpCode.Ldloca_S:          case OpCode.Stloc_S:            value = this.locals[this.GetByte()]; break;          case OpCode.Ldnull:             break;          case OpCode.Ldc_I4_M1: value = (Int32)(-1); break;          case OpCode.Ldc_I4_0: value = (Int32)0; break;          case OpCode.Ldc_I4_1: value = (Int32)1; break;          case OpCode.Ldc_I4_2: value = (Int32)2; break;          case OpCode.Ldc_I4_3: value = (Int32)3; break;          case OpCode.Ldc_I4_4: value = (Int32)4; break;          case OpCode.Ldc_I4_5: value = (Int32)5; break;          case OpCode.Ldc_I4_6: value = (Int32)6; break;          case OpCode.Ldc_I4_7: value = (Int32)7; break;          case OpCode.Ldc_I4_8: value = (Int32)8; break;          case OpCode.Ldc_I4_S: value = (Int32)this.GetSByte(); break;          case OpCode.Ldc_I4: value = this.GetInt32(); break;          case OpCode.Ldc_I8: value = this.GetInt64(); break;          case OpCode.Ldc_R4: value = this.GetSingle(); break;          case OpCode.Ldc_R8: value = this.GetDouble(); break;          case OpCode.Dup:          case OpCode.Pop:             break;          case OpCode.Jmp:           case OpCode.Call:            value = (Method)this.GetMemberFromToken(); break;          case OpCode.Calli:             value = (FunctionPointer)this.reader.GetCalliSignature(this.GetInt32()); break;          case OpCode.Ret: break;          case OpCode.Br_S:          case OpCode.Brfalse_S:          case OpCode.Brtrue_S:          case OpCode.Beq_S:          case OpCode.Bge_S:          case OpCode.Bgt_S:          case OpCode.Ble_S:          case OpCode.Blt_S:          case OpCode.Bne_Un_S:          case OpCode.Bge_Un_S:          case OpCode.Bgt_Un_S:          case OpCode.Ble_Un_S:          case OpCode.Blt_Un_S:            value = this.counter + 1 + this.GetSByte(); break;          case OpCode.Br:          case OpCode.Brfalse:          case OpCode.Brtrue:          case OpCode.Beq:          case OpCode.Bge:          case OpCode.Bgt:          case OpCode.Ble:          case OpCode.Blt:          case OpCode.Bne_Un:          case OpCode.Bge_Un:          case OpCode.Bgt_Un:          case OpCode.Ble_Un:          case OpCode.Blt_Un:            value = this.counter + 4 + this.GetInt32(); break;          case OpCode.Switch: value = this.ParseSwitchInstruction(); break;                  case OpCode.Ldind_I1:           case OpCode.Ldind_U1:          case OpCode.Ldind_I2:          case OpCode.Ldind_U2:          case OpCode.Ldind_I4:          case OpCode.Ldind_U4:          case OpCode.Ldind_I8:          case OpCode.Ldind_I:          case OpCode.Ldind_R4:          case OpCode.Ldind_R8:          case OpCode.Ldind_Ref:          case OpCode.Stind_Ref:          case OpCode.Stind_I1:          case OpCode.Stind_I2:          case OpCode.Stind_I4:          case OpCode.Stind_I8:          case OpCode.Stind_R4:          case OpCode.Stind_R8:          case OpCode.Add:          case OpCode.Sub:          case OpCode.Mul:          case OpCode.Div:          case OpCode.Div_Un:          case OpCode.Rem:          case OpCode.Rem_Un:          case OpCode.And:          case OpCode.Or:          case OpCode.Xor:          case OpCode.Shl:          case OpCode.Shr:          case OpCode.Shr_Un:          case OpCode.Neg:          case OpCode.Not:          case OpCode.Conv_I1:          case OpCode.Conv_I2:          case OpCode.Conv_I4:          case OpCode.Conv_I8:          case OpCode.Conv_R4:          case OpCode.Conv_R8:          case OpCode.Conv_U4:          case OpCode.Conv_U8:            break;          case OpCode.Callvirt: value = (Method)this.GetMemberFromToken(); break;          case OpCode.Cpobj:          case OpCode.Ldobj:             value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Ldstr: value = this.GetStringFromToken(); break;                    case OpCode.Newobj: value = (Method)this.GetMemberFromToken();break;          case OpCode.Castclass:          case OpCode.Isinst:             value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Conv_R_Un: break;                 case OpCode.Unbox: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Throw: break;          case OpCode.Ldfld:           case OpCode.Ldflda:          case OpCode.Stfld:          case OpCode.Ldsfld:          case OpCode.Ldsflda:          case OpCode.Stsfld:          case OpCode.Stobj:            value = this.GetMemberFromToken(); break;          case OpCode.Conv_Ovf_I1_Un:          case OpCode.Conv_Ovf_I2_Un:          case OpCode.Conv_Ovf_I4_Un:          case OpCode.Conv_Ovf_I8_Un:          case OpCode.Conv_Ovf_U1_Un:          case OpCode.Conv_Ovf_U2_Un:          case OpCode.Conv_Ovf_U4_Un:          case OpCode.Conv_Ovf_U8_Un:          case OpCode.Conv_Ovf_I_Un:          case OpCode.Conv_Ovf_U_Un:            break;          case OpCode.Box:          case OpCode.Newarr: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Ldlen: break;          case OpCode.Ldelema: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Ldelem_I1:          case OpCode.Ldelem_U1:          case OpCode.Ldelem_I2:          case OpCode.Ldelem_U2:          case OpCode.Ldelem_I4:          case OpCode.Ldelem_U4:          case OpCode.Ldelem_I8:          case OpCode.Ldelem_I:          case OpCode.Ldelem_R4:          case OpCode.Ldelem_R8:          case OpCode.Ldelem_Ref:           case OpCode.Stelem_I:          case OpCode.Stelem_I1:          case OpCode.Stelem_I2:          case OpCode.Stelem_I4:          case OpCode.Stelem_I8:          case OpCode.Stelem_R4:          case OpCode.Stelem_R8:          case OpCode.Stelem_Ref:            break;          case OpCode.Ldelem:             value = (TypeNode)this.GetMemberFromToken();            break;          case OpCode.Stelem: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Unbox_Any: value = this.GetMemberFromToken(); break;          case OpCode.Conv_Ovf_I1:          case OpCode.Conv_Ovf_U1:          case OpCode.Conv_Ovf_I2:          case OpCode.Conv_Ovf_U2:          case OpCode.Conv_Ovf_I4:          case OpCode.Conv_Ovf_U4:          case OpCode.Conv_Ovf_I8:          case OpCode.Conv_Ovf_U8:            break;          case OpCode.Refanyval: value = this.GetMemberFromToken(); break;          case OpCode.Ckfinite: break;          case OpCode.Mkrefany: value = this.GetMemberFromToken(); break;          case OpCode.Ldtoken: value = this.GetMemberFromToken(); break;          case OpCode.Conv_U2:          case OpCode.Conv_U1:          case OpCode.Conv_I:          case OpCode.Conv_Ovf_I:          case OpCode.Conv_Ovf_U:          case OpCode.Add_Ovf:          case OpCode.Add_Ovf_Un:          case OpCode.Mul_Ovf:          case OpCode.Mul_Ovf_Un:          case OpCode.Sub_Ovf:          case OpCode.Sub_Ovf_Un:          case OpCode.Endfinally:             break;          case OpCode.Leave:   value = this.counter + 4 + this.GetInt32(); break;           case OpCode.Leave_S: value = this.counter + 1 + this.GetSByte(); break;          case OpCode.Stind_I:          case OpCode.Conv_U:          case OpCode.Prefix7:          case OpCode.Prefix6:          case OpCode.Prefix5:          case OpCode.Prefix4:          case OpCode.Prefix3:          case OpCode.Prefix2:          case OpCode.Prefix1:          case OpCode.Arglist:          case OpCode.Ceq:          case OpCode.Cgt:          case OpCode.Cgt_Un:          case OpCode.Clt:          case OpCode.Clt_Un:            break;          case OpCode.Ldftn:          case OpCode.Ldvirtftn:            value = this.GetMemberFromToken(); break;          case OpCode.Ldarg:          case OpCode.Ldarga:          case OpCode.Starg:            value = this.Parameters(this.GetInt16()); break;          case OpCode.Ldloc:          case OpCode.Ldloca:          case OpCode.Stloc:            value = this.locals[this.GetInt16()]; break;          case OpCode.Localloc:          case OpCode.Endfilter:            break;          case OpCode.Unaligned_: value = this.GetByte(); break;          case OpCode.Volatile_:          case OpCode.Tail_:            break;          case OpCode.Initobj: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Constrained_: value = this.GetMemberFromToken() as TypeNode; break;          case OpCode.Cpblk:           case OpCode.Initblk:            break;          case OpCode.Rethrow:            break;          case OpCode.Sizeof: value = this.GetMemberFromToken(); break;          case OpCode.Refanytype:          case OpCode.Readonly_:            break;          default: throw new InvalidMetadataException(String.Format(CultureInfo.CurrentCulture'             ExceptionStrings.UnknownOpCodeEncountered' opCode.ToString("x")));        }
Magic Number,Microsoft.Cci.Metadata,InstructionParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseInstruction,The following statement contains a magic number: switch(opCode){          case OpCode.Nop:          case OpCode.Break:             break;          case OpCode.Ldarg_0: value = this.Parameters(0); break;          case OpCode.Ldarg_1: value = this.Parameters(1); break;          case OpCode.Ldarg_2: value = this.Parameters(2); break;           case OpCode.Ldarg_3: value = this.Parameters(3); break;          case OpCode.Ldloc_0: value = this.locals[0]; break;          case OpCode.Ldloc_1: value = this.locals[1]; break;          case OpCode.Ldloc_2: value = this.locals[2]; break;          case OpCode.Ldloc_3: value = this.locals[3]; break;          case OpCode.Stloc_0: value = this.locals[0]; break;          case OpCode.Stloc_1: value = this.locals[1]; break;          case OpCode.Stloc_2: value = this.locals[2]; break;          case OpCode.Stloc_3: value = this.locals[3]; break;          case OpCode.Ldarg_S:            case OpCode.Ldarga_S:          case OpCode.Starg_S:            value = this.Parameters(this.GetByte()); break;          case OpCode.Ldloc_S:          case OpCode.Ldloca_S:          case OpCode.Stloc_S:            value = this.locals[this.GetByte()]; break;          case OpCode.Ldnull:             break;          case OpCode.Ldc_I4_M1: value = (Int32)(-1); break;          case OpCode.Ldc_I4_0: value = (Int32)0; break;          case OpCode.Ldc_I4_1: value = (Int32)1; break;          case OpCode.Ldc_I4_2: value = (Int32)2; break;          case OpCode.Ldc_I4_3: value = (Int32)3; break;          case OpCode.Ldc_I4_4: value = (Int32)4; break;          case OpCode.Ldc_I4_5: value = (Int32)5; break;          case OpCode.Ldc_I4_6: value = (Int32)6; break;          case OpCode.Ldc_I4_7: value = (Int32)7; break;          case OpCode.Ldc_I4_8: value = (Int32)8; break;          case OpCode.Ldc_I4_S: value = (Int32)this.GetSByte(); break;          case OpCode.Ldc_I4: value = this.GetInt32(); break;          case OpCode.Ldc_I8: value = this.GetInt64(); break;          case OpCode.Ldc_R4: value = this.GetSingle(); break;          case OpCode.Ldc_R8: value = this.GetDouble(); break;          case OpCode.Dup:          case OpCode.Pop:             break;          case OpCode.Jmp:           case OpCode.Call:            value = (Method)this.GetMemberFromToken(); break;          case OpCode.Calli:             value = (FunctionPointer)this.reader.GetCalliSignature(this.GetInt32()); break;          case OpCode.Ret: break;          case OpCode.Br_S:          case OpCode.Brfalse_S:          case OpCode.Brtrue_S:          case OpCode.Beq_S:          case OpCode.Bge_S:          case OpCode.Bgt_S:          case OpCode.Ble_S:          case OpCode.Blt_S:          case OpCode.Bne_Un_S:          case OpCode.Bge_Un_S:          case OpCode.Bgt_Un_S:          case OpCode.Ble_Un_S:          case OpCode.Blt_Un_S:            value = this.counter + 1 + this.GetSByte(); break;          case OpCode.Br:          case OpCode.Brfalse:          case OpCode.Brtrue:          case OpCode.Beq:          case OpCode.Bge:          case OpCode.Bgt:          case OpCode.Ble:          case OpCode.Blt:          case OpCode.Bne_Un:          case OpCode.Bge_Un:          case OpCode.Bgt_Un:          case OpCode.Ble_Un:          case OpCode.Blt_Un:            value = this.counter + 4 + this.GetInt32(); break;          case OpCode.Switch: value = this.ParseSwitchInstruction(); break;                  case OpCode.Ldind_I1:           case OpCode.Ldind_U1:          case OpCode.Ldind_I2:          case OpCode.Ldind_U2:          case OpCode.Ldind_I4:          case OpCode.Ldind_U4:          case OpCode.Ldind_I8:          case OpCode.Ldind_I:          case OpCode.Ldind_R4:          case OpCode.Ldind_R8:          case OpCode.Ldind_Ref:          case OpCode.Stind_Ref:          case OpCode.Stind_I1:          case OpCode.Stind_I2:          case OpCode.Stind_I4:          case OpCode.Stind_I8:          case OpCode.Stind_R4:          case OpCode.Stind_R8:          case OpCode.Add:          case OpCode.Sub:          case OpCode.Mul:          case OpCode.Div:          case OpCode.Div_Un:          case OpCode.Rem:          case OpCode.Rem_Un:          case OpCode.And:          case OpCode.Or:          case OpCode.Xor:          case OpCode.Shl:          case OpCode.Shr:          case OpCode.Shr_Un:          case OpCode.Neg:          case OpCode.Not:          case OpCode.Conv_I1:          case OpCode.Conv_I2:          case OpCode.Conv_I4:          case OpCode.Conv_I8:          case OpCode.Conv_R4:          case OpCode.Conv_R8:          case OpCode.Conv_U4:          case OpCode.Conv_U8:            break;          case OpCode.Callvirt: value = (Method)this.GetMemberFromToken(); break;          case OpCode.Cpobj:          case OpCode.Ldobj:             value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Ldstr: value = this.GetStringFromToken(); break;                    case OpCode.Newobj: value = (Method)this.GetMemberFromToken();break;          case OpCode.Castclass:          case OpCode.Isinst:             value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Conv_R_Un: break;                 case OpCode.Unbox: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Throw: break;          case OpCode.Ldfld:           case OpCode.Ldflda:          case OpCode.Stfld:          case OpCode.Ldsfld:          case OpCode.Ldsflda:          case OpCode.Stsfld:          case OpCode.Stobj:            value = this.GetMemberFromToken(); break;          case OpCode.Conv_Ovf_I1_Un:          case OpCode.Conv_Ovf_I2_Un:          case OpCode.Conv_Ovf_I4_Un:          case OpCode.Conv_Ovf_I8_Un:          case OpCode.Conv_Ovf_U1_Un:          case OpCode.Conv_Ovf_U2_Un:          case OpCode.Conv_Ovf_U4_Un:          case OpCode.Conv_Ovf_U8_Un:          case OpCode.Conv_Ovf_I_Un:          case OpCode.Conv_Ovf_U_Un:            break;          case OpCode.Box:          case OpCode.Newarr: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Ldlen: break;          case OpCode.Ldelema: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Ldelem_I1:          case OpCode.Ldelem_U1:          case OpCode.Ldelem_I2:          case OpCode.Ldelem_U2:          case OpCode.Ldelem_I4:          case OpCode.Ldelem_U4:          case OpCode.Ldelem_I8:          case OpCode.Ldelem_I:          case OpCode.Ldelem_R4:          case OpCode.Ldelem_R8:          case OpCode.Ldelem_Ref:           case OpCode.Stelem_I:          case OpCode.Stelem_I1:          case OpCode.Stelem_I2:          case OpCode.Stelem_I4:          case OpCode.Stelem_I8:          case OpCode.Stelem_R4:          case OpCode.Stelem_R8:          case OpCode.Stelem_Ref:            break;          case OpCode.Ldelem:             value = (TypeNode)this.GetMemberFromToken();            break;          case OpCode.Stelem: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Unbox_Any: value = this.GetMemberFromToken(); break;          case OpCode.Conv_Ovf_I1:          case OpCode.Conv_Ovf_U1:          case OpCode.Conv_Ovf_I2:          case OpCode.Conv_Ovf_U2:          case OpCode.Conv_Ovf_I4:          case OpCode.Conv_Ovf_U4:          case OpCode.Conv_Ovf_I8:          case OpCode.Conv_Ovf_U8:            break;          case OpCode.Refanyval: value = this.GetMemberFromToken(); break;          case OpCode.Ckfinite: break;          case OpCode.Mkrefany: value = this.GetMemberFromToken(); break;          case OpCode.Ldtoken: value = this.GetMemberFromToken(); break;          case OpCode.Conv_U2:          case OpCode.Conv_U1:          case OpCode.Conv_I:          case OpCode.Conv_Ovf_I:          case OpCode.Conv_Ovf_U:          case OpCode.Add_Ovf:          case OpCode.Add_Ovf_Un:          case OpCode.Mul_Ovf:          case OpCode.Mul_Ovf_Un:          case OpCode.Sub_Ovf:          case OpCode.Sub_Ovf_Un:          case OpCode.Endfinally:             break;          case OpCode.Leave:   value = this.counter + 4 + this.GetInt32(); break;           case OpCode.Leave_S: value = this.counter + 1 + this.GetSByte(); break;          case OpCode.Stind_I:          case OpCode.Conv_U:          case OpCode.Prefix7:          case OpCode.Prefix6:          case OpCode.Prefix5:          case OpCode.Prefix4:          case OpCode.Prefix3:          case OpCode.Prefix2:          case OpCode.Prefix1:          case OpCode.Arglist:          case OpCode.Ceq:          case OpCode.Cgt:          case OpCode.Cgt_Un:          case OpCode.Clt:          case OpCode.Clt_Un:            break;          case OpCode.Ldftn:          case OpCode.Ldvirtftn:            value = this.GetMemberFromToken(); break;          case OpCode.Ldarg:          case OpCode.Ldarga:          case OpCode.Starg:            value = this.Parameters(this.GetInt16()); break;          case OpCode.Ldloc:          case OpCode.Ldloca:          case OpCode.Stloc:            value = this.locals[this.GetInt16()]; break;          case OpCode.Localloc:          case OpCode.Endfilter:            break;          case OpCode.Unaligned_: value = this.GetByte(); break;          case OpCode.Volatile_:          case OpCode.Tail_:            break;          case OpCode.Initobj: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Constrained_: value = this.GetMemberFromToken() as TypeNode; break;          case OpCode.Cpblk:           case OpCode.Initblk:            break;          case OpCode.Rethrow:            break;          case OpCode.Sizeof: value = this.GetMemberFromToken(); break;          case OpCode.Refanytype:          case OpCode.Readonly_:            break;          default: throw new InvalidMetadataException(String.Format(CultureInfo.CurrentCulture'             ExceptionStrings.UnknownOpCodeEncountered' opCode.ToString("x")));        }
Magic Number,Microsoft.Cci.Metadata,InstructionParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseInstruction,The following statement contains a magic number: switch(opCode){          case OpCode.Nop:          case OpCode.Break:             break;          case OpCode.Ldarg_0: value = this.Parameters(0); break;          case OpCode.Ldarg_1: value = this.Parameters(1); break;          case OpCode.Ldarg_2: value = this.Parameters(2); break;           case OpCode.Ldarg_3: value = this.Parameters(3); break;          case OpCode.Ldloc_0: value = this.locals[0]; break;          case OpCode.Ldloc_1: value = this.locals[1]; break;          case OpCode.Ldloc_2: value = this.locals[2]; break;          case OpCode.Ldloc_3: value = this.locals[3]; break;          case OpCode.Stloc_0: value = this.locals[0]; break;          case OpCode.Stloc_1: value = this.locals[1]; break;          case OpCode.Stloc_2: value = this.locals[2]; break;          case OpCode.Stloc_3: value = this.locals[3]; break;          case OpCode.Ldarg_S:            case OpCode.Ldarga_S:          case OpCode.Starg_S:            value = this.Parameters(this.GetByte()); break;          case OpCode.Ldloc_S:          case OpCode.Ldloca_S:          case OpCode.Stloc_S:            value = this.locals[this.GetByte()]; break;          case OpCode.Ldnull:             break;          case OpCode.Ldc_I4_M1: value = (Int32)(-1); break;          case OpCode.Ldc_I4_0: value = (Int32)0; break;          case OpCode.Ldc_I4_1: value = (Int32)1; break;          case OpCode.Ldc_I4_2: value = (Int32)2; break;          case OpCode.Ldc_I4_3: value = (Int32)3; break;          case OpCode.Ldc_I4_4: value = (Int32)4; break;          case OpCode.Ldc_I4_5: value = (Int32)5; break;          case OpCode.Ldc_I4_6: value = (Int32)6; break;          case OpCode.Ldc_I4_7: value = (Int32)7; break;          case OpCode.Ldc_I4_8: value = (Int32)8; break;          case OpCode.Ldc_I4_S: value = (Int32)this.GetSByte(); break;          case OpCode.Ldc_I4: value = this.GetInt32(); break;          case OpCode.Ldc_I8: value = this.GetInt64(); break;          case OpCode.Ldc_R4: value = this.GetSingle(); break;          case OpCode.Ldc_R8: value = this.GetDouble(); break;          case OpCode.Dup:          case OpCode.Pop:             break;          case OpCode.Jmp:           case OpCode.Call:            value = (Method)this.GetMemberFromToken(); break;          case OpCode.Calli:             value = (FunctionPointer)this.reader.GetCalliSignature(this.GetInt32()); break;          case OpCode.Ret: break;          case OpCode.Br_S:          case OpCode.Brfalse_S:          case OpCode.Brtrue_S:          case OpCode.Beq_S:          case OpCode.Bge_S:          case OpCode.Bgt_S:          case OpCode.Ble_S:          case OpCode.Blt_S:          case OpCode.Bne_Un_S:          case OpCode.Bge_Un_S:          case OpCode.Bgt_Un_S:          case OpCode.Ble_Un_S:          case OpCode.Blt_Un_S:            value = this.counter + 1 + this.GetSByte(); break;          case OpCode.Br:          case OpCode.Brfalse:          case OpCode.Brtrue:          case OpCode.Beq:          case OpCode.Bge:          case OpCode.Bgt:          case OpCode.Ble:          case OpCode.Blt:          case OpCode.Bne_Un:          case OpCode.Bge_Un:          case OpCode.Bgt_Un:          case OpCode.Ble_Un:          case OpCode.Blt_Un:            value = this.counter + 4 + this.GetInt32(); break;          case OpCode.Switch: value = this.ParseSwitchInstruction(); break;                  case OpCode.Ldind_I1:           case OpCode.Ldind_U1:          case OpCode.Ldind_I2:          case OpCode.Ldind_U2:          case OpCode.Ldind_I4:          case OpCode.Ldind_U4:          case OpCode.Ldind_I8:          case OpCode.Ldind_I:          case OpCode.Ldind_R4:          case OpCode.Ldind_R8:          case OpCode.Ldind_Ref:          case OpCode.Stind_Ref:          case OpCode.Stind_I1:          case OpCode.Stind_I2:          case OpCode.Stind_I4:          case OpCode.Stind_I8:          case OpCode.Stind_R4:          case OpCode.Stind_R8:          case OpCode.Add:          case OpCode.Sub:          case OpCode.Mul:          case OpCode.Div:          case OpCode.Div_Un:          case OpCode.Rem:          case OpCode.Rem_Un:          case OpCode.And:          case OpCode.Or:          case OpCode.Xor:          case OpCode.Shl:          case OpCode.Shr:          case OpCode.Shr_Un:          case OpCode.Neg:          case OpCode.Not:          case OpCode.Conv_I1:          case OpCode.Conv_I2:          case OpCode.Conv_I4:          case OpCode.Conv_I8:          case OpCode.Conv_R4:          case OpCode.Conv_R8:          case OpCode.Conv_U4:          case OpCode.Conv_U8:            break;          case OpCode.Callvirt: value = (Method)this.GetMemberFromToken(); break;          case OpCode.Cpobj:          case OpCode.Ldobj:             value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Ldstr: value = this.GetStringFromToken(); break;                    case OpCode.Newobj: value = (Method)this.GetMemberFromToken();break;          case OpCode.Castclass:          case OpCode.Isinst:             value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Conv_R_Un: break;                 case OpCode.Unbox: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Throw: break;          case OpCode.Ldfld:           case OpCode.Ldflda:          case OpCode.Stfld:          case OpCode.Ldsfld:          case OpCode.Ldsflda:          case OpCode.Stsfld:          case OpCode.Stobj:            value = this.GetMemberFromToken(); break;          case OpCode.Conv_Ovf_I1_Un:          case OpCode.Conv_Ovf_I2_Un:          case OpCode.Conv_Ovf_I4_Un:          case OpCode.Conv_Ovf_I8_Un:          case OpCode.Conv_Ovf_U1_Un:          case OpCode.Conv_Ovf_U2_Un:          case OpCode.Conv_Ovf_U4_Un:          case OpCode.Conv_Ovf_U8_Un:          case OpCode.Conv_Ovf_I_Un:          case OpCode.Conv_Ovf_U_Un:            break;          case OpCode.Box:          case OpCode.Newarr: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Ldlen: break;          case OpCode.Ldelema: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Ldelem_I1:          case OpCode.Ldelem_U1:          case OpCode.Ldelem_I2:          case OpCode.Ldelem_U2:          case OpCode.Ldelem_I4:          case OpCode.Ldelem_U4:          case OpCode.Ldelem_I8:          case OpCode.Ldelem_I:          case OpCode.Ldelem_R4:          case OpCode.Ldelem_R8:          case OpCode.Ldelem_Ref:           case OpCode.Stelem_I:          case OpCode.Stelem_I1:          case OpCode.Stelem_I2:          case OpCode.Stelem_I4:          case OpCode.Stelem_I8:          case OpCode.Stelem_R4:          case OpCode.Stelem_R8:          case OpCode.Stelem_Ref:            break;          case OpCode.Ldelem:             value = (TypeNode)this.GetMemberFromToken();            break;          case OpCode.Stelem: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Unbox_Any: value = this.GetMemberFromToken(); break;          case OpCode.Conv_Ovf_I1:          case OpCode.Conv_Ovf_U1:          case OpCode.Conv_Ovf_I2:          case OpCode.Conv_Ovf_U2:          case OpCode.Conv_Ovf_I4:          case OpCode.Conv_Ovf_U4:          case OpCode.Conv_Ovf_I8:          case OpCode.Conv_Ovf_U8:            break;          case OpCode.Refanyval: value = this.GetMemberFromToken(); break;          case OpCode.Ckfinite: break;          case OpCode.Mkrefany: value = this.GetMemberFromToken(); break;          case OpCode.Ldtoken: value = this.GetMemberFromToken(); break;          case OpCode.Conv_U2:          case OpCode.Conv_U1:          case OpCode.Conv_I:          case OpCode.Conv_Ovf_I:          case OpCode.Conv_Ovf_U:          case OpCode.Add_Ovf:          case OpCode.Add_Ovf_Un:          case OpCode.Mul_Ovf:          case OpCode.Mul_Ovf_Un:          case OpCode.Sub_Ovf:          case OpCode.Sub_Ovf_Un:          case OpCode.Endfinally:             break;          case OpCode.Leave:   value = this.counter + 4 + this.GetInt32(); break;           case OpCode.Leave_S: value = this.counter + 1 + this.GetSByte(); break;          case OpCode.Stind_I:          case OpCode.Conv_U:          case OpCode.Prefix7:          case OpCode.Prefix6:          case OpCode.Prefix5:          case OpCode.Prefix4:          case OpCode.Prefix3:          case OpCode.Prefix2:          case OpCode.Prefix1:          case OpCode.Arglist:          case OpCode.Ceq:          case OpCode.Cgt:          case OpCode.Cgt_Un:          case OpCode.Clt:          case OpCode.Clt_Un:            break;          case OpCode.Ldftn:          case OpCode.Ldvirtftn:            value = this.GetMemberFromToken(); break;          case OpCode.Ldarg:          case OpCode.Ldarga:          case OpCode.Starg:            value = this.Parameters(this.GetInt16()); break;          case OpCode.Ldloc:          case OpCode.Ldloca:          case OpCode.Stloc:            value = this.locals[this.GetInt16()]; break;          case OpCode.Localloc:          case OpCode.Endfilter:            break;          case OpCode.Unaligned_: value = this.GetByte(); break;          case OpCode.Volatile_:          case OpCode.Tail_:            break;          case OpCode.Initobj: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Constrained_: value = this.GetMemberFromToken() as TypeNode; break;          case OpCode.Cpblk:           case OpCode.Initblk:            break;          case OpCode.Rethrow:            break;          case OpCode.Sizeof: value = this.GetMemberFromToken(); break;          case OpCode.Refanytype:          case OpCode.Readonly_:            break;          default: throw new InvalidMetadataException(String.Format(CultureInfo.CurrentCulture'             ExceptionStrings.UnknownOpCodeEncountered' opCode.ToString("x")));        }
Magic Number,Microsoft.Cci.Metadata,InstructionParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseInstruction,The following statement contains a magic number: switch(opCode){          case OpCode.Nop:          case OpCode.Break:             break;          case OpCode.Ldarg_0: value = this.Parameters(0); break;          case OpCode.Ldarg_1: value = this.Parameters(1); break;          case OpCode.Ldarg_2: value = this.Parameters(2); break;           case OpCode.Ldarg_3: value = this.Parameters(3); break;          case OpCode.Ldloc_0: value = this.locals[0]; break;          case OpCode.Ldloc_1: value = this.locals[1]; break;          case OpCode.Ldloc_2: value = this.locals[2]; break;          case OpCode.Ldloc_3: value = this.locals[3]; break;          case OpCode.Stloc_0: value = this.locals[0]; break;          case OpCode.Stloc_1: value = this.locals[1]; break;          case OpCode.Stloc_2: value = this.locals[2]; break;          case OpCode.Stloc_3: value = this.locals[3]; break;          case OpCode.Ldarg_S:            case OpCode.Ldarga_S:          case OpCode.Starg_S:            value = this.Parameters(this.GetByte()); break;          case OpCode.Ldloc_S:          case OpCode.Ldloca_S:          case OpCode.Stloc_S:            value = this.locals[this.GetByte()]; break;          case OpCode.Ldnull:             break;          case OpCode.Ldc_I4_M1: value = (Int32)(-1); break;          case OpCode.Ldc_I4_0: value = (Int32)0; break;          case OpCode.Ldc_I4_1: value = (Int32)1; break;          case OpCode.Ldc_I4_2: value = (Int32)2; break;          case OpCode.Ldc_I4_3: value = (Int32)3; break;          case OpCode.Ldc_I4_4: value = (Int32)4; break;          case OpCode.Ldc_I4_5: value = (Int32)5; break;          case OpCode.Ldc_I4_6: value = (Int32)6; break;          case OpCode.Ldc_I4_7: value = (Int32)7; break;          case OpCode.Ldc_I4_8: value = (Int32)8; break;          case OpCode.Ldc_I4_S: value = (Int32)this.GetSByte(); break;          case OpCode.Ldc_I4: value = this.GetInt32(); break;          case OpCode.Ldc_I8: value = this.GetInt64(); break;          case OpCode.Ldc_R4: value = this.GetSingle(); break;          case OpCode.Ldc_R8: value = this.GetDouble(); break;          case OpCode.Dup:          case OpCode.Pop:             break;          case OpCode.Jmp:           case OpCode.Call:            value = (Method)this.GetMemberFromToken(); break;          case OpCode.Calli:             value = (FunctionPointer)this.reader.GetCalliSignature(this.GetInt32()); break;          case OpCode.Ret: break;          case OpCode.Br_S:          case OpCode.Brfalse_S:          case OpCode.Brtrue_S:          case OpCode.Beq_S:          case OpCode.Bge_S:          case OpCode.Bgt_S:          case OpCode.Ble_S:          case OpCode.Blt_S:          case OpCode.Bne_Un_S:          case OpCode.Bge_Un_S:          case OpCode.Bgt_Un_S:          case OpCode.Ble_Un_S:          case OpCode.Blt_Un_S:            value = this.counter + 1 + this.GetSByte(); break;          case OpCode.Br:          case OpCode.Brfalse:          case OpCode.Brtrue:          case OpCode.Beq:          case OpCode.Bge:          case OpCode.Bgt:          case OpCode.Ble:          case OpCode.Blt:          case OpCode.Bne_Un:          case OpCode.Bge_Un:          case OpCode.Bgt_Un:          case OpCode.Ble_Un:          case OpCode.Blt_Un:            value = this.counter + 4 + this.GetInt32(); break;          case OpCode.Switch: value = this.ParseSwitchInstruction(); break;                  case OpCode.Ldind_I1:           case OpCode.Ldind_U1:          case OpCode.Ldind_I2:          case OpCode.Ldind_U2:          case OpCode.Ldind_I4:          case OpCode.Ldind_U4:          case OpCode.Ldind_I8:          case OpCode.Ldind_I:          case OpCode.Ldind_R4:          case OpCode.Ldind_R8:          case OpCode.Ldind_Ref:          case OpCode.Stind_Ref:          case OpCode.Stind_I1:          case OpCode.Stind_I2:          case OpCode.Stind_I4:          case OpCode.Stind_I8:          case OpCode.Stind_R4:          case OpCode.Stind_R8:          case OpCode.Add:          case OpCode.Sub:          case OpCode.Mul:          case OpCode.Div:          case OpCode.Div_Un:          case OpCode.Rem:          case OpCode.Rem_Un:          case OpCode.And:          case OpCode.Or:          case OpCode.Xor:          case OpCode.Shl:          case OpCode.Shr:          case OpCode.Shr_Un:          case OpCode.Neg:          case OpCode.Not:          case OpCode.Conv_I1:          case OpCode.Conv_I2:          case OpCode.Conv_I4:          case OpCode.Conv_I8:          case OpCode.Conv_R4:          case OpCode.Conv_R8:          case OpCode.Conv_U4:          case OpCode.Conv_U8:            break;          case OpCode.Callvirt: value = (Method)this.GetMemberFromToken(); break;          case OpCode.Cpobj:          case OpCode.Ldobj:             value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Ldstr: value = this.GetStringFromToken(); break;                    case OpCode.Newobj: value = (Method)this.GetMemberFromToken();break;          case OpCode.Castclass:          case OpCode.Isinst:             value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Conv_R_Un: break;                 case OpCode.Unbox: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Throw: break;          case OpCode.Ldfld:           case OpCode.Ldflda:          case OpCode.Stfld:          case OpCode.Ldsfld:          case OpCode.Ldsflda:          case OpCode.Stsfld:          case OpCode.Stobj:            value = this.GetMemberFromToken(); break;          case OpCode.Conv_Ovf_I1_Un:          case OpCode.Conv_Ovf_I2_Un:          case OpCode.Conv_Ovf_I4_Un:          case OpCode.Conv_Ovf_I8_Un:          case OpCode.Conv_Ovf_U1_Un:          case OpCode.Conv_Ovf_U2_Un:          case OpCode.Conv_Ovf_U4_Un:          case OpCode.Conv_Ovf_U8_Un:          case OpCode.Conv_Ovf_I_Un:          case OpCode.Conv_Ovf_U_Un:            break;          case OpCode.Box:          case OpCode.Newarr: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Ldlen: break;          case OpCode.Ldelema: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Ldelem_I1:          case OpCode.Ldelem_U1:          case OpCode.Ldelem_I2:          case OpCode.Ldelem_U2:          case OpCode.Ldelem_I4:          case OpCode.Ldelem_U4:          case OpCode.Ldelem_I8:          case OpCode.Ldelem_I:          case OpCode.Ldelem_R4:          case OpCode.Ldelem_R8:          case OpCode.Ldelem_Ref:           case OpCode.Stelem_I:          case OpCode.Stelem_I1:          case OpCode.Stelem_I2:          case OpCode.Stelem_I4:          case OpCode.Stelem_I8:          case OpCode.Stelem_R4:          case OpCode.Stelem_R8:          case OpCode.Stelem_Ref:            break;          case OpCode.Ldelem:             value = (TypeNode)this.GetMemberFromToken();            break;          case OpCode.Stelem: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Unbox_Any: value = this.GetMemberFromToken(); break;          case OpCode.Conv_Ovf_I1:          case OpCode.Conv_Ovf_U1:          case OpCode.Conv_Ovf_I2:          case OpCode.Conv_Ovf_U2:          case OpCode.Conv_Ovf_I4:          case OpCode.Conv_Ovf_U4:          case OpCode.Conv_Ovf_I8:          case OpCode.Conv_Ovf_U8:            break;          case OpCode.Refanyval: value = this.GetMemberFromToken(); break;          case OpCode.Ckfinite: break;          case OpCode.Mkrefany: value = this.GetMemberFromToken(); break;          case OpCode.Ldtoken: value = this.GetMemberFromToken(); break;          case OpCode.Conv_U2:          case OpCode.Conv_U1:          case OpCode.Conv_I:          case OpCode.Conv_Ovf_I:          case OpCode.Conv_Ovf_U:          case OpCode.Add_Ovf:          case OpCode.Add_Ovf_Un:          case OpCode.Mul_Ovf:          case OpCode.Mul_Ovf_Un:          case OpCode.Sub_Ovf:          case OpCode.Sub_Ovf_Un:          case OpCode.Endfinally:             break;          case OpCode.Leave:   value = this.counter + 4 + this.GetInt32(); break;           case OpCode.Leave_S: value = this.counter + 1 + this.GetSByte(); break;          case OpCode.Stind_I:          case OpCode.Conv_U:          case OpCode.Prefix7:          case OpCode.Prefix6:          case OpCode.Prefix5:          case OpCode.Prefix4:          case OpCode.Prefix3:          case OpCode.Prefix2:          case OpCode.Prefix1:          case OpCode.Arglist:          case OpCode.Ceq:          case OpCode.Cgt:          case OpCode.Cgt_Un:          case OpCode.Clt:          case OpCode.Clt_Un:            break;          case OpCode.Ldftn:          case OpCode.Ldvirtftn:            value = this.GetMemberFromToken(); break;          case OpCode.Ldarg:          case OpCode.Ldarga:          case OpCode.Starg:            value = this.Parameters(this.GetInt16()); break;          case OpCode.Ldloc:          case OpCode.Ldloca:          case OpCode.Stloc:            value = this.locals[this.GetInt16()]; break;          case OpCode.Localloc:          case OpCode.Endfilter:            break;          case OpCode.Unaligned_: value = this.GetByte(); break;          case OpCode.Volatile_:          case OpCode.Tail_:            break;          case OpCode.Initobj: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Constrained_: value = this.GetMemberFromToken() as TypeNode; break;          case OpCode.Cpblk:           case OpCode.Initblk:            break;          case OpCode.Rethrow:            break;          case OpCode.Sizeof: value = this.GetMemberFromToken(); break;          case OpCode.Refanytype:          case OpCode.Readonly_:            break;          default: throw new InvalidMetadataException(String.Format(CultureInfo.CurrentCulture'             ExceptionStrings.UnknownOpCodeEncountered' opCode.ToString("x")));        }
Magic Number,Microsoft.Cci.Metadata,InstructionParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseInstruction,The following statement contains a magic number: switch(opCode){          case OpCode.Nop:          case OpCode.Break:             break;          case OpCode.Ldarg_0: value = this.Parameters(0); break;          case OpCode.Ldarg_1: value = this.Parameters(1); break;          case OpCode.Ldarg_2: value = this.Parameters(2); break;           case OpCode.Ldarg_3: value = this.Parameters(3); break;          case OpCode.Ldloc_0: value = this.locals[0]; break;          case OpCode.Ldloc_1: value = this.locals[1]; break;          case OpCode.Ldloc_2: value = this.locals[2]; break;          case OpCode.Ldloc_3: value = this.locals[3]; break;          case OpCode.Stloc_0: value = this.locals[0]; break;          case OpCode.Stloc_1: value = this.locals[1]; break;          case OpCode.Stloc_2: value = this.locals[2]; break;          case OpCode.Stloc_3: value = this.locals[3]; break;          case OpCode.Ldarg_S:            case OpCode.Ldarga_S:          case OpCode.Starg_S:            value = this.Parameters(this.GetByte()); break;          case OpCode.Ldloc_S:          case OpCode.Ldloca_S:          case OpCode.Stloc_S:            value = this.locals[this.GetByte()]; break;          case OpCode.Ldnull:             break;          case OpCode.Ldc_I4_M1: value = (Int32)(-1); break;          case OpCode.Ldc_I4_0: value = (Int32)0; break;          case OpCode.Ldc_I4_1: value = (Int32)1; break;          case OpCode.Ldc_I4_2: value = (Int32)2; break;          case OpCode.Ldc_I4_3: value = (Int32)3; break;          case OpCode.Ldc_I4_4: value = (Int32)4; break;          case OpCode.Ldc_I4_5: value = (Int32)5; break;          case OpCode.Ldc_I4_6: value = (Int32)6; break;          case OpCode.Ldc_I4_7: value = (Int32)7; break;          case OpCode.Ldc_I4_8: value = (Int32)8; break;          case OpCode.Ldc_I4_S: value = (Int32)this.GetSByte(); break;          case OpCode.Ldc_I4: value = this.GetInt32(); break;          case OpCode.Ldc_I8: value = this.GetInt64(); break;          case OpCode.Ldc_R4: value = this.GetSingle(); break;          case OpCode.Ldc_R8: value = this.GetDouble(); break;          case OpCode.Dup:          case OpCode.Pop:             break;          case OpCode.Jmp:           case OpCode.Call:            value = (Method)this.GetMemberFromToken(); break;          case OpCode.Calli:             value = (FunctionPointer)this.reader.GetCalliSignature(this.GetInt32()); break;          case OpCode.Ret: break;          case OpCode.Br_S:          case OpCode.Brfalse_S:          case OpCode.Brtrue_S:          case OpCode.Beq_S:          case OpCode.Bge_S:          case OpCode.Bgt_S:          case OpCode.Ble_S:          case OpCode.Blt_S:          case OpCode.Bne_Un_S:          case OpCode.Bge_Un_S:          case OpCode.Bgt_Un_S:          case OpCode.Ble_Un_S:          case OpCode.Blt_Un_S:            value = this.counter + 1 + this.GetSByte(); break;          case OpCode.Br:          case OpCode.Brfalse:          case OpCode.Brtrue:          case OpCode.Beq:          case OpCode.Bge:          case OpCode.Bgt:          case OpCode.Ble:          case OpCode.Blt:          case OpCode.Bne_Un:          case OpCode.Bge_Un:          case OpCode.Bgt_Un:          case OpCode.Ble_Un:          case OpCode.Blt_Un:            value = this.counter + 4 + this.GetInt32(); break;          case OpCode.Switch: value = this.ParseSwitchInstruction(); break;                  case OpCode.Ldind_I1:           case OpCode.Ldind_U1:          case OpCode.Ldind_I2:          case OpCode.Ldind_U2:          case OpCode.Ldind_I4:          case OpCode.Ldind_U4:          case OpCode.Ldind_I8:          case OpCode.Ldind_I:          case OpCode.Ldind_R4:          case OpCode.Ldind_R8:          case OpCode.Ldind_Ref:          case OpCode.Stind_Ref:          case OpCode.Stind_I1:          case OpCode.Stind_I2:          case OpCode.Stind_I4:          case OpCode.Stind_I8:          case OpCode.Stind_R4:          case OpCode.Stind_R8:          case OpCode.Add:          case OpCode.Sub:          case OpCode.Mul:          case OpCode.Div:          case OpCode.Div_Un:          case OpCode.Rem:          case OpCode.Rem_Un:          case OpCode.And:          case OpCode.Or:          case OpCode.Xor:          case OpCode.Shl:          case OpCode.Shr:          case OpCode.Shr_Un:          case OpCode.Neg:          case OpCode.Not:          case OpCode.Conv_I1:          case OpCode.Conv_I2:          case OpCode.Conv_I4:          case OpCode.Conv_I8:          case OpCode.Conv_R4:          case OpCode.Conv_R8:          case OpCode.Conv_U4:          case OpCode.Conv_U8:            break;          case OpCode.Callvirt: value = (Method)this.GetMemberFromToken(); break;          case OpCode.Cpobj:          case OpCode.Ldobj:             value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Ldstr: value = this.GetStringFromToken(); break;                    case OpCode.Newobj: value = (Method)this.GetMemberFromToken();break;          case OpCode.Castclass:          case OpCode.Isinst:             value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Conv_R_Un: break;                 case OpCode.Unbox: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Throw: break;          case OpCode.Ldfld:           case OpCode.Ldflda:          case OpCode.Stfld:          case OpCode.Ldsfld:          case OpCode.Ldsflda:          case OpCode.Stsfld:          case OpCode.Stobj:            value = this.GetMemberFromToken(); break;          case OpCode.Conv_Ovf_I1_Un:          case OpCode.Conv_Ovf_I2_Un:          case OpCode.Conv_Ovf_I4_Un:          case OpCode.Conv_Ovf_I8_Un:          case OpCode.Conv_Ovf_U1_Un:          case OpCode.Conv_Ovf_U2_Un:          case OpCode.Conv_Ovf_U4_Un:          case OpCode.Conv_Ovf_U8_Un:          case OpCode.Conv_Ovf_I_Un:          case OpCode.Conv_Ovf_U_Un:            break;          case OpCode.Box:          case OpCode.Newarr: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Ldlen: break;          case OpCode.Ldelema: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Ldelem_I1:          case OpCode.Ldelem_U1:          case OpCode.Ldelem_I2:          case OpCode.Ldelem_U2:          case OpCode.Ldelem_I4:          case OpCode.Ldelem_U4:          case OpCode.Ldelem_I8:          case OpCode.Ldelem_I:          case OpCode.Ldelem_R4:          case OpCode.Ldelem_R8:          case OpCode.Ldelem_Ref:           case OpCode.Stelem_I:          case OpCode.Stelem_I1:          case OpCode.Stelem_I2:          case OpCode.Stelem_I4:          case OpCode.Stelem_I8:          case OpCode.Stelem_R4:          case OpCode.Stelem_R8:          case OpCode.Stelem_Ref:            break;          case OpCode.Ldelem:             value = (TypeNode)this.GetMemberFromToken();            break;          case OpCode.Stelem: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Unbox_Any: value = this.GetMemberFromToken(); break;          case OpCode.Conv_Ovf_I1:          case OpCode.Conv_Ovf_U1:          case OpCode.Conv_Ovf_I2:          case OpCode.Conv_Ovf_U2:          case OpCode.Conv_Ovf_I4:          case OpCode.Conv_Ovf_U4:          case OpCode.Conv_Ovf_I8:          case OpCode.Conv_Ovf_U8:            break;          case OpCode.Refanyval: value = this.GetMemberFromToken(); break;          case OpCode.Ckfinite: break;          case OpCode.Mkrefany: value = this.GetMemberFromToken(); break;          case OpCode.Ldtoken: value = this.GetMemberFromToken(); break;          case OpCode.Conv_U2:          case OpCode.Conv_U1:          case OpCode.Conv_I:          case OpCode.Conv_Ovf_I:          case OpCode.Conv_Ovf_U:          case OpCode.Add_Ovf:          case OpCode.Add_Ovf_Un:          case OpCode.Mul_Ovf:          case OpCode.Mul_Ovf_Un:          case OpCode.Sub_Ovf:          case OpCode.Sub_Ovf_Un:          case OpCode.Endfinally:             break;          case OpCode.Leave:   value = this.counter + 4 + this.GetInt32(); break;           case OpCode.Leave_S: value = this.counter + 1 + this.GetSByte(); break;          case OpCode.Stind_I:          case OpCode.Conv_U:          case OpCode.Prefix7:          case OpCode.Prefix6:          case OpCode.Prefix5:          case OpCode.Prefix4:          case OpCode.Prefix3:          case OpCode.Prefix2:          case OpCode.Prefix1:          case OpCode.Arglist:          case OpCode.Ceq:          case OpCode.Cgt:          case OpCode.Cgt_Un:          case OpCode.Clt:          case OpCode.Clt_Un:            break;          case OpCode.Ldftn:          case OpCode.Ldvirtftn:            value = this.GetMemberFromToken(); break;          case OpCode.Ldarg:          case OpCode.Ldarga:          case OpCode.Starg:            value = this.Parameters(this.GetInt16()); break;          case OpCode.Ldloc:          case OpCode.Ldloca:          case OpCode.Stloc:            value = this.locals[this.GetInt16()]; break;          case OpCode.Localloc:          case OpCode.Endfilter:            break;          case OpCode.Unaligned_: value = this.GetByte(); break;          case OpCode.Volatile_:          case OpCode.Tail_:            break;          case OpCode.Initobj: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Constrained_: value = this.GetMemberFromToken() as TypeNode; break;          case OpCode.Cpblk:           case OpCode.Initblk:            break;          case OpCode.Rethrow:            break;          case OpCode.Sizeof: value = this.GetMemberFromToken(); break;          case OpCode.Refanytype:          case OpCode.Readonly_:            break;          default: throw new InvalidMetadataException(String.Format(CultureInfo.CurrentCulture'             ExceptionStrings.UnknownOpCodeEncountered' opCode.ToString("x")));        }
Magic Number,Microsoft.Cci.Metadata,InstructionParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseInstruction,The following statement contains a magic number: switch(opCode){          case OpCode.Nop:          case OpCode.Break:             break;          case OpCode.Ldarg_0: value = this.Parameters(0); break;          case OpCode.Ldarg_1: value = this.Parameters(1); break;          case OpCode.Ldarg_2: value = this.Parameters(2); break;           case OpCode.Ldarg_3: value = this.Parameters(3); break;          case OpCode.Ldloc_0: value = this.locals[0]; break;          case OpCode.Ldloc_1: value = this.locals[1]; break;          case OpCode.Ldloc_2: value = this.locals[2]; break;          case OpCode.Ldloc_3: value = this.locals[3]; break;          case OpCode.Stloc_0: value = this.locals[0]; break;          case OpCode.Stloc_1: value = this.locals[1]; break;          case OpCode.Stloc_2: value = this.locals[2]; break;          case OpCode.Stloc_3: value = this.locals[3]; break;          case OpCode.Ldarg_S:            case OpCode.Ldarga_S:          case OpCode.Starg_S:            value = this.Parameters(this.GetByte()); break;          case OpCode.Ldloc_S:          case OpCode.Ldloca_S:          case OpCode.Stloc_S:            value = this.locals[this.GetByte()]; break;          case OpCode.Ldnull:             break;          case OpCode.Ldc_I4_M1: value = (Int32)(-1); break;          case OpCode.Ldc_I4_0: value = (Int32)0; break;          case OpCode.Ldc_I4_1: value = (Int32)1; break;          case OpCode.Ldc_I4_2: value = (Int32)2; break;          case OpCode.Ldc_I4_3: value = (Int32)3; break;          case OpCode.Ldc_I4_4: value = (Int32)4; break;          case OpCode.Ldc_I4_5: value = (Int32)5; break;          case OpCode.Ldc_I4_6: value = (Int32)6; break;          case OpCode.Ldc_I4_7: value = (Int32)7; break;          case OpCode.Ldc_I4_8: value = (Int32)8; break;          case OpCode.Ldc_I4_S: value = (Int32)this.GetSByte(); break;          case OpCode.Ldc_I4: value = this.GetInt32(); break;          case OpCode.Ldc_I8: value = this.GetInt64(); break;          case OpCode.Ldc_R4: value = this.GetSingle(); break;          case OpCode.Ldc_R8: value = this.GetDouble(); break;          case OpCode.Dup:          case OpCode.Pop:             break;          case OpCode.Jmp:           case OpCode.Call:            value = (Method)this.GetMemberFromToken(); break;          case OpCode.Calli:             value = (FunctionPointer)this.reader.GetCalliSignature(this.GetInt32()); break;          case OpCode.Ret: break;          case OpCode.Br_S:          case OpCode.Brfalse_S:          case OpCode.Brtrue_S:          case OpCode.Beq_S:          case OpCode.Bge_S:          case OpCode.Bgt_S:          case OpCode.Ble_S:          case OpCode.Blt_S:          case OpCode.Bne_Un_S:          case OpCode.Bge_Un_S:          case OpCode.Bgt_Un_S:          case OpCode.Ble_Un_S:          case OpCode.Blt_Un_S:            value = this.counter + 1 + this.GetSByte(); break;          case OpCode.Br:          case OpCode.Brfalse:          case OpCode.Brtrue:          case OpCode.Beq:          case OpCode.Bge:          case OpCode.Bgt:          case OpCode.Ble:          case OpCode.Blt:          case OpCode.Bne_Un:          case OpCode.Bge_Un:          case OpCode.Bgt_Un:          case OpCode.Ble_Un:          case OpCode.Blt_Un:            value = this.counter + 4 + this.GetInt32(); break;          case OpCode.Switch: value = this.ParseSwitchInstruction(); break;                  case OpCode.Ldind_I1:           case OpCode.Ldind_U1:          case OpCode.Ldind_I2:          case OpCode.Ldind_U2:          case OpCode.Ldind_I4:          case OpCode.Ldind_U4:          case OpCode.Ldind_I8:          case OpCode.Ldind_I:          case OpCode.Ldind_R4:          case OpCode.Ldind_R8:          case OpCode.Ldind_Ref:          case OpCode.Stind_Ref:          case OpCode.Stind_I1:          case OpCode.Stind_I2:          case OpCode.Stind_I4:          case OpCode.Stind_I8:          case OpCode.Stind_R4:          case OpCode.Stind_R8:          case OpCode.Add:          case OpCode.Sub:          case OpCode.Mul:          case OpCode.Div:          case OpCode.Div_Un:          case OpCode.Rem:          case OpCode.Rem_Un:          case OpCode.And:          case OpCode.Or:          case OpCode.Xor:          case OpCode.Shl:          case OpCode.Shr:          case OpCode.Shr_Un:          case OpCode.Neg:          case OpCode.Not:          case OpCode.Conv_I1:          case OpCode.Conv_I2:          case OpCode.Conv_I4:          case OpCode.Conv_I8:          case OpCode.Conv_R4:          case OpCode.Conv_R8:          case OpCode.Conv_U4:          case OpCode.Conv_U8:            break;          case OpCode.Callvirt: value = (Method)this.GetMemberFromToken(); break;          case OpCode.Cpobj:          case OpCode.Ldobj:             value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Ldstr: value = this.GetStringFromToken(); break;                    case OpCode.Newobj: value = (Method)this.GetMemberFromToken();break;          case OpCode.Castclass:          case OpCode.Isinst:             value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Conv_R_Un: break;                 case OpCode.Unbox: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Throw: break;          case OpCode.Ldfld:           case OpCode.Ldflda:          case OpCode.Stfld:          case OpCode.Ldsfld:          case OpCode.Ldsflda:          case OpCode.Stsfld:          case OpCode.Stobj:            value = this.GetMemberFromToken(); break;          case OpCode.Conv_Ovf_I1_Un:          case OpCode.Conv_Ovf_I2_Un:          case OpCode.Conv_Ovf_I4_Un:          case OpCode.Conv_Ovf_I8_Un:          case OpCode.Conv_Ovf_U1_Un:          case OpCode.Conv_Ovf_U2_Un:          case OpCode.Conv_Ovf_U4_Un:          case OpCode.Conv_Ovf_U8_Un:          case OpCode.Conv_Ovf_I_Un:          case OpCode.Conv_Ovf_U_Un:            break;          case OpCode.Box:          case OpCode.Newarr: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Ldlen: break;          case OpCode.Ldelema: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Ldelem_I1:          case OpCode.Ldelem_U1:          case OpCode.Ldelem_I2:          case OpCode.Ldelem_U2:          case OpCode.Ldelem_I4:          case OpCode.Ldelem_U4:          case OpCode.Ldelem_I8:          case OpCode.Ldelem_I:          case OpCode.Ldelem_R4:          case OpCode.Ldelem_R8:          case OpCode.Ldelem_Ref:           case OpCode.Stelem_I:          case OpCode.Stelem_I1:          case OpCode.Stelem_I2:          case OpCode.Stelem_I4:          case OpCode.Stelem_I8:          case OpCode.Stelem_R4:          case OpCode.Stelem_R8:          case OpCode.Stelem_Ref:            break;          case OpCode.Ldelem:             value = (TypeNode)this.GetMemberFromToken();            break;          case OpCode.Stelem: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Unbox_Any: value = this.GetMemberFromToken(); break;          case OpCode.Conv_Ovf_I1:          case OpCode.Conv_Ovf_U1:          case OpCode.Conv_Ovf_I2:          case OpCode.Conv_Ovf_U2:          case OpCode.Conv_Ovf_I4:          case OpCode.Conv_Ovf_U4:          case OpCode.Conv_Ovf_I8:          case OpCode.Conv_Ovf_U8:            break;          case OpCode.Refanyval: value = this.GetMemberFromToken(); break;          case OpCode.Ckfinite: break;          case OpCode.Mkrefany: value = this.GetMemberFromToken(); break;          case OpCode.Ldtoken: value = this.GetMemberFromToken(); break;          case OpCode.Conv_U2:          case OpCode.Conv_U1:          case OpCode.Conv_I:          case OpCode.Conv_Ovf_I:          case OpCode.Conv_Ovf_U:          case OpCode.Add_Ovf:          case OpCode.Add_Ovf_Un:          case OpCode.Mul_Ovf:          case OpCode.Mul_Ovf_Un:          case OpCode.Sub_Ovf:          case OpCode.Sub_Ovf_Un:          case OpCode.Endfinally:             break;          case OpCode.Leave:   value = this.counter + 4 + this.GetInt32(); break;           case OpCode.Leave_S: value = this.counter + 1 + this.GetSByte(); break;          case OpCode.Stind_I:          case OpCode.Conv_U:          case OpCode.Prefix7:          case OpCode.Prefix6:          case OpCode.Prefix5:          case OpCode.Prefix4:          case OpCode.Prefix3:          case OpCode.Prefix2:          case OpCode.Prefix1:          case OpCode.Arglist:          case OpCode.Ceq:          case OpCode.Cgt:          case OpCode.Cgt_Un:          case OpCode.Clt:          case OpCode.Clt_Un:            break;          case OpCode.Ldftn:          case OpCode.Ldvirtftn:            value = this.GetMemberFromToken(); break;          case OpCode.Ldarg:          case OpCode.Ldarga:          case OpCode.Starg:            value = this.Parameters(this.GetInt16()); break;          case OpCode.Ldloc:          case OpCode.Ldloca:          case OpCode.Stloc:            value = this.locals[this.GetInt16()]; break;          case OpCode.Localloc:          case OpCode.Endfilter:            break;          case OpCode.Unaligned_: value = this.GetByte(); break;          case OpCode.Volatile_:          case OpCode.Tail_:            break;          case OpCode.Initobj: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Constrained_: value = this.GetMemberFromToken() as TypeNode; break;          case OpCode.Cpblk:           case OpCode.Initblk:            break;          case OpCode.Rethrow:            break;          case OpCode.Sizeof: value = this.GetMemberFromToken(); break;          case OpCode.Refanytype:          case OpCode.Readonly_:            break;          default: throw new InvalidMetadataException(String.Format(CultureInfo.CurrentCulture'             ExceptionStrings.UnknownOpCodeEncountered' opCode.ToString("x")));        }
Magic Number,Microsoft.Cci.Metadata,InstructionParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseInstruction,The following statement contains a magic number: switch(opCode){          case OpCode.Nop:          case OpCode.Break:             break;          case OpCode.Ldarg_0: value = this.Parameters(0); break;          case OpCode.Ldarg_1: value = this.Parameters(1); break;          case OpCode.Ldarg_2: value = this.Parameters(2); break;           case OpCode.Ldarg_3: value = this.Parameters(3); break;          case OpCode.Ldloc_0: value = this.locals[0]; break;          case OpCode.Ldloc_1: value = this.locals[1]; break;          case OpCode.Ldloc_2: value = this.locals[2]; break;          case OpCode.Ldloc_3: value = this.locals[3]; break;          case OpCode.Stloc_0: value = this.locals[0]; break;          case OpCode.Stloc_1: value = this.locals[1]; break;          case OpCode.Stloc_2: value = this.locals[2]; break;          case OpCode.Stloc_3: value = this.locals[3]; break;          case OpCode.Ldarg_S:            case OpCode.Ldarga_S:          case OpCode.Starg_S:            value = this.Parameters(this.GetByte()); break;          case OpCode.Ldloc_S:          case OpCode.Ldloca_S:          case OpCode.Stloc_S:            value = this.locals[this.GetByte()]; break;          case OpCode.Ldnull:             break;          case OpCode.Ldc_I4_M1: value = (Int32)(-1); break;          case OpCode.Ldc_I4_0: value = (Int32)0; break;          case OpCode.Ldc_I4_1: value = (Int32)1; break;          case OpCode.Ldc_I4_2: value = (Int32)2; break;          case OpCode.Ldc_I4_3: value = (Int32)3; break;          case OpCode.Ldc_I4_4: value = (Int32)4; break;          case OpCode.Ldc_I4_5: value = (Int32)5; break;          case OpCode.Ldc_I4_6: value = (Int32)6; break;          case OpCode.Ldc_I4_7: value = (Int32)7; break;          case OpCode.Ldc_I4_8: value = (Int32)8; break;          case OpCode.Ldc_I4_S: value = (Int32)this.GetSByte(); break;          case OpCode.Ldc_I4: value = this.GetInt32(); break;          case OpCode.Ldc_I8: value = this.GetInt64(); break;          case OpCode.Ldc_R4: value = this.GetSingle(); break;          case OpCode.Ldc_R8: value = this.GetDouble(); break;          case OpCode.Dup:          case OpCode.Pop:             break;          case OpCode.Jmp:           case OpCode.Call:            value = (Method)this.GetMemberFromToken(); break;          case OpCode.Calli:             value = (FunctionPointer)this.reader.GetCalliSignature(this.GetInt32()); break;          case OpCode.Ret: break;          case OpCode.Br_S:          case OpCode.Brfalse_S:          case OpCode.Brtrue_S:          case OpCode.Beq_S:          case OpCode.Bge_S:          case OpCode.Bgt_S:          case OpCode.Ble_S:          case OpCode.Blt_S:          case OpCode.Bne_Un_S:          case OpCode.Bge_Un_S:          case OpCode.Bgt_Un_S:          case OpCode.Ble_Un_S:          case OpCode.Blt_Un_S:            value = this.counter + 1 + this.GetSByte(); break;          case OpCode.Br:          case OpCode.Brfalse:          case OpCode.Brtrue:          case OpCode.Beq:          case OpCode.Bge:          case OpCode.Bgt:          case OpCode.Ble:          case OpCode.Blt:          case OpCode.Bne_Un:          case OpCode.Bge_Un:          case OpCode.Bgt_Un:          case OpCode.Ble_Un:          case OpCode.Blt_Un:            value = this.counter + 4 + this.GetInt32(); break;          case OpCode.Switch: value = this.ParseSwitchInstruction(); break;                  case OpCode.Ldind_I1:           case OpCode.Ldind_U1:          case OpCode.Ldind_I2:          case OpCode.Ldind_U2:          case OpCode.Ldind_I4:          case OpCode.Ldind_U4:          case OpCode.Ldind_I8:          case OpCode.Ldind_I:          case OpCode.Ldind_R4:          case OpCode.Ldind_R8:          case OpCode.Ldind_Ref:          case OpCode.Stind_Ref:          case OpCode.Stind_I1:          case OpCode.Stind_I2:          case OpCode.Stind_I4:          case OpCode.Stind_I8:          case OpCode.Stind_R4:          case OpCode.Stind_R8:          case OpCode.Add:          case OpCode.Sub:          case OpCode.Mul:          case OpCode.Div:          case OpCode.Div_Un:          case OpCode.Rem:          case OpCode.Rem_Un:          case OpCode.And:          case OpCode.Or:          case OpCode.Xor:          case OpCode.Shl:          case OpCode.Shr:          case OpCode.Shr_Un:          case OpCode.Neg:          case OpCode.Not:          case OpCode.Conv_I1:          case OpCode.Conv_I2:          case OpCode.Conv_I4:          case OpCode.Conv_I8:          case OpCode.Conv_R4:          case OpCode.Conv_R8:          case OpCode.Conv_U4:          case OpCode.Conv_U8:            break;          case OpCode.Callvirt: value = (Method)this.GetMemberFromToken(); break;          case OpCode.Cpobj:          case OpCode.Ldobj:             value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Ldstr: value = this.GetStringFromToken(); break;                    case OpCode.Newobj: value = (Method)this.GetMemberFromToken();break;          case OpCode.Castclass:          case OpCode.Isinst:             value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Conv_R_Un: break;                 case OpCode.Unbox: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Throw: break;          case OpCode.Ldfld:           case OpCode.Ldflda:          case OpCode.Stfld:          case OpCode.Ldsfld:          case OpCode.Ldsflda:          case OpCode.Stsfld:          case OpCode.Stobj:            value = this.GetMemberFromToken(); break;          case OpCode.Conv_Ovf_I1_Un:          case OpCode.Conv_Ovf_I2_Un:          case OpCode.Conv_Ovf_I4_Un:          case OpCode.Conv_Ovf_I8_Un:          case OpCode.Conv_Ovf_U1_Un:          case OpCode.Conv_Ovf_U2_Un:          case OpCode.Conv_Ovf_U4_Un:          case OpCode.Conv_Ovf_U8_Un:          case OpCode.Conv_Ovf_I_Un:          case OpCode.Conv_Ovf_U_Un:            break;          case OpCode.Box:          case OpCode.Newarr: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Ldlen: break;          case OpCode.Ldelema: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Ldelem_I1:          case OpCode.Ldelem_U1:          case OpCode.Ldelem_I2:          case OpCode.Ldelem_U2:          case OpCode.Ldelem_I4:          case OpCode.Ldelem_U4:          case OpCode.Ldelem_I8:          case OpCode.Ldelem_I:          case OpCode.Ldelem_R4:          case OpCode.Ldelem_R8:          case OpCode.Ldelem_Ref:           case OpCode.Stelem_I:          case OpCode.Stelem_I1:          case OpCode.Stelem_I2:          case OpCode.Stelem_I4:          case OpCode.Stelem_I8:          case OpCode.Stelem_R4:          case OpCode.Stelem_R8:          case OpCode.Stelem_Ref:            break;          case OpCode.Ldelem:             value = (TypeNode)this.GetMemberFromToken();            break;          case OpCode.Stelem: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Unbox_Any: value = this.GetMemberFromToken(); break;          case OpCode.Conv_Ovf_I1:          case OpCode.Conv_Ovf_U1:          case OpCode.Conv_Ovf_I2:          case OpCode.Conv_Ovf_U2:          case OpCode.Conv_Ovf_I4:          case OpCode.Conv_Ovf_U4:          case OpCode.Conv_Ovf_I8:          case OpCode.Conv_Ovf_U8:            break;          case OpCode.Refanyval: value = this.GetMemberFromToken(); break;          case OpCode.Ckfinite: break;          case OpCode.Mkrefany: value = this.GetMemberFromToken(); break;          case OpCode.Ldtoken: value = this.GetMemberFromToken(); break;          case OpCode.Conv_U2:          case OpCode.Conv_U1:          case OpCode.Conv_I:          case OpCode.Conv_Ovf_I:          case OpCode.Conv_Ovf_U:          case OpCode.Add_Ovf:          case OpCode.Add_Ovf_Un:          case OpCode.Mul_Ovf:          case OpCode.Mul_Ovf_Un:          case OpCode.Sub_Ovf:          case OpCode.Sub_Ovf_Un:          case OpCode.Endfinally:             break;          case OpCode.Leave:   value = this.counter + 4 + this.GetInt32(); break;           case OpCode.Leave_S: value = this.counter + 1 + this.GetSByte(); break;          case OpCode.Stind_I:          case OpCode.Conv_U:          case OpCode.Prefix7:          case OpCode.Prefix6:          case OpCode.Prefix5:          case OpCode.Prefix4:          case OpCode.Prefix3:          case OpCode.Prefix2:          case OpCode.Prefix1:          case OpCode.Arglist:          case OpCode.Ceq:          case OpCode.Cgt:          case OpCode.Cgt_Un:          case OpCode.Clt:          case OpCode.Clt_Un:            break;          case OpCode.Ldftn:          case OpCode.Ldvirtftn:            value = this.GetMemberFromToken(); break;          case OpCode.Ldarg:          case OpCode.Ldarga:          case OpCode.Starg:            value = this.Parameters(this.GetInt16()); break;          case OpCode.Ldloc:          case OpCode.Ldloca:          case OpCode.Stloc:            value = this.locals[this.GetInt16()]; break;          case OpCode.Localloc:          case OpCode.Endfilter:            break;          case OpCode.Unaligned_: value = this.GetByte(); break;          case OpCode.Volatile_:          case OpCode.Tail_:            break;          case OpCode.Initobj: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Constrained_: value = this.GetMemberFromToken() as TypeNode; break;          case OpCode.Cpblk:           case OpCode.Initblk:            break;          case OpCode.Rethrow:            break;          case OpCode.Sizeof: value = this.GetMemberFromToken(); break;          case OpCode.Refanytype:          case OpCode.Readonly_:            break;          default: throw new InvalidMetadataException(String.Format(CultureInfo.CurrentCulture'             ExceptionStrings.UnknownOpCodeEncountered' opCode.ToString("x")));        }
Magic Number,Microsoft.Cci.Metadata,InstructionParser,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseInstruction,The following statement contains a magic number: switch(opCode){          case OpCode.Nop:          case OpCode.Break:             break;          case OpCode.Ldarg_0: value = this.Parameters(0); break;          case OpCode.Ldarg_1: value = this.Parameters(1); break;          case OpCode.Ldarg_2: value = this.Parameters(2); break;           case OpCode.Ldarg_3: value = this.Parameters(3); break;          case OpCode.Ldloc_0: value = this.locals[0]; break;          case OpCode.Ldloc_1: value = this.locals[1]; break;          case OpCode.Ldloc_2: value = this.locals[2]; break;          case OpCode.Ldloc_3: value = this.locals[3]; break;          case OpCode.Stloc_0: value = this.locals[0]; break;          case OpCode.Stloc_1: value = this.locals[1]; break;          case OpCode.Stloc_2: value = this.locals[2]; break;          case OpCode.Stloc_3: value = this.locals[3]; break;          case OpCode.Ldarg_S:            case OpCode.Ldarga_S:          case OpCode.Starg_S:            value = this.Parameters(this.GetByte()); break;          case OpCode.Ldloc_S:          case OpCode.Ldloca_S:          case OpCode.Stloc_S:            value = this.locals[this.GetByte()]; break;          case OpCode.Ldnull:             break;          case OpCode.Ldc_I4_M1: value = (Int32)(-1); break;          case OpCode.Ldc_I4_0: value = (Int32)0; break;          case OpCode.Ldc_I4_1: value = (Int32)1; break;          case OpCode.Ldc_I4_2: value = (Int32)2; break;          case OpCode.Ldc_I4_3: value = (Int32)3; break;          case OpCode.Ldc_I4_4: value = (Int32)4; break;          case OpCode.Ldc_I4_5: value = (Int32)5; break;          case OpCode.Ldc_I4_6: value = (Int32)6; break;          case OpCode.Ldc_I4_7: value = (Int32)7; break;          case OpCode.Ldc_I4_8: value = (Int32)8; break;          case OpCode.Ldc_I4_S: value = (Int32)this.GetSByte(); break;          case OpCode.Ldc_I4: value = this.GetInt32(); break;          case OpCode.Ldc_I8: value = this.GetInt64(); break;          case OpCode.Ldc_R4: value = this.GetSingle(); break;          case OpCode.Ldc_R8: value = this.GetDouble(); break;          case OpCode.Dup:          case OpCode.Pop:             break;          case OpCode.Jmp:           case OpCode.Call:            value = (Method)this.GetMemberFromToken(); break;          case OpCode.Calli:             value = (FunctionPointer)this.reader.GetCalliSignature(this.GetInt32()); break;          case OpCode.Ret: break;          case OpCode.Br_S:          case OpCode.Brfalse_S:          case OpCode.Brtrue_S:          case OpCode.Beq_S:          case OpCode.Bge_S:          case OpCode.Bgt_S:          case OpCode.Ble_S:          case OpCode.Blt_S:          case OpCode.Bne_Un_S:          case OpCode.Bge_Un_S:          case OpCode.Bgt_Un_S:          case OpCode.Ble_Un_S:          case OpCode.Blt_Un_S:            value = this.counter + 1 + this.GetSByte(); break;          case OpCode.Br:          case OpCode.Brfalse:          case OpCode.Brtrue:          case OpCode.Beq:          case OpCode.Bge:          case OpCode.Bgt:          case OpCode.Ble:          case OpCode.Blt:          case OpCode.Bne_Un:          case OpCode.Bge_Un:          case OpCode.Bgt_Un:          case OpCode.Ble_Un:          case OpCode.Blt_Un:            value = this.counter + 4 + this.GetInt32(); break;          case OpCode.Switch: value = this.ParseSwitchInstruction(); break;                  case OpCode.Ldind_I1:           case OpCode.Ldind_U1:          case OpCode.Ldind_I2:          case OpCode.Ldind_U2:          case OpCode.Ldind_I4:          case OpCode.Ldind_U4:          case OpCode.Ldind_I8:          case OpCode.Ldind_I:          case OpCode.Ldind_R4:          case OpCode.Ldind_R8:          case OpCode.Ldind_Ref:          case OpCode.Stind_Ref:          case OpCode.Stind_I1:          case OpCode.Stind_I2:          case OpCode.Stind_I4:          case OpCode.Stind_I8:          case OpCode.Stind_R4:          case OpCode.Stind_R8:          case OpCode.Add:          case OpCode.Sub:          case OpCode.Mul:          case OpCode.Div:          case OpCode.Div_Un:          case OpCode.Rem:          case OpCode.Rem_Un:          case OpCode.And:          case OpCode.Or:          case OpCode.Xor:          case OpCode.Shl:          case OpCode.Shr:          case OpCode.Shr_Un:          case OpCode.Neg:          case OpCode.Not:          case OpCode.Conv_I1:          case OpCode.Conv_I2:          case OpCode.Conv_I4:          case OpCode.Conv_I8:          case OpCode.Conv_R4:          case OpCode.Conv_R8:          case OpCode.Conv_U4:          case OpCode.Conv_U8:            break;          case OpCode.Callvirt: value = (Method)this.GetMemberFromToken(); break;          case OpCode.Cpobj:          case OpCode.Ldobj:             value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Ldstr: value = this.GetStringFromToken(); break;                    case OpCode.Newobj: value = (Method)this.GetMemberFromToken();break;          case OpCode.Castclass:          case OpCode.Isinst:             value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Conv_R_Un: break;                 case OpCode.Unbox: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Throw: break;          case OpCode.Ldfld:           case OpCode.Ldflda:          case OpCode.Stfld:          case OpCode.Ldsfld:          case OpCode.Ldsflda:          case OpCode.Stsfld:          case OpCode.Stobj:            value = this.GetMemberFromToken(); break;          case OpCode.Conv_Ovf_I1_Un:          case OpCode.Conv_Ovf_I2_Un:          case OpCode.Conv_Ovf_I4_Un:          case OpCode.Conv_Ovf_I8_Un:          case OpCode.Conv_Ovf_U1_Un:          case OpCode.Conv_Ovf_U2_Un:          case OpCode.Conv_Ovf_U4_Un:          case OpCode.Conv_Ovf_U8_Un:          case OpCode.Conv_Ovf_I_Un:          case OpCode.Conv_Ovf_U_Un:            break;          case OpCode.Box:          case OpCode.Newarr: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Ldlen: break;          case OpCode.Ldelema: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Ldelem_I1:          case OpCode.Ldelem_U1:          case OpCode.Ldelem_I2:          case OpCode.Ldelem_U2:          case OpCode.Ldelem_I4:          case OpCode.Ldelem_U4:          case OpCode.Ldelem_I8:          case OpCode.Ldelem_I:          case OpCode.Ldelem_R4:          case OpCode.Ldelem_R8:          case OpCode.Ldelem_Ref:           case OpCode.Stelem_I:          case OpCode.Stelem_I1:          case OpCode.Stelem_I2:          case OpCode.Stelem_I4:          case OpCode.Stelem_I8:          case OpCode.Stelem_R4:          case OpCode.Stelem_R8:          case OpCode.Stelem_Ref:            break;          case OpCode.Ldelem:             value = (TypeNode)this.GetMemberFromToken();            break;          case OpCode.Stelem: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Unbox_Any: value = this.GetMemberFromToken(); break;          case OpCode.Conv_Ovf_I1:          case OpCode.Conv_Ovf_U1:          case OpCode.Conv_Ovf_I2:          case OpCode.Conv_Ovf_U2:          case OpCode.Conv_Ovf_I4:          case OpCode.Conv_Ovf_U4:          case OpCode.Conv_Ovf_I8:          case OpCode.Conv_Ovf_U8:            break;          case OpCode.Refanyval: value = this.GetMemberFromToken(); break;          case OpCode.Ckfinite: break;          case OpCode.Mkrefany: value = this.GetMemberFromToken(); break;          case OpCode.Ldtoken: value = this.GetMemberFromToken(); break;          case OpCode.Conv_U2:          case OpCode.Conv_U1:          case OpCode.Conv_I:          case OpCode.Conv_Ovf_I:          case OpCode.Conv_Ovf_U:          case OpCode.Add_Ovf:          case OpCode.Add_Ovf_Un:          case OpCode.Mul_Ovf:          case OpCode.Mul_Ovf_Un:          case OpCode.Sub_Ovf:          case OpCode.Sub_Ovf_Un:          case OpCode.Endfinally:             break;          case OpCode.Leave:   value = this.counter + 4 + this.GetInt32(); break;           case OpCode.Leave_S: value = this.counter + 1 + this.GetSByte(); break;          case OpCode.Stind_I:          case OpCode.Conv_U:          case OpCode.Prefix7:          case OpCode.Prefix6:          case OpCode.Prefix5:          case OpCode.Prefix4:          case OpCode.Prefix3:          case OpCode.Prefix2:          case OpCode.Prefix1:          case OpCode.Arglist:          case OpCode.Ceq:          case OpCode.Cgt:          case OpCode.Cgt_Un:          case OpCode.Clt:          case OpCode.Clt_Un:            break;          case OpCode.Ldftn:          case OpCode.Ldvirtftn:            value = this.GetMemberFromToken(); break;          case OpCode.Ldarg:          case OpCode.Ldarga:          case OpCode.Starg:            value = this.Parameters(this.GetInt16()); break;          case OpCode.Ldloc:          case OpCode.Ldloca:          case OpCode.Stloc:            value = this.locals[this.GetInt16()]; break;          case OpCode.Localloc:          case OpCode.Endfilter:            break;          case OpCode.Unaligned_: value = this.GetByte(); break;          case OpCode.Volatile_:          case OpCode.Tail_:            break;          case OpCode.Initobj: value = (TypeNode)this.GetMemberFromToken(); break;          case OpCode.Constrained_: value = this.GetMemberFromToken() as TypeNode; break;          case OpCode.Cpblk:           case OpCode.Initblk:            break;          case OpCode.Rethrow:            break;          case OpCode.Sizeof: value = this.GetMemberFromToken(); break;          case OpCode.Refanytype:          case OpCode.Readonly_:            break;          default: throw new InvalidMetadataException(String.Format(CultureInfo.CurrentCulture'             ExceptionStrings.UnknownOpCodeEncountered' opCode.ToString("x")));        }
Magic Number,Microsoft.Cci.Metadata,ExpressionStack,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,Grow,The following statement contains a magic number: Expression[] newElements = new Expression[n+64];
Missing Default,Microsoft.Cci,ReGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI\ILGenerator.cs,VisitAddressOf,The following switch statement is missing a default case: switch (operand.NodeType){          case NodeType.Indexer:            Indexer indexer = (Indexer)operand;            this.Visit(indexer.Object);            if (indexer.Operands != null && indexer.Operands.Count == 1)              this.Visit(indexer.Operands[0]);            if (expr.NodeType == NodeType.ReadOnlyAddressOf)              this.ILGenerator.Emit(OpCodes.Readonly);            if (indexer.ElementType != null)              this.ILGenerator.Emit(OpCodes.Ldelema' indexer.ElementType.GetRuntimeType());            return;          case NodeType.Local:            int li = this.GetLocalVarIndex((Local)operand);            if (li < 256)              this.ILGenerator.Emit(OpCodes.Ldloca_S' this.locals[li]);            else              this.ILGenerator.Emit(OpCodes.Ldloca' this.locals[li]);            return;          case NodeType.MemberBinding:            MemberBinding mb = (MemberBinding)operand;            Field f = mb.BoundMember as Field;            if (f == null) { Debug.Fail(""); return; }            System.Reflection.FieldInfo fieldInfo = f.GetFieldInfo();            if (fieldInfo == null) { Debug.Fail(""); return; }            if (mb.TargetObject != null){              this.Visit(mb.TargetObject);              this.ILGenerator.Emit(OpCodes.Ldflda' fieldInfo);            }else{              this.ILGenerator.Emit(OpCodes.Ldsflda' fieldInfo);            }            return;          case NodeType.Parameter:            ParameterBinding pb = operand as ParameterBinding;            if (pb != null) operand = pb.BoundParameter;            int pi = ((Parameter)operand).ArgumentListIndex;            if (pi < 256)              this.ILGenerator.Emit(OpCodes.Ldarga_S' (byte)pi);            else              this.ILGenerator.Emit(OpCodes.Ldarga' (ushort)pi);            return;        }
Missing Default,Microsoft.Cci,ReGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI\ILGenerator.cs,VisitBinaryExpression,The following switch statement is missing a default case: switch(binaryExpression.NodeType){          case NodeType.Castclass : opCode = OpCodes.Castclass; goto writeOpCodeAndToken;          case NodeType.Isinst :    opCode = OpCodes.Isinst; goto writeOpCodeAndToken;          case NodeType.Unbox :     opCode = OpCodes.Unbox; goto writeOpCodeAndToken;          case NodeType.UnboxAny :  opCode = OpCodes.Unbox_Any; goto writeOpCodeAndToken;          case NodeType.Box :       opCode = OpCodes.Box; goto writeOpCodeAndToken;          case NodeType.Refanyval : opCode = OpCodes.Refanyval; goto writeOpCodeAndToken;          case NodeType.Mkrefany :  opCode = OpCodes.Mkrefany; goto writeOpCodeAndToken;          writeOpCodeAndToken:            Literal lit = binaryExpression.Operand2 as Literal;            if (lit != null)              this.ILGenerator.Emit(opCode' ((TypeNode)lit.Value).GetRuntimeType());            else              this.ILGenerator.Emit(opCode' ((TypeNode)((MemberBinding)binaryExpression.Operand2).BoundMember).GetRuntimeType());          return;          case NodeType.Ldvirtftn :            System.Reflection.MethodInfo meth = ((Method)((MemberBinding)binaryExpression.Operand2).BoundMember).GetMethodInfo();            if (meth == null) { Debug.Fail(""); return; }            this.ILGenerator.Emit(OpCodes.Ldvirtftn' meth);            return;        }
Missing Default,Microsoft.Cci,ReGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI\ILGenerator.cs,VisitBinaryExpression,The following switch statement is missing a default case: switch(binaryExpression.NodeType){          case NodeType.Add :    opCode = OpCodes.Add; break;          case NodeType.Sub :    opCode = OpCodes.Sub; break;          case NodeType.Mul :    opCode = OpCodes.Mul; break;          case NodeType.Div :    opCode = OpCodes.Div; break;          case NodeType.Div_Un : opCode = OpCodes.Div_Un; break;          case NodeType.Rem :    opCode = OpCodes.Rem; break;          case NodeType.Rem_Un : opCode = OpCodes.Rem_Un; break;          case NodeType.And :    opCode = OpCodes.And; break;          case NodeType.Or :     opCode = OpCodes.Or; break;          case NodeType.Xor :    opCode = OpCodes.Xor; break;          case NodeType.Shl :    opCode = OpCodes.Shl; break;          case NodeType.Shr :    opCode = OpCodes.Shr; break;          case NodeType.Shr_Un : opCode = OpCodes.Shr_Un; break;          case NodeType.Add_Ovf:     opCode = OpCodes.Add_Ovf; break;          case NodeType.Add_Ovf_Un : opCode = OpCodes.Add_Ovf_Un; break;          case NodeType.Mul_Ovf :    opCode = OpCodes.Mul_Ovf; break;          case NodeType.Mul_Ovf_Un : opCode = OpCodes.Mul_Ovf_Un; break;          case NodeType.Sub_Ovf :    opCode = OpCodes.Sub_Ovf; break;          case NodeType.Sub_Ovf_Un : opCode = OpCodes.Sub_Ovf_Un; break;          case NodeType.Ceq :    opCode = OpCodes.Ceq; break;          case NodeType.Cgt :    opCode = OpCodes.Cgt; break;          case NodeType.Cgt_Un : opCode = OpCodes.Cgt_Un; break;          case NodeType.Clt :    opCode = OpCodes.Clt; break;          case NodeType.Clt_Un : opCode = OpCodes.Clt_Un; break;        }
Missing Default,Microsoft.Cci,ReGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI\ILGenerator.cs,VisitBranch,The following switch statement is missing a default case: switch (typeOfCondition){            case NodeType.Nop:              if (branch.Condition == null){                if (branch.LeavesExceptionBlock)                  opCode = OpCodes.Leave_S;                else                  opCode = OpCodes.Br_S;                break;              }else{                opCode = OpCodes.Brtrue_S; break;              }            case NodeType.If:              opCode = OpCodes.Brtrue_S; break;            case NodeType.LogicalNot:              opCode = OpCodes.Brfalse_S; break;            case NodeType.Eq:              opCode = OpCodes.Beq_S; break;            case NodeType.Ge:              if (branch.BranchIfUnordered)                opCode = OpCodes.Bge_Un_S;              else                opCode = OpCodes.Bge_S;              break;            case NodeType.Gt:              if (branch.BranchIfUnordered)                opCode = OpCodes.Bgt_Un_S;              else                opCode = OpCodes.Bgt_S;              break;            case NodeType.Le:              if (branch.BranchIfUnordered)                opCode = OpCodes.Ble_Un_S;              else                opCode = OpCodes.Ble_S;              break;            case NodeType.Lt:              if (branch.BranchIfUnordered)                opCode = OpCodes.Blt_Un_S;              else                opCode = OpCodes.Blt_S;              break;            case NodeType.Ne:              opCode = OpCodes.Bne_Un_S;              break;          }
Missing Default,Microsoft.Cci,ReGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI\ILGenerator.cs,VisitBranch,The following switch statement is missing a default case: switch (typeOfCondition){            case NodeType.Nop:              if (branch.Condition == null){                if (branch.LeavesExceptionBlock)                  opCode = OpCodes.Leave;                else                  opCode = OpCodes.Br;                break;              }else{                opCode = OpCodes.Brtrue; break;              }            case NodeType.If:              opCode = OpCodes.Brtrue; break;            case NodeType.LogicalNot:              opCode = OpCodes.Brfalse; break;            case NodeType.Eq:              opCode = OpCodes.Beq; break;            case NodeType.Ge:              if (branch.BranchIfUnordered)                opCode = OpCodes.Bge_Un;              else                opCode = OpCodes.Bge;              break;            case NodeType.Gt:              if (branch.BranchIfUnordered)                opCode = OpCodes.Bgt_Un;              else                opCode = OpCodes.Bgt;              break;            case NodeType.Le:              if (branch.BranchIfUnordered)                opCode = OpCodes.Ble_Un;              else                opCode = OpCodes.Ble;              break;            case NodeType.Lt:              if (branch.BranchIfUnordered)                opCode = OpCodes.Blt_Un;              else                opCode = OpCodes.Blt;              break;            case NodeType.Ne:              opCode = OpCodes.Bne_Un; break;          }
Missing Default,Microsoft.Cci,ReGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI\ILGenerator.cs,VisitExpression,The following switch statement is missing a default case: switch (expression.NodeType){          case NodeType.Dup:            this.ILGenerator.Emit(OpCodes.Dup);            return;          case NodeType.Pop:            UnaryExpression unex = expression as UnaryExpression;            if (unex != null){              this.Visit(unex.Operand);              this.ILGenerator.Emit(OpCodes.Pop);            }            return;          case NodeType.Arglist:            this.ILGenerator.Emit(OpCodes.Arglist);            return;        }
Missing Default,Microsoft.Cci,ReGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI\ILGenerator.cs,VisitStatement,The following switch statement is missing a default case: switch(statement.NodeType){          case NodeType.Nop: this.ILGenerator.Emit(OpCodes.Nop); break;          case NodeType.DebugBreak: this.ILGenerator.Emit(OpCodes.Break); break;          case NodeType.EndFinally: this.ILGenerator.Emit(OpCodes.Endfinally); break;        }
Missing Default,Microsoft.Cci,ReGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI\ILGenerator.cs,VisitUnaryExpression,The following switch statement is missing a default case: switch(unaryExpression.NodeType){                case NodeType.Ldtoken :            Literal lit = unaryExpression.Operand as Literal;            if (lit != null)              this.ILGenerator.Emit(OpCodes.Ldtoken' ((TypeNode)lit.Value).GetRuntimeType());            else{              Member m = ((MemberBinding)unaryExpression.Operand).BoundMember;              Method meth = m as Method;              if (meth != null) {                System.Reflection.MethodInfo methInfo = meth.GetMethodInfo();                if (methInfo == null) return;                this.ILGenerator.Emit(OpCodes.Ldtoken' methInfo);              } else {                System.Reflection.FieldInfo fieldInfo = ((Field)m).GetFieldInfo();                if (fieldInfo == null) return;                this.ILGenerator.Emit(OpCodes.Ldtoken' fieldInfo);              }            }            return;          case NodeType.Ldftn: {            System.Reflection.MethodInfo methInfo = ((Method)((MemberBinding)unaryExpression.Operand).BoundMember).GetMethodInfo();            if (methInfo != null) this.ILGenerator.Emit(OpCodes.Ldftn' methInfo);            return;}          case NodeType.Sizeof :            this.ILGenerator.Emit(OpCodes.Sizeof' ((TypeNode)((Literal)unaryExpression.Operand).Value).GetRuntimeType());            return;        }
Missing Default,Microsoft.Cci,ReGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI\ILGenerator.cs,VisitUnaryExpression,The following switch statement is missing a default case: switch(unaryExpression.NodeType){                case NodeType.Neg :            opCode = OpCodes.Neg; break;          case NodeType.Not :            opCode = OpCodes.Not; break;          case NodeType.Conv_I1 :        opCode = OpCodes.Conv_I1; break;          case NodeType.Conv_I2 :        opCode = OpCodes.Conv_I2; break;          case NodeType.Conv_I4 :        opCode = OpCodes.Conv_I4; break;          case NodeType.Conv_I8 :        opCode = OpCodes.Conv_I8; break;          case NodeType.Conv_R4 :        opCode = OpCodes.Conv_R4; break;          case NodeType.Conv_R8 :        opCode = OpCodes.Conv_R8; break;          case NodeType.Conv_U4 :        opCode = OpCodes.Conv_U4; break;          case NodeType.Conv_U8 :        opCode = OpCodes.Conv_U8; break;          case NodeType.Conv_R_Un :      opCode = OpCodes.Conv_R_Un; break;          case NodeType.Conv_Ovf_I1_Un : opCode = OpCodes.Conv_Ovf_I1_Un; break;          case NodeType.Conv_Ovf_I2_Un : opCode = OpCodes.Conv_Ovf_I2_Un; break;          case NodeType.Conv_Ovf_I4_Un : opCode = OpCodes.Conv_Ovf_I4_Un; break;          case NodeType.Conv_Ovf_I8_Un : opCode = OpCodes.Conv_Ovf_I8_Un; break;          case NodeType.Conv_Ovf_U1_Un : opCode = OpCodes.Conv_Ovf_U1_Un; break;          case NodeType.Conv_Ovf_U2_Un : opCode = OpCodes.Conv_Ovf_U2_Un; break;          case NodeType.Conv_Ovf_U4_Un : opCode = OpCodes.Conv_Ovf_U4_Un; break;          case NodeType.Conv_Ovf_U8_Un : opCode = OpCodes.Conv_Ovf_U8_Un; break;          case NodeType.Conv_Ovf_I_Un :  opCode = OpCodes.Conv_Ovf_I_Un; break;          case NodeType.Conv_Ovf_U_Un :  opCode = OpCodes.Conv_Ovf_U_Un; break;          case NodeType.Ldlen :          opCode = OpCodes.Ldlen; break;          case NodeType.Conv_Ovf_I1 :    opCode = OpCodes.Conv_Ovf_I1; break;          case NodeType.Conv_Ovf_U1 :    opCode = OpCodes.Conv_Ovf_U1; break;          case NodeType.Conv_Ovf_I2 :    opCode = OpCodes.Conv_Ovf_I2; break;          case NodeType.Conv_Ovf_U2 :    opCode = OpCodes.Conv_Ovf_U2; break;          case NodeType.Conv_Ovf_I4 :    opCode = OpCodes.Conv_Ovf_I4; break;          case NodeType.Conv_Ovf_U4 :    opCode = OpCodes.Conv_Ovf_U4; break;          case NodeType.Conv_Ovf_I8 :    opCode = OpCodes.Conv_Ovf_I8; break;          case NodeType.Conv_Ovf_U8 :    opCode = OpCodes.Conv_Ovf_U8; break;          case NodeType.Ckfinite :       opCode = OpCodes.Ckfinite; break;          case NodeType.Conv_U2 :        opCode = OpCodes.Conv_U2; break;          case NodeType.Conv_U1 :        opCode = OpCodes.Conv_U1; break;          case NodeType.Conv_I :         opCode = OpCodes.Conv_I; break;          case NodeType.Conv_Ovf_I :     opCode = OpCodes.Conv_Ovf_I; break;          case NodeType.Conv_Ovf_U :     opCode = OpCodes.Conv_Ovf_U; break;          case NodeType.Conv_U :         opCode = OpCodes.Conv_U; break;          case NodeType.Localloc :       opCode = OpCodes.Localloc; break;          case NodeType.Refanytype :     opCode = OpCodes.Refanytype; break;        }
Missing Default,Microsoft.Cci,Document,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetLineCount,The following switch statement is missing a default case: switch(text[i]){            case '\r':              if (i+1 < n && text[i+1] == '\n')                i++;              count++;              break;            case '\n':            case (char)0x2028:            case (char)0x2029:              count++;              break;          }
Missing Default,Microsoft.Cci,Document,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,ComputeLineOffsets,The following switch statement is missing a default case: switch(this.Text[i]){            case '\r':              if (i+1 < n && this.Text[i+1] == '\n')                i++;              this.AddOffset(i+1);              break;            case '\n':            case (char)0x2028:            case (char)0x2029:              this.AddOffset(i+1);              break;          }
Missing Default,Microsoft.Cci,AssemblyNode,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetAssemblyName,The following switch statement is missing a default case: switch (this.Flags & AssemblyFlags.CompatibilityMask){            case AssemblyFlags.NonSideBySideCompatible:              aName.VersionCompatibility = System.Configuration.Assemblies.AssemblyVersionCompatibility.SameDomain;              break;            case AssemblyFlags.NonSideBySideProcess:              aName.VersionCompatibility = System.Configuration.Assemblies.AssemblyVersionCompatibility.SameProcess;              break;            case AssemblyFlags.NonSideBySideMachine:              aName.VersionCompatibility = System.Configuration.Assemblies.AssemblyVersionCompatibility.SameMachine;              break;          }
Missing Default,Microsoft.Cci,AssemblyReference,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,AssemblyReference,The following switch statement is missing a default case: switch (assemblyStrongName[i]){            case 'v': case 'V': version = ParseAssignment(assemblyStrongName' "Version"' ref i); break;            case 'c': case 'C': culture = ParseAssignment(assemblyStrongName' "Culture"' ref i); break;            case 'p': case 'P':              if (PlatformHelpers.StringCompareOrdinalIgnoreCase(assemblyStrongName' i' "PublicKeyToken"' 0' "PublicKeyToken".Length) == 0)                token = ParseAssignment(assemblyStrongName' "PublicKeyToken"' ref i);              else {                token = ParseAssignment(assemblyStrongName' "PublicKey"' ref i);                flags |= AssemblyFlags.PublicKey;              }              break;            case 'r': case 'R':              string yesOrNo = ParseAssignment(assemblyStrongName' "Retargetable"' ref i);              if (PlatformHelpers.StringCompareOrdinalIgnoreCase(yesOrNo' "Yes") == 0)                flags |= AssemblyFlags.Retargetable;              break;          }
Missing Default,Microsoft.Cci,AssemblyReference,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetAssemblyName,The following switch statement is missing a default case: switch (this.Flags & AssemblyFlags.CompatibilityMask){            case AssemblyFlags.NonSideBySideCompatible:              aName.VersionCompatibility = System.Configuration.Assemblies.AssemblyVersionCompatibility.SameDomain;              break;            case AssemblyFlags.NonSideBySideProcess:              aName.VersionCompatibility = System.Configuration.Assemblies.AssemblyVersionCompatibility.SameProcess;              break;            case AssemblyFlags.NonSideBySideMachine:              aName.VersionCompatibility = System.Configuration.Assemblies.AssemblyVersionCompatibility.SameMachine;              break;          }
Missing Default,Microsoft.Cci,Member,C:\repos\Reactive-Extensions_IL2JS\CCI\Nodes.cs,GetHelpText,The following switch statement is missing a default case: switch (child.NodeType){              case XmlNodeType.Element:                string str = this.GetHelpText(child);                if (str == null || str.Length == 0) continue;                if (sb.Length > 0 && !Char.IsPunctuation(str[0]))                  sb.Append(' ');                sb.Append(str);                break;              case XmlNodeType.CDATA:              case XmlNodeType.Entity:              case XmlNodeType.Text:                this.AppendValue(sb' child);                break;            }
Missing Default,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetBlobIndex,The following switch statement is missing a default case: switch (marshallingInformation.NativeType){          case NativeType.SafeArray:            signature.Write((byte)marshallingInformation.ElementType);            if (marshallingInformation.Class != null && marshallingInformation.Class.Length > 0)              signature.Write(marshallingInformation.Class' false);            break;          case NativeType.LPArray:            signature.Write((byte)marshallingInformation.ElementType);            if (marshallingInformation.ParamIndex >= 0 || marshallingInformation.ElementSize > 0) {              if (marshallingInformation.ParamIndex < 0) {                Debug.Fail("MarshallingInformation.ElementSize > 0 should imply that ParamIndex >= 0");                marshallingInformation.ParamIndex = 0;              }              Ir2md.WriteCompressedInt(signature' marshallingInformation.ParamIndex);            }            if (marshallingInformation.ElementSize > 0){              Ir2md.WriteCompressedInt(signature' marshallingInformation.ElementSize);              if (marshallingInformation.NumberOfElements > 0)                Ir2md.WriteCompressedInt(signature' marshallingInformation.NumberOfElements);            }            break;          case NativeType.ByValArray:            Ir2md.WriteCompressedInt(signature' marshallingInformation.Size);            if (marshallingInformation.ElementType != NativeType.NotSpecified)              signature.Write((byte)marshallingInformation.ElementType);            break;          case NativeType.ByValTStr:            Ir2md.WriteCompressedInt(signature' marshallingInformation.Size);            break;          case NativeType.Interface:            if (marshallingInformation.Size > 0)              Ir2md.WriteCompressedInt(signature' marshallingInformation.Size);            break;          case NativeType.CustomMarshaler:            signature.Write((short)0);            signature.Write(marshallingInformation.Class);            signature.Write(marshallingInformation.Cookie);            break;        }
Missing Default,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,IsStructural,The following switch statement is missing a default case: switch (type.NodeType){          case NodeType.ArrayType:          case NodeType.Pointer:          case NodeType.Reference:          case NodeType.OptionalModifier:          case NodeType.RequiredModifier:            return true;          case NodeType.ClassParameter:          case NodeType.TypeParameter:            return this.UseGenerics;        }
Missing Default,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,GetStaticDataIndex,The following switch statement is missing a default case: switch (targetSection){          case PESection.SData:            result = (int)this.sdataHeap.BaseStream.Position;            this.sdataHeap.Write(data);            break;          case PESection.Text:            result = (int)this.methodBodiesHeap.BaseStream.Position;            this.methodBodiesHeap.Write(data);            break;          case PESection.TLS:            result = (int)this.tlsHeap.BaseStream.Position;            this.tlsHeap.Write(data);            break;        }
Missing Default,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateFileTable,The following switch statement is missing a default case: switch (module.Kind){            case ModuleKindFlags.ConsoleApplication:            case ModuleKindFlags.DynamicallyLinkedLibrary:            case ModuleKindFlags.WindowsApplication:              ftr[i].Flags = (int)FileFlags.ContainsMetaData;              break;            case ModuleKindFlags.ManifestResourceFile:              readContents = true;              ftr[i].Flags = (int)FileFlags.ContainsNoMetaData;              break;            case ModuleKindFlags.UnmanagedDynamicallyLinkedLibrary:              ftr[i].Flags = (int)FileFlags.ContainsNoMetaData;              break;          }
Missing Default,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,PopulateTypeDefTable,The following switch statement is missing a default case: switch(mem.NodeType){              case NodeType.Method:              case NodeType.InstanceInitializer:              case NodeType.StaticInitializer:                tdr[i].MethodList = this.GetMethodIndex((Method)mem);                goto done;            }
Missing Default,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitAddressOf,The following switch statement is missing a default case: switch (operand.NodeType){          case NodeType.Indexer:            Indexer indexer = (Indexer)operand;            this.Visit(indexer.Object);            if (indexer.Operands == null || indexer.Operands.Count < 1) return;            this.Visit(indexer.Operands[0]);            if (expr.NodeType == NodeType.ReadOnlyAddressOf){              this.methodBodyHeap.Write((byte)0xfe);              this.methodBodyHeap.Write((byte)0x1e);            }            this.methodBodyHeap.Write((byte)0x8f);            this.methodBodyHeap.Write((int)this.GetTypeToken(indexer.ElementType));            this.stackHeight--;            return;          case NodeType.Local:             int li = this.GetLocalVarIndex((Local)operand);            if (li < 256){              this.methodBodyHeap.Write((byte)0x12);              this.methodBodyHeap.Write((byte)li);            }else{              this.methodBodyHeap.Write((byte)0xfe);              this.methodBodyHeap.Write((byte)0x0d);              this.methodBodyHeap.Write((ushort)li);            }            this.IncrementStackHeight();            return;          case NodeType.MemberBinding:            MemberBinding mb = (MemberBinding)operand;            if (mb.TargetObject != null){              this.Visit(mb.TargetObject);              this.methodBodyHeap.Write((byte)0x7c);            }else{              this.methodBodyHeap.Write((byte)0x7f);              this.IncrementStackHeight();            }            this.methodBodyHeap.Write((int)this.GetFieldToken((Field)mb.BoundMember));            return;          case NodeType.Parameter:   #if !MinimalReader            ParameterBinding pb = operand as ParameterBinding;            if (pb != null) operand = pb.BoundParameter;  #endif            int pi = ((Parameter)operand).ArgumentListIndex;            if (pi < 256){              this.methodBodyHeap.Write((byte)0x0f);              this.methodBodyHeap.Write((byte)pi);            }else{              this.methodBodyHeap.Write((byte)0xfe);              this.methodBodyHeap.Write((byte)0x0a);              this.methodBodyHeap.Write((ushort)pi);            }            this.IncrementStackHeight();            return;        }
Missing Default,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitBinaryExpression,The following switch statement is missing a default case: switch(binaryExpression.NodeType){          case NodeType.Castclass : opCode = 0x74; goto writeOpCodeAndToken;          case NodeType.Isinst :    opCode = 0x75; goto writeOpCodeAndToken;          case NodeType.Unbox :     opCode = 0x79; goto writeOpCodeAndToken;          case NodeType.UnboxAny :  opCode = 0xa5; goto writeOpCodeAndToken;          case NodeType.Box :       opCode = 0x8c; goto writeOpCodeAndToken;          case NodeType.Refanyval : opCode = 0xc2; goto writeOpCodeAndToken;          case NodeType.Mkrefany :  opCode = 0xc6; goto writeOpCodeAndToken;          writeOpCodeAndToken:            this.methodBodyHeap.Write((byte)opCode);            Literal lit = binaryExpression.Operand2 as Literal;            if (lit != null)              this.methodBodyHeap.Write((int)this.GetTypeToken((TypeNode)lit.Value));            else{              // TODO: Normalized IR should never use a MemberBinding to represent a type              this.methodBodyHeap.Write((int)this.GetTypeToken((TypeNode)((MemberBinding)binaryExpression.Operand2).BoundMember));            }            return;          case NodeType.Ldvirtftn : opCode = 0x07; this.methodBodyHeap.Write((byte)0xfe);             this.methodBodyHeap.Write((byte)opCode);            this.methodBodyHeap.Write((int)this.GetMethodToken((Method)((MemberBinding)binaryExpression.Operand2).BoundMember));            return;        }
Missing Default,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitBinaryExpression,The following switch statement is missing a default case: switch(binaryExpression.NodeType){          case NodeType.Add :    opCode = 0x58; break;          case NodeType.Sub :    opCode = 0x59; break;          case NodeType.Mul :    opCode = 0x5a; break;          case NodeType.Div :    opCode = 0x5b; break;          case NodeType.Div_Un : opCode = 0x5c; break;          case NodeType.Rem :    opCode = 0x5d; break;          case NodeType.Rem_Un : opCode = 0x5e; break;          case NodeType.And :    opCode = 0x5f; break;          case NodeType.Or :     opCode = 0x60; break;          case NodeType.Xor :    opCode = 0x61; break;          case NodeType.Shl :    opCode = 0x62; break;          case NodeType.Shr :    opCode = 0x63; break;          case NodeType.Shr_Un : opCode = 0x64; break;          case NodeType.Add_Ovf:     opCode = 0xd6; break;          case NodeType.Add_Ovf_Un : opCode = 0xd7; break;          case NodeType.Mul_Ovf :    opCode = 0xd8; break;          case NodeType.Mul_Ovf_Un : opCode = 0xd9; break;          case NodeType.Sub_Ovf :    opCode = 0xda; break;          case NodeType.Sub_Ovf_Un : opCode = 0xdb; break;          case NodeType.Ceq :    opCode = 0x01; this.methodBodyHeap.Write((byte)0xfe); break;          case NodeType.Cgt :    opCode = 0x02; this.methodBodyHeap.Write((byte)0xfe); break;          case NodeType.Cgt_Un : opCode = 0x03; this.methodBodyHeap.Write((byte)0xfe); break;          case NodeType.Clt :    opCode = 0x04; this.methodBodyHeap.Write((byte)0xfe); break;          case NodeType.Clt_Un : opCode = 0x05; this.methodBodyHeap.Write((byte)0xfe); break;        }
Missing Default,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitBranch,The following switch statement is missing a default case: switch(typeOfCondition){            case NodeType.Nop:              if (branch.Condition == null){                if (branch.LeavesExceptionBlock)                  this.methodBodyHeap.Write((byte)0xde);                else                  this.methodBodyHeap.Write((byte)0x2b);                break;              }else{                this.methodBodyHeap.Write((byte)0x2d); break;              }            case NodeType.And:            case NodeType.Or:            case NodeType.Xor:            case NodeType.Isinst:            case NodeType.Castclass:            case NodeType.Undefined:              this.methodBodyHeap.Write((byte)0x2d); break;            case NodeType.LogicalNot:              this.methodBodyHeap.Write((byte)0x2c); break;            case NodeType.Eq:              this.methodBodyHeap.Write((byte)0x2e); break;            case NodeType.Ge:              if (branch.BranchIfUnordered)                this.methodBodyHeap.Write((byte)0x34);              else                this.methodBodyHeap.Write((byte)0x2f);              break;            case NodeType.Gt:              if (branch.BranchIfUnordered)                this.methodBodyHeap.Write((byte)0x35);              else                this.methodBodyHeap.Write((byte)0x30);              break;            case NodeType.Le:              if (branch.BranchIfUnordered)                this.methodBodyHeap.Write((byte)0x36);              else                this.methodBodyHeap.Write((byte)0x31);              break;            case NodeType.Lt:              if (branch.BranchIfUnordered)                this.methodBodyHeap.Write((byte)0x37);              else                this.methodBodyHeap.Write((byte)0x32);              break;            case NodeType.Ne:              this.methodBodyHeap.Write((byte)0x33);              break;          }
Missing Default,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitBranch,The following switch statement is missing a default case: switch(typeOfCondition){            case NodeType.Nop:              if (branch.Condition == null){                if (branch.LeavesExceptionBlock)                  this.methodBodyHeap.Write((byte)0xdd);                else                  this.methodBodyHeap.Write((byte)0x38);                break;              }else{                this.methodBodyHeap.Write((byte)0x3a); break;              }            case NodeType.And:            case NodeType.Or:            case NodeType.Xor:            case NodeType.Isinst:            case NodeType.Castclass:            case NodeType.Undefined:              this.methodBodyHeap.Write((byte)0x3a); break;            case NodeType.LogicalNot:              this.methodBodyHeap.Write((byte)0x39); break;            case NodeType.Eq:              this.methodBodyHeap.Write((byte)0x3b); break;            case NodeType.Ge:              if (branch.BranchIfUnordered)                this.methodBodyHeap.Write((byte)0x41);              else                this.methodBodyHeap.Write((byte)0x3c);              break;            case NodeType.Gt:              if (branch.BranchIfUnordered)                this.methodBodyHeap.Write((byte)0x42);              else                this.methodBodyHeap.Write((byte)0x3d);              break;            case NodeType.Le:              if (branch.BranchIfUnordered)                this.methodBodyHeap.Write((byte)0x43);              else                this.methodBodyHeap.Write((byte)0x3e);              break;            case NodeType.Lt:              if (branch.BranchIfUnordered)                this.methodBodyHeap.Write((byte)0x44);              else                this.methodBodyHeap.Write((byte)0x3f);              break;            case NodeType.Ne:              this.methodBodyHeap.Write((byte)0x40); break;          }
Missing Default,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitExpression,The following switch statement is missing a default case: switch(expression.NodeType){          case NodeType.Dup:             this.methodBodyHeap.Write((byte)0x25);             this.IncrementStackHeight();            return;          case NodeType.Pop:            UnaryExpression unex = expression as UnaryExpression;            if (unex != null){              this.Visit(unex.Operand);              this.stackHeight--;              this.methodBodyHeap.Write((byte)0x26);            }            return;          case NodeType.Arglist:            this.IncrementStackHeight();            this.methodBodyHeap.Write((byte)0xfe);            this.methodBodyHeap.Write((byte)0x00);            return;        }
Missing Default,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitMethodBody,The following switch statement is missing a default case: switch (eh.HandlerType) {              case NodeType.Filter: flags = 0x0001; break;              case NodeType.Finally: flags = 0x0002; break;              case NodeType.FaultHandler: flags = 0x0004; break;            }
Missing Default,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitModule,The following switch statement is missing a default case: switch(mem.NodeType){                case NodeType.Field: this.GetFieldIndex((Field)mem); break;                case NodeType.Method:                case NodeType.InstanceInitializer:                case NodeType.StaticInitializer:                   Method meth = (Method)mem;                  if (this.UseGenerics && meth.Template != null && meth.Template.IsGeneric)                    this.GetMethodSpecIndex(meth);                  else                    this.GetMethodIndex(meth);                   break;              }
Missing Default,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitStatement,The following switch statement is missing a default case: switch(statement.NodeType){          case NodeType.Nop: this.methodBodyHeap.Write((byte)0x00); break;          case NodeType.DebugBreak: this.methodBodyHeap.Write((byte)0x01); break;          case NodeType.EndFinally: this.methodBodyHeap.Write((byte)0xdc); break;        }
Missing Default,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,VisitUnaryExpression,The following switch statement is missing a default case: switch(unaryExpression.NodeType){                case NodeType.Neg :            opCode = 0x65; break;          case NodeType.Not :            opCode = 0x66; break;          case NodeType.Conv_I1 :        opCode = 0x67; break;          case NodeType.Conv_I2 :        opCode = 0x68; break;          case NodeType.Conv_I4 :        opCode = 0x69; break;          case NodeType.Conv_I8 :        opCode = 0x6a; break;          case NodeType.Conv_R4 :        opCode = 0x6b; break;          case NodeType.Conv_R8 :        opCode = 0x6c; break;          case NodeType.Conv_U4 :        opCode = 0x6d; break;          case NodeType.Conv_U8 :        opCode = 0x6e; break;          case NodeType.Conv_R_Un :      opCode = 0x76; break;          case NodeType.Conv_Ovf_I1_Un : opCode = 0x82; break;          case NodeType.Conv_Ovf_I2_Un : opCode = 0x83; break;          case NodeType.Conv_Ovf_I4_Un : opCode = 0x84; break;          case NodeType.Conv_Ovf_I8_Un : opCode = 0x85; break;          case NodeType.Conv_Ovf_U1_Un : opCode = 0x86; break;          case NodeType.Conv_Ovf_U2_Un : opCode = 0x87; break;          case NodeType.Conv_Ovf_U4_Un : opCode = 0x88; break;          case NodeType.Conv_Ovf_U8_Un : opCode = 0x89; break;          case NodeType.Conv_Ovf_I_Un :  opCode = 0x8a; break;          case NodeType.Conv_Ovf_U_Un :  opCode = 0x8b; break;          case NodeType.Ldlen :          opCode = 0x8e; break;          case NodeType.Conv_Ovf_I1 :    opCode = 0xb3; break;          case NodeType.Conv_Ovf_U1 :    opCode = 0xb4; break;          case NodeType.Conv_Ovf_I2 :    opCode = 0xb5; break;          case NodeType.Conv_Ovf_U2 :    opCode = 0xb6; break;          case NodeType.Conv_Ovf_I4 :    opCode = 0xb7; break;          case NodeType.Conv_Ovf_U4 :    opCode = 0xb8; break;          case NodeType.Conv_Ovf_I8 :    opCode = 0xb9; break;          case NodeType.Conv_Ovf_U8 :    opCode = 0xba; break;          case NodeType.Ckfinite :       opCode = 0xc3; break;          case NodeType.Conv_U2 :        opCode = 0xd1; break;          case NodeType.Conv_U1 :        opCode = 0xd2; break;          case NodeType.Conv_I :         opCode = 0xd3; break;          case NodeType.Conv_Ovf_I :     opCode = 0xd4; break;          case NodeType.Conv_Ovf_U :     opCode = 0xd5; break;          case NodeType.Conv_U :         opCode = 0xe0; break;          case NodeType.Localloc :       opCode = 0x0f; this.methodBodyHeap.Write((byte)0xfe); break;          case NodeType.Refanytype :     opCode = 0x1d; this.methodBodyHeap.Write((byte)0xfe); break;        }
Missing Default,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,WriteCustomModifiers,The following switch statement is missing a default case: switch(type.NodeType){          case NodeType.RequiredModifier:          case NodeType.OptionalModifier:            TypeModifier tm = (TypeModifier)type;            target.Write((byte)tm.typeCode);            this.WriteTypeDefOrRefEncoded(target' tm.Modifier);            return this.WriteCustomModifiers(target' tm.ModifiedType);        }
Missing Default,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,WriteCustomAttributeLiteral,The following switch statement is missing a default case: switch(typeCode){          case ElementType.Boolean: writer.Write((bool)value); return;          case ElementType.Char: writer.Write((ushort)(char)value); return;          case ElementType.Double: writer.Write((double)value); return;          case ElementType.Single: writer.Write((float)value); return;           case ElementType.Int16: writer.Write((short)value); return;          case ElementType.Int32: writer.Write((int)value); return;          case ElementType.Int64: writer.Write((long)value); return;          case ElementType.Int8: writer.Write((sbyte)value); return;          case ElementType.UInt16: writer.Write((ushort)value); return;          case ElementType.UInt32: writer.Write((uint)value); return;          case ElementType.UInt64: writer.Write((ulong)value); return;          case ElementType.UInt8: writer.Write((byte)value); return;          case ElementType.String: writer.Write((string)value' false); return;          case ElementType.ValueType: this.WriteCustomAttributeLiteral(writer' new Literal(value' ((EnumNode)literal.Type).UnderlyingType)' false); return;          case ElementType.Class: this.WriteSerializedTypeName(writer' (TypeNode)value); return;          case ElementType.SzArray:            TypeNode elemType = ((ArrayType)literal.Type).ElementType;            if (needsTag)              writer.Write((byte)elemType.typeCode);            Array array = (Array)value;            int numElems = array == null ? -1 : array.Length;            writer.Write((int)numElems);            bool elemNeedsTag = elemType == CoreSystemTypes.Object;            for (int i = 0; i < numElems; i++) {              object elemValue = array.GetValue(i);              Literal elemLit = elemValue as Literal;              if (elemLit == null) elemLit = new Literal(elemValue' elemType);              this.WriteCustomAttributeLiteral(writer' elemLit' elemNeedsTag);            }            return;          case ElementType.Object:            Literal lit = (Literal)literal.Clone();            TypeNode t = null;            switch(Convert.GetTypeCode(lit.Value)){              case TypeCode.Boolean: t = CoreSystemTypes.Boolean; break;              case TypeCode.Byte: t = CoreSystemTypes.UInt8; break;              case TypeCode.Char: t = CoreSystemTypes.Char; break;              case TypeCode.Double: t = CoreSystemTypes.Double; break;              case TypeCode.Int16: t = CoreSystemTypes.Int16; break;              case TypeCode.Int32: t = CoreSystemTypes.Int32; break;              case TypeCode.Int64: t = CoreSystemTypes.Int64; break;              case TypeCode.SByte: t = CoreSystemTypes.Int8; break;              case TypeCode.Single: t = CoreSystemTypes.Single; break;              case TypeCode.String: t = CoreSystemTypes.String; break;              case TypeCode.UInt16: t = CoreSystemTypes.UInt16; break;              case TypeCode.UInt32: t = CoreSystemTypes.UInt32; break;              case TypeCode.UInt64: t = CoreSystemTypes.UInt64; break;              case TypeCode.Empty:              case TypeCode.Object:                 Array arr = lit.Value as Array;                if (arr != null){  #if !NoReflection                  t = TypeNode.GetTypeNode(arr.GetType());  #else                  System.Type reflType = arr.GetType();                  System.Type reflElemType = reflType.GetElementType();                  AssemblyNode assem = AssemblyNode.GetAssembly(reflType.Assembly.Location);                  TypeNode cciElemType = assem.GetType(Identifier.For(reflElemType.Namespace)' Identifier.For(reflElemType.Name));                  t = cciElemType.GetArrayType(reflType.GetArrayRank());  #endif                }else                  t = CoreSystemTypes.Type;                 break;            }            if (t == null) break;            lit.Type = t;            this.WriteCustomAttributeLiteral(writer' lit' true);            return;        }
Missing Default,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,WriteCustomAttributeLiteral,The following switch statement is missing a default case: switch(Convert.GetTypeCode(lit.Value)){              case TypeCode.Boolean: t = CoreSystemTypes.Boolean; break;              case TypeCode.Byte: t = CoreSystemTypes.UInt8; break;              case TypeCode.Char: t = CoreSystemTypes.Char; break;              case TypeCode.Double: t = CoreSystemTypes.Double; break;              case TypeCode.Int16: t = CoreSystemTypes.Int16; break;              case TypeCode.Int32: t = CoreSystemTypes.Int32; break;              case TypeCode.Int64: t = CoreSystemTypes.Int64; break;              case TypeCode.SByte: t = CoreSystemTypes.Int8; break;              case TypeCode.Single: t = CoreSystemTypes.Single; break;              case TypeCode.String: t = CoreSystemTypes.String; break;              case TypeCode.UInt16: t = CoreSystemTypes.UInt16; break;              case TypeCode.UInt32: t = CoreSystemTypes.UInt32; break;              case TypeCode.UInt64: t = CoreSystemTypes.UInt64; break;              case TypeCode.Empty:              case TypeCode.Object:                 Array arr = lit.Value as Array;                if (arr != null){  #if !NoReflection                  t = TypeNode.GetTypeNode(arr.GetType());  #else                  System.Type reflType = arr.GetType();                  System.Type reflElemType = reflType.GetElementType();                  AssemblyNode assem = AssemblyNode.GetAssembly(reflType.Assembly.Location);                  TypeNode cciElemType = assem.GetType(Identifier.For(reflElemType.Namespace)' Identifier.For(reflElemType.Name));                  t = cciElemType.GetArrayType(reflType.GetArrayRank());  #endif                }else                  t = CoreSystemTypes.Type;                 break;            }
Missing Default,Microsoft.Cci,Ir2md,C:\repos\Reactive-Extensions_IL2JS\CCI\Writer.cs,WriteTypeSignature,The following switch statement is missing a default case: switch(t.typeCode){          case ElementType.Pointer: this.WriteTypeSignature(target' ((Pointer)t).ElementType); break;          case ElementType.Reference: this.WriteTypeSignature(target' ((Reference)t).ElementType); break;          case ElementType.ValueType:           case ElementType.Class: this.WriteTypeDefOrRefEncoded(target' t); break;          case ElementType.Array: this.WriteTypeSignature(target' ((ArrayType)t).ElementType); Ir2md.WriteArrayShape(target' (ArrayType)t); break;          case ElementType.FunctionPointer: this.WriteMethodSignature(target' (FunctionPointer)t); break;          case ElementType.SzArray: this.WriteTypeSignature(target' ((ArrayType)t).ElementType); break;        }
Missing Default,Microsoft.Cci.Metadata,MetadataReader,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,GetValueFromBlob,The following switch statement is missing a default case: switch((ElementType)type){          case ElementType.Boolean: return c.ReadBoolean();           case ElementType.Char: return (char)c.ReadUInt16();           case ElementType.Double: return c.ReadDouble();           case ElementType.Single: return c.ReadSingle();           case ElementType.Int16: return c.ReadInt16();           case ElementType.Int32: return c.ReadInt32();           case ElementType.Int64: return c.ReadInt64();           case ElementType.Int8: return c.ReadSByte();           case ElementType.UInt16: return c.ReadUInt16();           case ElementType.UInt32: return c.ReadUInt32();           case ElementType.UInt64: return c.ReadUInt64();           case ElementType.UInt8: return c.ReadByte();           case ElementType.Class: return null;          case ElementType.String: return c.ReadUTF16(blobLength/2);        }
Missing Default,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,SerializeFieldRvaTable,The following switch statement is missing a default case: switch (row.TargetSection){            case PESection.SData:            case PESection.TLS:              Fixup fixup = new Fixup();              fixup.fixupLocation = writer.BaseStream.Position;              fixup.addressOfNextInstruction = row.RVA;              if (row.TargetSection == PESection.SData){                sdataFixup.nextFixUp = fixup;                sdataFixup = fixup;              }else{                sdataFixup.nextFixUp = fixup;                sdataFixup = fixup;              }              writer.Write((int)0);              break;            case PESection.Text:              writer.Write((int)row.RVA+mbRVAOffset);              break;          }
Missing Default,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following switch statement is missing a default case: switch((TableIndices)i){            case TableIndices.Module : if (this.moduleTable != null) j = this.moduleTable.Length; break;            case TableIndices.TypeRef : if (this.typeRefTable != null) j = this.typeRefTable.Length; break;            case TableIndices.TypeDef : if (this.typeDefTable != null) j = this.typeDefTable.Length; break;            case TableIndices.Field : if (this.fieldTable != null) j = this.fieldTable.Length; break;            case TableIndices.Method : if (this.methodTable != null) j = this.methodTable.Length; break;            case TableIndices.Param : if (this.paramTable != null) j = this.paramTable.Length; break;            case TableIndices.InterfaceImpl : if (this.interfaceImplTable != null) j = this.interfaceImplTable.Length; break;            case TableIndices.MemberRef : if (this.memberRefTable != null) j = this.memberRefTable.Length; break;            case TableIndices.Constant : if (this.constantTable != null) j = this.constantTable.Length; break;            case TableIndices.CustomAttribute : if (this.customAttributeTable != null) j = this.customAttributeTable.Length; break;            case TableIndices.FieldMarshal : if (this.fieldMarshalTable != null) j = this.fieldMarshalTable.Length; break;            case TableIndices.DeclSecurity : if (this.declSecurityTable != null) j = this.declSecurityTable.Length; break;            case TableIndices.ClassLayout : if (this.classLayoutTable != null) j = this.classLayoutTable.Length; break;            case TableIndices.FieldLayout : if (this.fieldLayoutTable != null) j = this.fieldLayoutTable.Length; break;            case TableIndices.StandAloneSig : if (this.standAloneSigTable != null) j = this.standAloneSigTable.Length; break;            case TableIndices.EventMap : if (this.eventMapTable != null) j = this.eventMapTable.Length; break;            case TableIndices.Event : if (this.eventTable != null) j = this.eventTable.Length; break;            case TableIndices.PropertyMap : if (this.propertyMapTable != null) j = this.propertyMapTable.Length; break;            case TableIndices.Property : if (this.propertyTable != null) j = this.propertyTable.Length; break;            case TableIndices.MethodSemantics : if (this.methodSemanticsTable != null) j = this.methodSemanticsTable.Length; break;            case TableIndices.MethodImpl : if (this.methodImplTable != null) j = this.methodImplTable.Length; break;            case TableIndices.ModuleRef : if (this.moduleRefTable != null) j = this.moduleRefTable.Length; break;            case TableIndices.TypeSpec : if (this.typeSpecTable != null) j = this.typeSpecTable.Length; break;            case TableIndices.ImplMap : if (this.implMapTable != null) j = this.implMapTable.Length; break;            case TableIndices.FieldRva : if (this.fieldRvaTable != null) j = this.fieldRvaTable.Length; break;            case TableIndices.Assembly : if (this.assemblyTable != null) j = this.assemblyTable.Length; break;            case TableIndices.AssemblyRef : if (this.assemblyRefTable != null) j = this.assemblyRefTable.Length; break;            case TableIndices.File : if (this.fileTable != null) j = this.fileTable.Length; break;            case TableIndices.ExportedType : if (this.exportedTypeTable != null) j = this.exportedTypeTable.Length; break;            case TableIndices.ManifestResource : if (this.manifestResourceTable != null) j = this.manifestResourceTable.Length; break;            case TableIndices.NestedClass : if (this.nestedClassTable != null) j = this.nestedClassTable.Length; break;            case TableIndices.GenericParam: if (this.genericParamTable != null) j = this.genericParamTable.Length; break;            case TableIndices.MethodSpec: if (this.methodSpecTable != null) j = this.methodSpecTable.Length; break;            case TableIndices.GenericParamConstraint: if (this.genericParamConstraintTable != null) j = this.genericParamConstraintTable.Length; break;          }
Missing Default,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,TablesLength,The following switch statement is missing a default case: switch((TableIndices)i){            case TableIndices.Module : length += m * (2 + stringRefSize + 3*guidRefSize); break;            case TableIndices.TypeRef : length += m * (resolutionScopeRefSize + 2*stringRefSize); break;            case TableIndices.TypeDef : length += m * (4 + 2*stringRefSize + typeDefOrRefOrSpecSize + tableRefSize[(int)TableIndices.Field] + tableRefSize[(int)TableIndices.Method]); break;            case TableIndices.Field : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.Method : length += m * (8 + stringRefSize + blobRefSize + tableRefSize[(int)TableIndices.Param]); break;            case TableIndices.Param : length += m * (4 + stringRefSize); break;            case TableIndices.InterfaceImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef]+typeDefOrRefOrSpecSize); break;            case TableIndices.MemberRef : length += m * (memberRefParentSize + stringRefSize + blobRefSize); break;            case TableIndices.Constant : length += m * (2 + constantParentRefSize + blobRefSize); break;            case TableIndices.CustomAttribute : length += m * (customAttributeParentRefSize + customAttributeConstructorRefSize + blobRefSize); break;            case TableIndices.FieldMarshal : length += m * (fieldMarshalParentRefSize + blobRefSize); break;            case TableIndices.DeclSecurity : length += m * (2 + declSecurityParentRefSize + blobRefSize); break;            case TableIndices.ClassLayout : length += m * (6 + tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.FieldLayout : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.StandAloneSig : length += m * (blobRefSize); break;            case TableIndices.EventMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Event]); break;            case TableIndices.Event : length += m * (2 + stringRefSize + typeDefOrRefOrSpecSize); break;            case TableIndices.PropertyMap : length += m * (tableRefSize[(int)TableIndices.TypeDef] + tableRefSize[(int)TableIndices.Property]); break;            case TableIndices.Property : length += m * (2 + stringRefSize + blobRefSize); break;            case TableIndices.MethodSemantics : length += m * (2 + tableRefSize[(int)TableIndices.Method] + hasSemanticRefSize); break;            case TableIndices.MethodImpl : length += m * (tableRefSize[(int)TableIndices.TypeDef] + 2*methodDefOrRefSize); break;            case TableIndices.ModuleRef : length += m * (stringRefSize); break;            case TableIndices.TypeSpec : length += m * (blobRefSize); break;            case TableIndices.ImplMap : length += m * (2 + memberForwardedRefSize + stringRefSize + tableRefSize[(int)TableIndices.ModuleRef]); break;            case TableIndices.FieldRva : length += m * (4 + tableRefSize[(int)TableIndices.Field]); break;            case TableIndices.EncLog: throw new InvalidMetadataException(ExceptionStrings.ENCLogTableEncountered);            case TableIndices.EncMap: throw new InvalidMetadataException(ExceptionStrings.ENCMapTableEncountered);            case TableIndices.Assembly : length += m * (16 + blobRefSize + 2*stringRefSize); break;            case TableIndices.AssemblyRef : length += m * (12 + 2*blobRefSize + 2*stringRefSize); break;            case TableIndices.File : length += m * (4 + stringRefSize + blobRefSize); break;            case TableIndices.ExportedType : length += m * (8 + 2*stringRefSize + implementationRefSize); break;            case TableIndices.ManifestResource : length += m * (8 + stringRefSize + implementationRefSize); break;            case TableIndices.NestedClass : length += m * (2*tableRefSize[(int)TableIndices.TypeDef]); break;            case TableIndices.GenericParam:               if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 0)                length += m * (6 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else if (TargetPlatform.MajorVersion == 1 && TargetPlatform.MinorVersion == 1)                length += m * (4 + typeDefOrMethodDefSize + stringRefSize + typeDefOrRefOrSpecSize);              else                length += m * (4 + typeDefOrMethodDefSize + stringRefSize);              break;            case TableIndices.MethodSpec: length += m * (methodDefOrRefSize + blobRefSize); break;            case TableIndices.GenericParamConstraint: length += m * (tableRefSize[(int)TableIndices.GenericParam] + typeDefOrRefOrSpecSize); break;          }
Missing Default,Microsoft.Cci.Metadata,MetadataWriter,C:\repos\Reactive-Extensions_IL2JS\CCI\Metadata.cs,WritePE,The following switch statement is missing a default case: switch (this.moduleKind){          case ModuleKindFlags.ConsoleApplication:             this.ntHeader.subsystem = 3;            break;          case ModuleKindFlags.DynamicallyLinkedLibrary:            this.ntHeader.characteristics |= 0x2000;            this.ntHeader.subsystem = 3;            break;          case ModuleKindFlags.WindowsApplication:            this.ntHeader.subsystem = 2;            break;        }
Missing Default,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,TypeDefOrRefOrSpecIsClass,The following switch statement is missing a default case: switch(codedIndex & 0x3){          case 0x00 : return this.TypeDefIsClass(codedIndex >> 2);          case 0x01 : TypeNode t = this.GetTypeFromRef(codedIndex >> 2); return t is Class;          case 0x02 : return this.TypeSpecIsClass(codedIndex >> 2);        }
Missing Default,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,TypeDefOrRefOrSpecIsClassButNotValueTypeBaseClass,The following switch statement is missing a default case: switch (codedIndex & 0x3) {          case 0x00: return this.TypeDefIsClassButNotValueTypeBaseClass(codedIndex >> 2);          case 0x01:             TypeNode t = this.GetTypeFromRef(codedIndex >> 2);             return t != CoreSystemTypes.ValueType && t != CoreSystemTypes.Enum && t is Class;          case 0x02: return this.TypeSpecIsClass(codedIndex >> 2);        }
Missing Default,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,DecodeAndGetTypeDefOrRefOrSpec,The following switch statement is missing a default case: switch(codedIndex & 0x3){          case 0x00 : return this.GetTypeFromDef(codedIndex >> 2);          case 0x01 : return this.GetTypeFromRef(codedIndex >> 2);          case 0x02 : return this.GetTypeFromSpec(codedIndex >> 2);        }
Missing Default,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,DecodeAndGetTypeDefOrRefOrSpec,The following switch statement is missing a default case: switch(codedIndex & 0x3){          case 0x00 : return this.GetTypeFromDef(codedIndex >> 2);          case 0x01 : return this.GetTypeFromRef(codedIndex >> 2' expectStruct);          case 0x02 : return this.GetTypeFromSpec(codedIndex >> 2);        }
Missing Default,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetTypeIfNotGenericInstance,The following switch statement is missing a default case: switch(codedIndex & 0x3){          case 0x00 : return this.GetTypeFromDef(codedIndex >> 2);          case 0x01 : return this.GetTypeFromRef(codedIndex >> 2' false);        }
Missing Default,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetConstructorDefOrRef,The following switch statement is missing a default case: switch(codedIndex & 0x7){          case 0x02 : return this.GetMethodFromDef(codedIndex >> 3);           case 0x03 : return (Method)this.GetMemberFromRef(codedIndex >> 3' out varArgTypes);        }
Missing Default,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetResources,The following switch statement is missing a default case: switch(impl & 0x3){              case 0x0:                 string modName = this.tables.GetString(this.tables.FileTable[(impl >> 2)-1].Name);                if ((this.tables.FileTable[(impl >> 2)-1].Flags & (int)FileFlags.ContainsNoMetaData) != 0){                  r.DefiningModule = new Module();                  r.DefiningModule.Directory = module.Directory;                  r.DefiningModule.Location = Path.Combine(module.Directory'modName);                  r.DefiningModule.Name = modName;                  r.DefiningModule.Kind = ModuleKindFlags.ManifestResourceFile;                  r.DefiningModule.ContainingAssembly = module.ContainingAssembly;                  r.DefiningModule.HashValue = this.tables.GetBlob(this.tables.FileTable[(impl >> 2) - 1].HashValue);                } else {                  string modLocation = modName;                  r.DefiningModule = GetNestedModule(module' modName' ref modLocation);                }                break;              case 0x1:                 r.DefiningModule = this.tables.AssemblyRefTable[(impl >> 2)-1].AssemblyReference.Assembly;                break;            }
Missing Default,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetCustomAttributeLiteralValue,The following switch statement is missing a default case: switch(type.typeCode){          case ElementType.Boolean: return sigReader.ReadBoolean();          case ElementType.Char: return sigReader.ReadChar();          case ElementType.Double: return sigReader.ReadDouble();          case ElementType.Single: return sigReader.ReadSingle();           case ElementType.Int16: return sigReader.ReadInt16();          case ElementType.Int32: return sigReader.ReadInt32();          case ElementType.Int64: return sigReader.ReadInt64();          case ElementType.Int8: return sigReader.ReadSByte();          case ElementType.UInt16: return sigReader.ReadUInt16();          case ElementType.UInt32: return sigReader.ReadUInt32();          case ElementType.UInt64: return sigReader.ReadUInt64();          case ElementType.UInt8: return sigReader.ReadByte();          case ElementType.String: return ReadSerString(sigReader);          case ElementType.ValueType:            EnumNode etype = GetCustomAttributeEnumNode(ref type);            return this.GetCustomAttributeLiteralValue(sigReader' etype.UnderlyingType);          case ElementType.Class: return this.GetTypeFromSerializedName(ReadSerString(sigReader));          case ElementType.SzArray:            int numElems = sigReader.ReadInt32();            TypeNode elemType = ((ArrayType)type).ElementType;            return this.GetCustomAttributeLiteralArray(sigReader' numElems' elemType);          case ElementType.Object:{            type = this.ParseTypeSignature(sigReader);            return this.GetCustomAttributeLiteralValue(sigReader' ref type);          }        }
Missing Default,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ConstructCustomAttributeLiteralArray,The following switch statement is missing a default case: switch(elemType.typeCode){          case ElementType.Boolean: return new Boolean[numElems];          case ElementType.Char: return new Char[numElems];          case ElementType.Double: return new Double[numElems];          case ElementType.Single: return new Single[numElems];           case ElementType.Int16: return new Int16[numElems];          case ElementType.Int32: return new Int32[numElems];          case ElementType.Int64: return new Int64[numElems];          case ElementType.Int8: return new SByte[numElems];          case ElementType.UInt16: return new UInt16[numElems];          case ElementType.UInt32: return new UInt32[numElems];          case ElementType.UInt64: return new UInt64[numElems];          case ElementType.UInt8: return new Byte[numElems];          case ElementType.String: return new String[numElems];          // Only enum value types are legal in attribute instances as stated in section 17.1.3 of the C# 1.0 spec          case ElementType.ValueType:            TypeNode/*!*/ elType = elemType;            EnumNode eType = GetCustomAttributeEnumNode(ref elType);            return this.ConstructCustomAttributeLiteralArray(numElems' eType.UnderlyingType);          // This needs to be a TypeNode since GetCustomAttributeLiteralValue will return a Struct if the Type is a value type          case ElementType.Class: return new TypeNode[numElems];          // REVIEW: Is this the right exception? Is this the right exception string?          // Multi-dimensional arrays are not legal in attribute instances according section 17.1.3 of the C# 1.0 spec          case ElementType.SzArray: throw new InvalidMetadataException(ExceptionStrings.BadCustomAttributeTypeEncodedToken);          case ElementType.Object: return new Object[numElems];        }
Missing Default,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetLiteral,The following switch statement is missing a default case: switch(valTypeCode){              case TypeCode.Boolean: type = CoreSystemTypes.Boolean; break;              case TypeCode.Byte: type = CoreSystemTypes.UInt8; break;              case TypeCode.Char: type = CoreSystemTypes.Char; break;              case TypeCode.Double: type = CoreSystemTypes.Double; break;              case TypeCode.Int16: type = CoreSystemTypes.Int16; break;              case TypeCode.Int32: type = CoreSystemTypes.Int32; break;              case TypeCode.Int64: type = CoreSystemTypes.Int64; break;              case TypeCode.SByte: type = CoreSystemTypes.Int8; break;              case TypeCode.Single: type = CoreSystemTypes.Single; break;              case TypeCode.String: type = CoreSystemTypes.String; break;              case TypeCode.UInt16: type = CoreSystemTypes.UInt16; break;              case TypeCode.UInt32: type = CoreSystemTypes.UInt32; break;              case TypeCode.UInt64: type = CoreSystemTypes.UInt64; break;              case TypeCode.Empty:              case TypeCode.Object: type = CoreSystemTypes.Type; break;            }
Missing Default,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetMethodDefOrRef,The following switch statement is missing a default case: switch(codedIndex & 0x1){          case 0x00 : return this.GetMethodFromDef(codedIndex >> 1);           case 0x01 :            TypeNodeList varArgTypes;            return (Method)this.GetMemberFromRef(codedIndex >> 1' out varArgTypes);        }
Missing Default,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetMethodDefOrRef,The following switch statement is missing a default case: switch(codedIndex & 0x1){          case 0x00 : return this.GetMethodFromDef(codedIndex >> 1);           case 0x01 :            TypeNodeList varArgTypes;            return (Method)this.GetMemberFromRef(codedIndex >> 1' out varArgTypes' numberOfGenericArguments);        }
Missing Default,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetMemberFromRef,The following switch statement is missing a default case: switch (header & 7){          case 1: callingConvention |= CallingConventionFlags.C; break;          case 2: callingConvention |= CallingConventionFlags.StandardCall; break;          case 3: callingConvention |= CallingConventionFlags.ThisCall; break;          case 4: callingConvention |= CallingConventionFlags.FastCall; break;          case 5: callingConvention |= CallingConventionFlags.VarArg; break;        }
Missing Default,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,GetTypeList,The following switch statement is missing a default case: switch (etr.Implementation & 0x3){            case 0:              string modName = this.tables.GetString(this.tables.FileTable[(etr.Implementation >> 2)-1].Name);              string modLocation = modName;              Module mod = GetNestedModule(assem' modName' ref modLocation);              if (mod == null){Debug.Assert(false); break;}              exportedType = mod.GetType(nameSpace' typeName);              if (exportedType == null){                HandleError(assem' String.Format(CultureInfo.CurrentCulture'                  ExceptionStrings.CouldNotFindExportedTypeInModule' nameSpace+"."+typeName' modLocation));                exportedType = new Class();                exportedType.Name = typeName;                exportedType.Namespace = nameSpace;                exportedType.Flags = TypeFlags.Class|TypeFlags.Public;                exportedType.DeclaringModule = mod;              }              break;            case 1:              AssemblyReference aref = this.tables.AssemblyRefTable[(etr.Implementation >> 2)-1].AssemblyReference;              if (aref == null){                HandleError(assem' ExceptionStrings.BadMetadataInExportTypeTableNoSuchAssemblyReference);                aref = new AssemblyReference("dummy assembly for bad reference");              }              AssemblyNode a = aref.Assembly;              if (a == null){Debug.Assert(false); continue;}              exportedType = a.GetType(nameSpace' typeName);              if (exportedType == null){                HandleError(assem' String.Format(CultureInfo.CurrentCulture'                   ExceptionStrings.CouldNotFindExportedTypeInAssembly' nameSpace+"."+typeName' a.StrongName));                exportedType = new Class();                exportedType.Name = typeName;                exportedType.Namespace = nameSpace;                exportedType.Flags = TypeFlags.Class|TypeFlags.Public;                exportedType.DeclaringModule = a;              }              break;            case 2:              TypeNode parentType = types[(etr.Implementation >> 2)-1];              if (parentType == null){                HandleError(assem' ExceptionStrings.BadMetadataInExportTypeTableNoSuchParentType);                parentType = new Class();                parentType.DeclaringModule = this.module;                parentType.Name = Identifier.For("Missing parent type");              }              exportedType = parentType.GetNestedType(typeName);              if (exportedType == null){                HandleError(assem' String.Format(CultureInfo.CurrentCulture'                  ExceptionStrings.CouldNotFindExportedNestedTypeInType' typeName' parentType.FullName));                exportedType = new Class();                exportedType.Name = typeName;                exportedType.Flags = TypeFlags.Class|TypeFlags.NestedPublic;                exportedType.DeclaringType = parentType;                exportedType.DeclaringModule = parentType.DeclaringModule;              }              break;          }
Missing Default,Microsoft.Cci.Metadata,Reader,C:\repos\Reactive-Extensions_IL2JS\CCI\Reader.cs,ParseTypeSignature,The following switch statement is missing a default case: switch(tok){          case ElementType.Boolean: return CoreSystemTypes.Boolean;          case ElementType.Char: return CoreSystemTypes.Char;          case ElementType.Double: return CoreSystemTypes.Double;          case ElementType.Int16: return CoreSystemTypes.Int16;          case ElementType.Int32: return CoreSystemTypes.Int32;          case ElementType.Int64: return CoreSystemTypes.Int64;          case ElementType.Int8: return CoreSystemTypes.Int8;          case ElementType.IntPtr: return CoreSystemTypes.IntPtr;          case ElementType.BoxedEnum:          case ElementType.Object: return CoreSystemTypes.Object;          case ElementType.Single: return CoreSystemTypes.Single;          case ElementType.String: return CoreSystemTypes.String;          case ElementType.DynamicallyTypedReference : return CoreSystemTypes.DynamicallyTypedReference;          case ElementType.UInt16: return CoreSystemTypes.UInt16;          case ElementType.UInt32: return CoreSystemTypes.UInt32;          case ElementType.UInt64: return CoreSystemTypes.UInt64;          case ElementType.UInt8: return CoreSystemTypes.UInt8;          case ElementType.UIntPtr: return CoreSystemTypes.UIntPtr;          case ElementType.Void: return CoreSystemTypes.Void;          case ElementType.Pointer:            elementType = this.ParseTypeSignature(sigReader' ref pinned);            if (elementType == null) elementType = CoreSystemTypes.Object;            if (elementType == null) return null;            return elementType.GetPointerType();          case ElementType.Reference:            elementType = this.ParseTypeSignature(sigReader' ref pinned);            if (elementType == null) elementType = CoreSystemTypes.Object;            return elementType.GetReferenceType();          case ElementType.FunctionPointer:            return this.ParseFunctionPointer(sigReader);          case ElementType.OptionalModifier:          case ElementType.RequiredModifier:            TypeNode modifier = this.DecodeAndGetTypeDefOrRefOrSpec(sigReader.ReadCompressedInt());            if (modifier == null) modifier = CoreSystemTypes.Object;            TypeNode modified = this.ParseTypeSignature(sigReader' ref pinned);            if (modified == null) modified = CoreSystemTypes.Object;            if (modified == null || modified == null) return null;            if (tok == ElementType.RequiredModifier)              return RequiredModifier.For(modifier' modified);            else              return OptionalModifier.For(modifier' modified);          case ElementType.Class:            return this.DecodeAndGetTypeDefOrRefOrSpec(sigReader.ReadCompressedInt());          case ElementType.ValueType:            return this.DecodeAndGetTypeDefOrRefOrSpec(sigReader.ReadCompressedInt()' true);          case ElementType.TypeParameter:            TypeNode tPar = null;            int pnum = sigReader.ReadCompressedInt();            if (this.currentTypeParameters != null && this.currentTypeParameters.Count > pnum)              tPar = this.currentTypeParameters[pnum];            if (tPar == null){              HandleError(this.module' String.Format(CultureInfo.CurrentCulture'                  ExceptionStrings.BadTypeParameterInPositionForType' pnum' this.currentType == null ? "" : this.currentType.FullName));              tPar = new TypeParameter();              tPar.Name = Identifier.For("Bad type parameter in position "+pnum);              tPar.DeclaringModule = this.module;            }            isTypeArgument = true;            return tPar;          case ElementType.MethodParameter:            TypeNode mTPar = null;            pnum = sigReader.ReadCompressedInt();            if (this.currentMethodTypeParameters != null && this.currentMethodTypeParameters.Count > pnum)              mTPar = this.currentMethodTypeParameters[pnum];            if (mTPar == null){              HandleError(this.module' String.Format(CultureInfo.CurrentCulture'                  ExceptionStrings.BadMethodTypeParameterInPosition' pnum));              mTPar = new MethodTypeParameter();              mTPar.Name = Identifier.For("Bad method type parameter in position "+pnum);            }            isTypeArgument = true;            return mTPar;          case ElementType.GenericTypeInstance:            TypeNodeList savedCurrentTypeParameters = this.currentTypeParameters;            TypeNode template = this.ParseTypeSignature(sigReader' ref pinned);            this.currentTypeParameters = savedCurrentTypeParameters;            if (template == null || template.ConsolidatedTemplateParameters == null) return template; //Likely a dummy type            if (CoreSystemTypes.Initialized){              if (this.currentTypeParameters == null || this.currentTypeParameters.Count == 0)                this.currentTypeParameters = template.ConsolidatedTemplateParameters;              TypeNodeList genArgs = this.ParseTypeList(sigReader);              if (this.module == null) return null;              TypeNode genInst = template.GetGenericTemplateInstance(this.module' genArgs);              this.currentTypeParameters = savedCurrentTypeParameters;              return genInst;            }            InterfaceExpression ifaceExpr = new InterfaceExpression(null);            ifaceExpr.Template = template;            ifaceExpr.Namespace = template.Namespace;            ifaceExpr.Name = template.Name;            ifaceExpr.TemplateArguments = this.ParseTypeList(sigReader);            this.currentTypeParameters = savedCurrentTypeParameters;            return ifaceExpr;          case ElementType.SzArray:            elementType = this.ParseTypeSignature(sigReader' ref pinned);            if (elementType == null) elementType = CoreSystemTypes.Object;            if (elementType == null) return null;            return elementType.GetArrayType(1);          case ElementType.Array:            elementType = this.ParseTypeSignature(sigReader' ref pinned);            if (elementType == null) elementType = CoreSystemTypes.Object;            if (elementType == null) return null;            int rank = sigReader.ReadCompressedInt();            int numSizes = sigReader.ReadCompressedInt();            int[] sizes = new int[numSizes];            for (int i = 0; i < numSizes; i++) sizes[i] = sigReader.ReadCompressedInt();            int numLoBounds = sigReader.ReadCompressedInt();            int[] loBounds = new int[numLoBounds];            for (int i = 0; i < numLoBounds; i++) loBounds[i] = sigReader.ReadCompressedInt();            return elementType.GetArrayType(rank' numSizes' numLoBounds' sizes' loBounds);          case ElementType.Sentinel: return null;          case ElementType.Type: return CoreSystemTypes.Type;          case ElementType.Enum: return this.GetTypeFromSerializedName(ReadSerString(sigReader));        }
