Implementation smell,Namespace,Class,File,Method,Description
Long Method,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeMethodBodyIL,The method has 180 lines of code.
Long Method,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeTypeReference,The method has 130 lines of code.
Long Method,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,WriteHeaders,The method has 125 lines of code.
Complex Method,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteString,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,CreateIndicesFor,Cyclomatic complexity of the method is 22
Complex Method,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetFieldFlags,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetMappingFlags,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetMethodFlags,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetMethodImplementationFlags,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetTypeDefFlags,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,Cyclomatic complexity of the method is 24
Complex Method,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,PopulateConstantTableRows,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,PopulateMethodSemanticsTableRows,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeMethodBody,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,DebuggerShouldHideMethod,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeCustomAttributeSignature,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetSerializedTypeName,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeSignature,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeWin32Resources,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,WriteDirectory,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,WriteHeaders,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,ReferenceIndexer,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,Visit,Cyclomatic complexity of the method is 10
Long Parameter List,Microsoft.Cci,IMetaDataEmit,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,DefineNestedType,The method has 5 parameters. Parameters: szTypeDef' dwTypeDefFlags' tkExtends' rtkImplements' tdEncloser
Long Parameter List,Microsoft.Cci,IMetaDataEmit,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,DefineMethod,The method has 7 parameters. Parameters: td' zName' dwMethodFlags' pvSigBlob' cbSigBlob' ulCodeRVA' dwImplFlags
Long Parameter List,Microsoft.Cci,IMetaDataEmit,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,DefineImportType,The method has 6 parameters. Parameters: pAssemImport' pbHashValue' cbHashValue' pImport' tdImport' pAssemEmit
Long Parameter List,Microsoft.Cci,IMetaDataEmit,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,DefineImportMember,The method has 7 parameters. Parameters: pAssemImport' pbHashValue' cbHashValue' pImport' mbMember' pAssemEmit' tkParent
Long Parameter List,Microsoft.Cci,IMetaDataEmit,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,DefineEvent,The method has 8 parameters. Parameters: td' szEvent' dwEventFlags' tkEventType' mdAddOn' mdRemoveOn' mdFire' rmdOtherMethods
Long Parameter List,Microsoft.Cci,IMetaDataEmit,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,SetEventProps,The method has 7 parameters. Parameters: ev' dwEventFlags' tkEventType' mdAddOn' mdRemoveOn' mdFire' rmdOtherMethods
Long Parameter List,Microsoft.Cci,IMetaDataEmit,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,DefineField,The method has 8 parameters. Parameters: td' szName' dwFieldFlags' pvSigBlob' cbSigBlob' dwCPlusTypeFlag' pValue' cchValue
Long Parameter List,Microsoft.Cci,IMetaDataEmit,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,DefineProperty,The method has 11 parameters. Parameters: td' szProperty' dwPropFlags' pvSig' cbSig' dwCPlusTypeFlag' pValue' cchValue' mdSetter' mdGetter' rmdOtherMethods
Long Parameter List,Microsoft.Cci,IMetaDataEmit,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,DefineParam,The method has 7 parameters. Parameters: md' ulParamSeq' szName' dwParamFlags' dwCPlusTypeFlag' pValue' cchValue
Long Parameter List,Microsoft.Cci,IMetaDataEmit,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,SetFieldProps,The method has 5 parameters. Parameters: fd' dwFieldFlags' dwCPlusTypeFlag' pValue' cchValue
Long Parameter List,Microsoft.Cci,IMetaDataEmit,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,SetPropertyProps,The method has 8 parameters. Parameters: pr' dwPropFlags' dwCPlusTypeFlag' pValue' cchValue' mdSetter' mdGetter' rmdOtherMethods
Long Parameter List,Microsoft.Cci,IMetaDataEmit,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,SetParamProps,The method has 6 parameters. Parameters: pd' szName' dwParamFlags' dwCPlusTypeFlag' pValue' cchValue
Long Parameter List,Microsoft.Cci,IMetaDataEmit,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,TranslateSigWithScope,The method has 10 parameters. Parameters: pAssemImport' pbHashValue' cbHashValue' import' pbSigBlob' cbSigBlob' pAssemEmit' emit' pvTranslatedSig' cbTranslatedSigMax
Long Parameter List,Microsoft.Cci,IMetaDataImport,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,GetTypeDefProps,The method has 5 parameters. Parameters: td' szTypeDef' cchTypeDef' pchTypeDef' pdwTypeDefFlags
Long Parameter List,Microsoft.Cci,IMetaDataImport,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,EnumMembersWithName,The method has 5 parameters. Parameters: phEnum' cl' szName' rMembers' cMax
Long Parameter List,Microsoft.Cci,IMetaDataImport,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,EnumMethodsWithName,The method has 5 parameters. Parameters: phEnum' cl' szName' rMethods' cMax
Long Parameter List,Microsoft.Cci,IMetaDataImport,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,EnumFieldsWithName,The method has 5 parameters. Parameters: phEnum' cl' szName' rFields' cMax
Long Parameter List,Microsoft.Cci,IMetaDataImport,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,EnumMethodImpls,The method has 5 parameters. Parameters: phEnum' td' rMethodBody' rMethodDecl' cMax
Long Parameter List,Microsoft.Cci,IMetaDataImport,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,EnumPermissionSets,The method has 5 parameters. Parameters: phEnum' tk' dwActions' rPermission' cMax
Long Parameter List,Microsoft.Cci,IMetaDataImport,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,GetMethodProps,The method has 9 parameters. Parameters: mb' pClass' szMethod' cchMethod' pchMethod' pdwAttr' ppvSigBlob' pcbSigBlob' pulCodeRVA
Long Parameter List,Microsoft.Cci,IMetaDataImport,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,GetMemberRefProps,The method has 6 parameters. Parameters: mr' ptk' szMember' cchMember' pchMember' ppvSigBlob
Long Parameter List,Microsoft.Cci,IMetaDataImport,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,GetEventProps,The method has 12 parameters. Parameters: ev' pClass' szEvent' cchEvent' pchEvent' pdwEventFlags' ptkEventType' pmdAddOn' pmdRemoveOn' pmdFire' rmdOtherMethod' cMax
Long Parameter List,Microsoft.Cci,IMetaDataImport,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,GetClassLayout,The method has 5 parameters. Parameters: td' pdwPackSize' rFieldOffset' cMax' pcFieldOffset
Long Parameter List,Microsoft.Cci,IMetaDataImport,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,GetPinvokeMap,The method has 5 parameters. Parameters: tk' pdwMappingFlags' szImportName' cchImportName' pchImportName
Long Parameter List,Microsoft.Cci,IMetaDataImport,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,EnumCustomAttributes,The method has 5 parameters. Parameters: phEnum' tk' tkType' rCustomAttributes' cMax
Long Parameter List,Microsoft.Cci,IMetaDataImport,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,GetMemberProps,The method has 12 parameters. Parameters: mb' pClass' szMember' cchMember' pchMember' pdwAttr' ppvSigBlob' pcbSigBlob' pulCodeRVA' pdwImplFlags' pdwCPlusTypeFlag' ppValue
Long Parameter List,Microsoft.Cci,IMetaDataImport,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,GetFieldProps,The method has 10 parameters. Parameters: mb' pClass' szField' cchField' pchField' pdwAttr' ppvSigBlob' pcbSigBlob' pdwCPlusTypeFlag' ppValue
Long Parameter List,Microsoft.Cci,IMetaDataImport,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,GetPropertyProps,The method has 15 parameters. Parameters: prop' pClass' szProperty' cchProperty' pchProperty' pdwPropFlags' ppvSig' pbSig' pdwCPlusTypeFlag' ppDefaultValue' pcchDefaultValue' pmdSetter' pmdGetter' rmdOtherMethod' cMax
Long Parameter List,Microsoft.Cci,IMetaDataImport,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,GetParamProps,The method has 9 parameters. Parameters: tk' pmd' pulSequence' szName' cchName' pchName' pdwAttr' pdwCPlusTypeFlag' ppValue
Long Parameter List,Microsoft.Cci,MetadataWrapper,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,DefineNestedType,The method has 5 parameters. Parameters: szTypeDef' dwTypeDefFlags' tkExtends' rtkImplements' tdEncloser
Long Parameter List,Microsoft.Cci,MetadataWrapper,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,DefineMethod,The method has 7 parameters. Parameters: td' zName' dwMethodFlags' pvSigBlob' cbSigBlob' ulCodeRVA' dwImplFlags
Long Parameter List,Microsoft.Cci,MetadataWrapper,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,DefineImportType,The method has 6 parameters. Parameters: pAssemImport' pbHashValue' cbHashValue' pImport' tdImport' pAssemEmit
Long Parameter List,Microsoft.Cci,MetadataWrapper,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,DefineImportMember,The method has 7 parameters. Parameters: pAssemImport' pbHashValue' cbHashValue' pImport' mbMember' pAssemEmit' tkParent
Long Parameter List,Microsoft.Cci,MetadataWrapper,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,DefineEvent,The method has 8 parameters. Parameters: td' szEvent' dwEventFlags' tkEventType' mdAddOn' mdRemoveOn' mdFire' rmdOtherMethods
Long Parameter List,Microsoft.Cci,MetadataWrapper,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,SetEventProps,The method has 7 parameters. Parameters: ev' dwEventFlags' tkEventType' mdAddOn' mdRemoveOn' mdFire' rmdOtherMethods
Long Parameter List,Microsoft.Cci,MetadataWrapper,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,DefineField,The method has 8 parameters. Parameters: td' szName' dwFieldFlags' pvSigBlob' cbSigBlob' dwCPlusTypeFlag' pValue' cchValue
Long Parameter List,Microsoft.Cci,MetadataWrapper,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,DefineProperty,The method has 11 parameters. Parameters: td' szProperty' dwPropFlags' pvSig' cbSig' dwCPlusTypeFlag' pValue' cchValue' mdSetter' mdGetter' rmdOtherMethods
Long Parameter List,Microsoft.Cci,MetadataWrapper,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,DefineParam,The method has 7 parameters. Parameters: md' ulParamSeq' szName' dwParamFlags' dwCPlusTypeFlag' pValue' cchValue
Long Parameter List,Microsoft.Cci,MetadataWrapper,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,SetFieldProps,The method has 5 parameters. Parameters: fd' dwFieldFlags' dwCPlusTypeFlag' pValue' cchValue
Long Parameter List,Microsoft.Cci,MetadataWrapper,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,SetPropertyProps,The method has 8 parameters. Parameters: pr' dwPropFlags' dwCPlusTypeFlag' pValue' cchValue' mdSetter' mdGetter' rmdOtherMethods
Long Parameter List,Microsoft.Cci,MetadataWrapper,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,SetParamProps,The method has 6 parameters. Parameters: pd' szName' dwParamFlags' dwCPlusTypeFlag' pValue' cchValue
Long Parameter List,Microsoft.Cci,MetadataWrapper,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,TranslateSigWithScope,The method has 10 parameters. Parameters: pAssemImport' pbHashValue' cbHashValue' import' pbSigBlob' cbSigBlob' pAssemEmit' emit' pvTranslatedSig' cbTranslatedSigMax
Long Parameter List,Microsoft.Cci,MetadataWrapper,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,GetTypeDefProps,The method has 5 parameters. Parameters: td' szTypeDef' cchTypeDef' pchTypeDef' pdwTypeDefFlags
Long Parameter List,Microsoft.Cci,MetadataWrapper,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,EnumMembersWithName,The method has 5 parameters. Parameters: phEnum' cl' szName' rMembers' cMax
Long Parameter List,Microsoft.Cci,MetadataWrapper,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,EnumMethodsWithName,The method has 5 parameters. Parameters: phEnum' cl' szName' rMethods' cMax
Long Parameter List,Microsoft.Cci,MetadataWrapper,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,EnumFieldsWithName,The method has 5 parameters. Parameters: phEnum' cl' szName' rFields' cMax
Long Parameter List,Microsoft.Cci,MetadataWrapper,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,EnumMethodImpls,The method has 5 parameters. Parameters: phEnum' td' rMethodBody' rMethodDecl' cMax
Long Parameter List,Microsoft.Cci,MetadataWrapper,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,EnumPermissionSets,The method has 5 parameters. Parameters: phEnum' tk' dwActions' rPermission' cMax
Long Parameter List,Microsoft.Cci,MetadataWrapper,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,GetMethodProps,The method has 9 parameters. Parameters: mb' pClass' szMethod' cchMethod' pchMethod' pdwAttr' ppvSigBlob' pcbSigBlob' pulCodeRVA
Long Parameter List,Microsoft.Cci,MetadataWrapper,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,GetMemberRefProps,The method has 6 parameters. Parameters: mr' ptk' szMember' cchMember' pchMember' ppvSigBlob
Long Parameter List,Microsoft.Cci,MetadataWrapper,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,GetEventProps,The method has 12 parameters. Parameters: ev' pClass' szEvent' cchEvent' pchEvent' pdwEventFlags' ptkEventType' pmdAddOn' pmdRemoveOn' pmdFire' rmdOtherMethod' cMax
Long Parameter List,Microsoft.Cci,MetadataWrapper,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,GetClassLayout,The method has 5 parameters. Parameters: td' pdwPackSize' rFieldOffset' cMax' pcFieldOffset
Long Parameter List,Microsoft.Cci,MetadataWrapper,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,GetPinvokeMap,The method has 5 parameters. Parameters: tk' pdwMappingFlags' szImportName' cchImportName' pchImportName
Long Parameter List,Microsoft.Cci,MetadataWrapper,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,EnumCustomAttributes,The method has 5 parameters. Parameters: phEnum' tk' tkType' rCustomAttributes' cMax
Long Parameter List,Microsoft.Cci,MetadataWrapper,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,GetMemberProps,The method has 12 parameters. Parameters: mb' pClass' szMember' cchMember' pchMember' pdwAttr' ppvSigBlob' pcbSigBlob' pulCodeRVA' pdwImplFlags' pdwCPlusTypeFlag' ppValue
Long Parameter List,Microsoft.Cci,MetadataWrapper,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,GetFieldProps,The method has 10 parameters. Parameters: mb' pClass' szField' cchField' pchField' pdwAttr' ppvSigBlob' pcbSigBlob' pdwCPlusTypeFlag' ppValue
Long Parameter List,Microsoft.Cci,MetadataWrapper,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,GetPropertyProps,The method has 15 parameters. Parameters: prop' pClass' szProperty' cchProperty' pchProperty' pdwPropFlags' ppvSig' pbSig' pdwCPlusTypeFlag' ppDefaultValue' pcchDefaultValue' pmdSetter' pmdGetter' rmdOtherMethod' cMax
Long Parameter List,Microsoft.Cci,MetadataWrapper,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,GetParamProps,The method has 9 parameters. Parameters: tk' pmd' pulSequence' szName' cchName' pchName' pdwAttr' pdwCPlusTypeFlag' ppValue
Long Parameter List,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,PeWriter,The method has 6 parameters. Parameters: module' host' peStream' sourceLocationProvider' localScopeProvider' pdbWriter
Long Parameter List,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,WritePeToStream,The method has 6 parameters. Parameters: module' host' stream' sourceLocationProvider' localScopeProvider' pdbWriter
Long Parameter List,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,WriteDirectory,The method has 7 parameters. Parameters: directory' writer' offset' level' sizeOfDirectoryTree' virtualAddressBase' dataWriter
Long Identifier,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetGenericMethodInstanceIndex,The length of the parameter genericMethodInstanceReference is 30.
Long Identifier,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeGenericMethodInstanceSignature,The length of the parameter genericMethodInstanceReference is 30.
Long Identifier,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeTypeReference,The length of the parameter genericMethodParameterReference is 31.
Long Identifier,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,,The length of the parameter tokenOfFirstMethodWithDebugInfo is 31.
Long Identifier,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,,The length of the parameter tokenOfLastMethodWithUsingInfo is 30.
Long Identifier,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,,The length of the parameter customAttributeTypeCodedIndexSize is 33.
Long Identifier,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,,The length of the parameter hasCustomAttributeCodedIndexSize is 32.
Long Identifier,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,,The length of the parameter hasFieldMarshallCodedIndexSize is 30.
Long Identifier,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,,The length of the parameter customDebugMetadataForCurrentMethod is 35.
Long Identifier,Microsoft.Cci,ReferenceIndexer,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,Visit,The length of the parameter genericMethodInstanceReference is 30.
Long Identifier,Microsoft.Cci,ReferenceIndexer,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,Visit,The length of the parameter genericMethodInstanceReference is 30.
Long Identifier,Microsoft.Cci,ReferenceIndexer,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,Visit,The length of the parameter specializedNestedTypeReference is 30.
Long Identifier,Microsoft.Cci,ReferenceIndexer,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,Visit,The length of the parameter unspecializedNestedTypeReference is 32.
Long Statement,Microsoft.Cci,MetadataWrapper,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\IMetadata.cs,GetTypeDefProps,The length of the statement  "        tName = TypeHelper.GetTypeName(t' NameFormattingOptions.UseGenericTypeNameSuffix|NameFormattingOptions.OmitContainingType); " is 123.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,FoldStrings,The length of the statement  "          this.stringIndexMap.Add(cur.Value' this.stringWriter.BaseStream.Position - (uint)(Encoding.UTF8.GetBytes(cur.Key).Length + 1)); " is 127.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,WritePeToStream,The length of the statement  "      writer.FillInSectionHeaders(); //Do this here so that tables and win32 resources can contain actual RVAs without the need for fixups. " is 133.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The length of the statement  "      result += this.tableSizes[2] * (4u + this.stringIndexSize + this.stringIndexSize + this.typeDefOrRefCodedIndexSize + this.fieldDefIndexSize + this.methodDefIndexSize); " is 167.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The length of the statement  "      result += this.tableSizes[12] * (0u + this.hasCustomAttributeCodedIndexSize + this.customAttributeTypeCodedIndexSize + this.blobIndexSize); " is 139.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The length of the statement  "      result += this.tableSizes[25] * (0u + this.typeDefIndexSize + this.methodDefOrRefCodedIndexSize + this.methodDefOrRefCodedIndexSize); " is 133.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The length of the statement  "      result += this.tableSizes[28] * (2u + this.memberForwardedCodedIndexSize + this.stringIndexSize + this.moduleRefIndexSize); " is 123.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The length of the statement  "      result += this.tableSizes[35] * (12u + this.blobIndexSize + this.stringIndexSize + this.stringIndexSize + this.blobIndexSize); " is 126.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,CreateIndicesFor,The length of the statement  "      if (methodDef.IsForwardReference && !(methodDef.IsAbstract || methodDef.IsExternal) && (methodDef.Body == Dummy.MethodBody)) return; " is 132.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,CreateIndicesFor,The length of the statement  "      if (methodDef.ReturnValueIsMarshalledExplicitly || IteratorHelper.EnumerableIsNotEmpty(methodDef.ReturnValueAttributes)) " is 120.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,FillInClrHeader,The length of the statement  "      clrHeader.strongNameSignature.RelativeVirtualAddress = clrHeader.resources.RelativeVirtualAddress+clrHeader.resources.Size; " is 123.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,FillInNtHeader,The length of the statement  "      ntHeader.SizeOfInitializedData = this.rdataSection.SizeOfRawData + this.coverSection.SizeOfRawData + this.sdataSection.SizeOfRawData + this.tlsSection.SizeOfRawData + this.resourceSection.SizeOfRawData + this.relocSection.SizeOfRawData; " is 236.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,FillInNtHeader,The length of the statement  "      ntHeader.CliHeaderTable.RelativeVirtualAddress = ntHeader.ImportAddressTable.RelativeVirtualAddress+ntHeader.ImportAddressTable.Size; " is 133.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,FillInNtHeader,The length of the statement  "      ntHeader.ImportTable.RelativeVirtualAddress = this.textSection.RelativeVirtualAddress+this.ComputeOffsetToImportTable(); " is 120.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,FillInNtHeader,The length of the statement  "      ntHeader.DebugTable.RelativeVirtualAddress = this.pdbWriter == null ? 0u : this.textSection.RelativeVirtualAddress+this.ComputeOffsetToDebugTable(); " is 148.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,FillInNtHeader,The length of the statement  "      ntHeader.DebugTable.Size = this.pdbWriter == null ? 0u : 0x1c; //Only the size of the fixed part of the debug table goes here. " is 126.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,FillInNtHeader,The length of the statement  "      ntHeader.ThreadLocalStorageTable.RelativeVirtualAddress = this.tlsSection.SizeOfRawData == 0 ? 0u : this.tlsSection.RelativeVirtualAddress; " is 139.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,FillInSectionHeaders,The length of the statement  "      this.textDataSection.RelativeVirtualAddress = this.textSection.RelativeVirtualAddress+this.textSection.VirtualSize-Aligned(this.textDataWriter.BaseStream.Length' 4); " is 165.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,FillInSectionHeaders,The length of the statement  "      this.textMethodBodySection.RelativeVirtualAddress = this.textSection.RelativeVirtualAddress+(!this.module.Requires64bits ? 8u : 16u)+72; " is 136.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,FillInSectionHeaders,The length of the statement  "      this.rdataSection.RelativeVirtualAddress = Aligned(this.textSection.RelativeVirtualAddress+this.textSection.VirtualSize' 0x2000); " is 129.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,FillInSectionHeaders,The length of the statement  "      this.sdataSection.RelativeVirtualAddress = Aligned(this.rdataSection.RelativeVirtualAddress+this.rdataSection.VirtualSize' 0x2000); " is 131.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,FillInSectionHeaders,The length of the statement  "      this.coverSection.RelativeVirtualAddress = Aligned(this.sdataSection.RelativeVirtualAddress+this.sdataSection.VirtualSize' 0x2000); " is 131.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,FillInSectionHeaders,The length of the statement  "      this.tlsSection.RelativeVirtualAddress = Aligned(this.coverSection.RelativeVirtualAddress+this.coverSection.VirtualSize' 0x2000); " is 129.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,FillInSectionHeaders,The length of the statement  "      this.resourceSection.RelativeVirtualAddress = Aligned(this.tlsSection.RelativeVirtualAddress+this.tlsSection.VirtualSize' 0x2000); " is 130.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,FillInSectionHeaders,The length of the statement  "      this.relocSection.RelativeVirtualAddress = Aligned(this.resourceSection.RelativeVirtualAddress+this.resourceSection.VirtualSize' 0x2000); " is 137.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetAssemblyRefIndex,The length of the statement  "      if (this.module.ContainingAssembly != null && unifiedAssembly.Equals(this.module.ContainingAssembly.AssemblyIdentity)) return 0; " is 128.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetMemberRefIndex,The length of the statement  "      if (memberRef == Dummy.MethodReference || memberRef == Dummy.FieldReference || memberRef == Dummy.Method || memberRef == Dummy.Field) { " is 135.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetMethodRefTokenFor,The length of the statement  "      return 0x0A000000 | this.GetMemberRefIndex(new DummyArrayMethodReference(arrayTypeReference' operationCode' this.host.NameTable' this.module.PlatformType)); " is 156.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetMethodSignatureIndex,The length of the statement  "      this.SerializeSignature(methodReference' methodReference.GenericParameterCount' methodReference.ExtraParameters' writer); " is 121.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetMethodToken,The length of the statement  "      if (methodDef != null && (methodReference == methodDef || !methodReference.AcceptsExtraArguments) && this.methodDefIndex.TryGetValue(methodDef' out methodDefIndex)) " is 164.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeGeneralMetadataHeader,The length of the statement  "      writer.WriteUint(12); // version must be 12 chars long (TODO: this observation is not supported by the standard or the ILAsm book). 16 " is 134.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The length of the statement  "      if (this.IndexDoesNotFit(16-5' TableIndices.Method' TableIndices.Field' TableIndices.TypeRef' TableIndices.TypeDef' TableIndices.Param' TableIndices.InterfaceImpl' " is 163.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The length of the statement  "        TableIndices.MemberRef' TableIndices.Module' TableIndices.DeclSecurity' TableIndices.Property' TableIndices.Event' TableIndices.StandAloneSig' " is 142.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The length of the statement  "        TableIndices.ModuleRef' TableIndices.TypeSpec' TableIndices.Assembly' TableIndices.AssemblyRef' TableIndices.File' TableIndices.ExportedType' TableIndices.ManifestResource)) " is 173.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The length of the statement  "      if (this.IndexDoesNotFit(16-3' TableIndices.TypeDef' TableIndices.TypeRef' TableIndices.ModuleRef' TableIndices.Method' TableIndices.TypeSpec)) " is 143.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The length of the statement  "      if (this.IndexDoesNotFit(16-2' TableIndices.Module' TableIndices.ModuleRef' TableIndices.AssemblyRef' TableIndices.TypeRef)) " is 124.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,PopulateTableRows,The length of the statement  "      //This table is populated after the others because it depends on the order of the entries of the generic parameter table. " is 121.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,PopulateExportedTypeTableRows,The length of the statement  "          INestedUnitNamespaceReference/*?*/ nestedUnitNamespaceReference = nsRef.ContainingUnitNamespace as INestedUnitNamespaceReference; " is 129.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,PopulateExportedTypeTableRows,The length of the statement  "            r.TypeNamespace = this.GetStringIndex(TypeHelper.GetNamespaceName(nestedUnitNamespaceReference' NameFormattingOptions.None)); " is 125.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,PopulateTypeDefTableRows,The length of the statement  "        r.Namespace = nsType == null ? StringIdx.Empty : this.GetStringIndex(TypeHelper.GetNamespaceName(nsType.ContainingUnitNamespace' NameFormattingOptions.None)); " is 158.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,PopulateTypeRefTableRows,The length of the statement  "          INestedUnitNamespaceReference/*?*/ nestedUnitNamespaceReference = nsTypeRef.ContainingUnitNamespace as INestedUnitNamespaceReference; " is 133.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,PopulateTypeRefTableRows,The length of the statement  "            r.Namespace = this.GetStringIndex(TypeHelper.GetNamespaceName(nestedUnitNamespaceReference' NameFormattingOptions.None)); " is 121.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,DebuggerShouldHideMethod,The length of the statement  "            if (nensRef != null && nensRef.Name.UniqueKey == this.host.NameTable.System.UniqueKey && nensRef.ContainingUnitNamespace is IRootUnitNamespaceReference) { " is 154.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,DebuggerShouldHideMethod,The length of the statement  "              return IteratorHelper.EnumerableIsEmpty(this.sourceLocationProvider.GetPrimarySourceLocationsFor(firstOperation.Location)); " is 123.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,DebuggerShouldHideMethod,The length of the statement  "      return IteratorHelper.EnumerableIsEmpty(this.sourceLocationProvider.GetPrimarySourceLocationsFor(firstOperation.Location)); " is 123.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeMethodBodyExceptionHandlerTable,The length of the statement  "      bool useSmallExceptionHeaders = MayUseSmallExceptionHeaders(numberOfExceptionHandlers' methodBody.OperationExceptionInformation); " is 129.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,AppendAssemblyQualifierIfNecessary,The length of the statement  "      if (referencedAssembly != null && (this.module.ContainingAssembly == null || !referencedAssembly.AssemblyIdentity.Equals(this.module.ContainingAssembly.AssemblyIdentity))) { " is 173.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetConsolidatedTypeArguments,The length of the statement  "      if (nestedTypeReference != null) GetConsolidatedTypeArguments(consolidatedTypeArguments' nestedTypeReference.ContainingType); " is 125.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetUninstantiatedGenericType,The length of the statement  "      if (genericTypeInstanceReference != null) return GetUninstantiatedGenericType(genericTypeInstanceReference.GenericType); " is 120.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeWin32Resources,The length of the statement  "      this.WriteDirectory(TypeDirectory' this.win32ResourceWriter' 0' 0' sizeOfDirectoryTree' this.resourceSection.RelativeVirtualAddress' dataWriter); " is 145.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,WriteDirectory,The length of the statement  "          dataWriter.WriteChars(name.ToCharArray());  //REVIEW: what happens if the name contains chars that do not fit into a single utf8 code point? " is 140.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,WriteHeaders,The length of the statement  "      //ushort characteristics = 0x0002|0x0004|0x0008; //executable | no COFF line nums | no COFF symbols (as required by the standard) " is 129.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,WriteClrHeader,The length of the statement  "      writer.WriteUint(clrHeader.strongNameSignature.Size == 0 ? 0u : clrHeader.strongNameSignature.RelativeVirtualAddress); //36 " is 123.
Long Statement,Microsoft.Cci,MethodSpecComparer,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,Equals,The length of the statement  "      return x == y || this.peWriter.GetMethodDefOrRefCodedIndex(x.GenericMethod) == this.peWriter.GetMethodDefOrRefCodedIndex(y.GenericMethod) && " is 140.
Long Statement,Microsoft.Cci,ReferenceIndexer,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,Visit,The length of the statement  "      //do not visit the reference to aliased type' it does not get into the type ref table based only on its membership of the exported types collection. " is 148.
Long Statement,Microsoft.Cci,ReferenceIndexer,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,Visit,The length of the statement  "      //but DO visit the reference to assembly (if any) that defines the aliased type. That assembly might not already be in the assembly reference list. " is 147.
Long Statement,Microsoft.Cci,ReferenceIndexer,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,Visit,The length of the statement  "      ISpecializedNestedTypeReference specializedNestedType = genericTypeInstanceReference.GenericType as ISpecializedNestedTypeReference; " is 132.
Long Statement,Microsoft.Cci,ReferenceIndexer,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,Visit,The length of the statement  "      IGenericMethodInstanceReference/*?*/ genericMethodInstanceReference = methodReference as IGenericMethodInstanceReference; " is 121.
Long Statement,Microsoft.Cci,ReferenceIndexer,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,Visit,The length of the statement  "        ISpecializedNestedTypeReference/*?*/ specializedNestedTypeReference = nestedTypeReference as ISpecializedNestedTypeReference; " is 125.
Complex Conditional,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,CreateIndicesFor,The conditional expression  "methodDef.IsForwardReference && !(methodDef.IsAbstract || methodDef.IsExternal) && (methodDef.Body == Dummy.MethodBody)"  is complex.
Complex Conditional,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,CreateIndicesFor,The conditional expression  "parDef.HasDefaultValue || parDef.IsOptional || parDef.IsOut || parDef.IsMarshalledExplicitly ||              IteratorHelper.EnumerableIsNotEmpty(parDef.Attributes) ||              parDef.Name != this.host.NameTable.EmptyName"  is complex.
Complex Conditional,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetMemberRefIndex,The conditional expression  "memberRef == Dummy.MethodReference || memberRef == Dummy.FieldReference || memberRef == Dummy.Method || memberRef == Dummy.Field"  is complex.
Complex Conditional,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetMethodToken,The conditional expression  "methodDef != null && (methodReference == methodDef || !methodReference.AcceptsExtraArguments) && this.methodDefIndex.TryGetValue(methodDef' out methodDefIndex)"  is complex.
Complex Conditional,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeMethodBody,The conditional expression  "il.Length < 64 && methodBody.MaxStack <= 8 && localVariableSignatureToken == 0 && numberOfExceptionHandlers == 0"  is complex.
Complex Conditional,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeWin32Resources,The conditional expression  "typeDifferent || (r.Id < 0 && r.Name != lastName) || r.Id > lastID"  is complex.
Complex Conditional,Microsoft.Cci,ReferenceIndexer,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,Visit,The conditional expression  "this.typeReferenceNeedsToken || nestedTypeReference != null ||          (typeReference.TypeCode == PrimitiveTypeCode.NotPrimitive && typeReference is INamespaceTypeReference)"  is complex.
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (this.UTF8) {          m.Position = i+n;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++) {            char ch = chars[j];            if ((ch & 0x80) != 0) goto writeUTF8;            buffer[i++] = (byte)ch;          }          return;        writeUTF8:          int ch32 = 0;          for (uint j = n-(m.Position-i); j < n; j++) {            char ch = chars[j];            if (ch < 0x80) {              m.Position = i+1;              buffer = m.Buffer;              buffer[i++] = (byte)ch;            } else if (ch < 0x800) {              m.Position = i+2;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>6) & 0x1F) | 0xC0);              buffer[i] = (byte)((ch & 0x3F) | 0x80);            } else if (0xD800 <= ch && ch <= 0xDBFF) {              ch32 = (ch & 0x3FF) << 10;            } else if (0xDC00 <= ch && ch <= 0xDFFF) {              ch32 |= ch & 0x3FF;              m.Position = i+4;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch32>>18) & 0x7) | 0xF0);              buffer[i++] = (byte)(((ch32>>12) & 0x3F) | 0x80);              buffer[i++] = (byte)(((ch32>>6) & 0x3F) | 0x80);              buffer[i] = (byte)((ch32 & 0x3F) | 0x80);            } else {              m.Position = i+3;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>12) & 0xF) | 0xE0);              buffer[i++] = (byte)(((ch>>6) & 0x3F) | 0x80);              buffer[i] = (byte)((ch & 0x3F) | 0x80);            }          }        } else {          m.Position = i+n*2;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++) {            char ch = chars[j];            buffer[i++] = (byte)ch;            buffer[i++] = (byte)(ch >> 8);          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (this.UTF8) {          m.Position = i+n;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++) {            char ch = chars[j];            if ((ch & 0x80) != 0) goto writeUTF8;            buffer[i++] = (byte)ch;          }          return;        writeUTF8:          int ch32 = 0;          for (uint j = n-(m.Position-i); j < n; j++) {            char ch = chars[j];            if (ch < 0x80) {              m.Position = i+1;              buffer = m.Buffer;              buffer[i++] = (byte)ch;            } else if (ch < 0x800) {              m.Position = i+2;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>6) & 0x1F) | 0xC0);              buffer[i] = (byte)((ch & 0x3F) | 0x80);            } else if (0xD800 <= ch && ch <= 0xDBFF) {              ch32 = (ch & 0x3FF) << 10;            } else if (0xDC00 <= ch && ch <= 0xDFFF) {              ch32 |= ch & 0x3FF;              m.Position = i+4;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch32>>18) & 0x7) | 0xF0);              buffer[i++] = (byte)(((ch32>>12) & 0x3F) | 0x80);              buffer[i++] = (byte)(((ch32>>6) & 0x3F) | 0x80);              buffer[i] = (byte)((ch32 & 0x3F) | 0x80);            } else {              m.Position = i+3;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>12) & 0xF) | 0xE0);              buffer[i++] = (byte)(((ch>>6) & 0x3F) | 0x80);              buffer[i] = (byte)((ch & 0x3F) | 0x80);            }          }        } else {          m.Position = i+n*2;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++) {            char ch = chars[j];            buffer[i++] = (byte)ch;            buffer[i++] = (byte)(ch >> 8);          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (this.UTF8) {          m.Position = i+n;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++) {            char ch = chars[j];            if ((ch & 0x80) != 0) goto writeUTF8;            buffer[i++] = (byte)ch;          }          return;        writeUTF8:          int ch32 = 0;          for (uint j = n-(m.Position-i); j < n; j++) {            char ch = chars[j];            if (ch < 0x80) {              m.Position = i+1;              buffer = m.Buffer;              buffer[i++] = (byte)ch;            } else if (ch < 0x800) {              m.Position = i+2;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>6) & 0x1F) | 0xC0);              buffer[i] = (byte)((ch & 0x3F) | 0x80);            } else if (0xD800 <= ch && ch <= 0xDBFF) {              ch32 = (ch & 0x3FF) << 10;            } else if (0xDC00 <= ch && ch <= 0xDFFF) {              ch32 |= ch & 0x3FF;              m.Position = i+4;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch32>>18) & 0x7) | 0xF0);              buffer[i++] = (byte)(((ch32>>12) & 0x3F) | 0x80);              buffer[i++] = (byte)(((ch32>>6) & 0x3F) | 0x80);              buffer[i] = (byte)((ch32 & 0x3F) | 0x80);            } else {              m.Position = i+3;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>12) & 0xF) | 0xE0);              buffer[i++] = (byte)(((ch>>6) & 0x3F) | 0x80);              buffer[i] = (byte)((ch & 0x3F) | 0x80);            }          }        } else {          m.Position = i+n*2;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++) {            char ch = chars[j];            buffer[i++] = (byte)ch;            buffer[i++] = (byte)(ch >> 8);          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (this.UTF8) {          m.Position = i+n;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++) {            char ch = chars[j];            if ((ch & 0x80) != 0) goto writeUTF8;            buffer[i++] = (byte)ch;          }          return;        writeUTF8:          int ch32 = 0;          for (uint j = n-(m.Position-i); j < n; j++) {            char ch = chars[j];            if (ch < 0x80) {              m.Position = i+1;              buffer = m.Buffer;              buffer[i++] = (byte)ch;            } else if (ch < 0x800) {              m.Position = i+2;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>6) & 0x1F) | 0xC0);              buffer[i] = (byte)((ch & 0x3F) | 0x80);            } else if (0xD800 <= ch && ch <= 0xDBFF) {              ch32 = (ch & 0x3FF) << 10;            } else if (0xDC00 <= ch && ch <= 0xDFFF) {              ch32 |= ch & 0x3FF;              m.Position = i+4;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch32>>18) & 0x7) | 0xF0);              buffer[i++] = (byte)(((ch32>>12) & 0x3F) | 0x80);              buffer[i++] = (byte)(((ch32>>6) & 0x3F) | 0x80);              buffer[i] = (byte)((ch32 & 0x3F) | 0x80);            } else {              m.Position = i+3;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>12) & 0xF) | 0xE0);              buffer[i++] = (byte)(((ch>>6) & 0x3F) | 0x80);              buffer[i] = (byte)((ch & 0x3F) | 0x80);            }          }        } else {          m.Position = i+n*2;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++) {            char ch = chars[j];            buffer[i++] = (byte)ch;            buffer[i++] = (byte)(ch >> 8);          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (this.UTF8) {          m.Position = i+n;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++) {            char ch = chars[j];            if ((ch & 0x80) != 0) goto writeUTF8;            buffer[i++] = (byte)ch;          }          return;        writeUTF8:          int ch32 = 0;          for (uint j = n-(m.Position-i); j < n; j++) {            char ch = chars[j];            if (ch < 0x80) {              m.Position = i+1;              buffer = m.Buffer;              buffer[i++] = (byte)ch;            } else if (ch < 0x800) {              m.Position = i+2;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>6) & 0x1F) | 0xC0);              buffer[i] = (byte)((ch & 0x3F) | 0x80);            } else if (0xD800 <= ch && ch <= 0xDBFF) {              ch32 = (ch & 0x3FF) << 10;            } else if (0xDC00 <= ch && ch <= 0xDFFF) {              ch32 |= ch & 0x3FF;              m.Position = i+4;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch32>>18) & 0x7) | 0xF0);              buffer[i++] = (byte)(((ch32>>12) & 0x3F) | 0x80);              buffer[i++] = (byte)(((ch32>>6) & 0x3F) | 0x80);              buffer[i] = (byte)((ch32 & 0x3F) | 0x80);            } else {              m.Position = i+3;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>12) & 0xF) | 0xE0);              buffer[i++] = (byte)(((ch>>6) & 0x3F) | 0x80);              buffer[i] = (byte)((ch & 0x3F) | 0x80);            }          }        } else {          m.Position = i+n*2;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++) {            char ch = chars[j];            buffer[i++] = (byte)ch;            buffer[i++] = (byte)(ch >> 8);          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (this.UTF8) {          m.Position = i+n;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++) {            char ch = chars[j];            if ((ch & 0x80) != 0) goto writeUTF8;            buffer[i++] = (byte)ch;          }          return;        writeUTF8:          int ch32 = 0;          for (uint j = n-(m.Position-i); j < n; j++) {            char ch = chars[j];            if (ch < 0x80) {              m.Position = i+1;              buffer = m.Buffer;              buffer[i++] = (byte)ch;            } else if (ch < 0x800) {              m.Position = i+2;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>6) & 0x1F) | 0xC0);              buffer[i] = (byte)((ch & 0x3F) | 0x80);            } else if (0xD800 <= ch && ch <= 0xDBFF) {              ch32 = (ch & 0x3FF) << 10;            } else if (0xDC00 <= ch && ch <= 0xDFFF) {              ch32 |= ch & 0x3FF;              m.Position = i+4;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch32>>18) & 0x7) | 0xF0);              buffer[i++] = (byte)(((ch32>>12) & 0x3F) | 0x80);              buffer[i++] = (byte)(((ch32>>6) & 0x3F) | 0x80);              buffer[i] = (byte)((ch32 & 0x3F) | 0x80);            } else {              m.Position = i+3;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>12) & 0xF) | 0xE0);              buffer[i++] = (byte)(((ch>>6) & 0x3F) | 0x80);              buffer[i] = (byte)((ch & 0x3F) | 0x80);            }          }        } else {          m.Position = i+n*2;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++) {            char ch = chars[j];            buffer[i++] = (byte)ch;            buffer[i++] = (byte)(ch >> 8);          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (this.UTF8) {          m.Position = i+n;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++) {            char ch = chars[j];            if ((ch & 0x80) != 0) goto writeUTF8;            buffer[i++] = (byte)ch;          }          return;        writeUTF8:          int ch32 = 0;          for (uint j = n-(m.Position-i); j < n; j++) {            char ch = chars[j];            if (ch < 0x80) {              m.Position = i+1;              buffer = m.Buffer;              buffer[i++] = (byte)ch;            } else if (ch < 0x800) {              m.Position = i+2;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>6) & 0x1F) | 0xC0);              buffer[i] = (byte)((ch & 0x3F) | 0x80);            } else if (0xD800 <= ch && ch <= 0xDBFF) {              ch32 = (ch & 0x3FF) << 10;            } else if (0xDC00 <= ch && ch <= 0xDFFF) {              ch32 |= ch & 0x3FF;              m.Position = i+4;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch32>>18) & 0x7) | 0xF0);              buffer[i++] = (byte)(((ch32>>12) & 0x3F) | 0x80);              buffer[i++] = (byte)(((ch32>>6) & 0x3F) | 0x80);              buffer[i] = (byte)((ch32 & 0x3F) | 0x80);            } else {              m.Position = i+3;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>12) & 0xF) | 0xE0);              buffer[i++] = (byte)(((ch>>6) & 0x3F) | 0x80);              buffer[i] = (byte)((ch & 0x3F) | 0x80);            }          }        } else {          m.Position = i+n*2;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++) {            char ch = chars[j];            buffer[i++] = (byte)ch;            buffer[i++] = (byte)(ch >> 8);          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (this.UTF8) {          m.Position = i+n;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++) {            char ch = chars[j];            if ((ch & 0x80) != 0) goto writeUTF8;            buffer[i++] = (byte)ch;          }          return;        writeUTF8:          int ch32 = 0;          for (uint j = n-(m.Position-i); j < n; j++) {            char ch = chars[j];            if (ch < 0x80) {              m.Position = i+1;              buffer = m.Buffer;              buffer[i++] = (byte)ch;            } else if (ch < 0x800) {              m.Position = i+2;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>6) & 0x1F) | 0xC0);              buffer[i] = (byte)((ch & 0x3F) | 0x80);            } else if (0xD800 <= ch && ch <= 0xDBFF) {              ch32 = (ch & 0x3FF) << 10;            } else if (0xDC00 <= ch && ch <= 0xDFFF) {              ch32 |= ch & 0x3FF;              m.Position = i+4;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch32>>18) & 0x7) | 0xF0);              buffer[i++] = (byte)(((ch32>>12) & 0x3F) | 0x80);              buffer[i++] = (byte)(((ch32>>6) & 0x3F) | 0x80);              buffer[i] = (byte)((ch32 & 0x3F) | 0x80);            } else {              m.Position = i+3;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>12) & 0xF) | 0xE0);              buffer[i++] = (byte)(((ch>>6) & 0x3F) | 0x80);              buffer[i] = (byte)((ch & 0x3F) | 0x80);            }          }        } else {          m.Position = i+n*2;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++) {            char ch = chars[j];            buffer[i++] = (byte)ch;            buffer[i++] = (byte)(ch >> 8);          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (this.UTF8) {          m.Position = i+n;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++) {            char ch = chars[j];            if ((ch & 0x80) != 0) goto writeUTF8;            buffer[i++] = (byte)ch;          }          return;        writeUTF8:          int ch32 = 0;          for (uint j = n-(m.Position-i); j < n; j++) {            char ch = chars[j];            if (ch < 0x80) {              m.Position = i+1;              buffer = m.Buffer;              buffer[i++] = (byte)ch;            } else if (ch < 0x800) {              m.Position = i+2;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>6) & 0x1F) | 0xC0);              buffer[i] = (byte)((ch & 0x3F) | 0x80);            } else if (0xD800 <= ch && ch <= 0xDBFF) {              ch32 = (ch & 0x3FF) << 10;            } else if (0xDC00 <= ch && ch <= 0xDFFF) {              ch32 |= ch & 0x3FF;              m.Position = i+4;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch32>>18) & 0x7) | 0xF0);              buffer[i++] = (byte)(((ch32>>12) & 0x3F) | 0x80);              buffer[i++] = (byte)(((ch32>>6) & 0x3F) | 0x80);              buffer[i] = (byte)((ch32 & 0x3F) | 0x80);            } else {              m.Position = i+3;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>12) & 0xF) | 0xE0);              buffer[i++] = (byte)(((ch>>6) & 0x3F) | 0x80);              buffer[i] = (byte)((ch & 0x3F) | 0x80);            }          }        } else {          m.Position = i+n*2;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++) {            char ch = chars[j];            buffer[i++] = (byte)ch;            buffer[i++] = (byte)(ch >> 8);          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (this.UTF8) {          m.Position = i+n;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++) {            char ch = chars[j];            if ((ch & 0x80) != 0) goto writeUTF8;            buffer[i++] = (byte)ch;          }          return;        writeUTF8:          int ch32 = 0;          for (uint j = n-(m.Position-i); j < n; j++) {            char ch = chars[j];            if (ch < 0x80) {              m.Position = i+1;              buffer = m.Buffer;              buffer[i++] = (byte)ch;            } else if (ch < 0x800) {              m.Position = i+2;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>6) & 0x1F) | 0xC0);              buffer[i] = (byte)((ch & 0x3F) | 0x80);            } else if (0xD800 <= ch && ch <= 0xDBFF) {              ch32 = (ch & 0x3FF) << 10;            } else if (0xDC00 <= ch && ch <= 0xDFFF) {              ch32 |= ch & 0x3FF;              m.Position = i+4;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch32>>18) & 0x7) | 0xF0);              buffer[i++] = (byte)(((ch32>>12) & 0x3F) | 0x80);              buffer[i++] = (byte)(((ch32>>6) & 0x3F) | 0x80);              buffer[i] = (byte)((ch32 & 0x3F) | 0x80);            } else {              m.Position = i+3;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>12) & 0xF) | 0xE0);              buffer[i++] = (byte)(((ch>>6) & 0x3F) | 0x80);              buffer[i] = (byte)((ch & 0x3F) | 0x80);            }          }        } else {          m.Position = i+n*2;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++) {            char ch = chars[j];            buffer[i++] = (byte)ch;            buffer[i++] = (byte)(ch >> 8);          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (this.UTF8) {          m.Position = i+n;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++) {            char ch = chars[j];            if ((ch & 0x80) != 0) goto writeUTF8;            buffer[i++] = (byte)ch;          }          return;        writeUTF8:          int ch32 = 0;          for (uint j = n-(m.Position-i); j < n; j++) {            char ch = chars[j];            if (ch < 0x80) {              m.Position = i+1;              buffer = m.Buffer;              buffer[i++] = (byte)ch;            } else if (ch < 0x800) {              m.Position = i+2;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>6) & 0x1F) | 0xC0);              buffer[i] = (byte)((ch & 0x3F) | 0x80);            } else if (0xD800 <= ch && ch <= 0xDBFF) {              ch32 = (ch & 0x3FF) << 10;            } else if (0xDC00 <= ch && ch <= 0xDFFF) {              ch32 |= ch & 0x3FF;              m.Position = i+4;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch32>>18) & 0x7) | 0xF0);              buffer[i++] = (byte)(((ch32>>12) & 0x3F) | 0x80);              buffer[i++] = (byte)(((ch32>>6) & 0x3F) | 0x80);              buffer[i] = (byte)((ch32 & 0x3F) | 0x80);            } else {              m.Position = i+3;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>12) & 0xF) | 0xE0);              buffer[i++] = (byte)(((ch>>6) & 0x3F) | 0x80);              buffer[i] = (byte)((ch & 0x3F) | 0x80);            }          }        } else {          m.Position = i+n*2;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++) {            char ch = chars[j];            buffer[i++] = (byte)ch;            buffer[i++] = (byte)(ch >> 8);          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (this.UTF8) {          m.Position = i+n;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++) {            char ch = chars[j];            if ((ch & 0x80) != 0) goto writeUTF8;            buffer[i++] = (byte)ch;          }          return;        writeUTF8:          int ch32 = 0;          for (uint j = n-(m.Position-i); j < n; j++) {            char ch = chars[j];            if (ch < 0x80) {              m.Position = i+1;              buffer = m.Buffer;              buffer[i++] = (byte)ch;            } else if (ch < 0x800) {              m.Position = i+2;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>6) & 0x1F) | 0xC0);              buffer[i] = (byte)((ch & 0x3F) | 0x80);            } else if (0xD800 <= ch && ch <= 0xDBFF) {              ch32 = (ch & 0x3FF) << 10;            } else if (0xDC00 <= ch && ch <= 0xDFFF) {              ch32 |= ch & 0x3FF;              m.Position = i+4;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch32>>18) & 0x7) | 0xF0);              buffer[i++] = (byte)(((ch32>>12) & 0x3F) | 0x80);              buffer[i++] = (byte)(((ch32>>6) & 0x3F) | 0x80);              buffer[i] = (byte)((ch32 & 0x3F) | 0x80);            } else {              m.Position = i+3;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>12) & 0xF) | 0xE0);              buffer[i++] = (byte)(((ch>>6) & 0x3F) | 0x80);              buffer[i] = (byte)((ch & 0x3F) | 0x80);            }          }        } else {          m.Position = i+n*2;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++) {            char ch = chars[j];            buffer[i++] = (byte)ch;            buffer[i++] = (byte)(ch >> 8);          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteDouble,The following statement contains a magic number: m.Position=i+8;
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteShort,The following statement contains a magic number: m.Position=i+2;
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteShort,The following statement contains a magic number: buffer[i] = (byte)(value >> 8);
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteUshort,The following statement contains a magic number: m.Position=i+2;
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteUshort,The following statement contains a magic number: buffer[i] = (byte)(value >> 8);
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteInt,The following statement contains a magic number: m.Position=i+4;
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteInt,The following statement contains a magic number: buffer[i++] = (byte)(value >> 8);
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteInt,The following statement contains a magic number: buffer[i++] = (byte)(value >> 16);
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteInt,The following statement contains a magic number: buffer[i] = (byte)(value >> 24);
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteUint,The following statement contains a magic number: m.Position=i+4;
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteUint,The following statement contains a magic number: buffer[i++] = (byte)(value >> 8);
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteUint,The following statement contains a magic number: buffer[i++] = (byte)(value >> 16);
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteUint,The following statement contains a magic number: buffer[i] = (byte)(value >> 24);
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteLong,The following statement contains a magic number: m.Position=i+8;
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteLong,The following statement contains a magic number: uint hi = (uint)(value >> 32);
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteLong,The following statement contains a magic number: buffer[i++] = (byte)(lo >> 8);
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteLong,The following statement contains a magic number: buffer[i++] = (byte)(lo >> 16);
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteLong,The following statement contains a magic number: buffer[i++] = (byte)(lo >> 24);
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteLong,The following statement contains a magic number: buffer[i++] = (byte)(hi >> 8);
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteLong,The following statement contains a magic number: buffer[i++] = (byte)(hi >> 16);
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteLong,The following statement contains a magic number: buffer[i] = (byte)(hi >> 24);
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteUlong,The following statement contains a magic number: m.Position=i+8;
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteUlong,The following statement contains a magic number: uint hi = (uint)(value >> 32);
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteUlong,The following statement contains a magic number: buffer[i++] = (byte)(lo >> 8);
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteUlong,The following statement contains a magic number: buffer[i++] = (byte)(lo >> 16);
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteUlong,The following statement contains a magic number: buffer[i++] = (byte)(lo >> 24);
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteUlong,The following statement contains a magic number: buffer[i++] = (byte)(hi >> 8);
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteUlong,The following statement contains a magic number: buffer[i++] = (byte)(hi >> 16);
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteUlong,The following statement contains a magic number: buffer[i] = (byte)(hi >> 24);
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteFloat,The following statement contains a magic number: m.Position=i+4;
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (!emitNullTerminator) {          if (this.UTF8)            this.WriteCompressedUInt(GetUTF8ByteCount(str));          else            this.WriteCompressedUInt((uint)n*2);        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (this.UTF8) {          m.Position = i+(uint)n;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++) {            char ch = str[j];            if (ch >= 0x80) goto writeUTF8;            buffer[i++] = (byte)ch;          }          if (emitNullTerminator) {            m.Position = i+1;            buffer = m.Buffer;            buffer[i] = 0;          }          return;        writeUTF8:          int ch32 = 0;          for (int j = n-(int)(m.Position-i); j < n; j++) {            char ch = str[j];            if (ch < 0x80) {              m.Position = i+1;              buffer = m.Buffer;              buffer[i++] = (byte)ch;            } else if (ch < 0x800) {              m.Position = i+2;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>6) & 0x1F) | 0xC0);              buffer[i++] = (byte)((ch & 0x3F) | 0x80);            } else if (0xD800 <= ch && ch <= 0xDBFF) {              ch32 = (ch & 0x3FF) << 10;            } else if (0xDC00 <= ch && ch <= 0xDFFF) {              ch32 |= ch & 0x3FF;              m.Position = i+4;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch32>>18) & 0x7) | 0xF0);              buffer[i++] = (byte)(((ch32>>12) & 0x3F) | 0x80);              buffer[i++] = (byte)(((ch32>>6) & 0x3F) | 0x80);              buffer[i++] = (byte)((ch32 & 0x3F) | 0x80);            } else {              m.Position = i+3;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>12) & 0xF) | 0xE0);              buffer[i++] = (byte)(((ch>>6) & 0x3F) | 0x80);              buffer[i++] = (byte)((ch & 0x3F) | 0x80);            }          }          if (emitNullTerminator) {            m.Position = i+1;            buffer = m.Buffer;            buffer[i] = 0;          }        } else {          m.Position = i+(uint)n*2;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++) {            char ch = str[j];            buffer[i++] = (byte)ch;            buffer[i++] = (byte)(ch >> 8);          }          if (emitNullTerminator) {            m.Position = i+2;            buffer = m.Buffer;            buffer[i++] = 0;            buffer[i] = 0;          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (this.UTF8) {          m.Position = i+(uint)n;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++) {            char ch = str[j];            if (ch >= 0x80) goto writeUTF8;            buffer[i++] = (byte)ch;          }          if (emitNullTerminator) {            m.Position = i+1;            buffer = m.Buffer;            buffer[i] = 0;          }          return;        writeUTF8:          int ch32 = 0;          for (int j = n-(int)(m.Position-i); j < n; j++) {            char ch = str[j];            if (ch < 0x80) {              m.Position = i+1;              buffer = m.Buffer;              buffer[i++] = (byte)ch;            } else if (ch < 0x800) {              m.Position = i+2;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>6) & 0x1F) | 0xC0);              buffer[i++] = (byte)((ch & 0x3F) | 0x80);            } else if (0xD800 <= ch && ch <= 0xDBFF) {              ch32 = (ch & 0x3FF) << 10;            } else if (0xDC00 <= ch && ch <= 0xDFFF) {              ch32 |= ch & 0x3FF;              m.Position = i+4;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch32>>18) & 0x7) | 0xF0);              buffer[i++] = (byte)(((ch32>>12) & 0x3F) | 0x80);              buffer[i++] = (byte)(((ch32>>6) & 0x3F) | 0x80);              buffer[i++] = (byte)((ch32 & 0x3F) | 0x80);            } else {              m.Position = i+3;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>12) & 0xF) | 0xE0);              buffer[i++] = (byte)(((ch>>6) & 0x3F) | 0x80);              buffer[i++] = (byte)((ch & 0x3F) | 0x80);            }          }          if (emitNullTerminator) {            m.Position = i+1;            buffer = m.Buffer;            buffer[i] = 0;          }        } else {          m.Position = i+(uint)n*2;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++) {            char ch = str[j];            buffer[i++] = (byte)ch;            buffer[i++] = (byte)(ch >> 8);          }          if (emitNullTerminator) {            m.Position = i+2;            buffer = m.Buffer;            buffer[i++] = 0;            buffer[i] = 0;          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (this.UTF8) {          m.Position = i+(uint)n;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++) {            char ch = str[j];            if (ch >= 0x80) goto writeUTF8;            buffer[i++] = (byte)ch;          }          if (emitNullTerminator) {            m.Position = i+1;            buffer = m.Buffer;            buffer[i] = 0;          }          return;        writeUTF8:          int ch32 = 0;          for (int j = n-(int)(m.Position-i); j < n; j++) {            char ch = str[j];            if (ch < 0x80) {              m.Position = i+1;              buffer = m.Buffer;              buffer[i++] = (byte)ch;            } else if (ch < 0x800) {              m.Position = i+2;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>6) & 0x1F) | 0xC0);              buffer[i++] = (byte)((ch & 0x3F) | 0x80);            } else if (0xD800 <= ch && ch <= 0xDBFF) {              ch32 = (ch & 0x3FF) << 10;            } else if (0xDC00 <= ch && ch <= 0xDFFF) {              ch32 |= ch & 0x3FF;              m.Position = i+4;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch32>>18) & 0x7) | 0xF0);              buffer[i++] = (byte)(((ch32>>12) & 0x3F) | 0x80);              buffer[i++] = (byte)(((ch32>>6) & 0x3F) | 0x80);              buffer[i++] = (byte)((ch32 & 0x3F) | 0x80);            } else {              m.Position = i+3;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>12) & 0xF) | 0xE0);              buffer[i++] = (byte)(((ch>>6) & 0x3F) | 0x80);              buffer[i++] = (byte)((ch & 0x3F) | 0x80);            }          }          if (emitNullTerminator) {            m.Position = i+1;            buffer = m.Buffer;            buffer[i] = 0;          }        } else {          m.Position = i+(uint)n*2;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++) {            char ch = str[j];            buffer[i++] = (byte)ch;            buffer[i++] = (byte)(ch >> 8);          }          if (emitNullTerminator) {            m.Position = i+2;            buffer = m.Buffer;            buffer[i++] = 0;            buffer[i] = 0;          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (this.UTF8) {          m.Position = i+(uint)n;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++) {            char ch = str[j];            if (ch >= 0x80) goto writeUTF8;            buffer[i++] = (byte)ch;          }          if (emitNullTerminator) {            m.Position = i+1;            buffer = m.Buffer;            buffer[i] = 0;          }          return;        writeUTF8:          int ch32 = 0;          for (int j = n-(int)(m.Position-i); j < n; j++) {            char ch = str[j];            if (ch < 0x80) {              m.Position = i+1;              buffer = m.Buffer;              buffer[i++] = (byte)ch;            } else if (ch < 0x800) {              m.Position = i+2;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>6) & 0x1F) | 0xC0);              buffer[i++] = (byte)((ch & 0x3F) | 0x80);            } else if (0xD800 <= ch && ch <= 0xDBFF) {              ch32 = (ch & 0x3FF) << 10;            } else if (0xDC00 <= ch && ch <= 0xDFFF) {              ch32 |= ch & 0x3FF;              m.Position = i+4;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch32>>18) & 0x7) | 0xF0);              buffer[i++] = (byte)(((ch32>>12) & 0x3F) | 0x80);              buffer[i++] = (byte)(((ch32>>6) & 0x3F) | 0x80);              buffer[i++] = (byte)((ch32 & 0x3F) | 0x80);            } else {              m.Position = i+3;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>12) & 0xF) | 0xE0);              buffer[i++] = (byte)(((ch>>6) & 0x3F) | 0x80);              buffer[i++] = (byte)((ch & 0x3F) | 0x80);            }          }          if (emitNullTerminator) {            m.Position = i+1;            buffer = m.Buffer;            buffer[i] = 0;          }        } else {          m.Position = i+(uint)n*2;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++) {            char ch = str[j];            buffer[i++] = (byte)ch;            buffer[i++] = (byte)(ch >> 8);          }          if (emitNullTerminator) {            m.Position = i+2;            buffer = m.Buffer;            buffer[i++] = 0;            buffer[i] = 0;          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (this.UTF8) {          m.Position = i+(uint)n;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++) {            char ch = str[j];            if (ch >= 0x80) goto writeUTF8;            buffer[i++] = (byte)ch;          }          if (emitNullTerminator) {            m.Position = i+1;            buffer = m.Buffer;            buffer[i] = 0;          }          return;        writeUTF8:          int ch32 = 0;          for (int j = n-(int)(m.Position-i); j < n; j++) {            char ch = str[j];            if (ch < 0x80) {              m.Position = i+1;              buffer = m.Buffer;              buffer[i++] = (byte)ch;            } else if (ch < 0x800) {              m.Position = i+2;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>6) & 0x1F) | 0xC0);              buffer[i++] = (byte)((ch & 0x3F) | 0x80);            } else if (0xD800 <= ch && ch <= 0xDBFF) {              ch32 = (ch & 0x3FF) << 10;            } else if (0xDC00 <= ch && ch <= 0xDFFF) {              ch32 |= ch & 0x3FF;              m.Position = i+4;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch32>>18) & 0x7) | 0xF0);              buffer[i++] = (byte)(((ch32>>12) & 0x3F) | 0x80);              buffer[i++] = (byte)(((ch32>>6) & 0x3F) | 0x80);              buffer[i++] = (byte)((ch32 & 0x3F) | 0x80);            } else {              m.Position = i+3;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>12) & 0xF) | 0xE0);              buffer[i++] = (byte)(((ch>>6) & 0x3F) | 0x80);              buffer[i++] = (byte)((ch & 0x3F) | 0x80);            }          }          if (emitNullTerminator) {            m.Position = i+1;            buffer = m.Buffer;            buffer[i] = 0;          }        } else {          m.Position = i+(uint)n*2;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++) {            char ch = str[j];            buffer[i++] = (byte)ch;            buffer[i++] = (byte)(ch >> 8);          }          if (emitNullTerminator) {            m.Position = i+2;            buffer = m.Buffer;            buffer[i++] = 0;            buffer[i] = 0;          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (this.UTF8) {          m.Position = i+(uint)n;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++) {            char ch = str[j];            if (ch >= 0x80) goto writeUTF8;            buffer[i++] = (byte)ch;          }          if (emitNullTerminator) {            m.Position = i+1;            buffer = m.Buffer;            buffer[i] = 0;          }          return;        writeUTF8:          int ch32 = 0;          for (int j = n-(int)(m.Position-i); j < n; j++) {            char ch = str[j];            if (ch < 0x80) {              m.Position = i+1;              buffer = m.Buffer;              buffer[i++] = (byte)ch;            } else if (ch < 0x800) {              m.Position = i+2;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>6) & 0x1F) | 0xC0);              buffer[i++] = (byte)((ch & 0x3F) | 0x80);            } else if (0xD800 <= ch && ch <= 0xDBFF) {              ch32 = (ch & 0x3FF) << 10;            } else if (0xDC00 <= ch && ch <= 0xDFFF) {              ch32 |= ch & 0x3FF;              m.Position = i+4;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch32>>18) & 0x7) | 0xF0);              buffer[i++] = (byte)(((ch32>>12) & 0x3F) | 0x80);              buffer[i++] = (byte)(((ch32>>6) & 0x3F) | 0x80);              buffer[i++] = (byte)((ch32 & 0x3F) | 0x80);            } else {              m.Position = i+3;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>12) & 0xF) | 0xE0);              buffer[i++] = (byte)(((ch>>6) & 0x3F) | 0x80);              buffer[i++] = (byte)((ch & 0x3F) | 0x80);            }          }          if (emitNullTerminator) {            m.Position = i+1;            buffer = m.Buffer;            buffer[i] = 0;          }        } else {          m.Position = i+(uint)n*2;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++) {            char ch = str[j];            buffer[i++] = (byte)ch;            buffer[i++] = (byte)(ch >> 8);          }          if (emitNullTerminator) {            m.Position = i+2;            buffer = m.Buffer;            buffer[i++] = 0;            buffer[i] = 0;          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (this.UTF8) {          m.Position = i+(uint)n;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++) {            char ch = str[j];            if (ch >= 0x80) goto writeUTF8;            buffer[i++] = (byte)ch;          }          if (emitNullTerminator) {            m.Position = i+1;            buffer = m.Buffer;            buffer[i] = 0;          }          return;        writeUTF8:          int ch32 = 0;          for (int j = n-(int)(m.Position-i); j < n; j++) {            char ch = str[j];            if (ch < 0x80) {              m.Position = i+1;              buffer = m.Buffer;              buffer[i++] = (byte)ch;            } else if (ch < 0x800) {              m.Position = i+2;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>6) & 0x1F) | 0xC0);              buffer[i++] = (byte)((ch & 0x3F) | 0x80);            } else if (0xD800 <= ch && ch <= 0xDBFF) {              ch32 = (ch & 0x3FF) << 10;            } else if (0xDC00 <= ch && ch <= 0xDFFF) {              ch32 |= ch & 0x3FF;              m.Position = i+4;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch32>>18) & 0x7) | 0xF0);              buffer[i++] = (byte)(((ch32>>12) & 0x3F) | 0x80);              buffer[i++] = (byte)(((ch32>>6) & 0x3F) | 0x80);              buffer[i++] = (byte)((ch32 & 0x3F) | 0x80);            } else {              m.Position = i+3;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>12) & 0xF) | 0xE0);              buffer[i++] = (byte)(((ch>>6) & 0x3F) | 0x80);              buffer[i++] = (byte)((ch & 0x3F) | 0x80);            }          }          if (emitNullTerminator) {            m.Position = i+1;            buffer = m.Buffer;            buffer[i] = 0;          }        } else {          m.Position = i+(uint)n*2;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++) {            char ch = str[j];            buffer[i++] = (byte)ch;            buffer[i++] = (byte)(ch >> 8);          }          if (emitNullTerminator) {            m.Position = i+2;            buffer = m.Buffer;            buffer[i++] = 0;            buffer[i] = 0;          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (this.UTF8) {          m.Position = i+(uint)n;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++) {            char ch = str[j];            if (ch >= 0x80) goto writeUTF8;            buffer[i++] = (byte)ch;          }          if (emitNullTerminator) {            m.Position = i+1;            buffer = m.Buffer;            buffer[i] = 0;          }          return;        writeUTF8:          int ch32 = 0;          for (int j = n-(int)(m.Position-i); j < n; j++) {            char ch = str[j];            if (ch < 0x80) {              m.Position = i+1;              buffer = m.Buffer;              buffer[i++] = (byte)ch;            } else if (ch < 0x800) {              m.Position = i+2;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>6) & 0x1F) | 0xC0);              buffer[i++] = (byte)((ch & 0x3F) | 0x80);            } else if (0xD800 <= ch && ch <= 0xDBFF) {              ch32 = (ch & 0x3FF) << 10;            } else if (0xDC00 <= ch && ch <= 0xDFFF) {              ch32 |= ch & 0x3FF;              m.Position = i+4;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch32>>18) & 0x7) | 0xF0);              buffer[i++] = (byte)(((ch32>>12) & 0x3F) | 0x80);              buffer[i++] = (byte)(((ch32>>6) & 0x3F) | 0x80);              buffer[i++] = (byte)((ch32 & 0x3F) | 0x80);            } else {              m.Position = i+3;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>12) & 0xF) | 0xE0);              buffer[i++] = (byte)(((ch>>6) & 0x3F) | 0x80);              buffer[i++] = (byte)((ch & 0x3F) | 0x80);            }          }          if (emitNullTerminator) {            m.Position = i+1;            buffer = m.Buffer;            buffer[i] = 0;          }        } else {          m.Position = i+(uint)n*2;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++) {            char ch = str[j];            buffer[i++] = (byte)ch;            buffer[i++] = (byte)(ch >> 8);          }          if (emitNullTerminator) {            m.Position = i+2;            buffer = m.Buffer;            buffer[i++] = 0;            buffer[i] = 0;          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (this.UTF8) {          m.Position = i+(uint)n;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++) {            char ch = str[j];            if (ch >= 0x80) goto writeUTF8;            buffer[i++] = (byte)ch;          }          if (emitNullTerminator) {            m.Position = i+1;            buffer = m.Buffer;            buffer[i] = 0;          }          return;        writeUTF8:          int ch32 = 0;          for (int j = n-(int)(m.Position-i); j < n; j++) {            char ch = str[j];            if (ch < 0x80) {              m.Position = i+1;              buffer = m.Buffer;              buffer[i++] = (byte)ch;            } else if (ch < 0x800) {              m.Position = i+2;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>6) & 0x1F) | 0xC0);              buffer[i++] = (byte)((ch & 0x3F) | 0x80);            } else if (0xD800 <= ch && ch <= 0xDBFF) {              ch32 = (ch & 0x3FF) << 10;            } else if (0xDC00 <= ch && ch <= 0xDFFF) {              ch32 |= ch & 0x3FF;              m.Position = i+4;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch32>>18) & 0x7) | 0xF0);              buffer[i++] = (byte)(((ch32>>12) & 0x3F) | 0x80);              buffer[i++] = (byte)(((ch32>>6) & 0x3F) | 0x80);              buffer[i++] = (byte)((ch32 & 0x3F) | 0x80);            } else {              m.Position = i+3;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>12) & 0xF) | 0xE0);              buffer[i++] = (byte)(((ch>>6) & 0x3F) | 0x80);              buffer[i++] = (byte)((ch & 0x3F) | 0x80);            }          }          if (emitNullTerminator) {            m.Position = i+1;            buffer = m.Buffer;            buffer[i] = 0;          }        } else {          m.Position = i+(uint)n*2;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++) {            char ch = str[j];            buffer[i++] = (byte)ch;            buffer[i++] = (byte)(ch >> 8);          }          if (emitNullTerminator) {            m.Position = i+2;            buffer = m.Buffer;            buffer[i++] = 0;            buffer[i] = 0;          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (this.UTF8) {          m.Position = i+(uint)n;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++) {            char ch = str[j];            if (ch >= 0x80) goto writeUTF8;            buffer[i++] = (byte)ch;          }          if (emitNullTerminator) {            m.Position = i+1;            buffer = m.Buffer;            buffer[i] = 0;          }          return;        writeUTF8:          int ch32 = 0;          for (int j = n-(int)(m.Position-i); j < n; j++) {            char ch = str[j];            if (ch < 0x80) {              m.Position = i+1;              buffer = m.Buffer;              buffer[i++] = (byte)ch;            } else if (ch < 0x800) {              m.Position = i+2;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>6) & 0x1F) | 0xC0);              buffer[i++] = (byte)((ch & 0x3F) | 0x80);            } else if (0xD800 <= ch && ch <= 0xDBFF) {              ch32 = (ch & 0x3FF) << 10;            } else if (0xDC00 <= ch && ch <= 0xDFFF) {              ch32 |= ch & 0x3FF;              m.Position = i+4;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch32>>18) & 0x7) | 0xF0);              buffer[i++] = (byte)(((ch32>>12) & 0x3F) | 0x80);              buffer[i++] = (byte)(((ch32>>6) & 0x3F) | 0x80);              buffer[i++] = (byte)((ch32 & 0x3F) | 0x80);            } else {              m.Position = i+3;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>12) & 0xF) | 0xE0);              buffer[i++] = (byte)(((ch>>6) & 0x3F) | 0x80);              buffer[i++] = (byte)((ch & 0x3F) | 0x80);            }          }          if (emitNullTerminator) {            m.Position = i+1;            buffer = m.Buffer;            buffer[i] = 0;          }        } else {          m.Position = i+(uint)n*2;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++) {            char ch = str[j];            buffer[i++] = (byte)ch;            buffer[i++] = (byte)(ch >> 8);          }          if (emitNullTerminator) {            m.Position = i+2;            buffer = m.Buffer;            buffer[i++] = 0;            buffer[i] = 0;          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (this.UTF8) {          m.Position = i+(uint)n;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++) {            char ch = str[j];            if (ch >= 0x80) goto writeUTF8;            buffer[i++] = (byte)ch;          }          if (emitNullTerminator) {            m.Position = i+1;            buffer = m.Buffer;            buffer[i] = 0;          }          return;        writeUTF8:          int ch32 = 0;          for (int j = n-(int)(m.Position-i); j < n; j++) {            char ch = str[j];            if (ch < 0x80) {              m.Position = i+1;              buffer = m.Buffer;              buffer[i++] = (byte)ch;            } else if (ch < 0x800) {              m.Position = i+2;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>6) & 0x1F) | 0xC0);              buffer[i++] = (byte)((ch & 0x3F) | 0x80);            } else if (0xD800 <= ch && ch <= 0xDBFF) {              ch32 = (ch & 0x3FF) << 10;            } else if (0xDC00 <= ch && ch <= 0xDFFF) {              ch32 |= ch & 0x3FF;              m.Position = i+4;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch32>>18) & 0x7) | 0xF0);              buffer[i++] = (byte)(((ch32>>12) & 0x3F) | 0x80);              buffer[i++] = (byte)(((ch32>>6) & 0x3F) | 0x80);              buffer[i++] = (byte)((ch32 & 0x3F) | 0x80);            } else {              m.Position = i+3;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>12) & 0xF) | 0xE0);              buffer[i++] = (byte)(((ch>>6) & 0x3F) | 0x80);              buffer[i++] = (byte)((ch & 0x3F) | 0x80);            }          }          if (emitNullTerminator) {            m.Position = i+1;            buffer = m.Buffer;            buffer[i] = 0;          }        } else {          m.Position = i+(uint)n*2;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++) {            char ch = str[j];            buffer[i++] = (byte)ch;            buffer[i++] = (byte)(ch >> 8);          }          if (emitNullTerminator) {            m.Position = i+2;            buffer = m.Buffer;            buffer[i++] = 0;            buffer[i] = 0;          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (this.UTF8) {          m.Position = i+(uint)n;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++) {            char ch = str[j];            if (ch >= 0x80) goto writeUTF8;            buffer[i++] = (byte)ch;          }          if (emitNullTerminator) {            m.Position = i+1;            buffer = m.Buffer;            buffer[i] = 0;          }          return;        writeUTF8:          int ch32 = 0;          for (int j = n-(int)(m.Position-i); j < n; j++) {            char ch = str[j];            if (ch < 0x80) {              m.Position = i+1;              buffer = m.Buffer;              buffer[i++] = (byte)ch;            } else if (ch < 0x800) {              m.Position = i+2;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>6) & 0x1F) | 0xC0);              buffer[i++] = (byte)((ch & 0x3F) | 0x80);            } else if (0xD800 <= ch && ch <= 0xDBFF) {              ch32 = (ch & 0x3FF) << 10;            } else if (0xDC00 <= ch && ch <= 0xDFFF) {              ch32 |= ch & 0x3FF;              m.Position = i+4;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch32>>18) & 0x7) | 0xF0);              buffer[i++] = (byte)(((ch32>>12) & 0x3F) | 0x80);              buffer[i++] = (byte)(((ch32>>6) & 0x3F) | 0x80);              buffer[i++] = (byte)((ch32 & 0x3F) | 0x80);            } else {              m.Position = i+3;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>12) & 0xF) | 0xE0);              buffer[i++] = (byte)(((ch>>6) & 0x3F) | 0x80);              buffer[i++] = (byte)((ch & 0x3F) | 0x80);            }          }          if (emitNullTerminator) {            m.Position = i+1;            buffer = m.Buffer;            buffer[i] = 0;          }        } else {          m.Position = i+(uint)n*2;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++) {            char ch = str[j];            buffer[i++] = (byte)ch;            buffer[i++] = (byte)(ch >> 8);          }          if (emitNullTerminator) {            m.Position = i+2;            buffer = m.Buffer;            buffer[i++] = 0;            buffer[i] = 0;          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (this.UTF8) {          m.Position = i+(uint)n;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++) {            char ch = str[j];            if (ch >= 0x80) goto writeUTF8;            buffer[i++] = (byte)ch;          }          if (emitNullTerminator) {            m.Position = i+1;            buffer = m.Buffer;            buffer[i] = 0;          }          return;        writeUTF8:          int ch32 = 0;          for (int j = n-(int)(m.Position-i); j < n; j++) {            char ch = str[j];            if (ch < 0x80) {              m.Position = i+1;              buffer = m.Buffer;              buffer[i++] = (byte)ch;            } else if (ch < 0x800) {              m.Position = i+2;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>6) & 0x1F) | 0xC0);              buffer[i++] = (byte)((ch & 0x3F) | 0x80);            } else if (0xD800 <= ch && ch <= 0xDBFF) {              ch32 = (ch & 0x3FF) << 10;            } else if (0xDC00 <= ch && ch <= 0xDFFF) {              ch32 |= ch & 0x3FF;              m.Position = i+4;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch32>>18) & 0x7) | 0xF0);              buffer[i++] = (byte)(((ch32>>12) & 0x3F) | 0x80);              buffer[i++] = (byte)(((ch32>>6) & 0x3F) | 0x80);              buffer[i++] = (byte)((ch32 & 0x3F) | 0x80);            } else {              m.Position = i+3;              buffer = m.Buffer;              buffer[i++] = (byte)(((ch>>12) & 0xF) | 0xE0);              buffer[i++] = (byte)(((ch>>6) & 0x3F) | 0x80);              buffer[i++] = (byte)((ch & 0x3F) | 0x80);            }          }          if (emitNullTerminator) {            m.Position = i+1;            buffer = m.Buffer;            buffer[i] = 0;          }        } else {          m.Position = i+(uint)n*2;          byte[] buffer = m.Buffer;          for (int j = 0; j < n; j++) {            char ch = str[j];            buffer[i++] = (byte)ch;            buffer[i++] = (byte)(ch >> 8);          }          if (emitNullTerminator) {            m.Position = i+2;            buffer = m.Buffer;            buffer[i++] = 0;            buffer[i] = 0;          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteCompressedInt,The following statement contains a magic number: if (val >= 0) {          val = val << 1;          this.WriteCompressedUInt((uint)val);        } else {          if (val > -0x40) {            val = 0x40 + val;            val = (val << 1)|1;            this.WriteByte((byte)val);          } else if (val >= -0x2000) {            val = 0x2000 - val;            val = (val << 1)|1;            this.WriteByte((byte)((val >> 8)|0x80));            this.WriteByte((byte)(val & 0xff));          } else if (val >= -0x20000000) {            val = 0x20000000 - val;            val = (val << 1)|1;            this.WriteByte((byte)((val >> 24)|0xc0));            this.WriteByte((byte)((val & 0xff0000)>>16));            this.WriteByte((byte)((val & 0xff00)>>8));            this.WriteByte((byte)(val & 0xff));          } else {            //^ assume false;          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteCompressedInt,The following statement contains a magic number: if (val >= 0) {          val = val << 1;          this.WriteCompressedUInt((uint)val);        } else {          if (val > -0x40) {            val = 0x40 + val;            val = (val << 1)|1;            this.WriteByte((byte)val);          } else if (val >= -0x2000) {            val = 0x2000 - val;            val = (val << 1)|1;            this.WriteByte((byte)((val >> 8)|0x80));            this.WriteByte((byte)(val & 0xff));          } else if (val >= -0x20000000) {            val = 0x20000000 - val;            val = (val << 1)|1;            this.WriteByte((byte)((val >> 24)|0xc0));            this.WriteByte((byte)((val & 0xff0000)>>16));            this.WriteByte((byte)((val & 0xff00)>>8));            this.WriteByte((byte)(val & 0xff));          } else {            //^ assume false;          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteCompressedInt,The following statement contains a magic number: if (val >= 0) {          val = val << 1;          this.WriteCompressedUInt((uint)val);        } else {          if (val > -0x40) {            val = 0x40 + val;            val = (val << 1)|1;            this.WriteByte((byte)val);          } else if (val >= -0x2000) {            val = 0x2000 - val;            val = (val << 1)|1;            this.WriteByte((byte)((val >> 8)|0x80));            this.WriteByte((byte)(val & 0xff));          } else if (val >= -0x20000000) {            val = 0x20000000 - val;            val = (val << 1)|1;            this.WriteByte((byte)((val >> 24)|0xc0));            this.WriteByte((byte)((val & 0xff0000)>>16));            this.WriteByte((byte)((val & 0xff00)>>8));            this.WriteByte((byte)(val & 0xff));          } else {            //^ assume false;          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteCompressedInt,The following statement contains a magic number: if (val >= 0) {          val = val << 1;          this.WriteCompressedUInt((uint)val);        } else {          if (val > -0x40) {            val = 0x40 + val;            val = (val << 1)|1;            this.WriteByte((byte)val);          } else if (val >= -0x2000) {            val = 0x2000 - val;            val = (val << 1)|1;            this.WriteByte((byte)((val >> 8)|0x80));            this.WriteByte((byte)(val & 0xff));          } else if (val >= -0x20000000) {            val = 0x20000000 - val;            val = (val << 1)|1;            this.WriteByte((byte)((val >> 24)|0xc0));            this.WriteByte((byte)((val & 0xff0000)>>16));            this.WriteByte((byte)((val & 0xff00)>>8));            this.WriteByte((byte)(val & 0xff));          } else {            //^ assume false;          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteCompressedUInt,The following statement contains a magic number: if (val <= 0x7f)          this.WriteByte((byte)val);        else if (val <= 0x3fff) {          this.WriteByte((byte)((val >> 8)|0x80));          this.WriteByte((byte)(val & 0xff));        } else if (val <= 0x1fffffff) {          this.WriteByte((byte)((val >> 24)|0xc0));          this.WriteByte((byte)((val & 0xff0000)>>16));          this.WriteByte((byte)((val & 0xff00)>>8));          this.WriteByte((byte)(val & 0xff));        } else {          //^ assume false;        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteCompressedUInt,The following statement contains a magic number: if (val <= 0x7f)          this.WriteByte((byte)val);        else if (val <= 0x3fff) {          this.WriteByte((byte)((val >> 8)|0x80));          this.WriteByte((byte)(val & 0xff));        } else if (val <= 0x1fffffff) {          this.WriteByte((byte)((val >> 24)|0xc0));          this.WriteByte((byte)((val & 0xff0000)>>16));          this.WriteByte((byte)((val & 0xff00)>>8));          this.WriteByte((byte)(val & 0xff));        } else {          //^ assume false;        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteCompressedUInt,The following statement contains a magic number: if (val <= 0x7f)          this.WriteByte((byte)val);        else if (val <= 0x3fff) {          this.WriteByte((byte)((val >> 8)|0x80));          this.WriteByte((byte)(val & 0xff));        } else if (val <= 0x1fffffff) {          this.WriteByte((byte)((val >> 24)|0xc0));          this.WriteByte((byte)((val & 0xff0000)>>16));          this.WriteByte((byte)((val & 0xff00)>>8));          this.WriteByte((byte)(val & 0xff));        } else {          //^ assume false;        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,WriteCompressedUInt,The following statement contains a magic number: if (val <= 0x7f)          this.WriteByte((byte)val);        else if (val <= 0x3fff) {          this.WriteByte((byte)((val >> 8)|0x80));          this.WriteByte((byte)(val & 0xff));        } else if (val <= 0x1fffffff) {          this.WriteByte((byte)((val >> 24)|0xc0));          this.WriteByte((byte)((val & 0xff0000)>>16));          this.WriteByte((byte)((val & 0xff00)>>8));          this.WriteByte((byte)(val & 0xff));        } else {          //^ assume false;        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,GetUTF8ByteCount,The following statement contains a magic number: for (int i = 0' n = str.Length; i < n; i++) {          char ch = str[i];          if (ch < 0x80) {            count += 1;          } else if (ch < 0x800) {            count += 2;          } else if (0xD800 <= ch && ch <= 0xDBFF) {            count += 2;          } else if (0xDC00 <= ch && ch <= 0xDFFF) {            count += 2;          } else {            count += 3;          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,GetUTF8ByteCount,The following statement contains a magic number: for (int i = 0' n = str.Length; i < n; i++) {          char ch = str[i];          if (ch < 0x80) {            count += 1;          } else if (ch < 0x800) {            count += 2;          } else if (0xD800 <= ch && ch <= 0xDBFF) {            count += 2;          } else if (0xDC00 <= ch && ch <= 0xDFFF) {            count += 2;          } else {            count += 3;          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,GetUTF8ByteCount,The following statement contains a magic number: for (int i = 0' n = str.Length; i < n; i++) {          char ch = str[i];          if (ch < 0x80) {            count += 1;          } else if (ch < 0x800) {            count += 2;          } else if (0xD800 <= ch && ch <= 0xDBFF) {            count += 2;          } else if (0xDC00 <= ch && ch <= 0xDFFF) {            count += 2;          } else {            count += 3;          }        }
Magic Number,Microsoft.Cci,BinaryWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\BinaryWriter.cs,GetUTF8ByteCount,The following statement contains a magic number: for (int i = 0' n = str.Length; i < n; i++) {          char ch = str[i];          if (ch < 0x80) {            count += 1;          } else if (ch < 0x800) {            count += 2;          } else if (0xD800 <= ch && ch <= 0xDBFF) {            count += 2;          } else if (0xDC00 <= ch && ch <= 0xDFFF) {            count += 2;          } else {            count += 3;          }        }
Magic Number,Microsoft.Cci,MemoryStream,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\MemoryStream.cs,MemoryStream,The following statement contains a magic number: this.Buffer = new byte[64];
Magic Number,Microsoft.Cci,MemoryStream,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\MemoryStream.cs,Grow,The following statement contains a magic number: ulong n2 = n*2;
Magic Number,Microsoft.Cci,MemoryStream,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\MemoryStream.cs,Grow,The following statement contains a magic number: if (n2 == 0) n2 = 16;
Magic Number,Microsoft.Cci,MemoryStream,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\MemoryStream.cs,Grow,The following statement contains a magic number: while (m >= n2) n2 = n2*2;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeHashSize,The following statement contains a magic number: if (assembly != null) {          uint keySize = IteratorHelper.EnumerableCount(assembly.PublicKey);          if (keySize > 0) {            if (keySize > 128+32)              hashSize = keySize-32;            else              hashSize = 128;          }        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeHashSize,The following statement contains a magic number: if (assembly != null) {          uint keySize = IteratorHelper.EnumerableCount(assembly.PublicKey);          if (keySize > 0) {            if (keySize > 128+32)              hashSize = keySize-32;            else              hashSize = 128;          }        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeHashSize,The following statement contains a magic number: if (assembly != null) {          uint keySize = IteratorHelper.EnumerableCount(assembly.PublicKey);          if (keySize > 0) {            if (keySize > 128+32)              hashSize = keySize-32;            else              hashSize = 128;          }        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeHashSize,The following statement contains a magic number: if (assembly != null) {          uint keySize = IteratorHelper.EnumerableCount(assembly.PublicKey);          if (keySize > 0) {            if (keySize > 128+32)              hashSize = keySize-32;            else              hashSize = 128;          }        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeStrongNameSignatureSize,The following statement contains a magic number: return keySize < 128+32 ? 128u : keySize-32;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeStrongNameSignatureSize,The following statement contains a magic number: return keySize < 128+32 ? 128u : keySize-32;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeStrongNameSignatureSize,The following statement contains a magic number: return keySize < 128+32 ? 128u : keySize-32;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeOffsetToDebugTable,The following statement contains a magic number: result += Aligned(this.resourceWriter.BaseStream.Length' 4);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeOffsetToMetadata,The following statement contains a magic number: result += 72;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeOffsetToMetadata,The following statement contains a magic number: result += Aligned(this.methodStream.Length' 4);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfMetadata,The following statement contains a magic number: uint result = 108;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfMetadata,The following statement contains a magic number: result += Aligned(this.ComputeSizeOfMetadataTablesStream()' 4);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfMetadata,The following statement contains a magic number: result += Aligned(this.stringWriter.BaseStream.Length' 4);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfMetadata,The following statement contains a magic number: result += Aligned(this.userStringWriter.BaseStream.Length' 4);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfMetadata,The following statement contains a magic number: result += Aligned(this.blobWriter.BaseStream.Length' 4);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfMetadata,The following statement contains a magic number: result += 16;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes[2] * (4u + this.stringIndexSize + this.stringIndexSize + this.typeDefOrRefCodedIndexSize + this.fieldDefIndexSize + this.methodDefIndexSize);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes[4] * (2u + this.stringIndexSize + this.blobIndexSize);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes[6] * (8u + this.stringIndexSize + this.blobIndexSize + this.parameterIndexSize);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes[8] * (4u + this.stringIndexSize);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes[9] * (0u + this.typeDefIndexSize + this.typeDefOrRefCodedIndexSize);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes[10] * (0u + this.memberRefParentCodedIndexSize + this.stringIndexSize + this.blobIndexSize);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes[11] * (2u + this.hasConstantCodedIndexSize + this.blobIndexSize);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes[12] * (0u + this.hasCustomAttributeCodedIndexSize + this.customAttributeTypeCodedIndexSize + this.blobIndexSize);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes[13] * (0u + this.hasFieldMarshallCodedIndexSize + this.blobIndexSize);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes[14] * (2u + this.declSecurityCodedIndexSize + this.blobIndexSize);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes[15] * (6u + this.typeDefIndexSize);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes[16] * (4u + this.fieldDefIndexSize);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes[17] * (0u + this.blobIndexSize);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes[18] * (0u + this.typeDefIndexSize + this.eventDefIndexSize);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes[20] * (2u + this.stringIndexSize + this.typeDefOrRefCodedIndexSize);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes[21] * (0u + this.typeDefIndexSize + this.propertyDefIndexSize);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes[23] * (2u + this.stringIndexSize + this.blobIndexSize);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes[24] * (2u + this.methodDefIndexSize + this.hasSemanticsCodedIndexSize);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes[25] * (0u + this.typeDefIndexSize + this.methodDefOrRefCodedIndexSize + this.methodDefOrRefCodedIndexSize);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes[26] * (0u + this.stringIndexSize);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes[27] * (0u + this.blobIndexSize);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes[28] * (2u + this.memberForwardedCodedIndexSize + this.stringIndexSize + this.moduleRefIndexSize);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes[29] * (4u + this.fieldDefIndexSize);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes[32] * (16u + this.blobIndexSize + this.stringIndexSize + this.stringIndexSize);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes[35] * (12u + this.blobIndexSize + this.stringIndexSize + this.stringIndexSize + this.blobIndexSize);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes[38] * (4u + this.stringIndexSize + this.blobIndexSize);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes[39] * (8u + this.stringIndexSize + this.stringIndexSize + this.implementationCodedIndexSize);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes[40] * (8u + this.stringIndexSize + this.implementationCodedIndexSize);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes[41] * (0u + this.typeDefIndexSize + this.typeDefIndexSize);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes[42] * (4u + this.typeOrMethodDefCodedIndexSize + this.stringIndexSize);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes[43] * (0u + this.methodDefOrRefCodedIndexSize + this.blobIndexSize);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes[44] * (0u + this.genericParamIndexSize + this.typeDefOrRefCodedIndexSize);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfPeHeaders,The following statement contains a magic number: ushort numberOfSections = 2;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfPeHeaders,The following statement contains a magic number: uint sizeOfPeHeaders = 128 + 4 + 20 + 224 + 40u*numberOfSections;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfPeHeaders,The following statement contains a magic number: uint sizeOfPeHeaders = 128 + 4 + 20 + 224 + 40u*numberOfSections;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfPeHeaders,The following statement contains a magic number: uint sizeOfPeHeaders = 128 + 4 + 20 + 224 + 40u*numberOfSections;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfPeHeaders,The following statement contains a magic number: uint sizeOfPeHeaders = 128 + 4 + 20 + 224 + 40u*numberOfSections;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfPeHeaders,The following statement contains a magic number: if (this.module.Requires64bits) sizeOfPeHeaders += 16;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfTextSection,The following statement contains a magic number: textSectionLength += 14;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfTextSection,The following statement contains a magic number: textSectionLength += Aligned(this.textDataWriter.BaseStream.Length' 4);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfWin32Resources,The following statement contains a magic number: if (this.win32ResourceWriter.BaseStream.Length > 0)          result += Aligned(this.win32ResourceWriter.BaseStream.Length' 4);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,FillInClrHeader,The following statement contains a magic number: clrHeader.majorRuntimeVersion = 2;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,FillInClrHeader,The following statement contains a magic number: clrHeader.minorRuntimeVersion = 5;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,FillInClrHeader,The following statement contains a magic number: clrHeader.resources.Size = Aligned(this.resourceWriter.BaseStream.Length' 4);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,FillInNtHeader,The following statement contains a magic number: ntHeader.CliHeaderTable.Size = 72;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,FillInNtHeader,The following statement contains a magic number: ntHeader.ImportTable.Size += 13;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,FillInSectionHeaders,The following statement contains a magic number: this.textDataSection.RelativeVirtualAddress = this.textSection.RelativeVirtualAddress+this.textSection.VirtualSize-Aligned(this.textDataWriter.BaseStream.Length' 4);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,FillInSectionHeaders,The following statement contains a magic number: this.textMethodBodySection.RelativeVirtualAddress = this.textSection.RelativeVirtualAddress+(!this.module.Requires64bits ? 8u : 16u)+72;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetBlobIndex,The following statement contains a magic number: byte[] byteArray = new byte[str.Length*2];
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetBlobIndex,The following statement contains a magic number: foreach (char ch in str) {          byteArray[i++] = (byte)(ch & 0xFF);          byteArray[i++] = (byte)(ch >> 8);        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetClrHeaderFlags,The following statement contains a magic number: if (this.module.Requires32bits) result |= 2;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetCustomAttributeTypeCodedIndex,The following statement contains a magic number: if (methodDef != null)          return (this.GetMethodDefIndex(methodDef) << 3)|2;        else          return (this.GetMemberRefIndex(methodReference) << 3)|3;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetCustomAttributeTypeCodedIndex,The following statement contains a magic number: if (methodDef != null)          return (this.GetMethodDefIndex(methodDef) << 3)|2;        else          return (this.GetMemberRefIndex(methodReference) << 3)|3;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetCustomAttributeTypeCodedIndex,The following statement contains a magic number: if (methodDef != null)          return (this.GetMethodDefIndex(methodDef) << 3)|2;        else          return (this.GetMemberRefIndex(methodReference) << 3)|3;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetCustomAttributeTypeCodedIndex,The following statement contains a magic number: if (methodDef != null)          return (this.GetMethodDefIndex(methodDef) << 3)|2;        else          return (this.GetMemberRefIndex(methodReference) << 3)|3;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetDataOffset,The following statement contains a magic number: if (sectionWriter.BaseStream.Position == sectionWriter.BaseStream.Length)          sectionWriter.Align(8);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetImplementationCodedIndex,The following statement contains a magic number: if (aref != null) return (this.GetAssemblyRefIndex(aref)<< 2)|1;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetImplementationCodedIndex,The following statement contains a magic number: if (mref != null) return (this.GetFileRefIndex(mref) << 2)|0;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetManagedResourceOffset,The following statement contains a magic number: this.resourceWriter.Align(8);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetMemberRefParentCodedIndex,The following statement contains a magic number: if (parentTypeDefIndex > 0) {          IFieldReference/*?*/ fieldRef = memberRef as IFieldReference;          if (fieldRef != null) return parentTypeDefIndex << 3;          IMethodReference/*?*/ methodRef = memberRef as IMethodReference;          if (methodRef != null) {            if (methodRef.AcceptsExtraArguments) {              uint methodIndex = 0;              if (this.methodDefIndex.TryGetValue(methodRef.ResolvedMethod' out methodIndex))                return (methodIndex << 3)|3;            }            return parentTypeDefIndex << 3;          }          //TODO: error        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetMemberRefParentCodedIndex,The following statement contains a magic number: if (parentTypeDefIndex > 0) {          IFieldReference/*?*/ fieldRef = memberRef as IFieldReference;          if (fieldRef != null) return parentTypeDefIndex << 3;          IMethodReference/*?*/ methodRef = memberRef as IMethodReference;          if (methodRef != null) {            if (methodRef.AcceptsExtraArguments) {              uint methodIndex = 0;              if (this.methodDefIndex.TryGetValue(methodRef.ResolvedMethod' out methodIndex))                return (methodIndex << 3)|3;            }            return parentTypeDefIndex << 3;          }          //TODO: error        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetMemberRefParentCodedIndex,The following statement contains a magic number: if (parentTypeDefIndex > 0) {          IFieldReference/*?*/ fieldRef = memberRef as IFieldReference;          if (fieldRef != null) return parentTypeDefIndex << 3;          IMethodReference/*?*/ methodRef = memberRef as IMethodReference;          if (methodRef != null) {            if (methodRef.AcceptsExtraArguments) {              uint methodIndex = 0;              if (this.methodDefIndex.TryGetValue(methodRef.ResolvedMethod' out methodIndex))                return (methodIndex << 3)|3;            }            return parentTypeDefIndex << 3;          }          //TODO: error        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetMemberRefParentCodedIndex,The following statement contains a magic number: if (parentTypeDefIndex > 0) {          IFieldReference/*?*/ fieldRef = memberRef as IFieldReference;          if (fieldRef != null) return parentTypeDefIndex << 3;          IMethodReference/*?*/ methodRef = memberRef as IMethodReference;          if (methodRef != null) {            if (methodRef.AcceptsExtraArguments) {              uint methodIndex = 0;              if (this.methodDefIndex.TryGetValue(methodRef.ResolvedMethod' out methodIndex))                return (methodIndex << 3)|3;            }            return parentTypeDefIndex << 3;          }          //TODO: error        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetMemberRefParentCodedIndex,The following statement contains a magic number: if (!IsTypeSpecification(memberRef.ContainingType))          return (this.GetTypeRefIndex(memberRef.ContainingType) << 3)|1;        else          return (this.GetTypeSpecIndex(memberRef.ContainingType) << 3)|4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetMemberRefParentCodedIndex,The following statement contains a magic number: if (!IsTypeSpecification(memberRef.ContainingType))          return (this.GetTypeRefIndex(memberRef.ContainingType) << 3)|1;        else          return (this.GetTypeSpecIndex(memberRef.ContainingType) << 3)|4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetMemberRefParentCodedIndex,The following statement contains a magic number: if (!IsTypeSpecification(memberRef.ContainingType))          return (this.GetTypeRefIndex(memberRef.ContainingType) << 3)|1;        else          return (this.GetTypeSpecIndex(memberRef.ContainingType) << 3)|4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetResolutionScopeCodedIndex,The following statement contains a magic number: return (this.GetTypeRefIndex(typeReference) << 2) | 3;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetResolutionScopeCodedIndex,The following statement contains a magic number: return (this.GetTypeRefIndex(typeReference) << 2) | 3;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetResolutionScopeCodedIndex,The following statement contains a magic number: if (aref != null) return (this.GetAssemblyRefIndex(aref) << 2) | 2;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetResolutionScopeCodedIndex,The following statement contains a magic number: if (aref != null) return (this.GetAssemblyRefIndex(aref) << 2) | 2;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetResolutionScopeCodedIndex,The following statement contains a magic number: if (mref != null) return (this.GetModuleRefIndex(mref) << 2) | 1;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetTypeDefOrRefCodedIndex,The following statement contains a magic number: if (this.typeDefIndex.TryGetValue(typeReference.InternedKey' out typeDefIndex))          return (typeDefIndex << 2) | 0;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetTypeDefOrRefCodedIndex,The following statement contains a magic number: if (!IsTypeSpecification(typeReference))          return (this.GetTypeRefIndex(typeReference) << 2) | 1;        else          return (this.GetTypeSpecIndex(typeReference) << 2) | 2;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetTypeDefOrRefCodedIndex,The following statement contains a magic number: if (!IsTypeSpecification(typeReference))          return (this.GetTypeRefIndex(typeReference) << 2) | 1;        else          return (this.GetTypeSpecIndex(typeReference) << 2) | 2;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetTypeDefOrRefCodedIndex,The following statement contains a magic number: if (!IsTypeSpecification(typeReference))          return (this.GetTypeRefIndex(typeReference) << 2) | 1;        else          return (this.GetTypeSpecIndex(typeReference) << 2) | 2;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetUserStringToken,The following statement contains a magic number: if (!this.userStringIndex.TryGetValue(str' out index)) {          Debug.Assert(!this.streamsAreComplete);          index = this.userStringWriter.BaseStream.Position;          this.userStringIndex.Add(str' index);          this.userStringWriter.WriteCompressedUInt((uint)str.Length*2+1);          this.userStringWriter.WriteChars(str.ToCharArray());          //Write out a trailing byte indicating if the string is really quite simple          byte stringKind = 0;          foreach (char ch in str) {            if (ch >= 0x7F) {              stringKind = 1;            } else {              switch ((int)ch) {                case 0x1:                case 0x2:                case 0x3:                case 0x4:                case 0x5:                case 0x6:                case 0x7:                case 0x8:                case 0xE:                case 0xF:                case 0x10:                case 0x11:                case 0x12:                case 0x13:                case 0x14:                case 0x15:                case 0x16:                case 0x17:                case 0x18:                case 0x19:                case 0x1A:                case 0x1B:                case 0x1C:                case 0x1D:                case 0x1E:                case 0x1F:                case 0x27:                case 0x2D:                  stringKind = 1;                  break;                default:                  continue;              }            }            break;          }          this.userStringWriter.WriteByte(stringKind);        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeGeneralMetadataHeader,The following statement contains a magic number: writer.WriteUint(12);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeGeneralMetadataHeader,The following statement contains a magic number: for (int i = 0; i < 12 && i < n; i++) writer.WriteByte((byte)targetRuntimeVersion[i]);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeGeneralMetadataHeader,The following statement contains a magic number: for (int i = n; i < 12; i++) writer.WriteByte(0);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeGeneralMetadataHeader,The following statement contains a magic number: writer.WriteUshort(5);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeGeneralMetadataHeader,The following statement contains a magic number: uint offsetFromStartOfMetadata = 108;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeGeneralMetadataHeader,The following statement contains a magic number: SerializeStreamHeader(ref offsetFromStartOfMetadata' 16' "#GUID"' writer);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeStreamHeader,The following statement contains a magic number: uint sizeOfStreamHeader = 8+Aligned((uint)streamName.Length+1' 4);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeStreamHeader,The following statement contains a magic number: uint sizeOfStreamHeader = 8+Aligned((uint)streamName.Length+1' 4);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeStreamHeader,The following statement contains a magic number: writer.WriteUint(Aligned(sizeOfStreamHeap' 4));
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeStreamHeader,The following statement contains a magic number: for (uint i = 8+(uint)streamName.Length; i < sizeOfStreamHeader; i++) writer.WriteByte(0);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeMetadata,The following statement contains a magic number: this.stringWriter.Align(4);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeMetadata,The following statement contains a magic number: this.userStringWriter.Align(4);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeMetadata,The following statement contains a magic number: this.blobWriter.Align(4);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeMetadataTables,The following statement contains a magic number: writer.Align(4);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.blobWriter.BaseStream.Length > ushort.MaxValue)          this.blobIndexSize = 4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit(16-3' TableIndices.Method' TableIndices.MemberRef))          this.customAttributeTypeCodedIndexSize = 4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit(16-3' TableIndices.Method' TableIndices.MemberRef))          this.customAttributeTypeCodedIndexSize = 4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit(16-3' TableIndices.Method' TableIndices.MemberRef))          this.customAttributeTypeCodedIndexSize = 4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit(16-2' TableIndices.Method' TableIndices.TypeDef))          this.declSecurityCodedIndexSize = 4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit(16-2' TableIndices.Method' TableIndices.TypeDef))          this.declSecurityCodedIndexSize = 4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit(16-2' TableIndices.Method' TableIndices.TypeDef))          this.declSecurityCodedIndexSize = 4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit(16' TableIndices.Event))          this.eventDefIndexSize = 4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit(16' TableIndices.Event))          this.eventDefIndexSize = 4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit(16' TableIndices.Field))          this.fieldDefIndexSize = 4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit(16' TableIndices.Field))          this.fieldDefIndexSize = 4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit(16' TableIndices.GenericParam))          this.genericParamIndexSize = 4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit(16' TableIndices.GenericParam))          this.genericParamIndexSize = 4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit(16-2' TableIndices.Field' TableIndices.Param' TableIndices.Property))          this.hasConstantCodedIndexSize = 4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit(16-2' TableIndices.Field' TableIndices.Param' TableIndices.Property))          this.hasConstantCodedIndexSize = 4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit(16-2' TableIndices.Field' TableIndices.Param' TableIndices.Property))          this.hasConstantCodedIndexSize = 4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit(16-5' TableIndices.Method' TableIndices.Field' TableIndices.TypeRef' TableIndices.TypeDef' TableIndices.Param' TableIndices.InterfaceImpl'          TableIndices.MemberRef' TableIndices.Module' TableIndices.DeclSecurity' TableIndices.Property' TableIndices.Event' TableIndices.StandAloneSig'          TableIndices.ModuleRef' TableIndices.TypeSpec' TableIndices.Assembly' TableIndices.AssemblyRef' TableIndices.File' TableIndices.ExportedType' TableIndices.ManifestResource))          this.hasCustomAttributeCodedIndexSize = 4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit(16-5' TableIndices.Method' TableIndices.Field' TableIndices.TypeRef' TableIndices.TypeDef' TableIndices.Param' TableIndices.InterfaceImpl'          TableIndices.MemberRef' TableIndices.Module' TableIndices.DeclSecurity' TableIndices.Property' TableIndices.Event' TableIndices.StandAloneSig'          TableIndices.ModuleRef' TableIndices.TypeSpec' TableIndices.Assembly' TableIndices.AssemblyRef' TableIndices.File' TableIndices.ExportedType' TableIndices.ManifestResource))          this.hasCustomAttributeCodedIndexSize = 4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit(16-5' TableIndices.Method' TableIndices.Field' TableIndices.TypeRef' TableIndices.TypeDef' TableIndices.Param' TableIndices.InterfaceImpl'          TableIndices.MemberRef' TableIndices.Module' TableIndices.DeclSecurity' TableIndices.Property' TableIndices.Event' TableIndices.StandAloneSig'          TableIndices.ModuleRef' TableIndices.TypeSpec' TableIndices.Assembly' TableIndices.AssemblyRef' TableIndices.File' TableIndices.ExportedType' TableIndices.ManifestResource))          this.hasCustomAttributeCodedIndexSize = 4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit(16-1' TableIndices.Field' TableIndices.Param))          this.hasFieldMarshallCodedIndexSize = 4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit(16-1' TableIndices.Field' TableIndices.Param))          this.hasFieldMarshallCodedIndexSize = 4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit(16-1' TableIndices.Event' TableIndices.Property))          this.hasSemanticsCodedIndexSize = 4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit(16-1' TableIndices.Event' TableIndices.Property))          this.hasSemanticsCodedIndexSize = 4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit(16-2' TableIndices.File' TableIndices.AssemblyRef' TableIndices.ExportedType))          this.implementationCodedIndexSize = 4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit(16-2' TableIndices.File' TableIndices.AssemblyRef' TableIndices.ExportedType))          this.implementationCodedIndexSize = 4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit(16-2' TableIndices.File' TableIndices.AssemblyRef' TableIndices.ExportedType))          this.implementationCodedIndexSize = 4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit(16-1' TableIndices.Field' TableIndices.Method))          this.memberForwardedCodedIndexSize = 4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit(16-1' TableIndices.Field' TableIndices.Method))          this.memberForwardedCodedIndexSize = 4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit(16-3' TableIndices.TypeDef' TableIndices.TypeRef' TableIndices.ModuleRef' TableIndices.Method' TableIndices.TypeSpec))          this.memberRefParentCodedIndexSize = 4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit(16-3' TableIndices.TypeDef' TableIndices.TypeRef' TableIndices.ModuleRef' TableIndices.Method' TableIndices.TypeSpec))          this.memberRefParentCodedIndexSize = 4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit(16-3' TableIndices.TypeDef' TableIndices.TypeRef' TableIndices.ModuleRef' TableIndices.Method' TableIndices.TypeSpec))          this.memberRefParentCodedIndexSize = 4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit(16' TableIndices.Method))          this.methodDefIndexSize = 4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit(16' TableIndices.Method))          this.methodDefIndexSize = 4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit(16-1' TableIndices.Method' TableIndices.MemberRef))          this.methodDefOrRefCodedIndexSize = 4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit(16-1' TableIndices.Method' TableIndices.MemberRef))          this.methodDefOrRefCodedIndexSize = 4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit(16' TableIndices.ModuleRef))          this.moduleRefIndexSize = 4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit(16' TableIndices.ModuleRef))          this.moduleRefIndexSize = 4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit(16' TableIndices.Param))          this.parameterIndexSize = 4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit(16' TableIndices.Param))          this.parameterIndexSize = 4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit(16' TableIndices.Property))          this.propertyDefIndexSize = 4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit(16' TableIndices.Property))          this.propertyDefIndexSize = 4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit(16-2' TableIndices.Module' TableIndices.ModuleRef' TableIndices.AssemblyRef' TableIndices.TypeRef))          this.resolutionScopeCodedIndexSize = 4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit(16-2' TableIndices.Module' TableIndices.ModuleRef' TableIndices.AssemblyRef' TableIndices.TypeRef))          this.resolutionScopeCodedIndexSize = 4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit(16-2' TableIndices.Module' TableIndices.ModuleRef' TableIndices.AssemblyRef' TableIndices.TypeRef))          this.resolutionScopeCodedIndexSize = 4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.stringWriter.BaseStream.Length >= ushort.MaxValue)          this.stringIndexSize = 4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit(16' TableIndices.TypeDef))          this.typeDefIndexSize = 4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit(16' TableIndices.TypeDef))          this.typeDefIndexSize = 4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit(16-2' TableIndices.TypeDef' TableIndices.TypeRef' TableIndices.TypeSpec))          this.typeDefOrRefCodedIndexSize = 4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit(16-2' TableIndices.TypeDef' TableIndices.TypeRef' TableIndices.TypeSpec))          this.typeDefOrRefCodedIndexSize = 4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit(16-2' TableIndices.TypeDef' TableIndices.TypeRef' TableIndices.TypeSpec))          this.typeDefOrRefCodedIndexSize = 4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit(16-1' TableIndices.TypeDef' TableIndices.Method))          this.typeOrMethodDefCodedIndexSize = 4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit(16-1' TableIndices.TypeDef' TableIndices.Method))          this.typeOrMethodDefCodedIndexSize = 4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,PopulateConstantTableRows,The following statement contains a magic number: foreach (IFieldDefinition fieldDef in this.fieldDefList) {          fieldDefIndex++;          if (fieldDef.CompileTimeValue == Dummy.Constant) continue;          ConstantRow r = new ConstantRow();          r.Type = GetTypeCodeByteFor(fieldDef.CompileTimeValue.Value);          r.Parent = fieldDefIndex<<2;          r.Value = this.GetBlobIndex(fieldDef.CompileTimeValue.Value);          this.constantTable.Add(r);        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,PopulateConstantTableRows,The following statement contains a magic number: foreach (IParameterDefinition parDef in this.parameterDefList) {          parameterDefIndex++;          if (!parDef.HasDefaultValue) continue;          ConstantRow r = new ConstantRow();          r.Type = GetTypeCodeByteFor(parDef.DefaultValue.Value);          r.Parent = (parameterDefIndex << 2)|1;          r.Value = this.GetBlobIndex(parDef.DefaultValue.Value);          this.constantTable.Add(r);        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,PopulateConstantTableRows,The following statement contains a magic number: foreach (IPropertyDefinition propDef in this.propertyDefList) {          propertyDefIndex++;          if (!propDef.HasDefaultValue) continue;          ConstantRow r = new ConstantRow();          r.Type = GetTypeCodeByteFor(propDef.DefaultValue.Value);          r.Parent = (propertyDefIndex << 2)|2;          r.Value = this.GetBlobIndex(propDef.DefaultValue.Value);          this.constantTable.Add(r);        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,PopulateConstantTableRows,The following statement contains a magic number: foreach (IPropertyDefinition propDef in this.propertyDefList) {          propertyDefIndex++;          if (!propDef.HasDefaultValue) continue;          ConstantRow r = new ConstantRow();          r.Type = GetTypeCodeByteFor(propDef.DefaultValue.Value);          r.Parent = (propertyDefIndex << 2)|2;          r.Value = this.GetBlobIndex(propDef.DefaultValue.Value);          this.constantTable.Add(r);        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,PopulateCustomAttributeTableRows,The following statement contains a magic number: if (assembly != null) this.AddAssemblyAttributesToTable(assembly' 14);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,PopulateCustomAttributeTableRows,The following statement contains a magic number: this.AddCustomAttributesToTable(this.typeDefList' 3);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,PopulateCustomAttributeTableRows,The following statement contains a magic number: this.AddCustomAttributesToTable(this.parameterDefList' 4);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,PopulateCustomAttributeTableRows,The following statement contains a magic number: this.AddModuleAttributesToTable(this.module' 7);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,PopulateCustomAttributeTableRows,The following statement contains a magic number: this.AddCustomAttributesToTable(this.propertyDefList' 9);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,PopulateCustomAttributeTableRows,The following statement contains a magic number: this.AddCustomAttributesToTable(this.eventDefList' 10);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,PopulateCustomAttributeTableRows,The following statement contains a magic number: this.AddCustomAttributesToTable(new List<IModuleReference>(this.module.ModuleReferences)' 12);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,PopulateCustomAttributeTableRows,The following statement contains a magic number: this.AddCustomAttributesToTable(sortedGenericParameterList' 19);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,AddAssemblyAttributesToTable,The following statement contains a magic number: r.Parent = (1<<5)|tag;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,AddModuleAttributesToTable,The following statement contains a magic number: r.Parent = (1<<5)|tag;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,AddCustomAttributesToTable,The following statement contains a magic number: foreach (ParentType parent in parentList) {          parentIndex++;          CustomAttributeRow r = new CustomAttributeRow();          r.Parent = (parentIndex<<5)|tag;          foreach (ICustomAttribute customAttribute in parent.Attributes) {            if (customAttribute.Constructor == Dummy.MethodReference) {              //TODO: error            }            r.Type = this.GetCustomAttributeTypeCodedIndex(customAttribute.Constructor);            r.Value = this.GetCustomAttributeSignatureIndex(customAttribute);            r.OriginalPosition = this.customAttributeTable.Count;            this.customAttributeTable.Add(r);          }        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,PopulateDeclSecurityTableRows,The following statement contains a magic number: if (assembly != null)          this.PopulateDeclSecurityTableRowsFor((1 << 2)|2' assembly.SecurityAttributes);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,PopulateDeclSecurityTableRows,The following statement contains a magic number: if (assembly != null)          this.PopulateDeclSecurityTableRowsFor((1 << 2)|2' assembly.SecurityAttributes);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,PopulateDeclSecurityTableRows,The following statement contains a magic number: foreach (ITypeDefinition typeDef in this.typeDefList) {          typeDefIndex++;          if (!typeDef.HasDeclarativeSecurity) continue;          this.PopulateDeclSecurityTableRowsFor(typeDefIndex << 2' typeDef.SecurityAttributes);        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,PopulateDeclSecurityTableRows,The following statement contains a magic number: foreach (IMethodDefinition methodDef in this.methodDefList) {          methodDefIndex++;          if (!methodDef.HasDeclarativeSecurity) continue;          this.PopulateDeclSecurityTableRowsFor((methodDefIndex << 2)|1' methodDef.SecurityAttributes);        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,PopulateExportedTypeTableRows,The following statement contains a magic number: foreach (IAliasForType alias in assembly.ExportedTypes) {          ITypeReference exportedType = alias.AliasedType;          INestedTypeReference/*?*/ neRef = null;          INamespaceTypeReference/*?*/ nsRef = null;          ExportedTypeRow r = new ExportedTypeRow();          r.TypeDefId = this.GetExternalTypeToken(exportedType as ITypeDefinition);          if ((nsRef = exportedType as INamespaceTypeReference) != null) {            r.Flags = TypeFlags.PublicAccess;            r.TypeName = this.GetStringIndex(GetMangledName(nsRef));            INestedUnitNamespaceReference/*?*/ nestedUnitNamespaceReference = nsRef.ContainingUnitNamespace as INestedUnitNamespaceReference;            if (nestedUnitNamespaceReference == null)              r.TypeNamespace = StringIdx.Empty;            else              r.TypeNamespace = this.GetStringIndex(TypeHelper.GetNamespaceName(nestedUnitNamespaceReference' NameFormattingOptions.None));            r.Implementation = this.GetImplementationCodedIndex(nsRef);            if ((r.Implementation & 1) == 1)              r.Flags = TypeFlags.PrivateAccess|TypeFlags.ForwarderImplementation;          } else if ((neRef = exportedType as INestedTypeReference) != null) {            r.Flags = TypeFlags.NestedPublicAccess;            r.TypeName = this.GetStringIndex(GetMangledName(neRef));            r.TypeNamespace = StringIdx.Empty;            uint ci = this.GetExportedTypeIndex(neRef.ContainingType);            r.Implementation = (ci<<2)|2;            var parentFlags = this.exportedTypeTable[((int)ci)-1].Flags;            if (parentFlags == TypeFlags.PrivateAccess || (parentFlags & TypeFlags.ForwarderImplementation) != 0)              r.Flags = TypeFlags.PrivateAccess;          } else {            //TODO: error            continue;          }          this.exportedTypeTable.Add(r);        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,PopulateExportedTypeTableRows,The following statement contains a magic number: foreach (IAliasForType alias in assembly.ExportedTypes) {          ITypeReference exportedType = alias.AliasedType;          INestedTypeReference/*?*/ neRef = null;          INamespaceTypeReference/*?*/ nsRef = null;          ExportedTypeRow r = new ExportedTypeRow();          r.TypeDefId = this.GetExternalTypeToken(exportedType as ITypeDefinition);          if ((nsRef = exportedType as INamespaceTypeReference) != null) {            r.Flags = TypeFlags.PublicAccess;            r.TypeName = this.GetStringIndex(GetMangledName(nsRef));            INestedUnitNamespaceReference/*?*/ nestedUnitNamespaceReference = nsRef.ContainingUnitNamespace as INestedUnitNamespaceReference;            if (nestedUnitNamespaceReference == null)              r.TypeNamespace = StringIdx.Empty;            else              r.TypeNamespace = this.GetStringIndex(TypeHelper.GetNamespaceName(nestedUnitNamespaceReference' NameFormattingOptions.None));            r.Implementation = this.GetImplementationCodedIndex(nsRef);            if ((r.Implementation & 1) == 1)              r.Flags = TypeFlags.PrivateAccess|TypeFlags.ForwarderImplementation;          } else if ((neRef = exportedType as INestedTypeReference) != null) {            r.Flags = TypeFlags.NestedPublicAccess;            r.TypeName = this.GetStringIndex(GetMangledName(neRef));            r.TypeNamespace = StringIdx.Empty;            uint ci = this.GetExportedTypeIndex(neRef.ContainingType);            r.Implementation = (ci<<2)|2;            var parentFlags = this.exportedTypeTable[((int)ci)-1].Flags;            if (parentFlags == TypeFlags.PrivateAccess || (parentFlags & TypeFlags.ForwarderImplementation) != 0)              r.Flags = TypeFlags.PrivateAccess;          } else {            //TODO: error            continue;          }          this.exportedTypeTable.Add(r);        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,PopulateManifestResourceTableRows,The following statement contains a magic number: foreach (IResourceReference resourceReference in assembly.Resources) {          ManifestResourceRow r = new ManifestResourceRow();          r.Offset = this.GetManagedResourceOffset(resourceReference);          r.Flags = resourceReference.Resource.IsPublic ? 1u : 2u;          r.Name = this.GetStringIndex(resourceReference.Name.Value);          if (resourceReference.Resource.IsInExternalFile)            r.Implementation = this.GetFileRefIndex(resourceReference.Resource.ExternalFile) << 2;          else if (resourceReference.DefiningAssembly.AssemblyIdentity.Equals(assembly.AssemblyIdentity))            r.Implementation = 0;          else            r.Implementation = (this.GetAssemblyRefIndex(resourceReference.DefiningAssembly) << 2)|1;          this.manifestResourceTable.Add(r);        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,PopulateManifestResourceTableRows,The following statement contains a magic number: foreach (IResourceReference resourceReference in assembly.Resources) {          ManifestResourceRow r = new ManifestResourceRow();          r.Offset = this.GetManagedResourceOffset(resourceReference);          r.Flags = resourceReference.Resource.IsPublic ? 1u : 2u;          r.Name = this.GetStringIndex(resourceReference.Name.Value);          if (resourceReference.Resource.IsInExternalFile)            r.Implementation = this.GetFileRefIndex(resourceReference.Resource.ExternalFile) << 2;          else if (resourceReference.DefiningAssembly.AssemblyIdentity.Equals(assembly.AssemblyIdentity))            r.Implementation = 0;          else            r.Implementation = (this.GetAssemblyRefIndex(resourceReference.DefiningAssembly) << 2)|1;          this.manifestResourceTable.Add(r);        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeTablesHeader,The following statement contains a magic number: if (this.stringIndexSize > 2) heapSizes |= 0x01;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeTablesHeader,The following statement contains a magic number: if (this.blobIndexSize > 2) heapSizes |= 0x04;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfTablesHeader,The following statement contains a magic number: uint result = 4+4+8+8;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfTablesHeader,The following statement contains a magic number: uint result = 4+4+8+8;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfTablesHeader,The following statement contains a magic number: uint result = 4+4+8+8;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfTablesHeader,The following statement contains a magic number: uint result = 4+4+8+8;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,ComputeSizeOfTablesHeader,The following statement contains a magic number: foreach (uint tableSize in this.tableSizes)          if (tableSize > 0) result += 4;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeIndex,The following statement contains a magic number: if (indexSize == 2)          writer.WriteUshort((ushort)index);        else          writer.WriteUint(index);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeMethodBody,The following statement contains a magic number: if (il.Length < 64 && methodBody.MaxStack <= 8 && localVariableSignatureToken == 0 && numberOfExceptionHandlers == 0) {          this.methodBodyIndex[methodBody.MethodDefinition] = this.methodStream.Position;          writer.WriteByte((byte)((il.Length << 2) | 2));        } else {          writer.Align(4);          this.methodBodyIndex[methodBody.MethodDefinition] = this.methodStream.Position;          ushort flags = (3 << 12) | 0x3;          if (numberOfExceptionHandlers > 0) flags |= 0x08;          if (methodBody.LocalsAreZeroed) flags |= 0x10;          writer.WriteUshort(flags);          writer.WriteUshort(methodBody.MaxStack);          writer.WriteUint((uint)il.Length);          writer.WriteUint(localVariableSignatureToken);        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeMethodBody,The following statement contains a magic number: if (il.Length < 64 && methodBody.MaxStack <= 8 && localVariableSignatureToken == 0 && numberOfExceptionHandlers == 0) {          this.methodBodyIndex[methodBody.MethodDefinition] = this.methodStream.Position;          writer.WriteByte((byte)((il.Length << 2) | 2));        } else {          writer.Align(4);          this.methodBodyIndex[methodBody.MethodDefinition] = this.methodStream.Position;          ushort flags = (3 << 12) | 0x3;          if (numberOfExceptionHandlers > 0) flags |= 0x08;          if (methodBody.LocalsAreZeroed) flags |= 0x10;          writer.WriteUshort(flags);          writer.WriteUshort(methodBody.MaxStack);          writer.WriteUint((uint)il.Length);          writer.WriteUint(localVariableSignatureToken);        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeMethodBody,The following statement contains a magic number: if (il.Length < 64 && methodBody.MaxStack <= 8 && localVariableSignatureToken == 0 && numberOfExceptionHandlers == 0) {          this.methodBodyIndex[methodBody.MethodDefinition] = this.methodStream.Position;          writer.WriteByte((byte)((il.Length << 2) | 2));        } else {          writer.Align(4);          this.methodBodyIndex[methodBody.MethodDefinition] = this.methodStream.Position;          ushort flags = (3 << 12) | 0x3;          if (numberOfExceptionHandlers > 0) flags |= 0x08;          if (methodBody.LocalsAreZeroed) flags |= 0x10;          writer.WriteUshort(flags);          writer.WriteUshort(methodBody.MaxStack);          writer.WriteUint((uint)il.Length);          writer.WriteUint(localVariableSignatureToken);        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeMethodBody,The following statement contains a magic number: if (il.Length < 64 && methodBody.MaxStack <= 8 && localVariableSignatureToken == 0 && numberOfExceptionHandlers == 0) {          this.methodBodyIndex[methodBody.MethodDefinition] = this.methodStream.Position;          writer.WriteByte((byte)((il.Length << 2) | 2));        } else {          writer.Align(4);          this.methodBodyIndex[methodBody.MethodDefinition] = this.methodStream.Position;          ushort flags = (3 << 12) | 0x3;          if (numberOfExceptionHandlers > 0) flags |= 0x08;          if (methodBody.LocalsAreZeroed) flags |= 0x10;          writer.WriteUshort(flags);          writer.WriteUshort(methodBody.MaxStack);          writer.WriteUint((uint)il.Length);          writer.WriteUint(localVariableSignatureToken);        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeMethodBody,The following statement contains a magic number: if (il.Length < 64 && methodBody.MaxStack <= 8 && localVariableSignatureToken == 0 && numberOfExceptionHandlers == 0) {          this.methodBodyIndex[methodBody.MethodDefinition] = this.methodStream.Position;          writer.WriteByte((byte)((il.Length << 2) | 2));        } else {          writer.Align(4);          this.methodBodyIndex[methodBody.MethodDefinition] = this.methodStream.Position;          ushort flags = (3 << 12) | 0x3;          if (numberOfExceptionHandlers > 0) flags |= 0x08;          if (methodBody.LocalsAreZeroed) flags |= 0x10;          writer.WriteUshort(flags);          writer.WriteUshort(methodBody.MaxStack);          writer.WriteUint((uint)il.Length);          writer.WriteUint(localVariableSignatureToken);        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeMethodBody,The following statement contains a magic number: if (il.Length < 64 && methodBody.MaxStack <= 8 && localVariableSignatureToken == 0 && numberOfExceptionHandlers == 0) {          this.methodBodyIndex[methodBody.MethodDefinition] = this.methodStream.Position;          writer.WriteByte((byte)((il.Length << 2) | 2));        } else {          writer.Align(4);          this.methodBodyIndex[methodBody.MethodDefinition] = this.methodStream.Position;          ushort flags = (3 << 12) | 0x3;          if (numberOfExceptionHandlers > 0) flags |= 0x08;          if (methodBody.LocalsAreZeroed) flags |= 0x10;          writer.WriteUshort(flags);          writer.WriteUshort(methodBody.MaxStack);          writer.WriteUint((uint)il.Length);          writer.WriteUint(localVariableSignatureToken);        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeMethodBody,The following statement contains a magic number: if (il.Length < 64 && methodBody.MaxStack <= 8 && localVariableSignatureToken == 0 && numberOfExceptionHandlers == 0) {          this.methodBodyIndex[methodBody.MethodDefinition] = this.methodStream.Position;          writer.WriteByte((byte)((il.Length << 2) | 2));        } else {          writer.Align(4);          this.methodBodyIndex[methodBody.MethodDefinition] = this.methodStream.Position;          ushort flags = (3 << 12) | 0x3;          if (numberOfExceptionHandlers > 0) flags |= 0x08;          if (methodBody.LocalsAreZeroed) flags |= 0x10;          writer.WriteUshort(flags);          writer.WriteUshort(methodBody.MaxStack);          writer.WriteUint((uint)il.Length);          writer.WriteUint(localVariableSignatureToken);        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeReferenceToFirstMethod,The following statement contains a magic number: cmw.WriteByte(4);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeReferenceToFirstMethod,The following statement contains a magic number: cmw.WriteByte(2);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeReferenceToFirstMethod,The following statement contains a magic number: cmw.Align(4);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeReferenceToFirstMethod,The following statement contains a magic number: cmw.WriteUint(12);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeReferenceToLastMethodWithUsingInfo,The following statement contains a magic number: cmw.WriteByte(4);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeReferenceToLastMethodWithUsingInfo,The following statement contains a magic number: cmw.Align(4);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeReferenceToLastMethodWithUsingInfo,The following statement contains a magic number: cmw.WriteUint(12);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeIteratorLocalScopes,The following statement contains a magic number: cmw.WriteByte(4);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeIteratorLocalScopes,The following statement contains a magic number: cmw.WriteByte(3);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeIteratorLocalScopes,The following statement contains a magic number: cmw.Align(4);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeIteratorLocalScopes,The following statement contains a magic number: cmw.WriteUint(12+numberOfScopes*8);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeIteratorLocalScopes,The following statement contains a magic number: cmw.WriteUint(12+numberOfScopes*8);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeCustomDebugMetadata,The following statement contains a magic number: cmw.WriteByte(4);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeCustomDebugMetadata,The following statement contains a magic number: cmw.Align(4);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeNamespaceScopeMetadata,The following statement contains a magic number: cmw.WriteByte(4);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeNamespaceScopeMetadata,The following statement contains a magic number: cmw.Align(4);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeNamespaceScopeMetadata,The following statement contains a magic number: if (usingCounts.Count > 0) {          cmw.WriteUint(streamLength = Aligned((uint)usingCounts.Count*2+10' 4));          cmw.WriteUshort((ushort)usingCounts.Count);          foreach (ushort uc in usingCounts) cmw.WriteUshort(uc);        } else {          cmw.WriteUint(streamLength = 12);          cmw.WriteUshort(1);          cmw.WriteUshort(0);        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeNamespaceScopeMetadata,The following statement contains a magic number: if (usingCounts.Count > 0) {          cmw.WriteUint(streamLength = Aligned((uint)usingCounts.Count*2+10' 4));          cmw.WriteUshort((ushort)usingCounts.Count);          foreach (ushort uc in usingCounts) cmw.WriteUshort(uc);        } else {          cmw.WriteUint(streamLength = 12);          cmw.WriteUshort(1);          cmw.WriteUshort(0);        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeNamespaceScopeMetadata,The following statement contains a magic number: if (usingCounts.Count > 0) {          cmw.WriteUint(streamLength = Aligned((uint)usingCounts.Count*2+10' 4));          cmw.WriteUshort((ushort)usingCounts.Count);          foreach (ushort uc in usingCounts) cmw.WriteUshort(uc);        } else {          cmw.WriteUint(streamLength = 12);          cmw.WriteUshort(1);          cmw.WriteUshort(0);        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeNamespaceScopeMetadata,The following statement contains a magic number: if (usingCounts.Count > 0) {          cmw.WriteUint(streamLength = Aligned((uint)usingCounts.Count*2+10' 4));          cmw.WriteUshort((ushort)usingCounts.Count);          foreach (ushort uc in usingCounts) cmw.WriteUshort(uc);        } else {          cmw.WriteUint(streamLength = 12);          cmw.WriteUshort(1);          cmw.WriteUshort(0);        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeNamespaceScopeMetadata,The following statement contains a magic number: cmw.Align(4);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeReferenceToIteratorClass,The following statement contains a magic number: foreach (IOperation operation in methodBody.Operations) {          if (operation.OperationCode == OperationCode.Newobj) {            IMethodReference/*?*/ consRef = operation.Value as IMethodReference;            if (consRef != null && consRef.ContainingType is INamedEntity) {              string iteratorClassName = ((INamedEntity)consRef.ContainingType).Name.Value;              MemoryStream customMetadata = new MemoryStream();              BinaryWriter cmw = new BinaryWriter(customMetadata' true);              cmw.WriteByte(4); //version              cmw.WriteByte(4); //kind: ForwardIterator              cmw.Align(4);              uint length = 10+(uint)iteratorClassName.Length*2;              while (length % 4 > 0) length++;              cmw.WriteUint(length);              cmw.WriteString(iteratorClassName' true);              cmw.Align(4);              this.customDebugMetadataForCurrentMethod.Add(customMetadata);              return;            }          }        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeReferenceToIteratorClass,The following statement contains a magic number: foreach (IOperation operation in methodBody.Operations) {          if (operation.OperationCode == OperationCode.Newobj) {            IMethodReference/*?*/ consRef = operation.Value as IMethodReference;            if (consRef != null && consRef.ContainingType is INamedEntity) {              string iteratorClassName = ((INamedEntity)consRef.ContainingType).Name.Value;              MemoryStream customMetadata = new MemoryStream();              BinaryWriter cmw = new BinaryWriter(customMetadata' true);              cmw.WriteByte(4); //version              cmw.WriteByte(4); //kind: ForwardIterator              cmw.Align(4);              uint length = 10+(uint)iteratorClassName.Length*2;              while (length % 4 > 0) length++;              cmw.WriteUint(length);              cmw.WriteString(iteratorClassName' true);              cmw.Align(4);              this.customDebugMetadataForCurrentMethod.Add(customMetadata);              return;            }          }        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeReferenceToIteratorClass,The following statement contains a magic number: foreach (IOperation operation in methodBody.Operations) {          if (operation.OperationCode == OperationCode.Newobj) {            IMethodReference/*?*/ consRef = operation.Value as IMethodReference;            if (consRef != null && consRef.ContainingType is INamedEntity) {              string iteratorClassName = ((INamedEntity)consRef.ContainingType).Name.Value;              MemoryStream customMetadata = new MemoryStream();              BinaryWriter cmw = new BinaryWriter(customMetadata' true);              cmw.WriteByte(4); //version              cmw.WriteByte(4); //kind: ForwardIterator              cmw.Align(4);              uint length = 10+(uint)iteratorClassName.Length*2;              while (length % 4 > 0) length++;              cmw.WriteUint(length);              cmw.WriteString(iteratorClassName' true);              cmw.Align(4);              this.customDebugMetadataForCurrentMethod.Add(customMetadata);              return;            }          }        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeReferenceToIteratorClass,The following statement contains a magic number: foreach (IOperation operation in methodBody.Operations) {          if (operation.OperationCode == OperationCode.Newobj) {            IMethodReference/*?*/ consRef = operation.Value as IMethodReference;            if (consRef != null && consRef.ContainingType is INamedEntity) {              string iteratorClassName = ((INamedEntity)consRef.ContainingType).Name.Value;              MemoryStream customMetadata = new MemoryStream();              BinaryWriter cmw = new BinaryWriter(customMetadata' true);              cmw.WriteByte(4); //version              cmw.WriteByte(4); //kind: ForwardIterator              cmw.Align(4);              uint length = 10+(uint)iteratorClassName.Length*2;              while (length % 4 > 0) length++;              cmw.WriteUint(length);              cmw.WriteString(iteratorClassName' true);              cmw.Align(4);              this.customDebugMetadataForCurrentMethod.Add(customMetadata);              return;            }          }        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeReferenceToIteratorClass,The following statement contains a magic number: foreach (IOperation operation in methodBody.Operations) {          if (operation.OperationCode == OperationCode.Newobj) {            IMethodReference/*?*/ consRef = operation.Value as IMethodReference;            if (consRef != null && consRef.ContainingType is INamedEntity) {              string iteratorClassName = ((INamedEntity)consRef.ContainingType).Name.Value;              MemoryStream customMetadata = new MemoryStream();              BinaryWriter cmw = new BinaryWriter(customMetadata' true);              cmw.WriteByte(4); //version              cmw.WriteByte(4); //kind: ForwardIterator              cmw.Align(4);              uint length = 10+(uint)iteratorClassName.Length*2;              while (length % 4 > 0) length++;              cmw.WriteUint(length);              cmw.WriteString(iteratorClassName' true);              cmw.Align(4);              this.customDebugMetadataForCurrentMethod.Add(customMetadata);              return;            }          }        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeReferenceToIteratorClass,The following statement contains a magic number: foreach (IOperation operation in methodBody.Operations) {          if (operation.OperationCode == OperationCode.Newobj) {            IMethodReference/*?*/ consRef = operation.Value as IMethodReference;            if (consRef != null && consRef.ContainingType is INamedEntity) {              string iteratorClassName = ((INamedEntity)consRef.ContainingType).Name.Value;              MemoryStream customMetadata = new MemoryStream();              BinaryWriter cmw = new BinaryWriter(customMetadata' true);              cmw.WriteByte(4); //version              cmw.WriteByte(4); //kind: ForwardIterator              cmw.Align(4);              uint length = 10+(uint)iteratorClassName.Length*2;              while (length % 4 > 0) length++;              cmw.WriteUint(length);              cmw.WriteString(iteratorClassName' true);              cmw.Align(4);              this.customDebugMetadataForCurrentMethod.Add(customMetadata);              return;            }          }        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeReferenceToIteratorClass,The following statement contains a magic number: foreach (IOperation operation in methodBody.Operations) {          if (operation.OperationCode == OperationCode.Newobj) {            IMethodReference/*?*/ consRef = operation.Value as IMethodReference;            if (consRef != null && consRef.ContainingType is INamedEntity) {              string iteratorClassName = ((INamedEntity)consRef.ContainingType).Name.Value;              MemoryStream customMetadata = new MemoryStream();              BinaryWriter cmw = new BinaryWriter(customMetadata' true);              cmw.WriteByte(4); //version              cmw.WriteByte(4); //kind: ForwardIterator              cmw.Align(4);              uint length = 10+(uint)iteratorClassName.Length*2;              while (length % 4 > 0) length++;              cmw.WriteUint(length);              cmw.WriteString(iteratorClassName' true);              cmw.Align(4);              this.customDebugMetadataForCurrentMethod.Add(customMetadata);              return;            }          }        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeMethodBodyIL,The following statement contains a magic number: foreach (IOperation operation in methodBody.Operations) {          this.EmitPdbInformationFor(operation);          switch (operation.OperationCode) {            case OperationCode.Array_Addr:            case OperationCode.Array_Get:            case OperationCode.Array_Set:              writer.WriteByte((byte)OperationCode.Call);              writer.WriteUint(this.GetMethodRefTokenFor((IArrayTypeReference)operation.Value' operation.OperationCode));              continue;            case OperationCode.Array_Create:            case OperationCode.Array_Create_WithLowerBound:              writer.WriteByte((byte)OperationCode.Newobj);              writer.WriteUint(this.GetMethodRefTokenFor((IArrayTypeReference)operation.Value' operation.OperationCode));              continue;          }          if (operation.OperationCode < OperationCode.Arglist)            writer.WriteByte((byte)operation.OperationCode);          else {            writer.WriteByte((byte)((ushort)operation.OperationCode >> 8));            writer.WriteByte((byte)((ushort)operation.OperationCode & 0xff));          }          switch (operation.OperationCode) {            case OperationCode.Beq:            case OperationCode.Bge:            case OperationCode.Bge_Un:            case OperationCode.Bgt:            case OperationCode.Bgt_Un:            case OperationCode.Ble:            case OperationCode.Ble_Un:            case OperationCode.Blt:            case OperationCode.Blt_Un:            case OperationCode.Bne_Un:            case OperationCode.Br:            case OperationCode.Brfalse:            case OperationCode.Brtrue:            case OperationCode.Leave:              //^ assume operation.Value is int;              writer.WriteInt((int)((uint)operation.Value-mbody.Position-4)); break;            case OperationCode.Beq_S:            case OperationCode.Bge_S:            case OperationCode.Bge_Un_S:            case OperationCode.Bgt_S:            case OperationCode.Bgt_Un_S:            case OperationCode.Ble_S:            case OperationCode.Ble_Un_S:            case OperationCode.Blt_S:            case OperationCode.Blt_Un_S:            case OperationCode.Bne_Un_S:            case OperationCode.Br_S:            case OperationCode.Brfalse_S:            case OperationCode.Brtrue_S:            case OperationCode.Leave_S:              //^ assume operation.Value is int;              writer.WriteSbyte((sbyte)((uint)operation.Value-mbody.Position-1)); break;            case OperationCode.Box:            case OperationCode.Castclass:            case OperationCode.Constrained_:            case OperationCode.Cpobj:            case OperationCode.Initobj:            case OperationCode.Isinst:            case OperationCode.Ldelem:            case OperationCode.Ldelema:            case OperationCode.Ldobj:            case OperationCode.Mkrefany:            case OperationCode.Refanyval:            case OperationCode.Sizeof:            case OperationCode.Stelem:            case OperationCode.Stobj:            case OperationCode.Unbox:            case OperationCode.Unbox_Any:              //^ assume operation.Value is ITypeReference;              writer.WriteUint(this.GetTypeToken((ITypeReference)operation.Value)); break;            case OperationCode.Call:            case OperationCode.Callvirt:            case OperationCode.Jmp:            case OperationCode.Ldftn:            case OperationCode.Ldvirtftn:            case OperationCode.Newobj:              //^ assume operation.Value is IMethodReference;              writer.WriteUint(this.GetMethodToken((IMethodReference)operation.Value)); break;            case OperationCode.Calli:              //^ assume operation.Value is IFunctionPointerTypeReference;              writer.WriteUint(this.GetStandaloneSignatureToken((IFunctionPointerTypeReference)operation.Value)); break;            case OperationCode.Ldarg:            case OperationCode.Ldarga:            case OperationCode.Starg:              if (operation.Value == null)                writer.WriteUshort(0);              else {                //^ assume operation.Value is IParameterDefinition;                writer.WriteUshort(GetParameterIndex((IParameterDefinition)operation.Value));              }              break;            case OperationCode.Ldarg_S:            case OperationCode.Ldarga_S:            case OperationCode.Starg_S:              if (operation.Value == null)                writer.WriteByte(0);              else {                //^ assume operation.Value is IParameterDefinition;                writer.WriteByte((byte)GetParameterIndex((IParameterDefinition)operation.Value));              }              break;            case OperationCode.Ldc_I4:              //^ assume operation.Value is int;              writer.WriteInt((int)operation.Value); break;            case OperationCode.Ldc_I4_S:              //^ assume operation.Value is int;              writer.WriteSbyte((sbyte)(int)operation.Value); break;            case OperationCode.Ldc_I8:              //^ assume operation.Value is long;              writer.WriteLong((long)operation.Value); break;            case OperationCode.Ldc_R4:              //^ assume operation.Value is float;              writer.WriteFloat((float)operation.Value); break;            case OperationCode.Ldc_R8:              //^ assume operation.Value is double;              writer.WriteDouble((double)operation.Value); break;            case OperationCode.Ldfld:            case OperationCode.Ldflda:            case OperationCode.Ldsfld:            case OperationCode.Ldsflda:            case OperationCode.Stfld:            case OperationCode.Stsfld:              //^ assume operation.Value is IFieldReference;              writer.WriteUint(this.GetFieldToken((IFieldReference)operation.Value)); break;            case OperationCode.Ldloc:            case OperationCode.Ldloca:            case OperationCode.Stloc:              //^ assume operation.Value is ILocalDefinition;              writer.WriteUshort(this.localDefIndex[(ILocalDefinition)operation.Value]); break;            case OperationCode.Ldloc_S:            case OperationCode.Ldloca_S:            case OperationCode.Stloc_S:              //^ assume operation.Value is ILocalDefinition;              writer.WriteByte((byte)this.localDefIndex[(ILocalDefinition)operation.Value]); break;            case OperationCode.Ldstr:              //^ assume operation.Value is string;              writer.WriteUint(this.GetUserStringToken((string)operation.Value)); break;            case OperationCode.Ldtoken:              uint token = 0;              IFieldReference/*?*/ fieldRef = operation.Value as IFieldReference;              if (fieldRef != null)                token = this.GetFieldToken(fieldRef);              else {                IMethodReference/*?*/ methodRef = operation.Value as IMethodReference;                if (methodRef != null)                  token = this.GetMethodToken(methodRef);                else {                  //^ assume operation.Value is ITypeReference;                  token = this.GetTypeToken((ITypeReference)operation.Value);                }              }              writer.WriteUint(token);              break;            case OperationCode.Newarr:              //^ assume operation.Value is IArrayTypeReference;              writer.WriteUint(this.GetTypeToken(((IArrayTypeReference)operation.Value).ElementType)); break;            case OperationCode.No_:              //^ assume operation.Value is OperationCheckFlags;              writer.WriteByte((byte)(OperationCheckFlags)operation.Value); break;            case OperationCode.Switch:              //^ assume operation.Value is uint[];              uint[] targets = (uint[])operation.Value;              writer.WriteUint((uint)targets.Length);              uint offset = writer.BaseStream.Position + (uint)targets.Length*4;              foreach (uint target in targets) writer.WriteInt((int)(target-offset));              break;            case OperationCode.Unaligned_:              //^ assume operation.Value is byte;              writer.WriteByte((byte)operation.Value); break;            default:              break;          }        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeMethodBodyIL,The following statement contains a magic number: foreach (IOperation operation in methodBody.Operations) {          this.EmitPdbInformationFor(operation);          switch (operation.OperationCode) {            case OperationCode.Array_Addr:            case OperationCode.Array_Get:            case OperationCode.Array_Set:              writer.WriteByte((byte)OperationCode.Call);              writer.WriteUint(this.GetMethodRefTokenFor((IArrayTypeReference)operation.Value' operation.OperationCode));              continue;            case OperationCode.Array_Create:            case OperationCode.Array_Create_WithLowerBound:              writer.WriteByte((byte)OperationCode.Newobj);              writer.WriteUint(this.GetMethodRefTokenFor((IArrayTypeReference)operation.Value' operation.OperationCode));              continue;          }          if (operation.OperationCode < OperationCode.Arglist)            writer.WriteByte((byte)operation.OperationCode);          else {            writer.WriteByte((byte)((ushort)operation.OperationCode >> 8));            writer.WriteByte((byte)((ushort)operation.OperationCode & 0xff));          }          switch (operation.OperationCode) {            case OperationCode.Beq:            case OperationCode.Bge:            case OperationCode.Bge_Un:            case OperationCode.Bgt:            case OperationCode.Bgt_Un:            case OperationCode.Ble:            case OperationCode.Ble_Un:            case OperationCode.Blt:            case OperationCode.Blt_Un:            case OperationCode.Bne_Un:            case OperationCode.Br:            case OperationCode.Brfalse:            case OperationCode.Brtrue:            case OperationCode.Leave:              //^ assume operation.Value is int;              writer.WriteInt((int)((uint)operation.Value-mbody.Position-4)); break;            case OperationCode.Beq_S:            case OperationCode.Bge_S:            case OperationCode.Bge_Un_S:            case OperationCode.Bgt_S:            case OperationCode.Bgt_Un_S:            case OperationCode.Ble_S:            case OperationCode.Ble_Un_S:            case OperationCode.Blt_S:            case OperationCode.Blt_Un_S:            case OperationCode.Bne_Un_S:            case OperationCode.Br_S:            case OperationCode.Brfalse_S:            case OperationCode.Brtrue_S:            case OperationCode.Leave_S:              //^ assume operation.Value is int;              writer.WriteSbyte((sbyte)((uint)operation.Value-mbody.Position-1)); break;            case OperationCode.Box:            case OperationCode.Castclass:            case OperationCode.Constrained_:            case OperationCode.Cpobj:            case OperationCode.Initobj:            case OperationCode.Isinst:            case OperationCode.Ldelem:            case OperationCode.Ldelema:            case OperationCode.Ldobj:            case OperationCode.Mkrefany:            case OperationCode.Refanyval:            case OperationCode.Sizeof:            case OperationCode.Stelem:            case OperationCode.Stobj:            case OperationCode.Unbox:            case OperationCode.Unbox_Any:              //^ assume operation.Value is ITypeReference;              writer.WriteUint(this.GetTypeToken((ITypeReference)operation.Value)); break;            case OperationCode.Call:            case OperationCode.Callvirt:            case OperationCode.Jmp:            case OperationCode.Ldftn:            case OperationCode.Ldvirtftn:            case OperationCode.Newobj:              //^ assume operation.Value is IMethodReference;              writer.WriteUint(this.GetMethodToken((IMethodReference)operation.Value)); break;            case OperationCode.Calli:              //^ assume operation.Value is IFunctionPointerTypeReference;              writer.WriteUint(this.GetStandaloneSignatureToken((IFunctionPointerTypeReference)operation.Value)); break;            case OperationCode.Ldarg:            case OperationCode.Ldarga:            case OperationCode.Starg:              if (operation.Value == null)                writer.WriteUshort(0);              else {                //^ assume operation.Value is IParameterDefinition;                writer.WriteUshort(GetParameterIndex((IParameterDefinition)operation.Value));              }              break;            case OperationCode.Ldarg_S:            case OperationCode.Ldarga_S:            case OperationCode.Starg_S:              if (operation.Value == null)                writer.WriteByte(0);              else {                //^ assume operation.Value is IParameterDefinition;                writer.WriteByte((byte)GetParameterIndex((IParameterDefinition)operation.Value));              }              break;            case OperationCode.Ldc_I4:              //^ assume operation.Value is int;              writer.WriteInt((int)operation.Value); break;            case OperationCode.Ldc_I4_S:              //^ assume operation.Value is int;              writer.WriteSbyte((sbyte)(int)operation.Value); break;            case OperationCode.Ldc_I8:              //^ assume operation.Value is long;              writer.WriteLong((long)operation.Value); break;            case OperationCode.Ldc_R4:              //^ assume operation.Value is float;              writer.WriteFloat((float)operation.Value); break;            case OperationCode.Ldc_R8:              //^ assume operation.Value is double;              writer.WriteDouble((double)operation.Value); break;            case OperationCode.Ldfld:            case OperationCode.Ldflda:            case OperationCode.Ldsfld:            case OperationCode.Ldsflda:            case OperationCode.Stfld:            case OperationCode.Stsfld:              //^ assume operation.Value is IFieldReference;              writer.WriteUint(this.GetFieldToken((IFieldReference)operation.Value)); break;            case OperationCode.Ldloc:            case OperationCode.Ldloca:            case OperationCode.Stloc:              //^ assume operation.Value is ILocalDefinition;              writer.WriteUshort(this.localDefIndex[(ILocalDefinition)operation.Value]); break;            case OperationCode.Ldloc_S:            case OperationCode.Ldloca_S:            case OperationCode.Stloc_S:              //^ assume operation.Value is ILocalDefinition;              writer.WriteByte((byte)this.localDefIndex[(ILocalDefinition)operation.Value]); break;            case OperationCode.Ldstr:              //^ assume operation.Value is string;              writer.WriteUint(this.GetUserStringToken((string)operation.Value)); break;            case OperationCode.Ldtoken:              uint token = 0;              IFieldReference/*?*/ fieldRef = operation.Value as IFieldReference;              if (fieldRef != null)                token = this.GetFieldToken(fieldRef);              else {                IMethodReference/*?*/ methodRef = operation.Value as IMethodReference;                if (methodRef != null)                  token = this.GetMethodToken(methodRef);                else {                  //^ assume operation.Value is ITypeReference;                  token = this.GetTypeToken((ITypeReference)operation.Value);                }              }              writer.WriteUint(token);              break;            case OperationCode.Newarr:              //^ assume operation.Value is IArrayTypeReference;              writer.WriteUint(this.GetTypeToken(((IArrayTypeReference)operation.Value).ElementType)); break;            case OperationCode.No_:              //^ assume operation.Value is OperationCheckFlags;              writer.WriteByte((byte)(OperationCheckFlags)operation.Value); break;            case OperationCode.Switch:              //^ assume operation.Value is uint[];              uint[] targets = (uint[])operation.Value;              writer.WriteUint((uint)targets.Length);              uint offset = writer.BaseStream.Position + (uint)targets.Length*4;              foreach (uint target in targets) writer.WriteInt((int)(target-offset));              break;            case OperationCode.Unaligned_:              //^ assume operation.Value is byte;              writer.WriteByte((byte)operation.Value); break;            default:              break;          }        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeMethodBodyIL,The following statement contains a magic number: foreach (IOperation operation in methodBody.Operations) {          this.EmitPdbInformationFor(operation);          switch (operation.OperationCode) {            case OperationCode.Array_Addr:            case OperationCode.Array_Get:            case OperationCode.Array_Set:              writer.WriteByte((byte)OperationCode.Call);              writer.WriteUint(this.GetMethodRefTokenFor((IArrayTypeReference)operation.Value' operation.OperationCode));              continue;            case OperationCode.Array_Create:            case OperationCode.Array_Create_WithLowerBound:              writer.WriteByte((byte)OperationCode.Newobj);              writer.WriteUint(this.GetMethodRefTokenFor((IArrayTypeReference)operation.Value' operation.OperationCode));              continue;          }          if (operation.OperationCode < OperationCode.Arglist)            writer.WriteByte((byte)operation.OperationCode);          else {            writer.WriteByte((byte)((ushort)operation.OperationCode >> 8));            writer.WriteByte((byte)((ushort)operation.OperationCode & 0xff));          }          switch (operation.OperationCode) {            case OperationCode.Beq:            case OperationCode.Bge:            case OperationCode.Bge_Un:            case OperationCode.Bgt:            case OperationCode.Bgt_Un:            case OperationCode.Ble:            case OperationCode.Ble_Un:            case OperationCode.Blt:            case OperationCode.Blt_Un:            case OperationCode.Bne_Un:            case OperationCode.Br:            case OperationCode.Brfalse:            case OperationCode.Brtrue:            case OperationCode.Leave:              //^ assume operation.Value is int;              writer.WriteInt((int)((uint)operation.Value-mbody.Position-4)); break;            case OperationCode.Beq_S:            case OperationCode.Bge_S:            case OperationCode.Bge_Un_S:            case OperationCode.Bgt_S:            case OperationCode.Bgt_Un_S:            case OperationCode.Ble_S:            case OperationCode.Ble_Un_S:            case OperationCode.Blt_S:            case OperationCode.Blt_Un_S:            case OperationCode.Bne_Un_S:            case OperationCode.Br_S:            case OperationCode.Brfalse_S:            case OperationCode.Brtrue_S:            case OperationCode.Leave_S:              //^ assume operation.Value is int;              writer.WriteSbyte((sbyte)((uint)operation.Value-mbody.Position-1)); break;            case OperationCode.Box:            case OperationCode.Castclass:            case OperationCode.Constrained_:            case OperationCode.Cpobj:            case OperationCode.Initobj:            case OperationCode.Isinst:            case OperationCode.Ldelem:            case OperationCode.Ldelema:            case OperationCode.Ldobj:            case OperationCode.Mkrefany:            case OperationCode.Refanyval:            case OperationCode.Sizeof:            case OperationCode.Stelem:            case OperationCode.Stobj:            case OperationCode.Unbox:            case OperationCode.Unbox_Any:              //^ assume operation.Value is ITypeReference;              writer.WriteUint(this.GetTypeToken((ITypeReference)operation.Value)); break;            case OperationCode.Call:            case OperationCode.Callvirt:            case OperationCode.Jmp:            case OperationCode.Ldftn:            case OperationCode.Ldvirtftn:            case OperationCode.Newobj:              //^ assume operation.Value is IMethodReference;              writer.WriteUint(this.GetMethodToken((IMethodReference)operation.Value)); break;            case OperationCode.Calli:              //^ assume operation.Value is IFunctionPointerTypeReference;              writer.WriteUint(this.GetStandaloneSignatureToken((IFunctionPointerTypeReference)operation.Value)); break;            case OperationCode.Ldarg:            case OperationCode.Ldarga:            case OperationCode.Starg:              if (operation.Value == null)                writer.WriteUshort(0);              else {                //^ assume operation.Value is IParameterDefinition;                writer.WriteUshort(GetParameterIndex((IParameterDefinition)operation.Value));              }              break;            case OperationCode.Ldarg_S:            case OperationCode.Ldarga_S:            case OperationCode.Starg_S:              if (operation.Value == null)                writer.WriteByte(0);              else {                //^ assume operation.Value is IParameterDefinition;                writer.WriteByte((byte)GetParameterIndex((IParameterDefinition)operation.Value));              }              break;            case OperationCode.Ldc_I4:              //^ assume operation.Value is int;              writer.WriteInt((int)operation.Value); break;            case OperationCode.Ldc_I4_S:              //^ assume operation.Value is int;              writer.WriteSbyte((sbyte)(int)operation.Value); break;            case OperationCode.Ldc_I8:              //^ assume operation.Value is long;              writer.WriteLong((long)operation.Value); break;            case OperationCode.Ldc_R4:              //^ assume operation.Value is float;              writer.WriteFloat((float)operation.Value); break;            case OperationCode.Ldc_R8:              //^ assume operation.Value is double;              writer.WriteDouble((double)operation.Value); break;            case OperationCode.Ldfld:            case OperationCode.Ldflda:            case OperationCode.Ldsfld:            case OperationCode.Ldsflda:            case OperationCode.Stfld:            case OperationCode.Stsfld:              //^ assume operation.Value is IFieldReference;              writer.WriteUint(this.GetFieldToken((IFieldReference)operation.Value)); break;            case OperationCode.Ldloc:            case OperationCode.Ldloca:            case OperationCode.Stloc:              //^ assume operation.Value is ILocalDefinition;              writer.WriteUshort(this.localDefIndex[(ILocalDefinition)operation.Value]); break;            case OperationCode.Ldloc_S:            case OperationCode.Ldloca_S:            case OperationCode.Stloc_S:              //^ assume operation.Value is ILocalDefinition;              writer.WriteByte((byte)this.localDefIndex[(ILocalDefinition)operation.Value]); break;            case OperationCode.Ldstr:              //^ assume operation.Value is string;              writer.WriteUint(this.GetUserStringToken((string)operation.Value)); break;            case OperationCode.Ldtoken:              uint token = 0;              IFieldReference/*?*/ fieldRef = operation.Value as IFieldReference;              if (fieldRef != null)                token = this.GetFieldToken(fieldRef);              else {                IMethodReference/*?*/ methodRef = operation.Value as IMethodReference;                if (methodRef != null)                  token = this.GetMethodToken(methodRef);                else {                  //^ assume operation.Value is ITypeReference;                  token = this.GetTypeToken((ITypeReference)operation.Value);                }              }              writer.WriteUint(token);              break;            case OperationCode.Newarr:              //^ assume operation.Value is IArrayTypeReference;              writer.WriteUint(this.GetTypeToken(((IArrayTypeReference)operation.Value).ElementType)); break;            case OperationCode.No_:              //^ assume operation.Value is OperationCheckFlags;              writer.WriteByte((byte)(OperationCheckFlags)operation.Value); break;            case OperationCode.Switch:              //^ assume operation.Value is uint[];              uint[] targets = (uint[])operation.Value;              writer.WriteUint((uint)targets.Length);              uint offset = writer.BaseStream.Position + (uint)targets.Length*4;              foreach (uint target in targets) writer.WriteInt((int)(target-offset));              break;            case OperationCode.Unaligned_:              //^ assume operation.Value is byte;              writer.WriteByte((byte)operation.Value); break;            default:              break;          }        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeMethodBodyExceptionHandlerTable,The following statement contains a magic number: writer.Align(4);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeMethodBodyExceptionHandlerTable,The following statement contains a magic number: if (useSmallExceptionHeaders) {          uint dataSize = numberOfExceptionHandlers*12+4;          writer.WriteByte(0x01);          writer.WriteByte((byte)(dataSize & 0xff));          writer.WriteUshort(0);        } else {          uint dataSize = numberOfExceptionHandlers*24+4;          writer.WriteByte(0x41);          writer.WriteByte((byte)(dataSize & 0xff));          writer.WriteUshort((ushort)((dataSize >> 8) & 0xffff));        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeMethodBodyExceptionHandlerTable,The following statement contains a magic number: if (useSmallExceptionHeaders) {          uint dataSize = numberOfExceptionHandlers*12+4;          writer.WriteByte(0x01);          writer.WriteByte((byte)(dataSize & 0xff));          writer.WriteUshort(0);        } else {          uint dataSize = numberOfExceptionHandlers*24+4;          writer.WriteByte(0x41);          writer.WriteByte((byte)(dataSize & 0xff));          writer.WriteUshort((ushort)((dataSize >> 8) & 0xffff));        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeMethodBodyExceptionHandlerTable,The following statement contains a magic number: if (useSmallExceptionHeaders) {          uint dataSize = numberOfExceptionHandlers*12+4;          writer.WriteByte(0x01);          writer.WriteByte((byte)(dataSize & 0xff));          writer.WriteUshort(0);        } else {          uint dataSize = numberOfExceptionHandlers*24+4;          writer.WriteByte(0x41);          writer.WriteByte((byte)(dataSize & 0xff));          writer.WriteUshort((ushort)((dataSize >> 8) & 0xffff));        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeMethodBodyExceptionHandlerTable,The following statement contains a magic number: if (useSmallExceptionHeaders) {          uint dataSize = numberOfExceptionHandlers*12+4;          writer.WriteByte(0x01);          writer.WriteByte((byte)(dataSize & 0xff));          writer.WriteUshort(0);        } else {          uint dataSize = numberOfExceptionHandlers*24+4;          writer.WriteByte(0x41);          writer.WriteByte((byte)(dataSize & 0xff));          writer.WriteUshort((ushort)((dataSize >> 8) & 0xffff));        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeMethodBodyExceptionHandlerTable,The following statement contains a magic number: if (useSmallExceptionHeaders) {          uint dataSize = numberOfExceptionHandlers*12+4;          writer.WriteByte(0x01);          writer.WriteByte((byte)(dataSize & 0xff));          writer.WriteUshort(0);        } else {          uint dataSize = numberOfExceptionHandlers*24+4;          writer.WriteByte(0x41);          writer.WriteByte((byte)(dataSize & 0xff));          writer.WriteUshort((ushort)((dataSize >> 8) & 0xffff));        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,MayUseSmallExceptionHeaders,The following statement contains a magic number: if (numberOfExceptionHandlers*12+4 > 0xff) return false;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,MayUseSmallExceptionHeaders,The following statement contains a magic number: if (numberOfExceptionHandlers*12+4 > 0xff) return false;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeWin32Resources,The following statement contains a magic number: uint sizeOfDirectoryTree = 16;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeWin32Resources,The following statement contains a magic number: foreach (IWin32Resource r in this.module.Win32Resources) {          bool typeDifferent = (r.TypeId < 0 && r.TypeName != lastTypeName) || r.TypeId > lastTypeID;          if (typeDifferent) {            lastTypeID = r.TypeId;            lastTypeName = r.TypeName;            if (lastTypeID < 0) TypeDirectory.NumberOfNamedEntries++; else TypeDirectory.NumberOfIdEntries++;            sizeOfDirectoryTree += 24;            TypeDirectory.Entries.Add(NameDirectory = new Directory(lastTypeName' lastTypeID));          }          if (typeDifferent || (r.Id < 0 && r.Name != lastName) || r.Id > lastID) {            lastID = r.Id;            lastName = r.Name;            if (lastID < 0) NameDirectory.NumberOfNamedEntries++; else NameDirectory.NumberOfIdEntries++;            sizeOfDirectoryTree += 24;            NameDirectory.Entries.Add(LanguageDirectory = new Directory(lastName' lastID));          }          LanguageDirectory.NumberOfIdEntries++;          sizeOfDirectoryTree += 8;          LanguageDirectory.Entries.Add(r);        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeWin32Resources,The following statement contains a magic number: foreach (IWin32Resource r in this.module.Win32Resources) {          bool typeDifferent = (r.TypeId < 0 && r.TypeName != lastTypeName) || r.TypeId > lastTypeID;          if (typeDifferent) {            lastTypeID = r.TypeId;            lastTypeName = r.TypeName;            if (lastTypeID < 0) TypeDirectory.NumberOfNamedEntries++; else TypeDirectory.NumberOfIdEntries++;            sizeOfDirectoryTree += 24;            TypeDirectory.Entries.Add(NameDirectory = new Directory(lastTypeName' lastTypeID));          }          if (typeDifferent || (r.Id < 0 && r.Name != lastName) || r.Id > lastID) {            lastID = r.Id;            lastName = r.Name;            if (lastID < 0) NameDirectory.NumberOfNamedEntries++; else NameDirectory.NumberOfIdEntries++;            sizeOfDirectoryTree += 24;            NameDirectory.Entries.Add(LanguageDirectory = new Directory(lastName' lastID));          }          LanguageDirectory.NumberOfIdEntries++;          sizeOfDirectoryTree += 8;          LanguageDirectory.Entries.Add(r);        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeWin32Resources,The following statement contains a magic number: foreach (IWin32Resource r in this.module.Win32Resources) {          bool typeDifferent = (r.TypeId < 0 && r.TypeName != lastTypeName) || r.TypeId > lastTypeID;          if (typeDifferent) {            lastTypeID = r.TypeId;            lastTypeName = r.TypeName;            if (lastTypeID < 0) TypeDirectory.NumberOfNamedEntries++; else TypeDirectory.NumberOfIdEntries++;            sizeOfDirectoryTree += 24;            TypeDirectory.Entries.Add(NameDirectory = new Directory(lastTypeName' lastTypeID));          }          if (typeDifferent || (r.Id < 0 && r.Name != lastName) || r.Id > lastID) {            lastID = r.Id;            lastName = r.Name;            if (lastID < 0) NameDirectory.NumberOfNamedEntries++; else NameDirectory.NumberOfIdEntries++;            sizeOfDirectoryTree += 24;            NameDirectory.Entries.Add(LanguageDirectory = new Directory(lastName' lastID));          }          LanguageDirectory.NumberOfIdEntries++;          sizeOfDirectoryTree += 8;          LanguageDirectory.Entries.Add(r);        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeWin32Resources,The following statement contains a magic number: while ((this.win32ResourceWriter.BaseStream.Length % 4) != 0) this.win32ResourceWriter.WriteByte(0);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,WriteDirectory,The following statement contains a magic number: uint k = offset + 16 + n * 8;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,WriteDirectory,The following statement contains a magic number: uint k = offset + 16 + n * 8;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,WriteDirectory,The following statement contains a magic number: for (int i = 0; i < n; i++) {          int id = int.MinValue;          string name = null;          uint nOff = dataWriter.BaseStream.Position+sizeOfDirectoryTree;          uint dOff = k;          Directory subDir = directory.Entries[i] as Directory;          if (subDir != null) {            id = subDir.ID;            name = subDir.Name;            if (level == 0)              k += SizeOfDirectory(subDir);            else              k += 16 + 8 * (uint)subDir.Entries.Count;          } else {            IWin32Resource r = (IWin32Resource)directory.Entries[i];            id = level == 0 ? r.TypeId : level == 1 ? r.Id : (int)r.LanguageId;            name = level == 0 ? r.TypeName : level == 1 ? r.Name : null;            dataWriter.WriteUint(virtualAddressBase+sizeOfDirectoryTree+16+dataWriter.BaseStream.Position);            byte[] data = new List<byte>(r.Data).ToArray();            dataWriter.WriteUint((uint)data.Length);            dataWriter.WriteUint(r.CodePage);            dataWriter.WriteUint(0);            dataWriter.WriteBytes(data);            while ((dataWriter.BaseStream.Length % 4) != 0) dataWriter.WriteByte(0);          }          if (id >= 0)            writer.WriteInt(id);          else {            if (name == null) name = "";            writer.WriteUint(nOff|0x80000000);            dataWriter.WriteUshort((ushort)name.Length);            dataWriter.WriteChars(name.ToCharArray());  //REVIEW: what happens if the name contains chars that do not fit into a single utf8 code point?          }          if (subDir != null)            writer.WriteUint(dOff|0x80000000);          else            writer.WriteUint(nOff);        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,WriteDirectory,The following statement contains a magic number: for (int i = 0; i < n; i++) {          int id = int.MinValue;          string name = null;          uint nOff = dataWriter.BaseStream.Position+sizeOfDirectoryTree;          uint dOff = k;          Directory subDir = directory.Entries[i] as Directory;          if (subDir != null) {            id = subDir.ID;            name = subDir.Name;            if (level == 0)              k += SizeOfDirectory(subDir);            else              k += 16 + 8 * (uint)subDir.Entries.Count;          } else {            IWin32Resource r = (IWin32Resource)directory.Entries[i];            id = level == 0 ? r.TypeId : level == 1 ? r.Id : (int)r.LanguageId;            name = level == 0 ? r.TypeName : level == 1 ? r.Name : null;            dataWriter.WriteUint(virtualAddressBase+sizeOfDirectoryTree+16+dataWriter.BaseStream.Position);            byte[] data = new List<byte>(r.Data).ToArray();            dataWriter.WriteUint((uint)data.Length);            dataWriter.WriteUint(r.CodePage);            dataWriter.WriteUint(0);            dataWriter.WriteBytes(data);            while ((dataWriter.BaseStream.Length % 4) != 0) dataWriter.WriteByte(0);          }          if (id >= 0)            writer.WriteInt(id);          else {            if (name == null) name = "";            writer.WriteUint(nOff|0x80000000);            dataWriter.WriteUshort((ushort)name.Length);            dataWriter.WriteChars(name.ToCharArray());  //REVIEW: what happens if the name contains chars that do not fit into a single utf8 code point?          }          if (subDir != null)            writer.WriteUint(dOff|0x80000000);          else            writer.WriteUint(nOff);        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,WriteDirectory,The following statement contains a magic number: for (int i = 0; i < n; i++) {          int id = int.MinValue;          string name = null;          uint nOff = dataWriter.BaseStream.Position+sizeOfDirectoryTree;          uint dOff = k;          Directory subDir = directory.Entries[i] as Directory;          if (subDir != null) {            id = subDir.ID;            name = subDir.Name;            if (level == 0)              k += SizeOfDirectory(subDir);            else              k += 16 + 8 * (uint)subDir.Entries.Count;          } else {            IWin32Resource r = (IWin32Resource)directory.Entries[i];            id = level == 0 ? r.TypeId : level == 1 ? r.Id : (int)r.LanguageId;            name = level == 0 ? r.TypeName : level == 1 ? r.Name : null;            dataWriter.WriteUint(virtualAddressBase+sizeOfDirectoryTree+16+dataWriter.BaseStream.Position);            byte[] data = new List<byte>(r.Data).ToArray();            dataWriter.WriteUint((uint)data.Length);            dataWriter.WriteUint(r.CodePage);            dataWriter.WriteUint(0);            dataWriter.WriteBytes(data);            while ((dataWriter.BaseStream.Length % 4) != 0) dataWriter.WriteByte(0);          }          if (id >= 0)            writer.WriteInt(id);          else {            if (name == null) name = "";            writer.WriteUint(nOff|0x80000000);            dataWriter.WriteUshort((ushort)name.Length);            dataWriter.WriteChars(name.ToCharArray());  //REVIEW: what happens if the name contains chars that do not fit into a single utf8 code point?          }          if (subDir != null)            writer.WriteUint(dOff|0x80000000);          else            writer.WriteUint(nOff);        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,WriteDirectory,The following statement contains a magic number: for (int i = 0; i < n; i++) {          int id = int.MinValue;          string name = null;          uint nOff = dataWriter.BaseStream.Position+sizeOfDirectoryTree;          uint dOff = k;          Directory subDir = directory.Entries[i] as Directory;          if (subDir != null) {            id = subDir.ID;            name = subDir.Name;            if (level == 0)              k += SizeOfDirectory(subDir);            else              k += 16 + 8 * (uint)subDir.Entries.Count;          } else {            IWin32Resource r = (IWin32Resource)directory.Entries[i];            id = level == 0 ? r.TypeId : level == 1 ? r.Id : (int)r.LanguageId;            name = level == 0 ? r.TypeName : level == 1 ? r.Name : null;            dataWriter.WriteUint(virtualAddressBase+sizeOfDirectoryTree+16+dataWriter.BaseStream.Position);            byte[] data = new List<byte>(r.Data).ToArray();            dataWriter.WriteUint((uint)data.Length);            dataWriter.WriteUint(r.CodePage);            dataWriter.WriteUint(0);            dataWriter.WriteBytes(data);            while ((dataWriter.BaseStream.Length % 4) != 0) dataWriter.WriteByte(0);          }          if (id >= 0)            writer.WriteInt(id);          else {            if (name == null) name = "";            writer.WriteUint(nOff|0x80000000);            dataWriter.WriteUshort((ushort)name.Length);            dataWriter.WriteChars(name.ToCharArray());  //REVIEW: what happens if the name contains chars that do not fit into a single utf8 code point?          }          if (subDir != null)            writer.WriteUint(dOff|0x80000000);          else            writer.WriteUint(nOff);        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,WriteDirectory,The following statement contains a magic number: k = offset + 16 + n * 8;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,WriteDirectory,The following statement contains a magic number: k = offset + 16 + n * 8;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,WriteDirectory,The following statement contains a magic number: for (int i = 0; i < n; i++) {          Directory subDir = directory.Entries[i] as Directory;          if (subDir != null) {            this.WriteDirectory(subDir' writer' k' level+1' sizeOfDirectoryTree' virtualAddressBase' dataWriter);            if (level == 0)              k += SizeOfDirectory(subDir);            else              k += 16 + 8 * (uint)subDir.Entries.Count;          }        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,WriteDirectory,The following statement contains a magic number: for (int i = 0; i < n; i++) {          Directory subDir = directory.Entries[i] as Directory;          if (subDir != null) {            this.WriteDirectory(subDir' writer' k' level+1' sizeOfDirectoryTree' virtualAddressBase' dataWriter);            if (level == 0)              k += SizeOfDirectory(subDir);            else              k += 16 + 8 * (uint)subDir.Entries.Count;          }        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SizeOfDirectory,The following statement contains a magic number: uint size = 16 + 8 * n;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SizeOfDirectory,The following statement contains a magic number: uint size = 16 + 8 * n;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SizeOfDirectory,The following statement contains a magic number: for (int i = 0; i < n; i++) {          Directory subDir = directory.Entries[i] as Directory;          if (subDir != null)            size += 16 + 8 * (uint)subDir.Entries.Count;        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SizeOfDirectory,The following statement contains a magic number: for (int i = 0; i < n; i++) {          Directory subDir = directory.Entries[i] as Directory;          if (subDir != null)            size += 16 + 8 * (uint)subDir.Entries.Count;        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,WriteHeaders,The following statement contains a magic number: writer.WriteUshort((ushort)(!module.Requires64bits ? 224 : 240));
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,WriteHeaders,The following statement contains a magic number: writer.WriteUshort((ushort)(!module.Requires64bits ? 224 : 240));
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,WriteHeaders,The following statement contains a magic number: writer.WriteUshort(4);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,WriteHeaders,The following statement contains a magic number: writer.WriteUshort(4);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,WriteHeaders,The following statement contains a magic number: switch (module.Kind) {          case ModuleKind.ConsoleApplication:          case ModuleKind.DynamicallyLinkedLibrary:            writer.WriteUshort(3); //70            break;          case ModuleKind.WindowsApplication:            writer.WriteUshort(2); //70            break;        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,WriteHeaders,The following statement contains a magic number: switch (module.Kind) {          case ModuleKind.ConsoleApplication:          case ModuleKind.DynamicallyLinkedLibrary:            writer.WriteUshort(3); //70            break;          case ModuleKind.WindowsApplication:            writer.WriteUshort(2); //70            break;        }
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,WriteHeaders,The following statement contains a magic number: writer.WriteUint(16);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,WriteSectionHeader,The following statement contains a magic number: for (int j = 0' m = sectionHeader.Name.Length; j < 8; j++)          if (j < m) writer.WriteByte((byte)sectionHeader.Name[j]); else writer.WriteByte(0);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,WriteImportAddressTable,The following statement contains a magic number: BinaryWriter writer = new BinaryWriter(new MemoryStream(16));
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,WriteImportAddressTable,The following statement contains a magic number: uint ILTrva = ITrva + 40;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,WriteImportTable,The following statement contains a magic number: BinaryWriter writer = new BinaryWriter(new MemoryStream(70));
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,WriteImportTable,The following statement contains a magic number: uint ILTrva = ITrva + 40;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,WriteImportTable,The following statement contains a magic number: uint nameRva = hintRva+12+2;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,WriteImportTable,The following statement contains a magic number: uint nameRva = hintRva+12+2;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,WriteImportTable,The following statement contains a magic number: writer.BaseStream.Position += 20;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,WriteNameTable,The following statement contains a magic number: BinaryWriter writer = new BinaryWriter(new MemoryStream(14));
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,WriteClrHeader,The following statement contains a magic number: BinaryWriter writer = new BinaryWriter(new MemoryStream(72));
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,WriteClrHeader,The following statement contains a magic number: writer.WriteUint(72);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,WriteIL,The following statement contains a magic number: while (this.peStream.Position % 4 != 0) this.peStream.WriteByte(0);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,WriteTextData,The following statement contains a magic number: while (this.peStream.Position % 4 != 0) this.peStream.WriteByte(0);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,WriteMetadata,The following statement contains a magic number: while (this.peStream.Position % 4 != 0) this.peStream.WriteByte(0);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,WriteManagedResources,The following statement contains a magic number: while (this.peStream.Position % 4 != 0) this.peStream.WriteByte(0);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,WriteRuntimeStartupStub,The following statement contains a magic number: BinaryWriter writer = new BinaryWriter(new MemoryStream(16));
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,WriteRelocSection,The following statement contains a magic number: writer.WriteUint(((this.ntHeader.AddressOfEntryPoint+2) / 0x1000)*0x1000);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,WriteRelocSection,The following statement contains a magic number: uint offsetWithinPage = (this.ntHeader.AddressOfEntryPoint+2) % 0x1000;
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,WriteRelocSection,The following statement contains a magic number: ushort s = (ushort)((relocType << 12) | offsetWithinPage);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,WriteRelocSection,The following statement contains a magic number: if (this.module.Requires64bits && !this.module.RequiresAmdInstructionSet)          writer.WriteUint(relocType << 12);
Magic Number,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,WriteResourceSection,The following statement contains a magic number: while (this.peStream.Position % 8 != 0) this.peStream.WriteByte(0);
Magic Number,Microsoft.Cci,ByteArrayComparer,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetHashCode,The following statement contains a magic number: for (long i = 0' n = x.LongLength; i < n; i++)          hcode = hcode * 17 + x[i];
Magic Number,Microsoft.Cci,MemberRefComparer,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetHashCode,The following statement contains a magic number: long result = (this.peWriter.GetMemberRefParentCodedIndex(memberRef) << 4) ^ (memberRef.Name.UniqueKey << 2);
Magic Number,Microsoft.Cci,MemberRefComparer,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetHashCode,The following statement contains a magic number: long result = (this.peWriter.GetMemberRefParentCodedIndex(memberRef) << 4) ^ (memberRef.Name.UniqueKey << 2);
Magic Number,Microsoft.Cci,MethodSpecComparer,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetHashCode,The following statement contains a magic number: return (int)((this.peWriter.GetMethodDefOrRefCodedIndex(methodInstanceReference.GenericMethod) << 2) ^           this.peWriter.GetMethodInstanceSignatureIndex(methodInstanceReference));
Missing Default,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetGenericParamFlags,The following switch statement is missing a default case: switch (genPar.Variance) {          case TypeParameterVariance.Covariant: result |= 0x0001; break;          case TypeParameterVariance.Contravariant: result |= 0x0002; break;        }
Missing Default,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetMappingFlags,The following switch statement is missing a default case: switch (platformInvokeInformation.StringFormat) {          case StringFormatKind.Ansi: result |= 0x0002; break;          case StringFormatKind.Unicode: result |= 0x0004; break;          case StringFormatKind.AutoChar: result |= 0x0006; break;        }
Missing Default,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetMappingFlags,The following switch statement is missing a default case: switch (platformInvokeInformation.PInvokeCallingConvention) {          case PInvokeCallingConvention.WinApi: result |= 0x0100; break;          case PInvokeCallingConvention.CDecl: result |= 0x0200; break;          case PInvokeCallingConvention.StdCall: result |= 0x0300; break;          case PInvokeCallingConvention.ThisCall: result |= 0x0400; break;          case PInvokeCallingConvention.FastCall: result |= 0x0500; break;        }
Missing Default,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetTypeCodeByteFor,The following switch statement is missing a default case: switch (ic.GetTypeCode()) {          case TypeCode.Boolean: return 0x02;          case TypeCode.Char: return 0x03;          case TypeCode.SByte: return 0x04;          case TypeCode.Byte: return 0x05;          case TypeCode.Int16: return 0x06;          case TypeCode.UInt16: return 0x07;          case TypeCode.Int32: return 0x08;          case TypeCode.UInt32: return 0x09;          case TypeCode.Int64: return 0x0a;          case TypeCode.UInt64: return 0x0b;          case TypeCode.Single: return 0x0c;          case TypeCode.Double: return 0x0d;          case TypeCode.String: return 0x0e;        }
Missing Default,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetTypeDefFlags,The following switch statement is missing a default case: switch (typeDef.Layout) {          case LayoutKind.Sequential: result |= 0x00000008; break;          case LayoutKind.Explicit: result |= 0x00000010; break;        }
Missing Default,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetTypeDefFlags,The following switch statement is missing a default case: switch (typeDef.StringFormat) {          case StringFormatKind.Unicode: result |= 0x00010000; break;          case StringFormatKind.AutoChar: result |= 0x00020000; break;          //TODO: need object model support for 0x00030000; custom format class        }
Missing Default,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetTypeDefFlags,The following switch statement is missing a default case: switch (neTypeDef.Visibility) {            case TypeMemberVisibility.Public: result |= 0x00000002; break;            case TypeMemberVisibility.Private: result |= 0x00000003; break;            case TypeMemberVisibility.Family: result |= 0x00000004; break;            case TypeMemberVisibility.Assembly: result |= 0x00000005; break;            case TypeMemberVisibility.FamilyAndAssembly: result |= 0x00000006; break;            case TypeMemberVisibility.FamilyOrAssembly: result |= 0x00000007; break;          }
Missing Default,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,GetTypeMemberVisibilityFlags,The following switch statement is missing a default case: switch (member.Visibility) {          case TypeMemberVisibility.Private: result |= 0x00000001; break;          case TypeMemberVisibility.FamilyAndAssembly: result |= 0x00000002; break;          case TypeMemberVisibility.Assembly: result |= 0x00000003; break;          case TypeMemberVisibility.Family: result |= 0x00000004; break;          case TypeMemberVisibility.FamilyOrAssembly: result |= 0x00000005; break;          case TypeMemberVisibility.Public: result |= 0x00000006; break;        }
Missing Default,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeMetadataConstantValue,The following switch statement is missing a default case: switch (ic.GetTypeCode()) {            case TypeCode.Boolean: writer.WriteBool(ic.ToBoolean(null)); break;            case TypeCode.Byte: writer.WriteByte(ic.ToByte(null)); break;            case TypeCode.Char: writer.WriteUshort((ushort)ic.ToChar(null)); break;            case TypeCode.Double: writer.WriteDouble(ic.ToDouble(null)); break;            case TypeCode.Int16: writer.WriteShort(ic.ToInt16(null)); break;            case TypeCode.Int32: writer.WriteInt(ic.ToInt32(null)); break;            case TypeCode.Int64: writer.WriteLong(ic.ToInt64(null)); break;            case TypeCode.SByte: writer.WriteSbyte(ic.ToSByte(null)); break;            case TypeCode.Single: writer.WriteFloat(ic.ToSingle(null)); break;            case TypeCode.String: writer.WriteString(ic.ToString(null)); break;            case TypeCode.UInt16: writer.WriteUshort(ic.ToUInt16(null)); break;            case TypeCode.UInt32: writer.WriteUint(ic.ToUInt32(null)); break;            case TypeCode.UInt64: writer.WriteUlong(ic.ToUInt64(null)); break;          }
Missing Default,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeMethodBodyIL,The following switch statement is missing a default case: switch (operation.OperationCode) {            case OperationCode.Array_Addr:            case OperationCode.Array_Get:            case OperationCode.Array_Set:              writer.WriteByte((byte)OperationCode.Call);              writer.WriteUint(this.GetMethodRefTokenFor((IArrayTypeReference)operation.Value' operation.OperationCode));              continue;            case OperationCode.Array_Create:            case OperationCode.Array_Create_WithLowerBound:              writer.WriteByte((byte)OperationCode.Newobj);              writer.WriteUint(this.GetMethodRefTokenFor((IArrayTypeReference)operation.Value' operation.OperationCode));              continue;          }
Missing Default,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeExceptionInformation,The following switch statement is missing a default case: switch (exceptionInfo.HandlerKind) {          case HandlerKind.Catch: writer.WriteUshort(0x0000); break;          case HandlerKind.Filter: writer.WriteUshort(0x0001); break;          case HandlerKind.Finally: writer.WriteUshort(0x0002); break;          case HandlerKind.Fault: writer.WriteUshort(0x0004); break;        }
Missing Default,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,SerializeTypeReference,The following switch statement is missing a default case: switch (typeReference.TypeCode) {          case PrimitiveTypeCode.Void:            writer.WriteByte(0x01); return;          case PrimitiveTypeCode.Boolean:            writer.WriteByte(0x02); return;          case PrimitiveTypeCode.Char:            writer.WriteByte(0x03); return;          case PrimitiveTypeCode.Int8:            writer.WriteByte(0x04); return;          case PrimitiveTypeCode.UInt8:            writer.WriteByte(0x05); return;          case PrimitiveTypeCode.Int16:            writer.WriteByte(0x06); return;          case PrimitiveTypeCode.UInt16:            writer.WriteByte(0x07); return;          case PrimitiveTypeCode.Int32:            writer.WriteByte(0x08); return;          case PrimitiveTypeCode.UInt32:            writer.WriteByte(0x09); return;          case PrimitiveTypeCode.Int64:            writer.WriteByte(0x0a); return;          case PrimitiveTypeCode.UInt64:            writer.WriteByte(0x0b); return;          case PrimitiveTypeCode.Float32:            writer.WriteByte(0x0c); return;          case PrimitiveTypeCode.Float64:            writer.WriteByte(0x0d); return;          case PrimitiveTypeCode.String:            writer.WriteByte(0x0e); return;          case PrimitiveTypeCode.Pointer:            IPointerTypeReference/*?*/ pointerTypeReference = null;            if ((pointerTypeReference = typeReference as IPointerTypeReference) != null) {              if (noTokens)                this.SerializeTypeName(pointerTypeReference' writer);              else {                writer.WriteByte(0x0f); this.SerializeTypeReference(pointerTypeReference.TargetType' writer);              }              return;            }            break;          case PrimitiveTypeCode.Reference:            IManagedPointerTypeReference/*?*/ managedPointerTypeReference = null;            if ((managedPointerTypeReference = typeReference as IManagedPointerTypeReference) != null) {              if (noTokens)                this.SerializeTypeName(managedPointerTypeReference' writer);              else {                writer.WriteByte(0x10); this.SerializeTypeReference(managedPointerTypeReference.TargetType' writer);              }              return;            }            break;          case PrimitiveTypeCode.IntPtr:            writer.WriteByte(0x18); return;          case PrimitiveTypeCode.UIntPtr:            writer.WriteByte(0x19); return;        }
Missing Default,Microsoft.Cci,PeWriter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,WriteHeaders,The following switch statement is missing a default case: switch (module.Kind) {          case ModuleKind.ConsoleApplication:          case ModuleKind.DynamicallyLinkedLibrary:            writer.WriteUshort(3); //70            break;          case ModuleKind.WindowsApplication:            writer.WriteUshort(2); //70            break;        }
Missing Default,Microsoft.Cci,DummyArrayMethodReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeWriter\PeWriter.cs,DummyArrayMethodReference,The following switch statement is missing a default case: switch (this.arrayOperation) {          case OperationCode.Array_Addr: name = nameTable.Address; break;          case OperationCode.Array_Create:          case OperationCode.Array_Create_WithLowerBound: name = nameTable.Ctor; break;          case OperationCode.Array_Get: name = nameTable.Get; break;          case OperationCode.Array_Set: name = nameTable.Set; break;        }
