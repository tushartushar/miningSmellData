Implementation smell,Namespace,Class,File,Method,Description
Long Method,Microsoft.Cci.MetadataReader,ILReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\ILReader.cs,PopulateCilInstructions,The method has 436 lines of code.
Long Method,Microsoft.Cci.MetadataReader,CoreTypes,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\CoreTypes.cs,CoreTypes,The method has 239 lines of code.
Long Method,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetTypeReference,The method has 104 lines of code.
Long Method,Microsoft.Cci.MetadataReader,TypeSpecSignatureConverter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,TypeSpecSignatureConverter,The method has 117 lines of code.
Long Method,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\ILReader.cs,PopulateCilInstructions,The method has 436 lines of code.
Long Method,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The method has 230 lines of code.
Complex Method,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ParsePossiblyGenericTypeName,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ParseAssemblyName,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.MetadataReader.ObjectModelImplementation,CustomAttributeDecoder,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,CustomAttributeDecoder,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.Cci.MetadataReader.ObjectModelImplementation,SecurityAttributeDecoder20,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ReadSecurityAttribute,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NamespaceTypeNameTypeReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,UseNameToResolveTypeCode,Cyclomatic complexity of the method is 20
Complex Method,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeBase,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,ResolveMethodReference,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci.MetadataReader.ObjectModelImplementation,SignatureGenericTypeParameter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,SignatureGenericTypeParameter,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeCache,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,CompareParameters,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.MetadataReader,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ParsePossiblyGenericTypeName,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.MetadataReader,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ParseAssemblyName,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.MetadataReader,CustomAttributeDecoder,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,CustomAttributeDecoder,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.Cci.MetadataReader,SecurityAttributeDecoder20,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ReadSecurityAttribute,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetWin32Resources,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetFieldMapping,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetCustomModifiers,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetModuleFuntionPointer,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.MetadataReader,MethodDefSignatureConverter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,MethodDefSignatureConverter,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ReadPEFileLevelData,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ReadMetadataTableInformation,Cyclomatic complexity of the method is 8
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,FieldOrPropertyNamedArgumentExpression,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,FieldOrPropertyNamedArgumentExpression,The method has 5 parameters. Parameters: name' containingType' isField' fieldOrPropTypeReference' expressionValue
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,CustomAttribute,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,CustomAttribute,The method has 5 parameters. Parameters: peFileToObjectModel' attributeRowId' constructor' arguments' namedArguments
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,Module,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\BinaryObjectModel.cs,Module,The method has 5 parameters. Parameters: peFileToObjectModel' moduleName' cor20Flags' internedModuleId' moduleIdentity
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,Assembly,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\BinaryObjectModel.cs,Assembly,The method has 8 parameters. Parameters: peFileToObjectModel' moduleName' corFlags' internedModuleId' assemblyIdentity' assemblyName' assemblyFlags' publicKey
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,FieldDefinition,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\BinaryObjectModel.cs,FieldDefinition,The method has 5 parameters. Parameters: peFileToObjectModel' memberName' parentModuleType' fieldDefRowId' fieldFlags
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GlobalFieldDefinition,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\BinaryObjectModel.cs,GlobalFieldDefinition,The method has 7 parameters. Parameters: peFileToObjectModel' typeMemberName' parentModuleType' fieldDefRowId' fieldFlags' namespaceMemberName' parentModuleNamespace
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,MethodDefinition,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\BinaryObjectModel.cs,MethodDefinition,The method has 6 parameters. Parameters: peFileToObjectModel' memberName' parentModuleType' methodDefRowId' methodFlags' methodImplFlags
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NonGenericMethod,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\BinaryObjectModel.cs,NonGenericMethod,The method has 6 parameters. Parameters: peFileToObjectModel' memberName' parentModuleType' methodDefRowId' methodFlags' methodImplFlags
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GlobalNonGenericMethod,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\BinaryObjectModel.cs,GlobalNonGenericMethod,The method has 8 parameters. Parameters: peFileToObjectModel' memberName' parentModuleType' methodDefRowId' methodFlags' methodImplFlags' namespaceMemberName' parentModuleNamespace
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericMethod,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\BinaryObjectModel.cs,GenericMethod,The method has 8 parameters. Parameters: peFileToObjectModel' memberName' parentModuleType' methodDefRowId' methodFlags' methodImplFlags' genericParamRowIdStart' genericParamRowIdEnd
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GlobalGenericMethod,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\BinaryObjectModel.cs,GlobalGenericMethod,The method has 10 parameters. Parameters: peFileToObjectModel' memberName' parentModuleType' methodDefRowId' methodFlags' methodImplFlags' genericParamRowIdStart' genericParamRowIdEnd' namespaceMemberName' parentModuleNamespace
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,EventDefinition,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\BinaryObjectModel.cs,EventDefinition,The method has 5 parameters. Parameters: peFileToObjectModel' memberName' parentModuleType' eventRowId' eventFlags
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,PropertyDefinition,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\BinaryObjectModel.cs,PropertyDefinition,The method has 5 parameters. Parameters: peFileToObjectModel' memberName' parentModuleType' propertyRowId' propertyFlags
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,SpecializedNestedTypeFieldReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\BinaryObjectModel.cs,SpecializedNestedTypeFieldReference,The method has 5 parameters. Parameters: peFileToObjectModel' memberRefRowId' parentTypeReference' specializedParentTypeReference' name
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,MethodReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\BinaryObjectModel.cs,MethodReference,The method has 5 parameters. Parameters: peFileToObjectModel' memberRefRowId' parentTypeReference' name' firstByte
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericInstanceMethodReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\BinaryObjectModel.cs,GenericInstanceMethodReference,The method has 5 parameters. Parameters: peFileToObjectModel' memberRefRowId' parentTypeReference' name' firstByte
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,SpecializedNestedTypeMethodReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\BinaryObjectModel.cs,SpecializedNestedTypeMethodReference,The method has 6 parameters. Parameters: peFileToObjectModel' memberRefRowId' parentTypeReference' specializedParentTypeReference' name' firstByte
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,Win32Resource,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\BinaryObjectModel.cs,Win32Resource,The method has 7 parameters. Parameters: peFileTOObjectModel' typeIdOrName' idOrName' languageIdOrName' rvaToData' size' codePage
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,ResourceReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\BinaryObjectModel.cs,ResourceReference,The method has 5 parameters. Parameters: peFileToObjectModel' resourceRowId' definingAssembly' flags' name
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,Resource,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\BinaryObjectModel.cs,Resource,The method has 5 parameters. Parameters: peFileToObjectModel' resourceRowId' name' flags' inExternalFile
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,CoreTypeReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,CoreTypeReference,The method has 6 parameters. Parameters: peFileToObjectModel' moduleReference' namespaceReference' typeName' genericParamCount' signatureTypeCode
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeRefReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,TypeRefReference,The method has 5 parameters. Parameters: peFileToObjectModel' typeName' typeRefRowId' moduleReference' isValueType
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NamespaceTypeRefReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,NamespaceTypeRefReference,The method has 6 parameters. Parameters: peFileToObjectModel' typeName' typeRefRowId' moduleReference' namespaceReference' isValueType
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NonGenericNamespaceTypeRefReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,NonGenericNamespaceTypeRefReference,The method has 6 parameters. Parameters: peFileToObjectModel' typeName' typeRefRowId' moduleReference' namespaceReference' isValueType
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericNamespaceTypeRefReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,GenericNamespaceTypeRefReference,The method has 8 parameters. Parameters: peFileToObjectModel' typeName' typeRefRowId' moduleReference' namespaceReference' mangledTypeName' genericParamCount' isValueType
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NamespaceTypeRefReferenceWithoutPrimitiveTypeCode,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,NamespaceTypeRefReferenceWithoutPrimitiveTypeCode,The method has 6 parameters. Parameters: peFileToObjectModel' typeName' typeRefRowId' moduleReference' namespaceReference' isValueType
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NamespaceTypeRefReferenceWithPrimitiveTypeCode,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,NamespaceTypeRefReferenceWithPrimitiveTypeCode,The method has 6 parameters. Parameters: peFileToObjectModel' typeName' typeRefRowId' moduleReference' namespaceReference' signatureTypeCode
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NestedTypeRefReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,NestedTypeRefReference,The method has 6 parameters. Parameters: peFileToObjectModel' typeName' typeRefRowId' moduleReference' parentTypeReference' isValueType
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NonGenericNestedTypeRefReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,NonGenericNestedTypeRefReference,The method has 6 parameters. Parameters: peFileToObjectModel' typeName' typeRefRowId' moduleReference' parentTypeReference' isValueType
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericNestedTypeRefReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,GenericNestedTypeRefReference,The method has 8 parameters. Parameters: peFileToObjectModel' typeName' typeRefRowId' moduleReference' parentTypeReference' mangledTypeName' genericParamCount' isValueType
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NamespaceType,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,NamespaceType,The method has 5 parameters. Parameters: peFileToObjectModel' typeName' typeDefRowId' typeDefFlags' parentModuleNamespace
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NonGenericNamespaceType,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,NonGenericNamespaceType,The method has 5 parameters. Parameters: peFileToObjectModel' memberName' typeDefRowId' typeDefFlags' parentModuleNamespace
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NonGenericNamespaceTypeWithoutPrimitiveType,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,NonGenericNamespaceTypeWithoutPrimitiveType,The method has 5 parameters. Parameters: peFileToObjectModel' memberName' typeDefRowId' typeDefFlags' parentModuleNamespace
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,_Module_Type,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,_Module_Type,The method has 5 parameters. Parameters: peFileToObjectModel' memberName' typeDefRowId' typeDefFlags' parentModuleNamespace
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NonGenericNamespaceTypeWithPrimitiveType,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,NonGenericNamespaceTypeWithPrimitiveType,The method has 6 parameters. Parameters: peFileToObjectModel' memberName' typeDefRowId' typeDefFlags' parentModuleNamespace' signatureTypeCode
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericNamespaceType,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,GenericNamespaceType,The method has 8 parameters. Parameters: peFileToObjectModel' unmangledName' typeDefRowId' typeDefFlags' parentModuleNamespace' mangledName' genericParamRowIdStart' genericParamRowIdEnd
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NestedType,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,NestedType,The method has 5 parameters. Parameters: peFileToObjectModel' typeName' typeDefRowId' typeDefFlags' parentModuleType
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NonGenericNestedType,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,NonGenericNestedType,The method has 5 parameters. Parameters: peFileToObjectModel' memberName' typeDefRowId' typeDefFlags' parentModuleType
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericNestedType,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,GenericNestedType,The method has 8 parameters. Parameters: peFileToObjectModel' unmangledName' typeDefRowId' typeDefFlags' parentModuleType' mangledName' genericParamRowIdStart' genericParamRowIdEnd
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericParameter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,GenericParameter,The method has 5 parameters. Parameters: peFileToObjectModel' genericParameterOrdinality' genericParamFlags' genericParamName' genericParameterRowId
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericTypeParameter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,GenericTypeParameter,The method has 6 parameters. Parameters: peFileToObjectModel' genericParameterOrdinality' genericParamFlags' genericParamName' genericParameterRowId' owningGenericType
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericMethodParameter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,GenericMethodParameter,The method has 6 parameters. Parameters: peFileToObjectModel' genericParameterOrdinality' genericParamFlags' genericParamName' genericParameterRowId' owningGenericMethod
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,MatrixType,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,MatrixType,The method has 6 parameters. Parameters: peFileToObjectModel' typeSpecToken' elementType' rank' sizes' lowerBounds
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,FunctionPointerType,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,FunctionPointerType,The method has 8 parameters. Parameters: peFileToObjectModel' typeSpecToken' callingConvention' returnCustomModifiers' isReturnByReference' returnType' moduleParameters' moduleVarargsParameters
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,SpecializedNestedGenericTypeReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,SpecializedNestedGenericTypeReference,The method has 5 parameters. Parameters: peFileToObjectModel' typeSpecToken' parentGenericTypeReference' unspecializedVersion' genericParameterCount
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,ExportedTypeNamespaceAlias,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,ExportedTypeNamespaceAlias,The method has 5 parameters. Parameters: peFileToObjectModel' typeName' exportedTypeDefRowId' typeDefFlags' parentModuleNamespace
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,ExportedTypeNestedAlias,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,ExportedTypeNestedAlias,The method has 5 parameters. Parameters: peFileToObjectModel' typeName' exportedTypeDefRowId' typeDefFlags' parentExportedTypeAlias
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,Parameter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,Parameter,The method has 5 parameters. Parameters: peFileToObjectModel' parameterIndex' moduleCustomModifiers' typeReference' containingSignatureDefinition
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,ParameterInfo,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,ParameterInfo,The method has 6 parameters. Parameters: peFileToObjectModel' parameterIndex' moduleCustomModifiers' typeReference' containingSignatureDefinition' isByReference
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,ParameterWithMetadata,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,ParameterWithMetadata,The method has 10 parameters. Parameters: peFileToObjectModel' parameterIndex' moduleCustomModifiers' typeReference' containingSignatureDefinition' isByReference' possibleParamArray' paramRowId' parameterName' parameterFlags
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,ParameterWithoutMetadata,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,ParameterWithoutMetadata,The method has 6 parameters. Parameters: peFileToObjectModel' parameterIndex' moduleCustomModifiers' typeReference' containingSignatureDefinition' isByReference
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeCache,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,CreateCoreTypeReference,The method has 5 parameters. Parameters: coreAssemblyReference' namespaceReference' typeName' genericParameterCount' signatureTypeCode
Long Parameter List,Microsoft.Cci.MetadataReader,FieldOrPropertyNamedArgumentExpression,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,FieldOrPropertyNamedArgumentExpression,The method has 5 parameters. Parameters: name' containingType' isField' fieldOrPropTypeReference' expressionValue
Long Parameter List,Microsoft.Cci.MetadataReader,CustomAttribute,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,CustomAttribute,The method has 5 parameters. Parameters: peFileToObjectModel' attributeRowId' constructor' arguments' namedArguments
Long Parameter List,Microsoft.Cci.MetadataReader,LocalVariableDefinition,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\ILReader.cs,LocalVariableDefinition,The method has 6 parameters. Parameters: methodBody' customModifiers' isPinned' isReference' index' typeReference
Long Parameter List,Microsoft.Cci.MetadataReader,CilExceptionInformation,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\ILReader.cs,CilExceptionInformation,The method has 7 parameters. Parameters: handlerKind' exceptionType' tryStartOffset' tryEndOffset' filterDecisionStartOffset' handlerStartOffset' handlerEndOffset
Long Parameter List,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,PEFileToObjectModel,The method has 5 parameters. Parameters: peReader' peFileReader' moduleIdentity' containingAssembly' pointerSize
Long Parameter List,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,CreateTypeRefReference,The method has 5 parameters. Parameters: typeRefRowId' typeRefRow' parentModuleTypeReference' moduleReference' signatureTypeCode
Long Parameter List,Microsoft.Cci.MetadataReader.MethodBody,LocalVariableDefinition,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\ILReader.cs,LocalVariableDefinition,The method has 6 parameters. Parameters: methodBody' customModifiers' isPinned' isReference' index' typeReference
Long Parameter List,Microsoft.Cci.MetadataReader.MethodBody,CilExceptionInformation,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\ILReader.cs,CilExceptionInformation,The method has 7 parameters. Parameters: handlerKind' exceptionType' tryStartOffset' tryEndOffset' filterDecisionStartOffset' handlerStartOffset' handlerEndOffset
Long Parameter List,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\UnmanagedReadWrite.cs,BinarySearchForSlot,The method has 5 parameters. Parameters: numberOfRows' rowSize' referenceOffset' referenceValue' isReferenceSmall
Long Parameter List,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\UnmanagedReadWrite.cs,BinarySearchReference,The method has 5 parameters. Parameters: numberOfRows' rowSize' referenceOffset' referenceValue' isReferenceSmall
Long Parameter List,Microsoft.Cci.MetadataReader.PEFileFlags,ModuleRow,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,ModuleRow,The method has 5 parameters. Parameters: generation' name' mvId' encId' encBaseId
Long Parameter List,Microsoft.Cci.MetadataReader.PEFileFlags,TypeDefRow,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,TypeDefRow,The method has 6 parameters. Parameters: flags' name' namespace' extends' fieldList' methodList
Long Parameter List,Microsoft.Cci.MetadataReader.PEFileFlags,MethodRow,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,MethodRow,The method has 6 parameters. Parameters: rva' implFlags' flags' name' signature' paramList
Long Parameter List,Microsoft.Cci.MetadataReader.PEFileFlags,AssemblyRow,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,AssemblyRow,The method has 9 parameters. Parameters: hashAlgId' majorVersion' minorVersion' buildNumber' revisionNumber' flags' publicKey' name' culture
Long Parameter List,Microsoft.Cci.MetadataReader.PEFileFlags,AssemblyRefRow,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,AssemblyRefRow,The method has 9 parameters. Parameters: majorVersion' minorVersion' buildNumber' revisionNumber' flags' publicKeyOrToken' name' culture' hashValue
Long Parameter List,Microsoft.Cci.MetadataReader.PEFileFlags,ExportedTypeRow,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,ExportedTypeRow,The method has 5 parameters. Parameters: typeDefFlags' TypeDefId' typeName' typeNamespace' implementation
Long Parameter List,Microsoft.Cci.MetadataReader.PEFileFlags,SEHTableEntry,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,SEHTableEntry,The method has 6 parameters. Parameters: sehFlags' tryOffset' tryLength' handlerOffset' handlerLength' classTokenOrFilterOffset
Long Parameter List,Microsoft.Cci.MetadataReader.PEFileFlags,MethodIL,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,MethodIL,The method has 5 parameters. Parameters: localVariablesInited' maxStack' localSignatureToken' encodedILMemoryBlock' sehTable
Long Parameter List,Microsoft.Cci.MetadataReader.PEFile,ModuleRow,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,ModuleRow,The method has 5 parameters. Parameters: generation' name' mvId' encId' encBaseId
Long Parameter List,Microsoft.Cci.MetadataReader.PEFile,TypeDefRow,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,TypeDefRow,The method has 6 parameters. Parameters: flags' name' namespace' extends' fieldList' methodList
Long Parameter List,Microsoft.Cci.MetadataReader.PEFile,MethodRow,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,MethodRow,The method has 6 parameters. Parameters: rva' implFlags' flags' name' signature' paramList
Long Parameter List,Microsoft.Cci.MetadataReader.PEFile,AssemblyRow,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,AssemblyRow,The method has 9 parameters. Parameters: hashAlgId' majorVersion' minorVersion' buildNumber' revisionNumber' flags' publicKey' name' culture
Long Parameter List,Microsoft.Cci.MetadataReader.PEFile,AssemblyRefRow,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,AssemblyRefRow,The method has 9 parameters. Parameters: majorVersion' minorVersion' buildNumber' revisionNumber' flags' publicKeyOrToken' name' culture' hashValue
Long Parameter List,Microsoft.Cci.MetadataReader.PEFile,ExportedTypeRow,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,ExportedTypeRow,The method has 5 parameters. Parameters: typeDefFlags' TypeDefId' typeName' typeNamespace' implementation
Long Parameter List,Microsoft.Cci.MetadataReader.PEFile,SEHTableEntry,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,SEHTableEntry,The method has 6 parameters. Parameters: sehFlags' tryOffset' tryLength' handlerOffset' handlerLength' classTokenOrFilterOffset
Long Parameter List,Microsoft.Cci.MetadataReader.PEFile,MethodIL,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,MethodIL,The method has 5 parameters. Parameters: localVariablesInited' maxStack' localSignatureToken' encodedILMemoryBlock' sehTable
Long Parameter List,Microsoft.Cci.MetadataReader.PEFile,TypeDefTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,TypeDefTableReader,The method has 6 parameters. Parameters: numberOfRows' fieldRefSize' methodRefSize' typeDefOrRefRefSize' stringHeapRefSize' buffer
Long Parameter List,Microsoft.Cci.MetadataReader.PEFile,MethodTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,MethodTableReader,The method has 5 parameters. Parameters: numberOfRows' paramRefSize' stringHeapRefSize' blobHeapRefSize' buffer
Long Parameter List,Microsoft.Cci.MetadataReader.PEFile,MemberRefTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,MemberRefTableReader,The method has 5 parameters. Parameters: numberOfRows' memberRefParentRefSize' stringHeapRefSize' blobHeapRefSize' buffer
Long Parameter List,Microsoft.Cci.MetadataReader.PEFile,CustomAttributeTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,CustomAttributeTableReader,The method has 5 parameters. Parameters: numberOfRows' hasCustomAttributeRefSize' customAttributeTypeRefSize' blobHeapRefSize' buffer
Long Parameter List,Microsoft.Cci.MetadataReader.PEFile,ImplMapTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ImplMapTableReader,The method has 5 parameters. Parameters: numberOfRows' moduleRefTableRowRefSize' memberForwardedRefSize' stringHeapRefSize' buffer
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,ScopedContainerMetadataObject<InternalMemberType;ExternalMemberType;ExternalContainerType>,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\BinaryObjectModel.cs,,The length of the parameter caseInsensitiveMemberHashTable is 30.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NestedNamespaceReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\BinaryObjectModel.cs,NestedNamespaceReference,The length of the parameter parentModuleNamespaceReference is 30.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NestedNamespaceReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\BinaryObjectModel.cs,,The length of the parameter ParentModuleNamespaceReference is 30.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericTypeInstanceMember,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\BinaryObjectModel.cs,GenericTypeInstanceMember,The length of the parameter owningModuleGenericTypeInstance is 31.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericTypeInstanceMember,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\BinaryObjectModel.cs,,The length of the parameter OwningModuleGenericTypeInstance is 31.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericTypeInstanceField,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\BinaryObjectModel.cs,GenericTypeInstanceField,The length of the parameter owningModuleGenericTypeInstance is 31.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericTypeInstanceMethod,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\BinaryObjectModel.cs,GenericTypeInstanceMethod,The length of the parameter owningModuleGenericTypeInstance is 31.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericTypeInstanceNonGenericMethod,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\BinaryObjectModel.cs,GenericTypeInstanceNonGenericMethod,The length of the parameter owningModuleGenericTypeInstance is 31.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericTypeInstanceNonGenericMethod,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\BinaryObjectModel.cs,GenericTypeInstanceNonGenericMethod,The length of the parameter rawTemplateModuleNonGenericMethod is 33.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericTypeInstanceNonGenericMethod,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\BinaryObjectModel.cs,,The length of the parameter RawTemplateModuleNonGenericMethod is 33.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericTypeInstanceGenericMethod,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\BinaryObjectModel.cs,GenericTypeInstanceGenericMethod,The length of the parameter owningModuleGenericTypeInstance is 31.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericTypeInstanceGenericMethod,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\BinaryObjectModel.cs,GenericTypeInstanceGenericMethod,The length of the parameter rawTemplateModuleGenericMethod is 30.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericTypeInstanceGenericMethod,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\BinaryObjectModel.cs,,The length of the parameter RawTemplateModuleGenericMethod is 30.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericTypeInstanceEvent,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\BinaryObjectModel.cs,GenericTypeInstanceEvent,The length of the parameter owningModuleGenericTypeInstance is 31.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericTypeInstanceProperty,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\BinaryObjectModel.cs,GenericTypeInstanceProperty,The length of the parameter owningModuleGenericTypeInstance is 31.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericMethodInstance,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\BinaryObjectModel.cs,GenericMethodInstance,The length of the parameter genericMethodInstanceReference is 30.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericMethodInstance,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\BinaryObjectModel.cs,,The length of the parameter GenericMethodInstanceReference is 30.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,SpecializedNestedTypeFieldReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\BinaryObjectModel.cs,SpecializedNestedTypeFieldReference,The length of the parameter specializedParentTypeReference is 30.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,SpecializedNestedTypeFieldReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\BinaryObjectModel.cs,,The length of the parameter specializedParentTypeReference is 30.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,SpecializedNestedTypeMethodReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\BinaryObjectModel.cs,SpecializedNestedTypeMethodReference,The length of the parameter specializedParentTypeReference is 30.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,SpecializedNestedTypeMethodReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\BinaryObjectModel.cs,,The length of the parameter specializedParentTypeReference is 30.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,SafeArrayMarshallingInformation,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\BinaryObjectModel.cs,SafeArrayMarshallingInformation,The length of the parameter safeArrayElementUserDefinedSubType is 34.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,SafeArrayMarshallingInformation,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\BinaryObjectModel.cs,,The length of the parameter safeArrayElementUserDefinedSubType is 34.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NamespaceTypeNameNamespaceReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,NamespaceTypeNameNamespaceReference,The length of the parameter namespaceTypeNameTypeReference is 30.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NamespaceTypeNameNamespaceReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,,The length of the parameter NamespaceTypeNameTypeReference is 30.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NestedNamespaceTypeNameNamespaceReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,NestedNamespaceTypeNameNamespaceReference,The length of the parameter namespaceTypeNameTypeReference is 30.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,RootNamespaceTypeNameNamespaceReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,RootNamespaceTypeNameNamespaceReference,The length of the parameter namespaceTypeNameTypeReference is 30.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericNestedType,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,SpecializeTypeDefinitionMemberInstance,The length of the parameter specializedNestedPartialGenericInstanceReference is 48.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericParameter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,,The length of the parameter genericParamConstraintRowIDStart is 32.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericParameter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,,The length of the parameter genericParamConstraintRowIDEnd is 30.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeSpecializedGenericTypeParameter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,TypeSpecializedGenericTypeParameter,The length of the parameter rawTemplateGenericTypeParameter is 31.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeSpecializedGenericTypeParameter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,,The length of the parameter RawTemplateGenericTypeParameter is 31.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeSpecializedGenericMethodParameter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,TypeSpecializedGenericMethodParameter,The length of the parameter rawTemplateGenericMethodParameter is 33.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeSpecializedGenericMethodParameter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,,The length of the parameter RawTemplateGenericMethodParameter is 33.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NestedTypeGenericInstanceWithOwnerGenericInstanceReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,SpecializeTypeInstance,The length of the parameter specializedNestedGenericTypeReference is 37.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NestedTypeGenericInstanceWithOwnerGenericInstanceReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,SpecializeMethodInstance,The length of the parameter specializedNestedGenericTypeReference is 37.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NestedTypeGenericInstanceWithOwnerGenericInstanceReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,GetGenericTypeArgumentFromOrdinal,The length of the parameter parentGenericTypeArgCardinality is 31.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NestedTypeGenericInstanceWithOwnerGenericInstanceReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,,The length of the parameter NestedTypeGenericInstanceWithOwnerGenericInstance is 49.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NestedTypeGenericInstanceWithOwnerNonGenericInstanceReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,,The length of the parameter NestedTypeGenericInstanceWithOwnerNonGenericInstance is 52.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,SpecializedNestedNonGenericTypeReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,,The length of the parameter SpecializedNestedNonGenericType is 31.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NamespaceTypeGenericInstance,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,NamespaceTypeGenericInstance,The length of the parameter namespaceTypeGenericInstanceReference is 37.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NamespaceTypeGenericInstance,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,,The length of the parameter NamespaceTypeGenericInstanceReference is 37.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NestedTypeGenericInstanceWithOwnerGenericInstance,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,NestedTypeGenericInstanceWithOwnerGenericInstance,The length of the parameter nestedTypeGenericInstanceWithOwnerGenericInstanceReference is 58.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NestedTypeGenericInstanceWithOwnerGenericInstance,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,,The length of the parameter NestedTypeGenericInstanceWithOwnerGenericInstanceReference is 58.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NestedTypeGenericInstanceWithOwnerNonGenericInstance,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,NestedTypeGenericInstanceWithOwnerNonGenericInstance,The length of the parameter nestedTypeGenericInstanceWithOwnerNonGenericInstanceReference is 61.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NestedTypeGenericInstanceWithOwnerNonGenericInstance,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,,The length of the parameter NestedTypeGenericInstanceWithOwnerNonGenericInstanceReference is 61.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,SpecializedNestedNonGenericType,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,SpecializedNestedNonGenericType,The length of the parameter specializedNestedNonGenericTypeReference is 40.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,SpecializedNestedNonGenericType,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,,The length of the parameter SpecializedNestedNonGenericTypeReference is 40.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,SpecializedNestedGenericType,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,SpecializedNestedGenericType,The length of the parameter specializedNestedGenericTypeReference is 37.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,SpecializedNestedGenericType,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,,The length of the parameter SpecializedNestedGenericTypeReference is 37.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeCache,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,GetSpecializedNestedPartialGenericInstanceReference,The length of the parameter parentGenericTypeInstanceReference is 34.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeCache,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,GetGenericTypeInstanceReferenceInternal,The length of the parameter numberOfTypeArgsUsedByNestedTypes is 33.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeCache,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,GetGenericTypeInstanceReferenceInternal,The length of the parameter parentGenericTypeInstanceReference is 34.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeCache,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,GetGenericTypeInstanceReferenceInternal,The length of the parameter specializedNestedGenericTypeReference is 37.
Long Identifier,Microsoft.Cci.MetadataReader,CoreTypes,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\CoreTypes.cs,,The length of the parameter SystemCollectionsGenericIList1 is 30.
Long Identifier,Microsoft.Cci.MetadataReader,CoreTypes,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\CoreTypes.cs,,The length of the parameter SystemCollectionsGenericICollection1 is 36.
Long Identifier,Microsoft.Cci.MetadataReader,CoreTypes,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\CoreTypes.cs,,The length of the parameter SystemCollectionsGenericIEnumerable1 is 36.
Long Identifier,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetConstraintInfoForGenericParam,The length of the parameter genericParamConstraintRowIdStart is 32.
Long Identifier,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetConstraintInfoForGenericParam,The length of the parameter genericParamConstraintRowIdEnd is 30.
Long Identifier,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetModuleMemberReferenceAtRowWorker,The length of the parameter specializedNestedTypeReference is 30.
Long Identifier,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,,The length of the parameter StringIndexToUnmangledNameTable is 31.
Long Identifier,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,,The length of the parameter contractAssemblySymbolicIdentity is 32.
Long Identifier,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,,The length of the parameter NamespaceReferenceINameHashtable is 32.
Long Identifier,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,,The length of the parameter ModuleTypeRefReferenceLoadState is 31.
Long Identifier,Microsoft.Cci.MetadataReader.PEFileFlags,PEFileConstants,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,,The length of the parameter SizeofOptionalHeaderStandardFields32 is 36.
Long Identifier,Microsoft.Cci.MetadataReader.PEFileFlags,PEFileConstants,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,,The length of the parameter SizeofOptionalHeaderStandardFields64 is 36.
Long Identifier,Microsoft.Cci.MetadataReader.PEFileFlags,PEFileConstants,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,,The length of the parameter SizeofOptionalHeaderNTAdditionalFields32 is 40.
Long Identifier,Microsoft.Cci.MetadataReader.PEFileFlags,PEFileConstants,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,,The length of the parameter SizeofOptionalHeaderNTAdditionalFields64 is 40.
Long Identifier,Microsoft.Cci.MetadataReader.PEFileFlags,PEFileConstants,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,,The length of the parameter NumberofOptionalHeaderDirectoryEntries is 38.
Long Identifier,Microsoft.Cci.MetadataReader.PEFileFlags,PEFileConstants,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,,The length of the parameter SizeofOptionalHeaderDirectoriesEntries is 38.
Long Identifier,Microsoft.Cci.MetadataReader.PEFileFlags,OptionalHeaderDirectoryEntries,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,,The length of the parameter ThreadLocalStorageTableDirectory is 32.
Long Identifier,Microsoft.Cci.MetadataReader.PEFileFlags,COR20Constants,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,,The length of the parameter CompressedMetadataTableStreamName is 33.
Long Identifier,Microsoft.Cci.MetadataReader.PEFileFlags,COR20Constants,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,,The length of the parameter UncompressedMetadataTableStreamName is 35.
Long Identifier,Microsoft.Cci.MetadataReader.PEFileFlags,COR20Header,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,,The length of the parameter ExportAddressTableJumpsDirectory is 32.
Long Identifier,Microsoft.Cci.MetadataReader.PEFileFlags,MetadataTableHeader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,GetNumberOfTablesPresent,The length of the parameter MASK_01010101010101010101010101010101 is 37.
Long Identifier,Microsoft.Cci.MetadataReader.PEFileFlags,MetadataTableHeader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,GetNumberOfTablesPresent,The length of the parameter MASK_00110011001100110011001100110011 is 37.
Long Identifier,Microsoft.Cci.MetadataReader.PEFileFlags,MetadataTableHeader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,GetNumberOfTablesPresent,The length of the parameter MASK_00001111000011110000111100001111 is 37.
Long Identifier,Microsoft.Cci.MetadataReader.PEFileFlags,MetadataTableHeader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,GetNumberOfTablesPresent,The length of the parameter MASK_00000000111111110000000011111111 is 37.
Long Identifier,Microsoft.Cci.MetadataReader.PEFileFlags,MetadataTableHeader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,GetNumberOfTablesPresent,The length of the parameter MASK_00000000000000001111111111111111 is 37.
Long Identifier,Microsoft.Cci.MetadataReader.PEFileFlags,MetadataTableHeader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,GetNumberOfTablesPresent,The length of the parameter MASK_11111111111111111111111111111111 is 37.
Long Identifier,Microsoft.Cci.MetadataReader.PEFile,PEFileConstants,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,,The length of the parameter SizeofOptionalHeaderStandardFields32 is 36.
Long Identifier,Microsoft.Cci.MetadataReader.PEFile,PEFileConstants,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,,The length of the parameter SizeofOptionalHeaderStandardFields64 is 36.
Long Identifier,Microsoft.Cci.MetadataReader.PEFile,PEFileConstants,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,,The length of the parameter SizeofOptionalHeaderNTAdditionalFields32 is 40.
Long Identifier,Microsoft.Cci.MetadataReader.PEFile,PEFileConstants,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,,The length of the parameter SizeofOptionalHeaderNTAdditionalFields64 is 40.
Long Identifier,Microsoft.Cci.MetadataReader.PEFile,PEFileConstants,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,,The length of the parameter NumberofOptionalHeaderDirectoryEntries is 38.
Long Identifier,Microsoft.Cci.MetadataReader.PEFile,PEFileConstants,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,,The length of the parameter SizeofOptionalHeaderDirectoriesEntries is 38.
Long Identifier,Microsoft.Cci.MetadataReader.PEFile,OptionalHeaderDirectoryEntries,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,,The length of the parameter ThreadLocalStorageTableDirectory is 32.
Long Identifier,Microsoft.Cci.MetadataReader.PEFile,COR20Constants,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,,The length of the parameter CompressedMetadataTableStreamName is 33.
Long Identifier,Microsoft.Cci.MetadataReader.PEFile,COR20Constants,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,,The length of the parameter UncompressedMetadataTableStreamName is 35.
Long Identifier,Microsoft.Cci.MetadataReader.PEFile,COR20Header,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,,The length of the parameter ExportAddressTableJumpsDirectory is 32.
Long Identifier,Microsoft.Cci.MetadataReader.PEFile,MetadataTableHeader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,GetNumberOfTablesPresent,The length of the parameter MASK_01010101010101010101010101010101 is 37.
Long Identifier,Microsoft.Cci.MetadataReader.PEFile,MetadataTableHeader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,GetNumberOfTablesPresent,The length of the parameter MASK_00110011001100110011001100110011 is 37.
Long Identifier,Microsoft.Cci.MetadataReader.PEFile,MetadataTableHeader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,GetNumberOfTablesPresent,The length of the parameter MASK_00001111000011110000111100001111 is 37.
Long Identifier,Microsoft.Cci.MetadataReader.PEFile,MetadataTableHeader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,GetNumberOfTablesPresent,The length of the parameter MASK_00000000111111110000000011111111 is 37.
Long Identifier,Microsoft.Cci.MetadataReader.PEFile,MetadataTableHeader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,GetNumberOfTablesPresent,The length of the parameter MASK_00000000000000001111111111111111 is 37.
Long Identifier,Microsoft.Cci.MetadataReader.PEFile,MetadataTableHeader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,GetNumberOfTablesPresent,The length of the parameter MASK_11111111111111111111111111111111 is 37.
Long Identifier,Microsoft.Cci.MetadataReader.PEFile,InterfaceImplTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,,The length of the parameter InterfaceImplTableMemoryReader is 30.
Long Identifier,Microsoft.Cci.MetadataReader.PEFile,CustomAttributeTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,,The length of the parameter IsHasCustomAttributeRefSizeSmall is 32.
Long Identifier,Microsoft.Cci.MetadataReader.PEFile,CustomAttributeTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,,The length of the parameter IsCustomAttriubuteTypeRefSizeSmall is 34.
Long Identifier,Microsoft.Cci.MetadataReader.PEFile,CustomAttributeTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,,The length of the parameter CustomAttributeTableMemoryReader is 32.
Long Identifier,Microsoft.Cci.MetadataReader.PEFile,StandAloneSigTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,,The length of the parameter StandAloneSigTableMemoryReader is 30.
Long Identifier,Microsoft.Cci.MetadataReader.PEFile,PropertyPtrTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,,The length of the parameter IsPropertyTableRowRefSizeSmall is 30.
Long Identifier,Microsoft.Cci.MetadataReader.PEFile,MethodSemanticsTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,,The length of the parameter MethodSemanticsTableMemoryReader is 32.
Long Identifier,Microsoft.Cci.MetadataReader.PEFile,ImplMapTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,,The length of the parameter IsModuleRefTableRowRefSizeSmall is 31.
Long Identifier,Microsoft.Cci.MetadataReader.PEFile,ImplMapTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,,The length of the parameter IsMemberForwardRowRefSizeSmall is 30.
Long Identifier,Microsoft.Cci.MetadataReader.PEFile,AssemblyProcessorTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,,The length of the parameter AssemblyProcessorTableMemoryReader is 34.
Long Identifier,Microsoft.Cci.MetadataReader.PEFile,AssemblyRefProcessorTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,,The length of the parameter IsAssemblyRefTableRowSizeSmall is 30.
Long Identifier,Microsoft.Cci.MetadataReader.PEFile,AssemblyRefProcessorTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,,The length of the parameter AssemblyRefProcessorTableMemoryReader is 37.
Long Identifier,Microsoft.Cci.MetadataReader.PEFile,AssemblyRefOSTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,,The length of the parameter IsAssemblyRefTableRowRefSizeSmall is 33.
Long Identifier,Microsoft.Cci.MetadataReader.PEFile,AssemblyRefOSTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,,The length of the parameter AssemblyRefOSTableMemoryReader is 30.
Long Identifier,Microsoft.Cci.MetadataReader.PEFile,ManifestResourceTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,,The length of the parameter ManifestResourceTableMemoryReader is 33.
Long Identifier,Microsoft.Cci.MetadataReader.PEFile,GenericParamConstraintTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,,The length of the parameter IsGenericParamTableRowRefSizeSmall is 34.
Long Identifier,Microsoft.Cci.MetadataReader.PEFile,GenericParamConstraintTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,,The length of the parameter GenericParamConstraintTableMemoryReader is 39.
Long Identifier,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,,The length of the parameter OptionalHeaderNTAdditionalFields is 32.
Long Identifier,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,,The length of the parameter OptionalHeaderDirectoryEntries is 30.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericTypeName,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,GetAsTypeReference,The length of the statement  "        moduleTypeReferenceList[i] = this.GenericArguments[i].GetAsTypeReference(peFileToObjectModel' peFileToObjectModel.Module); " is 122.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,AssemblyQualifiedTypeName,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,GetAsTypeReference,The length of the statement  "      return this.TypeName.GetAsTypeReference(peFileToObjectModel' new AssemblyReference(peFileToObjectModel' 0' this.AssemblyIdentity' flags)); " is 138.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ScanBoolean,The length of the statement  "      if (currPtr + 4 <= this.Length && string.Compare(name.Substring(currPtr' 4)' "true"' StringComparison.OrdinalIgnoreCase) == 0) { " is 128.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ScanBoolean,The length of the statement  "      if (currPtr + 5 <= this.Length && string.Compare(name.Substring(currPtr' 5)' "false"' StringComparison.OrdinalIgnoreCase) == 0) { " is 129.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ScanPublicKeyToken,The length of the statement  "      if (currPtr + 4 <= this.Length && string.Compare(name.Substring(currPtr' 4)' "null"' StringComparison.OrdinalIgnoreCase) == 0) { " is 128.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ScanPublicKeyToken,The length of the statement  "        result = ulong.Parse(val' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture); " is 122.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ParseAssemblyName,The length of the statement  "          while (this.CurrentTypeNameTokenKind != TypeNameTokenKind.Comma && this.CurrentTypeNameTokenKind != TypeNameTokenKind.CloseBracket && this.CurrentTypeNameTokenKind != TypeNameTokenKind.EOS) { " is 191.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,AttributeDecoder,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,GetFieldOrPropType,The length of the statement  "            TypeNameTypeReference/*?*/ result = (TypeNameTypeReference)this.PEFileToObjectModel.GetSerializedTypeNameAsTypeReference(typeName); " is 131.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,AttributeDecoder,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ReadSerializedValue,The length of the statement  "            return new TypeOfExpression(this.PEFileToObjectModel' this.PEFileToObjectModel.GetSerializedTypeNameAsTypeReference(typeNameStr)); " is 130.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,AttributeDecoder,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ReadSerializedValue,The length of the statement  "            return new ArrayExpression(vectorType' new EnumerableArrayWrapper<ExpressionBase' IMetadataExpression>(arrayElements.ToArray()' Dummy.Expression)); " is 147.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,AttributeDecoder,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ReadSerializedValue,The length of the statement  "            // Problem is' that without resolving this reference' it is not possible to know how many bytes to consume for the enum value " is 125.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,AttributeDecoder,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ReadSerializedValue,The length of the statement  "            switch (this.PEFileToObjectModel.ModuleReader.metadataReaderHost.GuessUnderlyingTypeSizeOfUnresolvableReferenceToEnum(type)) { " is 126.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,SecurityAttributeDecoder20,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ReadSecurityAttribute,The length of the statement  "      IModuleTypeReference/*?*/ moduleTypeReference = this.PEFileToObjectModel.GetSerializedTypeNameAsTypeReference(typeNameStr); " is 123.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,SecurityAttributeDecoder20,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ReadSecurityAttribute,The length of the statement  "        foreach (ITypeDefinitionMember member in attributeType.GetMembersNamed(this.PEFileToObjectModel.NameTable.Ctor' false)) { " is 121.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,SecurityAttributeDecoder20,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ReadSecurityAttribute,The length of the statement  "          this.PEFileToObjectModel.NameTable.Ctor' 0' this.PEFileToObjectModel.PlatformType.SystemSecurityPermissionsSecurityAction); " is 123.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,SecurityAttributeDecoder20,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ReadSecurityAttribute,The length of the statement  "          namedArgumentArray[i] = new FieldOrPropertyNamedArgumentExpression(memberName' moduleTypeReference' isField' memberType' value); " is 128.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,SecurityAttributeDecoder20,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ReadSecurityAttribute,The length of the statement  "      EnumerableArrayWrapper<FieldOrPropertyNamedArgumentExpression' IMetadataNamedArgument> namedArguments = TypeCache.EmptyNamedArgumentList; " is 137.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,SecurityAttributeDecoder20,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ReadSecurityAttribute,The length of the statement  "        namedArguments = new EnumerableArrayWrapper<FieldOrPropertyNamedArgumentExpression' IMetadataNamedArgument>(namedArgumentArray' Dummy.NamedArgument); " is 149.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,ScopedContainerMetadataObject<InternalMemberType;ExternalMemberType;ExternalContainerType>,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\BinaryObjectModel.cs,GetMatchingMembersNamed,The length of the statement  "      MultiHashtable<InternalMemberType> hashTable = ignoreCase ? this.caseInsensitiveMemberHashTable : this.caseSensitiveMemberHashTable; " is 132.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,ScopedContainerMetadataObject<InternalMemberType;ExternalMemberType;ExternalContainerType>,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\BinaryObjectModel.cs,GetMembersNamed,The length of the statement  "      MultiHashtable<InternalMemberType> hashTable = ignoreCase ? this.caseInsensitiveMemberHashTable : this.caseSensitiveMemberHashTable; " is 132.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,MethodDefinition,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\BinaryObjectModel.cs,ToString,The length of the statement  "      return MemberHelper.GetMethodSignature(this' NameFormattingOptions.ReturnType|NameFormattingOptions.Signature|NameFormattingOptions.TypeParameters); " is 148.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericTypeInstanceMethod,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\BinaryObjectModel.cs,ToString,The length of the statement  "      return MemberHelper.GetMethodSignature(this' NameFormattingOptions.ReturnType|NameFormattingOptions.Signature|NameFormattingOptions.TypeParameters); " is 148.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericMethodInstanceReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\BinaryObjectModel.cs,ToString,The length of the statement  "      return MemberHelper.GetMethodSignature(this' NameFormattingOptions.ReturnType|NameFormattingOptions.TypeParameters|NameFormattingOptions.Signature); " is 148.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,MethodReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\BinaryObjectModel.cs,ToString,The length of the statement  "      return MemberHelper.GetMethodSignature(this' NameFormattingOptions.ReturnType|NameFormattingOptions.TypeParameters|NameFormattingOptions.Signature); " is 148.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericInstanceMethodReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\BinaryObjectModel.cs,InitMethodSignature,The length of the statement  "      this.requiredParameters = methodSignature.RequiredParameters; //Needed so that the method reference can be interned during specialization " is 137.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericInstanceMethodReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\BinaryObjectModel.cs,InitMethodSignature,The length of the statement  "      this.requiredParameters = TypeCache.SpecializeInstantiatedParameters(this' methodSignature.RequiredParameters' moduleGenericTypeInstance); " is 138.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericInstanceMethodReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\BinaryObjectModel.cs,InitMethodSignature,The length of the statement  "      this.varArgParameters = TypeCache.SpecializeInstantiatedParameters(this' methodSignature.VarArgParameters' moduleGenericTypeInstance); " is 134.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,SpecializedNestedTypeMethodReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\BinaryObjectModel.cs,InitMethodSignature,The length of the statement  "      this.requiredParameters = methodSignature.RequiredParameters; //Needed so that the method reference can be interned during specialization " is 137.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,SpecializedNestedTypeMethodReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\BinaryObjectModel.cs,InitMethodSignature,The length of the statement  "      this.requiredParameters = TypeCache.SpecializeInstantiatedParameters(this' methodSignature.RequiredParameters' moduleGenericTypeInstance); " is 138.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,SpecializedNestedTypeMethodReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\BinaryObjectModel.cs,InitMethodSignature,The length of the statement  "      this.varArgParameters = TypeCache.SpecializeInstantiatedParameters(this' methodSignature.VarArgParameters' moduleGenericTypeInstance); " is 134.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,ModifiedTypeReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,SpecializeTypeInstance,The length of the statement  "      IModuleTypeReference/*?*/ underlyingModuleTypeReference = this.UnderlyingModuleTypeReference.SpecializeTypeInstance(genericTypeInstance); " is 137.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,ModifiedTypeReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,SpecializeMethodInstance,The length of the statement  "      IModuleTypeReference/*?*/ underlyingModuleTypeReference = this.UnderlyingModuleTypeReference.SpecializeMethodInstance(genericMethodInstance); " is 141.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeBase,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,ResolveMethodReference,The length of the statement  "        if (!TypeCache.CompareParameters(mm.RequiredModuleParameterInfos.RawArray' methodReference.RequiredModuleParameterInfos.RawArray)) " is 130.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericNestedType,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,SpecializeTypeDefinitionMemberInstance,The length of the statement  "      SpecializedNestedPartialGenericInstanceReference specializedNestedPartialGenericInstanceReference = genericTypeInstance.PEFileToObjectModel.typeCache.GetSpecializedNestedPartialGenericInstanceReference(0xFFFFFFFF' genericTypeInstance.ModuleGenericTypeInstanceReference' this' this.GenericParameterCount); " is 304.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericTypeParameter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,SpecializeTypeInstance,The length of the statement  "      if (genPartialInstance != null) return this.SpecializeTypeInstance(genPartialInstance.GenericType.OwningGenericTypeInstance); " is 125.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericTypeParameter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,SpecializeTypeInstance,The length of the statement  "      if (genPartialInstanceRef != null) return this.SpecializeTypeInstance(genPartialInstanceRef.GenericTypeReference.ParentGenericTypeReference); " is 141.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericMethodParameter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,SpecializeTypeInstance,The length of the statement  "        genericTypeInstanceMethod = genericTypeInst.FindInstantiatedMemberFor(this.OwningGenericMethod) as GenericTypeInstanceMethod; " is 125.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,MatrixType,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,SpecializeTypeInstance,The length of the statement  "      return new MatrixType(this.PEFileToObjectModel' 0xFFFFFFFF' instantiatedElementType' (int)this.Rank' this.Sizes' this.LowerBounds); " is 131.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,MatrixType,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,SpecializeMethodInstance,The length of the statement  "      return new MatrixType(this.PEFileToObjectModel' 0xFFFFFFFF' instantiatedElementType' (int)this.Rank' this.Sizes' this.LowerBounds); " is 131.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NamespaceTypeGenericInstanceReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,SpecializeTypeInstance,The length of the statement  "      EnumerableArrayWrapper<IModuleTypeReference/*?*/' ITypeReference> newTypeArgs = TypeCache.SpecializeTypeInstance(this.TypeArguments' genericTypeInstance); " is 154.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NamespaceTypeGenericInstanceReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,SpecializeTypeInstance,The length of the statement  "      return new NamespaceTypeGenericInstanceReference(this.PEFileToObjectModel' 0xFFFFFFFF' this.GenericNamespaceType' newTypeArgs); " is 127.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NamespaceTypeGenericInstanceReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,SpecializeMethodInstance,The length of the statement  "      EnumerableArrayWrapper<IModuleTypeReference/*?*/' ITypeReference> newTypeArgs = TypeCache.SpecializeMethodInstance(this.TypeArguments' genericMethodInstance); " is 158.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NamespaceTypeGenericInstanceReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,SpecializeMethodInstance,The length of the statement  "      return new NamespaceTypeGenericInstanceReference(this.PEFileToObjectModel' 0xFFFFFFFF' this.GenericNamespaceType' newTypeArgs); " is 127.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NestedTypeGenericInstanceWithOwnerGenericInstanceReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,SpecializeTypeInstance,The length of the statement  "      SpecializedNestedGenericTypeReference/*?*/ specializedNestedGenericTypeReference = this.GenericTypeReference.SpecializeTypeInstance(genericTypeInstance) as SpecializedNestedGenericTypeReference; " is 194.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NestedTypeGenericInstanceWithOwnerGenericInstanceReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,SpecializeTypeInstance,The length of the statement  "      EnumerableArrayWrapper<IModuleTypeReference/*?*/' ITypeReference> newTypeArgs = TypeCache.SpecializeTypeInstance(this.TypeArguments' genericTypeInstance); " is 154.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NestedTypeGenericInstanceWithOwnerGenericInstanceReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,SpecializeTypeInstance,The length of the statement  "      return new NestedTypeGenericInstanceWithOwnerGenericInstanceReference(this.PEFileToObjectModel' 0xFFFFFFFF' specializedNestedGenericTypeReference' newTypeArgs); " is 160.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NestedTypeGenericInstanceWithOwnerGenericInstanceReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,SpecializeMethodInstance,The length of the statement  "      SpecializedNestedGenericTypeReference/*?*/ specializedNestedGenericTypeReference = this.GenericTypeReference.SpecializeMethodInstance(genericMethodInstance) as SpecializedNestedGenericTypeReference; " is 198.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NestedTypeGenericInstanceWithOwnerGenericInstanceReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,SpecializeMethodInstance,The length of the statement  "      EnumerableArrayWrapper<IModuleTypeReference/*?*/' ITypeReference> newTypeArgs = TypeCache.SpecializeMethodInstance(this.TypeArguments' genericMethodInstance); " is 158.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NestedTypeGenericInstanceWithOwnerGenericInstanceReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,SpecializeMethodInstance,The length of the statement  "      return new NestedTypeGenericInstanceWithOwnerGenericInstanceReference(this.PEFileToObjectModel' 0xFFFFFFFF' specializedNestedGenericTypeReference' newTypeArgs); " is 160.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NestedTypeGenericInstanceWithOwnerNonGenericInstanceReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,SpecializeTypeInstance,The length of the statement  "      EnumerableArrayWrapper<IModuleTypeReference/*?*/' ITypeReference> newTypeArgs = TypeCache.SpecializeTypeInstance(this.TypeArguments' genericTypeInstance); " is 154.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NestedTypeGenericInstanceWithOwnerNonGenericInstanceReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,SpecializeTypeInstance,The length of the statement  "      return new NestedTypeGenericInstanceWithOwnerNonGenericInstanceReference(this.PEFileToObjectModel' 0xFFFFFFFF' this.GenericTypeReference' newTypeArgs); " is 151.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NestedTypeGenericInstanceWithOwnerNonGenericInstanceReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,SpecializeMethodInstance,The length of the statement  "      EnumerableArrayWrapper<IModuleTypeReference/*?*/' ITypeReference> newTypeArgs = TypeCache.SpecializeMethodInstance(this.TypeArguments' genericMethodInstance); " is 158.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NestedTypeGenericInstanceWithOwnerNonGenericInstanceReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,SpecializeMethodInstance,The length of the statement  "      return new NestedTypeGenericInstanceWithOwnerNonGenericInstanceReference(this.PEFileToObjectModel' 0xFFFFFFFF' this.GenericTypeReference' newTypeArgs); " is 151.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,SpecializedNestedPartialGenericInstanceReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,SpecializeTypeInstance,The length of the statement  "      GenericTypeInstanceReference/*?*/ genericTypeInstanceReference = this.ParentGenericTypeReference.SpecializeTypeInstance(genericTypeInstance) as GenericTypeInstanceReference; " is 173.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,SpecializedNestedPartialGenericInstanceReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,SpecializeTypeInstance,The length of the statement  "      return this.PEFileToObjectModel.typeCache.GetSpecializedNestedPartialGenericInstanceReference(0xFFFFFFFF' genericTypeInstanceReference' this.unspecializedVersion' this.GenericParameterCount); " is 191.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,SpecializedNestedPartialGenericInstanceReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,SpecializeMethodInstance,The length of the statement  "      GenericTypeInstanceReference/*?*/ genericTypeInstanceReference = this.ParentGenericTypeReference.SpecializeMethodInstance(genericMethodInstance) as GenericTypeInstanceReference; " is 177.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,SpecializedNestedPartialGenericInstanceReference,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,SpecializeMethodInstance,The length of the statement  "      return this.PEFileToObjectModel.typeCache.GetSpecializedNestedPartialGenericInstanceReference(0xFFFFFFFF' genericTypeInstanceReference' this.unspecializedVersion' this.GenericParameterCount); " is 191.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeCache,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,CreateCoreTypeReference,The length of the statement  "      return new CoreTypeReference(this.PEFileToObjectModel' coreAssemblyReference' namespaceReference' typeName' 0' signatureTypeCode); " is 130.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeCache,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,CreateCoreTypeReference,The length of the statement  "      return new CoreTypeReference(this.PEFileToObjectModel' coreAssemblyReference' namespaceReference' typeName' genericParameterCount' signatureTypeCode); " is 150.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeCache,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,GetSpecializedNestedPartialGenericInstanceReference,The length of the statement  "        return new SpecializedNestedNonGenericTypeReference(this.PEFileToObjectModel' typeSpecToken' parentGenericTypeInstanceReference' unspecializedVersion); " is 151.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeCache,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,GetSpecializedNestedPartialGenericInstanceReference,The length of the statement  "        return new SpecializedNestedGenericTypeReference(this.PEFileToObjectModel' typeSpecToken' parentGenericTypeInstanceReference' unspecializedVersion' genericParameterCount); " is 171.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeCache,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,GetGenericTypeInstanceReferenceInternal,The length of the statement  "      //  This method returns null if the type that is being instantiated is not generic in the sense of persistence into module (cummulatively). " is 139.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeCache,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,GetGenericTypeInstanceReferenceInternal,The length of the statement  "        EnumerableArrayWrapper<IModuleTypeReference/*?*/' ITypeReference> genericTypeArgs = new EnumerableArrayWrapper<IModuleTypeReference/*?*/' ITypeReference>(TypeCache.GetSubArray(cummulativeGenericTypeArgs' startIndex' genParamCount)' Dummy.TypeReference); " is 253.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeCache,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,GetGenericTypeInstanceReferenceInternal,The length of the statement  "        return new NamespaceTypeGenericInstanceReference(this.PEFileToObjectModel' 0xFFFFFFFF' moduleNamespaceType' genericTypeArgs); " is 125.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeCache,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,GetGenericTypeInstanceReferenceInternal,The length of the statement  "      //^ assume rawTemplateTypeReference is IModuleNestedType; //if it is not a namespace type' it had better be a nested one. " is 121.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeCache,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,GetGenericTypeInstanceReferenceInternal,The length of the statement  "      GenericTypeInstanceReference/*?*/ parentGenericTypeInstanceReference = this.GetGenericTypeInstanceReferenceInternal(moduleNestedType.ParentTypeReference' " is 153.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeCache,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,GetGenericTypeInstanceReferenceInternal,The length of the statement  "        // For example' if only the nested generic type is instantiated and referenced' the no reference will exist to an instantiation " is 127.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeCache,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,GetGenericTypeInstanceReferenceInternal,The length of the statement  "        EnumerableArrayWrapper<IModuleTypeReference/*?*/' ITypeReference> genericTypeArgs = new EnumerableArrayWrapper<IModuleTypeReference/*?*/' ITypeReference>(TypeCache.GetSubArray(cummulativeGenericTypeArgs' startIndex' genParamCount)' Dummy.TypeReference); " is 253.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeCache,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,GetGenericTypeInstanceReferenceInternal,The length of the statement  "        return new NestedTypeGenericInstanceWithOwnerNonGenericInstanceReference(this.PEFileToObjectModel' 0xFFFFFFFF' moduleNestedType' genericTypeArgs); " is 146.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeCache,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,GetGenericTypeInstanceReferenceInternal,The length of the statement  "          return this.GetSpecializedNestedPartialGenericInstanceReference(0xFFFFFFFF' parentGenericTypeInstanceReference' moduleNestedType' genParamCount); " is 145.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeCache,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,GetGenericTypeInstanceReferenceInternal,The length of the statement  "          EnumerableArrayWrapper<IModuleTypeReference/*?*/' ITypeReference> genericTypeArgs = new EnumerableArrayWrapper<IModuleTypeReference/*?*/' ITypeReference>(TypeCache.GetSubArray(cummulativeGenericTypeArgs' startIndex' genParamCount)' Dummy.TypeReference); " is 253.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeCache,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,GetGenericTypeInstanceReferenceInternal,The length of the statement  "          SpecializedNestedGenericTypeReference/*?*/ specializedNestedGenericTypeReference = this.GetSpecializedNestedPartialGenericInstanceReference(0xFFFFFFFF' parentGenericTypeInstanceReference' moduleNestedType' genParamCount) as SpecializedNestedGenericTypeReference; " is 262.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeCache,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,GetGenericTypeInstanceReferenceInternal,The length of the statement  "          return new NestedTypeGenericInstanceWithOwnerGenericInstanceReference(this.PEFileToObjectModel' 0xFFFFFFFF' specializedNestedGenericTypeReference' genericTypeArgs); " is 164.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeCache,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,GetGenericTypeInstanceReference,The length of the statement  "      GenericTypeInstanceReference/*?*/ genericTypeInstanceReference = this.GetGenericTypeInstanceReferenceInternal(rawTemplateTypeReference' cummulativeGenericTypeArgs' 0' ref startIndex); " is 183.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeCache,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,SpecializeInstantiatedParameters,The length of the statement  "        IModuleTypeReference/*?*/ specializedTypeRef = unspecializedTypeRef != null ? unspecializedTypeRef.SpecializeTypeInstance(moduleGenericTypeInstance) : null; " is 156.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeCache,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,SpecializeInstantiatedParameters,The length of the statement  "        IModuleTypeReference/*?*/ specializedTypeRef = unspecializedTypeRef != null ? unspecializedTypeRef.SpecializeMethodInstance(moduleGenericMethodInstance) : null; " is 160.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeCache,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,SpecializeInstantiatedParameters,The length of the statement  "        IModuleTypeReference/*?*/ specializedTypeRef = unspecializedTypeRef != null ? unspecializedTypeRef.SpecializeTypeInstance(moduleGenericTypeInstance) : null; " is 156.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeCache,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,SpecializeInstantiatedParameters,The length of the statement  "      return new EnumerableArrayWrapper<IModuleParameterTypeInformation' IParameterTypeInformation>(instParamArray' Dummy.ParameterTypeInformation); " is 142.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeCache,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,SpecializeInstantiatedParameters,The length of the statement  "        IModuleTypeReference/*?*/ specializedTypeRef = unspecializedTypeRef != null ? unspecializedTypeRef.SpecializeMethodInstance(moduleGenericMethodInstance) : null; " is 160.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeCache,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,SpecializeInstantiatedParameters,The length of the statement  "      return new EnumerableArrayWrapper<IModuleParameterTypeInformation' IParameterTypeInformation>(instParamArray' Dummy.ParameterTypeInformation); " is 142.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeCache,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,SplitMangledTypeName,The length of the statement  "          genericParamCount = ushort.Parse(mangledTypeName.Substring(index + 1' mangledTypeName.Length - index - 1)' System.Globalization.NumberStyles.Integer' " is 149.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeCache,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,SplitMangledTypeName,The length of the statement  "      ushort.TryParse(mangledTypeName.Substring(index + 1' mangledTypeName.Length - index - 1)' System.Globalization.NumberStyles.Integer' " is 132.
Long Statement,Microsoft.Cci.MetadataReader,GenericTypeName,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,GetAsTypeReference,The length of the statement  "        moduleTypeReferenceList[i] = this.GenericArguments[i].GetAsTypeReference(peFileToObjectModel' peFileToObjectModel.Module); " is 122.
Long Statement,Microsoft.Cci.MetadataReader,AssemblyQualifiedTypeName,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,GetAsTypeReference,The length of the statement  "      return this.TypeName.GetAsTypeReference(peFileToObjectModel' new AssemblyReference(peFileToObjectModel' 0' this.AssemblyIdentity' flags)); " is 138.
Long Statement,Microsoft.Cci.MetadataReader,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ScanBoolean,The length of the statement  "      if (currPtr + 4 <= this.Length && string.Compare(name.Substring(currPtr' 4)' "true"' StringComparison.OrdinalIgnoreCase) == 0) { " is 128.
Long Statement,Microsoft.Cci.MetadataReader,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ScanBoolean,The length of the statement  "      if (currPtr + 5 <= this.Length && string.Compare(name.Substring(currPtr' 5)' "false"' StringComparison.OrdinalIgnoreCase) == 0) { " is 129.
Long Statement,Microsoft.Cci.MetadataReader,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ScanPublicKeyToken,The length of the statement  "      if (currPtr + 4 <= this.Length && string.Compare(name.Substring(currPtr' 4)' "null"' StringComparison.OrdinalIgnoreCase) == 0) { " is 128.
Long Statement,Microsoft.Cci.MetadataReader,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ScanPublicKeyToken,The length of the statement  "        result = ulong.Parse(val' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture); " is 122.
Long Statement,Microsoft.Cci.MetadataReader,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ParseAssemblyName,The length of the statement  "          while (this.CurrentTypeNameTokenKind != TypeNameTokenKind.Comma && this.CurrentTypeNameTokenKind != TypeNameTokenKind.CloseBracket && this.CurrentTypeNameTokenKind != TypeNameTokenKind.EOS) { " is 191.
Long Statement,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,GetFieldOrPropType,The length of the statement  "            TypeNameTypeReference/*?*/ result = (TypeNameTypeReference)this.PEFileToObjectModel.GetSerializedTypeNameAsTypeReference(typeName); " is 131.
Long Statement,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ReadSerializedValue,The length of the statement  "            return new TypeOfExpression(this.PEFileToObjectModel' this.PEFileToObjectModel.GetSerializedTypeNameAsTypeReference(typeNameStr)); " is 130.
Long Statement,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ReadSerializedValue,The length of the statement  "            return new ArrayExpression(vectorType' new EnumerableArrayWrapper<ExpressionBase' IMetadataExpression>(arrayElements.ToArray()' Dummy.Expression)); " is 147.
Long Statement,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ReadSerializedValue,The length of the statement  "            // Problem is' that without resolving this reference' it is not possible to know how many bytes to consume for the enum value " is 125.
Long Statement,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ReadSerializedValue,The length of the statement  "            switch (this.PEFileToObjectModel.ModuleReader.metadataReaderHost.GuessUnderlyingTypeSizeOfUnresolvableReferenceToEnum(type)) { " is 126.
Long Statement,Microsoft.Cci.MetadataReader,SecurityAttributeDecoder20,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ReadSecurityAttribute,The length of the statement  "      IModuleTypeReference/*?*/ moduleTypeReference = this.PEFileToObjectModel.GetSerializedTypeNameAsTypeReference(typeNameStr); " is 123.
Long Statement,Microsoft.Cci.MetadataReader,SecurityAttributeDecoder20,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ReadSecurityAttribute,The length of the statement  "        foreach (ITypeDefinitionMember member in attributeType.GetMembersNamed(this.PEFileToObjectModel.NameTable.Ctor' false)) { " is 121.
Long Statement,Microsoft.Cci.MetadataReader,SecurityAttributeDecoder20,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ReadSecurityAttribute,The length of the statement  "          this.PEFileToObjectModel.NameTable.Ctor' 0' this.PEFileToObjectModel.PlatformType.SystemSecurityPermissionsSecurityAction); " is 123.
Long Statement,Microsoft.Cci.MetadataReader,SecurityAttributeDecoder20,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ReadSecurityAttribute,The length of the statement  "          namedArgumentArray[i] = new FieldOrPropertyNamedArgumentExpression(memberName' moduleTypeReference' isField' memberType' value); " is 128.
Long Statement,Microsoft.Cci.MetadataReader,SecurityAttributeDecoder20,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ReadSecurityAttribute,The length of the statement  "      EnumerableArrayWrapper<FieldOrPropertyNamedArgumentExpression' IMetadataNamedArgument> namedArguments = TypeCache.EmptyNamedArgumentList; " is 137.
Long Statement,Microsoft.Cci.MetadataReader,SecurityAttributeDecoder20,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ReadSecurityAttribute,The length of the statement  "        namedArguments = new EnumerableArrayWrapper<FieldOrPropertyNamedArgumentExpression' IMetadataNamedArgument>(namedArgumentArray' Dummy.NamedArgument); " is 149.
Long Statement,Microsoft.Cci.MetadataReader,ILReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\ILReader.cs,LoadLocalSignature,The length of the statement  "        LocalVariableSignatureConverter locVarSigConv = new LocalVariableSignatureConverter(this.PEFileToObjectModel' this.MethodBody' memoryReader); " is 141.
Long Statement,Microsoft.Cci.MetadataReader,ILReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\ILReader.cs,GetStandAloneMethodSignature,The length of the statement  "      StandAloneSigRow sigRow = this.PEFileToObjectModel.PEFileReader.StandAloneSigTable[standAloneMethodToken & TokenTypeIds.RIDMask]; " is 129.
Long Statement,Microsoft.Cci.MetadataReader,ILReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\ILReader.cs,GetStandAloneMethodSignature,The length of the statement  "      MemoryBlock signatureMemoryBlock = this.PEFileToObjectModel.PEFileReader.BlobStream.GetMemoryBlockAt(signatureBlobOffset); " is 122.
Long Statement,Microsoft.Cci.MetadataReader,ILReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\ILReader.cs,GetStandAloneMethodSignature,The length of the statement  "      StandAloneMethodSignatureConverter standAloneSigConv = new StandAloneMethodSignatureConverter(this.PEFileToObjectModel' this.MethodDefinition' memoryReader); " is 157.
Long Statement,Microsoft.Cci.MetadataReader,ILReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\ILReader.cs,PopulateCilInstructions,The length of the statement  "            this.PEFileToObjectModel.PEFileReader.ErrorContainer.AddILError(this.MethodDefinition' offset' MetadataReaderErrorKind.UnknownILInstruction); " is 141.
Long Statement,Microsoft.Cci.MetadataReader,ILReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\ILReader.cs,PopulateCilInstructions,The length of the statement  "      this.MethodBody.SetCilInstructions(new EnumerableArrayWrapper<CilInstruction' IOperation>(instrList.ToArray()' Dummy.Operation)); " is 129.
Long Statement,Microsoft.Cci.MetadataReader,ILReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\ILReader.cs,PopulateExceptionInformation,The length of the statement  "            IModuleTypeReference/*?*/ typeRef = this.PEFileToObjectModel.GetTypeReferenceForToken(this.MethodDefinition' sehTableEntry.ClassTokenOrFilterOffset); " is 149.
Long Statement,Microsoft.Cci.MetadataReader,ILReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\ILReader.cs,PopulateExceptionInformation,The length of the statement  "      this.MethodBody.SetExceptionInformation(new EnumerableArrayWrapper<CilExceptionInformation' IOperationExceptionInformation>(excepList.ToArray()' Dummy.OperationExceptionInformation)); " is 183.
Long Statement,Microsoft.Cci.MetadataReader,MethodBodyDocument,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\ILReader.cs,GetTypeFromToken,The length of the statement  "      ITypeReference/*?*/ result = this.method.PEFileToObjectModel.GetTypeReferenceFromStandaloneSignatureToken(this.method' standAloneSignatureToken); " is 145.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetCoreAssemblySymbolicIdentity,The length of the statement  "          //Look for a lot of different mscorlib types' since an assembly need not reference System.Object or any particular type. " is 120.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetCoreAssemblySymbolicIdentity,The length of the statement  "            tKey != attributeKey && tKey != delegateKey && tKey != iAsyncResultKey && tKey != iCloneableKey && tKey != asyncCallbackKey && " is 126.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetCoreAssemblySymbolicIdentity,The length of the statement  "            tKey != attributeUsageAttributeKey && tKey != paramArrayAttributeKey && tKey != booleanKey && tKey != byteKey && tKey != charKey && " is 131.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetCoreAssemblySymbolicIdentity,The length of the statement  "            tKey != sByteKey && tKey != int16Key && tKey != uint16Key && tKey != int32Key && tKey != uint32Key && tKey != int64Key && " is 121.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetCoreAssemblySymbolicIdentity,The length of the statement  "            tKey != uint64Key && tKey != stringKey && tKey != intPtrKey && tKey != uintPtrKey && tKey != singleKey && tKey != doubleKey && " is 126.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,LoadAssemblyReferences,The length of the statement  "        Version version = new Version(assemblyRefRow.MajorVersion' assemblyRefRow.MinorVersion' assemblyRefRow.BuildNumber' assemblyRefRow.RevisionNumber); " is 147.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,LoadAssemblyReferences,The length of the statement  "        AssemblyIdentity assemblyIdentity = new AssemblyIdentity(assemblyRefName' cultureName.Value' version' publicKeyTokenArray' string.Empty); " is 137.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,LoadModuleReferences,The length of the statement  "        ModuleIdentity probedModuleIdentity = this.ModuleReader.metadataReaderHost.ProbeModuleReference(this.Module' moduleIdentity); " is 125.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,LoadModuleReferences,The length of the statement  "        uint internedModuleId = (uint)this.ModuleReader.metadataReaderHost.InternFactory.GetModuleInternedKey(probedModuleIdentity); " is 124.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,FindAssemblyReference,The length of the statement  "      uint assemblyInteredId = (uint)this.ModuleReader.metadataReaderHost.InternFactory.GetAssemblyInternedKey(assemblyIdentity); " is 123.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetWin32Resources,The length of the statement  "            yield return new Win32Resource(this' typeIdOrName' idOrName' langIdOrName' resourceData.RVAToData' (uint)resourceData.Size' (uint)resourceData.CodePage); " is 153.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,ResolveResource,The length of the statement  "        return new Resource(this' resourceReference.ResourceRowId' resourceReference.Name' resRow.Flags' (resRow.Implementation & TokenTypeIds.RIDMask) != 0); " is 150.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetResourceData,The length of the statement  "        IBinaryDocumentMemoryBlock/*?*/ binaryDocumentMemoryBlock = this.ModuleReader.metadataReaderHost.OpenBinaryDocument(this.PEFileReader.BinaryDocumentMemoryBlock.BinaryDocument' resource.ExternalFile.FileName.Value); " is 214.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetResourceData,The length of the statement  "        return new EnumberableMemoryBlockWrapper(this.PEFileReader.ResourceMemoryReader.GetMemoryBlockAt(resOffset + sizeof(Int32)' len)); " is 130.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetEntryPointMethod,The length of the statement  "        FileReference/*?*/ file = this.GetFileReferenceAt(this.PEFileReader.COR20Header.EntryPointTokenOrRVA & TokenTypeIds.RIDMask); " is 125.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetNamespaceForString,The length of the statement  "        NestedNamespace nestedNamespace = new NestedNamespace(this' iNamespaceFullName' iNamespaceFullName' this.RootModuleNamespace); " is 126.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetNamespaceReferenceForString,The length of the statement  "      NamespaceReference/*?*/ retNamespaceReference = this.NamespaceReferenceINameHashtable.Find(moduleReference.InternedModuleId' (uint)iNamespaceFullName.UniqueKey); " is 161.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetNamespaceReferenceForString,The length of the statement  "        retNamespaceReference = new NestedNamespaceReference(this' iNamespaceName' iNamespaceFullName' parentNamespaceReference); " is 121.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetNamespaceReferenceForString,The length of the statement  "      this.NamespaceReferenceINameHashtable.Add(moduleReference.InternedModuleId' (uint)iNamespaceFullName.UniqueKey' retNamespaceReference); " is 135.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,PreLoadTypeDefTableLookup,The length of the statement  "        this.NestedTypeTokenTable.Add(TokenTypeIds.TypeDef | nestedClassRow.EnclosingClass' (uint)typeName.UniqueKey' TokenTypeIds.TypeDef | nestedClassRow.NestedClass); " is 161.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,PreLoadTypeDefTableLookup,The length of the statement  "          this.NamespaceTypeTokenTable.Add((uint)namespaceName.UniqueKey' (uint)typeName.UniqueKey' TokenTypeIds.ExportedType | i); " is 121.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,CreateModuleNamespaceType,The length of the statement  "          type = new NonGenericNamespaceTypeWithoutPrimitiveType(this' typeName' typeDefRowId' typeDefRow.Flags' moduleNamespace); " is 120.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,CreateModuleNamespaceType,The length of the statement  "          type = new NonGenericNamespaceTypeWithPrimitiveType(this' typeName' typeDefRowId' typeDefRow.Flags' moduleNamespace' signatureTypeCode); " is 136.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,CreateModuleNamespaceType,The length of the statement  "        type = new GenericNamespaceType(this' unmangledTypeName' typeDefRowId' typeDefRow.Flags' moduleNamespace' typeName' genericParamRowIdStart' genericParamRowIdEnd); " is 162.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,CreateModuleNestedType,The length of the statement  "        type = new GenericNestedType(this' unmangledTypeName' typeDefRowId' typeDefRow.Flags' parentModuleType' typeName' genericParamRowIdStart' genericParamRowIdEnd); " is 160.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,CreateExportedNamespaceType,The length of the statement  "      ExportedTypeNamespaceAlias exportedType = new ExportedTypeNamespaceAlias(this' typeName' exportedTypeRowId' exportedTypeRow.Flags' moduleNamespace); " is 148.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,CreateExportedNestedType,The length of the statement  "      ExportedTypeNestedAlias exportedType = new ExportedTypeNestedAlias(this' typeName' exportedTypeRowId' exportedTypeRow.Flags' parentExportedType); " is 145.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetPredefinedTypeDefinitionAtRowWorker,The length of the statement  "        this.ModuleTypeDefArray[typeDefRowId] = this.CreateModuleNamespaceType(typeDefRowId' typeDefRow' parentNamespace' signatureTypeCode); " is 133.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetTypeDefinitionAtRowWorker,The length of the statement  "            this.PEFileReader.ErrorContainer.AddMetadataError(TableIndices.NestedClass' typeDefRowId' MetadataReaderErrorKind.NestedClassParentError); " is 138.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetTypeDefinitionAtRowWorker,The length of the statement  "          type = this.CreateModuleNamespaceType(typeDefRowId' typeDefRow' parentNamespace' ModuleSignatureTypeCode.NotModulePrimitive); " is 125.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetExportedTypeAtRowWorker,The length of the statement  "              this.PEFileReader.ErrorContainer.AddMetadataError(TableIndices.ExportedType' exportedTypeRowId' MetadataReaderErrorKind.NestedClassParentError); " is 144.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,ResolveNestedTypeDefinition,The length of the statement  "      uint typeToken = this.NestedTypeTokenTable.Find(TokenTypeIds.TypeDef | parentType.TypeDefRowId' (uint)typeName.UniqueKey); " is 122.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,ResolveExportedNamespaceType,The length of the statement  "      uint exportedTypeToken = this.NamespaceTypeTokenTable.Find((uint)namespaceName.UniqueKey' (uint)mangledTypeName.UniqueKey); " is 123.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,ResolveExportedNestedType,The length of the statement  "      uint exportedTypeToken = this.NestedTypeTokenTable.Find(TokenTypeIds.ExportedType | parentType.ExportedTypeRowId' (uint)typeName.UniqueKey); " is 140.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetGenericParamInfoForType,The length of the statement  "      genericParamRowIdStart = this.PEFileReader.GenericParamTable.FindGenericParametersForType(typeDefRowId' out genericParamCount); " is 127.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetInterfaceInfoForType,The length of the statement  "      interfaceRowIdStart = this.PEFileReader.InterfaceImplTable.FindInterfaceImplForType(moduleType.TypeDefRowId' out interfaceCount); " is 129.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetMethodImplInfoForType,The length of the statement  "      methodImplRowIdStart = this.PEFileReader.MethodImplTable.FindMethodsImplForClass(moduleType.TypeDefRowId' out methodImplCount); " is 127.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetConstraintInfoForGenericParam,The length of the statement  "      genericParamConstraintRowIdStart = this.PEFileReader.GenericParamConstraintTable.FindConstraintForGenericParam(genericParam.GenericParameterRowId' out constraintCount); " is 168.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetGenericTypeParamAtRow,The length of the statement  "            this.ModuleGenericParamArray[genericParamRowId] = new GenericTypeParameter(this' genericParamRow.Number' genericParamRow.Flags' genericParamName' genericParamRowId' moduleTypeOwner); " is 182.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetGenericMethodParamAtRow,The length of the statement  "            this.ModuleGenericParamArray[genericParamRowId] = new GenericMethodParameter(this' genericParamRow.Number' genericParamRow.Flags' genericParamName' genericParamRowId' moduleMethodOwner); " is 186.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetPredefinedTypeRefReferenceAtRowWorker,The length of the statement  "      this.ModuleTypeRefReferenceArray[typeRefRowId] = this.CreateTypeRefReference(typeRefRowId' typeRefRow' null' this.AssemblyReferenceArray[resolutionScopeRowId]' signatureTypeCode); " is 179.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetTypeRefReferenceAtRowWorker,The length of the statement  "            this.PEFileReader.ErrorContainer.AddMetadataError(TableIndices.TypeRef' typeRefRowId' MetadataReaderErrorKind.NestedClassParentError); " is 134.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetTypeRefReferenceAtRowWorker,The length of the statement  "          typeRefReference = this.CreateTypeRefReference(typeRefRowId' typeRefRow' parentModuleTypeReference' parentModuleTypeReference.ModuleReference' " is 142.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,FindExportedType,The length of the statement  "              ExportedTypeAliasBase/*?*/ aliasType = assemblyPEFileToObjectModel.ResolveExportedNamespaceType(namespaceName' typeName); " is 121.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,UnderlyingModuleTypeSpecReference,The length of the statement  "      TypeSpecSignatureConverter typeSpecSignatureConverter = new TypeSpecSignatureConverter(this' moduleTypeSpecReference' memoryReader); " is 132.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,FindCoreTypeReference,The length of the statement  "      TypeBase/*?*/ retModuleType = this.ResolveNamespaceTypeDefinition(coreTypeReference.NamespaceFullName' coreTypeReference.mangledTypeName); " is 138.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,CreateMethod,The length of the statement  "        moduleMethod = new NonGenericMethod(this' methodName' parentModuleType' methodDefRowId' methodRow.Flags' methodRow.ImplFlags); " is 126.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,CreateMethod,The length of the statement  "        moduleMethod = new GenericMethod(this' methodName' parentModuleType' methodDefRowId' methodRow.Flags' methodRow.ImplFlags' genericParamRowIdStart' genericParamRowIdEnd); " is 169.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,CreateProperty,The length of the statement  "      PropertyDefinition moduleProperty = new PropertyDefinition(this' propertyName' parentModuleType' propertyDefRowId' propertyRow.Flags); " is 134.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,LoadNestedTypesOfType,The length of the statement  "          currType = this.CreateModuleNestedType(nestedClassRow.NestedClass' this.PEFileReader.TypeDefTable[nestedClassRow.NestedClass]' moduleType); " is 139.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,LoadMethodsOfType,The length of the statement  "            moduleMethod = this.CreateMethod(methodRowId' moduleType); //TODO: is the token for the method derived from methodIter or methodRowId? " is 134.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,LoadPropertiesOfType,The length of the statement  "        for (uint propertyIter = propertyStart; propertyIter < propertyEnd && propertyIter <= numberOfPropertyPtrRows; ++propertyIter) { " is 128.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,LoadPropertiesOfType,The length of the statement  "        for (uint propertyIter = propertyStart; propertyIter < propertyEnd && propertyIter <= numberOfPropertyRows; ++propertyIter) { " is 125.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetPropertiesOfType,The length of the statement  "        for (uint propertyIter = propertyStart; propertyIter < propertyEnd && propertyIter <= numberOfPropertyPtrRows; ++propertyIter) { " is 128.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetPropertiesOfType,The length of the statement  "        for (uint propertyIter = propertyStart; propertyIter < propertyEnd && propertyIter <= numberOfPropertyRows; ++propertyIter) { " is 125.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,CreateGlobalField,The length of the statement  "      GlobalFieldDefinition globalField = new GlobalFieldDefinition(this' fieldTypeMembName' this._Module_' fieldDefRowId' fieldRow.Flags' globalFieldName' containingNamespace); " is 171.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,CreateGlobalMethod,The length of the statement  "        GlobalNonGenericMethod globalNGMethod = new GlobalNonGenericMethod(this' methodTypeMembName' this._Module_' methodDefRowId' methodRow.Flags' methodRow.ImplFlags' globalMethodName' containingNamespace); " is 201.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,CreateGlobalMethod,The length of the statement  "        GlobalGenericMethod globalGMethod = new GlobalGenericMethod(this' methodTypeMembName' this._Module_' methodDefRowId' methodRow.Flags' methodRow.ImplFlags' genericParamRowIdStart' genericParamRowIdEnd' globalMethodName' containingNamespace); " is 240.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetGenericParamInfoForMethod,The length of the statement  "      genericParamRowIdStart = this.PEFileReader.GenericParamTable.FindGenericParametersForMethod(methodDefRowId' out genericParamCount); " is 131.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetSemanticInfoForProperty,The length of the statement  "      methodSemanticRowIdStart = this.PEFileReader.MethodSemanticsTable.FindSemanticMethodsForProperty(propertyRowId' out methodCount); " is 129.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetSemanticInfoForEvent,The length of the statement  "      methodSemanticRowIdStart = this.PEFileReader.MethodSemanticsTable.FindSemanticMethodsForEvent(eventRowId' out methodCount); " is 123.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetPropertyGetterOrSetterMethod,The length of the statement  "      this.GetSemanticInfoForProperty(propertyDefinition.PropertyRowId' out methodSemanticRowIdStart' out methodSemanticRowIdEnd); " is 124.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetPropertyAccessorMethods,The length of the statement  "      this.GetSemanticInfoForProperty(propertyDefinition.PropertyRowId' out methodSemanticRowIdStart' out methodSemanticRowIdEnd); " is 124.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetMarshallingInformation,The length of the statement  "      System.Runtime.InteropServices.UnmanagedType unmanagedType = (System.Runtime.InteropServices.UnmanagedType)memoryReader.ReadByte(); " is 131.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetMarshallingInformation,The length of the statement  "          System.Runtime.InteropServices.UnmanagedType elementType = (System.Runtime.InteropServices.UnmanagedType)memoryReader.ReadByte(); " is 129.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetPlatformInvokeInformation,The length of the statement  "      return new PlatformInvokeInformation(implMapRow.PInvokeMapFlags' this.GetNameFromOffset(implMapRow.ImportName)' moduleReference); " is 129.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetModuleMemberReferenceAtRowWorker,The length of the statement  "        IModuleSpecializedNestedTypeReference/*?*/ specializedNestedTypeReference = parentTypeReference as IModuleSpecializedNestedTypeReference; " is 137.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetModuleMemberReferenceAtRowWorker,The length of the statement  "            return new SpecializedNestedTypeFieldReference(this' memberRefRowId' parentTypeReference' specializedNestedTypeReference' name); " is 128.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetModuleMemberReferenceAtRowWorker,The length of the statement  "            return new SpecializedNestedTypeMethodReference(this' memberRefRowId' parentTypeReference' specializedNestedTypeReference' name' firstByte); " is 140.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetMethodRefSignature,The length of the statement  "      MethodRefSignatureConverter methodRefSigConv = new MethodRefSignatureConverter(this' moduleMethodReference' memoryReader); " is 122.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetMethodSpecAtRow,The length of the statement  "      GenericMethodInstanceReference/*?*/ methodSpecReference = this.ModuleMethodSpecHashtable.Find(ownerId' methodSpecRowId); " is 120.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetCustomAttributeInfo,The length of the statement  "      customAttributeRowIdStart = this.PEFileReader.CustomAttributeTable.FindCustomAttributesForToken(metadataObject.TokenValue' out customAttributeCount); " is 149.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetCustomAttributeAtRow,The length of the statement  "            if (customAttribute.Parent == owningObject.TokenValue || (customAttribute.Parent == 1 && owningObject.TokenValue == TokenTypeIds.Assembly+1)) { " is 143.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetCustomAttributeAtRow,The length of the statement  "                  new CustomAttribute(this' customAttributeRowId' moduleMethodReference' TypeCache.EmptyExpressionList' TypeCache.EmptyNamedArgumentList); " is 136.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetCustomAttributeAtRow,The length of the statement  "                CustomAttributeDecoder customAttrDecoder = new CustomAttributeDecoder(this' memoryReader' customAttributeRowId' moduleMethodReference); " is 135.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetModuleCustomAttributes,The length of the statement  "      uint customAttributeRowIdStart = this.PEFileReader.CustomAttributeTable.FindCustomAttributesForToken(TokenTypeIds.Module | (uint)0x00000001' out customAttributeCount); " is 167.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetModuleCustomAttributes,The length of the statement  "      for (uint customAttributeIter = customAttributeRowIdStart; customAttributeIter < customAttributeRowIdEnd; ++customAttributeIter) { " is 130.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetAssemblyCustomAttributes,The length of the statement  "      uint customAttributeRowIdStart = this.PEFileReader.CustomAttributeTable.FindCustomAttributesForToken(TokenTypeIds.Assembly | (uint)0x00000001' out customAttributeCount); " is 169.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetAssemblyCustomAttributes,The length of the statement  "      for (uint customAttributeIter = customAttributeRowIdStart; customAttributeIter < customAttributeRowIdEnd; ++customAttributeIter) { " is 130.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetSecurityAttributeInfo,The length of the statement  "      securityAttributeRowIdStart = this.PEFileReader.DeclSecurityTable.FindSecurityAttributesForToken(metadataObject.TokenValue' out securityAttributeCount); " is 152.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetSecurityAttributeAtRow,The length of the statement  "              this.DeclSecurityArray[securityAttributeRowId] = new SecurityAttribute(this' securityAttributeRowId' (SecurityAction)declSecurity.ActionFlags); " is 143.
Long Statement,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetCustomModifiers,The length of the statement  "          typeRef = this.PEFileToObjectModel.GetTypeSpecReferenceAtRow(this.MetadataOwnerObject' typeRID).UnderlyingModuleTypeReference; " is 126.
Long Statement,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetModuleGenericTypeInstanceReference,The length of the statement  "        templateTypeReference = this.PEFileToObjectModel.GetTypeRefReferenceAtRow(templateTypeRowId' headByte == ElementType.ValueType); " is 128.
Long Statement,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetModuleMatrixType,The length of the statement  "      return new MatrixType(this.PEFileToObjectModel' typeSpecToken' elementType' rank' new EnumerableArrayWrapper<ulong>(sizeList.ToArray())' new EnumerableArrayWrapper<int>(lowerBoundList.ToArray())); " is 196.
Long Statement,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetModuleFuntionPointer,The length of the statement  "      EnumerableArrayWrapper<CustomModifier' ICustomModifier> returnCustomModifiers = this.GetCustomModifiers(out dummyPinned); " is 121.
Long Statement,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetModuleFuntionPointer,The length of the statement  "      EnumerableArrayWrapper<IModuleParameterTypeInformation' IParameterTypeInformation> moduleParameters = TypeCache.EmptyParameterInfoArray; " is 136.
Long Statement,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetModuleFuntionPointer,The length of the statement  "        IModuleParameterTypeInformation[] moduleParameterArr = this.GetModuleParameterTypeInformations(Dummy.Method' paramCount); " is 121.
Long Statement,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetModuleFuntionPointer,The length of the statement  "          moduleParameters = new EnumerableArrayWrapper<IModuleParameterTypeInformation' IParameterTypeInformation>(moduleParameterArr' Dummy.ParameterTypeInformation); " is 158.
Long Statement,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetModuleFuntionPointer,The length of the statement  "      EnumerableArrayWrapper<IModuleParameterTypeInformation' IParameterTypeInformation> moduleVarargsParameters = TypeCache.EmptyParameterInfoArray; " is 143.
Long Statement,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetModuleFuntionPointer,The length of the statement  "        IModuleParameterTypeInformation[] moduleParameterArr = this.GetModuleParameterTypeInformations(Dummy.Method' paramCount - moduleParameters.RawArray.Length); " is 156.
Long Statement,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetModuleFuntionPointer,The length of the statement  "          moduleVarargsParameters = new EnumerableArrayWrapper<IModuleParameterTypeInformation' IParameterTypeInformation>(moduleParameterArr' Dummy.ParameterTypeInformation); " is 165.
Long Statement,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetTypeReference,The length of the statement  "            return this.PEFileToObjectModel.GetTypeReferenceForToken(this.MetadataOwnerObject' typeToken' headByte == ElementType.ValueType); " is 129.
Long Statement,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\ILReader.cs,LoadLocalSignature,The length of the statement  "        LocalVariableSignatureConverter locVarSigConv = new LocalVariableSignatureConverter(this.PEFileToObjectModel' this.MethodBody' memoryReader); " is 141.
Long Statement,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\ILReader.cs,GetStandAloneMethodSignature,The length of the statement  "      StandAloneSigRow sigRow = this.PEFileToObjectModel.PEFileReader.StandAloneSigTable[standAloneMethodToken & TokenTypeIds.RIDMask]; " is 129.
Long Statement,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\ILReader.cs,GetStandAloneMethodSignature,The length of the statement  "      MemoryBlock signatureMemoryBlock = this.PEFileToObjectModel.PEFileReader.BlobStream.GetMemoryBlockAt(signatureBlobOffset); " is 122.
Long Statement,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\ILReader.cs,GetStandAloneMethodSignature,The length of the statement  "      StandAloneMethodSignatureConverter standAloneSigConv = new StandAloneMethodSignatureConverter(this.PEFileToObjectModel' this.MethodDefinition' memoryReader); " is 157.
Long Statement,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\ILReader.cs,PopulateCilInstructions,The length of the statement  "            this.PEFileToObjectModel.PEFileReader.ErrorContainer.AddILError(this.MethodDefinition' offset' MetadataReaderErrorKind.UnknownILInstruction); " is 141.
Long Statement,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\ILReader.cs,PopulateCilInstructions,The length of the statement  "      this.MethodBody.SetCilInstructions(new EnumerableArrayWrapper<CilInstruction' IOperation>(instrList.ToArray()' Dummy.Operation)); " is 129.
Long Statement,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\ILReader.cs,PopulateExceptionInformation,The length of the statement  "            IModuleTypeReference/*?*/ typeRef = this.PEFileToObjectModel.GetTypeReferenceForToken(this.MethodDefinition' sehTableEntry.ClassTokenOrFilterOffset); " is 149.
Long Statement,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\ILReader.cs,PopulateExceptionInformation,The length of the statement  "      this.MethodBody.SetExceptionInformation(new EnumerableArrayWrapper<CilExceptionInformation' IOperationExceptionInformation>(excepList.ToArray()' Dummy.OperationExceptionInformation)); " is 183.
Long Statement,Microsoft.Cci.MetadataReader.MethodBody,MethodBodyDocument,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\ILReader.cs,GetTypeFromToken,The length of the statement  "      ITypeReference/*?*/ result = this.method.PEFileToObjectModel.GetTypeReferenceFromStandaloneSignatureToken(this.method' standAloneSignatureToken); " is 145.
Long Statement,Microsoft.Cci.MetadataReader.Errors,DirectoryLocation,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Errors.cs,ToString,The length of the statement  "      sb.AppendFormat(CultureInfo.InvariantCulture' "DirectoryLocation({0}'{1}'{2})"' this.binaryDocument.Location' this.directory.ToString()' this.offset); " is 150.
Long Statement,Microsoft.Cci.MetadataReader.Errors,MetadataStreamLocation,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Errors.cs,ToString,The length of the statement  "      sb.AppendFormat(CultureInfo.InvariantCulture' "MetadataStreamLocation({0}'{1}'{2})"' this.binaryDocument.Location' this.streamName' this.offset); " is 145.
Long Statement,Microsoft.Cci.MetadataReader.Errors,MetadataLocation,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Errors.cs,ToString,The length of the statement  "      sb.AppendFormat(CultureInfo.InvariantCulture' "MetadataLocation({0}'{1}'{2})"' this.binaryDocument.Location' this.tableIndex.ToString()' this.rowId); " is 149.
Long Statement,Microsoft.Cci.MetadataReader.Errors,MetadataErrorContainer,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Errors.cs,AddBinaryError,The length of the statement  "      this.AddMetadataReaderErrorMessage(new MetadataReaderErrorMessage(this.MetadataReader.ErrorsReporter' new BinaryLocation(this.BinaryDocument' offset)' errorKind)); " is 163.
Long Statement,Microsoft.Cci.MetadataReader.Errors,MetadataErrorContainer,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Errors.cs,AddDirectoryError,The length of the statement  "      this.AddMetadataReaderErrorMessage(new MetadataReaderErrorMessage(this.MetadataReader.ErrorsReporter' new DirectoryLocation(this.BinaryDocument' directory' offset)' errorKind)); " is 177.
Long Statement,Microsoft.Cci.MetadataReader.Errors,MetadataErrorContainer,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Errors.cs,AddMetadataStreamError,The length of the statement  "      this.AddMetadataReaderErrorMessage(new MetadataReaderErrorMessage(this.MetadataReader.ErrorsReporter' new MetadataStreamLocation(this.BinaryDocument' streamName' offset)' errorKind)); " is 183.
Long Statement,Microsoft.Cci.MetadataReader.Errors,MetadataErrorContainer,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Errors.cs,AddMetadataError,The length of the statement  "      this.AddMetadataReaderErrorMessage(new MetadataReaderErrorMessage(this.MetadataReader.ErrorsReporter' new MetadataLocation(this.BinaryDocument' tableIndex' rowId)' errorKind)); " is 176.
Long Statement,Microsoft.Cci.MetadataReader.Errors,MetadataErrorContainer,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Errors.cs,AddILError,The length of the statement  "      this.AddMetadataReaderErrorMessage(new MetadataReaderErrorMessage(this.MetadataReader.ErrorsReporter' new ILLocation(this.BinaryDocument' methodDefinition' offset)' errorKind)); " is 177.
Long Statement,Microsoft.Cci,PeReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\ModuleReadWriteFactory.cs,OpenMemberModules,The length of the statement  "        IBinaryDocumentMemoryBlock/*?*/ binaryDocumentMemoryBlock = this.metadataReaderHost.OpenBinaryDocument(binaryDocument' fileRef.FileName.Value); " is 143.
Long Statement,Microsoft.Cci,PeReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\ModuleReadWriteFactory.cs,OpenMemberModules,The length of the statement  "          PEFileToObjectModel peFileToObjectModel = new PEFileToObjectModel(this' peFileReader' moduleIdentity' assembly' this.metadataReaderHost.PointerSize); " is 149.
Long Statement,Microsoft.Cci,PeReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\ModuleReadWriteFactory.cs,OpenAssembly,The length of the statement  "          PEFileToObjectModel peFileToObjectModel = new PEFileToObjectModel(this' peFileReader' assemblyIdentity' null' this.metadataReaderHost.PointerSize); " is 147.
Long Statement,Microsoft.Cci,PeReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\ModuleReadWriteFactory.cs,OpenModule,The length of the statement  "          PEFileToObjectModel peFileToObjectModel = new PEFileToObjectModel(this' peFileReader' moduleIdentity' null' this.metadataReaderHost.PointerSize); " is 145.
Long Statement,Microsoft.Cci,PeReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\ModuleReadWriteFactory.cs,GetAssemblyIdentifier,The length of the statement  "      Version version = new Version(assemblyRow.MajorVersion' assemblyRow.MinorVersion' assemblyRow.BuildNumber' assemblyRow.RevisionNumber); " is 135.
Long Statement,Microsoft.Cci,PeReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\ModuleReadWriteFactory.cs,GetAssemblyIdentifier,The length of the statement  "      return new AssemblyIdentity(assemblyName' cultureName' version' publicKeyTokenArray' peFileReader.BinaryDocumentMemoryBlock.BinaryDocument.Location); " is 149.
Long Statement,Microsoft.Cci,PeReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\ModuleReadWriteFactory.cs,GetModuleIdentifier,The length of the statement  "      return new ModuleIdentity(moduleName' peFileReader.BinaryDocumentMemoryBlock.BinaryDocument.Location' containingAssemblyIdentity); " is 130.
Long Statement,Microsoft.Cci,PeReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\ModuleReadWriteFactory.cs,ResolveSerializedTypeName,The length of the statement  "      IModuleTypeReference/*?*/ moduleTypeRef = internalAssembly.PEFileToObjectModel.GetSerializedTypeNameAsTypeReference(typeName); " is 126.
Long Statement,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\UnmanagedReadWrite.cs,PeekUTF16WithShortSize,The length of the statement  "      string result = new string((sbyte*)(this.CurrentPointer + offset + sizeof(UInt16))' 0' length * sizeof(Char)' Encoding.Unicode); " is 128.
Long Statement,Microsoft.Cci.MetadataReader.PEFileFlags,TypeDefOrRefTag,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,ConvertToToken,The length of the statement  "      return TypeDefOrRefTag.TagToTokenTypeArray[typeDefOrRefTag & TypeDefOrRefTag.TagMask] | typeDefOrRefTag >> TypeDefOrRefTag.NumberOfBits; " is 136.
Long Statement,Microsoft.Cci.MetadataReader.PEFileFlags,HasConstantTag,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,ConvertToToken,The length of the statement  "      return HasConstantTag.TagToTokenTypeArray[hasConstant & HasConstantTag.TagMask] | hasConstant >> HasConstantTag.NumberOfBits; " is 125.
Long Statement,Microsoft.Cci.MetadataReader.PEFileFlags,HasCustomAttributeTag,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,ConvertToToken,The length of the statement  "      return HasCustomAttributeTag.TagToTokenTypeArray[hasCustomAttribute & HasCustomAttributeTag.TagMask] | hasCustomAttribute >> HasCustomAttributeTag.NumberOfBits; " is 160.
Long Statement,Microsoft.Cci.MetadataReader.PEFileFlags,HasFieldMarshalTag,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,ConvertToToken,The length of the statement  "      return HasFieldMarshalTag.TagToTokenTypeArray[hasFieldMarshal & HasFieldMarshalTag.TagMask] | hasFieldMarshal >> HasFieldMarshalTag.NumberOfBits; " is 145.
Long Statement,Microsoft.Cci.MetadataReader.PEFileFlags,HasDeclSecurityTag,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,ConvertToToken,The length of the statement  "      return HasDeclSecurityTag.TagToTokenTypeArray[hasDeclSecurity & HasDeclSecurityTag.TagMask] | hasDeclSecurity >> HasDeclSecurityTag.NumberOfBits; " is 145.
Long Statement,Microsoft.Cci.MetadataReader.PEFileFlags,MemberRefParentTag,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,ConvertToToken,The length of the statement  "      return MemberRefParentTag.TagToTokenTypeArray[memberRef & MemberRefParentTag.TagMask] | memberRef >> MemberRefParentTag.NumberOfBits; " is 133.
Long Statement,Microsoft.Cci.MetadataReader.PEFileFlags,HasSemanticsTag,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,ConvertToToken,The length of the statement  "      return HasSemanticsTag.TagToTokenTypeArray[hasSemantic & HasSemanticsTag.TagMask] | hasSemantic >> HasSemanticsTag.NumberOfBits; " is 128.
Long Statement,Microsoft.Cci.MetadataReader.PEFileFlags,MethodDefOrRefTag,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,ConvertToToken,The length of the statement  "      return MethodDefOrRefTag.TagToTokenTypeArray[methodDefOrRef & MethodDefOrRefTag.TagMask] | methodDefOrRef >> MethodDefOrRefTag.NumberOfBits; " is 140.
Long Statement,Microsoft.Cci.MetadataReader.PEFileFlags,MemberForwardedTag,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,ConvertToToken,The length of the statement  "      return MemberForwardedTag.TagToTokenTypeArray[memberForwarded & MethodDefOrRefTag.TagMask] | memberForwarded >> MethodDefOrRefTag.NumberOfBits; " is 143.
Long Statement,Microsoft.Cci.MetadataReader.PEFileFlags,ImplementationTag,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,ConvertToToken,The length of the statement  "      return ImplementationTag.TagToTokenTypeArray[implementation & ImplementationTag.TagMask] | implementation >> ImplementationTag.NumberOfBits; " is 140.
Long Statement,Microsoft.Cci.MetadataReader.PEFileFlags,CustomAttributeTypeTag,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,ConvertToToken,The length of the statement  "      return CustomAttributeTypeTag.TagToTokenTypeArray[customAttributeType & CustomAttributeTypeTag.TagMask] | customAttributeType >> CustomAttributeTypeTag.NumberOfBits; " is 165.
Long Statement,Microsoft.Cci.MetadataReader.PEFileFlags,ResolutionScopeTag,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,ConvertToToken,The length of the statement  "      return ResolutionScopeTag.TagToTokenTypeArray[resolutionScope & ResolutionScopeTag.TagMask] | resolutionScope >> ResolutionScopeTag.NumberOfBits; " is 145.
Long Statement,Microsoft.Cci.MetadataReader.PEFileFlags,TypeOrMethodDefTag,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,ConvertToToken,The length of the statement  "      return TypeOrMethodDefTag.TagToTokenTypeArray[typeOrMethodDef & TypeOrMethodDefTag.TagMask] | typeOrMethodDef >> TypeOrMethodDefTag.NumberOfBits; " is 145.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,TypeDefOrRefTag,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,ConvertToToken,The length of the statement  "      return TypeDefOrRefTag.TagToTokenTypeArray[typeDefOrRefTag & TypeDefOrRefTag.TagMask] | typeDefOrRefTag >> TypeDefOrRefTag.NumberOfBits; " is 136.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,HasConstantTag,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,ConvertToToken,The length of the statement  "      return HasConstantTag.TagToTokenTypeArray[hasConstant & HasConstantTag.TagMask] | hasConstant >> HasConstantTag.NumberOfBits; " is 125.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,HasCustomAttributeTag,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,ConvertToToken,The length of the statement  "      return HasCustomAttributeTag.TagToTokenTypeArray[hasCustomAttribute & HasCustomAttributeTag.TagMask] | hasCustomAttribute >> HasCustomAttributeTag.NumberOfBits; " is 160.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,HasFieldMarshalTag,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,ConvertToToken,The length of the statement  "      return HasFieldMarshalTag.TagToTokenTypeArray[hasFieldMarshal & HasFieldMarshalTag.TagMask] | hasFieldMarshal >> HasFieldMarshalTag.NumberOfBits; " is 145.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,HasDeclSecurityTag,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,ConvertToToken,The length of the statement  "      return HasDeclSecurityTag.TagToTokenTypeArray[hasDeclSecurity & HasDeclSecurityTag.TagMask] | hasDeclSecurity >> HasDeclSecurityTag.NumberOfBits; " is 145.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,MemberRefParentTag,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,ConvertToToken,The length of the statement  "      return MemberRefParentTag.TagToTokenTypeArray[memberRef & MemberRefParentTag.TagMask] | memberRef >> MemberRefParentTag.NumberOfBits; " is 133.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,HasSemanticsTag,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,ConvertToToken,The length of the statement  "      return HasSemanticsTag.TagToTokenTypeArray[hasSemantic & HasSemanticsTag.TagMask] | hasSemantic >> HasSemanticsTag.NumberOfBits; " is 128.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,MethodDefOrRefTag,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,ConvertToToken,The length of the statement  "      return MethodDefOrRefTag.TagToTokenTypeArray[methodDefOrRef & MethodDefOrRefTag.TagMask] | methodDefOrRef >> MethodDefOrRefTag.NumberOfBits; " is 140.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,MemberForwardedTag,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,ConvertToToken,The length of the statement  "      return MemberForwardedTag.TagToTokenTypeArray[memberForwarded & MethodDefOrRefTag.TagMask] | memberForwarded >> MethodDefOrRefTag.NumberOfBits; " is 143.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,ImplementationTag,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,ConvertToToken,The length of the statement  "      return ImplementationTag.TagToTokenTypeArray[implementation & ImplementationTag.TagMask] | implementation >> ImplementationTag.NumberOfBits; " is 140.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,CustomAttributeTypeTag,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,ConvertToToken,The length of the statement  "      return CustomAttributeTypeTag.TagToTokenTypeArray[customAttributeType & CustomAttributeTypeTag.TagMask] | customAttributeType >> CustomAttributeTypeTag.NumberOfBits; " is 165.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,ResolutionScopeTag,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,ConvertToToken,The length of the statement  "      return ResolutionScopeTag.TagToTokenTypeArray[resolutionScope & ResolutionScopeTag.TagMask] | resolutionScope >> ResolutionScopeTag.NumberOfBits; " is 145.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,TypeOrMethodDefTag,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,ConvertToToken,The length of the statement  "      return TypeOrMethodDefTag.TagToTokenTypeArray[typeOrMethodDef & TypeOrMethodDefTag.TagMask] | typeOrMethodDef >> TypeOrMethodDefTag.NumberOfBits; " is 145.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,TypeDefTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,GetExtends,The length of the statement  "      uint extends = this.TypeDefTableMemoryReader.PeekReference(rowOffset + this.ExtendsOffset' this.IsTypeDefOrRefRefSizeSmall); " is 124.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,TypeDefTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,GetFieldStart,The length of the statement  "      uint fieldListStart = this.TypeDefTableMemoryReader.PeekReference(rowOffset + this.FieldListOffset' this.IsFieldRefSizeSmall); " is 126.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,TypeDefTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,GetMethodStart,The length of the statement  "      uint methodListStart = this.TypeDefTableMemoryReader.PeekReference(rowOffset + this.MethodListOffset' this.IsMethodRefSizeSmall); " is 129.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,TypeDefTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,FindTypeContainingMethod,The length of the statement  "      int slot = this.TypeDefTableMemoryReader.BinarySearchForSlot(numOfRows' this.RowSize' this.MethodListOffset' methodDefOrPtrRowId' this.IsMethodRefSizeSmall); " is 157.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,TypeDefTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,FindTypeContainingField,The length of the statement  "      int slot = this.TypeDefTableMemoryReader.BinarySearchForSlot(numOfRows' this.RowSize' this.FieldListOffset' fieldDefOrPtrRowId' this.IsFieldRefSizeSmall); " is 154.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,FieldPtrTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,GetFieldFor,The length of the statement  "      uint field = this.FieldPtrTableMemoryReader.PeekReference(rowOffset + this.FieldOffset' this.IsFieldTableRowRefSizeSmall); " is 122.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,FieldPtrTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,GetRowIdForFieldDefRow,The length of the statement  "      return (uint)(this.FieldPtrTableMemoryReader.LinearSearchReference(this.RowSize' this.FieldOffset' fieldDefRowId' this.IsFieldTableRowRefSizeSmall) + 1); " is 153.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,FieldTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,GetSignature,The length of the statement  "      uint signature = this.FieldTableMemoryReader.PeekReference(rowOffset + this.SignatureOffset' this.IsBlobHeapRefSizeSmall); " is 122.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,MethodPtrTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,GetMethodFor,The length of the statement  "      uint method = this.MethodPtrTableMemoryReader.PeekReference(rowOffset + this.MethodOffset' this.IsMethodTableRowRefSizeSmall); " is 126.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,MethodPtrTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,GetRowIdForMethodDefRow,The length of the statement  "      return (uint)(this.MethodPtrTableMemoryReader.LinearSearchReference(this.RowSize' this.MethodOffset' methodDefRowId' this.IsMethodTableRowRefSizeSmall) + 1); " is 157.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,MethodTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,GetParamStart,The length of the statement  "      uint paramListStart = this.MethodTableMemoryReader.PeekReference(rowOffset + this.ParamListOffset' this.IsParamRefSizeSmall); " is 125.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,MethodTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,GetSignature,The length of the statement  "      uint signature = this.MethodTableMemoryReader.PeekReference(rowOffset + this.SignatureOffset' this.IsBlobHeapRefSizeSmall); " is 123.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,ParamPtrTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,GetParamFor,The length of the statement  "      uint param = this.ParamPtrTableMemoryReader.PeekReference(rowOffset + this.ParamOffset' this.IsParamTableRowRefSizeSmall); " is 122.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,InterfaceImplTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,FindInterfaceImplForType,The length of the statement  "        && this.InterfaceImplTableMemoryReader.PeekReference((startRowNumber - 1) * this.RowSize + this.ClassOffset' this.IsTypeDefOrRefRefSizeSmall) == typeDefRowId " is 157.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,InterfaceImplTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,FindInterfaceImplForType,The length of the statement  "        && this.InterfaceImplTableMemoryReader.PeekReference((endRowNumber + 1) * this.RowSize + this.ClassOffset' this.IsTypeDefOrRefRefSizeSmall) == typeDefRowId " is 155.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,InterfaceImplTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,GetInterface,The length of the statement  "      uint @interface = this.InterfaceImplTableMemoryReader.PeekReference(rowOffset + this.InterfaceOffset' this.IsTypeDefOrRefRefSizeSmall); " is 135.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,MemberRefTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,GetSignature,The length of the statement  "      uint signature = this.MemberRefTableMemoryReader.PeekReference(rowOffset + this.SignatureOffset' this.IsBlobHeapRefSizeSmall); " is 126.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,CustomAttributeTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,BinarySearchTag,The length of the statement  "        && this.CustomAttributeTableMemoryReader.PeekReference((startRowNumber - 1) * this.RowSize + this.ParentOffset' this.IsHasCustomAttributeRefSizeSmall) == searchCodedTag " is 168.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,CustomAttributeTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,BinarySearchTag,The length of the statement  "        && this.CustomAttributeTableMemoryReader.PeekReference((endRowNumber + 1) * this.RowSize + this.ParentOffset' this.IsHasCustomAttributeRefSizeSmall) == searchCodedTag " is 166.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,DeclSecurityTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,BinarySearchTag,The length of the statement  "        && this.DeclSecurityTableMemoryReader.PeekReference((startRowNumber - 1) * this.RowSize + this.ParentOffset' this.IsHasDeclSecurityRefSizeSmall) == searchCodedTag " is 162.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,DeclSecurityTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,BinarySearchTag,The length of the statement  "        && this.DeclSecurityTableMemoryReader.PeekReference((endRowNumber + 1) * this.RowSize + this.ParentOffset' this.IsHasDeclSecurityRefSizeSmall) == searchCodedTag " is 160.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,EventMapTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,GetEventListStartFor,The length of the statement  "      uint eventList = this.EventMapTableMemoryReader.PeekReference(rowOffset + this.EventListOffset' this.IsEventRefSizeSmall); " is 122.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,EventPtrTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,GetEventFor,The length of the statement  "      uint @event = this.EventPtrTableMemoryReader.PeekReference(rowOffset + this.EventOffset' this.IsEventTableRowRefSizeSmall); " is 123.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,EventTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,GetEventType,The length of the statement  "      uint eventType = this.EventTableMemoryReader.PeekReference(rowOffset + this.EventTypeOffset' this.IsTypeDefOrRefRefSizeSmall); " is 126.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PropertyMapTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,GetPropertyListStartFor,The length of the statement  "      uint propertyList = this.PropertyMapTableMemoryReader.PeekReference(rowOffset + this.PropertyListOffset' this.IsPropertyRefSizeSmall); " is 134.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PropertyPtrTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,GetPropertyFor,The length of the statement  "      uint property = this.PropertyPtrTableMemoryReader.PeekReference(rowOffset + this.PropertyOffset' this.IsPropertyTableRowRefSizeSmall); " is 134.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PropertyTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,GetSignature,The length of the statement  "      uint signature = this.PropertyTableMemoryReader.PeekReference(rowOffset + this.SignatureOffset' this.IsBlobHeapRefSizeSmall); " is 125.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,MethodSemanticsTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,BinarySearchTag,The length of the statement  "        && this.MethodSemanticsTableMemoryReader.PeekReference((startRowNumber - 1) * this.RowSize + this.AssociationOffset' this.IsHasSemanticRefSizeSmall) == searchCodedTag " is 166.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,MethodSemanticsTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,BinarySearchTag,The length of the statement  "        && this.MethodSemanticsTableMemoryReader.PeekReference((endRowNumber + 1) * this.RowSize + this.AssociationOffset' this.IsHasSemanticRefSizeSmall) == searchCodedTag " is 164.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,MethodImplTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,FindMethodsImplForClass,The length of the statement  "        && this.MethodImplTableMemoryReader.PeekReference((startRowNumber - 1) * this.RowSize + this.ClassOffset' this.IsTypeDefTableRowRefSizeSmall) == typeDefRowId " is 157.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,MethodImplTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,FindMethodsImplForClass,The length of the statement  "        && this.MethodImplTableMemoryReader.PeekReference((endRowNumber + 1) * this.RowSize + this.ClassOffset' this.IsTypeDefTableRowRefSizeSmall) == typeDefRowId " is 155.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,TypeSpecTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,GetSignature,The length of the statement  "      uint signature = this.TypeSpecTableMemoryReader.PeekReference(rowOffset + this.SignatureOffset' this.IsBlobHeapRefSizeSmall); " is 125.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,FileTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,GetHashValue,The length of the statement  "      uint hashValue = this.FileTableMemoryReader.PeekReference(rowOffset + this.HashValueOffset' this.IsBlobHeapRefSizeSmall); " is 121.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,ExportedTypeTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,GetNamespace,The length of the statement  "      uint typeNamespace = this.ExportedTypeTableMemoryReader.PeekReference(rowOffset + this.TypeNamespaceOffset' this.IsStringHeapRefSizeSmall); " is 139.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,ManifestResourceTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,GetImplementation,The length of the statement  "      uint implementation = this.ManifestResourceTableMemoryReader.PeekReference(rowOffset + this.ImplementationOffset' this.IsImplementationRefSizeSmall); " is 149.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,NestedClassTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,FindParentTypeDefRowId,The length of the statement  "      return this.NestedClassTableMemoryReader.PeekReference(rowNumber * this.RowSize + this.EnclosingClassOffset' this.IsTypeDefTableRowRefSizeSmall); " is 145.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,GenericParamTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,BinarySearchTag,The length of the statement  "        && this.GenericParamTableMemoryReader.PeekReference((startRowNumber - 1) * this.RowSize + this.OwnerOffset' this.IsTypeOrMethodDefRefSizeSmall) == searchCodedTag " is 161.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,GenericParamTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,BinarySearchTag,The length of the statement  "        && this.GenericParamTableMemoryReader.PeekReference((endRowNumber + 1) * this.RowSize + this.OwnerOffset' this.IsTypeOrMethodDefRefSizeSmall) == searchCodedTag " is 159.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,GenericParamConstraintTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,FindConstraintForGenericParam,The length of the statement  "        && this.GenericParamConstraintTableMemoryReader.PeekReference((startRowNumber - 1) * this.RowSize + this.OwnerOffset' this.IsGenericParamTableRowRefSizeSmall) == genericParamRowId " is 179.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,GenericParamConstraintTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,FindConstraintForGenericParam,The length of the statement  "        && this.GenericParamConstraintTableMemoryReader.PeekReference((endRowNumber + 1) * this.RowSize + this.OwnerOffset' this.IsGenericParamTableRowRefSizeSmall) == genericParamRowId " is 177.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,GenericParamConstraintTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,GetConstraint,The length of the statement  "      uint constraint = this.GenericParamConstraintTableMemoryReader.PeekReference(rowOffset + this.ConstraintOffset' this.IsTypeDefOrRefRefSizeSmall); " is 145.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ReadOptionalHeaderNTAdditionalFields32,The length of the statement  "        this.ErrorContainer.AddBinaryError(memReader.Offset' MetadataReaderErrorKind.OptionalHeaderNTAdditionalFields32TooSmall); " is 121.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ReadOptionalHeaderNTAdditionalFields64,The length of the statement  "        this.ErrorContainer.AddBinaryError(memReader.Offset' MetadataReaderErrorKind.OptionalHeaderNTAdditionalFields64TooSmall); " is 121.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ReadPEFileLevelData,The length of the statement  "      MemoryReader memReader = new MemoryReader(this.BinaryDocumentMemoryBlock.Pointer' this.BinaryDocumentMemoryBlock.Length); " is 121.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ReadPEFileLevelData,The length of the statement  "      this.Win32ResourceMemoryReader = new MemoryReader(this.DirectoryToMemoryBlock(this.OptionalHeaderDirectoryEntries.ResourceTableDirectory)); " is 139.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,DirectoryToMemoryBlock,The length of the statement  "        if (sectionHeaderIter.VirtualAddress <= directory.RelativeVirtualAddress && directory.RelativeVirtualAddress < sectionHeaderIter.VirtualAddress + sectionHeaderIter.VirtualSize) { " is 178.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,RVAToMemoryBlockWithSize,The length of the statement  "        if (sectionHeaderIter.VirtualAddress <= RVA && RVA < sectionHeaderIter.VirtualAddress + sectionHeaderIter.VirtualSize) { " is 120.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,RVAToMemoryBlock,The length of the statement  "        if (sectionHeaderIter.VirtualAddress <= RVA && RVA < sectionHeaderIter.VirtualAddress + sectionHeaderIter.VirtualSize) { " is 120.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,RVAToSubSection,The length of the statement  "        if (sectionHeaderIter.VirtualAddress <= RVA && RVA + size <= sectionHeaderIter.VirtualAddress + sectionHeaderIter.VirtualSize) { " is 128.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,RVAToSubSectionName,The length of the statement  "        if (sectionHeaderIter.VirtualAddress <= RVA && RVA < sectionHeaderIter.VirtualAddress + sectionHeaderIter.VirtualSize) { " is 120.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,GetSizeOfRemainderOfSectionContaining,The length of the statement  "        if (sectionHeaderIter.VirtualAddress <= RVA && RVA < sectionHeaderIter.VirtualAddress + sectionHeaderIter.VirtualSize) { " is 120.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ReadCOR20Header,The length of the statement  "        this.ErrorContainer.AddDirectoryError(Directories.COR20Header' 0' MetadataReaderErrorKind.NotEnoughSpaceForCOR20HeaderTableDirectory); " is 134.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ReadMetadataHeader,The length of the statement  "        this.ErrorContainer.AddDirectoryError(Directories.Cor20HeaderMetaData' 0' MetadataReaderErrorKind.MetadataHeaderTooSmall); " is 122.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ReadMetadataHeader,The length of the statement  "        this.ErrorContainer.AddDirectoryError(Directories.Cor20HeaderMetaData' memReader.Offset - sizeof(uint)' MetadataReaderErrorKind.MetadataSignature); " is 147.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ReadMetadataHeader,The length of the statement  "        this.ErrorContainer.AddDirectoryError(Directories.Cor20HeaderMetaData' memReader.Offset' MetadataReaderErrorKind.NotEnoughSpaceForVersionString); " is 145.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ReadStorageHeader,The length of the statement  "        this.ErrorContainer.AddDirectoryError(Directories.Cor20HeaderMetaData' memReader.Offset' MetadataReaderErrorKind.StorageHeaderTooSmall); " is 136.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ReadStreamHeaders,The length of the statement  "          this.ErrorContainer.AddDirectoryError(Directories.Cor20HeaderMetaData' memReader.Offset' MetadataReaderErrorKind.StreamHeaderTooSmall); " is 135.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ReadStreamHeaders,The length of the statement  "        //  Review: Oh well there is no way i can test if we will read correctly. However we can check it after reading and aligning... " is 127.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ReadStreamHeaders,The length of the statement  "          this.ErrorContainer.AddDirectoryError(Directories.Cor20HeaderMetaData' memReader.Offset' MetadataReaderErrorKind.NotEnoughSpaceForStreamHeaderName); " is 148.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheStreams,The length of the statement  "              this.ErrorContainer.AddDirectoryError(Directories.Cor20HeaderMetaData' streamHeader.Offset' MetadataReaderErrorKind.NotEnoughSpaceForStringStream); " is 147.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheStreams,The length of the statement  "              this.ErrorContainer.AddDirectoryError(Directories.Cor20HeaderMetaData' streamHeader.Offset' MetadataReaderErrorKind.NotEnoughSpaceForBlobStream); " is 145.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheStreams,The length of the statement  "              this.ErrorContainer.AddDirectoryError(Directories.Cor20HeaderMetaData' streamHeader.Offset' MetadataReaderErrorKind.NotEnoughSpaceForGUIDStream); " is 145.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheStreams,The length of the statement  "              this.ErrorContainer.AddDirectoryError(Directories.Cor20HeaderMetaData' streamHeader.Offset' MetadataReaderErrorKind.NotEnoughSpaceForBlobStream); " is 145.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheStreams,The length of the statement  "              this.ErrorContainer.AddDirectoryError(Directories.Cor20HeaderMetaData' streamHeader.Offset' MetadataReaderErrorKind.NotEnoughSpaceForMetadataStream); " is 149.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheStreams,The length of the statement  "              this.ErrorContainer.AddDirectoryError(Directories.Cor20HeaderMetaData' streamHeader.Offset' MetadataReaderErrorKind.NotEnoughSpaceForMetadataStream); " is 149.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheStreams,The length of the statement  "            this.ErrorContainer.AddDirectoryError(Directories.Cor20HeaderMetaData' streamHeader.Offset' MetadataReaderErrorKind.UnknownMetadataStream); " is 139.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ReadCORModuleLevelData,The length of the statement  "        this.ErrorContainer.AddDirectoryError(Directories.Cor20HeaderMetaData' 0' MetadataReaderErrorKind.NotEnoughSpaceForMetadataDirectory); " is 134.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ReadMetadataTableInformation,The length of the statement  "        this.ErrorContainer.AddMetadataStreamError(this.MetadataStreamName' 0' MetadataReaderErrorKind.MetadataTableHeaderTooSmall); " is 124.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ReadMetadataTableInformation,The length of the statement  "          this.ErrorContainer.AddMetadataStreamError(this.MetadataStreamName' 4' MetadataReaderErrorKind.UnknownVersionOfMetadata); " is 121.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ReadMetadataTableInformation,The length of the statement  "      if (this.MetadataStreamKind == MetadataStreamKind.Compressed && (presentTables & (ulong)TableMask.CompressedStreamNotAllowedMask) != 0) { " is 137.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ReadMetadataTableInformation,The length of the statement  "        this.ErrorContainer.AddMetadataStreamError(this.MetadataStreamName' 8' MetadataReaderErrorKind.IllegalTablesInCompressedMetadataStream); " is 136.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ReadMetadataTableInformation,The length of the statement  "        this.ErrorContainer.AddMetadataStreamError(this.MetadataStreamName' 16' MetadataReaderErrorKind.SomeRequiredTablesNotSorted); " is 125.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ReadMetadataTableInformation,The length of the statement  "        //Carry on regardless. There are/were compiler out there that sort the required tables' but fail to set the bit in SortedTables. " is 128.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ReadMetadataTableInformation,The length of the statement  "        this.ErrorContainer.AddMetadataStreamError(this.MetadataStreamName' memReader.Offset' MetadataReaderErrorKind.TableRowCountSpaceTooSmall); " is 138.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      int propertyRefSize = rowRefSizeArray[(int)TableIndices.PropertyPtr] > 2 ? 4 : rowRefSizeArray[(int)TableIndices.Property]; " is 123.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      int typeDefOrRefRefSize = PEFileReader.ComputeCodedTokenSize(TypeDefOrRefTag.LargeRowSize' rowCountArray' TypeDefOrRefTag.TablesReferenced); " is 140.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      int hasConstantRefSize = PEFileReader.ComputeCodedTokenSize(HasConstantTag.LargeRowSize' rowCountArray' HasConstantTag.TablesReferenced); " is 137.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      int hasCustomAttributeRefSize = PEFileReader.ComputeCodedTokenSize(HasCustomAttributeTag.LargeRowSize' rowCountArray' HasCustomAttributeTag.TablesReferenced); " is 158.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      int hasFieldMarshalRefSize = PEFileReader.ComputeCodedTokenSize(HasFieldMarshalTag.LargeRowSize' rowCountArray' HasFieldMarshalTag.TablesReferenced); " is 149.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      int hasDeclSecurityRefSize = PEFileReader.ComputeCodedTokenSize(HasDeclSecurityTag.LargeRowSize' rowCountArray' HasDeclSecurityTag.TablesReferenced); " is 149.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      int memberRefParentRefSize = PEFileReader.ComputeCodedTokenSize(MemberRefParentTag.LargeRowSize' rowCountArray' MemberRefParentTag.TablesReferenced); " is 149.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      int hasSemanticsRefSize = PEFileReader.ComputeCodedTokenSize(HasSemanticsTag.LargeRowSize' rowCountArray' HasSemanticsTag.TablesReferenced); " is 140.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      int methodDefOrRefRefSize = PEFileReader.ComputeCodedTokenSize(MethodDefOrRefTag.LargeRowSize' rowCountArray' MethodDefOrRefTag.TablesReferenced); " is 146.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      int memberForwardedRefSize = PEFileReader.ComputeCodedTokenSize(MemberForwardedTag.LargeRowSize' rowCountArray' MemberForwardedTag.TablesReferenced); " is 149.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      int implementationRefSize = PEFileReader.ComputeCodedTokenSize(ImplementationTag.LargeRowSize' rowCountArray' ImplementationTag.TablesReferenced); " is 146.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      int customAttributeTypeRefSize = PEFileReader.ComputeCodedTokenSize(CustomAttributeTypeTag.LargeRowSize' rowCountArray' CustomAttributeTypeTag.TablesReferenced); " is 161.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      int resolutionScopeRefSize = PEFileReader.ComputeCodedTokenSize(ResolutionScopeTag.LargeRowSize' rowCountArray' ResolutionScopeTag.TablesReferenced); " is 149.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      int typeOrMethodDefRefSize = PEFileReader.ComputeCodedTokenSize(TypeOrMethodDefTag.LargeRowSize' rowCountArray' TypeOrMethodDefTag.TablesReferenced); " is 149.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      int stringHeapRefSize = (this.MetadataTableHeader.HeapSizeFlags & HeapSizeFlag.StringHeapLarge) == HeapSizeFlag.StringHeapLarge ? 4 : 2; " is 136.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      int guidHeapRefSize = (this.MetadataTableHeader.HeapSizeFlags & HeapSizeFlag.GUIDHeapLarge) == HeapSizeFlag.GUIDHeapLarge ? 4 : 2; " is 130.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      int blobHeapRefSize = (this.MetadataTableHeader.HeapSizeFlags & HeapSizeFlag.BlobHeapLarge) == HeapSizeFlag.BlobHeapLarge ? 4 : 2; " is 130.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      this.ModuleTable = new ModuleTableReader(rowCountArray[(int)TableIndices.Module]' stringHeapRefSize' guidHeapRefSize' currentPointer); " is 134.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      this.TypeRefTable = new TypeRefTableReader(rowCountArray[(int)TableIndices.TypeRef]' resolutionScopeRefSize' stringHeapRefSize' currentPointer); " is 144.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      this.TypeDefTable = new TypeDefTableReader(rowCountArray[(int)TableIndices.TypeDef]' fieldRefSize' methodRefSize' typeDefOrRefRefSize' stringHeapRefSize' currentPointer); " is 170.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      this.FieldPtrTable = new FieldPtrTableReader(rowCountArray[(int)TableIndices.FieldPtr]' rowRefSizeArray[(int)TableIndices.Field]' currentPointer); " is 146.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      this.FieldTable = new FieldTableReader(rowCountArray[(int)TableIndices.Field]' stringHeapRefSize' blobHeapRefSize' currentPointer); " is 131.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      this.MethodPtrTable = new MethodPtrTableReader(rowCountArray[(int)TableIndices.MethodPtr]' rowRefSizeArray[(int)TableIndices.Method]' currentPointer); " is 150.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      this.MethodTable = new MethodTableReader(rowCountArray[(int)TableIndices.Method]' paramRefSize' stringHeapRefSize' blobHeapRefSize' currentPointer); " is 148.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      this.ParamPtrTable = new ParamPtrTableReader(rowCountArray[(int)TableIndices.ParamPtr]' rowRefSizeArray[(int)TableIndices.Param]' currentPointer); " is 146.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      this.InterfaceImplTable = new InterfaceImplTableReader(rowCountArray[(int)TableIndices.InterfaceImpl]' rowRefSizeArray[(int)TableIndices.TypeDef]' typeDefOrRefRefSize' currentPointer); " is 184.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      this.MemberRefTable = new MemberRefTableReader(rowCountArray[(int)TableIndices.MemberRef]' memberRefParentRefSize' stringHeapRefSize' blobHeapRefSize' currentPointer); " is 167.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      this.ConstantTable = new ConstantTableReader(rowCountArray[(int)TableIndices.Constant]' hasConstantRefSize' blobHeapRefSize' currentPointer); " is 141.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      this.CustomAttributeTable = new CustomAttributeTableReader(rowCountArray[(int)TableIndices.CustomAttribute]' hasCustomAttributeRefSize' customAttributeTypeRefSize' blobHeapRefSize' currentPointer); " is 197.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      this.FieldMarshalTable = new FieldMarshalTableReader(rowCountArray[(int)TableIndices.FieldMarshal]' hasFieldMarshalRefSize' blobHeapRefSize' currentPointer); " is 157.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      this.DeclSecurityTable = new DeclSecurityTableReader(rowCountArray[(int)TableIndices.DeclSecurity]' hasDeclSecurityRefSize' blobHeapRefSize' currentPointer); " is 157.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      this.ClassLayoutTable = new ClassLayoutTableReader(rowCountArray[(int)TableIndices.ClassLayout]' rowRefSizeArray[(int)TableIndices.TypeDef]' currentPointer); " is 157.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      this.FieldLayoutTable = new FieldLayoutTableReader(rowCountArray[(int)TableIndices.FieldLayout]' rowRefSizeArray[(int)TableIndices.Field]' currentPointer); " is 155.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      this.StandAloneSigTable = new StandAloneSigTableReader(rowCountArray[(int)TableIndices.StandAloneSig]' blobHeapRefSize' currentPointer); " is 136.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      this.EventMapTable = new EventMapTableReader(rowCountArray[(int)TableIndices.EventMap]' rowRefSizeArray[(int)TableIndices.TypeDef]' eventRefSize' currentPointer); " is 162.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      this.EventPtrTable = new EventPtrTableReader(rowCountArray[(int)TableIndices.EventPtr]' rowRefSizeArray[(int)TableIndices.Event]' currentPointer); " is 146.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      this.EventTable = new EventTableReader(rowCountArray[(int)TableIndices.Event]' typeDefOrRefRefSize' stringHeapRefSize' currentPointer); " is 135.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      this.PropertyMapTable = new PropertyMapTableReader(rowCountArray[(int)TableIndices.PropertyMap]' rowRefSizeArray[(int)TableIndices.TypeDef]' propertyRefSize' currentPointer); " is 174.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      this.PropertyPtrTable = new PropertyPtrTableReader(rowCountArray[(int)TableIndices.PropertyPtr]' rowRefSizeArray[(int)TableIndices.Property]' currentPointer); " is 158.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      this.PropertyTable = new PropertyTableReader(rowCountArray[(int)TableIndices.Property]' stringHeapRefSize' blobHeapRefSize' currentPointer); " is 140.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      this.MethodSemanticsTable = new MethodSemanticsTableReader(rowCountArray[(int)TableIndices.MethodSemantics]' rowRefSizeArray[(int)TableIndices.Method]' hasSemanticsRefSize' currentPointer); " is 189.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      this.MethodImplTable = new MethodImplTableReader(rowCountArray[(int)TableIndices.MethodImpl]' rowRefSizeArray[(int)TableIndices.TypeDef]' methodDefOrRefRefSize' currentPointer); " is 177.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      this.ModuleRefTable = new ModuleRefTableReader(rowCountArray[(int)TableIndices.ModuleRef]' stringHeapRefSize' currentPointer); " is 126.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      this.TypeSpecTable = new TypeSpecTableReader(rowCountArray[(int)TableIndices.TypeSpec]' blobHeapRefSize' currentPointer); " is 121.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      this.ImplMapTable = new ImplMapTableReader(rowCountArray[(int)TableIndices.ImplMap]' rowRefSizeArray[(int)TableIndices.ModuleRef]' memberForwardedRefSize' stringHeapRefSize' currentPointer); " is 190.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      this.FieldRVATable = new FieldRVATableReader(rowCountArray[(int)TableIndices.FieldRva]' rowRefSizeArray[(int)TableIndices.Field]' currentPointer); " is 146.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      this.AssemblyTable = new AssemblyTableReader(rowCountArray[(int)TableIndices.Assembly]' stringHeapRefSize' blobHeapRefSize' currentPointer); " is 140.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      this.AssemblyProcessorTable = new AssemblyProcessorTableReader(rowCountArray[(int)TableIndices.AssemblyProcessor]' currentPointer); " is 131.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      this.AssemblyRefTable = new AssemblyRefTableReader(rowCountArray[(int)TableIndices.AssemblyRef]' stringHeapRefSize' blobHeapRefSize' currentPointer); " is 149.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      this.AssemblyRefProcessorTable = new AssemblyRefProcessorTableReader(rowCountArray[(int)TableIndices.AssemblyRefProcessor]' rowRefSizeArray[(int)TableIndices.AssemblyRef]' currentPointer); " is 188.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      this.AssemblyRefOSTable = new AssemblyRefOSTableReader(rowCountArray[(int)TableIndices.AssemblyRefOS]' rowRefSizeArray[(int)TableIndices.AssemblyRef]' currentPointer); " is 167.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      this.FileTable = new FileTableReader(rowCountArray[(int)TableIndices.File]' stringHeapRefSize' blobHeapRefSize' currentPointer); " is 128.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      this.ExportedTypeTable = new ExportedTypeTableReader(rowCountArray[(int)TableIndices.ExportedType]' implementationRefSize' stringHeapRefSize' currentPointer); " is 158.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      this.ManifestResourceTable = new ManifestResourceTableReader(rowCountArray[(int)TableIndices.ManifestResource]' implementationRefSize' stringHeapRefSize' currentPointer); " is 170.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      this.NestedClassTable = new NestedClassTableReader(rowCountArray[(int)TableIndices.NestedClass]' rowRefSizeArray[(int)TableIndices.TypeDef]' currentPointer); " is 157.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      this.GenericParamTable = new GenericParamTableReader(rowCountArray[(int)TableIndices.GenericParam]' typeOrMethodDefRefSize' stringHeapRefSize' currentPointer); " is 159.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      this.MethodSpecTable = new MethodSpecTableReader(rowCountArray[(int)TableIndices.MethodSpec]' methodDefOrRefRefSize' blobHeapRefSize' currentPointer); " is 150.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "      this.GenericParamConstraintTable = new GenericParamConstraintTableReader(rowCountArray[(int)TableIndices.GenericParamConstraint]' rowRefSizeArray[(int)TableIndices.GenericParam]' typeDefOrRefRefSize' currentPointer); " is 216.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "        this.ErrorContainer.AddDirectoryError(Directories.Cor20HeaderMetaData' 0' MetadataReaderErrorKind.MetadataTablesTooSmall); " is 122.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,GetFieldInformation,The length of the statement  "        fieldCount = (this.UseFieldPtrTable ? this.FieldPtrTable.NumberOfRows : this.FieldTable.NumberOfRows) - fieldStartRow + 1; " is 122.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,GetMethodInformation,The length of the statement  "        methodCount = (this.UseMethodPtrTable ? this.MethodPtrTable.NumberOfRows : this.MethodTable.NumberOfRows) - methodStartRow + 1; " is 127.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,GetEventInformation,The length of the statement  "        eventCount = (this.UseEventPtrTable ? this.EventPtrTable.NumberOfRows : this.EventTable.NumberOfRows) - eventStartRow + 1; " is 122.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,GetPropertyInformation,The length of the statement  "        propertyCount = (this.UsePropertyPtrTable ? this.PropertyPtrTable.NumberOfRows : this.PropertyTable.NumberOfRows) - propertyStartRow + 1; " is 137.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,GetParamInformation,The length of the statement  "        paramRowCount = (this.UseParamPtrTable ? this.ParamPtrTable.NumberOfRows : this.ParamTable.NumberOfRows) - paramStartRow + 1; " is 125.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,GetSmallSEHEntries,The length of the statement  "        retSEHEntries[i] = new SEHTableEntry(sehFlags' tryOffset' tryLength' handlerOffset' handlerLength' classTokenOrFilterOffset); " is 125.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,GetFatSEHEntries,The length of the statement  "        retSEHEntries[i] = new SEHTableEntry(sehFlags' tryOffset' tryLength' handlerOffset' handlerLength' classTokenOrFilterOffset); " is 125.
Complex Conditional,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,IsEndofIdentifier,The conditional expression  "c == '[' || c == ']' || c == '*' || c == '+' || c == ''' || c == '&' || c == ' ' || char.IsWhiteSpace(c)"  is complex.
Complex Conditional,Microsoft.Cci.MetadataReader,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,IsEndofIdentifier,The conditional expression  "c == '[' || c == ']' || c == '*' || c == '+' || c == ''' || c == '&' || c == ' ' || char.IsWhiteSpace(c)"  is complex.
Complex Conditional,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetCoreAssemblySymbolicIdentity,The conditional expression  "tKey != objectKey && tKey != valueTypeKey && tKey != enumKey && tKey != multicastDelegateKey && tKey != arrayKey &&              tKey != attributeKey && tKey != delegateKey && tKey != iAsyncResultKey && tKey != iCloneableKey && tKey != asyncCallbackKey &&              tKey != attributeUsageAttributeKey && tKey != paramArrayAttributeKey && tKey != booleanKey && tKey != byteKey && tKey != charKey &&              tKey != sByteKey && tKey != int16Key && tKey != uint16Key && tKey != int32Key && tKey != uint32Key && tKey != int64Key &&              tKey != uint64Key && tKey != stringKey && tKey != intPtrKey && tKey != uintPtrKey && tKey != singleKey && tKey != doubleKey &&              tKey != typedReferenceKey && tKey != typeKey && tKey != dateTimeKey && tKey != decimalKey && tKey != dbNullKey &&              tKey != runtimeArgumentHandleKey && tKey != runtimeFieldHandleKey && tKey != runtimeMethodHandleKey &&              tKey != runtimeTypeHandleKey && tKey != argIteratorKey && tKey != voidKey"  is complex.
Complex Conditional,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,RVAsInSameSection,The conditional expression  "sectionHeaderIter.VirtualAddress <= RVA1 && RVA1 < sectionHeaderIter.VirtualAddress + sectionHeaderIter.VirtualSize            && sectionHeaderIter.VirtualAddress <= RVA2 && RVA2 < sectionHeaderIter.VirtualAddress + sectionHeaderIter.VirtualSize"  is complex.
Complex Conditional,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ReadCORModuleLevelData,The conditional expression  "!this.ReadMetadataHeader(ref memReader)          || !this.ReadStorageHeader(ref memReader)          || !this.ReadStreamHeaders(ref memReader)          || !this.ProcessAndCacheStreams(ref metadataRoot)"  is complex.
Empty Catch Block,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ScanVersion,The method has an empty catch block.
Empty Catch Block,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ScanVersion,The method has an empty catch block.
Empty Catch Block,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ScanVersion,The method has an empty catch block.
Empty Catch Block,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ScanVersion,The method has an empty catch block.
Empty Catch Block,Microsoft.Cci.MetadataReader,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ScanVersion,The method has an empty catch block.
Empty Catch Block,Microsoft.Cci.MetadataReader,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ScanVersion,The method has an empty catch block.
Empty Catch Block,Microsoft.Cci.MetadataReader,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ScanVersion,The method has an empty catch block.
Empty Catch Block,Microsoft.Cci.MetadataReader,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ScanVersion,The method has an empty catch block.
Empty Catch Block,Microsoft.Cci,PeReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\ModuleReadWriteFactory.cs,OpenModule,The method has an empty catch block.
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ScanBoolean,The following statement contains a magic number: if (currPtr + 4 <= this.Length && string.Compare(name.Substring(currPtr' 4)' "true"' StringComparison.OrdinalIgnoreCase) == 0) {          this.CurrentIndex += 4;          return true;        }
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ScanBoolean,The following statement contains a magic number: if (currPtr + 4 <= this.Length && string.Compare(name.Substring(currPtr' 4)' "true"' StringComparison.OrdinalIgnoreCase) == 0) {          this.CurrentIndex += 4;          return true;        }
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ScanBoolean,The following statement contains a magic number: if (currPtr + 4 <= this.Length && string.Compare(name.Substring(currPtr' 4)' "true"' StringComparison.OrdinalIgnoreCase) == 0) {          this.CurrentIndex += 4;          return true;        }
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ScanBoolean,The following statement contains a magic number: if (currPtr + 5 <= this.Length && string.Compare(name.Substring(currPtr' 5)' "false"' StringComparison.OrdinalIgnoreCase) == 0) {          this.CurrentIndex += 5;        }
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ScanBoolean,The following statement contains a magic number: if (currPtr + 5 <= this.Length && string.Compare(name.Substring(currPtr' 5)' "false"' StringComparison.OrdinalIgnoreCase) == 0) {          this.CurrentIndex += 5;        }
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ScanBoolean,The following statement contains a magic number: if (currPtr + 5 <= this.Length && string.Compare(name.Substring(currPtr' 5)' "false"' StringComparison.OrdinalIgnoreCase) == 0) {          this.CurrentIndex += 5;        }
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ScanPublicKeyToken,The following statement contains a magic number: if (currPtr + 4 <= this.Length && string.Compare(name.Substring(currPtr' 4)' "null"' StringComparison.OrdinalIgnoreCase) == 0) {          this.CurrentIndex += 4;          return TypeCache.EmptyByteArray;        }
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ScanPublicKeyToken,The following statement contains a magic number: if (currPtr + 4 <= this.Length && string.Compare(name.Substring(currPtr' 4)' "null"' StringComparison.OrdinalIgnoreCase) == 0) {          this.CurrentIndex += 4;          return TypeCache.EmptyByteArray;        }
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ScanPublicKeyToken,The following statement contains a magic number: if (currPtr + 4 <= this.Length && string.Compare(name.Substring(currPtr' 4)' "null"' StringComparison.OrdinalIgnoreCase) == 0) {          this.CurrentIndex += 4;          return TypeCache.EmptyByteArray;        }
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ScanPublicKeyToken,The following statement contains a magic number: if (currPtr + 16 > this.Length) {          return TypeCache.EmptyByteArray;        }
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ScanPublicKeyToken,The following statement contains a magic number: string val = name.Substring(currPtr' 16);
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ScanPublicKeyToken,The following statement contains a magic number: this.CurrentIndex += 16;
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ScanPublicKeyToken,The following statement contains a magic number: byte[] pkToken = new byte[8];
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ScanPublicKeyToken,The following statement contains a magic number: for (int i = 7; i >= 0; --i) {          pkToken[i] = (byte)result;          result >>= 8;        }
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ScanPublicKeyToken,The following statement contains a magic number: for (int i = 7; i >= 0; --i) {          pkToken[i] = (byte)result;          result >>= 8;        }
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,AttributeDecoder,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: switch (type.SignatureTypeCode) {          case ModuleSignatureTypeCode.SByte:            if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (sbyte)0;            }            return this.SignatureMemoryReader.ReadSByte();          case ModuleSignatureTypeCode.Int16:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (short)0;            }            return this.SignatureMemoryReader.ReadInt16();          case ModuleSignatureTypeCode.Int32:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (int)0;            }            return this.SignatureMemoryReader.ReadInt32();          case ModuleSignatureTypeCode.Int64:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (long)0;            }            return this.SignatureMemoryReader.ReadInt64();          case ModuleSignatureTypeCode.Byte:            if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (byte)0;            }            return this.SignatureMemoryReader.ReadByte();          case ModuleSignatureTypeCode.UInt16:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (ushort)0;            }            return this.SignatureMemoryReader.ReadUInt16();          case ModuleSignatureTypeCode.UInt32:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (uint)0;            }            return this.SignatureMemoryReader.ReadUInt32();          case ModuleSignatureTypeCode.UInt64:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (ulong)0;            }            return this.SignatureMemoryReader.ReadUInt64();          case ModuleSignatureTypeCode.Single:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (float)0;            }            return this.SignatureMemoryReader.ReadSingle();          case ModuleSignatureTypeCode.Double:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (double)0;            }            return this.SignatureMemoryReader.ReadDouble();          case ModuleSignatureTypeCode.Boolean: {              if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {                this.decodeFailed = true;                return false;              }              byte val = this.SignatureMemoryReader.ReadByte();              return val == 1;            }          case ModuleSignatureTypeCode.Char:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (char)0;            }            return this.SignatureMemoryReader.ReadChar();        }
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,AttributeDecoder,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: switch (type.SignatureTypeCode) {          case ModuleSignatureTypeCode.SByte:            if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (sbyte)0;            }            return this.SignatureMemoryReader.ReadSByte();          case ModuleSignatureTypeCode.Int16:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (short)0;            }            return this.SignatureMemoryReader.ReadInt16();          case ModuleSignatureTypeCode.Int32:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (int)0;            }            return this.SignatureMemoryReader.ReadInt32();          case ModuleSignatureTypeCode.Int64:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (long)0;            }            return this.SignatureMemoryReader.ReadInt64();          case ModuleSignatureTypeCode.Byte:            if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (byte)0;            }            return this.SignatureMemoryReader.ReadByte();          case ModuleSignatureTypeCode.UInt16:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (ushort)0;            }            return this.SignatureMemoryReader.ReadUInt16();          case ModuleSignatureTypeCode.UInt32:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (uint)0;            }            return this.SignatureMemoryReader.ReadUInt32();          case ModuleSignatureTypeCode.UInt64:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (ulong)0;            }            return this.SignatureMemoryReader.ReadUInt64();          case ModuleSignatureTypeCode.Single:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (float)0;            }            return this.SignatureMemoryReader.ReadSingle();          case ModuleSignatureTypeCode.Double:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (double)0;            }            return this.SignatureMemoryReader.ReadDouble();          case ModuleSignatureTypeCode.Boolean: {              if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {                this.decodeFailed = true;                return false;              }              byte val = this.SignatureMemoryReader.ReadByte();              return val == 1;            }          case ModuleSignatureTypeCode.Char:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (char)0;            }            return this.SignatureMemoryReader.ReadChar();        }
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,AttributeDecoder,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: switch (type.SignatureTypeCode) {          case ModuleSignatureTypeCode.SByte:            if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (sbyte)0;            }            return this.SignatureMemoryReader.ReadSByte();          case ModuleSignatureTypeCode.Int16:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (short)0;            }            return this.SignatureMemoryReader.ReadInt16();          case ModuleSignatureTypeCode.Int32:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (int)0;            }            return this.SignatureMemoryReader.ReadInt32();          case ModuleSignatureTypeCode.Int64:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (long)0;            }            return this.SignatureMemoryReader.ReadInt64();          case ModuleSignatureTypeCode.Byte:            if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (byte)0;            }            return this.SignatureMemoryReader.ReadByte();          case ModuleSignatureTypeCode.UInt16:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (ushort)0;            }            return this.SignatureMemoryReader.ReadUInt16();          case ModuleSignatureTypeCode.UInt32:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (uint)0;            }            return this.SignatureMemoryReader.ReadUInt32();          case ModuleSignatureTypeCode.UInt64:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (ulong)0;            }            return this.SignatureMemoryReader.ReadUInt64();          case ModuleSignatureTypeCode.Single:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (float)0;            }            return this.SignatureMemoryReader.ReadSingle();          case ModuleSignatureTypeCode.Double:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (double)0;            }            return this.SignatureMemoryReader.ReadDouble();          case ModuleSignatureTypeCode.Boolean: {              if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {                this.decodeFailed = true;                return false;              }              byte val = this.SignatureMemoryReader.ReadByte();              return val == 1;            }          case ModuleSignatureTypeCode.Char:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (char)0;            }            return this.SignatureMemoryReader.ReadChar();        }
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,AttributeDecoder,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: switch (type.SignatureTypeCode) {          case ModuleSignatureTypeCode.SByte:            if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (sbyte)0;            }            return this.SignatureMemoryReader.ReadSByte();          case ModuleSignatureTypeCode.Int16:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (short)0;            }            return this.SignatureMemoryReader.ReadInt16();          case ModuleSignatureTypeCode.Int32:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (int)0;            }            return this.SignatureMemoryReader.ReadInt32();          case ModuleSignatureTypeCode.Int64:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (long)0;            }            return this.SignatureMemoryReader.ReadInt64();          case ModuleSignatureTypeCode.Byte:            if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (byte)0;            }            return this.SignatureMemoryReader.ReadByte();          case ModuleSignatureTypeCode.UInt16:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (ushort)0;            }            return this.SignatureMemoryReader.ReadUInt16();          case ModuleSignatureTypeCode.UInt32:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (uint)0;            }            return this.SignatureMemoryReader.ReadUInt32();          case ModuleSignatureTypeCode.UInt64:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (ulong)0;            }            return this.SignatureMemoryReader.ReadUInt64();          case ModuleSignatureTypeCode.Single:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (float)0;            }            return this.SignatureMemoryReader.ReadSingle();          case ModuleSignatureTypeCode.Double:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (double)0;            }            return this.SignatureMemoryReader.ReadDouble();          case ModuleSignatureTypeCode.Boolean: {              if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {                this.decodeFailed = true;                return false;              }              byte val = this.SignatureMemoryReader.ReadByte();              return val == 1;            }          case ModuleSignatureTypeCode.Char:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (char)0;            }            return this.SignatureMemoryReader.ReadChar();        }
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,AttributeDecoder,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: switch (type.SignatureTypeCode) {          case ModuleSignatureTypeCode.SByte:            if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (sbyte)0;            }            return this.SignatureMemoryReader.ReadSByte();          case ModuleSignatureTypeCode.Int16:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (short)0;            }            return this.SignatureMemoryReader.ReadInt16();          case ModuleSignatureTypeCode.Int32:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (int)0;            }            return this.SignatureMemoryReader.ReadInt32();          case ModuleSignatureTypeCode.Int64:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (long)0;            }            return this.SignatureMemoryReader.ReadInt64();          case ModuleSignatureTypeCode.Byte:            if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (byte)0;            }            return this.SignatureMemoryReader.ReadByte();          case ModuleSignatureTypeCode.UInt16:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (ushort)0;            }            return this.SignatureMemoryReader.ReadUInt16();          case ModuleSignatureTypeCode.UInt32:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (uint)0;            }            return this.SignatureMemoryReader.ReadUInt32();          case ModuleSignatureTypeCode.UInt64:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (ulong)0;            }            return this.SignatureMemoryReader.ReadUInt64();          case ModuleSignatureTypeCode.Single:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (float)0;            }            return this.SignatureMemoryReader.ReadSingle();          case ModuleSignatureTypeCode.Double:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (double)0;            }            return this.SignatureMemoryReader.ReadDouble();          case ModuleSignatureTypeCode.Boolean: {              if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {                this.decodeFailed = true;                return false;              }              byte val = this.SignatureMemoryReader.ReadByte();              return val == 1;            }          case ModuleSignatureTypeCode.Char:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (char)0;            }            return this.SignatureMemoryReader.ReadChar();        }
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,AttributeDecoder,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: switch (type.SignatureTypeCode) {          case ModuleSignatureTypeCode.SByte:            if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (sbyte)0;            }            return this.SignatureMemoryReader.ReadSByte();          case ModuleSignatureTypeCode.Int16:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (short)0;            }            return this.SignatureMemoryReader.ReadInt16();          case ModuleSignatureTypeCode.Int32:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (int)0;            }            return this.SignatureMemoryReader.ReadInt32();          case ModuleSignatureTypeCode.Int64:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (long)0;            }            return this.SignatureMemoryReader.ReadInt64();          case ModuleSignatureTypeCode.Byte:            if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (byte)0;            }            return this.SignatureMemoryReader.ReadByte();          case ModuleSignatureTypeCode.UInt16:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (ushort)0;            }            return this.SignatureMemoryReader.ReadUInt16();          case ModuleSignatureTypeCode.UInt32:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (uint)0;            }            return this.SignatureMemoryReader.ReadUInt32();          case ModuleSignatureTypeCode.UInt64:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (ulong)0;            }            return this.SignatureMemoryReader.ReadUInt64();          case ModuleSignatureTypeCode.Single:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (float)0;            }            return this.SignatureMemoryReader.ReadSingle();          case ModuleSignatureTypeCode.Double:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (double)0;            }            return this.SignatureMemoryReader.ReadDouble();          case ModuleSignatureTypeCode.Boolean: {              if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {                this.decodeFailed = true;                return false;              }              byte val = this.SignatureMemoryReader.ReadByte();              return val == 1;            }          case ModuleSignatureTypeCode.Char:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (char)0;            }            return this.SignatureMemoryReader.ReadChar();        }
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,AttributeDecoder,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: switch (type.SignatureTypeCode) {          case ModuleSignatureTypeCode.SByte:            if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (sbyte)0;            }            return this.SignatureMemoryReader.ReadSByte();          case ModuleSignatureTypeCode.Int16:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (short)0;            }            return this.SignatureMemoryReader.ReadInt16();          case ModuleSignatureTypeCode.Int32:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (int)0;            }            return this.SignatureMemoryReader.ReadInt32();          case ModuleSignatureTypeCode.Int64:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (long)0;            }            return this.SignatureMemoryReader.ReadInt64();          case ModuleSignatureTypeCode.Byte:            if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (byte)0;            }            return this.SignatureMemoryReader.ReadByte();          case ModuleSignatureTypeCode.UInt16:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (ushort)0;            }            return this.SignatureMemoryReader.ReadUInt16();          case ModuleSignatureTypeCode.UInt32:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (uint)0;            }            return this.SignatureMemoryReader.ReadUInt32();          case ModuleSignatureTypeCode.UInt64:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (ulong)0;            }            return this.SignatureMemoryReader.ReadUInt64();          case ModuleSignatureTypeCode.Single:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (float)0;            }            return this.SignatureMemoryReader.ReadSingle();          case ModuleSignatureTypeCode.Double:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (double)0;            }            return this.SignatureMemoryReader.ReadDouble();          case ModuleSignatureTypeCode.Boolean: {              if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {                this.decodeFailed = true;                return false;              }              byte val = this.SignatureMemoryReader.ReadByte();              return val == 1;            }          case ModuleSignatureTypeCode.Char:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (char)0;            }            return this.SignatureMemoryReader.ReadChar();        }
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,AttributeDecoder,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: switch (type.SignatureTypeCode) {          case ModuleSignatureTypeCode.SByte:            if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (sbyte)0;            }            return this.SignatureMemoryReader.ReadSByte();          case ModuleSignatureTypeCode.Int16:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (short)0;            }            return this.SignatureMemoryReader.ReadInt16();          case ModuleSignatureTypeCode.Int32:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (int)0;            }            return this.SignatureMemoryReader.ReadInt32();          case ModuleSignatureTypeCode.Int64:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (long)0;            }            return this.SignatureMemoryReader.ReadInt64();          case ModuleSignatureTypeCode.Byte:            if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (byte)0;            }            return this.SignatureMemoryReader.ReadByte();          case ModuleSignatureTypeCode.UInt16:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (ushort)0;            }            return this.SignatureMemoryReader.ReadUInt16();          case ModuleSignatureTypeCode.UInt32:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (uint)0;            }            return this.SignatureMemoryReader.ReadUInt32();          case ModuleSignatureTypeCode.UInt64:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (ulong)0;            }            return this.SignatureMemoryReader.ReadUInt64();          case ModuleSignatureTypeCode.Single:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (float)0;            }            return this.SignatureMemoryReader.ReadSingle();          case ModuleSignatureTypeCode.Double:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (double)0;            }            return this.SignatureMemoryReader.ReadDouble();          case ModuleSignatureTypeCode.Boolean: {              if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {                this.decodeFailed = true;                return false;              }              byte val = this.SignatureMemoryReader.ReadByte();              return val == 1;            }          case ModuleSignatureTypeCode.Char:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (char)0;            }            return this.SignatureMemoryReader.ReadChar();        }
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,AttributeDecoder,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: switch (type.SignatureTypeCode) {          case ModuleSignatureTypeCode.SByte:            if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (sbyte)0;            }            return this.SignatureMemoryReader.ReadSByte();          case ModuleSignatureTypeCode.Int16:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (short)0;            }            return this.SignatureMemoryReader.ReadInt16();          case ModuleSignatureTypeCode.Int32:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (int)0;            }            return this.SignatureMemoryReader.ReadInt32();          case ModuleSignatureTypeCode.Int64:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (long)0;            }            return this.SignatureMemoryReader.ReadInt64();          case ModuleSignatureTypeCode.Byte:            if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (byte)0;            }            return this.SignatureMemoryReader.ReadByte();          case ModuleSignatureTypeCode.UInt16:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (ushort)0;            }            return this.SignatureMemoryReader.ReadUInt16();          case ModuleSignatureTypeCode.UInt32:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (uint)0;            }            return this.SignatureMemoryReader.ReadUInt32();          case ModuleSignatureTypeCode.UInt64:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (ulong)0;            }            return this.SignatureMemoryReader.ReadUInt64();          case ModuleSignatureTypeCode.Single:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (float)0;            }            return this.SignatureMemoryReader.ReadSingle();          case ModuleSignatureTypeCode.Double:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (double)0;            }            return this.SignatureMemoryReader.ReadDouble();          case ModuleSignatureTypeCode.Boolean: {              if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {                this.decodeFailed = true;                return false;              }              byte val = this.SignatureMemoryReader.ReadByte();              return val == 1;            }          case ModuleSignatureTypeCode.Char:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (char)0;            }            return this.SignatureMemoryReader.ReadChar();        }
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,AttributeDecoder,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ReadSerializedValue,The following statement contains a magic number: switch (type.SignatureTypeCode) {          case ModuleSignatureTypeCode.SByte:          case ModuleSignatureTypeCode.Int16:          case ModuleSignatureTypeCode.Int32:          case ModuleSignatureTypeCode.Int64:          case ModuleSignatureTypeCode.Byte:          case ModuleSignatureTypeCode.UInt16:          case ModuleSignatureTypeCode.UInt32:          case ModuleSignatureTypeCode.UInt64:          case ModuleSignatureTypeCode.Single:          case ModuleSignatureTypeCode.Double:          case ModuleSignatureTypeCode.Boolean:          case ModuleSignatureTypeCode.Char:            return new ConstantExpression(type' this.GetPrimitiveValue(type));          case ModuleSignatureTypeCode.String:            return new ConstantExpression(type' this.GetSerializedString());          case ModuleSignatureTypeCode.Object: {              IModuleTypeReference/*?*/ underlyingType = this.GetFieldOrPropType();              if (underlyingType == null)                return null;              return this.ReadSerializedValue(underlyingType);            }          default:            if (type == this.PEFileToObjectModel.SystemType) {              string/*?*/ typeNameStr = this.GetSerializedString();              if (typeNameStr == null) {                return new ConstantExpression(this.PEFileToObjectModel.SystemType' null);              }              return new TypeOfExpression(this.PEFileToObjectModel' this.PEFileToObjectModel.GetSerializedTypeNameAsTypeReference(typeNameStr));            }            IModuleNominalType/*?*/ typeDef = type.ResolvedType as IModuleNominalType;            if (typeDef != null && typeDef.IsEnum)              return new ConstantExpression(type' this.GetPrimitiveValue(typeDef.EnumUnderlyingType));            VectorType/*?*/ vectorType = type as VectorType;            if (vectorType != null) {              IModuleTypeReference/*?*/ elementType = vectorType.ElementType;              if (elementType == null) {                this.decodeFailed = true;                return null;              }              int size = this.SignatureMemoryReader.ReadInt32();              if (size == -1) {                return new ConstantExpression(vectorType' null);              }              List<ExpressionBase> arrayElements = new List<ExpressionBase>();              for (int i = 0; i < size; ++i) {                ExpressionBase/*?*/ expr = this.ReadSerializedValue(elementType);                if (expr == null) {                  this.decodeFailed = true;                  return null;                }                arrayElements.Add(expr);              }              return new ArrayExpression(vectorType' new EnumerableArrayWrapper<ExpressionBase' IMetadataExpression>(arrayElements.ToArray()' Dummy.Expression));            } else {              // If the metadata is correct' type must be a reference to an enum type.              // Problem is' that without resolving this reference' it is not possible to know how many bytes to consume for the enum value              // We'll let the host deal with this by guessing              IModuleNominalType underlyingType;              switch (this.PEFileToObjectModel.ModuleReader.metadataReaderHost.GuessUnderlyingTypeSizeOfUnresolvableReferenceToEnum(type)) {                case 1: underlyingType = this.PEFileToObjectModel.SystemByte; break;                case 2: underlyingType = this.PEFileToObjectModel.SystemInt16; break;                case 4: underlyingType = this.PEFileToObjectModel.SystemInt32; break;                case 8: underlyingType = this.PEFileToObjectModel.SystemInt64; break;                default:                  this.decodeFailed = true; this.morePermutationsArePossible = false;                  return new ConstantExpression(type' 0);              }              return new ConstantExpression(type' this.GetPrimitiveValue(underlyingType));            }        }
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,AttributeDecoder,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ReadSerializedValue,The following statement contains a magic number: switch (type.SignatureTypeCode) {          case ModuleSignatureTypeCode.SByte:          case ModuleSignatureTypeCode.Int16:          case ModuleSignatureTypeCode.Int32:          case ModuleSignatureTypeCode.Int64:          case ModuleSignatureTypeCode.Byte:          case ModuleSignatureTypeCode.UInt16:          case ModuleSignatureTypeCode.UInt32:          case ModuleSignatureTypeCode.UInt64:          case ModuleSignatureTypeCode.Single:          case ModuleSignatureTypeCode.Double:          case ModuleSignatureTypeCode.Boolean:          case ModuleSignatureTypeCode.Char:            return new ConstantExpression(type' this.GetPrimitiveValue(type));          case ModuleSignatureTypeCode.String:            return new ConstantExpression(type' this.GetSerializedString());          case ModuleSignatureTypeCode.Object: {              IModuleTypeReference/*?*/ underlyingType = this.GetFieldOrPropType();              if (underlyingType == null)                return null;              return this.ReadSerializedValue(underlyingType);            }          default:            if (type == this.PEFileToObjectModel.SystemType) {              string/*?*/ typeNameStr = this.GetSerializedString();              if (typeNameStr == null) {                return new ConstantExpression(this.PEFileToObjectModel.SystemType' null);              }              return new TypeOfExpression(this.PEFileToObjectModel' this.PEFileToObjectModel.GetSerializedTypeNameAsTypeReference(typeNameStr));            }            IModuleNominalType/*?*/ typeDef = type.ResolvedType as IModuleNominalType;            if (typeDef != null && typeDef.IsEnum)              return new ConstantExpression(type' this.GetPrimitiveValue(typeDef.EnumUnderlyingType));            VectorType/*?*/ vectorType = type as VectorType;            if (vectorType != null) {              IModuleTypeReference/*?*/ elementType = vectorType.ElementType;              if (elementType == null) {                this.decodeFailed = true;                return null;              }              int size = this.SignatureMemoryReader.ReadInt32();              if (size == -1) {                return new ConstantExpression(vectorType' null);              }              List<ExpressionBase> arrayElements = new List<ExpressionBase>();              for (int i = 0; i < size; ++i) {                ExpressionBase/*?*/ expr = this.ReadSerializedValue(elementType);                if (expr == null) {                  this.decodeFailed = true;                  return null;                }                arrayElements.Add(expr);              }              return new ArrayExpression(vectorType' new EnumerableArrayWrapper<ExpressionBase' IMetadataExpression>(arrayElements.ToArray()' Dummy.Expression));            } else {              // If the metadata is correct' type must be a reference to an enum type.              // Problem is' that without resolving this reference' it is not possible to know how many bytes to consume for the enum value              // We'll let the host deal with this by guessing              IModuleNominalType underlyingType;              switch (this.PEFileToObjectModel.ModuleReader.metadataReaderHost.GuessUnderlyingTypeSizeOfUnresolvableReferenceToEnum(type)) {                case 1: underlyingType = this.PEFileToObjectModel.SystemByte; break;                case 2: underlyingType = this.PEFileToObjectModel.SystemInt16; break;                case 4: underlyingType = this.PEFileToObjectModel.SystemInt32; break;                case 8: underlyingType = this.PEFileToObjectModel.SystemInt64; break;                default:                  this.decodeFailed = true; this.morePermutationsArePossible = false;                  return new ConstantExpression(type' 0);              }              return new ConstantExpression(type' this.GetPrimitiveValue(underlyingType));            }        }
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,AttributeDecoder,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ReadSerializedValue,The following statement contains a magic number: switch (type.SignatureTypeCode) {          case ModuleSignatureTypeCode.SByte:          case ModuleSignatureTypeCode.Int16:          case ModuleSignatureTypeCode.Int32:          case ModuleSignatureTypeCode.Int64:          case ModuleSignatureTypeCode.Byte:          case ModuleSignatureTypeCode.UInt16:          case ModuleSignatureTypeCode.UInt32:          case ModuleSignatureTypeCode.UInt64:          case ModuleSignatureTypeCode.Single:          case ModuleSignatureTypeCode.Double:          case ModuleSignatureTypeCode.Boolean:          case ModuleSignatureTypeCode.Char:            return new ConstantExpression(type' this.GetPrimitiveValue(type));          case ModuleSignatureTypeCode.String:            return new ConstantExpression(type' this.GetSerializedString());          case ModuleSignatureTypeCode.Object: {              IModuleTypeReference/*?*/ underlyingType = this.GetFieldOrPropType();              if (underlyingType == null)                return null;              return this.ReadSerializedValue(underlyingType);            }          default:            if (type == this.PEFileToObjectModel.SystemType) {              string/*?*/ typeNameStr = this.GetSerializedString();              if (typeNameStr == null) {                return new ConstantExpression(this.PEFileToObjectModel.SystemType' null);              }              return new TypeOfExpression(this.PEFileToObjectModel' this.PEFileToObjectModel.GetSerializedTypeNameAsTypeReference(typeNameStr));            }            IModuleNominalType/*?*/ typeDef = type.ResolvedType as IModuleNominalType;            if (typeDef != null && typeDef.IsEnum)              return new ConstantExpression(type' this.GetPrimitiveValue(typeDef.EnumUnderlyingType));            VectorType/*?*/ vectorType = type as VectorType;            if (vectorType != null) {              IModuleTypeReference/*?*/ elementType = vectorType.ElementType;              if (elementType == null) {                this.decodeFailed = true;                return null;              }              int size = this.SignatureMemoryReader.ReadInt32();              if (size == -1) {                return new ConstantExpression(vectorType' null);              }              List<ExpressionBase> arrayElements = new List<ExpressionBase>();              for (int i = 0; i < size; ++i) {                ExpressionBase/*?*/ expr = this.ReadSerializedValue(elementType);                if (expr == null) {                  this.decodeFailed = true;                  return null;                }                arrayElements.Add(expr);              }              return new ArrayExpression(vectorType' new EnumerableArrayWrapper<ExpressionBase' IMetadataExpression>(arrayElements.ToArray()' Dummy.Expression));            } else {              // If the metadata is correct' type must be a reference to an enum type.              // Problem is' that without resolving this reference' it is not possible to know how many bytes to consume for the enum value              // We'll let the host deal with this by guessing              IModuleNominalType underlyingType;              switch (this.PEFileToObjectModel.ModuleReader.metadataReaderHost.GuessUnderlyingTypeSizeOfUnresolvableReferenceToEnum(type)) {                case 1: underlyingType = this.PEFileToObjectModel.SystemByte; break;                case 2: underlyingType = this.PEFileToObjectModel.SystemInt16; break;                case 4: underlyingType = this.PEFileToObjectModel.SystemInt32; break;                case 8: underlyingType = this.PEFileToObjectModel.SystemInt64; break;                default:                  this.decodeFailed = true; this.morePermutationsArePossible = false;                  return new ConstantExpression(type' 0);              }              return new ConstantExpression(type' this.GetPrimitiveValue(underlyingType));            }        }
Magic Number,Microsoft.Cci.MetadataReader,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ScanBoolean,The following statement contains a magic number: if (currPtr + 4 <= this.Length && string.Compare(name.Substring(currPtr' 4)' "true"' StringComparison.OrdinalIgnoreCase) == 0) {          this.CurrentIndex += 4;          return true;        }
Magic Number,Microsoft.Cci.MetadataReader,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ScanBoolean,The following statement contains a magic number: if (currPtr + 4 <= this.Length && string.Compare(name.Substring(currPtr' 4)' "true"' StringComparison.OrdinalIgnoreCase) == 0) {          this.CurrentIndex += 4;          return true;        }
Magic Number,Microsoft.Cci.MetadataReader,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ScanBoolean,The following statement contains a magic number: if (currPtr + 4 <= this.Length && string.Compare(name.Substring(currPtr' 4)' "true"' StringComparison.OrdinalIgnoreCase) == 0) {          this.CurrentIndex += 4;          return true;        }
Magic Number,Microsoft.Cci.MetadataReader,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ScanBoolean,The following statement contains a magic number: if (currPtr + 5 <= this.Length && string.Compare(name.Substring(currPtr' 5)' "false"' StringComparison.OrdinalIgnoreCase) == 0) {          this.CurrentIndex += 5;        }
Magic Number,Microsoft.Cci.MetadataReader,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ScanBoolean,The following statement contains a magic number: if (currPtr + 5 <= this.Length && string.Compare(name.Substring(currPtr' 5)' "false"' StringComparison.OrdinalIgnoreCase) == 0) {          this.CurrentIndex += 5;        }
Magic Number,Microsoft.Cci.MetadataReader,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ScanBoolean,The following statement contains a magic number: if (currPtr + 5 <= this.Length && string.Compare(name.Substring(currPtr' 5)' "false"' StringComparison.OrdinalIgnoreCase) == 0) {          this.CurrentIndex += 5;        }
Magic Number,Microsoft.Cci.MetadataReader,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ScanPublicKeyToken,The following statement contains a magic number: if (currPtr + 4 <= this.Length && string.Compare(name.Substring(currPtr' 4)' "null"' StringComparison.OrdinalIgnoreCase) == 0) {          this.CurrentIndex += 4;          return TypeCache.EmptyByteArray;        }
Magic Number,Microsoft.Cci.MetadataReader,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ScanPublicKeyToken,The following statement contains a magic number: if (currPtr + 4 <= this.Length && string.Compare(name.Substring(currPtr' 4)' "null"' StringComparison.OrdinalIgnoreCase) == 0) {          this.CurrentIndex += 4;          return TypeCache.EmptyByteArray;        }
Magic Number,Microsoft.Cci.MetadataReader,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ScanPublicKeyToken,The following statement contains a magic number: if (currPtr + 4 <= this.Length && string.Compare(name.Substring(currPtr' 4)' "null"' StringComparison.OrdinalIgnoreCase) == 0) {          this.CurrentIndex += 4;          return TypeCache.EmptyByteArray;        }
Magic Number,Microsoft.Cci.MetadataReader,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ScanPublicKeyToken,The following statement contains a magic number: if (currPtr + 16 > this.Length) {          return TypeCache.EmptyByteArray;        }
Magic Number,Microsoft.Cci.MetadataReader,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ScanPublicKeyToken,The following statement contains a magic number: string val = name.Substring(currPtr' 16);
Magic Number,Microsoft.Cci.MetadataReader,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ScanPublicKeyToken,The following statement contains a magic number: this.CurrentIndex += 16;
Magic Number,Microsoft.Cci.MetadataReader,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ScanPublicKeyToken,The following statement contains a magic number: byte[] pkToken = new byte[8];
Magic Number,Microsoft.Cci.MetadataReader,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ScanPublicKeyToken,The following statement contains a magic number: for (int i = 7; i >= 0; --i) {          pkToken[i] = (byte)result;          result >>= 8;        }
Magic Number,Microsoft.Cci.MetadataReader,TypeNameParser,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ScanPublicKeyToken,The following statement contains a magic number: for (int i = 7; i >= 0; --i) {          pkToken[i] = (byte)result;          result >>= 8;        }
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: switch (type.SignatureTypeCode) {          case ModuleSignatureTypeCode.SByte:            if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (sbyte)0;            }            return this.SignatureMemoryReader.ReadSByte();          case ModuleSignatureTypeCode.Int16:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (short)0;            }            return this.SignatureMemoryReader.ReadInt16();          case ModuleSignatureTypeCode.Int32:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (int)0;            }            return this.SignatureMemoryReader.ReadInt32();          case ModuleSignatureTypeCode.Int64:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (long)0;            }            return this.SignatureMemoryReader.ReadInt64();          case ModuleSignatureTypeCode.Byte:            if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (byte)0;            }            return this.SignatureMemoryReader.ReadByte();          case ModuleSignatureTypeCode.UInt16:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (ushort)0;            }            return this.SignatureMemoryReader.ReadUInt16();          case ModuleSignatureTypeCode.UInt32:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (uint)0;            }            return this.SignatureMemoryReader.ReadUInt32();          case ModuleSignatureTypeCode.UInt64:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (ulong)0;            }            return this.SignatureMemoryReader.ReadUInt64();          case ModuleSignatureTypeCode.Single:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (float)0;            }            return this.SignatureMemoryReader.ReadSingle();          case ModuleSignatureTypeCode.Double:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (double)0;            }            return this.SignatureMemoryReader.ReadDouble();          case ModuleSignatureTypeCode.Boolean: {              if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {                this.decodeFailed = true;                return false;              }              byte val = this.SignatureMemoryReader.ReadByte();              return val == 1;            }          case ModuleSignatureTypeCode.Char:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (char)0;            }            return this.SignatureMemoryReader.ReadChar();        }
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: switch (type.SignatureTypeCode) {          case ModuleSignatureTypeCode.SByte:            if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (sbyte)0;            }            return this.SignatureMemoryReader.ReadSByte();          case ModuleSignatureTypeCode.Int16:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (short)0;            }            return this.SignatureMemoryReader.ReadInt16();          case ModuleSignatureTypeCode.Int32:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (int)0;            }            return this.SignatureMemoryReader.ReadInt32();          case ModuleSignatureTypeCode.Int64:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (long)0;            }            return this.SignatureMemoryReader.ReadInt64();          case ModuleSignatureTypeCode.Byte:            if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (byte)0;            }            return this.SignatureMemoryReader.ReadByte();          case ModuleSignatureTypeCode.UInt16:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (ushort)0;            }            return this.SignatureMemoryReader.ReadUInt16();          case ModuleSignatureTypeCode.UInt32:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (uint)0;            }            return this.SignatureMemoryReader.ReadUInt32();          case ModuleSignatureTypeCode.UInt64:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (ulong)0;            }            return this.SignatureMemoryReader.ReadUInt64();          case ModuleSignatureTypeCode.Single:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (float)0;            }            return this.SignatureMemoryReader.ReadSingle();          case ModuleSignatureTypeCode.Double:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (double)0;            }            return this.SignatureMemoryReader.ReadDouble();          case ModuleSignatureTypeCode.Boolean: {              if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {                this.decodeFailed = true;                return false;              }              byte val = this.SignatureMemoryReader.ReadByte();              return val == 1;            }          case ModuleSignatureTypeCode.Char:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (char)0;            }            return this.SignatureMemoryReader.ReadChar();        }
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: switch (type.SignatureTypeCode) {          case ModuleSignatureTypeCode.SByte:            if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (sbyte)0;            }            return this.SignatureMemoryReader.ReadSByte();          case ModuleSignatureTypeCode.Int16:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (short)0;            }            return this.SignatureMemoryReader.ReadInt16();          case ModuleSignatureTypeCode.Int32:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (int)0;            }            return this.SignatureMemoryReader.ReadInt32();          case ModuleSignatureTypeCode.Int64:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (long)0;            }            return this.SignatureMemoryReader.ReadInt64();          case ModuleSignatureTypeCode.Byte:            if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (byte)0;            }            return this.SignatureMemoryReader.ReadByte();          case ModuleSignatureTypeCode.UInt16:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (ushort)0;            }            return this.SignatureMemoryReader.ReadUInt16();          case ModuleSignatureTypeCode.UInt32:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (uint)0;            }            return this.SignatureMemoryReader.ReadUInt32();          case ModuleSignatureTypeCode.UInt64:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (ulong)0;            }            return this.SignatureMemoryReader.ReadUInt64();          case ModuleSignatureTypeCode.Single:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (float)0;            }            return this.SignatureMemoryReader.ReadSingle();          case ModuleSignatureTypeCode.Double:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (double)0;            }            return this.SignatureMemoryReader.ReadDouble();          case ModuleSignatureTypeCode.Boolean: {              if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {                this.decodeFailed = true;                return false;              }              byte val = this.SignatureMemoryReader.ReadByte();              return val == 1;            }          case ModuleSignatureTypeCode.Char:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (char)0;            }            return this.SignatureMemoryReader.ReadChar();        }
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: switch (type.SignatureTypeCode) {          case ModuleSignatureTypeCode.SByte:            if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (sbyte)0;            }            return this.SignatureMemoryReader.ReadSByte();          case ModuleSignatureTypeCode.Int16:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (short)0;            }            return this.SignatureMemoryReader.ReadInt16();          case ModuleSignatureTypeCode.Int32:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (int)0;            }            return this.SignatureMemoryReader.ReadInt32();          case ModuleSignatureTypeCode.Int64:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (long)0;            }            return this.SignatureMemoryReader.ReadInt64();          case ModuleSignatureTypeCode.Byte:            if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (byte)0;            }            return this.SignatureMemoryReader.ReadByte();          case ModuleSignatureTypeCode.UInt16:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (ushort)0;            }            return this.SignatureMemoryReader.ReadUInt16();          case ModuleSignatureTypeCode.UInt32:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (uint)0;            }            return this.SignatureMemoryReader.ReadUInt32();          case ModuleSignatureTypeCode.UInt64:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (ulong)0;            }            return this.SignatureMemoryReader.ReadUInt64();          case ModuleSignatureTypeCode.Single:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (float)0;            }            return this.SignatureMemoryReader.ReadSingle();          case ModuleSignatureTypeCode.Double:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (double)0;            }            return this.SignatureMemoryReader.ReadDouble();          case ModuleSignatureTypeCode.Boolean: {              if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {                this.decodeFailed = true;                return false;              }              byte val = this.SignatureMemoryReader.ReadByte();              return val == 1;            }          case ModuleSignatureTypeCode.Char:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (char)0;            }            return this.SignatureMemoryReader.ReadChar();        }
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: switch (type.SignatureTypeCode) {          case ModuleSignatureTypeCode.SByte:            if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (sbyte)0;            }            return this.SignatureMemoryReader.ReadSByte();          case ModuleSignatureTypeCode.Int16:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (short)0;            }            return this.SignatureMemoryReader.ReadInt16();          case ModuleSignatureTypeCode.Int32:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (int)0;            }            return this.SignatureMemoryReader.ReadInt32();          case ModuleSignatureTypeCode.Int64:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (long)0;            }            return this.SignatureMemoryReader.ReadInt64();          case ModuleSignatureTypeCode.Byte:            if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (byte)0;            }            return this.SignatureMemoryReader.ReadByte();          case ModuleSignatureTypeCode.UInt16:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (ushort)0;            }            return this.SignatureMemoryReader.ReadUInt16();          case ModuleSignatureTypeCode.UInt32:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (uint)0;            }            return this.SignatureMemoryReader.ReadUInt32();          case ModuleSignatureTypeCode.UInt64:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (ulong)0;            }            return this.SignatureMemoryReader.ReadUInt64();          case ModuleSignatureTypeCode.Single:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (float)0;            }            return this.SignatureMemoryReader.ReadSingle();          case ModuleSignatureTypeCode.Double:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (double)0;            }            return this.SignatureMemoryReader.ReadDouble();          case ModuleSignatureTypeCode.Boolean: {              if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {                this.decodeFailed = true;                return false;              }              byte val = this.SignatureMemoryReader.ReadByte();              return val == 1;            }          case ModuleSignatureTypeCode.Char:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (char)0;            }            return this.SignatureMemoryReader.ReadChar();        }
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: switch (type.SignatureTypeCode) {          case ModuleSignatureTypeCode.SByte:            if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (sbyte)0;            }            return this.SignatureMemoryReader.ReadSByte();          case ModuleSignatureTypeCode.Int16:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (short)0;            }            return this.SignatureMemoryReader.ReadInt16();          case ModuleSignatureTypeCode.Int32:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (int)0;            }            return this.SignatureMemoryReader.ReadInt32();          case ModuleSignatureTypeCode.Int64:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (long)0;            }            return this.SignatureMemoryReader.ReadInt64();          case ModuleSignatureTypeCode.Byte:            if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (byte)0;            }            return this.SignatureMemoryReader.ReadByte();          case ModuleSignatureTypeCode.UInt16:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (ushort)0;            }            return this.SignatureMemoryReader.ReadUInt16();          case ModuleSignatureTypeCode.UInt32:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (uint)0;            }            return this.SignatureMemoryReader.ReadUInt32();          case ModuleSignatureTypeCode.UInt64:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (ulong)0;            }            return this.SignatureMemoryReader.ReadUInt64();          case ModuleSignatureTypeCode.Single:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (float)0;            }            return this.SignatureMemoryReader.ReadSingle();          case ModuleSignatureTypeCode.Double:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (double)0;            }            return this.SignatureMemoryReader.ReadDouble();          case ModuleSignatureTypeCode.Boolean: {              if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {                this.decodeFailed = true;                return false;              }              byte val = this.SignatureMemoryReader.ReadByte();              return val == 1;            }          case ModuleSignatureTypeCode.Char:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (char)0;            }            return this.SignatureMemoryReader.ReadChar();        }
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: switch (type.SignatureTypeCode) {          case ModuleSignatureTypeCode.SByte:            if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (sbyte)0;            }            return this.SignatureMemoryReader.ReadSByte();          case ModuleSignatureTypeCode.Int16:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (short)0;            }            return this.SignatureMemoryReader.ReadInt16();          case ModuleSignatureTypeCode.Int32:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (int)0;            }            return this.SignatureMemoryReader.ReadInt32();          case ModuleSignatureTypeCode.Int64:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (long)0;            }            return this.SignatureMemoryReader.ReadInt64();          case ModuleSignatureTypeCode.Byte:            if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (byte)0;            }            return this.SignatureMemoryReader.ReadByte();          case ModuleSignatureTypeCode.UInt16:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (ushort)0;            }            return this.SignatureMemoryReader.ReadUInt16();          case ModuleSignatureTypeCode.UInt32:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (uint)0;            }            return this.SignatureMemoryReader.ReadUInt32();          case ModuleSignatureTypeCode.UInt64:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (ulong)0;            }            return this.SignatureMemoryReader.ReadUInt64();          case ModuleSignatureTypeCode.Single:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (float)0;            }            return this.SignatureMemoryReader.ReadSingle();          case ModuleSignatureTypeCode.Double:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (double)0;            }            return this.SignatureMemoryReader.ReadDouble();          case ModuleSignatureTypeCode.Boolean: {              if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {                this.decodeFailed = true;                return false;              }              byte val = this.SignatureMemoryReader.ReadByte();              return val == 1;            }          case ModuleSignatureTypeCode.Char:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (char)0;            }            return this.SignatureMemoryReader.ReadChar();        }
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: switch (type.SignatureTypeCode) {          case ModuleSignatureTypeCode.SByte:            if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (sbyte)0;            }            return this.SignatureMemoryReader.ReadSByte();          case ModuleSignatureTypeCode.Int16:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (short)0;            }            return this.SignatureMemoryReader.ReadInt16();          case ModuleSignatureTypeCode.Int32:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (int)0;            }            return this.SignatureMemoryReader.ReadInt32();          case ModuleSignatureTypeCode.Int64:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (long)0;            }            return this.SignatureMemoryReader.ReadInt64();          case ModuleSignatureTypeCode.Byte:            if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (byte)0;            }            return this.SignatureMemoryReader.ReadByte();          case ModuleSignatureTypeCode.UInt16:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (ushort)0;            }            return this.SignatureMemoryReader.ReadUInt16();          case ModuleSignatureTypeCode.UInt32:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (uint)0;            }            return this.SignatureMemoryReader.ReadUInt32();          case ModuleSignatureTypeCode.UInt64:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (ulong)0;            }            return this.SignatureMemoryReader.ReadUInt64();          case ModuleSignatureTypeCode.Single:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (float)0;            }            return this.SignatureMemoryReader.ReadSingle();          case ModuleSignatureTypeCode.Double:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (double)0;            }            return this.SignatureMemoryReader.ReadDouble();          case ModuleSignatureTypeCode.Boolean: {              if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {                this.decodeFailed = true;                return false;              }              byte val = this.SignatureMemoryReader.ReadByte();              return val == 1;            }          case ModuleSignatureTypeCode.Char:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (char)0;            }            return this.SignatureMemoryReader.ReadChar();        }
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: switch (type.SignatureTypeCode) {          case ModuleSignatureTypeCode.SByte:            if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (sbyte)0;            }            return this.SignatureMemoryReader.ReadSByte();          case ModuleSignatureTypeCode.Int16:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (short)0;            }            return this.SignatureMemoryReader.ReadInt16();          case ModuleSignatureTypeCode.Int32:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (int)0;            }            return this.SignatureMemoryReader.ReadInt32();          case ModuleSignatureTypeCode.Int64:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (long)0;            }            return this.SignatureMemoryReader.ReadInt64();          case ModuleSignatureTypeCode.Byte:            if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (byte)0;            }            return this.SignatureMemoryReader.ReadByte();          case ModuleSignatureTypeCode.UInt16:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (ushort)0;            }            return this.SignatureMemoryReader.ReadUInt16();          case ModuleSignatureTypeCode.UInt32:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (uint)0;            }            return this.SignatureMemoryReader.ReadUInt32();          case ModuleSignatureTypeCode.UInt64:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (ulong)0;            }            return this.SignatureMemoryReader.ReadUInt64();          case ModuleSignatureTypeCode.Single:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (float)0;            }            return this.SignatureMemoryReader.ReadSingle();          case ModuleSignatureTypeCode.Double:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (double)0;            }            return this.SignatureMemoryReader.ReadDouble();          case ModuleSignatureTypeCode.Boolean: {              if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {                this.decodeFailed = true;                return false;              }              byte val = this.SignatureMemoryReader.ReadByte();              return val == 1;            }          case ModuleSignatureTypeCode.Char:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (char)0;            }            return this.SignatureMemoryReader.ReadChar();        }
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ReadSerializedValue,The following statement contains a magic number: switch (type.SignatureTypeCode) {          case ModuleSignatureTypeCode.SByte:          case ModuleSignatureTypeCode.Int16:          case ModuleSignatureTypeCode.Int32:          case ModuleSignatureTypeCode.Int64:          case ModuleSignatureTypeCode.Byte:          case ModuleSignatureTypeCode.UInt16:          case ModuleSignatureTypeCode.UInt32:          case ModuleSignatureTypeCode.UInt64:          case ModuleSignatureTypeCode.Single:          case ModuleSignatureTypeCode.Double:          case ModuleSignatureTypeCode.Boolean:          case ModuleSignatureTypeCode.Char:            return new ConstantExpression(type' this.GetPrimitiveValue(type));          case ModuleSignatureTypeCode.String:            return new ConstantExpression(type' this.GetSerializedString());          case ModuleSignatureTypeCode.Object: {              IModuleTypeReference/*?*/ underlyingType = this.GetFieldOrPropType();              if (underlyingType == null)                return null;              return this.ReadSerializedValue(underlyingType);            }          default:            if (type == this.PEFileToObjectModel.SystemType) {              string/*?*/ typeNameStr = this.GetSerializedString();              if (typeNameStr == null) {                return new ConstantExpression(this.PEFileToObjectModel.SystemType' null);              }              return new TypeOfExpression(this.PEFileToObjectModel' this.PEFileToObjectModel.GetSerializedTypeNameAsTypeReference(typeNameStr));            }            IModuleNominalType/*?*/ typeDef = type.ResolvedType as IModuleNominalType;            if (typeDef != null && typeDef.IsEnum)              return new ConstantExpression(type' this.GetPrimitiveValue(typeDef.EnumUnderlyingType));            VectorType/*?*/ vectorType = type as VectorType;            if (vectorType != null) {              IModuleTypeReference/*?*/ elementType = vectorType.ElementType;              if (elementType == null) {                this.decodeFailed = true;                return null;              }              int size = this.SignatureMemoryReader.ReadInt32();              if (size == -1) {                return new ConstantExpression(vectorType' null);              }              List<ExpressionBase> arrayElements = new List<ExpressionBase>();              for (int i = 0; i < size; ++i) {                ExpressionBase/*?*/ expr = this.ReadSerializedValue(elementType);                if (expr == null) {                  this.decodeFailed = true;                  return null;                }                arrayElements.Add(expr);              }              return new ArrayExpression(vectorType' new EnumerableArrayWrapper<ExpressionBase' IMetadataExpression>(arrayElements.ToArray()' Dummy.Expression));            } else {              // If the metadata is correct' type must be a reference to an enum type.              // Problem is' that without resolving this reference' it is not possible to know how many bytes to consume for the enum value              // We'll let the host deal with this by guessing              IModuleNominalType underlyingType;              switch (this.PEFileToObjectModel.ModuleReader.metadataReaderHost.GuessUnderlyingTypeSizeOfUnresolvableReferenceToEnum(type)) {                case 1: underlyingType = this.PEFileToObjectModel.SystemByte; break;                case 2: underlyingType = this.PEFileToObjectModel.SystemInt16; break;                case 4: underlyingType = this.PEFileToObjectModel.SystemInt32; break;                case 8: underlyingType = this.PEFileToObjectModel.SystemInt64; break;                default:                  this.decodeFailed = true; this.morePermutationsArePossible = false;                  return new ConstantExpression(type' 0);              }              return new ConstantExpression(type' this.GetPrimitiveValue(underlyingType));            }        }
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ReadSerializedValue,The following statement contains a magic number: switch (type.SignatureTypeCode) {          case ModuleSignatureTypeCode.SByte:          case ModuleSignatureTypeCode.Int16:          case ModuleSignatureTypeCode.Int32:          case ModuleSignatureTypeCode.Int64:          case ModuleSignatureTypeCode.Byte:          case ModuleSignatureTypeCode.UInt16:          case ModuleSignatureTypeCode.UInt32:          case ModuleSignatureTypeCode.UInt64:          case ModuleSignatureTypeCode.Single:          case ModuleSignatureTypeCode.Double:          case ModuleSignatureTypeCode.Boolean:          case ModuleSignatureTypeCode.Char:            return new ConstantExpression(type' this.GetPrimitiveValue(type));          case ModuleSignatureTypeCode.String:            return new ConstantExpression(type' this.GetSerializedString());          case ModuleSignatureTypeCode.Object: {              IModuleTypeReference/*?*/ underlyingType = this.GetFieldOrPropType();              if (underlyingType == null)                return null;              return this.ReadSerializedValue(underlyingType);            }          default:            if (type == this.PEFileToObjectModel.SystemType) {              string/*?*/ typeNameStr = this.GetSerializedString();              if (typeNameStr == null) {                return new ConstantExpression(this.PEFileToObjectModel.SystemType' null);              }              return new TypeOfExpression(this.PEFileToObjectModel' this.PEFileToObjectModel.GetSerializedTypeNameAsTypeReference(typeNameStr));            }            IModuleNominalType/*?*/ typeDef = type.ResolvedType as IModuleNominalType;            if (typeDef != null && typeDef.IsEnum)              return new ConstantExpression(type' this.GetPrimitiveValue(typeDef.EnumUnderlyingType));            VectorType/*?*/ vectorType = type as VectorType;            if (vectorType != null) {              IModuleTypeReference/*?*/ elementType = vectorType.ElementType;              if (elementType == null) {                this.decodeFailed = true;                return null;              }              int size = this.SignatureMemoryReader.ReadInt32();              if (size == -1) {                return new ConstantExpression(vectorType' null);              }              List<ExpressionBase> arrayElements = new List<ExpressionBase>();              for (int i = 0; i < size; ++i) {                ExpressionBase/*?*/ expr = this.ReadSerializedValue(elementType);                if (expr == null) {                  this.decodeFailed = true;                  return null;                }                arrayElements.Add(expr);              }              return new ArrayExpression(vectorType' new EnumerableArrayWrapper<ExpressionBase' IMetadataExpression>(arrayElements.ToArray()' Dummy.Expression));            } else {              // If the metadata is correct' type must be a reference to an enum type.              // Problem is' that without resolving this reference' it is not possible to know how many bytes to consume for the enum value              // We'll let the host deal with this by guessing              IModuleNominalType underlyingType;              switch (this.PEFileToObjectModel.ModuleReader.metadataReaderHost.GuessUnderlyingTypeSizeOfUnresolvableReferenceToEnum(type)) {                case 1: underlyingType = this.PEFileToObjectModel.SystemByte; break;                case 2: underlyingType = this.PEFileToObjectModel.SystemInt16; break;                case 4: underlyingType = this.PEFileToObjectModel.SystemInt32; break;                case 8: underlyingType = this.PEFileToObjectModel.SystemInt64; break;                default:                  this.decodeFailed = true; this.morePermutationsArePossible = false;                  return new ConstantExpression(type' 0);              }              return new ConstantExpression(type' this.GetPrimitiveValue(underlyingType));            }        }
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,ReadSerializedValue,The following statement contains a magic number: switch (type.SignatureTypeCode) {          case ModuleSignatureTypeCode.SByte:          case ModuleSignatureTypeCode.Int16:          case ModuleSignatureTypeCode.Int32:          case ModuleSignatureTypeCode.Int64:          case ModuleSignatureTypeCode.Byte:          case ModuleSignatureTypeCode.UInt16:          case ModuleSignatureTypeCode.UInt32:          case ModuleSignatureTypeCode.UInt64:          case ModuleSignatureTypeCode.Single:          case ModuleSignatureTypeCode.Double:          case ModuleSignatureTypeCode.Boolean:          case ModuleSignatureTypeCode.Char:            return new ConstantExpression(type' this.GetPrimitiveValue(type));          case ModuleSignatureTypeCode.String:            return new ConstantExpression(type' this.GetSerializedString());          case ModuleSignatureTypeCode.Object: {              IModuleTypeReference/*?*/ underlyingType = this.GetFieldOrPropType();              if (underlyingType == null)                return null;              return this.ReadSerializedValue(underlyingType);            }          default:            if (type == this.PEFileToObjectModel.SystemType) {              string/*?*/ typeNameStr = this.GetSerializedString();              if (typeNameStr == null) {                return new ConstantExpression(this.PEFileToObjectModel.SystemType' null);              }              return new TypeOfExpression(this.PEFileToObjectModel' this.PEFileToObjectModel.GetSerializedTypeNameAsTypeReference(typeNameStr));            }            IModuleNominalType/*?*/ typeDef = type.ResolvedType as IModuleNominalType;            if (typeDef != null && typeDef.IsEnum)              return new ConstantExpression(type' this.GetPrimitiveValue(typeDef.EnumUnderlyingType));            VectorType/*?*/ vectorType = type as VectorType;            if (vectorType != null) {              IModuleTypeReference/*?*/ elementType = vectorType.ElementType;              if (elementType == null) {                this.decodeFailed = true;                return null;              }              int size = this.SignatureMemoryReader.ReadInt32();              if (size == -1) {                return new ConstantExpression(vectorType' null);              }              List<ExpressionBase> arrayElements = new List<ExpressionBase>();              for (int i = 0; i < size; ++i) {                ExpressionBase/*?*/ expr = this.ReadSerializedValue(elementType);                if (expr == null) {                  this.decodeFailed = true;                  return null;                }                arrayElements.Add(expr);              }              return new ArrayExpression(vectorType' new EnumerableArrayWrapper<ExpressionBase' IMetadataExpression>(arrayElements.ToArray()' Dummy.Expression));            } else {              // If the metadata is correct' type must be a reference to an enum type.              // Problem is' that without resolving this reference' it is not possible to know how many bytes to consume for the enum value              // We'll let the host deal with this by guessing              IModuleNominalType underlyingType;              switch (this.PEFileToObjectModel.ModuleReader.metadataReaderHost.GuessUnderlyingTypeSizeOfUnresolvableReferenceToEnum(type)) {                case 1: underlyingType = this.PEFileToObjectModel.SystemByte; break;                case 2: underlyingType = this.PEFileToObjectModel.SystemInt16; break;                case 4: underlyingType = this.PEFileToObjectModel.SystemInt32; break;                case 8: underlyingType = this.PEFileToObjectModel.SystemInt64; break;                default:                  this.decodeFailed = true; this.morePermutationsArePossible = false;                  return new ConstantExpression(type' 0);              }              return new ConstantExpression(type' this.GetPrimitiveValue(underlyingType));            }        }
Magic Number,Microsoft.Cci.MetadataReader,ILReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\ILReader.cs,PopulateCilInstructions,The following statement contains a magic number: while (memReader.NotEndOfBytes) {          object/*?*/ value = null;          uint offset = (uint)memReader.Offset;          OperationCode cilOpCode = memReader.ReadOpcode();          switch (cilOpCode) {            case OperationCode.Nop:            case OperationCode.Break:              break;            case OperationCode.Ldarg_0:            case OperationCode.Ldarg_1:            case OperationCode.Ldarg_2:            case OperationCode.Ldarg_3:              value = this.GetParameter((uint)(cilOpCode - OperationCode.Ldarg_0));              break;            case OperationCode.Ldloc_0:            case OperationCode.Ldloc_1:            case OperationCode.Ldloc_2:            case OperationCode.Ldloc_3:              value = this.GetLocal((uint)(cilOpCode - OperationCode.Ldloc_0));              break;            case OperationCode.Stloc_0:            case OperationCode.Stloc_1:            case OperationCode.Stloc_2:            case OperationCode.Stloc_3:              value = this.GetLocal((uint)(cilOpCode - OperationCode.Stloc_0));              break;            case OperationCode.Ldarg_S:            case OperationCode.Ldarga_S:            case OperationCode.Starg_S:              value = this.GetParameter(memReader.ReadByte());              break;            case OperationCode.Ldloc_S:            case OperationCode.Ldloca_S:            case OperationCode.Stloc_S:              value = this.GetLocal(memReader.ReadByte());              break;            case OperationCode.Ldnull:            case OperationCode.Ldc_I4_M1:            case OperationCode.Ldc_I4_0:            case OperationCode.Ldc_I4_1:            case OperationCode.Ldc_I4_2:            case OperationCode.Ldc_I4_3:            case OperationCode.Ldc_I4_4:            case OperationCode.Ldc_I4_5:            case OperationCode.Ldc_I4_6:            case OperationCode.Ldc_I4_7:            case OperationCode.Ldc_I4_8:              break;            case OperationCode.Ldc_I4_S:              value = (int)memReader.ReadSByte();              break;            case OperationCode.Ldc_I4:              value = memReader.ReadInt32();              break;            case OperationCode.Ldc_I8:              value = memReader.ReadInt64();              break;            case OperationCode.Ldc_R4:              value = memReader.ReadSingle();              break;            case OperationCode.Ldc_R8:              value = memReader.ReadDouble();              break;            case OperationCode.Dup:            case OperationCode.Pop:              break;            case OperationCode.Jmp:              value = this.GetMethod(memReader.ReadUInt32());              break;            case OperationCode.Call: {                IMethodReference methodReference = this.GetMethod(memReader.ReadUInt32());                IArrayTypeReference/*?*/ arrayType = methodReference.ContainingType as IArrayTypeReference;                if (arrayType != null) {                  // For Get()' Set() and Address() on arrays' the runtime provides method implementations.                  // Hence' CCI2 replaces these with pseudo instrcutions Array_Set' Array_Get and Array_Addr.                  // All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.                   if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {                    cilOpCode = OperationCode.Array_Set;                    value = arrayType;                  } else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {                    cilOpCode = OperationCode.Array_Get;                    value = arrayType;                  } else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {                    cilOpCode = OperationCode.Array_Addr;                    value = arrayType;                  } else {                    value = methodReference;                  }                } else {                  value = methodReference;                }              }              break;            case OperationCode.Calli:              value = this.GetFunctionPointerType(memReader.ReadUInt32());              break;            case OperationCode.Ret:              break;            case OperationCode.Br_S:            case OperationCode.Brfalse_S:            case OperationCode.Brtrue_S:            case OperationCode.Beq_S:            case OperationCode.Bge_S:            case OperationCode.Bgt_S:            case OperationCode.Ble_S:            case OperationCode.Blt_S:            case OperationCode.Bne_Un_S:            case OperationCode.Bge_Un_S:            case OperationCode.Bgt_Un_S:            case OperationCode.Ble_Un_S:            case OperationCode.Blt_Un_S: {                uint jumpOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte());                if (jumpOffset >= this.EndOfMethodOffset) {                  //  Error...                }                value = jumpOffset;              }              break;            case OperationCode.Br:            case OperationCode.Brfalse:            case OperationCode.Brtrue:            case OperationCode.Beq:            case OperationCode.Bge:            case OperationCode.Bgt:            case OperationCode.Ble:            case OperationCode.Blt:            case OperationCode.Bne_Un:            case OperationCode.Bge_Un:            case OperationCode.Bgt_Un:            case OperationCode.Ble_Un:            case OperationCode.Blt_Un: {                uint jumpOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32());                if (jumpOffset >= this.EndOfMethodOffset) {                  //  Error...                }                value = jumpOffset;              }              break;            case OperationCode.Switch: {                uint numTargets = memReader.ReadUInt32();                uint[] result = new uint[numTargets];                uint asOffset = memReader.Offset + numTargets * 4;                for (int i = 0; i < numTargets; i++) {                  uint targetAddress = memReader.ReadUInt32() + asOffset;                  if (targetAddress >= this.EndOfMethodOffset) {                    //  Error...                  }                  result[i] = targetAddress;                }                value = result;              }              break;            case OperationCode.Ldind_I1:            case OperationCode.Ldind_U1:            case OperationCode.Ldind_I2:            case OperationCode.Ldind_U2:            case OperationCode.Ldind_I4:            case OperationCode.Ldind_U4:            case OperationCode.Ldind_I8:            case OperationCode.Ldind_I:            case OperationCode.Ldind_R4:            case OperationCode.Ldind_R8:            case OperationCode.Ldind_Ref:            case OperationCode.Stind_Ref:            case OperationCode.Stind_I1:            case OperationCode.Stind_I2:            case OperationCode.Stind_I4:            case OperationCode.Stind_I8:            case OperationCode.Stind_R4:            case OperationCode.Stind_R8:            case OperationCode.Add:            case OperationCode.Sub:            case OperationCode.Mul:            case OperationCode.Div:            case OperationCode.Div_Un:            case OperationCode.Rem:            case OperationCode.Rem_Un:            case OperationCode.And:            case OperationCode.Or:            case OperationCode.Xor:            case OperationCode.Shl:            case OperationCode.Shr:            case OperationCode.Shr_Un:            case OperationCode.Neg:            case OperationCode.Not:            case OperationCode.Conv_I1:            case OperationCode.Conv_I2:            case OperationCode.Conv_I4:            case OperationCode.Conv_I8:            case OperationCode.Conv_R4:            case OperationCode.Conv_R8:            case OperationCode.Conv_U4:            case OperationCode.Conv_U8:              break;            case OperationCode.Callvirt: {                IMethodReference methodReference = this.GetMethod(memReader.ReadUInt32());                IArrayTypeReference/*?*/ arrayType = methodReference.ContainingType as IArrayTypeReference;                if (arrayType != null) {                  // For Get()' Set() and Address() on arrays' the runtime provides method implementations.                  // Hence' CCI2 replaces these with pseudo instrcutions Array_Set' Array_Get and Array_Addr.                  // All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.                   if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {                    cilOpCode = OperationCode.Array_Set;                    value = arrayType;                  } else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {                    cilOpCode = OperationCode.Array_Get;                    value = arrayType;                  } else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {                    cilOpCode = OperationCode.Array_Addr;                    value = arrayType;                  } else {                    value = methodReference;                  }                } else {                  value = methodReference;                }              }              break;            case OperationCode.Cpobj:            case OperationCode.Ldobj:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Ldstr:              value = this.GetUserStringForToken(memReader.ReadUInt32());              break;            case OperationCode.Newobj: {                IMethodReference methodReference = this.GetMethod(memReader.ReadUInt32());                IArrayTypeReference/*?*/ arrayType = methodReference.ContainingType as IArrayTypeReference;                if (arrayType != null && !arrayType.IsVector) {                  uint numParam = IteratorHelper.EnumerableCount(methodReference.Parameters);                  if (numParam != arrayType.Rank)                    cilOpCode = OperationCode.Array_Create_WithLowerBound;                  else                    cilOpCode = OperationCode.Array_Create;                  value = arrayType;                } else {                  value = methodReference;                }              }              break;            case OperationCode.Castclass:            case OperationCode.Isinst:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Conv_R_Un:              break;            case OperationCode.Unbox:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Throw:              break;            case OperationCode.Ldfld:            case OperationCode.Ldflda:            case OperationCode.Stfld:            case OperationCode.Ldsfld:            case OperationCode.Ldsflda:            case OperationCode.Stsfld:              value = this.GetField(memReader.ReadUInt32());              break;            case OperationCode.Stobj:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Conv_Ovf_I1_Un:            case OperationCode.Conv_Ovf_I2_Un:            case OperationCode.Conv_Ovf_I4_Un:            case OperationCode.Conv_Ovf_I8_Un:            case OperationCode.Conv_Ovf_U1_Un:            case OperationCode.Conv_Ovf_U2_Un:            case OperationCode.Conv_Ovf_U4_Un:            case OperationCode.Conv_Ovf_U8_Un:            case OperationCode.Conv_Ovf_I_Un:            case OperationCode.Conv_Ovf_U_Un:              break;            case OperationCode.Box:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Newarr: {                ITypeReference elementType = this.GetType(memReader.ReadUInt32());                IModuleTypeReference/*?*/ moduleTypeReference = elementType as IModuleTypeReference;                if (moduleTypeReference != null)                  value = new VectorType(this.PEFileToObjectModel' 0xFFFFFFFF' moduleTypeReference);                else                  value = Dummy.ArrayType;              }              break;            case OperationCode.Ldlen:              break;            case OperationCode.Ldelema:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Ldelem_I1:            case OperationCode.Ldelem_U1:            case OperationCode.Ldelem_I2:            case OperationCode.Ldelem_U2:            case OperationCode.Ldelem_I4:            case OperationCode.Ldelem_U4:            case OperationCode.Ldelem_I8:            case OperationCode.Ldelem_I:            case OperationCode.Ldelem_R4:            case OperationCode.Ldelem_R8:            case OperationCode.Ldelem_Ref:            case OperationCode.Stelem_I:            case OperationCode.Stelem_I1:            case OperationCode.Stelem_I2:            case OperationCode.Stelem_I4:            case OperationCode.Stelem_I8:            case OperationCode.Stelem_R4:            case OperationCode.Stelem_R8:            case OperationCode.Stelem_Ref:              break;            case OperationCode.Ldelem:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Stelem:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Unbox_Any:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Conv_Ovf_I1:            case OperationCode.Conv_Ovf_U1:            case OperationCode.Conv_Ovf_I2:            case OperationCode.Conv_Ovf_U2:            case OperationCode.Conv_Ovf_I4:            case OperationCode.Conv_Ovf_U4:            case OperationCode.Conv_Ovf_I8:            case OperationCode.Conv_Ovf_U8:              break;            case OperationCode.Refanyval:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Ckfinite:              break;            case OperationCode.Mkrefany:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Ldtoken:              value = this.GetRuntimeHandleFromToken(memReader.ReadUInt32());              break;            case OperationCode.Conv_U2:            case OperationCode.Conv_U1:            case OperationCode.Conv_I:            case OperationCode.Conv_Ovf_I:            case OperationCode.Conv_Ovf_U:            case OperationCode.Add_Ovf:            case OperationCode.Add_Ovf_Un:            case OperationCode.Mul_Ovf:            case OperationCode.Mul_Ovf_Un:            case OperationCode.Sub_Ovf:            case OperationCode.Sub_Ovf_Un:            case OperationCode.Endfinally:              break;            case OperationCode.Leave: {                uint leaveOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32());                if (leaveOffset >= this.EndOfMethodOffset) {                  //  Error...                }                value = leaveOffset;              }              break;            case OperationCode.Leave_S: {                uint leaveOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte());                if (leaveOffset >= this.EndOfMethodOffset) {                  //  Error...                }                value = leaveOffset;              }              break;            case OperationCode.Stind_I:            case OperationCode.Conv_U:            case OperationCode.Arglist:            case OperationCode.Ceq:            case OperationCode.Cgt:            case OperationCode.Cgt_Un:            case OperationCode.Clt:            case OperationCode.Clt_Un:              break;            case OperationCode.Ldftn:            case OperationCode.Ldvirtftn:              value = this.GetMethod(memReader.ReadUInt32());              break;            case OperationCode.Ldarg:            case OperationCode.Ldarga:            case OperationCode.Starg:              value = this.GetParameter(memReader.ReadUInt16());              break;            case OperationCode.Ldloc:            case OperationCode.Ldloca:            case OperationCode.Stloc:              value = this.GetLocal(memReader.ReadUInt16());              break;            case OperationCode.Localloc:              value = new PointerType(this.PEFileToObjectModel' 0xFFFFFFFF' this.PEFileToObjectModel.SystemVoid);              break;            case OperationCode.Endfilter:              break;            case OperationCode.Unaligned_:              value = memReader.ReadByte();              break;            case OperationCode.Volatile_:            case OperationCode.Tail_:              break;            case OperationCode.Initobj:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Constrained_:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Cpblk:            case OperationCode.Initblk:              break;            case OperationCode.No_:              value = (OperationCheckFlags)memReader.ReadByte();              break;            case OperationCode.Rethrow:              break;            case OperationCode.Sizeof:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Refanytype:            case OperationCode.Readonly_:              break;            default:              this.PEFileToObjectModel.PEFileReader.ErrorContainer.AddILError(this.MethodDefinition' offset' MetadataReaderErrorKind.UnknownILInstruction);              break;          }          MethodBodyLocation location = new MethodBodyLocation(document' offset);          instrList.Add(new CilInstruction(cilOpCode' location' value));        }
Magic Number,Microsoft.Cci.MetadataReader,ILReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\ILReader.cs,PopulateCilInstructions,The following statement contains a magic number: while (memReader.NotEndOfBytes) {          object/*?*/ value = null;          uint offset = (uint)memReader.Offset;          OperationCode cilOpCode = memReader.ReadOpcode();          switch (cilOpCode) {            case OperationCode.Nop:            case OperationCode.Break:              break;            case OperationCode.Ldarg_0:            case OperationCode.Ldarg_1:            case OperationCode.Ldarg_2:            case OperationCode.Ldarg_3:              value = this.GetParameter((uint)(cilOpCode - OperationCode.Ldarg_0));              break;            case OperationCode.Ldloc_0:            case OperationCode.Ldloc_1:            case OperationCode.Ldloc_2:            case OperationCode.Ldloc_3:              value = this.GetLocal((uint)(cilOpCode - OperationCode.Ldloc_0));              break;            case OperationCode.Stloc_0:            case OperationCode.Stloc_1:            case OperationCode.Stloc_2:            case OperationCode.Stloc_3:              value = this.GetLocal((uint)(cilOpCode - OperationCode.Stloc_0));              break;            case OperationCode.Ldarg_S:            case OperationCode.Ldarga_S:            case OperationCode.Starg_S:              value = this.GetParameter(memReader.ReadByte());              break;            case OperationCode.Ldloc_S:            case OperationCode.Ldloca_S:            case OperationCode.Stloc_S:              value = this.GetLocal(memReader.ReadByte());              break;            case OperationCode.Ldnull:            case OperationCode.Ldc_I4_M1:            case OperationCode.Ldc_I4_0:            case OperationCode.Ldc_I4_1:            case OperationCode.Ldc_I4_2:            case OperationCode.Ldc_I4_3:            case OperationCode.Ldc_I4_4:            case OperationCode.Ldc_I4_5:            case OperationCode.Ldc_I4_6:            case OperationCode.Ldc_I4_7:            case OperationCode.Ldc_I4_8:              break;            case OperationCode.Ldc_I4_S:              value = (int)memReader.ReadSByte();              break;            case OperationCode.Ldc_I4:              value = memReader.ReadInt32();              break;            case OperationCode.Ldc_I8:              value = memReader.ReadInt64();              break;            case OperationCode.Ldc_R4:              value = memReader.ReadSingle();              break;            case OperationCode.Ldc_R8:              value = memReader.ReadDouble();              break;            case OperationCode.Dup:            case OperationCode.Pop:              break;            case OperationCode.Jmp:              value = this.GetMethod(memReader.ReadUInt32());              break;            case OperationCode.Call: {                IMethodReference methodReference = this.GetMethod(memReader.ReadUInt32());                IArrayTypeReference/*?*/ arrayType = methodReference.ContainingType as IArrayTypeReference;                if (arrayType != null) {                  // For Get()' Set() and Address() on arrays' the runtime provides method implementations.                  // Hence' CCI2 replaces these with pseudo instrcutions Array_Set' Array_Get and Array_Addr.                  // All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.                   if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {                    cilOpCode = OperationCode.Array_Set;                    value = arrayType;                  } else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {                    cilOpCode = OperationCode.Array_Get;                    value = arrayType;                  } else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {                    cilOpCode = OperationCode.Array_Addr;                    value = arrayType;                  } else {                    value = methodReference;                  }                } else {                  value = methodReference;                }              }              break;            case OperationCode.Calli:              value = this.GetFunctionPointerType(memReader.ReadUInt32());              break;            case OperationCode.Ret:              break;            case OperationCode.Br_S:            case OperationCode.Brfalse_S:            case OperationCode.Brtrue_S:            case OperationCode.Beq_S:            case OperationCode.Bge_S:            case OperationCode.Bgt_S:            case OperationCode.Ble_S:            case OperationCode.Blt_S:            case OperationCode.Bne_Un_S:            case OperationCode.Bge_Un_S:            case OperationCode.Bgt_Un_S:            case OperationCode.Ble_Un_S:            case OperationCode.Blt_Un_S: {                uint jumpOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte());                if (jumpOffset >= this.EndOfMethodOffset) {                  //  Error...                }                value = jumpOffset;              }              break;            case OperationCode.Br:            case OperationCode.Brfalse:            case OperationCode.Brtrue:            case OperationCode.Beq:            case OperationCode.Bge:            case OperationCode.Bgt:            case OperationCode.Ble:            case OperationCode.Blt:            case OperationCode.Bne_Un:            case OperationCode.Bge_Un:            case OperationCode.Bgt_Un:            case OperationCode.Ble_Un:            case OperationCode.Blt_Un: {                uint jumpOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32());                if (jumpOffset >= this.EndOfMethodOffset) {                  //  Error...                }                value = jumpOffset;              }              break;            case OperationCode.Switch: {                uint numTargets = memReader.ReadUInt32();                uint[] result = new uint[numTargets];                uint asOffset = memReader.Offset + numTargets * 4;                for (int i = 0; i < numTargets; i++) {                  uint targetAddress = memReader.ReadUInt32() + asOffset;                  if (targetAddress >= this.EndOfMethodOffset) {                    //  Error...                  }                  result[i] = targetAddress;                }                value = result;              }              break;            case OperationCode.Ldind_I1:            case OperationCode.Ldind_U1:            case OperationCode.Ldind_I2:            case OperationCode.Ldind_U2:            case OperationCode.Ldind_I4:            case OperationCode.Ldind_U4:            case OperationCode.Ldind_I8:            case OperationCode.Ldind_I:            case OperationCode.Ldind_R4:            case OperationCode.Ldind_R8:            case OperationCode.Ldind_Ref:            case OperationCode.Stind_Ref:            case OperationCode.Stind_I1:            case OperationCode.Stind_I2:            case OperationCode.Stind_I4:            case OperationCode.Stind_I8:            case OperationCode.Stind_R4:            case OperationCode.Stind_R8:            case OperationCode.Add:            case OperationCode.Sub:            case OperationCode.Mul:            case OperationCode.Div:            case OperationCode.Div_Un:            case OperationCode.Rem:            case OperationCode.Rem_Un:            case OperationCode.And:            case OperationCode.Or:            case OperationCode.Xor:            case OperationCode.Shl:            case OperationCode.Shr:            case OperationCode.Shr_Un:            case OperationCode.Neg:            case OperationCode.Not:            case OperationCode.Conv_I1:            case OperationCode.Conv_I2:            case OperationCode.Conv_I4:            case OperationCode.Conv_I8:            case OperationCode.Conv_R4:            case OperationCode.Conv_R8:            case OperationCode.Conv_U4:            case OperationCode.Conv_U8:              break;            case OperationCode.Callvirt: {                IMethodReference methodReference = this.GetMethod(memReader.ReadUInt32());                IArrayTypeReference/*?*/ arrayType = methodReference.ContainingType as IArrayTypeReference;                if (arrayType != null) {                  // For Get()' Set() and Address() on arrays' the runtime provides method implementations.                  // Hence' CCI2 replaces these with pseudo instrcutions Array_Set' Array_Get and Array_Addr.                  // All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.                   if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {                    cilOpCode = OperationCode.Array_Set;                    value = arrayType;                  } else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {                    cilOpCode = OperationCode.Array_Get;                    value = arrayType;                  } else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {                    cilOpCode = OperationCode.Array_Addr;                    value = arrayType;                  } else {                    value = methodReference;                  }                } else {                  value = methodReference;                }              }              break;            case OperationCode.Cpobj:            case OperationCode.Ldobj:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Ldstr:              value = this.GetUserStringForToken(memReader.ReadUInt32());              break;            case OperationCode.Newobj: {                IMethodReference methodReference = this.GetMethod(memReader.ReadUInt32());                IArrayTypeReference/*?*/ arrayType = methodReference.ContainingType as IArrayTypeReference;                if (arrayType != null && !arrayType.IsVector) {                  uint numParam = IteratorHelper.EnumerableCount(methodReference.Parameters);                  if (numParam != arrayType.Rank)                    cilOpCode = OperationCode.Array_Create_WithLowerBound;                  else                    cilOpCode = OperationCode.Array_Create;                  value = arrayType;                } else {                  value = methodReference;                }              }              break;            case OperationCode.Castclass:            case OperationCode.Isinst:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Conv_R_Un:              break;            case OperationCode.Unbox:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Throw:              break;            case OperationCode.Ldfld:            case OperationCode.Ldflda:            case OperationCode.Stfld:            case OperationCode.Ldsfld:            case OperationCode.Ldsflda:            case OperationCode.Stsfld:              value = this.GetField(memReader.ReadUInt32());              break;            case OperationCode.Stobj:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Conv_Ovf_I1_Un:            case OperationCode.Conv_Ovf_I2_Un:            case OperationCode.Conv_Ovf_I4_Un:            case OperationCode.Conv_Ovf_I8_Un:            case OperationCode.Conv_Ovf_U1_Un:            case OperationCode.Conv_Ovf_U2_Un:            case OperationCode.Conv_Ovf_U4_Un:            case OperationCode.Conv_Ovf_U8_Un:            case OperationCode.Conv_Ovf_I_Un:            case OperationCode.Conv_Ovf_U_Un:              break;            case OperationCode.Box:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Newarr: {                ITypeReference elementType = this.GetType(memReader.ReadUInt32());                IModuleTypeReference/*?*/ moduleTypeReference = elementType as IModuleTypeReference;                if (moduleTypeReference != null)                  value = new VectorType(this.PEFileToObjectModel' 0xFFFFFFFF' moduleTypeReference);                else                  value = Dummy.ArrayType;              }              break;            case OperationCode.Ldlen:              break;            case OperationCode.Ldelema:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Ldelem_I1:            case OperationCode.Ldelem_U1:            case OperationCode.Ldelem_I2:            case OperationCode.Ldelem_U2:            case OperationCode.Ldelem_I4:            case OperationCode.Ldelem_U4:            case OperationCode.Ldelem_I8:            case OperationCode.Ldelem_I:            case OperationCode.Ldelem_R4:            case OperationCode.Ldelem_R8:            case OperationCode.Ldelem_Ref:            case OperationCode.Stelem_I:            case OperationCode.Stelem_I1:            case OperationCode.Stelem_I2:            case OperationCode.Stelem_I4:            case OperationCode.Stelem_I8:            case OperationCode.Stelem_R4:            case OperationCode.Stelem_R8:            case OperationCode.Stelem_Ref:              break;            case OperationCode.Ldelem:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Stelem:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Unbox_Any:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Conv_Ovf_I1:            case OperationCode.Conv_Ovf_U1:            case OperationCode.Conv_Ovf_I2:            case OperationCode.Conv_Ovf_U2:            case OperationCode.Conv_Ovf_I4:            case OperationCode.Conv_Ovf_U4:            case OperationCode.Conv_Ovf_I8:            case OperationCode.Conv_Ovf_U8:              break;            case OperationCode.Refanyval:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Ckfinite:              break;            case OperationCode.Mkrefany:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Ldtoken:              value = this.GetRuntimeHandleFromToken(memReader.ReadUInt32());              break;            case OperationCode.Conv_U2:            case OperationCode.Conv_U1:            case OperationCode.Conv_I:            case OperationCode.Conv_Ovf_I:            case OperationCode.Conv_Ovf_U:            case OperationCode.Add_Ovf:            case OperationCode.Add_Ovf_Un:            case OperationCode.Mul_Ovf:            case OperationCode.Mul_Ovf_Un:            case OperationCode.Sub_Ovf:            case OperationCode.Sub_Ovf_Un:            case OperationCode.Endfinally:              break;            case OperationCode.Leave: {                uint leaveOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32());                if (leaveOffset >= this.EndOfMethodOffset) {                  //  Error...                }                value = leaveOffset;              }              break;            case OperationCode.Leave_S: {                uint leaveOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte());                if (leaveOffset >= this.EndOfMethodOffset) {                  //  Error...                }                value = leaveOffset;              }              break;            case OperationCode.Stind_I:            case OperationCode.Conv_U:            case OperationCode.Arglist:            case OperationCode.Ceq:            case OperationCode.Cgt:            case OperationCode.Cgt_Un:            case OperationCode.Clt:            case OperationCode.Clt_Un:              break;            case OperationCode.Ldftn:            case OperationCode.Ldvirtftn:              value = this.GetMethod(memReader.ReadUInt32());              break;            case OperationCode.Ldarg:            case OperationCode.Ldarga:            case OperationCode.Starg:              value = this.GetParameter(memReader.ReadUInt16());              break;            case OperationCode.Ldloc:            case OperationCode.Ldloca:            case OperationCode.Stloc:              value = this.GetLocal(memReader.ReadUInt16());              break;            case OperationCode.Localloc:              value = new PointerType(this.PEFileToObjectModel' 0xFFFFFFFF' this.PEFileToObjectModel.SystemVoid);              break;            case OperationCode.Endfilter:              break;            case OperationCode.Unaligned_:              value = memReader.ReadByte();              break;            case OperationCode.Volatile_:            case OperationCode.Tail_:              break;            case OperationCode.Initobj:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Constrained_:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Cpblk:            case OperationCode.Initblk:              break;            case OperationCode.No_:              value = (OperationCheckFlags)memReader.ReadByte();              break;            case OperationCode.Rethrow:              break;            case OperationCode.Sizeof:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Refanytype:            case OperationCode.Readonly_:              break;            default:              this.PEFileToObjectModel.PEFileReader.ErrorContainer.AddILError(this.MethodDefinition' offset' MetadataReaderErrorKind.UnknownILInstruction);              break;          }          MethodBodyLocation location = new MethodBodyLocation(document' offset);          instrList.Add(new CilInstruction(cilOpCode' location' value));        }
Magic Number,Microsoft.Cci.MetadataReader,ILReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\ILReader.cs,PopulateCilInstructions,The following statement contains a magic number: while (memReader.NotEndOfBytes) {          object/*?*/ value = null;          uint offset = (uint)memReader.Offset;          OperationCode cilOpCode = memReader.ReadOpcode();          switch (cilOpCode) {            case OperationCode.Nop:            case OperationCode.Break:              break;            case OperationCode.Ldarg_0:            case OperationCode.Ldarg_1:            case OperationCode.Ldarg_2:            case OperationCode.Ldarg_3:              value = this.GetParameter((uint)(cilOpCode - OperationCode.Ldarg_0));              break;            case OperationCode.Ldloc_0:            case OperationCode.Ldloc_1:            case OperationCode.Ldloc_2:            case OperationCode.Ldloc_3:              value = this.GetLocal((uint)(cilOpCode - OperationCode.Ldloc_0));              break;            case OperationCode.Stloc_0:            case OperationCode.Stloc_1:            case OperationCode.Stloc_2:            case OperationCode.Stloc_3:              value = this.GetLocal((uint)(cilOpCode - OperationCode.Stloc_0));              break;            case OperationCode.Ldarg_S:            case OperationCode.Ldarga_S:            case OperationCode.Starg_S:              value = this.GetParameter(memReader.ReadByte());              break;            case OperationCode.Ldloc_S:            case OperationCode.Ldloca_S:            case OperationCode.Stloc_S:              value = this.GetLocal(memReader.ReadByte());              break;            case OperationCode.Ldnull:            case OperationCode.Ldc_I4_M1:            case OperationCode.Ldc_I4_0:            case OperationCode.Ldc_I4_1:            case OperationCode.Ldc_I4_2:            case OperationCode.Ldc_I4_3:            case OperationCode.Ldc_I4_4:            case OperationCode.Ldc_I4_5:            case OperationCode.Ldc_I4_6:            case OperationCode.Ldc_I4_7:            case OperationCode.Ldc_I4_8:              break;            case OperationCode.Ldc_I4_S:              value = (int)memReader.ReadSByte();              break;            case OperationCode.Ldc_I4:              value = memReader.ReadInt32();              break;            case OperationCode.Ldc_I8:              value = memReader.ReadInt64();              break;            case OperationCode.Ldc_R4:              value = memReader.ReadSingle();              break;            case OperationCode.Ldc_R8:              value = memReader.ReadDouble();              break;            case OperationCode.Dup:            case OperationCode.Pop:              break;            case OperationCode.Jmp:              value = this.GetMethod(memReader.ReadUInt32());              break;            case OperationCode.Call: {                IMethodReference methodReference = this.GetMethod(memReader.ReadUInt32());                IArrayTypeReference/*?*/ arrayType = methodReference.ContainingType as IArrayTypeReference;                if (arrayType != null) {                  // For Get()' Set() and Address() on arrays' the runtime provides method implementations.                  // Hence' CCI2 replaces these with pseudo instrcutions Array_Set' Array_Get and Array_Addr.                  // All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.                   if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {                    cilOpCode = OperationCode.Array_Set;                    value = arrayType;                  } else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {                    cilOpCode = OperationCode.Array_Get;                    value = arrayType;                  } else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {                    cilOpCode = OperationCode.Array_Addr;                    value = arrayType;                  } else {                    value = methodReference;                  }                } else {                  value = methodReference;                }              }              break;            case OperationCode.Calli:              value = this.GetFunctionPointerType(memReader.ReadUInt32());              break;            case OperationCode.Ret:              break;            case OperationCode.Br_S:            case OperationCode.Brfalse_S:            case OperationCode.Brtrue_S:            case OperationCode.Beq_S:            case OperationCode.Bge_S:            case OperationCode.Bgt_S:            case OperationCode.Ble_S:            case OperationCode.Blt_S:            case OperationCode.Bne_Un_S:            case OperationCode.Bge_Un_S:            case OperationCode.Bgt_Un_S:            case OperationCode.Ble_Un_S:            case OperationCode.Blt_Un_S: {                uint jumpOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte());                if (jumpOffset >= this.EndOfMethodOffset) {                  //  Error...                }                value = jumpOffset;              }              break;            case OperationCode.Br:            case OperationCode.Brfalse:            case OperationCode.Brtrue:            case OperationCode.Beq:            case OperationCode.Bge:            case OperationCode.Bgt:            case OperationCode.Ble:            case OperationCode.Blt:            case OperationCode.Bne_Un:            case OperationCode.Bge_Un:            case OperationCode.Bgt_Un:            case OperationCode.Ble_Un:            case OperationCode.Blt_Un: {                uint jumpOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32());                if (jumpOffset >= this.EndOfMethodOffset) {                  //  Error...                }                value = jumpOffset;              }              break;            case OperationCode.Switch: {                uint numTargets = memReader.ReadUInt32();                uint[] result = new uint[numTargets];                uint asOffset = memReader.Offset + numTargets * 4;                for (int i = 0; i < numTargets; i++) {                  uint targetAddress = memReader.ReadUInt32() + asOffset;                  if (targetAddress >= this.EndOfMethodOffset) {                    //  Error...                  }                  result[i] = targetAddress;                }                value = result;              }              break;            case OperationCode.Ldind_I1:            case OperationCode.Ldind_U1:            case OperationCode.Ldind_I2:            case OperationCode.Ldind_U2:            case OperationCode.Ldind_I4:            case OperationCode.Ldind_U4:            case OperationCode.Ldind_I8:            case OperationCode.Ldind_I:            case OperationCode.Ldind_R4:            case OperationCode.Ldind_R8:            case OperationCode.Ldind_Ref:            case OperationCode.Stind_Ref:            case OperationCode.Stind_I1:            case OperationCode.Stind_I2:            case OperationCode.Stind_I4:            case OperationCode.Stind_I8:            case OperationCode.Stind_R4:            case OperationCode.Stind_R8:            case OperationCode.Add:            case OperationCode.Sub:            case OperationCode.Mul:            case OperationCode.Div:            case OperationCode.Div_Un:            case OperationCode.Rem:            case OperationCode.Rem_Un:            case OperationCode.And:            case OperationCode.Or:            case OperationCode.Xor:            case OperationCode.Shl:            case OperationCode.Shr:            case OperationCode.Shr_Un:            case OperationCode.Neg:            case OperationCode.Not:            case OperationCode.Conv_I1:            case OperationCode.Conv_I2:            case OperationCode.Conv_I4:            case OperationCode.Conv_I8:            case OperationCode.Conv_R4:            case OperationCode.Conv_R8:            case OperationCode.Conv_U4:            case OperationCode.Conv_U8:              break;            case OperationCode.Callvirt: {                IMethodReference methodReference = this.GetMethod(memReader.ReadUInt32());                IArrayTypeReference/*?*/ arrayType = methodReference.ContainingType as IArrayTypeReference;                if (arrayType != null) {                  // For Get()' Set() and Address() on arrays' the runtime provides method implementations.                  // Hence' CCI2 replaces these with pseudo instrcutions Array_Set' Array_Get and Array_Addr.                  // All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.                   if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {                    cilOpCode = OperationCode.Array_Set;                    value = arrayType;                  } else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {                    cilOpCode = OperationCode.Array_Get;                    value = arrayType;                  } else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {                    cilOpCode = OperationCode.Array_Addr;                    value = arrayType;                  } else {                    value = methodReference;                  }                } else {                  value = methodReference;                }              }              break;            case OperationCode.Cpobj:            case OperationCode.Ldobj:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Ldstr:              value = this.GetUserStringForToken(memReader.ReadUInt32());              break;            case OperationCode.Newobj: {                IMethodReference methodReference = this.GetMethod(memReader.ReadUInt32());                IArrayTypeReference/*?*/ arrayType = methodReference.ContainingType as IArrayTypeReference;                if (arrayType != null && !arrayType.IsVector) {                  uint numParam = IteratorHelper.EnumerableCount(methodReference.Parameters);                  if (numParam != arrayType.Rank)                    cilOpCode = OperationCode.Array_Create_WithLowerBound;                  else                    cilOpCode = OperationCode.Array_Create;                  value = arrayType;                } else {                  value = methodReference;                }              }              break;            case OperationCode.Castclass:            case OperationCode.Isinst:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Conv_R_Un:              break;            case OperationCode.Unbox:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Throw:              break;            case OperationCode.Ldfld:            case OperationCode.Ldflda:            case OperationCode.Stfld:            case OperationCode.Ldsfld:            case OperationCode.Ldsflda:            case OperationCode.Stsfld:              value = this.GetField(memReader.ReadUInt32());              break;            case OperationCode.Stobj:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Conv_Ovf_I1_Un:            case OperationCode.Conv_Ovf_I2_Un:            case OperationCode.Conv_Ovf_I4_Un:            case OperationCode.Conv_Ovf_I8_Un:            case OperationCode.Conv_Ovf_U1_Un:            case OperationCode.Conv_Ovf_U2_Un:            case OperationCode.Conv_Ovf_U4_Un:            case OperationCode.Conv_Ovf_U8_Un:            case OperationCode.Conv_Ovf_I_Un:            case OperationCode.Conv_Ovf_U_Un:              break;            case OperationCode.Box:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Newarr: {                ITypeReference elementType = this.GetType(memReader.ReadUInt32());                IModuleTypeReference/*?*/ moduleTypeReference = elementType as IModuleTypeReference;                if (moduleTypeReference != null)                  value = new VectorType(this.PEFileToObjectModel' 0xFFFFFFFF' moduleTypeReference);                else                  value = Dummy.ArrayType;              }              break;            case OperationCode.Ldlen:              break;            case OperationCode.Ldelema:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Ldelem_I1:            case OperationCode.Ldelem_U1:            case OperationCode.Ldelem_I2:            case OperationCode.Ldelem_U2:            case OperationCode.Ldelem_I4:            case OperationCode.Ldelem_U4:            case OperationCode.Ldelem_I8:            case OperationCode.Ldelem_I:            case OperationCode.Ldelem_R4:            case OperationCode.Ldelem_R8:            case OperationCode.Ldelem_Ref:            case OperationCode.Stelem_I:            case OperationCode.Stelem_I1:            case OperationCode.Stelem_I2:            case OperationCode.Stelem_I4:            case OperationCode.Stelem_I8:            case OperationCode.Stelem_R4:            case OperationCode.Stelem_R8:            case OperationCode.Stelem_Ref:              break;            case OperationCode.Ldelem:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Stelem:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Unbox_Any:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Conv_Ovf_I1:            case OperationCode.Conv_Ovf_U1:            case OperationCode.Conv_Ovf_I2:            case OperationCode.Conv_Ovf_U2:            case OperationCode.Conv_Ovf_I4:            case OperationCode.Conv_Ovf_U4:            case OperationCode.Conv_Ovf_I8:            case OperationCode.Conv_Ovf_U8:              break;            case OperationCode.Refanyval:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Ckfinite:              break;            case OperationCode.Mkrefany:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Ldtoken:              value = this.GetRuntimeHandleFromToken(memReader.ReadUInt32());              break;            case OperationCode.Conv_U2:            case OperationCode.Conv_U1:            case OperationCode.Conv_I:            case OperationCode.Conv_Ovf_I:            case OperationCode.Conv_Ovf_U:            case OperationCode.Add_Ovf:            case OperationCode.Add_Ovf_Un:            case OperationCode.Mul_Ovf:            case OperationCode.Mul_Ovf_Un:            case OperationCode.Sub_Ovf:            case OperationCode.Sub_Ovf_Un:            case OperationCode.Endfinally:              break;            case OperationCode.Leave: {                uint leaveOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32());                if (leaveOffset >= this.EndOfMethodOffset) {                  //  Error...                }                value = leaveOffset;              }              break;            case OperationCode.Leave_S: {                uint leaveOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte());                if (leaveOffset >= this.EndOfMethodOffset) {                  //  Error...                }                value = leaveOffset;              }              break;            case OperationCode.Stind_I:            case OperationCode.Conv_U:            case OperationCode.Arglist:            case OperationCode.Ceq:            case OperationCode.Cgt:            case OperationCode.Cgt_Un:            case OperationCode.Clt:            case OperationCode.Clt_Un:              break;            case OperationCode.Ldftn:            case OperationCode.Ldvirtftn:              value = this.GetMethod(memReader.ReadUInt32());              break;            case OperationCode.Ldarg:            case OperationCode.Ldarga:            case OperationCode.Starg:              value = this.GetParameter(memReader.ReadUInt16());              break;            case OperationCode.Ldloc:            case OperationCode.Ldloca:            case OperationCode.Stloc:              value = this.GetLocal(memReader.ReadUInt16());              break;            case OperationCode.Localloc:              value = new PointerType(this.PEFileToObjectModel' 0xFFFFFFFF' this.PEFileToObjectModel.SystemVoid);              break;            case OperationCode.Endfilter:              break;            case OperationCode.Unaligned_:              value = memReader.ReadByte();              break;            case OperationCode.Volatile_:            case OperationCode.Tail_:              break;            case OperationCode.Initobj:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Constrained_:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Cpblk:            case OperationCode.Initblk:              break;            case OperationCode.No_:              value = (OperationCheckFlags)memReader.ReadByte();              break;            case OperationCode.Rethrow:              break;            case OperationCode.Sizeof:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Refanytype:            case OperationCode.Readonly_:              break;            default:              this.PEFileToObjectModel.PEFileReader.ErrorContainer.AddILError(this.MethodDefinition' offset' MetadataReaderErrorKind.UnknownILInstruction);              break;          }          MethodBodyLocation location = new MethodBodyLocation(document' offset);          instrList.Add(new CilInstruction(cilOpCode' location' value));        }
Magic Number,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,LoadAssemblyReferences,The following statement contains a magic number: for (uint i = 1; i <= numberOfAssemblyReferences; ++i) {          AssemblyRefRow assemblyRefRow = this.PEFileReader.AssemblyRefTable[i];          IName assemblyRefName = this.GetNameFromOffset(assemblyRefRow.Name);          IName cultureName = this.GetNameFromOffset(assemblyRefRow.Culture);          Version version = new Version(assemblyRefRow.MajorVersion' assemblyRefRow.MinorVersion' assemblyRefRow.BuildNumber' assemblyRefRow.RevisionNumber);          byte[] publicKeyTokenArray = TypeCache.EmptyByteArray;          if (assemblyRefRow.PublicKeyOrToken != 0) {            var publicKeyOrTokenArray = this.PEFileReader.BlobStream[assemblyRefRow.PublicKeyOrToken];            if ((assemblyRefRow.Flags & AssemblyFlags.PublicKey) == AssemblyFlags.PublicKey && publicKeyOrTokenArray.Length > 0) {              publicKeyTokenArray = UnitHelper.ComputePublicKeyToken(publicKeyOrTokenArray);            } else {              publicKeyTokenArray = publicKeyOrTokenArray;            }            if (publicKeyTokenArray.Length != 8) {              //  Error            }          }          AssemblyIdentity assemblyIdentity = new AssemblyIdentity(assemblyRefName' cultureName.Value' version' publicKeyTokenArray' string.Empty);          AssemblyReference assemblyReference = new AssemblyReference(this' i' assemblyIdentity' assemblyRefRow.Flags);          assemblyRefList[i] = assemblyReference;        }
Magic Number,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetResourceData,The following statement contains a magic number: if (resource.IsInExternalFile) {          IBinaryDocumentMemoryBlock/*?*/ binaryDocumentMemoryBlock = this.ModuleReader.metadataReaderHost.OpenBinaryDocument(this.PEFileReader.BinaryDocumentMemoryBlock.BinaryDocument' resource.ExternalFile.FileName.Value);          if (binaryDocumentMemoryBlock == null) {            //  Error. File not present            return TypeCache.EmptyByteArray;          }          return new EnumerableBinaryDocumentMemoryBlockWrapper(binaryDocumentMemoryBlock);        } else {          uint resOffset = this.PEFileReader.ManifestResourceTable.GetOffset(resource.ResourceRowId);          if (this.PEFileReader.ResourceMemoryReader.Length < resOffset + 4) {            //  MDError:            return TypeCache.EmptyByteArray;          }          uint len = this.PEFileReader.ResourceMemoryReader.PeekUInt32((int)resOffset);          if (this.PEFileReader.ResourceMemoryReader.Length < resOffset + 4 + len) {            //  MDError:            return TypeCache.EmptyByteArray;          }          return new EnumberableMemoryBlockWrapper(this.PEFileReader.ResourceMemoryReader.GetMemoryBlockAt(resOffset + sizeof(Int32)' len));        }
Magic Number,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetResourceData,The following statement contains a magic number: if (resource.IsInExternalFile) {          IBinaryDocumentMemoryBlock/*?*/ binaryDocumentMemoryBlock = this.ModuleReader.metadataReaderHost.OpenBinaryDocument(this.PEFileReader.BinaryDocumentMemoryBlock.BinaryDocument' resource.ExternalFile.FileName.Value);          if (binaryDocumentMemoryBlock == null) {            //  Error. File not present            return TypeCache.EmptyByteArray;          }          return new EnumerableBinaryDocumentMemoryBlockWrapper(binaryDocumentMemoryBlock);        } else {          uint resOffset = this.PEFileReader.ManifestResourceTable.GetOffset(resource.ResourceRowId);          if (this.PEFileReader.ResourceMemoryReader.Length < resOffset + 4) {            //  MDError:            return TypeCache.EmptyByteArray;          }          uint len = this.PEFileReader.ResourceMemoryReader.PeekUInt32((int)resOffset);          if (this.PEFileReader.ResourceMemoryReader.Length < resOffset + 4 + len) {            //  MDError:            return TypeCache.EmptyByteArray;          }          return new EnumberableMemoryBlockWrapper(this.PEFileReader.ResourceMemoryReader.GetMemoryBlockAt(resOffset + sizeof(Int32)' len));        }
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\ILReader.cs,PopulateCilInstructions,The following statement contains a magic number: while (memReader.NotEndOfBytes) {          object/*?*/ value = null;          uint offset = (uint)memReader.Offset;          OperationCode cilOpCode = memReader.ReadOpcode();          switch (cilOpCode) {            case OperationCode.Nop:            case OperationCode.Break:              break;            case OperationCode.Ldarg_0:            case OperationCode.Ldarg_1:            case OperationCode.Ldarg_2:            case OperationCode.Ldarg_3:              value = this.GetParameter((uint)(cilOpCode - OperationCode.Ldarg_0));              break;            case OperationCode.Ldloc_0:            case OperationCode.Ldloc_1:            case OperationCode.Ldloc_2:            case OperationCode.Ldloc_3:              value = this.GetLocal((uint)(cilOpCode - OperationCode.Ldloc_0));              break;            case OperationCode.Stloc_0:            case OperationCode.Stloc_1:            case OperationCode.Stloc_2:            case OperationCode.Stloc_3:              value = this.GetLocal((uint)(cilOpCode - OperationCode.Stloc_0));              break;            case OperationCode.Ldarg_S:            case OperationCode.Ldarga_S:            case OperationCode.Starg_S:              value = this.GetParameter(memReader.ReadByte());              break;            case OperationCode.Ldloc_S:            case OperationCode.Ldloca_S:            case OperationCode.Stloc_S:              value = this.GetLocal(memReader.ReadByte());              break;            case OperationCode.Ldnull:            case OperationCode.Ldc_I4_M1:            case OperationCode.Ldc_I4_0:            case OperationCode.Ldc_I4_1:            case OperationCode.Ldc_I4_2:            case OperationCode.Ldc_I4_3:            case OperationCode.Ldc_I4_4:            case OperationCode.Ldc_I4_5:            case OperationCode.Ldc_I4_6:            case OperationCode.Ldc_I4_7:            case OperationCode.Ldc_I4_8:              break;            case OperationCode.Ldc_I4_S:              value = (int)memReader.ReadSByte();              break;            case OperationCode.Ldc_I4:              value = memReader.ReadInt32();              break;            case OperationCode.Ldc_I8:              value = memReader.ReadInt64();              break;            case OperationCode.Ldc_R4:              value = memReader.ReadSingle();              break;            case OperationCode.Ldc_R8:              value = memReader.ReadDouble();              break;            case OperationCode.Dup:            case OperationCode.Pop:              break;            case OperationCode.Jmp:              value = this.GetMethod(memReader.ReadUInt32());              break;            case OperationCode.Call: {                IMethodReference methodReference = this.GetMethod(memReader.ReadUInt32());                IArrayTypeReference/*?*/ arrayType = methodReference.ContainingType as IArrayTypeReference;                if (arrayType != null) {                  // For Get()' Set() and Address() on arrays' the runtime provides method implementations.                  // Hence' CCI2 replaces these with pseudo instrcutions Array_Set' Array_Get and Array_Addr.                  // All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.                   if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {                    cilOpCode = OperationCode.Array_Set;                    value = arrayType;                  } else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {                    cilOpCode = OperationCode.Array_Get;                    value = arrayType;                  } else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {                    cilOpCode = OperationCode.Array_Addr;                    value = arrayType;                  } else {                    value = methodReference;                  }                } else {                  value = methodReference;                }              }              break;            case OperationCode.Calli:              value = this.GetFunctionPointerType(memReader.ReadUInt32());              break;            case OperationCode.Ret:              break;            case OperationCode.Br_S:            case OperationCode.Brfalse_S:            case OperationCode.Brtrue_S:            case OperationCode.Beq_S:            case OperationCode.Bge_S:            case OperationCode.Bgt_S:            case OperationCode.Ble_S:            case OperationCode.Blt_S:            case OperationCode.Bne_Un_S:            case OperationCode.Bge_Un_S:            case OperationCode.Bgt_Un_S:            case OperationCode.Ble_Un_S:            case OperationCode.Blt_Un_S: {                uint jumpOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte());                if (jumpOffset >= this.EndOfMethodOffset) {                  //  Error...                }                value = jumpOffset;              }              break;            case OperationCode.Br:            case OperationCode.Brfalse:            case OperationCode.Brtrue:            case OperationCode.Beq:            case OperationCode.Bge:            case OperationCode.Bgt:            case OperationCode.Ble:            case OperationCode.Blt:            case OperationCode.Bne_Un:            case OperationCode.Bge_Un:            case OperationCode.Bgt_Un:            case OperationCode.Ble_Un:            case OperationCode.Blt_Un: {                uint jumpOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32());                if (jumpOffset >= this.EndOfMethodOffset) {                  //  Error...                }                value = jumpOffset;              }              break;            case OperationCode.Switch: {                uint numTargets = memReader.ReadUInt32();                uint[] result = new uint[numTargets];                uint asOffset = memReader.Offset + numTargets * 4;                for (int i = 0; i < numTargets; i++) {                  uint targetAddress = memReader.ReadUInt32() + asOffset;                  if (targetAddress >= this.EndOfMethodOffset) {                    //  Error...                  }                  result[i] = targetAddress;                }                value = result;              }              break;            case OperationCode.Ldind_I1:            case OperationCode.Ldind_U1:            case OperationCode.Ldind_I2:            case OperationCode.Ldind_U2:            case OperationCode.Ldind_I4:            case OperationCode.Ldind_U4:            case OperationCode.Ldind_I8:            case OperationCode.Ldind_I:            case OperationCode.Ldind_R4:            case OperationCode.Ldind_R8:            case OperationCode.Ldind_Ref:            case OperationCode.Stind_Ref:            case OperationCode.Stind_I1:            case OperationCode.Stind_I2:            case OperationCode.Stind_I4:            case OperationCode.Stind_I8:            case OperationCode.Stind_R4:            case OperationCode.Stind_R8:            case OperationCode.Add:            case OperationCode.Sub:            case OperationCode.Mul:            case OperationCode.Div:            case OperationCode.Div_Un:            case OperationCode.Rem:            case OperationCode.Rem_Un:            case OperationCode.And:            case OperationCode.Or:            case OperationCode.Xor:            case OperationCode.Shl:            case OperationCode.Shr:            case OperationCode.Shr_Un:            case OperationCode.Neg:            case OperationCode.Not:            case OperationCode.Conv_I1:            case OperationCode.Conv_I2:            case OperationCode.Conv_I4:            case OperationCode.Conv_I8:            case OperationCode.Conv_R4:            case OperationCode.Conv_R8:            case OperationCode.Conv_U4:            case OperationCode.Conv_U8:              break;            case OperationCode.Callvirt: {                IMethodReference methodReference = this.GetMethod(memReader.ReadUInt32());                IArrayTypeReference/*?*/ arrayType = methodReference.ContainingType as IArrayTypeReference;                if (arrayType != null) {                  // For Get()' Set() and Address() on arrays' the runtime provides method implementations.                  // Hence' CCI2 replaces these with pseudo instrcutions Array_Set' Array_Get and Array_Addr.                  // All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.                   if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {                    cilOpCode = OperationCode.Array_Set;                    value = arrayType;                  } else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {                    cilOpCode = OperationCode.Array_Get;                    value = arrayType;                  } else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {                    cilOpCode = OperationCode.Array_Addr;                    value = arrayType;                  } else {                    value = methodReference;                  }                } else {                  value = methodReference;                }              }              break;            case OperationCode.Cpobj:            case OperationCode.Ldobj:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Ldstr:              value = this.GetUserStringForToken(memReader.ReadUInt32());              break;            case OperationCode.Newobj: {                IMethodReference methodReference = this.GetMethod(memReader.ReadUInt32());                IArrayTypeReference/*?*/ arrayType = methodReference.ContainingType as IArrayTypeReference;                if (arrayType != null && !arrayType.IsVector) {                  uint numParam = IteratorHelper.EnumerableCount(methodReference.Parameters);                  if (numParam != arrayType.Rank)                    cilOpCode = OperationCode.Array_Create_WithLowerBound;                  else                    cilOpCode = OperationCode.Array_Create;                  value = arrayType;                } else {                  value = methodReference;                }              }              break;            case OperationCode.Castclass:            case OperationCode.Isinst:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Conv_R_Un:              break;            case OperationCode.Unbox:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Throw:              break;            case OperationCode.Ldfld:            case OperationCode.Ldflda:            case OperationCode.Stfld:            case OperationCode.Ldsfld:            case OperationCode.Ldsflda:            case OperationCode.Stsfld:              value = this.GetField(memReader.ReadUInt32());              break;            case OperationCode.Stobj:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Conv_Ovf_I1_Un:            case OperationCode.Conv_Ovf_I2_Un:            case OperationCode.Conv_Ovf_I4_Un:            case OperationCode.Conv_Ovf_I8_Un:            case OperationCode.Conv_Ovf_U1_Un:            case OperationCode.Conv_Ovf_U2_Un:            case OperationCode.Conv_Ovf_U4_Un:            case OperationCode.Conv_Ovf_U8_Un:            case OperationCode.Conv_Ovf_I_Un:            case OperationCode.Conv_Ovf_U_Un:              break;            case OperationCode.Box:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Newarr: {                ITypeReference elementType = this.GetType(memReader.ReadUInt32());                IModuleTypeReference/*?*/ moduleTypeReference = elementType as IModuleTypeReference;                if (moduleTypeReference != null)                  value = new VectorType(this.PEFileToObjectModel' 0xFFFFFFFF' moduleTypeReference);                else                  value = Dummy.ArrayType;              }              break;            case OperationCode.Ldlen:              break;            case OperationCode.Ldelema:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Ldelem_I1:            case OperationCode.Ldelem_U1:            case OperationCode.Ldelem_I2:            case OperationCode.Ldelem_U2:            case OperationCode.Ldelem_I4:            case OperationCode.Ldelem_U4:            case OperationCode.Ldelem_I8:            case OperationCode.Ldelem_I:            case OperationCode.Ldelem_R4:            case OperationCode.Ldelem_R8:            case OperationCode.Ldelem_Ref:            case OperationCode.Stelem_I:            case OperationCode.Stelem_I1:            case OperationCode.Stelem_I2:            case OperationCode.Stelem_I4:            case OperationCode.Stelem_I8:            case OperationCode.Stelem_R4:            case OperationCode.Stelem_R8:            case OperationCode.Stelem_Ref:              break;            case OperationCode.Ldelem:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Stelem:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Unbox_Any:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Conv_Ovf_I1:            case OperationCode.Conv_Ovf_U1:            case OperationCode.Conv_Ovf_I2:            case OperationCode.Conv_Ovf_U2:            case OperationCode.Conv_Ovf_I4:            case OperationCode.Conv_Ovf_U4:            case OperationCode.Conv_Ovf_I8:            case OperationCode.Conv_Ovf_U8:              break;            case OperationCode.Refanyval:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Ckfinite:              break;            case OperationCode.Mkrefany:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Ldtoken:              value = this.GetRuntimeHandleFromToken(memReader.ReadUInt32());              break;            case OperationCode.Conv_U2:            case OperationCode.Conv_U1:            case OperationCode.Conv_I:            case OperationCode.Conv_Ovf_I:            case OperationCode.Conv_Ovf_U:            case OperationCode.Add_Ovf:            case OperationCode.Add_Ovf_Un:            case OperationCode.Mul_Ovf:            case OperationCode.Mul_Ovf_Un:            case OperationCode.Sub_Ovf:            case OperationCode.Sub_Ovf_Un:            case OperationCode.Endfinally:              break;            case OperationCode.Leave: {                uint leaveOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32());                if (leaveOffset >= this.EndOfMethodOffset) {                  //  Error...                }                value = leaveOffset;              }              break;            case OperationCode.Leave_S: {                uint leaveOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte());                if (leaveOffset >= this.EndOfMethodOffset) {                  //  Error...                }                value = leaveOffset;              }              break;            case OperationCode.Stind_I:            case OperationCode.Conv_U:            case OperationCode.Arglist:            case OperationCode.Ceq:            case OperationCode.Cgt:            case OperationCode.Cgt_Un:            case OperationCode.Clt:            case OperationCode.Clt_Un:              break;            case OperationCode.Ldftn:            case OperationCode.Ldvirtftn:              value = this.GetMethod(memReader.ReadUInt32());              break;            case OperationCode.Ldarg:            case OperationCode.Ldarga:            case OperationCode.Starg:              value = this.GetParameter(memReader.ReadUInt16());              break;            case OperationCode.Ldloc:            case OperationCode.Ldloca:            case OperationCode.Stloc:              value = this.GetLocal(memReader.ReadUInt16());              break;            case OperationCode.Localloc:              value = new PointerType(this.PEFileToObjectModel' 0xFFFFFFFF' this.PEFileToObjectModel.SystemVoid);              break;            case OperationCode.Endfilter:              break;            case OperationCode.Unaligned_:              value = memReader.ReadByte();              break;            case OperationCode.Volatile_:            case OperationCode.Tail_:              break;            case OperationCode.Initobj:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Constrained_:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Cpblk:            case OperationCode.Initblk:              break;            case OperationCode.No_:              value = (OperationCheckFlags)memReader.ReadByte();              break;            case OperationCode.Rethrow:              break;            case OperationCode.Sizeof:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Refanytype:            case OperationCode.Readonly_:              break;            default:              this.PEFileToObjectModel.PEFileReader.ErrorContainer.AddILError(this.MethodDefinition' offset' MetadataReaderErrorKind.UnknownILInstruction);              break;          }          MethodBodyLocation location = new MethodBodyLocation(document' offset);          instrList.Add(new CilInstruction(cilOpCode' location' value));        }
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\ILReader.cs,PopulateCilInstructions,The following statement contains a magic number: while (memReader.NotEndOfBytes) {          object/*?*/ value = null;          uint offset = (uint)memReader.Offset;          OperationCode cilOpCode = memReader.ReadOpcode();          switch (cilOpCode) {            case OperationCode.Nop:            case OperationCode.Break:              break;            case OperationCode.Ldarg_0:            case OperationCode.Ldarg_1:            case OperationCode.Ldarg_2:            case OperationCode.Ldarg_3:              value = this.GetParameter((uint)(cilOpCode - OperationCode.Ldarg_0));              break;            case OperationCode.Ldloc_0:            case OperationCode.Ldloc_1:            case OperationCode.Ldloc_2:            case OperationCode.Ldloc_3:              value = this.GetLocal((uint)(cilOpCode - OperationCode.Ldloc_0));              break;            case OperationCode.Stloc_0:            case OperationCode.Stloc_1:            case OperationCode.Stloc_2:            case OperationCode.Stloc_3:              value = this.GetLocal((uint)(cilOpCode - OperationCode.Stloc_0));              break;            case OperationCode.Ldarg_S:            case OperationCode.Ldarga_S:            case OperationCode.Starg_S:              value = this.GetParameter(memReader.ReadByte());              break;            case OperationCode.Ldloc_S:            case OperationCode.Ldloca_S:            case OperationCode.Stloc_S:              value = this.GetLocal(memReader.ReadByte());              break;            case OperationCode.Ldnull:            case OperationCode.Ldc_I4_M1:            case OperationCode.Ldc_I4_0:            case OperationCode.Ldc_I4_1:            case OperationCode.Ldc_I4_2:            case OperationCode.Ldc_I4_3:            case OperationCode.Ldc_I4_4:            case OperationCode.Ldc_I4_5:            case OperationCode.Ldc_I4_6:            case OperationCode.Ldc_I4_7:            case OperationCode.Ldc_I4_8:              break;            case OperationCode.Ldc_I4_S:              value = (int)memReader.ReadSByte();              break;            case OperationCode.Ldc_I4:              value = memReader.ReadInt32();              break;            case OperationCode.Ldc_I8:              value = memReader.ReadInt64();              break;            case OperationCode.Ldc_R4:              value = memReader.ReadSingle();              break;            case OperationCode.Ldc_R8:              value = memReader.ReadDouble();              break;            case OperationCode.Dup:            case OperationCode.Pop:              break;            case OperationCode.Jmp:              value = this.GetMethod(memReader.ReadUInt32());              break;            case OperationCode.Call: {                IMethodReference methodReference = this.GetMethod(memReader.ReadUInt32());                IArrayTypeReference/*?*/ arrayType = methodReference.ContainingType as IArrayTypeReference;                if (arrayType != null) {                  // For Get()' Set() and Address() on arrays' the runtime provides method implementations.                  // Hence' CCI2 replaces these with pseudo instrcutions Array_Set' Array_Get and Array_Addr.                  // All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.                   if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {                    cilOpCode = OperationCode.Array_Set;                    value = arrayType;                  } else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {                    cilOpCode = OperationCode.Array_Get;                    value = arrayType;                  } else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {                    cilOpCode = OperationCode.Array_Addr;                    value = arrayType;                  } else {                    value = methodReference;                  }                } else {                  value = methodReference;                }              }              break;            case OperationCode.Calli:              value = this.GetFunctionPointerType(memReader.ReadUInt32());              break;            case OperationCode.Ret:              break;            case OperationCode.Br_S:            case OperationCode.Brfalse_S:            case OperationCode.Brtrue_S:            case OperationCode.Beq_S:            case OperationCode.Bge_S:            case OperationCode.Bgt_S:            case OperationCode.Ble_S:            case OperationCode.Blt_S:            case OperationCode.Bne_Un_S:            case OperationCode.Bge_Un_S:            case OperationCode.Bgt_Un_S:            case OperationCode.Ble_Un_S:            case OperationCode.Blt_Un_S: {                uint jumpOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte());                if (jumpOffset >= this.EndOfMethodOffset) {                  //  Error...                }                value = jumpOffset;              }              break;            case OperationCode.Br:            case OperationCode.Brfalse:            case OperationCode.Brtrue:            case OperationCode.Beq:            case OperationCode.Bge:            case OperationCode.Bgt:            case OperationCode.Ble:            case OperationCode.Blt:            case OperationCode.Bne_Un:            case OperationCode.Bge_Un:            case OperationCode.Bgt_Un:            case OperationCode.Ble_Un:            case OperationCode.Blt_Un: {                uint jumpOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32());                if (jumpOffset >= this.EndOfMethodOffset) {                  //  Error...                }                value = jumpOffset;              }              break;            case OperationCode.Switch: {                uint numTargets = memReader.ReadUInt32();                uint[] result = new uint[numTargets];                uint asOffset = memReader.Offset + numTargets * 4;                for (int i = 0; i < numTargets; i++) {                  uint targetAddress = memReader.ReadUInt32() + asOffset;                  if (targetAddress >= this.EndOfMethodOffset) {                    //  Error...                  }                  result[i] = targetAddress;                }                value = result;              }              break;            case OperationCode.Ldind_I1:            case OperationCode.Ldind_U1:            case OperationCode.Ldind_I2:            case OperationCode.Ldind_U2:            case OperationCode.Ldind_I4:            case OperationCode.Ldind_U4:            case OperationCode.Ldind_I8:            case OperationCode.Ldind_I:            case OperationCode.Ldind_R4:            case OperationCode.Ldind_R8:            case OperationCode.Ldind_Ref:            case OperationCode.Stind_Ref:            case OperationCode.Stind_I1:            case OperationCode.Stind_I2:            case OperationCode.Stind_I4:            case OperationCode.Stind_I8:            case OperationCode.Stind_R4:            case OperationCode.Stind_R8:            case OperationCode.Add:            case OperationCode.Sub:            case OperationCode.Mul:            case OperationCode.Div:            case OperationCode.Div_Un:            case OperationCode.Rem:            case OperationCode.Rem_Un:            case OperationCode.And:            case OperationCode.Or:            case OperationCode.Xor:            case OperationCode.Shl:            case OperationCode.Shr:            case OperationCode.Shr_Un:            case OperationCode.Neg:            case OperationCode.Not:            case OperationCode.Conv_I1:            case OperationCode.Conv_I2:            case OperationCode.Conv_I4:            case OperationCode.Conv_I8:            case OperationCode.Conv_R4:            case OperationCode.Conv_R8:            case OperationCode.Conv_U4:            case OperationCode.Conv_U8:              break;            case OperationCode.Callvirt: {                IMethodReference methodReference = this.GetMethod(memReader.ReadUInt32());                IArrayTypeReference/*?*/ arrayType = methodReference.ContainingType as IArrayTypeReference;                if (arrayType != null) {                  // For Get()' Set() and Address() on arrays' the runtime provides method implementations.                  // Hence' CCI2 replaces these with pseudo instrcutions Array_Set' Array_Get and Array_Addr.                  // All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.                   if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {                    cilOpCode = OperationCode.Array_Set;                    value = arrayType;                  } else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {                    cilOpCode = OperationCode.Array_Get;                    value = arrayType;                  } else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {                    cilOpCode = OperationCode.Array_Addr;                    value = arrayType;                  } else {                    value = methodReference;                  }                } else {                  value = methodReference;                }              }              break;            case OperationCode.Cpobj:            case OperationCode.Ldobj:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Ldstr:              value = this.GetUserStringForToken(memReader.ReadUInt32());              break;            case OperationCode.Newobj: {                IMethodReference methodReference = this.GetMethod(memReader.ReadUInt32());                IArrayTypeReference/*?*/ arrayType = methodReference.ContainingType as IArrayTypeReference;                if (arrayType != null && !arrayType.IsVector) {                  uint numParam = IteratorHelper.EnumerableCount(methodReference.Parameters);                  if (numParam != arrayType.Rank)                    cilOpCode = OperationCode.Array_Create_WithLowerBound;                  else                    cilOpCode = OperationCode.Array_Create;                  value = arrayType;                } else {                  value = methodReference;                }              }              break;            case OperationCode.Castclass:            case OperationCode.Isinst:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Conv_R_Un:              break;            case OperationCode.Unbox:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Throw:              break;            case OperationCode.Ldfld:            case OperationCode.Ldflda:            case OperationCode.Stfld:            case OperationCode.Ldsfld:            case OperationCode.Ldsflda:            case OperationCode.Stsfld:              value = this.GetField(memReader.ReadUInt32());              break;            case OperationCode.Stobj:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Conv_Ovf_I1_Un:            case OperationCode.Conv_Ovf_I2_Un:            case OperationCode.Conv_Ovf_I4_Un:            case OperationCode.Conv_Ovf_I8_Un:            case OperationCode.Conv_Ovf_U1_Un:            case OperationCode.Conv_Ovf_U2_Un:            case OperationCode.Conv_Ovf_U4_Un:            case OperationCode.Conv_Ovf_U8_Un:            case OperationCode.Conv_Ovf_I_Un:            case OperationCode.Conv_Ovf_U_Un:              break;            case OperationCode.Box:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Newarr: {                ITypeReference elementType = this.GetType(memReader.ReadUInt32());                IModuleTypeReference/*?*/ moduleTypeReference = elementType as IModuleTypeReference;                if (moduleTypeReference != null)                  value = new VectorType(this.PEFileToObjectModel' 0xFFFFFFFF' moduleTypeReference);                else                  value = Dummy.ArrayType;              }              break;            case OperationCode.Ldlen:              break;            case OperationCode.Ldelema:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Ldelem_I1:            case OperationCode.Ldelem_U1:            case OperationCode.Ldelem_I2:            case OperationCode.Ldelem_U2:            case OperationCode.Ldelem_I4:            case OperationCode.Ldelem_U4:            case OperationCode.Ldelem_I8:            case OperationCode.Ldelem_I:            case OperationCode.Ldelem_R4:            case OperationCode.Ldelem_R8:            case OperationCode.Ldelem_Ref:            case OperationCode.Stelem_I:            case OperationCode.Stelem_I1:            case OperationCode.Stelem_I2:            case OperationCode.Stelem_I4:            case OperationCode.Stelem_I8:            case OperationCode.Stelem_R4:            case OperationCode.Stelem_R8:            case OperationCode.Stelem_Ref:              break;            case OperationCode.Ldelem:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Stelem:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Unbox_Any:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Conv_Ovf_I1:            case OperationCode.Conv_Ovf_U1:            case OperationCode.Conv_Ovf_I2:            case OperationCode.Conv_Ovf_U2:            case OperationCode.Conv_Ovf_I4:            case OperationCode.Conv_Ovf_U4:            case OperationCode.Conv_Ovf_I8:            case OperationCode.Conv_Ovf_U8:              break;            case OperationCode.Refanyval:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Ckfinite:              break;            case OperationCode.Mkrefany:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Ldtoken:              value = this.GetRuntimeHandleFromToken(memReader.ReadUInt32());              break;            case OperationCode.Conv_U2:            case OperationCode.Conv_U1:            case OperationCode.Conv_I:            case OperationCode.Conv_Ovf_I:            case OperationCode.Conv_Ovf_U:            case OperationCode.Add_Ovf:            case OperationCode.Add_Ovf_Un:            case OperationCode.Mul_Ovf:            case OperationCode.Mul_Ovf_Un:            case OperationCode.Sub_Ovf:            case OperationCode.Sub_Ovf_Un:            case OperationCode.Endfinally:              break;            case OperationCode.Leave: {                uint leaveOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32());                if (leaveOffset >= this.EndOfMethodOffset) {                  //  Error...                }                value = leaveOffset;              }              break;            case OperationCode.Leave_S: {                uint leaveOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte());                if (leaveOffset >= this.EndOfMethodOffset) {                  //  Error...                }                value = leaveOffset;              }              break;            case OperationCode.Stind_I:            case OperationCode.Conv_U:            case OperationCode.Arglist:            case OperationCode.Ceq:            case OperationCode.Cgt:            case OperationCode.Cgt_Un:            case OperationCode.Clt:            case OperationCode.Clt_Un:              break;            case OperationCode.Ldftn:            case OperationCode.Ldvirtftn:              value = this.GetMethod(memReader.ReadUInt32());              break;            case OperationCode.Ldarg:            case OperationCode.Ldarga:            case OperationCode.Starg:              value = this.GetParameter(memReader.ReadUInt16());              break;            case OperationCode.Ldloc:            case OperationCode.Ldloca:            case OperationCode.Stloc:              value = this.GetLocal(memReader.ReadUInt16());              break;            case OperationCode.Localloc:              value = new PointerType(this.PEFileToObjectModel' 0xFFFFFFFF' this.PEFileToObjectModel.SystemVoid);              break;            case OperationCode.Endfilter:              break;            case OperationCode.Unaligned_:              value = memReader.ReadByte();              break;            case OperationCode.Volatile_:            case OperationCode.Tail_:              break;            case OperationCode.Initobj:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Constrained_:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Cpblk:            case OperationCode.Initblk:              break;            case OperationCode.No_:              value = (OperationCheckFlags)memReader.ReadByte();              break;            case OperationCode.Rethrow:              break;            case OperationCode.Sizeof:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Refanytype:            case OperationCode.Readonly_:              break;            default:              this.PEFileToObjectModel.PEFileReader.ErrorContainer.AddILError(this.MethodDefinition' offset' MetadataReaderErrorKind.UnknownILInstruction);              break;          }          MethodBodyLocation location = new MethodBodyLocation(document' offset);          instrList.Add(new CilInstruction(cilOpCode' location' value));        }
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\ILReader.cs,PopulateCilInstructions,The following statement contains a magic number: while (memReader.NotEndOfBytes) {          object/*?*/ value = null;          uint offset = (uint)memReader.Offset;          OperationCode cilOpCode = memReader.ReadOpcode();          switch (cilOpCode) {            case OperationCode.Nop:            case OperationCode.Break:              break;            case OperationCode.Ldarg_0:            case OperationCode.Ldarg_1:            case OperationCode.Ldarg_2:            case OperationCode.Ldarg_3:              value = this.GetParameter((uint)(cilOpCode - OperationCode.Ldarg_0));              break;            case OperationCode.Ldloc_0:            case OperationCode.Ldloc_1:            case OperationCode.Ldloc_2:            case OperationCode.Ldloc_3:              value = this.GetLocal((uint)(cilOpCode - OperationCode.Ldloc_0));              break;            case OperationCode.Stloc_0:            case OperationCode.Stloc_1:            case OperationCode.Stloc_2:            case OperationCode.Stloc_3:              value = this.GetLocal((uint)(cilOpCode - OperationCode.Stloc_0));              break;            case OperationCode.Ldarg_S:            case OperationCode.Ldarga_S:            case OperationCode.Starg_S:              value = this.GetParameter(memReader.ReadByte());              break;            case OperationCode.Ldloc_S:            case OperationCode.Ldloca_S:            case OperationCode.Stloc_S:              value = this.GetLocal(memReader.ReadByte());              break;            case OperationCode.Ldnull:            case OperationCode.Ldc_I4_M1:            case OperationCode.Ldc_I4_0:            case OperationCode.Ldc_I4_1:            case OperationCode.Ldc_I4_2:            case OperationCode.Ldc_I4_3:            case OperationCode.Ldc_I4_4:            case OperationCode.Ldc_I4_5:            case OperationCode.Ldc_I4_6:            case OperationCode.Ldc_I4_7:            case OperationCode.Ldc_I4_8:              break;            case OperationCode.Ldc_I4_S:              value = (int)memReader.ReadSByte();              break;            case OperationCode.Ldc_I4:              value = memReader.ReadInt32();              break;            case OperationCode.Ldc_I8:              value = memReader.ReadInt64();              break;            case OperationCode.Ldc_R4:              value = memReader.ReadSingle();              break;            case OperationCode.Ldc_R8:              value = memReader.ReadDouble();              break;            case OperationCode.Dup:            case OperationCode.Pop:              break;            case OperationCode.Jmp:              value = this.GetMethod(memReader.ReadUInt32());              break;            case OperationCode.Call: {                IMethodReference methodReference = this.GetMethod(memReader.ReadUInt32());                IArrayTypeReference/*?*/ arrayType = methodReference.ContainingType as IArrayTypeReference;                if (arrayType != null) {                  // For Get()' Set() and Address() on arrays' the runtime provides method implementations.                  // Hence' CCI2 replaces these with pseudo instrcutions Array_Set' Array_Get and Array_Addr.                  // All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.                   if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {                    cilOpCode = OperationCode.Array_Set;                    value = arrayType;                  } else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {                    cilOpCode = OperationCode.Array_Get;                    value = arrayType;                  } else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {                    cilOpCode = OperationCode.Array_Addr;                    value = arrayType;                  } else {                    value = methodReference;                  }                } else {                  value = methodReference;                }              }              break;            case OperationCode.Calli:              value = this.GetFunctionPointerType(memReader.ReadUInt32());              break;            case OperationCode.Ret:              break;            case OperationCode.Br_S:            case OperationCode.Brfalse_S:            case OperationCode.Brtrue_S:            case OperationCode.Beq_S:            case OperationCode.Bge_S:            case OperationCode.Bgt_S:            case OperationCode.Ble_S:            case OperationCode.Blt_S:            case OperationCode.Bne_Un_S:            case OperationCode.Bge_Un_S:            case OperationCode.Bgt_Un_S:            case OperationCode.Ble_Un_S:            case OperationCode.Blt_Un_S: {                uint jumpOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte());                if (jumpOffset >= this.EndOfMethodOffset) {                  //  Error...                }                value = jumpOffset;              }              break;            case OperationCode.Br:            case OperationCode.Brfalse:            case OperationCode.Brtrue:            case OperationCode.Beq:            case OperationCode.Bge:            case OperationCode.Bgt:            case OperationCode.Ble:            case OperationCode.Blt:            case OperationCode.Bne_Un:            case OperationCode.Bge_Un:            case OperationCode.Bgt_Un:            case OperationCode.Ble_Un:            case OperationCode.Blt_Un: {                uint jumpOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32());                if (jumpOffset >= this.EndOfMethodOffset) {                  //  Error...                }                value = jumpOffset;              }              break;            case OperationCode.Switch: {                uint numTargets = memReader.ReadUInt32();                uint[] result = new uint[numTargets];                uint asOffset = memReader.Offset + numTargets * 4;                for (int i = 0; i < numTargets; i++) {                  uint targetAddress = memReader.ReadUInt32() + asOffset;                  if (targetAddress >= this.EndOfMethodOffset) {                    //  Error...                  }                  result[i] = targetAddress;                }                value = result;              }              break;            case OperationCode.Ldind_I1:            case OperationCode.Ldind_U1:            case OperationCode.Ldind_I2:            case OperationCode.Ldind_U2:            case OperationCode.Ldind_I4:            case OperationCode.Ldind_U4:            case OperationCode.Ldind_I8:            case OperationCode.Ldind_I:            case OperationCode.Ldind_R4:            case OperationCode.Ldind_R8:            case OperationCode.Ldind_Ref:            case OperationCode.Stind_Ref:            case OperationCode.Stind_I1:            case OperationCode.Stind_I2:            case OperationCode.Stind_I4:            case OperationCode.Stind_I8:            case OperationCode.Stind_R4:            case OperationCode.Stind_R8:            case OperationCode.Add:            case OperationCode.Sub:            case OperationCode.Mul:            case OperationCode.Div:            case OperationCode.Div_Un:            case OperationCode.Rem:            case OperationCode.Rem_Un:            case OperationCode.And:            case OperationCode.Or:            case OperationCode.Xor:            case OperationCode.Shl:            case OperationCode.Shr:            case OperationCode.Shr_Un:            case OperationCode.Neg:            case OperationCode.Not:            case OperationCode.Conv_I1:            case OperationCode.Conv_I2:            case OperationCode.Conv_I4:            case OperationCode.Conv_I8:            case OperationCode.Conv_R4:            case OperationCode.Conv_R8:            case OperationCode.Conv_U4:            case OperationCode.Conv_U8:              break;            case OperationCode.Callvirt: {                IMethodReference methodReference = this.GetMethod(memReader.ReadUInt32());                IArrayTypeReference/*?*/ arrayType = methodReference.ContainingType as IArrayTypeReference;                if (arrayType != null) {                  // For Get()' Set() and Address() on arrays' the runtime provides method implementations.                  // Hence' CCI2 replaces these with pseudo instrcutions Array_Set' Array_Get and Array_Addr.                  // All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.                   if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {                    cilOpCode = OperationCode.Array_Set;                    value = arrayType;                  } else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {                    cilOpCode = OperationCode.Array_Get;                    value = arrayType;                  } else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {                    cilOpCode = OperationCode.Array_Addr;                    value = arrayType;                  } else {                    value = methodReference;                  }                } else {                  value = methodReference;                }              }              break;            case OperationCode.Cpobj:            case OperationCode.Ldobj:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Ldstr:              value = this.GetUserStringForToken(memReader.ReadUInt32());              break;            case OperationCode.Newobj: {                IMethodReference methodReference = this.GetMethod(memReader.ReadUInt32());                IArrayTypeReference/*?*/ arrayType = methodReference.ContainingType as IArrayTypeReference;                if (arrayType != null && !arrayType.IsVector) {                  uint numParam = IteratorHelper.EnumerableCount(methodReference.Parameters);                  if (numParam != arrayType.Rank)                    cilOpCode = OperationCode.Array_Create_WithLowerBound;                  else                    cilOpCode = OperationCode.Array_Create;                  value = arrayType;                } else {                  value = methodReference;                }              }              break;            case OperationCode.Castclass:            case OperationCode.Isinst:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Conv_R_Un:              break;            case OperationCode.Unbox:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Throw:              break;            case OperationCode.Ldfld:            case OperationCode.Ldflda:            case OperationCode.Stfld:            case OperationCode.Ldsfld:            case OperationCode.Ldsflda:            case OperationCode.Stsfld:              value = this.GetField(memReader.ReadUInt32());              break;            case OperationCode.Stobj:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Conv_Ovf_I1_Un:            case OperationCode.Conv_Ovf_I2_Un:            case OperationCode.Conv_Ovf_I4_Un:            case OperationCode.Conv_Ovf_I8_Un:            case OperationCode.Conv_Ovf_U1_Un:            case OperationCode.Conv_Ovf_U2_Un:            case OperationCode.Conv_Ovf_U4_Un:            case OperationCode.Conv_Ovf_U8_Un:            case OperationCode.Conv_Ovf_I_Un:            case OperationCode.Conv_Ovf_U_Un:              break;            case OperationCode.Box:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Newarr: {                ITypeReference elementType = this.GetType(memReader.ReadUInt32());                IModuleTypeReference/*?*/ moduleTypeReference = elementType as IModuleTypeReference;                if (moduleTypeReference != null)                  value = new VectorType(this.PEFileToObjectModel' 0xFFFFFFFF' moduleTypeReference);                else                  value = Dummy.ArrayType;              }              break;            case OperationCode.Ldlen:              break;            case OperationCode.Ldelema:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Ldelem_I1:            case OperationCode.Ldelem_U1:            case OperationCode.Ldelem_I2:            case OperationCode.Ldelem_U2:            case OperationCode.Ldelem_I4:            case OperationCode.Ldelem_U4:            case OperationCode.Ldelem_I8:            case OperationCode.Ldelem_I:            case OperationCode.Ldelem_R4:            case OperationCode.Ldelem_R8:            case OperationCode.Ldelem_Ref:            case OperationCode.Stelem_I:            case OperationCode.Stelem_I1:            case OperationCode.Stelem_I2:            case OperationCode.Stelem_I4:            case OperationCode.Stelem_I8:            case OperationCode.Stelem_R4:            case OperationCode.Stelem_R8:            case OperationCode.Stelem_Ref:              break;            case OperationCode.Ldelem:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Stelem:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Unbox_Any:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Conv_Ovf_I1:            case OperationCode.Conv_Ovf_U1:            case OperationCode.Conv_Ovf_I2:            case OperationCode.Conv_Ovf_U2:            case OperationCode.Conv_Ovf_I4:            case OperationCode.Conv_Ovf_U4:            case OperationCode.Conv_Ovf_I8:            case OperationCode.Conv_Ovf_U8:              break;            case OperationCode.Refanyval:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Ckfinite:              break;            case OperationCode.Mkrefany:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Ldtoken:              value = this.GetRuntimeHandleFromToken(memReader.ReadUInt32());              break;            case OperationCode.Conv_U2:            case OperationCode.Conv_U1:            case OperationCode.Conv_I:            case OperationCode.Conv_Ovf_I:            case OperationCode.Conv_Ovf_U:            case OperationCode.Add_Ovf:            case OperationCode.Add_Ovf_Un:            case OperationCode.Mul_Ovf:            case OperationCode.Mul_Ovf_Un:            case OperationCode.Sub_Ovf:            case OperationCode.Sub_Ovf_Un:            case OperationCode.Endfinally:              break;            case OperationCode.Leave: {                uint leaveOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32());                if (leaveOffset >= this.EndOfMethodOffset) {                  //  Error...                }                value = leaveOffset;              }              break;            case OperationCode.Leave_S: {                uint leaveOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte());                if (leaveOffset >= this.EndOfMethodOffset) {                  //  Error...                }                value = leaveOffset;              }              break;            case OperationCode.Stind_I:            case OperationCode.Conv_U:            case OperationCode.Arglist:            case OperationCode.Ceq:            case OperationCode.Cgt:            case OperationCode.Cgt_Un:            case OperationCode.Clt:            case OperationCode.Clt_Un:              break;            case OperationCode.Ldftn:            case OperationCode.Ldvirtftn:              value = this.GetMethod(memReader.ReadUInt32());              break;            case OperationCode.Ldarg:            case OperationCode.Ldarga:            case OperationCode.Starg:              value = this.GetParameter(memReader.ReadUInt16());              break;            case OperationCode.Ldloc:            case OperationCode.Ldloca:            case OperationCode.Stloc:              value = this.GetLocal(memReader.ReadUInt16());              break;            case OperationCode.Localloc:              value = new PointerType(this.PEFileToObjectModel' 0xFFFFFFFF' this.PEFileToObjectModel.SystemVoid);              break;            case OperationCode.Endfilter:              break;            case OperationCode.Unaligned_:              value = memReader.ReadByte();              break;            case OperationCode.Volatile_:            case OperationCode.Tail_:              break;            case OperationCode.Initobj:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Constrained_:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Cpblk:            case OperationCode.Initblk:              break;            case OperationCode.No_:              value = (OperationCheckFlags)memReader.ReadByte();              break;            case OperationCode.Rethrow:              break;            case OperationCode.Sizeof:              value = this.GetType(memReader.ReadUInt32());              break;            case OperationCode.Refanytype:            case OperationCode.Readonly_:              break;            default:              this.PEFileToObjectModel.PEFileReader.ErrorContainer.AddILError(this.MethodDefinition' offset' MetadataReaderErrorKind.UnknownILInstruction);              break;          }          MethodBodyLocation location = new MethodBodyLocation(document' offset);          instrList.Add(new CilInstruction(cilOpCode' location' value));        }
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\UnmanagedReadWrite.cs,PeekCompressedInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00) {          result = headerByte;          numberOfBytesRead = 1;        } else if ((headerByte & 0x40) == 0x00) {          result = ((headerByte & 0x3f) << 8) | this.PeekByte(offset + 1);          numberOfBytesRead = 2;        } else if (headerByte == 0xFF) {          result = -1;          numberOfBytesRead = 1;        } else {          int offsetIter = offset + 1;          result = ((headerByte & 0x3f) << 24) | (this.PeekByte(offsetIter) << 16);          offsetIter++;          result |= (this.PeekByte(offsetIter) << 8);          offsetIter++;          result |= this.PeekByte(offsetIter);          numberOfBytesRead = 4;        }
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\UnmanagedReadWrite.cs,PeekCompressedInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00) {          result = headerByte;          numberOfBytesRead = 1;        } else if ((headerByte & 0x40) == 0x00) {          result = ((headerByte & 0x3f) << 8) | this.PeekByte(offset + 1);          numberOfBytesRead = 2;        } else if (headerByte == 0xFF) {          result = -1;          numberOfBytesRead = 1;        } else {          int offsetIter = offset + 1;          result = ((headerByte & 0x3f) << 24) | (this.PeekByte(offsetIter) << 16);          offsetIter++;          result |= (this.PeekByte(offsetIter) << 8);          offsetIter++;          result |= this.PeekByte(offsetIter);          numberOfBytesRead = 4;        }
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\UnmanagedReadWrite.cs,PeekCompressedInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00) {          result = headerByte;          numberOfBytesRead = 1;        } else if ((headerByte & 0x40) == 0x00) {          result = ((headerByte & 0x3f) << 8) | this.PeekByte(offset + 1);          numberOfBytesRead = 2;        } else if (headerByte == 0xFF) {          result = -1;          numberOfBytesRead = 1;        } else {          int offsetIter = offset + 1;          result = ((headerByte & 0x3f) << 24) | (this.PeekByte(offsetIter) << 16);          offsetIter++;          result |= (this.PeekByte(offsetIter) << 8);          offsetIter++;          result |= this.PeekByte(offsetIter);          numberOfBytesRead = 4;        }
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\UnmanagedReadWrite.cs,PeekCompressedInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00) {          result = headerByte;          numberOfBytesRead = 1;        } else if ((headerByte & 0x40) == 0x00) {          result = ((headerByte & 0x3f) << 8) | this.PeekByte(offset + 1);          numberOfBytesRead = 2;        } else if (headerByte == 0xFF) {          result = -1;          numberOfBytesRead = 1;        } else {          int offsetIter = offset + 1;          result = ((headerByte & 0x3f) << 24) | (this.PeekByte(offsetIter) << 16);          offsetIter++;          result |= (this.PeekByte(offsetIter) << 8);          offsetIter++;          result |= this.PeekByte(offsetIter);          numberOfBytesRead = 4;        }
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\UnmanagedReadWrite.cs,PeekCompressedInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00) {          result = headerByte;          numberOfBytesRead = 1;        } else if ((headerByte & 0x40) == 0x00) {          result = ((headerByte & 0x3f) << 8) | this.PeekByte(offset + 1);          numberOfBytesRead = 2;        } else if (headerByte == 0xFF) {          result = -1;          numberOfBytesRead = 1;        } else {          int offsetIter = offset + 1;          result = ((headerByte & 0x3f) << 24) | (this.PeekByte(offsetIter) << 16);          offsetIter++;          result |= (this.PeekByte(offsetIter) << 8);          offsetIter++;          result |= this.PeekByte(offsetIter);          numberOfBytesRead = 4;        }
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\UnmanagedReadWrite.cs,PeekCompressedInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00) {          result = headerByte;          numberOfBytesRead = 1;        } else if ((headerByte & 0x40) == 0x00) {          result = ((headerByte & 0x3f) << 8) | this.PeekByte(offset + 1);          numberOfBytesRead = 2;        } else if (headerByte == 0xFF) {          result = -1;          numberOfBytesRead = 1;        } else {          int offsetIter = offset + 1;          result = ((headerByte & 0x3f) << 24) | (this.PeekByte(offsetIter) << 16);          offsetIter++;          result |= (this.PeekByte(offsetIter) << 8);          offsetIter++;          result |= this.PeekByte(offsetIter);          numberOfBytesRead = 4;        }
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\UnmanagedReadWrite.cs,PeekCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00) {          result = headerByte;          numberOfBytesRead = 1;        } else if ((headerByte & 0x40) == 0x00) {          result = (uint)((headerByte & 0x3f) << 8) | this.PeekByte((int)offset + 1);          numberOfBytesRead = 2;        } else if (headerByte == 0xFF) {          result = 0xFF;          numberOfBytesRead = 1;        } else {          int offsetIter = (int)offset + 1;          result = (uint)((headerByte & 0x3f) << 24) | (uint)(this.PeekByte(offsetIter) << 16);          offsetIter++;          result |= (uint)(this.PeekByte(offsetIter) << 8);          offsetIter++;          result |= (uint)this.PeekByte(offsetIter);          numberOfBytesRead = 4;        }
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\UnmanagedReadWrite.cs,PeekCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00) {          result = headerByte;          numberOfBytesRead = 1;        } else if ((headerByte & 0x40) == 0x00) {          result = (uint)((headerByte & 0x3f) << 8) | this.PeekByte((int)offset + 1);          numberOfBytesRead = 2;        } else if (headerByte == 0xFF) {          result = 0xFF;          numberOfBytesRead = 1;        } else {          int offsetIter = (int)offset + 1;          result = (uint)((headerByte & 0x3f) << 24) | (uint)(this.PeekByte(offsetIter) << 16);          offsetIter++;          result |= (uint)(this.PeekByte(offsetIter) << 8);          offsetIter++;          result |= (uint)this.PeekByte(offsetIter);          numberOfBytesRead = 4;        }
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\UnmanagedReadWrite.cs,PeekCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00) {          result = headerByte;          numberOfBytesRead = 1;        } else if ((headerByte & 0x40) == 0x00) {          result = (uint)((headerByte & 0x3f) << 8) | this.PeekByte((int)offset + 1);          numberOfBytesRead = 2;        } else if (headerByte == 0xFF) {          result = 0xFF;          numberOfBytesRead = 1;        } else {          int offsetIter = (int)offset + 1;          result = (uint)((headerByte & 0x3f) << 24) | (uint)(this.PeekByte(offsetIter) << 16);          offsetIter++;          result |= (uint)(this.PeekByte(offsetIter) << 8);          offsetIter++;          result |= (uint)this.PeekByte(offsetIter);          numberOfBytesRead = 4;        }
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\UnmanagedReadWrite.cs,PeekCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00) {          result = headerByte;          numberOfBytesRead = 1;        } else if ((headerByte & 0x40) == 0x00) {          result = (uint)((headerByte & 0x3f) << 8) | this.PeekByte((int)offset + 1);          numberOfBytesRead = 2;        } else if (headerByte == 0xFF) {          result = 0xFF;          numberOfBytesRead = 1;        } else {          int offsetIter = (int)offset + 1;          result = (uint)((headerByte & 0x3f) << 24) | (uint)(this.PeekByte(offsetIter) << 16);          offsetIter++;          result |= (uint)(this.PeekByte(offsetIter) << 8);          offsetIter++;          result |= (uint)this.PeekByte(offsetIter);          numberOfBytesRead = 4;        }
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\UnmanagedReadWrite.cs,PeekCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00) {          result = headerByte;          numberOfBytesRead = 1;        } else if ((headerByte & 0x40) == 0x00) {          result = (uint)((headerByte & 0x3f) << 8) | this.PeekByte((int)offset + 1);          numberOfBytesRead = 2;        } else if (headerByte == 0xFF) {          result = 0xFF;          numberOfBytesRead = 1;        } else {          int offsetIter = (int)offset + 1;          result = (uint)((headerByte & 0x3f) << 24) | (uint)(this.PeekByte(offsetIter) << 16);          offsetIter++;          result |= (uint)(this.PeekByte(offsetIter) << 8);          offsetIter++;          result |= (uint)this.PeekByte(offsetIter);          numberOfBytesRead = 4;        }
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\UnmanagedReadWrite.cs,PeekCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00) {          result = headerByte;          numberOfBytesRead = 1;        } else if ((headerByte & 0x40) == 0x00) {          result = (uint)((headerByte & 0x3f) << 8) | this.PeekByte((int)offset + 1);          numberOfBytesRead = 2;        } else if (headerByte == 0xFF) {          result = 0xFF;          numberOfBytesRead = 1;        } else {          int offsetIter = (int)offset + 1;          result = (uint)((headerByte & 0x3f) << 24) | (uint)(this.PeekByte(offsetIter) << 16);          offsetIter++;          result |= (uint)(this.PeekByte(offsetIter) << 8);          offsetIter++;          result |= (uint)this.PeekByte(offsetIter);          numberOfBytesRead = 4;        }
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: for (; ; ) {          b = *pIter++;          if (b == 0) break;          if ((b & 0x80) == 0) {            sb.Append((char)b);            continue;          }          char ch;          byte b1 = *pIter++;          if (b1 == 0) { //Dangling lead byte' do not decompose            sb.Append((char)b);            break;          }          if ((b & 0x20) == 0) {            ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));          } else {            byte b2 = *pIter++;            if (b2 == 0) { //Dangling lead bytes' do not decompose              sb.Append((char)((b << 8) | b1));              break;            }            uint ch32;            if ((b & 0x10) == 0)              ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));            else {              byte b3 = *pIter++;              if (b3 == 0) { //Dangling lead bytes' do not decompose                sb.Append((char)((b << 8) | b1));                sb.Append((char)b2);                break;              }              ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));            }            if ((ch32 & 0xFFFF0000) == 0)              ch = (char)ch32;            else { //break up into UTF16 surrogate pair              sb.Append((char)((ch32 >> 10) | 0xD800));              ch = (char)((ch32 & 0x3FF) | 0xDC00);            }          }          sb.Append(ch);        }
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: for (; ; ) {          b = *pIter++;          if (b == 0) break;          if ((b & 0x80) == 0) {            sb.Append((char)b);            continue;          }          char ch;          byte b1 = *pIter++;          if (b1 == 0) { //Dangling lead byte' do not decompose            sb.Append((char)b);            break;          }          if ((b & 0x20) == 0) {            ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));          } else {            byte b2 = *pIter++;            if (b2 == 0) { //Dangling lead bytes' do not decompose              sb.Append((char)((b << 8) | b1));              break;            }            uint ch32;            if ((b & 0x10) == 0)              ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));            else {              byte b3 = *pIter++;              if (b3 == 0) { //Dangling lead bytes' do not decompose                sb.Append((char)((b << 8) | b1));                sb.Append((char)b2);                break;              }              ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));            }            if ((ch32 & 0xFFFF0000) == 0)              ch = (char)ch32;            else { //break up into UTF16 surrogate pair              sb.Append((char)((ch32 >> 10) | 0xD800));              ch = (char)((ch32 & 0x3FF) | 0xDC00);            }          }          sb.Append(ch);        }
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: for (; ; ) {          b = *pIter++;          if (b == 0) break;          if ((b & 0x80) == 0) {            sb.Append((char)b);            continue;          }          char ch;          byte b1 = *pIter++;          if (b1 == 0) { //Dangling lead byte' do not decompose            sb.Append((char)b);            break;          }          if ((b & 0x20) == 0) {            ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));          } else {            byte b2 = *pIter++;            if (b2 == 0) { //Dangling lead bytes' do not decompose              sb.Append((char)((b << 8) | b1));              break;            }            uint ch32;            if ((b & 0x10) == 0)              ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));            else {              byte b3 = *pIter++;              if (b3 == 0) { //Dangling lead bytes' do not decompose                sb.Append((char)((b << 8) | b1));                sb.Append((char)b2);                break;              }              ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));            }            if ((ch32 & 0xFFFF0000) == 0)              ch = (char)ch32;            else { //break up into UTF16 surrogate pair              sb.Append((char)((ch32 >> 10) | 0xD800));              ch = (char)((ch32 & 0x3FF) | 0xDC00);            }          }          sb.Append(ch);        }
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: for (; ; ) {          b = *pIter++;          if (b == 0) break;          if ((b & 0x80) == 0) {            sb.Append((char)b);            continue;          }          char ch;          byte b1 = *pIter++;          if (b1 == 0) { //Dangling lead byte' do not decompose            sb.Append((char)b);            break;          }          if ((b & 0x20) == 0) {            ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));          } else {            byte b2 = *pIter++;            if (b2 == 0) { //Dangling lead bytes' do not decompose              sb.Append((char)((b << 8) | b1));              break;            }            uint ch32;            if ((b & 0x10) == 0)              ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));            else {              byte b3 = *pIter++;              if (b3 == 0) { //Dangling lead bytes' do not decompose                sb.Append((char)((b << 8) | b1));                sb.Append((char)b2);                break;              }              ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));            }            if ((ch32 & 0xFFFF0000) == 0)              ch = (char)ch32;            else { //break up into UTF16 surrogate pair              sb.Append((char)((ch32 >> 10) | 0xD800));              ch = (char)((ch32 & 0x3FF) | 0xDC00);            }          }          sb.Append(ch);        }
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: for (; ; ) {          b = *pIter++;          if (b == 0) break;          if ((b & 0x80) == 0) {            sb.Append((char)b);            continue;          }          char ch;          byte b1 = *pIter++;          if (b1 == 0) { //Dangling lead byte' do not decompose            sb.Append((char)b);            break;          }          if ((b & 0x20) == 0) {            ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));          } else {            byte b2 = *pIter++;            if (b2 == 0) { //Dangling lead bytes' do not decompose              sb.Append((char)((b << 8) | b1));              break;            }            uint ch32;            if ((b & 0x10) == 0)              ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));            else {              byte b3 = *pIter++;              if (b3 == 0) { //Dangling lead bytes' do not decompose                sb.Append((char)((b << 8) | b1));                sb.Append((char)b2);                break;              }              ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));            }            if ((ch32 & 0xFFFF0000) == 0)              ch = (char)ch32;            else { //break up into UTF16 surrogate pair              sb.Append((char)((ch32 >> 10) | 0xD800));              ch = (char)((ch32 & 0x3FF) | 0xDC00);            }          }          sb.Append(ch);        }
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: for (; ; ) {          b = *pIter++;          if (b == 0) break;          if ((b & 0x80) == 0) {            sb.Append((char)b);            continue;          }          char ch;          byte b1 = *pIter++;          if (b1 == 0) { //Dangling lead byte' do not decompose            sb.Append((char)b);            break;          }          if ((b & 0x20) == 0) {            ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));          } else {            byte b2 = *pIter++;            if (b2 == 0) { //Dangling lead bytes' do not decompose              sb.Append((char)((b << 8) | b1));              break;            }            uint ch32;            if ((b & 0x10) == 0)              ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));            else {              byte b3 = *pIter++;              if (b3 == 0) { //Dangling lead bytes' do not decompose                sb.Append((char)((b << 8) | b1));                sb.Append((char)b2);                break;              }              ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));            }            if ((ch32 & 0xFFFF0000) == 0)              ch = (char)ch32;            else { //break up into UTF16 surrogate pair              sb.Append((char)((ch32 >> 10) | 0xD800));              ch = (char)((ch32 & 0x3FF) | 0xDC00);            }          }          sb.Append(ch);        }
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: for (; ; ) {          b = *pIter++;          if (b == 0) break;          if ((b & 0x80) == 0) {            sb.Append((char)b);            continue;          }          char ch;          byte b1 = *pIter++;          if (b1 == 0) { //Dangling lead byte' do not decompose            sb.Append((char)b);            break;          }          if ((b & 0x20) == 0) {            ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));          } else {            byte b2 = *pIter++;            if (b2 == 0) { //Dangling lead bytes' do not decompose              sb.Append((char)((b << 8) | b1));              break;            }            uint ch32;            if ((b & 0x10) == 0)              ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));            else {              byte b3 = *pIter++;              if (b3 == 0) { //Dangling lead bytes' do not decompose                sb.Append((char)((b << 8) | b1));                sb.Append((char)b2);                break;              }              ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));            }            if ((ch32 & 0xFFFF0000) == 0)              ch = (char)ch32;            else { //break up into UTF16 surrogate pair              sb.Append((char)((ch32 >> 10) | 0xD800));              ch = (char)((ch32 & 0x3FF) | 0xDC00);            }          }          sb.Append(ch);        }
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: for (; ; ) {          b = *pIter++;          if (b == 0) break;          if ((b & 0x80) == 0) {            sb.Append((char)b);            continue;          }          char ch;          byte b1 = *pIter++;          if (b1 == 0) { //Dangling lead byte' do not decompose            sb.Append((char)b);            break;          }          if ((b & 0x20) == 0) {            ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));          } else {            byte b2 = *pIter++;            if (b2 == 0) { //Dangling lead bytes' do not decompose              sb.Append((char)((b << 8) | b1));              break;            }            uint ch32;            if ((b & 0x10) == 0)              ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));            else {              byte b3 = *pIter++;              if (b3 == 0) { //Dangling lead bytes' do not decompose                sb.Append((char)((b << 8) | b1));                sb.Append((char)b2);                break;              }              ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));            }            if ((ch32 & 0xFFFF0000) == 0)              ch = (char)ch32;            else { //break up into UTF16 surrogate pair              sb.Append((char)((ch32 >> 10) | 0xD800));              ch = (char)((ch32 & 0x3FF) | 0xDC00);            }          }          sb.Append(ch);        }
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: for (; ; ) {          b = *pIter++;          if (b == 0) break;          if ((b & 0x80) == 0) {            sb.Append((char)b);            continue;          }          char ch;          byte b1 = *pIter++;          if (b1 == 0) { //Dangling lead byte' do not decompose            sb.Append((char)b);            break;          }          if ((b & 0x20) == 0) {            ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));          } else {            byte b2 = *pIter++;            if (b2 == 0) { //Dangling lead bytes' do not decompose              sb.Append((char)((b << 8) | b1));              break;            }            uint ch32;            if ((b & 0x10) == 0)              ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));            else {              byte b3 = *pIter++;              if (b3 == 0) { //Dangling lead bytes' do not decompose                sb.Append((char)((b << 8) | b1));                sb.Append((char)b2);                break;              }              ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));            }            if ((ch32 & 0xFFFF0000) == 0)              ch = (char)ch32;            else { //break up into UTF16 surrogate pair              sb.Append((char)((ch32 >> 10) | 0xD800));              ch = (char)((ch32 & 0x3FF) | 0xDC00);            }          }          sb.Append(ch);        }
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\UnmanagedReadWrite.cs,BinarySearchForSlot,The following statement contains a magic number: while ((endRowNumber - startRowNumber) > 1) {          if (referenceValue <= startValue)            return referenceValue == startValue ? startRowNumber : startRowNumber - 1;          else if (referenceValue >= endValue)            return referenceValue == endValue ? endRowNumber : endRowNumber + 1;          int midRowNumber = (startRowNumber + endRowNumber) / 2;          uint midReferenceValue = this.PeekReference(midRowNumber * rowSize + referenceOffset' isReferenceSmall);          if (referenceValue > midReferenceValue) {            startRowNumber = midRowNumber;            startValue = midReferenceValue;          } else if (referenceValue < midReferenceValue) {            endRowNumber = midRowNumber;            endValue = midReferenceValue;          } else            return midRowNumber;        }
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\UnmanagedReadWrite.cs,BinarySearchReference,The following statement contains a magic number: while (startRowNumber <= endRowNumber) {          int midRowNumber = (startRowNumber + endRowNumber) / 2;          uint midReferenceValue = this.PeekReference(midRowNumber * rowSize + referenceOffset' isReferenceSmall);          if (referenceValue > midReferenceValue)            startRowNumber = midRowNumber + 1;          else if (referenceValue < midReferenceValue)            endRowNumber = midRowNumber - 1;          else            return midRowNumber;        }
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\UnmanagedReadWrite.cs,ReadOpcode,The following statement contains a magic number: if (result == 0xFE) {          result = result << 8 | this.ReadByte();        }
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\UnmanagedReadWrite.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00)          result = headerByte;        else if ((headerByte & 0x40) == 0x00)          result = ((headerByte & 0x3f) << 8) | this.ReadByte();        else if (headerByte == 0xFF)          result = -1;        else          result = ((headerByte & 0x3f) << 24) | (this.ReadByte() << 16) | (this.ReadByte() << 8) | this.ReadByte();
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\UnmanagedReadWrite.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00)          result = headerByte;        else if ((headerByte & 0x40) == 0x00)          result = ((headerByte & 0x3f) << 8) | this.ReadByte();        else if (headerByte == 0xFF)          result = -1;        else          result = ((headerByte & 0x3f) << 24) | (this.ReadByte() << 16) | (this.ReadByte() << 8) | this.ReadByte();
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\UnmanagedReadWrite.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00)          result = headerByte;        else if ((headerByte & 0x40) == 0x00)          result = ((headerByte & 0x3f) << 8) | this.ReadByte();        else if (headerByte == 0xFF)          result = -1;        else          result = ((headerByte & 0x3f) << 24) | (this.ReadByte() << 16) | (this.ReadByte() << 8) | this.ReadByte();
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\UnmanagedReadWrite.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00)          result = headerByte;        else if ((headerByte & 0x40) == 0x00)          result = ((headerByte & 0x3f) << 8) | this.ReadByte();        else if (headerByte == 0xFF)          result = -1;        else          result = ((headerByte & 0x3f) << 24) | (this.ReadByte() << 16) | (this.ReadByte() << 8) | this.ReadByte();
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\UnmanagedReadWrite.cs,ReadCompressedInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00) {          result = headerByte;          if ((result & 0x01) == 0)            result = result >> 1;          else            result = (result >> 1) - 0x40;        } else if ((headerByte & 0x40) == 0x00) {          result = ((headerByte & 0x3f) << 8) | this.ReadByte();          if ((result & 0x01) == 0)            result = result >> 1;          else            result = (result >> 1) - 0x2000;        } else if (headerByte == 0xFF)          result = -1;        else {          result = ((headerByte & 0x3f) << 24) | (this.ReadByte() << 16) | (this.ReadByte() << 8) | this.ReadByte();          if ((result & 0x01) == 0)            result = result >> 1;          else            result = (result >> 1) - 0x20000000;        }
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\UnmanagedReadWrite.cs,ReadCompressedInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00) {          result = headerByte;          if ((result & 0x01) == 0)            result = result >> 1;          else            result = (result >> 1) - 0x40;        } else if ((headerByte & 0x40) == 0x00) {          result = ((headerByte & 0x3f) << 8) | this.ReadByte();          if ((result & 0x01) == 0)            result = result >> 1;          else            result = (result >> 1) - 0x2000;        } else if (headerByte == 0xFF)          result = -1;        else {          result = ((headerByte & 0x3f) << 24) | (this.ReadByte() << 16) | (this.ReadByte() << 8) | this.ReadByte();          if ((result & 0x01) == 0)            result = result >> 1;          else            result = (result >> 1) - 0x20000000;        }
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\UnmanagedReadWrite.cs,ReadCompressedInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00) {          result = headerByte;          if ((result & 0x01) == 0)            result = result >> 1;          else            result = (result >> 1) - 0x40;        } else if ((headerByte & 0x40) == 0x00) {          result = ((headerByte & 0x3f) << 8) | this.ReadByte();          if ((result & 0x01) == 0)            result = result >> 1;          else            result = (result >> 1) - 0x2000;        } else if (headerByte == 0xFF)          result = -1;        else {          result = ((headerByte & 0x3f) << 24) | (this.ReadByte() << 16) | (this.ReadByte() << 8) | this.ReadByte();          if ((result & 0x01) == 0)            result = result >> 1;          else            result = (result >> 1) - 0x20000000;        }
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\UnmanagedReadWrite.cs,ReadCompressedInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00) {          result = headerByte;          if ((result & 0x01) == 0)            result = result >> 1;          else            result = (result >> 1) - 0x40;        } else if ((headerByte & 0x40) == 0x00) {          result = ((headerByte & 0x3f) << 8) | this.ReadByte();          if ((result & 0x01) == 0)            result = result >> 1;          else            result = (result >> 1) - 0x2000;        } else if (headerByte == 0xFF)          result = -1;        else {          result = ((headerByte & 0x3f) << 24) | (this.ReadByte() << 16) | (this.ReadByte() << 8) | this.ReadByte();          if ((result & 0x01) == 0)            result = result >> 1;          else            result = (result >> 1) - 0x20000000;        }
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\UnmanagedReadWrite.cs,ReadASCIINullTerminated,The following statement contains a magic number: int count = 128;
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\UnmanagedReadWrite.cs,ReadASCIINullTerminated,The following statement contains a magic number: if (b != 0) {          count <<= 2;          char[] newBuffer = new char[count];          for (int copy = 0; copy < j; copy++)            newBuffer[copy] = buffer[copy];          buffer = newBuffer;          goto Restart;        }
Magic Number,Microsoft.Cci.MetadataReader.PEFileFlags,MetadataTableHeader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,GetNumberOfTablesPresent,The following statement contains a magic number: count = (count & MASK_00110011001100110011001100110011) + ((count >> 2) & MASK_00110011001100110011001100110011);
Magic Number,Microsoft.Cci.MetadataReader.PEFileFlags,MetadataTableHeader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,GetNumberOfTablesPresent,The following statement contains a magic number: count = (count & MASK_00001111000011110000111100001111) + ((count >> 4) & MASK_00001111000011110000111100001111);
Magic Number,Microsoft.Cci.MetadataReader.PEFileFlags,MetadataTableHeader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,GetNumberOfTablesPresent,The following statement contains a magic number: count = (count & MASK_00000000111111110000000011111111) + ((count >> 8) & MASK_00000000111111110000000011111111);
Magic Number,Microsoft.Cci.MetadataReader.PEFileFlags,MetadataTableHeader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,GetNumberOfTablesPresent,The following statement contains a magic number: count = (count & MASK_00000000000000001111111111111111) + ((count >> 16) & MASK_00000000000000001111111111111111);
Magic Number,Microsoft.Cci.MetadataReader.PEFileFlags,MetadataTableHeader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,GetNumberOfTablesPresent,The following statement contains a magic number: count = (count & MASK_11111111111111111111111111111111) + ((count >> 32) & MASK_11111111111111111111111111111111);
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MetadataTableHeader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,GetNumberOfTablesPresent,The following statement contains a magic number: count = (count & MASK_00110011001100110011001100110011) + ((count >> 2) & MASK_00110011001100110011001100110011);
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MetadataTableHeader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,GetNumberOfTablesPresent,The following statement contains a magic number: count = (count & MASK_00001111000011110000111100001111) + ((count >> 4) & MASK_00001111000011110000111100001111);
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MetadataTableHeader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,GetNumberOfTablesPresent,The following statement contains a magic number: count = (count & MASK_00000000111111110000000011111111) + ((count >> 8) & MASK_00000000111111110000000011111111);
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MetadataTableHeader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,GetNumberOfTablesPresent,The following statement contains a magic number: count = (count & MASK_00000000000000001111111111111111) + ((count >> 16) & MASK_00000000000000001111111111111111);
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MetadataTableHeader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,GetNumberOfTablesPresent,The following statement contains a magic number: count = (count & MASK_11111111111111111111111111111111) + ((count >> 32) & MASK_11111111111111111111111111111111);
Magic Number,Microsoft.Cci.MetadataReader.PEFile,ModuleTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ModuleTableReader,The following statement contains a magic number: this.IsStringHeapRefSizeSmall = stringHeapRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,ModuleTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ModuleTableReader,The following statement contains a magic number: this.IsGUIDHeapRefSizeSmall = guidHeapRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,TypeRefTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,TypeRefTableReader,The following statement contains a magic number: this.IsResolutionScopeRefSizeSmall = resolutionScopeRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,TypeRefTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,TypeRefTableReader,The following statement contains a magic number: this.IsStringHeapRefSizeSmall = stringHeapRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,TypeDefTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,TypeDefTableReader,The following statement contains a magic number: this.IsFieldRefSizeSmall = fieldRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,TypeDefTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,TypeDefTableReader,The following statement contains a magic number: this.IsMethodRefSizeSmall = methodRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,TypeDefTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,TypeDefTableReader,The following statement contains a magic number: this.IsTypeDefOrRefRefSizeSmall = typeDefOrRefRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,TypeDefTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,TypeDefTableReader,The following statement contains a magic number: this.IsStringHeapRefSizeSmall = stringHeapRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,FieldPtrTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,FieldPtrTableReader,The following statement contains a magic number: this.IsFieldTableRowRefSizeSmall = fieldTableRowRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,FieldTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,FieldTableReader,The following statement contains a magic number: this.IsStringHeapRefSizeSmall = stringHeapRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,FieldTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,FieldTableReader,The following statement contains a magic number: this.IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MethodPtrTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,MethodPtrTableReader,The following statement contains a magic number: this.IsMethodTableRowRefSizeSmall = methodTableRowRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MethodTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,MethodTableReader,The following statement contains a magic number: this.IsParamRefSizeSmall = paramRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MethodTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,MethodTableReader,The following statement contains a magic number: this.IsStringHeapRefSizeSmall = stringHeapRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MethodTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,MethodTableReader,The following statement contains a magic number: this.IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,ParamPtrTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ParamPtrTableReader,The following statement contains a magic number: this.IsParamTableRowRefSizeSmall = paramTableRowRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,ParamTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ParamTableReader,The following statement contains a magic number: this.IsStringHeapRefSizeSmall = stringHeapRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,InterfaceImplTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,InterfaceImplTableReader,The following statement contains a magic number: this.IsTypeDefTableRowRefSizeSmall = typeDefTableRowRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,InterfaceImplTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,InterfaceImplTableReader,The following statement contains a magic number: this.IsTypeDefOrRefRefSizeSmall = typeDefOrRefRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MemberRefTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,MemberRefTableReader,The following statement contains a magic number: this.IsMemberRefParentRefSizeSmall = memberRefParentRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MemberRefTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,MemberRefTableReader,The following statement contains a magic number: this.IsStringHeapRefSizeSmall = stringHeapRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MemberRefTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,MemberRefTableReader,The following statement contains a magic number: this.IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,ConstantTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ConstantTableReader,The following statement contains a magic number: this.IsHasConstantRefSizeSmall = hasConstantRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,ConstantTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ConstantTableReader,The following statement contains a magic number: this.IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,CustomAttributeTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,CustomAttributeTableReader,The following statement contains a magic number: this.IsHasCustomAttributeRefSizeSmall = hasCustomAttributeRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,CustomAttributeTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,CustomAttributeTableReader,The following statement contains a magic number: this.IsCustomAttriubuteTypeRefSizeSmall = customAttributeTypeRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,CustomAttributeTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,CustomAttributeTableReader,The following statement contains a magic number: this.IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,FieldMarshalTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,FieldMarshalTableReader,The following statement contains a magic number: this.IsHasFieldMarshalRefSizeSmall = hasFieldMarshalRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,FieldMarshalTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,FieldMarshalTableReader,The following statement contains a magic number: this.IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,DeclSecurityTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,DeclSecurityTableReader,The following statement contains a magic number: this.IsHasDeclSecurityRefSizeSmall = hasDeclSecurityRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,DeclSecurityTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,DeclSecurityTableReader,The following statement contains a magic number: this.IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,ClassLayoutTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ClassLayoutTableReader,The following statement contains a magic number: this.IsTypeDefTableRowRefSizeSmall = typeDefTableRowRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,FieldLayoutTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,FieldLayoutTableReader,The following statement contains a magic number: this.IsFieldTableRowRefSizeSmall = fieldTableRowRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,StandAloneSigTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,StandAloneSigTableReader,The following statement contains a magic number: this.IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,EventMapTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,EventMapTableReader,The following statement contains a magic number: this.IsTypeDefTableRowRefSizeSmall = typeDefTableRowRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,EventMapTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,EventMapTableReader,The following statement contains a magic number: this.IsEventRefSizeSmall = eventRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,EventPtrTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,EventPtrTableReader,The following statement contains a magic number: this.IsEventTableRowRefSizeSmall = eventTableRowRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,EventTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,EventTableReader,The following statement contains a magic number: this.IsTypeDefOrRefRefSizeSmall = typeDefOrRefRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,EventTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,EventTableReader,The following statement contains a magic number: this.IsStringHeapRefSizeSmall = stringHeapRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PropertyMapTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,PropertyMapTableReader,The following statement contains a magic number: this.IsTypeDefTableRowRefSizeSmall = typeDefTableRowRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PropertyMapTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,PropertyMapTableReader,The following statement contains a magic number: this.IsPropertyRefSizeSmall = propertyRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PropertyPtrTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,PropertyPtrTableReader,The following statement contains a magic number: this.IsPropertyTableRowRefSizeSmall = propertyTableRowRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PropertyTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,PropertyTableReader,The following statement contains a magic number: this.IsStringHeapRefSizeSmall = stringHeapRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PropertyTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,PropertyTableReader,The following statement contains a magic number: this.IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MethodSemanticsTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,MethodSemanticsTableReader,The following statement contains a magic number: this.IsMethodTableRowRefSizeSmall = methodTableRowRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MethodSemanticsTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,MethodSemanticsTableReader,The following statement contains a magic number: this.IsHasSemanticRefSizeSmall = hasSemanticRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MethodImplTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,MethodImplTableReader,The following statement contains a magic number: this.IsTypeDefTableRowRefSizeSmall = typeDefTableRowRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MethodImplTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,MethodImplTableReader,The following statement contains a magic number: this.IsMethodDefOrRefRefSizeSmall = methodDefOrRefRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,ModuleRefTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ModuleRefTableReader,The following statement contains a magic number: this.IsStringHeapRefSizeSmall = stringHeapRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,TypeSpecTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,TypeSpecTableReader,The following statement contains a magic number: this.IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,ImplMapTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ImplMapTableReader,The following statement contains a magic number: this.IsModuleRefTableRowRefSizeSmall = moduleRefTableRowRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,ImplMapTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ImplMapTableReader,The following statement contains a magic number: this.IsMemberForwardRowRefSizeSmall = memberForwardedRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,ImplMapTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ImplMapTableReader,The following statement contains a magic number: this.IsStringHeapRefSizeSmall = stringHeapRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,FieldRVATableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,FieldRVATableReader,The following statement contains a magic number: this.IsFieldTableRowRefSizeSmall = fieldTableRowRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,AssemblyTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,AssemblyTableReader,The following statement contains a magic number: this.IsStringHeapRefSizeSmall = stringHeapRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,AssemblyTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,AssemblyTableReader,The following statement contains a magic number: this.IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,AssemblyRefTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,AssemblyRefTableReader,The following statement contains a magic number: this.IsStringHeapRefSizeSmall = stringHeapRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,AssemblyRefTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,AssemblyRefTableReader,The following statement contains a magic number: this.IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,AssemblyRefProcessorTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,AssemblyRefProcessorTableReader,The following statement contains a magic number: this.IsAssemblyRefTableRowSizeSmall = assembyRefTableRowRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,AssemblyRefOSTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,AssemblyRefOSTableReader,The following statement contains a magic number: this.IsAssemblyRefTableRowRefSizeSmall = assembyRefTableRowRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,FileTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,FileTableReader,The following statement contains a magic number: this.IsStringHeapRefSizeSmall = stringHeapRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,FileTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,FileTableReader,The following statement contains a magic number: this.IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,ExportedTypeTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ExportedTypeTableReader,The following statement contains a magic number: this.IsImplementationRefSizeSmall = implementationRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,ExportedTypeTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ExportedTypeTableReader,The following statement contains a magic number: this.IsStringHeapRefSizeSmall = stringHeapRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,ManifestResourceTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ManifestResourceTableReader,The following statement contains a magic number: this.IsImplementationRefSizeSmall = implementationRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,ManifestResourceTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ManifestResourceTableReader,The following statement contains a magic number: this.IsStringHeapRefSizeSmall = stringHeapRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,NestedClassTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,NestedClassTableReader,The following statement contains a magic number: this.IsTypeDefTableRowRefSizeSmall = typeDefTableRowRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,GenericParamTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,GenericParamTableReader,The following statement contains a magic number: this.IsTypeOrMethodDefRefSizeSmall = typeOrMethodDefRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,GenericParamTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,GenericParamTableReader,The following statement contains a magic number: this.IsStringHeapRefSizeSmall = stringHeapRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MethodSpecTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,MethodSpecTableReader,The following statement contains a magic number: this.IsMethodDefOrRefRefSizeSmall = methodDefOrRefRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MethodSpecTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,MethodSpecTableReader,The following statement contains a magic number: this.IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,GenericParamConstraintTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,GenericParamConstraintTableReader,The following statement contains a magic number: this.IsGenericParamTableRowRefSizeSmall = genericParamTableRowRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,GenericParamConstraintTableReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,GenericParamConstraintTableReader,The following statement contains a magic number: this.IsTypeDefOrRefRefSizeSmall = typeDefOrRefRefSize == 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ReadStreamHeaders,The following statement contains a magic number: for (int i = 0; i < numberOfStreams; ++i) {          if (memReader.RemainingBytes < COR20Constants.MinimumSizeofStreamHeader) {            this.ErrorContainer.AddDirectoryError(Directories.Cor20HeaderMetaData' memReader.Offset' MetadataReaderErrorKind.StreamHeaderTooSmall);            return false;          }          streamHeaders[i].Offset = memReader.ReadUInt32();          streamHeaders[i].Size = memReader.ReadInt32();          //  Review: Oh well there is no way i can test if we will read correctly. However we can check it after reading and aligning...          streamHeaders[i].Name = memReader.ReadASCIINullTerminated();          memReader.Align(4);          if (memReader.RemainingBytes < 0) {            this.ErrorContainer.AddDirectoryError(Directories.Cor20HeaderMetaData' memReader.Offset' MetadataReaderErrorKind.NotEnoughSpaceForStreamHeaderName);            return false;          }        }
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ReadMetadataTableInformation,The following statement contains a magic number: int version = this.MetadataTableHeader.MajorVersion << 16 | this.MetadataTableHeader.MinorVersion;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ReadMetadataTableInformation,The following statement contains a magic number: switch (version) {          case 0x00010000:            validTablesForVersion = (ulong)TableMask.V1_0_TablesMask;            break;          case 0x00010001:            validTablesForVersion = (ulong)TableMask.V1_1_TablesMask;            break;          case 0x00020000:            validTablesForVersion = (ulong)TableMask.V2_0_TablesMask;            break;          default:            this.ErrorContainer.AddMetadataStreamError(this.MetadataStreamName' 4' MetadataReaderErrorKind.UnknownVersionOfMetadata);            return false;        }
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ReadMetadataTableInformation,The following statement contains a magic number: if ((presentTables & ~validTablesForVersion) != 0) {          this.ErrorContainer.AddMetadataStreamError(this.MetadataStreamName' 8' MetadataReaderErrorKind.UnknownTables);          return false;        }
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ReadMetadataTableInformation,The following statement contains a magic number: if (this.MetadataStreamKind == MetadataStreamKind.Compressed && (presentTables & (ulong)TableMask.CompressedStreamNotAllowedMask) != 0) {          this.ErrorContainer.AddMetadataStreamError(this.MetadataStreamName' 8' MetadataReaderErrorKind.IllegalTablesInCompressedMetadataStream);          return false;        }
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ReadMetadataTableInformation,The following statement contains a magic number: if ((requiredSortedTables & (ulong)this.MetadataTableHeader.SortedTables) != requiredSortedTables) {          this.ErrorContainer.AddMetadataStreamError(this.MetadataStreamName' 16' MetadataReaderErrorKind.SomeRequiredTablesNotSorted);          //Carry on regardless. There are/were compiler out there that sort the required tables' but fail to set the bit in SortedTables.        }
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ComputeCodedTokenSize,The following statement contains a magic number: return isAllReferencedTablesSmall ? 2 : 4;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ComputeCodedTokenSize,The following statement contains a magic number: return isAllReferencedTablesSmall ? 2 : 4;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The following statement contains a magic number: for (int tableIndex = 0' arrayIndex = 0; tableIndex < (int)TableIndices.Count; tableIndex++) {          if ((validTables & 0x0000000000000001UL) != 0) {            uint rowCount = rowCountCompressedArray[arrayIndex++];            rowCountArray[tableIndex] = rowCount;            rowRefSizeArray[tableIndex] = rowCount < MetadataStreamConstants.LargeTableRowCount ? 2 : 4;          } else {            rowRefSizeArray[tableIndex] = 2;          }          validTables >>= 1;        }
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The following statement contains a magic number: for (int tableIndex = 0' arrayIndex = 0; tableIndex < (int)TableIndices.Count; tableIndex++) {          if ((validTables & 0x0000000000000001UL) != 0) {            uint rowCount = rowCountCompressedArray[arrayIndex++];            rowCountArray[tableIndex] = rowCount;            rowRefSizeArray[tableIndex] = rowCount < MetadataStreamConstants.LargeTableRowCount ? 2 : 4;          } else {            rowRefSizeArray[tableIndex] = 2;          }          validTables >>= 1;        }
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The following statement contains a magic number: for (int tableIndex = 0' arrayIndex = 0; tableIndex < (int)TableIndices.Count; tableIndex++) {          if ((validTables & 0x0000000000000001UL) != 0) {            uint rowCount = rowCountCompressedArray[arrayIndex++];            rowCountArray[tableIndex] = rowCount;            rowRefSizeArray[tableIndex] = rowCount < MetadataStreamConstants.LargeTableRowCount ? 2 : 4;          } else {            rowRefSizeArray[tableIndex] = 2;          }          validTables >>= 1;        }
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The following statement contains a magic number: int fieldRefSize = rowRefSizeArray[(int)TableIndices.FieldPtr] > 2 ? 4 : rowRefSizeArray[(int)TableIndices.Field];
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The following statement contains a magic number: int fieldRefSize = rowRefSizeArray[(int)TableIndices.FieldPtr] > 2 ? 4 : rowRefSizeArray[(int)TableIndices.Field];
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The following statement contains a magic number: int methodRefSize = rowRefSizeArray[(int)TableIndices.MethodPtr] > 2 ? 4 : rowRefSizeArray[(int)TableIndices.Method];
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The following statement contains a magic number: int methodRefSize = rowRefSizeArray[(int)TableIndices.MethodPtr] > 2 ? 4 : rowRefSizeArray[(int)TableIndices.Method];
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The following statement contains a magic number: int paramRefSize = rowRefSizeArray[(int)TableIndices.ParamPtr] > 2 ? 4 : rowRefSizeArray[(int)TableIndices.Param];
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The following statement contains a magic number: int paramRefSize = rowRefSizeArray[(int)TableIndices.ParamPtr] > 2 ? 4 : rowRefSizeArray[(int)TableIndices.Param];
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The following statement contains a magic number: int eventRefSize = rowRefSizeArray[(int)TableIndices.EventPtr] > 2 ? 4 : rowRefSizeArray[(int)TableIndices.Event];
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The following statement contains a magic number: int eventRefSize = rowRefSizeArray[(int)TableIndices.EventPtr] > 2 ? 4 : rowRefSizeArray[(int)TableIndices.Event];
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The following statement contains a magic number: int propertyRefSize = rowRefSizeArray[(int)TableIndices.PropertyPtr] > 2 ? 4 : rowRefSizeArray[(int)TableIndices.Property];
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The following statement contains a magic number: int propertyRefSize = rowRefSizeArray[(int)TableIndices.PropertyPtr] > 2 ? 4 : rowRefSizeArray[(int)TableIndices.Property];
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The following statement contains a magic number: int stringHeapRefSize = (this.MetadataTableHeader.HeapSizeFlags & HeapSizeFlag.StringHeapLarge) == HeapSizeFlag.StringHeapLarge ? 4 : 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The following statement contains a magic number: int stringHeapRefSize = (this.MetadataTableHeader.HeapSizeFlags & HeapSizeFlag.StringHeapLarge) == HeapSizeFlag.StringHeapLarge ? 4 : 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The following statement contains a magic number: int guidHeapRefSize = (this.MetadataTableHeader.HeapSizeFlags & HeapSizeFlag.GUIDHeapLarge) == HeapSizeFlag.GUIDHeapLarge ? 4 : 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The following statement contains a magic number: int guidHeapRefSize = (this.MetadataTableHeader.HeapSizeFlags & HeapSizeFlag.GUIDHeapLarge) == HeapSizeFlag.GUIDHeapLarge ? 4 : 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The following statement contains a magic number: int blobHeapRefSize = (this.MetadataTableHeader.HeapSizeFlags & HeapSizeFlag.BlobHeapLarge) == HeapSizeFlag.BlobHeapLarge ? 4 : 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The following statement contains a magic number: int blobHeapRefSize = (this.MetadataTableHeader.HeapSizeFlags & HeapSizeFlag.BlobHeapLarge) == HeapSizeFlag.BlobHeapLarge ? 4 : 2;
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,GetMethodIL,The following statement contains a magic number: if ((headByte & CILMethodFlags.ILFormatMask) == CILMethodFlags.ILTinyFormat) {          int size = headByte >> CILMethodFlags.ILTinyFormatSizeShift;          return new MethodIL(            true'            8'            0x00000000'            memReader.GetMemoryBlockAt(0' size)'            null          );        } else if ((headByte & CILMethodFlags.ILFormatMask) != CILMethodFlags.ILFatFormat) {          //  PEFileFormat Error...          return null;        }
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,GetMethodIL,The following statement contains a magic number: if (moreSectsPresent) {          memReader.SkipBytes(codeSize);          memReader.Align(4);          byte sectHeader = memReader.ReadByte();          if ((sectHeader & CILMethodFlags.SectEHTable) != CILMethodFlags.SectEHTable) {            //  PEFile Format Error...            return null;          }          bool sectFatFormat = (sectHeader & CILMethodFlags.SectFatFormat) == CILMethodFlags.SectFatFormat;          int dataSize = memReader.ReadByte();          if (sectFatFormat) {            dataSize += (int)memReader.ReadUInt16() << 8;            sehTableEntries = PEFileReader.GetFatSEHEntries(memReader' dataSize / 24);          } else {            memReader.SkipBytes(2); //skip over reserved field            sehTableEntries = PEFileReader.GetSmallSEHEntries(memReader' dataSize / 12);          }        }
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,GetMethodIL,The following statement contains a magic number: if (moreSectsPresent) {          memReader.SkipBytes(codeSize);          memReader.Align(4);          byte sectHeader = memReader.ReadByte();          if ((sectHeader & CILMethodFlags.SectEHTable) != CILMethodFlags.SectEHTable) {            //  PEFile Format Error...            return null;          }          bool sectFatFormat = (sectHeader & CILMethodFlags.SectFatFormat) == CILMethodFlags.SectFatFormat;          int dataSize = memReader.ReadByte();          if (sectFatFormat) {            dataSize += (int)memReader.ReadUInt16() << 8;            sehTableEntries = PEFileReader.GetFatSEHEntries(memReader' dataSize / 24);          } else {            memReader.SkipBytes(2); //skip over reserved field            sehTableEntries = PEFileReader.GetSmallSEHEntries(memReader' dataSize / 12);          }        }
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,GetMethodIL,The following statement contains a magic number: if (moreSectsPresent) {          memReader.SkipBytes(codeSize);          memReader.Align(4);          byte sectHeader = memReader.ReadByte();          if ((sectHeader & CILMethodFlags.SectEHTable) != CILMethodFlags.SectEHTable) {            //  PEFile Format Error...            return null;          }          bool sectFatFormat = (sectHeader & CILMethodFlags.SectFatFormat) == CILMethodFlags.SectFatFormat;          int dataSize = memReader.ReadByte();          if (sectFatFormat) {            dataSize += (int)memReader.ReadUInt16() << 8;            sehTableEntries = PEFileReader.GetFatSEHEntries(memReader' dataSize / 24);          } else {            memReader.SkipBytes(2); //skip over reserved field            sehTableEntries = PEFileReader.GetSmallSEHEntries(memReader' dataSize / 12);          }        }
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,GetMethodIL,The following statement contains a magic number: if (moreSectsPresent) {          memReader.SkipBytes(codeSize);          memReader.Align(4);          byte sectHeader = memReader.ReadByte();          if ((sectHeader & CILMethodFlags.SectEHTable) != CILMethodFlags.SectEHTable) {            //  PEFile Format Error...            return null;          }          bool sectFatFormat = (sectHeader & CILMethodFlags.SectFatFormat) == CILMethodFlags.SectFatFormat;          int dataSize = memReader.ReadByte();          if (sectFatFormat) {            dataSize += (int)memReader.ReadUInt16() << 8;            sehTableEntries = PEFileReader.GetFatSEHEntries(memReader' dataSize / 24);          } else {            memReader.SkipBytes(2); //skip over reserved field            sehTableEntries = PEFileReader.GetSmallSEHEntries(memReader' dataSize / 12);          }        }
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileReader.cs,GetMethodIL,The following statement contains a magic number: if (moreSectsPresent) {          memReader.SkipBytes(codeSize);          memReader.Align(4);          byte sectHeader = memReader.ReadByte();          if ((sectHeader & CILMethodFlags.SectEHTable) != CILMethodFlags.SectEHTable) {            //  PEFile Format Error...            return null;          }          bool sectFatFormat = (sectHeader & CILMethodFlags.SectFatFormat) == CILMethodFlags.SectFatFormat;          int dataSize = memReader.ReadByte();          if (sectFatFormat) {            dataSize += (int)memReader.ReadUInt16() << 8;            sehTableEntries = PEFileReader.GetFatSEHEntries(memReader' dataSize / 24);          } else {            memReader.SkipBytes(2); //skip over reserved field            sehTableEntries = PEFileReader.GetSmallSEHEntries(memReader' dataSize / 12);          }        }
Duplicate Code,Microsoft.Cci.MetadataReader,ILReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\ILReader.cs,PopulateCilInstructions,The method contains a code clone-set at the following line numbers (starting from the method definition): ((75' 97)' (200' 222))
Duplicate Code,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\ILReader.cs,PopulateCilInstructions,The method contains a code clone-set at the following line numbers (starting from the method definition): ((75' 97)' (200' 222))
Missing Default,Microsoft.Cci.MetadataReader.ObjectModelImplementation,AttributeDecoder,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,GetPrimitiveValue,The following switch statement is missing a default case: switch (type.SignatureTypeCode) {          case ModuleSignatureTypeCode.SByte:            if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (sbyte)0;            }            return this.SignatureMemoryReader.ReadSByte();          case ModuleSignatureTypeCode.Int16:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (short)0;            }            return this.SignatureMemoryReader.ReadInt16();          case ModuleSignatureTypeCode.Int32:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (int)0;            }            return this.SignatureMemoryReader.ReadInt32();          case ModuleSignatureTypeCode.Int64:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (long)0;            }            return this.SignatureMemoryReader.ReadInt64();          case ModuleSignatureTypeCode.Byte:            if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (byte)0;            }            return this.SignatureMemoryReader.ReadByte();          case ModuleSignatureTypeCode.UInt16:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (ushort)0;            }            return this.SignatureMemoryReader.ReadUInt16();          case ModuleSignatureTypeCode.UInt32:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (uint)0;            }            return this.SignatureMemoryReader.ReadUInt32();          case ModuleSignatureTypeCode.UInt64:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (ulong)0;            }            return this.SignatureMemoryReader.ReadUInt64();          case ModuleSignatureTypeCode.Single:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (float)0;            }            return this.SignatureMemoryReader.ReadSingle();          case ModuleSignatureTypeCode.Double:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (double)0;            }            return this.SignatureMemoryReader.ReadDouble();          case ModuleSignatureTypeCode.Boolean: {              if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {                this.decodeFailed = true;                return false;              }              byte val = this.SignatureMemoryReader.ReadByte();              return val == 1;            }          case ModuleSignatureTypeCode.Char:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (char)0;            }            return this.SignatureMemoryReader.ReadChar();        }
Missing Default,Microsoft.Cci.MetadataReader.ObjectModelImplementation,AttributeDecoder,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,GetFieldOrPropType,The following switch statement is missing a default case: switch (elementByte) {          case SerializationType.Boolean:            return this.PEFileToObjectModel.SystemBoolean;          case SerializationType.Char:            return this.PEFileToObjectModel.SystemChar;          case SerializationType.Int8:            return this.PEFileToObjectModel.SystemSByte;          case SerializationType.UInt8:            return this.PEFileToObjectModel.SystemByte;          case SerializationType.Int16:            return this.PEFileToObjectModel.SystemInt16;          case SerializationType.UInt16:            return this.PEFileToObjectModel.SystemUInt16;          case SerializationType.Int32:            return this.PEFileToObjectModel.SystemInt32;          case SerializationType.UInt32:            return this.PEFileToObjectModel.SystemUInt32;          case SerializationType.Int64:            return this.PEFileToObjectModel.SystemInt64;          case SerializationType.UInt64:            return this.PEFileToObjectModel.SystemUInt64;          case SerializationType.Single:            return this.PEFileToObjectModel.SystemSingle;          case SerializationType.Double:            return this.PEFileToObjectModel.SystemDouble;          case SerializationType.String:            return this.PEFileToObjectModel.SystemString;          case SerializationType.SZArray: {              IModuleTypeReference/*?*/ elementType = this.GetFieldOrPropType();              if (elementType == null)                return null;              return new VectorType(this.PEFileToObjectModel' 0xFFFFFFFF' elementType);            }          case SerializationType.Type:            return this.PEFileToObjectModel.SystemType;          case SerializationType.TaggedObject:            return this.PEFileToObjectModel.SystemObject;          case SerializationType.Enum: {              string/*?*/ typeName = this.GetSerializedString();              if (typeName == null)                return null;              TypeNameTypeReference/*?*/ result = (TypeNameTypeReference)this.PEFileToObjectModel.GetSerializedTypeNameAsTypeReference(typeName);              if (result != null) result.IsEnum = true;              return result;            }        }
Missing Default,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NonGenericNamespaceTypeWithPrimitiveType,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Types.cs,ToString,The following switch statement is missing a default case: switch (this.signatureTypeCode) {          case ModuleSignatureTypeCode.Boolean: return "System.Boolean";          case ModuleSignatureTypeCode.Byte: return "System.Byte";          case ModuleSignatureTypeCode.Char: return "System.Char";          case ModuleSignatureTypeCode.Double: return "System.Double";          case ModuleSignatureTypeCode.Int16: return "System.Int16";          case ModuleSignatureTypeCode.Int32: return "System.Int32";          case ModuleSignatureTypeCode.Int64: return "System.Int64";          case ModuleSignatureTypeCode.IntPtr: return "System.IntPtr";          case ModuleSignatureTypeCode.Object: return "System.Object";          case ModuleSignatureTypeCode.SByte: return "System.SByte";          case ModuleSignatureTypeCode.Single: return "System.Single";          case ModuleSignatureTypeCode.String: return "System.String";          case ModuleSignatureTypeCode.TypedReference: return "System.TypedReference";          case ModuleSignatureTypeCode.UInt16: return "System.UInt16";          case ModuleSignatureTypeCode.UInt32: return "System.UInt32";          case ModuleSignatureTypeCode.UInt64: return "System.UInt64";          case ModuleSignatureTypeCode.UIntPtr: return "System.UIntPtr";          case ModuleSignatureTypeCode.Void: return "System.Void";        }
Missing Default,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,GetPrimitiveValue,The following switch statement is missing a default case: switch (type.SignatureTypeCode) {          case ModuleSignatureTypeCode.SByte:            if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (sbyte)0;            }            return this.SignatureMemoryReader.ReadSByte();          case ModuleSignatureTypeCode.Int16:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (short)0;            }            return this.SignatureMemoryReader.ReadInt16();          case ModuleSignatureTypeCode.Int32:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (int)0;            }            return this.SignatureMemoryReader.ReadInt32();          case ModuleSignatureTypeCode.Int64:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (long)0;            }            return this.SignatureMemoryReader.ReadInt64();          case ModuleSignatureTypeCode.Byte:            if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (byte)0;            }            return this.SignatureMemoryReader.ReadByte();          case ModuleSignatureTypeCode.UInt16:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (ushort)0;            }            return this.SignatureMemoryReader.ReadUInt16();          case ModuleSignatureTypeCode.UInt32:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (uint)0;            }            return this.SignatureMemoryReader.ReadUInt32();          case ModuleSignatureTypeCode.UInt64:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (ulong)0;            }            return this.SignatureMemoryReader.ReadUInt64();          case ModuleSignatureTypeCode.Single:            if (this.SignatureMemoryReader.Offset+4 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (float)0;            }            return this.SignatureMemoryReader.ReadSingle();          case ModuleSignatureTypeCode.Double:            if (this.SignatureMemoryReader.Offset+8 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (double)0;            }            return this.SignatureMemoryReader.ReadDouble();          case ModuleSignatureTypeCode.Boolean: {              if (this.SignatureMemoryReader.Offset+1 > this.SignatureMemoryReader.Length) {                this.decodeFailed = true;                return false;              }              byte val = this.SignatureMemoryReader.ReadByte();              return val == 1;            }          case ModuleSignatureTypeCode.Char:            if (this.SignatureMemoryReader.Offset+2 > this.SignatureMemoryReader.Length) {              this.decodeFailed = true;              return (char)0;            }            return this.SignatureMemoryReader.ReadChar();        }
Missing Default,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\Attributes.cs,GetFieldOrPropType,The following switch statement is missing a default case: switch (elementByte) {          case SerializationType.Boolean:            return this.PEFileToObjectModel.SystemBoolean;          case SerializationType.Char:            return this.PEFileToObjectModel.SystemChar;          case SerializationType.Int8:            return this.PEFileToObjectModel.SystemSByte;          case SerializationType.UInt8:            return this.PEFileToObjectModel.SystemByte;          case SerializationType.Int16:            return this.PEFileToObjectModel.SystemInt16;          case SerializationType.UInt16:            return this.PEFileToObjectModel.SystemUInt16;          case SerializationType.Int32:            return this.PEFileToObjectModel.SystemInt32;          case SerializationType.UInt32:            return this.PEFileToObjectModel.SystemUInt32;          case SerializationType.Int64:            return this.PEFileToObjectModel.SystemInt64;          case SerializationType.UInt64:            return this.PEFileToObjectModel.SystemUInt64;          case SerializationType.Single:            return this.PEFileToObjectModel.SystemSingle;          case SerializationType.Double:            return this.PEFileToObjectModel.SystemDouble;          case SerializationType.String:            return this.PEFileToObjectModel.SystemString;          case SerializationType.SZArray: {              IModuleTypeReference/*?*/ elementType = this.GetFieldOrPropType();              if (elementType == null)                return null;              return new VectorType(this.PEFileToObjectModel' 0xFFFFFFFF' elementType);            }          case SerializationType.Type:            return this.PEFileToObjectModel.SystemType;          case SerializationType.TaggedObject:            return this.PEFileToObjectModel.SystemObject;          case SerializationType.Enum: {              string/*?*/ typeName = this.GetSerializedString();              if (typeName == null)                return null;              TypeNameTypeReference/*?*/ result = (TypeNameTypeReference)this.PEFileToObjectModel.GetSerializedTypeNameAsTypeReference(typeName);              if (result != null) result.IsEnum = true;              return result;            }        }
Missing Default,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetTypeReferenceForToken,The following switch statement is missing a default case: switch (tokenType) {          case TokenTypeIds.TypeDef: {              if (rowId == 0 || rowId > this.PEFileReader.TypeDefTable.NumberOfRows) {                //  handle Error              }              return this.GetTypeDefinitionAtRow(rowId);            }          case TokenTypeIds.TypeRef: {              if (rowId == 0 || rowId > this.PEFileReader.TypeRefTable.NumberOfRows) {                //  handle Error              }              return this.GetTypeRefReferenceAtRow(rowId' mustBeStruct);            }          case TokenTypeIds.TypeSpec: {              if (rowId == 0 || rowId > this.PEFileReader.TypeSpecTable.NumberOfRows) {                //  handle Error              }              return this.GetTypeSpecReferenceAtRow(owningObject' rowId).UnderlyingModuleTypeReference;            }        }
Missing Default,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,FindExportedType,The following switch statement is missing a default case: switch (tokenType) {          case TokenTypeIds.File: {              FileReference/*?*/ fileRef = this.GetFileReferenceAt(rowId);              if (fileRef == null) {                return null;              }              Module/*?*/ module =thisAssembly.FindMemberModuleNamed(fileRef.Name);              if (module == null) {                return null;              }              TypeBase/*?*/ foundType = module.PEFileToObjectModel.ResolveNamespaceTypeDefinition(namespaceName' typeName);              if (foundType == null) {                return null;              }              return foundType;            }          case TokenTypeIds.ExportedType: {              ExportedTypeAliasBase/*?*/ parentExportedType = this.GetExportedTypeAtRowWorker(rowId);              if (parentExportedType == null) {                return null;              }              IModuleTypeReference/*?*/ parentModuleType = this.FindExportedType(parentExportedType);              if (parentModuleType == null) {                return null;              }              ITypeDefinition parentType = parentModuleType.ResolvedType;              if (parentType != Dummy.Type) {                foreach (ITypeDefinitionMember tdm in parentModuleType.ResolvedType.GetMembersNamed(typeName' false)) {                  IModuleTypeReference/*?*/ modTypeRef = tdm as IModuleTypeReference;                  if (modTypeRef != null)                    return modTypeRef;                }              } else {                NamespaceTypeNameTypeReference/*?*/ nstr = parentModuleType as NamespaceTypeNameTypeReference;                if (nstr != null) {                  var nestedTypeName = new NestedTypeName(this.NameTable' nstr.NamespaceTypeName' typeName);                  return nestedTypeName.GetAsTypeReference(this' nstr.Module);                }                NestedTypeNameTypeReference/*?*/ netr = parentModuleType as NestedTypeNameTypeReference;                if (netr != null) {                  var nestedTypeName = new NestedTypeName(this.NameTable' netr.NestedTypeName' typeName);                  return nestedTypeName.GetAsTypeReference(this' netr.Module);                }              }              return null;            }          case TokenTypeIds.AssemblyRef: {              AssemblyReference/*?*/ assemRef = this.GetAssemblyReferenceAt(rowId);              if (assemRef == null) {                return null;              }              var internalAssembly = assemRef.ResolvedAssembly as Assembly;              if (internalAssembly != null) {                PEFileToObjectModel assemblyPEFileToObjectModel = internalAssembly.PEFileToObjectModel;                TypeBase/*?*/ type = assemblyPEFileToObjectModel.ResolveNamespaceTypeDefinition(namespaceName' typeName);                if (type != null)                  return type;                ExportedTypeAliasBase/*?*/ aliasType = assemblyPEFileToObjectModel.ResolveExportedNamespaceType(namespaceName' typeName);                if (aliasType != null && aliasType != aliasAliasBase) {                  return assemblyPEFileToObjectModel.FindExportedType(aliasType);                }              } else {                string fullTypeName = typeName.Value;                if (namespaceName.Value.Length > 0)                  fullTypeName = namespaceName.Value+"."+typeName.Value;                var parser = new TypeNameParser(this.NameTable' fullTypeName);                return parser.ParseTypeName().GetAsTypeReference(this' assemRef);              }            }            break;        }
Missing Default,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetFieldMapping,The following switch statement is missing a default case: switch (this.PEFileReader.RVAToSubSectionName(rva)) {          case ".text": sectionKind = PESectionKind.Text; break;          case ".sdata": sectionKind = PESectionKind.StaticData; break;          case ".tls": sectionKind = PESectionKind.ThreadLocalStorage; break;          case ".rdata": sectionKind = PESectionKind.ConstantData; break;          case ".cover": sectionKind = PESectionKind.CoverageData; break;        }
Missing Default,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetFieldSizeIfPossibleToDoSoWithoutResolving,The following switch statement is missing a default case: switch (typeReference.TypeCode) {          case PrimitiveTypeCode.Boolean:            return sizeof(Boolean);          case PrimitiveTypeCode.Char:            return sizeof(Char);          case PrimitiveTypeCode.Int16:            return sizeof(Int16);          case PrimitiveTypeCode.Int32:            return sizeof(Int32);          case PrimitiveTypeCode.Int8:            return sizeof(SByte);          case PrimitiveTypeCode.UInt16:            return sizeof(UInt16);          case PrimitiveTypeCode.UInt32:            return sizeof(UInt32);          case PrimitiveTypeCode.UInt8:            return sizeof(Byte);          case PrimitiveTypeCode.Int64:            return sizeof(Int64);          case PrimitiveTypeCode.UInt64:            return sizeof(UInt64);          case PrimitiveTypeCode.IntPtr:            return this.pointerSize;          case PrimitiveTypeCode.UIntPtr:            return this.pointerSize;          case PrimitiveTypeCode.Float32:            return sizeof(Single);          case PrimitiveTypeCode.Float64:            return sizeof(Double);          case PrimitiveTypeCode.Pointer:            return this.pointerSize;        }
Missing Default,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetDefaultValue,The following switch statement is missing a default case: switch (constRow.Type) {          case ElementType.Boolean: {              byte val = memoryReader.ReadByte();              return new ConstantExpression(this.SystemBoolean' val != 0);            }          case ElementType.Char:            return new ConstantExpression(this.SystemChar' memoryReader.ReadChar());          case ElementType.Int8:            return new ConstantExpression(this.SystemSByte' memoryReader.ReadSByte());          case ElementType.Int16:            return new ConstantExpression(this.SystemInt16' memoryReader.ReadInt16());          case ElementType.Int32:            return new ConstantExpression(this.SystemInt32' memoryReader.ReadInt32());          case ElementType.Int64:            return new ConstantExpression(this.SystemInt64' memoryReader.ReadInt64());          case ElementType.UInt8:            return new ConstantExpression(this.SystemByte' memoryReader.ReadByte());          case ElementType.UInt16:            return new ConstantExpression(this.SystemUInt16' memoryReader.ReadUInt16());          case ElementType.UInt32:            return new ConstantExpression(this.SystemUInt32' memoryReader.ReadUInt32());          case ElementType.UInt64:            return new ConstantExpression(this.SystemUInt64' memoryReader.ReadUInt64());          case ElementType.Single:            return new ConstantExpression(this.SystemSingle' memoryReader.ReadSingle());          case ElementType.Double:            return new ConstantExpression(this.SystemDouble' memoryReader.ReadDouble());          case ElementType.String: {              int byteLen = memoryReader.Length;              string/*?*/ value;              if (byteLen == -1) {                value = null;              } else if (byteLen == 0) {                value = string.Empty;              } else {                value = memoryReader.ReadUTF16WithSize(byteLen);              }              return new ConstantExpression(this.SystemString' value);            }          case ElementType.Class:            return new ConstantExpression(this.SystemObject' null);        }
Missing Default,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileToObjectModel.cs,GetMethodReferenceForToken,The following switch statement is missing a default case: switch (tokenKind) {          case TokenTypeIds.MethodDef:            methRef = this.GetMethodDefAtRow(rowId);            break;          case TokenTypeIds.MethodSpec:            methRef = this.GetMethodSpecAtRow(owningObject' rowId);            break;          case TokenTypeIds.MemberRef:            methRef = this.GetModuleMemberReferenceAtRow(owningObject' rowId) as IMethodReference;            break;        }
Missing Default,Microsoft.Cci.MetadataReader.PEFileFlags,HasCustomAttributeTag,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,ConvertToTag,The following switch statement is missing a default case: switch (tokenType) {          case TokenTypeIds.MethodDef:            return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.Method;          case TokenTypeIds.FieldDef:            return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.Field;          case TokenTypeIds.TypeRef:            return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.TypeRef;          case TokenTypeIds.TypeDef:            return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.TypeDef;          case TokenTypeIds.ParamDef:            return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.Param;          case TokenTypeIds.InterfaceImpl:            return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.InterfaceImpl;          case TokenTypeIds.MemberRef:            return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.MemberRef;          case TokenTypeIds.Module:            return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.Module;          case TokenTypeIds.Permission:            return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.DeclSecurity;          case TokenTypeIds.Property:            return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.Property;          case TokenTypeIds.Event:            return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.Event;          case TokenTypeIds.Signature:            return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.StandAloneSig;          case TokenTypeIds.ModuleRef:            return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.ModuleRef;          case TokenTypeIds.TypeSpec:            return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.TypeSpec;          case TokenTypeIds.Assembly:            return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.Assembly;          case TokenTypeIds.AssemblyRef:            return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.AssemblyRef;          case TokenTypeIds.File:            return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.File;          case TokenTypeIds.ExportedType:            return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.ExportedType;          case TokenTypeIds.ManifestResource:            return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.ManifestResource;          case TokenTypeIds.GenericParam:            return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.GenericParameter;        }
Missing Default,Microsoft.Cci.MetadataReader.PEFile,HasCustomAttributeTag,C:\repos\Reactive-Extensions_IL2JS\CCI2\PeReader\PEFileStructures.cs,ConvertToTag,The following switch statement is missing a default case: switch (tokenType) {          case TokenTypeIds.MethodDef:            return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.Method;          case TokenTypeIds.FieldDef:            return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.Field;          case TokenTypeIds.TypeRef:            return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.TypeRef;          case TokenTypeIds.TypeDef:            return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.TypeDef;          case TokenTypeIds.ParamDef:            return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.Param;          case TokenTypeIds.InterfaceImpl:            return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.InterfaceImpl;          case TokenTypeIds.MemberRef:            return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.MemberRef;          case TokenTypeIds.Module:            return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.Module;          case TokenTypeIds.Permission:            return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.DeclSecurity;          case TokenTypeIds.Property:            return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.Property;          case TokenTypeIds.Event:            return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.Event;          case TokenTypeIds.Signature:            return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.StandAloneSig;          case TokenTypeIds.ModuleRef:            return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.ModuleRef;          case TokenTypeIds.TypeSpec:            return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.TypeSpec;          case TokenTypeIds.Assembly:            return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.Assembly;          case TokenTypeIds.AssemblyRef:            return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.AssemblyRef;          case TokenTypeIds.File:            return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.File;          case TokenTypeIds.ExportedType:            return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.ExportedType;          case TokenTypeIds.ManifestResource:            return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.ManifestResource;          case TokenTypeIds.GenericParam:            return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.GenericParameter;        }
