Implementation smell,Namespace,Class,File,Method,Description
Long Method,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,BasicBlockFromIndex,The method has 224 lines of code.
Long Method,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceBranch,The method has 368 lines of code.
Long Method,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceSwitch,The method has 122 lines of code.
Long Method,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceLooping,The method has 153 lines of code.
Long Method,Microsoft.LiveLabs.CST,Global,C:\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,Global,The method has 323 lines of code.
Long Method,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The method has 697 lines of code.
Long Method,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The method has 506 lines of code.
Long Method,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,BackwardInstruction,The method has 146 lines of code.
Long Method,Microsoft.LiveLabs.CST,Peephole,C:\repos\Reactive-Extensions_IL2JS\CST\Peephole.cs,MoveNext,The method has 131 lines of code.
Long Method,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,MethodDefFromRow,The method has 154 lines of code.
Long Method,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The method has 255 lines of code.
Long Method,Microsoft.LiveLabs.CST,ValidityContext,C:\repos\Reactive-Extensions_IL2JS\CST\Validity.cs,Check,The method has 231 lines of code.
Long Method,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The method has 545 lines of code.
Long Method,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,CaseBody,The method has 137 lines of code.
Complex Method,Microsoft.LiveLabs.CST,Test,C:\repos\Reactive-Extensions_IL2JS\CST\BasicBlock.cs,FromBranchOp,Cyclomatic complexity of the method is 29
Complex Method,Microsoft.LiveLabs.CST,Test,C:\repos\Reactive-Extensions_IL2JS\CST\BasicBlock.cs,FromCompareOp,Cyclomatic complexity of the method is 26
Complex Method,Microsoft.LiveLabs.CST,Test,C:\repos\Reactive-Extensions_IL2JS\CST\BasicBlock.cs,Negate,Cyclomatic complexity of the method is 26
Complex Method,Microsoft.LiveLabs.CST,Test,C:\repos\Reactive-Extensions_IL2JS\CST\BasicBlock.cs,ToCompareInstruction,Cyclomatic complexity of the method is 26
Complex Method,Microsoft.LiveLabs.CST,Test,C:\repos\Reactive-Extensions_IL2JS\CST\BasicBlock.cs,Append,Cyclomatic complexity of the method is 41
Complex Method,Microsoft.LiveLabs.CST,BasicBlock,C:\repos\Reactive-Extensions_IL2JS\CST\BasicBlock.cs,CoalesceFrom,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.LiveLabs.CST,BasicBlock,C:\repos\Reactive-Extensions_IL2JS\CST\BasicBlock.cs,DeleteFrom,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.LiveLabs.CST,BBLoop,C:\repos\Reactive-Extensions_IL2JS\CST\BasicBlockUtils.cs,BBLoop,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.LiveLabs.CST,BBLoop,C:\repos\Reactive-Extensions_IL2JS\CST\BasicBlockUtils.cs,Append,Cyclomatic complexity of the method is 23
Complex Method,Microsoft.LiveLabs.CST,BasicBlockUtils,C:\repos\Reactive-Extensions_IL2JS\CST\BasicBlockUtils.cs,Dominators,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.LiveLabs.CST,VariableCell,C:\repos\Reactive-Extensions_IL2JS\CST\Cell.cs,AccumEffects,Cyclomatic complexity of the method is 21
Complex Method,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,BuildTargetsFrom,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,BasicBlockFromIndex,Cyclomatic complexity of the method is 78
Complex Method,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceJump,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceBranch,Cyclomatic complexity of the method is 36
Complex Method,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceSwitch,Cyclomatic complexity of the method is 19
Complex Method,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceNonLooping,Cyclomatic complexity of the method is 32
Complex Method,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceLooping,Cyclomatic complexity of the method is 86
Complex Method,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,Reduce,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.LiveLabs.CST,PointsTo,C:\repos\Reactive-Extensions_IL2JS\CST\Domain.cs,Append,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.CST,Effects,C:\repos\Reactive-Extensions_IL2JS\CST\Domain.cs,Append,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.LiveLabs.CST,Global,C:\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,CodePointerDef,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.CST,MethodEnvironment,C:\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,SubstituteParameter,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.LiveLabs.CST,UnaryExpression,C:\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,Type,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.LiveLabs.CST,UnaryExpression,C:\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,IsCondition,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.LiveLabs.CST,UnaryExpression,C:\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,Simplify,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.LiveLabs.CST,UnaryExpression,C:\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,SimplifyLogNot,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.LiveLabs.CST,UnaryExpression,C:\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,GetHashCode,Cyclomatic complexity of the method is 31
Complex Method,Microsoft.LiveLabs.CST,BinaryExpression,C:\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,Type,Cyclomatic complexity of the method is 20
Complex Method,Microsoft.LiveLabs.CST,BinaryExpression,C:\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,IsCondition,Cyclomatic complexity of the method is 20
Complex Method,Microsoft.LiveLabs.CST,BinaryExpression,C:\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,CanAbsorbLogNot,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.CST,BinaryExpression,C:\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,SimplifyLogNot,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.LiveLabs.CST,BinaryExpression,C:\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,GetHashCode,Cyclomatic complexity of the method is 58
Complex Method,Microsoft.LiveLabs.CST,CallExpression,C:\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,Simplify,Cyclomatic complexity of the method is 28
Complex Method,Microsoft.LiveLabs.CST,CallExpression,C:\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,Append,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.LiveLabs.CST,CallExpression,C:\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,GetHashCode,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.LiveLabs.CST,UnsupportedInstruction,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,AppendBody,Cyclomatic complexity of the method is 32
Complex Method,Microsoft.LiveLabs.CST,MiscInstruction,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,IsInlinable,Cyclomatic complexity of the method is 20
Complex Method,Microsoft.LiveLabs.CST,MiscInstruction,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,AppendBody,Cyclomatic complexity of the method is 53
Complex Method,Microsoft.LiveLabs.CST,BranchInstruction,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,IsInlinable,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.LiveLabs.CST,BranchInstruction,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,AppendBody,Cyclomatic complexity of the method is 50
Complex Method,Microsoft.LiveLabs.CST,CompareInstruction,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,AppendBody,Cyclomatic complexity of the method is 36
Complex Method,Microsoft.LiveLabs.CST,ArgLocalInstruction,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,AppendBody,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.LiveLabs.CST,FieldInstruction,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,AppendBody,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.LiveLabs.CST,MethodInstruction,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,CheckValid,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.CST,MethodInstruction,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,AppendBody,Cyclomatic complexity of the method is 23
Complex Method,Microsoft.LiveLabs.CST,TypeInstruction,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,AppendBody,Cyclomatic complexity of the method is 41
Complex Method,Microsoft.LiveLabs.CST,ArithInstruction,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,AppendBody,Cyclomatic complexity of the method is 65
Complex Method,Microsoft.LiveLabs.CST,ConvInstruction,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,AppendBody,Cyclomatic complexity of the method is 50
Complex Method,Microsoft.LiveLabs.CST,ShortCircuitingInstruction,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,AppendBody,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.LiveLabs.CST,BreakContinueInstruction,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,AppendBody,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,Cyclomatic complexity of the method is 630
Complex Method,Microsoft.LiveLabs.CST,ArgsLocalsState,C:\repos\Reactive-Extensions_IL2JS\CST\MachineState.cs,PropogateBackwards,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.CST,MachineState,C:\repos\Reactive-Extensions_IL2JS\CST\MachineState.cs,PeekDereferencableExpectedType,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,AddEffectiveInstructionTransitions,Cyclomatic complexity of the method is 24
Complex Method,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,Cyclomatic complexity of the method is 216
Complex Method,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,BackwardInstruction,Cyclomatic complexity of the method is 90
Complex Method,Microsoft.LiveLabs.CST,MethodDef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,AccumUsedTypeAndMemberDefs,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.LiveLabs.CST,MethodDef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,CheckValid,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.LiveLabs.CST,MethodDef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,AppendDefinition,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.LiveLabs.CST,MethodDef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,AppendModifiers,Cyclomatic complexity of the method is 30
Complex Method,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,AssemblyName,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.LiveLabs.CST,TypeName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,Append,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.CST,QualifiedTypeName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,Append,Cyclomatic complexity of the method is 17
Complex Method,Microsoft.LiveLabs.CST,Peephole,C:\repos\Reactive-Extensions_IL2JS\CST\Peephole.cs,MoveNext,Cyclomatic complexity of the method is 28
Complex Method,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,AssemblyNameFromResolutionScopeRow,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeRefFromPrimitiveTypeName,Cyclomatic complexity of the method is 21
Complex Method,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeRefFromTypeSig,Cyclomatic complexity of the method is 41
Complex Method,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeRefFromRow,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,DefiningTypeRefFromRow,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,FieldRefFromRow,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,ArgsAndResultFromMethodSig,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,MethodRefFromRowWithTypeArgs,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,MethodRefFromRow,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,PolymorphicMethodRefFromRow,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,SignatureFromRow,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,FieldDefFromRow,Cyclomatic complexity of the method is 28
Complex Method,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,AnnotationFromCallingConvention,Cyclomatic complexity of the method is 20
Complex Method,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,ParameterTypeDefFromRow,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,ResolveRow,Cyclomatic complexity of the method is 17
Complex Method,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,MethodDefFromRow,Cyclomatic complexity of the method is 55
Complex Method,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,Cyclomatic complexity of the method is 87
Complex Method,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,MergeAssemblyDefs,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,PropertyTypeFromTypeRef,Cyclomatic complexity of the method is 18
Complex Method,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,CustomAttributeFromRow,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,LoadCustomAttributes,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.CST,MethodSignature,C:\repos\Reactive-Extensions_IL2JS\CST\Signature.cs,Fixup,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.CST,MethodSignature,C:\repos\Reactive-Extensions_IL2JS\CST\Signature.cs,Append,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.CST,ValidityContext,C:\repos\Reactive-Extensions_IL2JS\CST\Validity.cs,PropogateInvalidity,Cyclomatic complexity of the method is 29
Complex Method,Microsoft.LiveLabs.CST,ValidityContext,C:\repos\Reactive-Extensions_IL2JS\CST\Validity.cs,Stats,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.CST,ValidityContext,C:\repos\Reactive-Extensions_IL2JS\CST\Validity.cs,Check,Cyclomatic complexity of the method is 59
Complex Method,Microsoft.LiveLabs.CST,Variable,C:\repos\Reactive-Extensions_IL2JS\CST\Variable.cs,GetHashCode,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,ArithOpToBinaryOp,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,ArithOpToUnaryOp,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateHandlers,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,Cyclomatic complexity of the method is 196
Complex Method,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,CanInlineBlock,Cyclomatic complexity of the method is 17
Complex Method,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,CaseBody,Cyclomatic complexity of the method is 54
Complex Method,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,Translate,Cyclomatic complexity of the method is 29
Complex Method,Microsoft.LiveLabs.CST,TypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PropogateInvalidity,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.CST,TypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceIsAssignableTo,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.LiveLabs.CST,PointerTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,AppendDefinition,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.LiveLabs.CST,PointerTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,AppendReference,Cyclomatic complexity of the method is 16
Complex Method,Microsoft.LiveLabs.CST,CodePointerTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,AppendDefinition,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.LiveLabs.CST,CodePointerTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,AppendReference,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.LiveLabs.CST,MultiDimArrayTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,MultiDimArrayTypeDef,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.LiveLabs.CST,DerivingTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceRespectsParameterConstraint,Cyclomatic complexity of the method is 18
Complex Method,Microsoft.LiveLabs.CST,ParameterTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceRespectsParameterConstraint,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.LiveLabs.CST,ParameterTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimIsValidParameterBinding,Cyclomatic complexity of the method is 25
Complex Method,Microsoft.LiveLabs.CST,ParameterTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,AppendDefinition,Cyclomatic complexity of the method is 29
Complex Method,Microsoft.LiveLabs.CST,NamedTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,NamedTypeDef,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.LiveLabs.CST,NamedTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,AccumUsedTypeDefs,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.CST,RealTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,CompleteSlotImplementations,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.LiveLabs.CST,EnumTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,EnumTypeDef,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.LiveLabs.CST,ParameterTypeRef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeRef.cs,GetHashCode,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.LiveLabs.CST,ParameterTypeRef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeRef.cs,PrimSubstitute,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.LiveLabs.CST,ParameterTypeRef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeRef.cs,CheckValid,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.LiveLabs.CST,ParameterTypeRef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeRef.cs,Append,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.LiveLabs.CST,NamedTypeRef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeRef.cs,RuntimeFlavor,Cyclomatic complexity of the method is 16
Complex Method,Microsoft.LiveLabs.CST,Usage,C:\repos\Reactive-Extensions_IL2JS\CST\Usage.cs,Merge,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.LiveLabs.CST,Usage,C:\repos\Reactive-Extensions_IL2JS\CST\Usage.cs,Merge,Cyclomatic complexity of the method is 13
Long Parameter List,Microsoft.LiveLabs.CST,AssemblyDef,C:\repos\Reactive-Extensions_IL2JS\CST\AssemblyDef.cs,AssemblyDef,The method has 7 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,LeaveTryBasicBlock,C:\repos\Reactive-Extensions_IL2JS\CST\BasicBlock.cs,LeaveTryBasicBlock,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,LeaveCatchBasicBlock,C:\repos\Reactive-Extensions_IL2JS\CST\BasicBlock.cs,LeaveCatchBasicBlock,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,BreakReduceJump,The method has 6 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,BreakReduceBranch,The method has 6 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,BreakReduceLeaveTry,The method has 6 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,BreakReduceLeaveCatch,The method has 6 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,CSTMethod,C:\repos\Reactive-Extensions_IL2JS\CST\CSTMethod.cs,Translate,The method has 6 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,Effects,C:\repos\Reactive-Extensions_IL2JS\CST\Domain.cs,Effects,The method has 7 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,Effects,C:\repos\Reactive-Extensions_IL2JS\CST\Domain.cs,MakeArgLocal,The method has 6 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,TypeEnvironment,C:\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,TypeEnvironment,The method has 6 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,FieldEnvironment,C:\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,FieldEnvironment,The method has 6 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,EventEnvironment,C:\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,EventEnvironment,The method has 6 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,PropertyEnvironment,C:\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,PropertyEnvironment,The method has 6 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,PolymorphicMethodEnvironment,C:\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,PolymorphicMethodEnvironment,The method has 6 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,MethodEnvironment,C:\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,MethodEnvironment,The method has 8 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,CompilationEnvironment,C:\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,CompilationEnvironment,The method has 10 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,CompilationEnvironment,C:\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,AddVariable,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,BinaryExpression,C:\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,BinaryExpression,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,ExpressionStack,C:\repos\Reactive-Extensions_IL2JS\CST\ExpressionStack.cs,ExpressionStack,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,ExpressionStack,C:\repos\Reactive-Extensions_IL2JS\CST\ExpressionStack.cs,PopEvalPushSE,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,ExpressionStack,C:\repos\Reactive-Extensions_IL2JS\CST\ExpressionStack.cs,PopEvalSE,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,Instruction,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,CalcStackChange,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,Instructions,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,AccumUsedTypeAndMemberDefs,The method has 6 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,Instructions,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,CheckValid,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,MethodInstruction,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,MethodInstruction,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,TryInstruction,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,AccumUsedTypeAndMemberDefs,The method has 6 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,TryInstruction,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,CheckValid,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,StructuralSwitchInstruction,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,AccumUsedTypeAndMemberDefs,The method has 6 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,StructuralSwitchInstruction,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,CheckValid,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,ArgsLocalsState,C:\repos\Reactive-Extensions_IL2JS\CST\MachineState.cs,PropogateBackwards,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,MachineState,C:\repos\Reactive-Extensions_IL2JS\CST\MachineState.cs,Unify,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,BackwardInstruction,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,MemberDef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,TopologicalAllDeps,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,MemberDef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,UsedByMembersClosure,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,MemberDef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,TopologicalTypeInit,The method has 6 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,MemberDef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,TopologicalTypeInitFromImplementors,The method has 6 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,MethodDef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,MethodDef,The method has 15 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,MethodDef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,PrimReference,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,MethodDef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,PrimMethodReference,The method has 6 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,MethodDef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,TopologicalTypeInitFromImplementors,The method has 6 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,FieldDef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,FieldDef,The method has 6 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,EventDef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,EventDef,The method has 7 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,PropertyDef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,PropertyDef,The method has 7 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,PolymorphicMethodRef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberRef.cs,PolymorphicMethodRef,The method has 7 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,PolymorphicMethodRef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberRef.cs,PolymorphicMethodRef,The method has 6 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,MethodRef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberRef.cs,MethodRef,The method has 7 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,MethodRef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberRef.cs,MethodRef,The method has 6 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,MethodRef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberRef.cs,AccumUsedTypeDefs,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,MethodRef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberRef.cs,CheckValid,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,PropertyRef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberRef.cs,PropertyRef,The method has 6 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,PropertyRef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberRef.cs,PropertyRef,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,MessageContextBuilders,C:\repos\Reactive-Extensions_IL2JS\CST\MessageContextBuilders.cs,Type,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,MessageContextBuilders,C:\repos\Reactive-Extensions_IL2JS\CST\MessageContextBuilders.cs,Member,The method has 6 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,MessageContextBuilders,C:\repos\Reactive-Extensions_IL2JS\CST\MessageContextBuilders.cs,AttributeProperty,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,AssemblyName,The method has 9 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,AssemblyName,The method has 8 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,Peephole,C:\repos\Reactive-Extensions_IL2JS\CST\Peephole.cs,Trace,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,DllLoadContext,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,DllLoadContext,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,ArgsAndResultFromMethodSig,The method has 7 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,MethodRefFromMethodSig,The method has 7 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,SignatureFromMethodSig,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,MethodDefFromRow,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The method has 6 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,MergeAssemblyDefs,The method has 6 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,CustomAttributeFromRow,The method has 6 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,MethodSignature,C:\repos\Reactive-Extensions_IL2JS\CST\Signature.cs,MethodSignature,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,MethodSignature,C:\repos\Reactive-Extensions_IL2JS\CST\Signature.cs,AccumUsedTypeDefs,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,MethodSignature,C:\repos\Reactive-Extensions_IL2JS\CST\Signature.cs,CheckValid,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,PropertySignature,C:\repos\Reactive-Extensions_IL2JS\CST\Signature.cs,AccumUsedTypeDefs,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,PropertySignature,C:\repos\Reactive-Extensions_IL2JS\CST\Signature.cs,CheckValid,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,SimplifierContext,C:\repos\Reactive-Extensions_IL2JS\CST\SimplifierContext.cs,SimplifierContext,The method has 7 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,ValidityContext,C:\repos\Reactive-Extensions_IL2JS\CST\Validity.cs,Check,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,ValidityContext,C:\repos\Reactive-Extensions_IL2JS\CST\Validity.cs,ImplementableInstruction,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,Variable,C:\repos\Reactive-Extensions_IL2JS\CST\Variable.cs,Variable,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The method has 78 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,TypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,TopologicalTypeInit,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,TypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimAreValidArguments,The method has 6 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,TypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceRespectsParameterConstraint,The method has 7 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,TypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceIsAssignableTo,The method has 7 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,PointerTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceRespectsParameterConstraint,The method has 7 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,PointerTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceIsAssignableTo,The method has 6 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,CodePointerTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceRespectsParameterConstraint,The method has 7 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,ArrayTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceRespectsParameterConstraint,The method has 7 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,MultiDimArrayTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceRespectsParameterConstraint,The method has 7 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,MultiDimArrayTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceIsAssignableTo,The method has 6 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,BoxTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceRespectsParameterConstraint,The method has 7 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,NullTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceRespectsParameterConstraint,The method has 7 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,NullTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceIsAssignableTo,The method has 6 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,DerivingTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceRespectsParameterConstraint,The method has 7 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,ParameterTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,ParameterTypeDef,The method has 8 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,ParameterTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceRespectsParameterConstraint,The method has 7 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,ParameterTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimIsValidParameterBinding,The method has 7 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,NamedTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,NamedTypeDef,The method has 7 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,RealTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,RealTypeDef,The method has 11 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,StructTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,StructTypeDef,The method has 9 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,VoidTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,VoidTypeDef,The method has 9 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,VoidTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceIsAssignableTo,The method has 6 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,VoidTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceRespectsParameterConstraint,The method has 7 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,NumberTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,NumberTypeDef,The method has 10 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,HandleTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,HandleTypeDef,The method has 10 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,NullableTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,NullableTypeDef,The method has 9 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,NullableTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceRespectsParameterConstraint,The method has 7 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,EnumTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,EnumTypeDef,The method has 8 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,DelegateTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,DelegateTypeDef,The method has 9 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,ClassTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,ClassTypeDef,The method has 11 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,ObjectTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,ObjectTypeDef,The method has 9 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,StringTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,StringTypeDef,The method has 9 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,InterfaceTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,InterfaceTypeDef,The method has 6 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,InterfaceTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceIsAssignableTo,The method has 6 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,GenericIEnumerableTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,GenericIEnumerableTypeDef,The method has 6 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,NamedTypeRef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeRef.cs,AccumUsedTypeDefs,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,NamedTypeRef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeRef.cs,CheckValid,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.CST,Usage,C:\repos\Reactive-Extensions_IL2JS\CST\Usage.cs,Merge,The method has 7 parameters.
Long Identifier,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceSwitch,The length of the parameter allIntermediateAreNonReturningOrJumpToTarget is 44.
Long Identifier,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The length of the parameter explicitInterfaceImplementationRows is 35.
Long Identifier,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The length of the parameter explicitInterfaceImplementations is 32.
Long Identifier,Microsoft.LiveLabs.CST,PointerTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceIsAssignableTo,The length of the parameter thisGroundThisThisGroundTypeArguments is 37.
Long Identifier,Microsoft.LiveLabs.CST,PointerTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceIsAssignableTo,The length of the parameter otherGroundGroundTypeArguments is 30.
Long Identifier,Microsoft.LiveLabs.CST,RealTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,RealTypeDef,The length of the parameter explicitInterfaceImplementations is 32.
Long Statement,Microsoft.LiveLabs.CST,BranchBasicBlock,C:\repos\Reactive-Extensions_IL2JS\CST\BasicBlock.cs,HasSameExit,The length of the statement  "	return branchbb != null && Target.Equals (branchbb.Target) && Fallthrough.Equals (branchbb.Fallthrough) && Test.Equals (branchbb.Test); " is 135.
Long Statement,Microsoft.LiveLabs.CST,LeaveTryBasicBlock,C:\repos\Reactive-Extensions_IL2JS\CST\BasicBlock.cs,HasSameExit,The length of the statement  "	return leavebb != null && Try.Equals (leavebb.Try) && HandlerPopCount == leavebb.HandlerPopCount && Target.Equals (leavebb.Target); " is 131.
Long Statement,Microsoft.LiveLabs.CST,LeaveCatchBasicBlock,C:\repos\Reactive-Extensions_IL2JS\CST\BasicBlock.cs,HasSameExit,The length of the statement  "	return leavebb != null && Catch.Body.Equals (leavebb.Catch.Body) && HandlerPopCount == leavebb.HandlerPopCount && Target.Equals (leavebb.Target); " is 145.
Long Statement,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,BasicBlockFromIndex,The length of the statement  "						var efbb = new EndFinallyBasicBlock (nextBlockId++' extractExclusive (i)' (TBBFinallyHandler)handlerContext.TBBHandler' misci.BeforeState.Depth); " is 145.
Long Statement,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,BasicBlockFromIndex,The length of the statement  "					var bbb = new BranchBasicBlock (nextBlockId++' extractExclusive (i)' Test.FromBranchOp (bri.Op' bri.IsUnsigned' bri.Type)); " is 123.
Long Statement,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,BasicBlockFromIndex,The length of the statement  "							var ltbb = new LeaveTryBasicBlock (nextBlockId++' extractExclusive (i)' tryContext.TryBasicBlock' handlerPopCount' stackPopCount); " is 130.
Long Statement,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,BasicBlockFromIndex,The length of the statement  "									var lcbb = new LeaveCatchBasicBlock (nextBlockId++' extractExclusive (i)' (TBBCatchHandler)handlerContext.TBBHandler' handlerPopCount' stackPopCount); " is 150.
Long Statement,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceBranch,The length of the statement  "		if (thenbb != null && thenbb.Target.Equals (branchbb) && thenbb.Sources.Count == 1 && group.Add (thenbb) && !group.Contains (branchbb.Fallthrough)) { " is 149.
Long Statement,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceBranch,The length of the statement  "		if (elsebb != null && elsebb.Target.Equals (branchbb) && elsebb.Sources.Count == 1 && group.Add (elsebb) && !group.Contains (branchbb.Target)) { " is 144.
Long Statement,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceBranch,The length of the statement  "		if (thenbb != null && elsebb != null && thenbb.Target.Equals (elsebb.Target) && elsebb.Sources.Count == 1 && group.Add (elsebb) && !group.Contains (thenbb) && !group.Contains (thenbb.Target) && !thenbb.Target.Equals (thenbb) && IsLoadBooleanBlock (thenbb.Block)) { " is 264.
Long Statement,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceBranch,The length of the statement  "		if (thenbb != null && elsebb != null && thenbb.Target.Equals (elsebb.Target) && thenbb.Sources.Count == 1 && group.Add (thenbb) && !group.Contains (elsebb) && !group.Contains (elsebb.Target) && !elsebb.Target.Equals (elsebb) && IsLoadBooleanBlock (elsebb.Block)) { " is 264.
Long Statement,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceBranch,The length of the statement  "		if (thenbb != null && branchbb.Fallthrough.Equals (thenbb.Fallthrough) && thenbb.Sources.Count == 1 && group.Add (thenbb) && !group.Contains (thenbb.Target) && !group.Contains (branchbb.Fallthrough)) { " is 201.
Long Statement,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceBranch,The length of the statement  "			var newbb = new BranchBasicBlock (nextBlockId++' new Instructions (beforeState' instructions)' new Test (TestOp.True' false' methEnv.Global.Int32Ref)) { " is 152.
Long Statement,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceBranch,The length of the statement  "		if (elsebb != null && branchbb.Target.Equals (elsebb.Fallthrough) && elsebb.Sources.Count == 1 && group.Add (elsebb) && !group.Contains (elsebb.Target) && !group.Contains (branchbb.Target)) { " is 191.
Long Statement,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceBranch,The length of the statement  "			var newbb = new BranchBasicBlock (nextBlockId++' new Instructions (beforeState' instructions)' new Test (TestOp.True' false' methEnv.Global.Int32Ref)) { " is 152.
Long Statement,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceBranch,The length of the statement  "		if (thenbb != null && branchbb.Fallthrough.Equals (thenbb.Target) && thenbb.Sources.Count == 1 && group.Add (thenbb) && !group.Contains (thenbb.Fallthrough) && !group.Contains (branchbb.Fallthrough)) { " is 201.
Long Statement,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceBranch,The length of the statement  "			var afterState2 = thenbb.Test.Negate ().Eval (instructions2' thenbb.Block.AfterState' thenbb.Fallthrough.Block.BeforeState' BottomPT); " is 134.
Long Statement,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceBranch,The length of the statement  "			var newbb = new BranchBasicBlock (nextBlockId++' new Instructions (beforeState' instructions)' new Test (TestOp.True' false' methEnv.Global.Int32Ref)) { " is 152.
Long Statement,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceBranch,The length of the statement  "		if (elsebb != null && branchbb.Target.Equals (elsebb.Target) && elsebb.Sources.Count == 1 && group.Add (elsebb) && !group.Contains (elsebb.Fallthrough) && !group.Contains (branchbb.Target)) { " is 191.
Long Statement,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceBranch,The length of the statement  "			var afterState2 = elsebb.Test.Negate ().Eval (instructions2' elsebb.Block.AfterState' elsebb.Fallthrough.Block.BeforeState' BottomPT); " is 134.
Long Statement,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceBranch,The length of the statement  "			var newbb = new BranchBasicBlock (nextBlockId++' new Instructions (beforeState' instructions)' new Test (TestOp.True' false' methEnv.Global.Int32Ref)) { " is 152.
Long Statement,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceBranch,The length of the statement  "		if (thenbb != null && elsebb != null && !branchbb.Equals (thenbb) && !branchbb.Equals (elsebb) && !thenbb.Equals (elsebb) && branchbb.Target.Sources.Count == 1 && branchbb.Fallthrough.Sources.Count == 1) { " is 205.
Long Statement,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceBranch,The length of the statement  "		if (group.Add (branchbb.Target) && group.Add (branchbb.Fallthrough) && branchbb.Target.Sources.Count == 1 && branchbb.Fallthrough.Sources.Count == 1 && branchbb.Target.HasSameExit (branchbb.Fallthrough)) { " is 205.
Long Statement,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceSwitch,The length of the statement  "		var newbb = new JumpBasicBlock (nextBlockId++' Peephole (switchbb.Block.BeforeState' instructions)' switchbb.Fallthrough); " is 122.
Long Statement,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceLoopCandidate,The length of the statement  "	if ((jumpheadbb != null && jumpheadbb.Target.Equals (loopbb.Break) || nonretheadbb != null) && group.Add (headbb) && !group.Contains (loopbb.Break)) { " is 150.
Long Statement,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,ContinueReduceJump,The length of the statement  "	if (jumpbb.Target.Equals (loop.ContinueTarget) && jumpbb.Block.AfterState.Depth == 0 && loop.ContinueTarget.Sources.Count > 1) { " is 128.
Long Statement,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,ContinueReduceBranch,The length of the statement  "	if (branchbb.Target.Equals (loop.ContinueTarget) && !branchbb.Fallthrough.Equals (loop.ContinueTarget) && loop.ContinueTarget.Sources.Count > 1) { " is 146.
Long Statement,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,ContinueReduceBranch,The length of the statement  "	if (branchbb.Fallthrough.Equals (loop.ContinueTarget) && !branchbb.Target.Equals (loop.ContinueTarget) && loop.ContinueTarget.Sources.Count > 1) { " is 146.
Long Statement,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,Root,The length of the statement  "	var root = new RootBasicBlock (nextBlockId++' new MachineState (methEnv' method.ValueParameters.Count' method.Locals.Count)); " is 125.
Long Statement,Microsoft.LiveLabs.CST,PointsTo,C:\repos\Reactive-Extensions_IL2JS\CST\Domain.cs,MakeArgLocal,The length of the statement  "		return new PointsTo (IntPowersetDomain.Singleton (nArgs' index)' IntPowersetDomain.Bottom (nLocals)' BooleanDomain.Bottom); " is 123.
Long Statement,Microsoft.LiveLabs.CST,PointsTo,C:\repos\Reactive-Extensions_IL2JS\CST\Domain.cs,MakeArgLocal,The length of the statement  "		return new PointsTo (IntPowersetDomain.Bottom (nArgs)' IntPowersetDomain.Singleton (nLocals' index)' BooleanDomain.Bottom); " is 123.
Long Statement,Microsoft.LiveLabs.CST,PointsTo,C:\repos\Reactive-Extensions_IL2JS\CST\Domain.cs,ReadEffect,The length of the statement  "		return new Effects (Args.Members.Clone ()' new IntSet (NumArgs)' Locals.Members.Clone ()' new IntSet (NumLocals)' Heap.Value' false' false); " is 140.
Long Statement,Microsoft.LiveLabs.CST,PointsTo,C:\repos\Reactive-Extensions_IL2JS\CST\Domain.cs,WriteEffect,The length of the statement  "		return new Effects (Args.Members.Clone ()' Args.Members.Clone ()' Locals.Members.Clone ()' Locals.Members.Clone ()' Heap.Value' Heap.Value' false); " is 147.
Long Statement,Microsoft.LiveLabs.CST,Effects,C:\repos\Reactive-Extensions_IL2JS\CST\Domain.cs,CommutableWith,The length of the statement  "	return Args.CommutableWith (other.Args) && Locals.CommutableWith (other.Locals) && Heap.CommutableWith (other.Heap) && MayThrow.CommutableWith (other.MayThrow); " is 160.
Long Statement,Microsoft.LiveLabs.CST,Effects,C:\repos\Reactive-Extensions_IL2JS\CST\Domain.cs,MakeBottom,The length of the statement  "	return new Effects (ReadWriteVectorDomain.FromSameElement (ReadWriteDomain.Bottom' nArgs)' ReadWriteVectorDomain.FromSameElement (ReadWriteDomain.Bottom' nLocals)' ReadWriteDomain.Bottom' BooleanDomain.Bottom); " is 210.
Long Statement,Microsoft.LiveLabs.CST,Effects,C:\repos\Reactive-Extensions_IL2JS\CST\Domain.cs,MakeTop,The length of the statement  "	return new Effects (ReadWriteVectorDomain.FromSameElement (ReadWriteDomain.Top' nArgs)' ReadWriteVectorDomain.FromSameElement (ReadWriteDomain.Top' nLocals)' ReadWriteDomain.Top' BooleanDomain.Top); " is 198.
Long Statement,Microsoft.LiveLabs.CST,Effects,C:\repos\Reactive-Extensions_IL2JS\CST\Domain.cs,MakeArgLocal,The length of the statement  "		return new Effects (ReadWriteVectorDomain.FromSameElementExcept (ReadWriteDomain.Bottom' nArgs' new ReadWriteDomain (true' isWrite)' index)' ReadWriteVectorDomain.FromSameElement (ReadWriteDomain.Bottom' nLocals)' ReadWriteDomain.Bottom' new BooleanDomain (couldThrow)); " is 270.
Long Statement,Microsoft.LiveLabs.CST,Effects,C:\repos\Reactive-Extensions_IL2JS\CST\Domain.cs,MakeArgLocal,The length of the statement  "		return new Effects (ReadWriteVectorDomain.FromSameElement (ReadWriteDomain.Bottom' nArgs)' ReadWriteVectorDomain.FromSameElementExcept (ReadWriteDomain.Bottom' nLocals' new ReadWriteDomain (true' isWrite)' index)' ReadWriteDomain.Bottom' new BooleanDomain (couldThrow)); " is 270.
Long Statement,Microsoft.LiveLabs.CST,Effects,C:\repos\Reactive-Extensions_IL2JS\CST\Domain.cs,MakeHeap,The length of the statement  "	return new Effects (ReadWriteVectorDomain.FromSameElement (ReadWriteDomain.Bottom' nArgs)' ReadWriteVectorDomain.FromSameElement (ReadWriteDomain.Bottom' nLocals)' new ReadWriteDomain (true' isWrite)' new BooleanDomain (couldThrow)); " is 233.
Long Statement,Microsoft.LiveLabs.CST,Effects,C:\repos\Reactive-Extensions_IL2JS\CST\Domain.cs,MakeArgLocalHeap,The length of the statement  "	return new Effects (ReadWriteVectorDomain.FromSameElement (new ReadWriteDomain (true' isWrite)' nArgs)' ReadWriteVectorDomain.FromSameElement (new ReadWriteDomain (true' isWrite)' nLocals)' new ReadWriteDomain (true' isWrite)' new BooleanDomain (couldThrow)); " is 259.
Long Statement,Microsoft.LiveLabs.CST,Effects,C:\repos\Reactive-Extensions_IL2JS\CST\Domain.cs,MakeThrows,The length of the statement  "	return new Effects (ReadWriteVectorDomain.FromSameElement (ReadWriteDomain.Bottom' nArgs)' ReadWriteVectorDomain.FromSameElement (ReadWriteDomain.Bottom' nLocals)' ReadWriteDomain.Bottom' BooleanDomain.Top); " is 207.
Long Statement,Microsoft.LiveLabs.CST,Global,C:\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,GetCodePointerTypeConstructorDetails,The length of the statement  "	if (nm.Length > functionPrefix.Length && nm [0] == '$' && nm.Substring (0' functionPrefix.Length).Equals (functionPrefix' StringComparison.Ordinal)) { " is 150.
Long Statement,Microsoft.LiveLabs.CST,Global,C:\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,GetCodePointerTypeConstructorDetails,The length of the statement  "	else if (nm.Length > actionPrefix.Length && nm [0] == '$' && nm.Substring (0' actionPrefix.Length).Equals (actionPrefix' StringComparison.Ordinal)) { " is 149.
Long Statement,Microsoft.LiveLabs.CST,Global,C:\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,GetMultiDimArrayTypeConstructorDetails,The length of the statement  "	if (nm.Length > multiDimArrayPrefix.Length && nm [0] == '$' && nm.Substring (0' multiDimArrayPrefix.Length).Equals (multiDimArrayPrefix' StringComparison.Ordinal)) " is 163.
Long Statement,Microsoft.LiveLabs.CST,TypeConstructorEnvironment,C:\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,AddSelfTypeBoundArguments,The length of the statement  "		var typeBoundSkolemDefs = Type.Parameters.Select (p => new SkolemDef (Assembly' Type' p.PrimSubstitute (typeBoundArguments' null))); " is 132.
Long Statement,Microsoft.LiveLabs.CST,TypeConstructorEnvironment,C:\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,AddSelfTypeBoundArguments,The length of the statement  "		return new TypeEnvironment (Global' SkolemDefs.Concat (typeBoundSkolemDefs).ToSeq ()' Assembly' Type' typeBoundArguments); " is 122.
Long Statement,Microsoft.LiveLabs.CST,PolymorphicMethodEnvironment,C:\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,AddSelfMethodBoundArguments,The length of the statement  "		var methodBoundArguments = Method.TypeParameters.Select ((t' i) => (TypeRef)new SkolemTypeRef (SkolemDefs.Count + i)).ToSeq (); " is 127.
Long Statement,Microsoft.LiveLabs.CST,PolymorphicMethodEnvironment,C:\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,AddSelfMethodBoundArguments,The length of the statement  "		var methodBoundSkolemDefs = Method.TypeParameters.Select (p => new SkolemDef (Assembly' Type' p.PrimSubstitute (TypeBoundArguments' methodBoundArguments))); " is 156.
Long Statement,Microsoft.LiveLabs.CST,PolymorphicMethodEnvironment,C:\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,AddSelfMethodBoundArguments,The length of the statement  "		return new MethodEnvironment (Global' SkolemDefs.Concat (methodBoundSkolemDefs).ToSeq ()' Assembly' Type' TypeBoundArguments' Method' methodBoundArguments); " is 156.
Long Statement,Microsoft.LiveLabs.CST,MethodEnvironment,C:\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,AddVariables,The length of the statement  "	return new CompilationEnvironment (Global' SkolemDefs' Assembly' Type' TypeBoundArguments' Method' MethodBoundArguments' variables' valueParameterIds' localIds); " is 161.
Long Statement,Microsoft.LiveLabs.CST,MethodEnvironment,C:\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,AddVariables,The length of the statement  "		variables.Add (id' new Variable (id' ArgLocal.Local' localIsAlive (i)' false' SubstituteType (Method.Locals [i].Type))); " is 120.
Long Statement,Microsoft.LiveLabs.CST,BinaryExpression,C:\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,SimplifyLogNot,The length of the statement  "		return new BinaryExpression (LeftValue.Simplify (ctxt)' BinaryOp.Ne' RightValue.Simplify (ctxt)' WithOverflow' IsUnsigned); " is 123.
Long Statement,Microsoft.LiveLabs.CST,BinaryExpression,C:\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,SimplifyLogNot,The length of the statement  "		return new BinaryExpression (LeftValue.Simplify (ctxt)' BinaryOp.Eq' RightValue.Simplify (ctxt)' WithOverflow' IsUnsigned); " is 123.
Long Statement,Microsoft.LiveLabs.CST,BinaryExpression,C:\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,SimplifyLogNot,The length of the statement  "		return new BinaryExpression (LeftValue.Simplify (ctxt)' BinaryOp.Ge' RightValue.Simplify (ctxt)' WithOverflow' IsUnsigned); " is 123.
Long Statement,Microsoft.LiveLabs.CST,BinaryExpression,C:\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,SimplifyLogNot,The length of the statement  "		return new BinaryExpression (LeftValue.Simplify (ctxt)' BinaryOp.Gt' RightValue.Simplify (ctxt)' WithOverflow' IsUnsigned); " is 123.
Long Statement,Microsoft.LiveLabs.CST,BinaryExpression,C:\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,SimplifyLogNot,The length of the statement  "		return new BinaryExpression (LeftValue.Simplify (ctxt)' BinaryOp.Le' RightValue.Simplify (ctxt)' WithOverflow' IsUnsigned); " is 123.
Long Statement,Microsoft.LiveLabs.CST,BinaryExpression,C:\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,SimplifyLogNot,The length of the statement  "		return new BinaryExpression (LeftValue.Simplify (ctxt)' BinaryOp.Lt' RightValue.Simplify (ctxt)' WithOverflow' IsUnsigned); " is 123.
Long Statement,Microsoft.LiveLabs.CST,BinaryExpression,C:\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,SimplifyLogNot,The length of the statement  "		return new BinaryExpression (LeftValue.SimplifyLogNot (ctxt)' BinaryOp.LogOr' RightValue.SimplifyLogNot (ctxt)' WithOverflow' IsUnsigned); " is 138.
Long Statement,Microsoft.LiveLabs.CST,BinaryExpression,C:\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,SimplifyLogNot,The length of the statement  "		return new BinaryExpression (LeftValue.SimplifyLogNot (ctxt)' BinaryOp.LogAnd' RightValue.SimplifyLogNot (ctxt)' WithOverflow' IsUnsigned); " is 139.
Long Statement,Microsoft.LiveLabs.CST,BinaryExpression,C:\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,EqualBody,The length of the statement  "	return Op == bin.Op && LeftValue.Equals (bin.LeftValue) && RightValue.Equals (bin.RightValue) && WithOverflow == bin.WithOverflow && IsUnsigned == bin.IsUnsigned; " is 162.
Long Statement,Microsoft.LiveLabs.CST,ConvertExpression,C:\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,EqualBody,The length of the statement  "	return Value.Equals (conv.Value) && ResultType.Equals (conv.ResultType) && WithOverflow == conv.WithOverflow && IsUnsigned == conv.IsUnsigned; " is 142.
Long Statement,Microsoft.LiveLabs.CST,CallExpression,C:\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,Simplify,The length of the statement  "				exportedArgs.Add (new ImportExportExpression (false' Arguments [i]' inlinedMethEnv.SubstituteType (inlinedMethEnv.Method.ValueParameters [i + delta].Type))); " is 157.
Long Statement,Microsoft.LiveLabs.CST,CallExpression,C:\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,Simplify,The length of the statement  "					var newid = subCtxt.FreshenArgument (cstmethod.CompEnv.ValueParameterIds [i]' inlinedMethEnv.SubstituteType (cstmethod.CompEnv.Method.ValueParameters [i].Type)); " is 161.
Long Statement,Microsoft.LiveLabs.CST,ExpressionStack,C:\repos\Reactive-Extensions_IL2JS\CST\ExpressionStack.cs,Dump,The length of the statement  "		compEnv.AddVariable (id' ArgLocal.Local' false' true' compEnv.SubstituteType (state.PeekType (stack.Count - (1 + skip) - i))); " is 126.
Long Statement,Microsoft.LiveLabs.CST,ExpressionStack,C:\repos\Reactive-Extensions_IL2JS\CST\ExpressionStack.cs,ProtectStackFromNonLinearEvaluation,The length of the statement  "		needsEvaluation [i] = !(stack [i].Effects.CommutableWith (argAndBodyEffects) && stack [i].Effects.IsReadOnly && stack [i].Expression.IsCheap); " is 142.
Long Statement,Microsoft.LiveLabs.CST,ExpressionStack,C:\repos\Reactive-Extensions_IL2JS\CST\ExpressionStack.cs,Restore,The length of the statement  "		compEnv.AddVariable (id' ArgLocal.Local' false' true' compEnv.SubstituteType (stateAfterRestore.PeekType (stateAfterRestore.Depth - skip - 1 - i))); " is 148.
Long Statement,Microsoft.LiveLabs.CST,Instructions,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,AccumUsedTypeAndMemberDefs,The length of the statement  "	return Body.Select (i => i.AccumUsedTypeAndMemberDefs (vctxt' ctxt' usedTypes' usedMembers)).FirstOrDefault (v => v != null); " is 125.
Long Statement,Microsoft.LiveLabs.CST,MethodInstruction,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,AccumUsedTypeAndMemberDefs,The length of the statement  "	return Method.AccumUsedTypeDefs (vctxt' ctxt' usedTypes) ?? (Constrained == null ? null : Constrained.AccumUsedTypeDefs (vctxt' ctxt' usedTypes)); " is 146.
Long Statement,Microsoft.LiveLabs.CST,MethodInstruction,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,CheckValid,The length of the statement  "	var v = Method.CheckValid (vctxt' ctxt' methEnv) ?? (Constrained == null ? null : Constrained.CheckValid (vctxt' ctxt' methEnv)); " is 129.
Long Statement,Microsoft.LiveLabs.CST,TryInstruction,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,AccumUsedTypeAndMemberDefs,The length of the statement  "	return Body.AccumUsedTypeAndMemberDefs (vctxt' ctxt' usedTypes' usedMembers) ?? Handlers.Select (h => h.AccumUsedTypeAndMemberDefs (vctxt' ctxt' usedTypes' usedMembers)).FirstOrDefault (v => v != null); " is 202.
Long Statement,Microsoft.LiveLabs.CST,TryInstruction,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,CheckValid,The length of the statement  "	return Body.CheckValid (vctxt' ctxt' methEnv) ?? Handlers.Select (h => h.CheckValid (vctxt' ctxt' methEnv)).FirstOrDefault (v => v != null); " is 140.
Long Statement,Microsoft.LiveLabs.CST,CatchTryInstructionHandler,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,AccumUsedTypeAndMemberDefs,The length of the statement  "	return base.AccumUsedTypeAndMemberDefs (vctxt' ctxt' usedTypes' usedMembers) ?? Type.AccumUsedTypeDefs (vctxt' ctxt' usedTypes); " is 128.
Long Statement,Microsoft.LiveLabs.CST,FilterTryInstructionHandler,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,AccumUsedTypeAndMemberDefs,The length of the statement  "	return base.AccumUsedTypeAndMemberDefs (vctxt' ctxt' usedTypes' usedMembers) ?? FilterBody.AccumUsedTypeAndMemberDefs (vctxt' ctxt' usedTypes' usedMembers); " is 156.
Long Statement,Microsoft.LiveLabs.CST,IfThenElseInstruction,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,IsInlinable,The length of the statement  "	return Condition.IsInlinable (ref numReturns) && Then.IsInlinable (ref numReturns) && (Else == null || Else.IsInlinable (ref numReturns)); " is 138.
Long Statement,Microsoft.LiveLabs.CST,IfThenElseInstruction,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,Clone,The length of the statement  "	return new IfThenElseInstruction (nextInstructionId--' Condition.Clone (ref nextInstructionId)' Then.Clone (ref nextInstructionId)' Else == null ? null : Else.Clone (ref nextInstructionId)) { " is 191.
Long Statement,Microsoft.LiveLabs.CST,IfThenElseInstruction,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,AccumUsedTypeAndMemberDefs,The length of the statement  "	return Condition.AccumUsedTypeAndMemberDefs (vctxt' ctxt' usedTypes' usedMembers) ?? Then.AccumUsedTypeAndMemberDefs (vctxt' ctxt' usedTypes' usedMembers) ?? Else.AccumUsedTypeAndMemberDefs (vctxt' ctxt' usedTypes' usedMembers); " is 228.
Long Statement,Microsoft.LiveLabs.CST,IfThenElseInstruction,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,CheckValid,The length of the statement  "	return Condition.CheckValid (vctxt' ctxt' methEnv) ?? Then.CheckValid (vctxt' ctxt' methEnv) ?? Else.CheckValid (vctxt' ctxt' methEnv); " is 135.
Long Statement,Microsoft.LiveLabs.CST,ShortCircuitingInstruction,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,Clone,The length of the statement  "	return new ShortCircuitingInstruction (nextInstructionId--' Left.Clone (ref nextInstructionId)' Op' Right.Clone (ref nextInstructionId)) { " is 138.
Long Statement,Microsoft.LiveLabs.CST,ShortCircuitingInstruction,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,AccumUsedTypeAndMemberDefs,The length of the statement  "	return Left.AccumUsedTypeAndMemberDefs (vctxt' ctxt' usedTypes' usedMembers) ?? Right.AccumUsedTypeAndMemberDefs (vctxt' ctxt' usedTypes' usedMembers); " is 151.
Long Statement,Microsoft.LiveLabs.CST,StructuralSwitchInstruction,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,AccumUsedTypeAndMemberDefs,The length of the statement  "	return Body.AccumUsedTypeAndMemberDefs (vctxt' ctxt' usedTypes' usedMembers) ?? Cases.Select (c => c.AccumUsedTypeAndMemberDefs (vctxt' ctxt' usedTypes' usedMembers)).FirstOrDefault (v => v != null); " is 199.
Long Statement,Microsoft.LiveLabs.CST,StructuralSwitchInstruction,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,CheckValid,The length of the statement  "	return Body.CheckValid (vctxt' ctxt' methEnv) ?? Cases.Select (c => c.CheckValid (vctxt' ctxt' methEnv)).FirstOrDefault (v => v != null); " is 137.
Long Statement,Microsoft.LiveLabs.CST,WhileDoInstruction,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,Clone,The length of the statement  "	return new WhileDoInstruction (nextInstructionId--' Condition.Clone (ref nextInstructionId)' Body.Clone (ref nextInstructionId)) { " is 130.
Long Statement,Microsoft.LiveLabs.CST,WhileDoInstruction,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,AccumUsedTypeAndMemberDefs,The length of the statement  "	return Condition.AccumUsedTypeAndMemberDefs (vctxt' ctxt' usedTypes' usedMembers) ?? Body.AccumUsedTypeAndMemberDefs (vctxt' ctxt' usedTypes' usedMembers); " is 155.
Long Statement,Microsoft.LiveLabs.CST,DoWhileInstruction,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,Clone,The length of the statement  "	return new DoWhileInstruction (nextInstructionId--' Body.Clone (ref nextInstructionId)' Condition.Clone (ref nextInstructionId)) { " is 130.
Long Statement,Microsoft.LiveLabs.CST,DoWhileInstruction,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,AccumUsedTypeAndMemberDefs,The length of the statement  "	return Body.AccumUsedTypeAndMemberDefs (vctxt' ctxt' usedTypes' usedMembers) ?? Condition.AccumUsedTypeAndMemberDefs (vctxt' ctxt' usedTypes' usedMembers); " is 155.
Long Statement,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The length of the statement  "				while (instruction.OpCode == PE.OpCode.Unaligned || instruction.OpCode == PE.OpCode.Volatile || instruction.OpCode == PE.OpCode.Tailcall) { " is 139.
Long Statement,Microsoft.LiveLabs.CST,MachineState,C:\repos\Reactive-Extensions_IL2JS\CST\MachineState.cs,CloneWithArgLocalPointsTo,The length of the statement  "	return new MachineState (RootEnv' nArgs' nLocals' innerState.Value.CloneWithArgLocalPointsTo (stack' argLocal' index' pointsTo)); " is 129.
Long Statement,Microsoft.LiveLabs.CST,MachineState,C:\repos\Reactive-Extensions_IL2JS\CST\MachineState.cs,PeekDereferencableExpectedType,The length of the statement  "			throw new InvalidOperationException ("stack entry is a value type' but value types cannot be the target of field pointers"); " is 124.
Long Statement,Microsoft.LiveLabs.CST,MachineState,C:\repos\Reactive-Extensions_IL2JS\CST\MachineState.cs,PropogateBackwards,The length of the statement  "	innerState.Value.ArgsLocalsState.PropogateBackwards (nextState.innerState.Value.ArgsLocalsState' default(ArgLocal)' -1' false' changed); " is 136.
Long Statement,Microsoft.LiveLabs.CST,MachineState,C:\repos\Reactive-Extensions_IL2JS\CST\MachineState.cs,WriteArgLocal,The length of the statement  "	innerState.Value.ArgsLocalsState.PropogateBackwards (nextState.innerState.Value.ArgsLocalsState' argLocal' index' false' changed); " is 130.
Long Statement,Microsoft.LiveLabs.CST,MachineState,C:\repos\Reactive-Extensions_IL2JS\CST\MachineState.cs,ReadArgLocal,The length of the statement  "	innerState.Value.ArgsLocalsState.PropogateBackwards (nextState.innerState.Value.ArgsLocalsState' argLocal' index' true' changed); " is 129.
Long Statement,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The length of the statement  "			return state.PushType (methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (type)' ArgLocalPT (argi.ArgLocal' argi.Index)); " is 127.
Long Statement,Microsoft.LiveLabs.CST,MemberDef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,TopologicalTypeInit,The length of the statement  "				usedMemberDef.TopologicalTypeInit (global' usedAssemblyDef' usedTypeDef' visitedTypeDefs' sortedTypeDefs' visitedMemberDefs); " is 125.
Long Statement,Microsoft.LiveLabs.CST,MethodDef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,HasParamsArray,The length of the statement  "		return p.Type.Style (rootEnv) is ArrayTypeStyle && p.CustomAttributes.Any (attr => attr.Type.Equals (rootEnv.Global.ParamArrayAttributeRef)); " is 141.
Long Statement,Microsoft.LiveLabs.CST,MethodDef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,PrimReference,The length of the statement  "	return new PolymorphicMethodRef (typeDef.PrimReference (global' assemblyDef' typeBoundArguments)' Name' IsStatic' TypeArity' ValueParameters.Select (p => p.Type).ToSeq ()' Result == null ? null : Result.Type); " is 209.
Long Statement,Microsoft.LiveLabs.CST,MethodDef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,PrimMethodReference,The length of the statement  "	return new MethodRef (typeDef.PrimReference (global' assemblyDef' typeBoundArguments)' Name' IsStatic' methodBoundArguments' ValueParameters.Select (p => p.Type).ToSeq ()' Result == null ? null : Result.Type); " is 209.
Long Statement,Microsoft.LiveLabs.CST,MethodDef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,SelfMethodReference,The length of the statement  "	return PrimMethodReference (tyconEnv.Global' tyconEnv.Assembly' tyconEnv.Type' typeRef.Arguments' methodBoundArguments); " is 120.
Long Statement,Microsoft.LiveLabs.CST,MethodDef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,Instructions,The length of the statement  "		instructionsCache = new InstructionLoader (global).InstructionsFromMethodBody (Result == null ? null : Result.Type' MethodBody); " is 128.
Long Statement,Microsoft.LiveLabs.CST,MethodDef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,TopologicalTypeInitFromImplementors,The length of the statement  "				usedMemberDef.TopologicalTypeInit (global' usedAssemblyDef' usedTypeDef' visitedTypeDefs' sortedTypeDefs' visitedMemberDefs); " is 125.
Long Statement,Microsoft.LiveLabs.CST,PropertyDef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,PrimReference,The length of the statement  "	return new PropertyRef (typeDef.PrimReference (global' assemblyDef' typeBoundArguments)' sig.Name' sig.IsStatic' sig.Parameters' sig.Result); " is 141.
Long Statement,Microsoft.LiveLabs.CST,MemberRef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberRef.cs,Equals,The length of the statement  "	return Flavor == other.Flavor && DefiningType.Equals (other.DefiningType) && Name.Equals (other.Name' StringComparison.Ordinal) && Signature.Equals (other.Signature); " is 166.
Long Statement,Microsoft.LiveLabs.CST,PolymorphicMethodRef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberRef.cs,PrimSubstitute,The length of the statement  "	return new PolymorphicMethodRef (Annotations' DefiningType.PrimSubstitute (typeBoundArguments' methodBoundArguments)' signature); " is 129.
Long Statement,Microsoft.LiveLabs.CST,MethodRef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberRef.cs,AccumUsedTypeDefs,The length of the statement  "	return base.AccumUsedTypeDefs (vctxt' ctxt' usedTypes) ?? MethodTypeArguments.Select (a => a.AccumUsedTypeDefs (vctxt' ctxt' usedTypes)).FirstOrDefault (v => v != null); " is 169.
Long Statement,Microsoft.LiveLabs.CST,MethodRef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberRef.cs,CheckValid,The length of the statement  "		vctxt.Log (new InvalidMemberRef (ctxt' this' String.Format ("Polymorphic method has {0} type parameters but is applied to {1} type arguments"' MethodTypeArity' MethodTypeArguments.Count))); " is 189.
Long Statement,Microsoft.LiveLabs.CST,MethodRef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberRef.cs,PrimSubstitute,The length of the statement  "		methodTypeArguments = MethodTypeArguments.Select (type => type.PrimSubstitute (typeBoundArguments' methodBoundArguments)).ToSeq (); " is 131.
Long Statement,Microsoft.LiveLabs.CST,MethodRef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberRef.cs,PrimSubstitute,The length of the statement  "	return new MethodRef (Annotations' DefiningType.PrimSubstitute (typeBoundArguments' methodBoundArguments)' signature' methodTypeArguments); " is 139.
Long Statement,Microsoft.LiveLabs.CST,MethodRef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberRef.cs,ToOverriddenMethod,The length of the statement  "		return new MethodRef (polyRef.DefiningType' polyRef.Name' polyRef.IsStatic' MethodTypeArguments' polyRef.ValueParameters' polyRef.Result); " is 138.
Long Statement,Microsoft.LiveLabs.CST,PropertyRef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberRef.cs,PrimSubstitute,The length of the statement  "	return new PropertyRef (Annotations' DefiningType.PrimSubstitute (typeBoundArguments' methodBoundArguments)' signature); " is 120.
Long Statement,Microsoft.LiveLabs.CST,MessageContextBuilders,C:\repos\Reactive-Extensions_IL2JS\CST\MessageContextBuilders.cs,Member,The length of the statement  "	return new MessageContext (parent' memberDef.Loc' sb => CSTWriter.WithAppend (sb' global' WriterStyle.Debug' memberDef.PrimReference (global' assemblyDef' typeDef' null).Append)); " is 179.
Long Statement,Microsoft.LiveLabs.CST,MessageContextBuilders,C:\repos\Reactive-Extensions_IL2JS\CST\MessageContextBuilders.cs,Member,The length of the statement  "	return new MessageContext (parent' memberRef.Loc' sb => CSTWriter.WithAppend (sb' global' WriterStyle.Debug' memberRef.Append)); " is 128.
Long Statement,Microsoft.LiveLabs.CST,MessageContextBuilders,C:\repos\Reactive-Extensions_IL2JS\CST\MessageContextBuilders.cs,Env,The length of the statement  "	return new MessageContext (parent' assmEnv.Loc' sb => CSTWriter.WithAppend (sb' assmEnv.Global' WriterStyle.Debug' assmEnv.Append)); " is 132.
Long Statement,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,Append,The length of the statement  "	if (w.Global.AssemblyNameResolution == AssemblyNameResolution.Full || w.Global.AssemblyNameResolution == AssemblyNameResolution.NameVersion) { " is 142.
Long Statement,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,Equals,The length of the statement  "	if (MajorVersion != other.MajorVersion || MinorVersion != other.MinorVersion || BuildNumber != other.BuildNumber || RevisionNumber != other.RevisionNumber) " is 155.
Long Statement,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,FromReflectionName,The length of the statement  "	return new AssemblyName (resolution' name' majorVersion' minorVersion' buildNumber' revisionNumber' culture' publicKeyToken); " is 125.
Long Statement,Microsoft.LiveLabs.CST,AssemblyNameSubstitution,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,Add,The length of the statement  "		if ((existTarget == null && target != null) || (existTarget != null && target == null) || (existTarget != null && !existTarget.Equals (target))) { " is 146.
Long Statement,Microsoft.LiveLabs.CST,DllLoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,AssemblyNameFromAssemblyRow,The length of the statement  "	return new AssemblyName (resolution' row.Name.Value' row.MajorVersion' row.MinorVersion' row.BuildNumber' row.RevisionNumber' row.Culture.Value' row.PublicKey.Value); " is 166.
Long Statement,Microsoft.LiveLabs.CST,LoadedAssemblyDatabase,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,Add,The length of the statement  "				Log (new CompilingAugmentedAssemblyMessage (dllInfo.AssemblyName' dllInfo.CanonicalFileName' target' dllInfos.Select (i => i.CanonicalFileName).ToSeq ())); " is 155.
Long Statement,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,AssemblyNameFromAssemblyRefRow,The length of the statement  "		res = new AssemblyName (loadedAssemblies.Resolution' row.Name.Value' row.MajorVersion' row.MinorVersion' row.BuildNumber' row.RevisionNumber' row.Culture.Value' row.PublicKeyOrToken.Value); " is 189.
Long Statement,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeRefFromTypeSig,The length of the statement  "		return global.UnmanagedPointerTypeConstructorRef.ApplyTo (TypeRefFromTypeSigWithCustomMods (ctxt' unmanPtrSig.ElementType)); " is 124.
Long Statement,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeRefFromTypeSig,The length of the statement  "		return global.ManagedPointerTypeConstructorRef.ApplyTo (annotations' TypeRefFromTypeSig (ctxt' null' manPtrSig.ElementType' true)); " is 131.
Long Statement,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeRefFromTypeSig,The length of the statement  "		return global.ArrayTypeConstructorRef.ApplyTo (annotations' TypeRefFromTypeSigWithCustomMods (ctxt' arrayTypeSig.ElementType)); " is 127.
Long Statement,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,ArgsAndResultFromMethodSig,The length of the statement  "	if (definingTypeRef.Arguments.Count == 1 && !isStatic && (name.Equals ("Set"' StringComparison.Ordinal) || name.Equals ("Get"' StringComparison.Ordinal)) && valParams != null) { " is 177.
Long Statement,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,ArgsAndResultFromMethodSig,The length of the statement  "			if (name.Equals ("Set"' StringComparison.Ordinal) && valParams.Count == 2 + bounds.Rank && valParams [valParams.Count - 1].Equals (definingTypeRef.Arguments [0])) { " is 164.
Long Statement,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,ArgsAndResultFromMethodSig,The length of the statement  "			else if (name.Equals ("Get"' StringComparison.Ordinal) && valParams.Count == 1 + bounds.Rank && result != null && result.Equals (definingTypeRef.Arguments [0])) { " is 162.
Long Statement,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,MethodRefFromRowWithTypeArgs,The length of the statement  "		res = (MethodRef)MethodRefFromMethodSig (ctxt' definingTypeRef' methodDefRow.Name.Value' isStatic' methodBoundArguments' -1' methodSig); " is 136.
Long Statement,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,MethodRefFromRowWithTypeArgs,The length of the statement  "		res = (MethodRef)MethodRefFromMethodSig (ctxt' definingTypeRef' memberRefRow.Name.Value' methodSig.IsStatic' methodBoundArguments' -1' methodSig); " is 146.
Long Statement,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,PolymorphicMethodRefFromRow,The length of the statement  "			res = (PolymorphicMethodRef)MethodRefFromMethodSig (ctxt' definingTypeRef' methodDefRow.Name.Value' isStatic' null' methodSig.TypeArity' methodSig); " is 148.
Long Statement,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,PolymorphicMethodRefFromRow,The length of the statement  "			res = (PolymorphicMethodRef)MethodRefFromMethodSig (ctxt' definingTypeRef' memberRefRow.Name.Value' methodSig.IsStatic' null' methodSig.TypeArity' methodSig); " is 158.
Long Statement,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,MethodDefFromRow,The length of the statement  "	annotations.Add (new MethodOverriddingControlAnnotation ((row.Flags & PE.MethodAttributes.Final) != 0' (row.Flags & PE.MethodAttributes.HideBySig) != 0' (row.Flags & PE.MethodAttributes.Strict) != 0)); " is 201.
Long Statement,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,MethodDefFromRow,The length of the statement  "	annotations.Add (new MethodSecurityAnnotation ((row.Flags & PE.MethodAttributes.HasSecurity) != 0' (row.Flags & PE.MethodAttributes.RequireSecObject) != 0)); " is 157.
Long Statement,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,MethodDefFromRow,The length of the statement  "	if ((row.Flags & PE.MethodAttributes.SpecialName) != 0 && (row.Flags & PE.MethodAttributes.RTSpecialName) != 0 && (row.Name.Value.Equals (".ctor"' StringComparison.Ordinal) || row.Name.Value.Equals (".cctor"' StringComparison.Ordinal))) " is 236.
Long Statement,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,MethodDefFromRow,The length of the statement  "				var paramOrLocal = new ParameterOrLocalOrResult (lvAnnotations' null' TypeRefFromTypeSigWithCustomMods (ctxt' lv.Type)); " is 120.
Long Statement,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,MethodDefFromRow,The length of the statement  "	var methodDef = new MethodDef (annotations' null' name' isStatic' typeParameters' valueParameters' result' methodStyle' hasNewSlot' codeFlavor' isSyncronized' noInlining' isInitLocals' locals' methodBody); " is 205.
Long Statement,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The length of the statement  "	if (extends != null && (extends.Equals (global.EnumRef) || (!thisTypeRef.Equals (global.EnumRef) && extends.Equals (global.ValueTypeRef)))) " is 139.
Long Statement,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The length of the statement  "		explicitInterfaceImplementations.Add (PolymorphicMethodRefFromRow (ctxt' r.MethodDeclaration.Value)' PolymorphicMethodRefFromRow (ctxt' r.MethodBody.Value)); " is 157.
Long Statement,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The length of the statement  "				res = new NumberTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' numberFlavor' explicitInterfaceImplementations' isCallStaticConstructorEarly); " is 174.
Long Statement,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The length of the statement  "				res = new HandleTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' handleFlavor' explicitInterfaceImplementations' isCallStaticConstructorEarly); " is 174.
Long Statement,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The length of the statement  "				res = new VoidTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly); " is 158.
Long Statement,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The length of the statement  "				res = new ObjectTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly); " is 160.
Long Statement,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The length of the statement  "				res = new StringTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly); " is 160.
Long Statement,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The length of the statement  "		else if (qtn.Equals (global.EnumRef.QualifiedTypeName) || qtn.Equals (global.ValueTypeRef.QualifiedTypeName) || qtn.Equals (global.DelegateRef.QualifiedTypeName) || qtn.Equals (global.MulticastDelegateRef.QualifiedTypeName) || qtn.Equals (global.ObjectRef.QualifiedTypeName)) " is 275.
Long Statement,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The length of the statement  "			res = new ClassTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isSealed' isAbstract' isCallStaticConstructorEarly); " is 181.
Long Statement,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The length of the statement  "			res = new NullableTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly); " is 162.
Long Statement,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The length of the statement  "				var invokeDef = members.OfType<MethodDef> ().Where (m => !m.IsStatic && m.Name.Equals ("Invoke"' StringComparison.Ordinal)).FirstOrDefault (); " is 142.
Long Statement,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The length of the statement  "				var ctorDef = members.OfType<MethodDef> ().Where (m => !m.IsStatic && m.IsConstructor && m.Arity == 3).FirstOrDefault (); " is 121.
Long Statement,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The length of the statement  "					new ParameterOrLocalOrResult (ctorDef.ValueParameters [2].Annotations' ctorDef.ValueParameters [2].CustomAttributes' codePointer) " is 129.
Long Statement,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The length of the statement  "				var newCtorDef = new MethodDef (ctorDef.Annotations' ctorDef.CustomAttributes' ctorDef.Name' ctorDef.IsStatic' ctorDef.TypeParameters' newCtorParams' ctorDef.Result' ctorDef.MethodStyle' ctorDef.HasNewSlot' ctorDef.CodeFlavor' ctorDef.IsSyncronized' ctorDef.NoInlining' ctorDef.IsInitLocals' ctorDef.Locals' ctorDef.MethodBody); " is 328.
Long Statement,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The length of the statement  "				res = new DelegateTypeDef (annotations' null' extends' implements' parameters' qtn.Type' newMembers' explicitInterfaceImplementations' isCallStaticConstructorEarly); " is 165.
Long Statement,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The length of the statement  "				res = new EnumTypeDef (annotations' null' extends' implements' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly); " is 146.
Long Statement,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The length of the statement  "				res = new StructTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly); " is 160.
Long Statement,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The length of the statement  "				res = new ClassTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isSealed' isAbstract' isCallStaticConstructorEarly); " is 181.
Long Statement,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The length of the statement  "			res = new ClassTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isSealed' isAbstract' isCallStaticConstructorEarly); " is 181.
Long Statement,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,MergeAssemblyDefs,The length of the statement  "	assmLoadContext.AssemblyDef = new AssemblyDef (global' annotations' null' assmLoadContext.TargetAssemblyName' references' types' entryPoint); " is 141.
Long Statement,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeRefToPropertyTypeName,The length of the statement  "		throw new InvalidOperationException ("only types without type arguments may be used as custom attribute property types"); " is 121.
Long Statement,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,CustomAttributeFromRow,The length of the statement  "	log (new InvalidCustomAttribute (null' info.AssemblyName' ctor.DefiningType' "Attribute type or one of its property types is not available")); " is 142.
Long Statement,Microsoft.LiveLabs.CST,MethodSignature,C:\repos\Reactive-Extensions_IL2JS\CST\Signature.cs,Equals,The length of the statement  "	if (IsStatic != otherMeth.IsStatic || TypeArity != otherMeth.TypeArity || Parameters.Count != otherMeth.Parameters.Count) " is 121.
Long Statement,Microsoft.LiveLabs.CST,MethodSignature,C:\repos\Reactive-Extensions_IL2JS\CST\Signature.cs,Fixup,The length of the statement  "				newValueParameters.Add (TypeRef.CodePointerFrom (global' delTypeDef.ValueParameters.Select (p => p.Type).ToSeq ()' delTypeDef.Result == null ? null : delTypeDef.Result.Type)); " is 175.
Long Statement,Microsoft.LiveLabs.CST,MethodSignature,C:\repos\Reactive-Extensions_IL2JS\CST\Signature.cs,AccumUsedTypeDefs,The length of the statement  "	return Parameters.Select (p => p.AccumUsedTypeDefs (vctxt' ctxt' usedTypes)).FirstOrDefault (v => v != null) ?? (Result == null ? null : Result.AccumUsedTypeDefs (vctxt' ctxt' usedTypes)); " is 188.
Long Statement,Microsoft.LiveLabs.CST,MethodSignature,C:\repos\Reactive-Extensions_IL2JS\CST\Signature.cs,CheckValid,The length of the statement  "	return Parameters.Select (p => p.CheckValid (vctxt' ctxt' rootEnv)).FirstOrDefault (v => v != null) ?? (Result == null ? null : Result.CheckValid (vctxt' ctxt' rootEnv)); " is 170.
Long Statement,Microsoft.LiveLabs.CST,PropertySignature,C:\repos\Reactive-Extensions_IL2JS\CST\Signature.cs,AccumUsedTypeDefs,The length of the statement  "	return Parameters.Select (p => p.AccumUsedTypeDefs (vctxt' ctxt' usedTypes)).FirstOrDefault (v => v != null) ?? Result.AccumUsedTypeDefs (vctxt' ctxt' usedTypes); " is 162.
Long Statement,Microsoft.LiveLabs.CST,PropertySignature,C:\repos\Reactive-Extensions_IL2JS\CST\Signature.cs,CheckValid,The length of the statement  "	return Parameters.Select (p => p.CheckValid (vctxt' ctxt' rootEnv)).FirstOrDefault (v => v != null) ?? Result.CheckValid (vctxt' ctxt' rootEnv); " is 144.
Long Statement,Microsoft.LiveLabs.CST,SimplifierContext,C:\repos\Reactive-Extensions_IL2JS\CST\SimplifierContext.cs,InSubMethod,The length of the statement  "	return new SimplifierContext (CompEnv' NameSupply' subst.ToMap ()' new Seq<Statement> ()' JST.Effects.Bottom' Database' Trace); " is 127.
Long Statement,Microsoft.LiveLabs.CST,ValidityContext,C:\repos\Reactive-Extensions_IL2JS\CST\Validity.cs,PropogateInvalidity,The length of the statement  "						invalid = new InvalidInfo (MessageContextBuilders.Member (Global' sccAssemblyDef' sccTypeDef' sccMemberDef)' sccMemberDef.Invalid); " is 131.
Long Statement,Microsoft.LiveLabs.CST,ValidityContext,C:\repos\Reactive-Extensions_IL2JS\CST\Validity.cs,Stats,The length of the statement  "		tracer.AppendLine (String.Format ("{0}: {1} assemblies' {2} types ({3} valid' {4} used)' {5} members ({6} valid' {7} used)"' msg' nAssemblies' nTypes' nValidTypes' nUsedTypes' nMembers' nValidMembers' nUsedMembers)); " is 216.
Long Statement,Microsoft.LiveLabs.CST,ValidityContext,C:\repos\Reactive-Extensions_IL2JS\CST\Validity.cs,Check,The length of the statement  "			//  - virtual/iface method must have a def and used implementing type => used override/impl methods of that type must have a def " is 128.
Long Statement,Microsoft.LiveLabs.CST,ValidityContext,C:\repos\Reactive-Extensions_IL2JS\CST\Validity.cs,Check,The length of the statement  "										methodDef.Invalid = new CST.InvalidInfo (MessageContextBuilders.Member (Global' implAssemblyDef' implTypeDef' implMemberDef)' implMemberDef.Invalid); " is 149.
Long Statement,Microsoft.LiveLabs.CST,ValidityContext,C:\repos\Reactive-Extensions_IL2JS\CST\Validity.cs,Check,The length of the statement  "					Log (new UnimplementableRootMethodMessage (MessageContextBuilders.Member (Global' assemblyDef' typeDef' memberDef)' memberDef.Invalid)); " is 136.
Long Statement,Microsoft.LiveLabs.CST,Variable,C:\repos\Reactive-Extensions_IL2JS\CST\Variable.cs,Equals,The length of the statement  "	return Id.Equals (other.Id) && ArgLocal == other.ArgLocal && IsInit == other.IsInit && IsReadOnly == other.IsReadOnly && Type.Equals (other.Type); " is 146.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "			return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' UnaryOp.CheckFinite' false' false)' e.Lub (ThrowsE))); " is 165.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "			return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ReadExpression (a [0]).CloneIfStruct (compEnv)' e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ()))); " is 200.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "			return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' true).Read ().CloneIfStruct (compEnv)' e.Lub (ReadHeapOrThrowE))); " is 180.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "			return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' UnaryOp.Length' false' false)' e.Lub (ReadHeapOrThrowE))); " is 169.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "			return stack.PopEvalSE (statements' 2' true' instruction.BeforeState.PeekPointsTo (1).WriteEffect ()' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' a [1])))); " is 182.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "			return stack.PopEvalSE (statements' 3' true' WriteHeapOrThrowE' (s' a) => s.Add (new ExpressionStatement (new ElementCell (a [0]' a [1]' false).Write (a [2])))); " is 161.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "			return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' unop' false' cmpi.IsUnsigned)' e)); " is 146.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "			return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new BinaryExpression (a [0]' binop' a [1]' false' cmpi.IsUnsigned)' e)); " is 155.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "			return stack.PopEvalSE (statements' 1' true' WriteArgLocalE (sli.ArgLocal' sli.Index)' (s' a) => s.Add (new ExpressionStatement (cell.Write (a [0])))); " is 151.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "				stack.Push (new ExpressionStackEntry (new FieldCell (null' compEnv.SubstituteMember (fieldi.Field)).Read ().CloneIfStruct (compEnv)' ReadHeapE)); " is 145.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "					return new ExpressionStackEntry (new FieldCell (obj' compEnv.SubstituteMember (fieldi.Field)).Read ().CloneIfStruct (compEnv)' readEffect); " is 139.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "				stack.Push (new ExpressionStackEntry (new FieldCell (null' compEnv.SubstituteMember (fieldi.Field)).AddressOf ()' BottomE)); " is 124.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "						return new ExpressionStackEntry (new FieldCell (new ReadExpression (a [0])' compEnv.SubstituteMember (fieldi.Field)).AddressOf ()' e); " is 134.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "						return new ExpressionStackEntry (new FieldCell (a [0]' compEnv.SubstituteMember (fieldi.Field)).AddressOf ()' e.Lub (ThrowsE)); " is 127.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "				return stack.PopEvalSE (statements' 1' true' WriteHeapE' (s' a) => s.Add (new ExpressionStatement (new FieldCell (null' compEnv.SubstituteMember (fieldi.Field)).Write (a [0])))); " is 178.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "				var writeEffect = fieldi.IsViaPointer.Value ? instruction.BeforeState.PeekPointsTo (1).WriteEffect () : WriteHeapOrThrowE; " is 122.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "			stack.Push (new ExpressionStackEntry (new FieldHandleConstantExpression (compEnv.SubstituteMember (fieldi.Field))' BottomE)); " is 125.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "				return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new CodePointerExpression (a [0]' compEnv.SubstituteMember (methodi.Method))' e.Lub (ReadHeapOrThrowE))); " is 188.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "				stack.Push (new ExpressionStackEntry (new CodePointerExpression (null' compEnv.SubstituteMember (methodi.Method))' BottomE)); " is 125.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "				return stack.PopEvalSE (statements' arity' true' CalleeEffects (methodi.BeforeState' arity)' (s' a) => s.Add (new ExpressionStatement (new CallExpression (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal' compEnv.SubstituteMember (methodi.Method)' CallerArguments (methodi.Constrained' methodi.Method' a))))); " is 319.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "				return stack.PopEvalPush (statements' arity' true' (a' e) => new ExpressionStackEntry (new CallExpression (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal' compEnv.SubstituteMember (methodi.Method)' CallerArguments (methodi.Constrained' methodi.Method' a))' e.Lub (CalleeEffects (methodi.BeforeState' arity)))); " is 322.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "			return stack.PopEvalPush (statements' arity' true' (a' e) => new ExpressionStackEntry (new NewObjectExpression (compEnv.SubstituteMember (methodi.Method)' CallerArguments (null' methodi.Method' a))' e.Lub (CalleeEffects (methodi.BeforeState' arity)))); " is 252.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "			stack.Push (new ExpressionStackEntry (new MethodHandleConstantExpression (compEnv.SubstituteMember (methodi.Method))' BottomE)); " is 128.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "			return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ReadExpression (a [0]).CloneIfStruct (compEnv)' e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ()))); " is 200.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "			return stack.PopEvalSE (statements' 2' true' instruction.BeforeState.PeekPointsTo (1).WriteEffect ()' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' a [1])))); " is 182.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "			var copyEffect = instruction.BeforeState.PeekPointsTo (0).ReadEffect ().Lub (instruction.BeforeState.PeekPointsTo (1).WriteEffect ()); " is 134.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "			return stack.PopEvalSE (statements' 2' true' copyEffect' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' new ReadExpression (a [1]).CloneIfStruct (compEnv))))); " is 182.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "			return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new NewArrayExpression (a [0]' compEnv.SubstituteType (typei.Type))' e.Lub (ThrowsE))); " is 170.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "			return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new CastExpression (a [0]' compEnv.SubstituteType (typei.Type))' e.Lub (ThrowsE))); " is 166.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "			return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new IsInstExpression (a [0]' compEnv.SubstituteType (typei.Type))' e)); " is 154.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "			return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new NewBoxExpression (a [0]' compEnv.SubstituteType (typei.Type))' e)); " is 154.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "			return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new BoxCell (a [0]' compEnv.SubstituteType (typei.Type)).AddressOf ()' e.Lub (ThrowsE))); " is 172.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "			return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new BoxCell (a [0]' compEnv.SubstituteType (typei.Type)).Read ().CloneIfStruct (compEnv)' e.Lub (ThrowsE))); " is 191.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "			stack.Push (new ExpressionStackEntry (new TypeHandleConstantExpression (compEnv.SubstituteType (typei.Type))' BottomE)); " is 120.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "			return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' true).Read ().CloneIfStruct (compEnv)' e.Lub (ReadHeapOrThrowE))); " is 180.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "			return stack.PopEvalSE (statements' 3' true' WriteHeapOrThrowE' (s' a) => s.Add (new ExpressionStatement (new ElementCell (a [0]' a [1]' false).Write (a [2])))); " is 161.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' false).AddressOf ()' e.Lub (ThrowsE))); " is 153.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "			return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new BinaryExpression (a [0]' ArithOpToBinaryOp (arithi.Op)' a [1]' arithi.WithOverflow' arithi.IsUnsigned)' e.Lub (ThrowsE))); " is 209.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "			return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new BinaryExpression (a [0]' ArithOpToBinaryOp (arithi.Op)' a [1]' arithi.WithOverflow' arithi.IsUnsigned)' e.Lub (arithi.WithOverflow ? ThrowsE : BottomE))); " is 241.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "			return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' ArithOpToUnaryOp (arithi.Op)' arithi.WithOverflow' arithi.IsUnsigned)' e)); " is 186.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ConvertExpression (a [0]' new NamedTypeRef (compEnv.Global.NumberFlavorToQualifiedTypeName [convi.TargetNumberFlavor])' convi.WithOverflow' convi.IsSourceUnsigned)' e.Lub (convi.WithOverflow ? ThrowsE : BottomE))); " is 301.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "					return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new IfThenElseExpression (a [0]' thenEntry.Expression' elseEntry.Expression)' e.Lub (thenEntry.Effects.Lub (elseEntry.Effects)))); " is 213.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "		statements.Add (new IfThenElseStatement (condEntry.Expression' new Statements (thenStmnts)' elseStmnts == null ? null : new Statements (elseStmnts))); " is 150.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "					stack.Push (new ExpressionStackEntry (new BinaryExpression (leftEntry.Expression' ShortCircuitingOpToBinaryOp (sci.Op)' rightEntry.Expression' false' false)' leftEntry.Effects.Lub (rightEntry.Effects))); " is 203.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "			statements.Add (new IfThenElseStatement (leftEntry2.Expression' new Statements (rightStatements)' new Statements (new ExpressionStatement (cell.Write (new Int32ConstantExpression (0)))))); " is 188.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "			statements.Add (new IfThenElseStatement (leftEntry2.Expression' new Statements (new ExpressionStatement (cell.Write (new Int32ConstantExpression (1))))' new Statements (rightStatements))); " is 188.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "			preCondStatements.Add (new IfThenElseStatement (condEntry.Expression' new Statements (postCondStatements)' new Statements (new BreakStatement ()))); " is 148.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "		var loopStatements = BlockToConditionStatements (new Instructions (null' combined)' dwi.Body.BeforeState' exid' out condEntry); " is 127.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "			if (labelToLoopCandidateContinueState != null && labelToLoopCandidateContinueState.TryGetValue (lci.Label' out targetState)) " is 124.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,CaseBody,The length of the statement  "		var statements = BlockToConditionStatements (new Instructions (null' cond)' branchbb.Target.Block.BeforeState' exid' out condEntry); " is 132.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,CaseBody,The length of the statement  "		statements.Add (new IfThenElseStatement (condEntry.Expression' CaseBodyOrGoto (stateMap' branchbb.Target' exid)' CaseBodyOrGoto (stateMap' branchbb.Fallthrough' exid))); " is 169.
Long Statement,Microsoft.LiveLabs.CST,TypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimAreValidArguments,The length of the statement  "		vctxt.Log (new InvalidTypeRef (ctxt' originalType' String.Format ("Type has {0} type parameters but is given {1} type arguments"' Parameters.Count' groundTypeBoundArguments.Count))); " is 182.
Long Statement,Microsoft.LiveLabs.CST,TypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimAreValidArguments,The length of the statement  "	return Parameters.All (p => p.PrimIsValidParameterBinding (vctxt' ctxt' originalType' groundEnv' groundTypeBoundArguments' Constants.EmptyTypeRefs' InCodePointer)); " is 164.
Long Statement,Microsoft.LiveLabs.CST,TypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceIsAssignableTo,The length of the statement  "			return implEnv.Type.PrimInstanceIsAssignableTo (groundEnv' implEnv.Assembly' groundImplements.Arguments' otherAssembly' otherDef' otherGroundTypeBoundArguments); " is 161.
Long Statement,Microsoft.LiveLabs.CST,TypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceIsAssignableTo,The length of the statement  "		if (extendsEnv.Type.PrimInstanceIsAssignableTo (groundEnv' extendsEnv.Assembly' groundExtends.Arguments' otherAssembly' otherDef' otherGroundTypeBoundArguments)) " is 161.
Long Statement,Microsoft.LiveLabs.CST,CodePointerTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimIsSameDefinition,The length of the statement  "	return otherCodePointerDef != null && CodePointerFlavor == otherCodePointerDef.CodePointerFlavor && parameters.Count == otherCodePointerDef.parameters.Count; " is 157.
Long Statement,Microsoft.LiveLabs.CST,CodePointerTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceRespectsParameterConstraint,The length of the statement  "		vctxt.Log (new InvalidTypeRef (ctxt' originalType' "A code pointer type cannot be used to instantiate a type parameter")); " is 122.
Long Statement,Microsoft.LiveLabs.CST,ArrayTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceRespectsParameterConstraint,The length of the statement  "		vctxt.Log (new InvalidTypeRef (ctxt' originalType' "An array type cannot be used to instantiate a type parameter with a value-type or constructor constraint")); " is 160.
Long Statement,Microsoft.LiveLabs.CST,MultiDimArrayTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceRespectsParameterConstraint,The length of the statement  "		vctxt.Log (new InvalidTypeRef (ctxt' originalType' "A multi-dimensional array type cannot be used to instantiate a type parameter with a value-type or constructor constraint")); " is 177.
Long Statement,Microsoft.LiveLabs.CST,MultiDimArrayTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceIsAssignableTo,The length of the statement  "		return base.PrimInstanceIsAssignableTo (groundEnv' thisAssembly' thisGroundTypeBoundArguments' otherAssembly' otherDef' otherGroundTypeBoundArguments); " is 151.
Long Statement,Microsoft.LiveLabs.CST,DerivingTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceRespectsParameterConstraint,The length of the statement  "			vctxt.Log (new InvalidTypeRef (ctxt' originalType' "Type does not extend a type which respects the type parameter constraint")); " is 128.
Long Statement,Microsoft.LiveLabs.CST,ParameterTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimIsSameDefinition,The length of the statement  "	return otherParameterDef != null && ParameterFlavor == otherParameterDef.ParameterFlavor && Index == otherParameterDef.Index; " is 125.
Long Statement,Microsoft.LiveLabs.CST,ParameterTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceRespectsParameterConstraint,The length of the statement  "	return base.PrimInstanceRespectsParameterConstraint (vctxt' ctxt' originalType' groundEnv' groundTypeBoundArguments' constraint' inCodePointer); " is 144.
Long Statement,Microsoft.LiveLabs.CST,ParameterTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimIsValidParameterBinding,The length of the statement  "	if (!boundTypeEnv.Type.PrimInstanceRespectsParameterConstraint (vctxt' ctxt' originalType' groundEnv' boundGroundArguments' Constraint' inCodePointer)) { " is 153.
Long Statement,Microsoft.LiveLabs.CST,ParameterTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimIsValidParameterBinding,The length of the statement  "		vctxt.Log (new InvalidTypeRef (ctxt' originalType' String.Format ("{0} type argument {1} does not respect parameter's constraint"' which' Index))); " is 147.
Long Statement,Microsoft.LiveLabs.CST,ParameterTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimIsValidParameterBinding,The length of the statement  "				vctxt.Log (new InvalidTypeRef (ctxt' originalType' String.Format ("{0} type argument {1} does not extend the type required by the parameter"' which' Index))); " is 158.
Long Statement,Microsoft.LiveLabs.CST,ParameterTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimIsValidParameterBinding,The length of the statement  "			vctxt.Log (new InvalidTypeRef (ctxt' originalType' String.Format ("{0} type argument {1} does not implement an interface required by the parameter"' which' Index))); " is 165.
Long Statement,Microsoft.LiveLabs.CST,ParameterTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimSubstitute,The length of the statement  "	return new ParameterTypeDef (Annotations' CustomAttributes' Extends == null ? null : Extends.PrimSubstitute (typeBoundArguments' methodBoundArguments)' Implements.Select (i => i.PrimSubstitute (typeBoundArguments' methodBoundArguments)).ToSeq ()' ParameterFlavor' Index' Variance' Constraint); " is 293.
Long Statement,Microsoft.LiveLabs.CST,NamedTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,HasDefaultConstructor,The length of the statement  "	return Style is ValueTypeStyle || Members.Any (m => m.Flavor == MemberDefFlavor.Method && m.MethodStyle == MethodStyle.Constructor && m.Arity == 1); " is 148.
Long Statement,Microsoft.LiveLabs.CST,RealTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,ImplementingMethod,The length of the statement  "		if (slotRef.DefiningType.Equals (interfaceMethodRef.DefiningType) && slotRef.ExternalSignature.WithoutThis ().Equals (interfaceMethodSig)) " is 138.
Long Statement,Microsoft.LiveLabs.CST,NullableTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceRespectsParameterConstraint,The length of the statement  "		vctxt.Log (new InvalidTypeRef (ctxt' originalType' "Nullable type cannot be used to instantiate a type parameter with the value type constraint")); " is 147.
Long Statement,Microsoft.LiveLabs.CST,NullableTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceRespectsParameterConstraint,The length of the statement  "	return base.PrimInstanceRespectsParameterConstraint (vctxt' ctxt' originalType' groundEnv' groundTypeBoundArguments' constraint' inCodePointer); " is 144.
Long Statement,Microsoft.LiveLabs.CST,EnumTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,AccumUsedTypeDefs,The length of the statement  "	Invalid = Implementation.AccumUsedTypeDefs (vctxt' MessageContextBuilders.Type (vctxt.Global' assemblyDef' this)' usedTypes); " is 125.
Long Statement,Microsoft.LiveLabs.CST,DelegateTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,HasParamsArray,The length of the statement  "		return p.Type.Style (rootEnv) is ArrayTypeStyle && p.CustomAttributes.Any (attr => attr.Type.Equals (rootEnv.Global.ParamArrayAttributeRef)); " is 141.
Long Statement,Microsoft.LiveLabs.CST,InterfaceTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceIsAssignableTo,The length of the statement  "		return base.PrimInstanceIsAssignableTo (groundEnv' thisAssembly' thisTypeArguments' otherAssembly' otherDef' otherTypeArguments); " is 129.
Long Statement,Microsoft.LiveLabs.CST,TypeRef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeRef.cs,PrimIsAssignableTo,The length of the statement  "	return thisTypeEnv.Type.PrimInstanceIsAssignableTo (groundEnv' thisTypeEnv.Assembly' Arguments' otherTypeEnv.Assembly' otherTypeEnv.Type' otherGround.Arguments); " is 161.
Long Statement,Microsoft.LiveLabs.CST,TypeRef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeRef.cs,IsAssignableTo,The length of the statement  "	return thisTypeEnv.Type.PrimInstanceIsAssignableTo (rootEnv.ToGround ()' thisTypeEnv.Assembly' thisTypeEnv.TypeBoundArguments' otherTypeEnv.Assembly' otherTypeEnv.Type' otherTypeEnv.TypeBoundArguments); " is 202.
Long Statement,Microsoft.LiveLabs.CST,TypeRef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeRef.cs,CodePointerFrom,The length of the statement  "		return new NamedTypeRef (global.CodePointerTypeConstructorName (CodePointerFlavor.Function' allArguments.Count)' allArguments); " is 127.
Long Statement,Microsoft.LiveLabs.CST,NamedTypeRef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeRef.cs,PrimSubstitute,The length of the statement  "	return new NamedTypeRef (Annotations' name' arguments.Select (t => t.PrimSubstitute (typeBoundArguments' methodBoundArguments)).ToSeq ()); " is 138.
Long Statement,Microsoft.LiveLabs.CST,CSTWriter,C:\repos\Reactive-Extensions_IL2JS\CST\Writer.cs,AppendMnemonicFileName,The length of the statement  "	var nm = val.Replace ('.'' '_').Replace ('/'' '_').Replace ('+'' '_').Replace ("`"' "").Replace ("<"' "").Replace (">"' ""); " is 124.
Long Statement,Microsoft.LiveLabs.CST,CSTWriter,C:\repos\Reactive-Extensions_IL2JS\CST\Writer.cs,AppendMnemonicIdentifier,The length of the statement  "	var nm = val.Replace ('.'' '_').Replace ('/'' '_').Replace ('+'' '_').Replace ("`"' "").Replace ("<"' "").Replace (">"' ""); " is 124.
Complex Conditional,Microsoft.LiveLabs.CST,BBLoop,C:\repos\Reactive-Extensions_IL2JS\CST\BasicBlockUtils.cs,BBLoop,The conditional expression  "headEscapes && tailEscapes && headbranchbb != null && tailbranchbb != null"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,FieldCell,C:\repos\Reactive-Extensions_IL2JS\CST\Cell.cs,EqualBody,The conditional expression  "Object == null && field.Object != null || Object != null && field.Object == null"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceBranch,The conditional expression  "thenbb != null && thenbb.Target.Equals (branchbb) && thenbb.Sources.Count == 1 && group.Add (thenbb) && !group.Contains (branchbb.Fallthrough)"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceBranch,The conditional expression  "elsebb != null && elsebb.Target.Equals (branchbb) && elsebb.Sources.Count == 1 && group.Add (elsebb) && !group.Contains (branchbb.Target)"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceBranch,The conditional expression  "thenbb != null && elsebb != null && thenbb.Target.Equals (elsebb.Target) && elsebb.Sources.Count == 1 && group.Add (elsebb) && !group.Contains (thenbb) && !group.Contains (thenbb.Target) && !thenbb.Target.Equals (thenbb) && IsLoadBooleanBlock (thenbb.Block)"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceBranch,The conditional expression  "thenbb != null && elsebb != null && thenbb.Target.Equals (elsebb.Target) && thenbb.Sources.Count == 1 && group.Add (thenbb) && !group.Contains (elsebb) && !group.Contains (elsebb.Target) && !elsebb.Target.Equals (elsebb) && IsLoadBooleanBlock (elsebb.Block)"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceBranch,The conditional expression  "thenbb != null && branchbb.Fallthrough.Equals (thenbb.Fallthrough) && thenbb.Sources.Count == 1 && group.Add (thenbb) && !group.Contains (thenbb.Target) && !group.Contains (branchbb.Fallthrough)"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceBranch,The conditional expression  "elsebb != null && branchbb.Target.Equals (elsebb.Fallthrough) && elsebb.Sources.Count == 1 && group.Add (elsebb) && !group.Contains (elsebb.Target) && !group.Contains (branchbb.Target)"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceBranch,The conditional expression  "thenbb != null && branchbb.Fallthrough.Equals (thenbb.Target) && thenbb.Sources.Count == 1 && group.Add (thenbb) && !group.Contains (thenbb.Fallthrough) && !group.Contains (branchbb.Fallthrough)"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceBranch,The conditional expression  "elsebb != null && branchbb.Target.Equals (elsebb.Target) && elsebb.Sources.Count == 1 && group.Add (elsebb) && !group.Contains (elsebb.Fallthrough) && !group.Contains (branchbb.Target)"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceBranch,The conditional expression  "thenbb != null && elsebb != null && !branchbb.Equals (thenbb) && !branchbb.Equals (elsebb) && !thenbb.Equals (elsebb) && branchbb.Target.Sources.Count == 1 && branchbb.Fallthrough.Sources.Count == 1"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceBranch,The conditional expression  "group.Add (branchbb.Target) && group.Add (branchbb.Fallthrough) && branchbb.Target.Sources.Count == 1 && branchbb.Fallthrough.Sources.Count == 1 && branchbb.Target.HasSameExit (branchbb.Fallthrough)"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceLoopCandidate,The conditional expression  "(jumpheadbb != null && jumpheadbb.Target.Equals (loopbb.Break) || nonretheadbb != null) && group.Add (headbb) && !group.Contains (loopbb.Break)"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,Effects,C:\repos\Reactive-Extensions_IL2JS\CST\Domain.cs,Lub,The conditional expression  "args == null || locals == null || heap == null || mayThrow == null"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,Effects,C:\repos\Reactive-Extensions_IL2JS\CST\Domain.cs,Lub,The conditional expression  "args == null || locals == null || heap == null || mayThrow == null"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,CodePointerExpression,C:\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,EqualBody,The conditional expression  "Object == null && func.Object != null || Object != null && func.Object == null"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,Equals,The conditional expression  "MajorVersion != other.MajorVersion || MinorVersion != other.MinorVersion || BuildNumber != other.BuildNumber || RevisionNumber != other.RevisionNumber"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,AssemblyNameSubstitution,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,Add,The conditional expression  "(existTarget == null && target != null) || (existTarget != null && target == null) || (existTarget != null && !existTarget.Equals (target))"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,ArgsAndResultFromMethodSig,The conditional expression  "definingTypeRef.Arguments.Count == 1 && !isStatic && (name.Equals ("Set"' StringComparison.Ordinal) || name.Equals ("Get"' StringComparison.Ordinal)) && valParams != null"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,ArgsAndResultFromMethodSig,The conditional expression  "name.Equals ("Get"' StringComparison.Ordinal) && valParams.Count == 1 + bounds.Rank && result != null && result.Equals (definingTypeRef.Arguments [0])"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,MethodDefFromRow,The conditional expression  "(row.Flags & PE.MethodAttributes.SpecialName) != 0 && (row.Flags & PE.MethodAttributes.RTSpecialName) != 0 && (row.Name.Value.Equals (".ctor"' StringComparison.Ordinal) || row.Name.Value.Equals (".cctor"' StringComparison.Ordinal))"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The conditional expression  "extends != null && (extends.Equals (global.EnumRef) || (!thisTypeRef.Equals (global.EnumRef) && extends.Equals (global.ValueTypeRef)))"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The conditional expression  "qtn.Equals (global.EnumRef.QualifiedTypeName) || qtn.Equals (global.ValueTypeRef.QualifiedTypeName) || qtn.Equals (global.DelegateRef.QualifiedTypeName) || qtn.Equals (global.MulticastDelegateRef.QualifiedTypeName) || qtn.Equals (global.ObjectRef.QualifiedTypeName)"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,MethodSignature,C:\repos\Reactive-Extensions_IL2JS\CST\Signature.cs,Equals,The conditional expression  "Result == null && otherMeth.Result != null || Result != null && otherMeth.Result == null"  is complex.
Empty Catch Block,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,CustomAttributeFromRow,The method has an empty catch block.
Magic Number,Microsoft.LiveLabs.CST,Test,C:\repos\Reactive-Extensions_IL2JS\CST\BasicBlock.cs,Rot11,The following statement contains a magic number: return v << 11 | v >> 21;  
Magic Number,Microsoft.LiveLabs.CST,Test,C:\repos\Reactive-Extensions_IL2JS\CST\BasicBlock.cs,Rot11,The following statement contains a magic number: return v << 11 | v >> 21;  
Magic Number,Microsoft.LiveLabs.CST,Test,C:\repos\Reactive-Extensions_IL2JS\CST\BasicBlock.cs,GetHashCode,The following statement contains a magic number: res = Rot11 (res) ^ (uint)Op * 47;  
Magic Number,Microsoft.LiveLabs.CST,BBEdge,C:\repos\Reactive-Extensions_IL2JS\CST\BasicBlockUtils.cs,Rot17,The following statement contains a magic number: return (int)(((uint)v << 17) | ((uint)v >> 15));  
Magic Number,Microsoft.LiveLabs.CST,BBEdge,C:\repos\Reactive-Extensions_IL2JS\CST\BasicBlockUtils.cs,Rot17,The following statement contains a magic number: return (int)(((uint)v << 17) | ((uint)v >> 15));  
Magic Number,Microsoft.LiveLabs.CST,Constants,C:\repos\Reactive-Extensions_IL2JS\CST\Constants.cs,Rot3,The following statement contains a magic number: return v << 3 | v >> 29;  
Magic Number,Microsoft.LiveLabs.CST,Constants,C:\repos\Reactive-Extensions_IL2JS\CST\Constants.cs,Rot3,The following statement contains a magic number: return v << 3 | v >> 29;  
Magic Number,Microsoft.LiveLabs.CST,Constants,C:\repos\Reactive-Extensions_IL2JS\CST\Constants.cs,Rot7,The following statement contains a magic number: return v << 7 | v >> 25;  
Magic Number,Microsoft.LiveLabs.CST,Constants,C:\repos\Reactive-Extensions_IL2JS\CST\Constants.cs,Rot7,The following statement contains a magic number: return v << 7 | v >> 25;  
Magic Number,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,IsDuplicatableBasicBlock,The following statement contains a magic number: if (i == 0 && bb.Block.Count <= 2)  	// threshold of 2 instructions  	return true;  
Magic Number,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,Reduce,The following statement contains a magic number: if (tracer != null) {  	if (BasicBlockUtils.PostOrder (root).Count > 2)  		tracer.AppendLine ("WARNING: Did not reduce all control flow.");  	else  		tracer.AppendLine ("All control flow reduced.");  }  
Magic Number,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,Reduce,The following statement contains a magic number: if (BasicBlockUtils.PostOrder (root).Count > 2)  	tracer.AppendLine ("WARNING: Did not reduce all control flow.");  else  	tracer.AppendLine ("All control flow reduced.");  
Magic Number,Microsoft.LiveLabs.CST,Int64ConstantExpression,C:\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,GetHashCode,The following statement contains a magic number: res ^= (uint)((ulong)Value >> 32);  
Magic Number,Microsoft.LiveLabs.CST,Int64ConstantExpression,C:\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,GetHashCode,The following statement contains a magic number: res ^= (uint)((ulong)Value & ((1LU << 32) - 1));  
Magic Number,Microsoft.LiveLabs.CST,SingleConstantExpression,C:\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,GetHashCode,The following statement contains a magic number: res ^= (uint)(v >> 32);  
Magic Number,Microsoft.LiveLabs.CST,SingleConstantExpression,C:\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,GetHashCode,The following statement contains a magic number: res ^= (uint)(v & ((1UL << 32) - 1));  
Magic Number,Microsoft.LiveLabs.CST,DoubleConstantExpression,C:\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,GetHashCode,The following statement contains a magic number: res ^= (uint)(v >> 32);  
Magic Number,Microsoft.LiveLabs.CST,DoubleConstantExpression,C:\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,GetHashCode,The following statement contains a magic number: res ^= (uint)(v & ((1LU << 32) - 1));  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: while (!ctxt.AtEnd (i)) {  	var j = i > ctxt.Start ? ctxt.JumpOverHandlers (i) : i;  	if (j > i)  		i = j;  	else {  		var ehcs = ctxt.OutermostTryBlocks (i);  		if (ehcs != null) {  			// A try instruction begins here with given handlers  			var offset = ctxt.Instructions [i].Offset;  			var tryCtxt = new TryTranslationContext (ctxt' i' ehcs);  			var tryBlock = InstructionsFromContext (tryCtxt);  			var handlers = new Seq<TryInstructionHandler> ();  			foreach (var ehc in ehcs) {  				var handlerCtxt = new HandlerTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.HandlerOffset]' ehc);  				var handlerBlock = InstructionsFromContext (handlerCtxt);  				switch (ehc.Flags) {  				case PE.CorILExceptionClause.Exception:  					handlers.Add (new CatchTryInstructionHandler ((TypeRef)ehc.Class' handlerBlock));  					break;  				case PE.CorILExceptionClause.Filter: {  					var filterCtxt = new FilterTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.FilterOffset]' ehc);  					var filterBlock = InstructionsFromContext (filterCtxt);  					handlers.Add (new FilterTryInstructionHandler (filterBlock' handlerBlock));  					break;  				}  				case PE.CorILExceptionClause.Finally:  					handlers.Add (new FinallyTryInstructionHandler (handlerBlock));  					break;  				case PE.CorILExceptionClause.Fault:  					handlers.Add (new FaultTryInstructionHandler (handlerBlock));  					break;  				default:  					throw new ArgumentOutOfRangeException ();  				}  			}  			instructions.Add (new TryInstruction (offset' tryBlock' handlers));  			// Jump over try block  			var nextOffset = ehcs [0].TryOffset + ehcs [0].TryLength;  			if (!ctxt.OffsetToIndex.TryGetValue (nextOffset' out i))  				i = ctxt.Instructions.Length;  		}  		else {  			var instruction = ctxt.Instructions [i++];  			var offset = instruction.Offset;  			while (instruction.OpCode == PE.OpCode.Unaligned || instruction.OpCode == PE.OpCode.Volatile || instruction.OpCode == PE.OpCode.Tailcall) {  				// Skip over any ignored prefixes' but remember instruction begins at original offset  				// NOTE: What ever happened to the "no." prefix mentioned in the spec?  				if (i >= ctxt.Instructions.Length)  					throw new InvalidOperationException ("invalid instructions");  				instruction = ctxt.Instructions [i++];  			}  			switch (instruction.OpCode) {  			case PE.OpCode.Cpblk:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Cpblk));  				break;  			case PE.OpCode.Initblk:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Initblk));  				break;  			case PE.OpCode.Arglist:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Arglist));  				break;  			case PE.OpCode.Localloc:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Localloc));  				break;  			case PE.OpCode.Jmp:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Jmp));  				break;  			case PE.OpCode.Calli:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Calli));  				break;  			case PE.OpCode.Sizeof:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Sizeof));  				break;  			case PE.OpCode.Mkrefany:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Mkrefany));  				break;  			case PE.OpCode.Refanytype:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanytype));  				break;  			case PE.OpCode.Refanyval:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanyval));  				break;  			case PE.OpCode.Nop:  				instructions.Add (new MiscInstruction (offset' MiscOp.Nop));  				break;  			case PE.OpCode.Break:  				instructions.Add (new MiscInstruction (offset' MiscOp.Break));  				break;  			case PE.OpCode.Dup:  				instructions.Add (new MiscInstruction (offset' MiscOp.Dup));  				break;  			case PE.OpCode.Pop:  				instructions.Add (new MiscInstruction (offset' MiscOp.Pop));  				break;  			case PE.OpCode.Ldnull:  				instructions.Add (new MiscInstruction (offset' MiscOp.Ldnull));  				break;  			case PE.OpCode.Ckfinite:  				instructions.Add (new MiscInstruction (offset' MiscOp.Ckfinite));  				break;  			case PE.OpCode.Throw:  				instructions.Add (new MiscInstruction (offset' MiscOp.Throw));  				break;  			case PE.OpCode.Rethrow:  				instructions.Add (new MiscInstruction (offset' MiscOp.Rethrow));  				break;  			case PE.OpCode.Ldind_ref:  				instructions.Add (new MiscInstruction (offset' MiscOp.LdindRef));  				break;  			case PE.OpCode.Stind_ref:  				instructions.Add (new MiscInstruction (offset' MiscOp.StindRef));  				break;  			case PE.OpCode.Ldelem_ref:  				instructions.Add (new MiscInstruction (offset' MiscOp.LdelemRef));  				break;  			case PE.OpCode.Stelem_ref:  				instructions.Add (new MiscInstruction (offset' MiscOp.StelemRef));  				break;  			case PE.OpCode.Ldlen:  				instructions.Add (new MiscInstruction (offset' MiscOp.Ldlen));  				break;  			case PE.OpCode.Ret:  				if (ctxt.ResultType == null)  					instructions.Add (new MiscInstruction (offset' MiscOp.Ret));  				else  					instructions.Add (new MiscInstruction (offset' MiscOp.RetVal));  				break;  			case PE.OpCode.Endfilter:  				instructions.Add (new MiscInstruction (offset' MiscOp.Endfilter));  				break;  			case PE.OpCode.Endfinally:  				// aka EndFault  				instructions.Add (new MiscInstruction (offset' MiscOp.Endfinally));  				break;  			case PE.OpCode.Br_s:  			case PE.OpCode.Br:  				instructions.Add (new BranchInstruction (offset' BranchOp.Br' false' (int)instruction.Value));  				break;  			case PE.OpCode.Brtrue_s:  			// aka brinst.s  			case PE.OpCode.Brtrue:  				// aka brinst  				instructions.Add (new BranchInstruction (offset' BranchOp.Brtrue' false' (int)instruction.Value));  				break;  			case PE.OpCode.Brfalse_s:  			// aka brzero.s' brnull.s  			case PE.OpCode.Brfalse:  				// aka brzero' brnull  				instructions.Add (new BranchInstruction (offset' BranchOp.Brfalse' false' (int)instruction.Value));  				break;  			case PE.OpCode.Beq:  			case PE.OpCode.Beq_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.Breq' false' (int)instruction.Value));  				break;  			case PE.OpCode.Bne_un:  			case PE.OpCode.Bne_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.Brne' false' (int)instruction.Value));  				break;  			case PE.OpCode.Leave:  			case PE.OpCode.Leave_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.Leave' false' (int)instruction.Value));  				break;  			case PE.OpCode.Blt:  			case PE.OpCode.Blt_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' false' (int)instruction.Value));  				break;  			case PE.OpCode.Blt_un:  			case PE.OpCode.Blt_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' true' (int)instruction.Value));  				break;  			case PE.OpCode.Ble:  			case PE.OpCode.Ble_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' false' (int)instruction.Value));  				break;  			case PE.OpCode.Ble_un:  			case PE.OpCode.Ble_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' true' (int)instruction.Value));  				break;  			case PE.OpCode.Bgt:  			case PE.OpCode.Bgt_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' false' (int)instruction.Value));  				break;  			case PE.OpCode.Bgt_un:  			case PE.OpCode.Bgt_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' true' (int)instruction.Value));  				break;  			case PE.OpCode.Bge:  			case PE.OpCode.Bge_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' false' (int)instruction.Value));  				break;  			case PE.OpCode.Bge_un:  			case PE.OpCode.Bge_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' true' (int)instruction.Value));  				break;  			case PE.OpCode.Switch:  				instructions.Add (new SwitchInstruction (offset' (Seq<int>)instruction.Value));  				break;  			case PE.OpCode.Ceq:  				instructions.Add (new CompareInstruction (offset' CompareOp.Ceq' false));  				break;  			case PE.OpCode.Clt:  				instructions.Add (new CompareInstruction (offset' CompareOp.Clt' false));  				break;  			case PE.OpCode.Clt_un:  				instructions.Add (new CompareInstruction (offset' CompareOp.Clt' true));  				break;  			case PE.OpCode.Cgt:  				instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' false));  				break;  			case PE.OpCode.Cgt_un:  				instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' true));  				break;  			case PE.OpCode.Ldarg_0:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));  				break;  			case PE.OpCode.Ldarg_1:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));  				break;  			case PE.OpCode.Ldarg_2:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));  				break;  			case PE.OpCode.Ldarg_3:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));  				break;  			case PE.OpCode.Ldarg:  			case PE.OpCode.Ldarg_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));  				break;  			case PE.OpCode.Ldarga:  			case PE.OpCode.Ldarga_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));  				break;  			case PE.OpCode.Starg:  			case PE.OpCode.Starg_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));  				break;  			case PE.OpCode.Ldloc_0:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 0));  				break;  			case PE.OpCode.Ldloc_1:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 1));  				break;  			case PE.OpCode.Ldloc_2:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 2));  				break;  			case PE.OpCode.Ldloc_3:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 3));  				break;  			case PE.OpCode.Ldloc:  			case PE.OpCode.Ldloc_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));  				break;  			case PE.OpCode.Ldloca:  			case PE.OpCode.Ldloca_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));  				break;  			case PE.OpCode.Stloc_0:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 0));  				break;  			case PE.OpCode.Stloc_1:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 1));  				break;  			case PE.OpCode.Stloc_2:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 2));  				break;  			case PE.OpCode.Stloc_3:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 3));  				break;  			case PE.OpCode.Stloc:  			case PE.OpCode.Stloc_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));  				break;  			case PE.OpCode.Ldfld:  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));  				break;  			case PE.OpCode.Ldsfld:  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));  				break;  			case PE.OpCode.Ldflda:  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));  				break;  			case PE.OpCode.Ldsflda:  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));  				break;  			case PE.OpCode.Stfld:  				instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));  				break;  			case PE.OpCode.Stsfld:  				instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));  				break;  			case PE.OpCode.Ldtoken: {  				if (instruction.Value is FieldRef)  					instructions.Add (new FieldInstruction (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));  				else if (instruction.Value is MethodRef)  					instructions.Add (new MethodInstruction (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));  				else if (instruction.Value is TypeRef)  					// NOTE: May be a higher-kinded type  					instructions.Add (new TypeInstruction (offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));  				else  					throw new InvalidOperationException ("unexpected ldtoken instruction value");  				break;  			}  			case PE.OpCode.Constrained: {  				var constrained = (TypeRef)instruction.Value;  				if (i >= ctxt.Instructions.Length)  					throw new InvalidOperationException ("invalid instructions");  				instruction = ctxt.Instructions [i++];  				if (instruction.OpCode != PE.OpCode.Callvirt)  					throw new InvalidOperationException ("invalid instruction");  				instructions.Add (new MethodInstruction (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));  				break;  			}  			case PE.OpCode.Call:  				instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Callvirt:  				instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Ldftn:  				instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Ldvirtftn:  				instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Newobj:  				instructions.Add (new MethodInstruction (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Ldind_i1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int8Ref));  				break;  			case PE.OpCode.Ldind_u1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt8Ref));  				break;  			case PE.OpCode.Ldind_i2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int16Ref));  				break;  			case PE.OpCode.Ldind_u2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt16Ref));  				break;  			case PE.OpCode.Ldind_i4:  			case PE.OpCode.Ldind_u4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int32Ref));  				break;  			case PE.OpCode.Ldind_i8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int64Ref));  				break;  			case PE.OpCode.Ldind_i:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.IntNativeRef));  				break;  			case PE.OpCode.Ldind_r4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.SingleRef));  				break;  			case PE.OpCode.Ldind_r8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.DoubleRef));  				break;  			case PE.OpCode.Ldobj:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Stind_i1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int8Ref));  				break;  			case PE.OpCode.Stind_i2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int16Ref));  				break;  			case PE.OpCode.Stind_i4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int32Ref));  				break;  			case PE.OpCode.Stind_i8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int64Ref));  				break;  			case PE.OpCode.Stind_i:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.IntNativeRef));  				break;  			case PE.OpCode.Stind_r4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.SingleRef));  				break;  			case PE.OpCode.Stind_r8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.DoubleRef));  				break;  			case PE.OpCode.Stobj:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Cpobj:  				instructions.Add (new TypeInstruction (offset' TypeOp.Cpobj' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Newarr:  				instructions.Add (new TypeInstruction (offset' TypeOp.Newarr' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Initobj:  				instructions.Add (new TypeInstruction (offset' TypeOp.Initobj' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Castclass:  				instructions.Add (new TypeInstruction (offset' TypeOp.Castclass' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Isinst:  				instructions.Add (new TypeInstruction (offset' TypeOp.Isinst' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Box:  				instructions.Add (new TypeInstruction (offset' TypeOp.Box' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Unbox:  				instructions.Add (new TypeInstruction (offset' TypeOp.Unbox' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Unbox_any:  				instructions.Add (new TypeInstruction (offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Ldelem_i1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int8Ref));  				break;  			case PE.OpCode.Ldelem_u1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt8Ref));  				break;  			case PE.OpCode.Ldelem_i2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int16Ref));  				break;  			case PE.OpCode.Ldelem_u2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt16Ref));  				break;  			case PE.OpCode.Ldelem_i4:  			case PE.OpCode.Ldelem_u4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int32Ref));  				break;  			case PE.OpCode.Ldelem_i:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.IntNativeRef));  				break;  			case PE.OpCode.Ldelem_i8:  				// aka ldelem.u8  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int64Ref));  				break;  			case PE.OpCode.Ldelem_r4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.SingleRef));  				break;  			case PE.OpCode.Ldelem_r8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.DoubleRef));  				break;  			case PE.OpCode.Ldelem:  				// aka ldelem.any  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Stelem_i1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int8Ref));  				break;  			case PE.OpCode.Stelem_i2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int16Ref));  				break;  			case PE.OpCode.Stelem_i4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int32Ref));  				break;  			case PE.OpCode.Stelem_i8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int64Ref));  				break;  			case PE.OpCode.Stelem_i:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.IntNativeRef));  				break;  			case PE.OpCode.Stelem_r4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.SingleRef));  				break;  			case PE.OpCode.Stelem_r8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.DoubleRef));  				break;  			case PE.OpCode.Stelem:  				// aka stelem.any  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Readonly:  				if (i >= ctxt.Instructions.Length)  					throw new InvalidOperationException ("invalid instruction");  				instruction = ctxt.Instructions [i++];  				if (instruction.OpCode != PE.OpCode.Ldelema)  					throw new InvalidOperationException ("invalid instruction");  				instructions.Add (new LdElemAddrInstruction (offset' true' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Ldelema:  				instructions.Add (new LdElemAddrInstruction (offset' false' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Ldc_i4_0:  				instructions.Add (new LdInt32Instruction (offset' 0));  				break;  			case PE.OpCode.Ldc_i4_1:  				instructions.Add (new LdInt32Instruction (offset' 1));  				break;  			case PE.OpCode.Ldc_i4_2:  				instructions.Add (new LdInt32Instruction (offset' 2));  				break;  			case PE.OpCode.Ldc_i4_3:  				instructions.Add (new LdInt32Instruction (offset' 3));  				break;  			case PE.OpCode.Ldc_i4_4:  				instructions.Add (new LdInt32Instruction (offset' 4));  				break;  			case PE.OpCode.Ldc_i4_5:  				instructions.Add (new LdInt32Instruction (offset' 5));  				break;  			case PE.OpCode.Ldc_i4_6:  				instructions.Add (new LdInt32Instruction (offset' 6));  				break;  			case PE.OpCode.Ldc_i4_7:  				instructions.Add (new LdInt32Instruction (offset' 7));  				break;  			case PE.OpCode.Ldc_i4_8:  				instructions.Add (new LdInt32Instruction (offset' 8));  				break;  			case PE.OpCode.Ldc_i4_m1:  				instructions.Add (new LdInt32Instruction (offset' -1));  				break;  			case PE.OpCode.Ldc_i4:  			case PE.OpCode.Ldc_i4_s:  				instructions.Add (new LdInt32Instruction (offset' (int)instruction.Value));  				break;  			case PE.OpCode.Ldc_i8:  				instructions.Add (new LdInt64Instruction (offset' (long)instruction.Value));  				break;  			case PE.OpCode.Ldc_r4:  				instructions.Add (new LdSingleInstruction (offset' (float)instruction.Value));  				break;  			case PE.OpCode.Ldc_r8:  				instructions.Add (new LdDoubleInstruction (offset' (double)instruction.Value));  				break;  			case PE.OpCode.Ldstr:  				instructions.Add (new LdStringInstruction (offset' (string)instruction.Value));  				break;  			case PE.OpCode.Add:  				instructions.Add (new ArithInstruction (offset' ArithOp.Add' false' false));  				break;  			case PE.OpCode.Add_ovf:  				instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' false));  				break;  			case PE.OpCode.Add_ovf_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' true));  				break;  			case PE.OpCode.Sub:  				instructions.Add (new ArithInstruction (offset' ArithOp.Sub' false' false));  				break;  			case PE.OpCode.Sub_ovf:  				instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' false));  				break;  			case PE.OpCode.Sub_ovf_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' true));  				break;  			case PE.OpCode.Mul:  				instructions.Add (new ArithInstruction (offset' ArithOp.Mul' false' false));  				break;  			case PE.OpCode.Mul_ovf:  				instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' false));  				break;  			case PE.OpCode.Mul_ovf_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' true));  				break;  			case PE.OpCode.Div:  				instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' false));  				break;  			case PE.OpCode.Div_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' true));  				break;  			case PE.OpCode.Rem:  				instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' false));  				break;  			case PE.OpCode.Rem_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' true));  				break;  			case PE.OpCode.Neg:  				instructions.Add (new ArithInstruction (offset' ArithOp.Neg' false' false));  				break;  			case PE.OpCode.And:  				instructions.Add (new ArithInstruction (offset' ArithOp.BitAnd' false' false));  				break;  			case PE.OpCode.Or:  				instructions.Add (new ArithInstruction (offset' ArithOp.BitOr' false' false));  				break;  			case PE.OpCode.Xor:  				instructions.Add (new ArithInstruction (offset' ArithOp.BitXor' false' false));  				break;  			case PE.OpCode.Not:  				instructions.Add (new ArithInstruction (offset' ArithOp.BitNot' false' false));  				break;  			case PE.OpCode.Shl:  				instructions.Add (new ArithInstruction (offset' ArithOp.Shl' false' false));  				break;  			case PE.OpCode.Shr:  				instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' false));  				break;  			case PE.OpCode.Shr_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' true));  				break;  			case PE.OpCode.Conv_i1:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' false' false));  				break;  			case PE.OpCode.Conv_u1:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' false' false));  				break;  			case PE.OpCode.Conv_i2:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' false' false));  				break;  			case PE.OpCode.Conv_u2:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' false' false));  				break;  			case PE.OpCode.Conv_i4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' false' false));  				break;  			case PE.OpCode.Conv_u4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' false' false));  				break;  			case PE.OpCode.Conv_i8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' false' false));  				break;  			case PE.OpCode.Conv_u8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' false' false));  				break;  			case PE.OpCode.Conv_i:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' false' false));  				break;  			case PE.OpCode.Conv_u:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' false' false));  				break;  			case PE.OpCode.Conv_r4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Single' false' false));  				break;  			case PE.OpCode.Conv_r8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' false));  				break;  			case PE.OpCode.Conv_r_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' true));  				break;  			case PE.OpCode.Conv_ovf_i1:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' false));  				break;  			case PE.OpCode.Conv_ovf_u1:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' false));  				break;  			case PE.OpCode.Conv_ovf_i2:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' false));  				break;  			case PE.OpCode.Conv_ovf_u2:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' false));  				break;  			case PE.OpCode.Conv_ovf_i4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' false));  				break;  			case PE.OpCode.Conv_ovf_u4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' false));  				break;  			case PE.OpCode.Conv_ovf_i8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' false));  				break;  			case PE.OpCode.Conv_ovf_u8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' false));  				break;  			case PE.OpCode.Conv_ovf_i:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' false));  				break;  			case PE.OpCode.Conv_ovf_u:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' false));  				break;  			case PE.OpCode.Conv_ovf_i1_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' true));  				break;  			case PE.OpCode.Conv_ovf_u1_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' true));  				break;  			case PE.OpCode.Conv_ovf_i2_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' true));  				break;  			case PE.OpCode.Conv_ovf_u2_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' true));  				break;  			case PE.OpCode.Conv_ovf_i4_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' true));  				break;  			case PE.OpCode.Conv_ovf_u4_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' true));  				break;  			case PE.OpCode.Conv_ovf_i8_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' true));  				break;  			case PE.OpCode.Conv_ovf_u8_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' true));  				break;  			case PE.OpCode.Conv_ovf_i_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' true));  				break;  			case PE.OpCode.Conv_ovf_u_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' true));  				break;  			default:  				throw new InvalidOperationException ("invalid instruction");  			}  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: while (!ctxt.AtEnd (i)) {  	var j = i > ctxt.Start ? ctxt.JumpOverHandlers (i) : i;  	if (j > i)  		i = j;  	else {  		var ehcs = ctxt.OutermostTryBlocks (i);  		if (ehcs != null) {  			// A try instruction begins here with given handlers  			var offset = ctxt.Instructions [i].Offset;  			var tryCtxt = new TryTranslationContext (ctxt' i' ehcs);  			var tryBlock = InstructionsFromContext (tryCtxt);  			var handlers = new Seq<TryInstructionHandler> ();  			foreach (var ehc in ehcs) {  				var handlerCtxt = new HandlerTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.HandlerOffset]' ehc);  				var handlerBlock = InstructionsFromContext (handlerCtxt);  				switch (ehc.Flags) {  				case PE.CorILExceptionClause.Exception:  					handlers.Add (new CatchTryInstructionHandler ((TypeRef)ehc.Class' handlerBlock));  					break;  				case PE.CorILExceptionClause.Filter: {  					var filterCtxt = new FilterTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.FilterOffset]' ehc);  					var filterBlock = InstructionsFromContext (filterCtxt);  					handlers.Add (new FilterTryInstructionHandler (filterBlock' handlerBlock));  					break;  				}  				case PE.CorILExceptionClause.Finally:  					handlers.Add (new FinallyTryInstructionHandler (handlerBlock));  					break;  				case PE.CorILExceptionClause.Fault:  					handlers.Add (new FaultTryInstructionHandler (handlerBlock));  					break;  				default:  					throw new ArgumentOutOfRangeException ();  				}  			}  			instructions.Add (new TryInstruction (offset' tryBlock' handlers));  			// Jump over try block  			var nextOffset = ehcs [0].TryOffset + ehcs [0].TryLength;  			if (!ctxt.OffsetToIndex.TryGetValue (nextOffset' out i))  				i = ctxt.Instructions.Length;  		}  		else {  			var instruction = ctxt.Instructions [i++];  			var offset = instruction.Offset;  			while (instruction.OpCode == PE.OpCode.Unaligned || instruction.OpCode == PE.OpCode.Volatile || instruction.OpCode == PE.OpCode.Tailcall) {  				// Skip over any ignored prefixes' but remember instruction begins at original offset  				// NOTE: What ever happened to the "no." prefix mentioned in the spec?  				if (i >= ctxt.Instructions.Length)  					throw new InvalidOperationException ("invalid instructions");  				instruction = ctxt.Instructions [i++];  			}  			switch (instruction.OpCode) {  			case PE.OpCode.Cpblk:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Cpblk));  				break;  			case PE.OpCode.Initblk:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Initblk));  				break;  			case PE.OpCode.Arglist:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Arglist));  				break;  			case PE.OpCode.Localloc:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Localloc));  				break;  			case PE.OpCode.Jmp:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Jmp));  				break;  			case PE.OpCode.Calli:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Calli));  				break;  			case PE.OpCode.Sizeof:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Sizeof));  				break;  			case PE.OpCode.Mkrefany:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Mkrefany));  				break;  			case PE.OpCode.Refanytype:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanytype));  				break;  			case PE.OpCode.Refanyval:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanyval));  				break;  			case PE.OpCode.Nop:  				instructions.Add (new MiscInstruction (offset' MiscOp.Nop));  				break;  			case PE.OpCode.Break:  				instructions.Add (new MiscInstruction (offset' MiscOp.Break));  				break;  			case PE.OpCode.Dup:  				instructions.Add (new MiscInstruction (offset' MiscOp.Dup));  				break;  			case PE.OpCode.Pop:  				instructions.Add (new MiscInstruction (offset' MiscOp.Pop));  				break;  			case PE.OpCode.Ldnull:  				instructions.Add (new MiscInstruction (offset' MiscOp.Ldnull));  				break;  			case PE.OpCode.Ckfinite:  				instructions.Add (new MiscInstruction (offset' MiscOp.Ckfinite));  				break;  			case PE.OpCode.Throw:  				instructions.Add (new MiscInstruction (offset' MiscOp.Throw));  				break;  			case PE.OpCode.Rethrow:  				instructions.Add (new MiscInstruction (offset' MiscOp.Rethrow));  				break;  			case PE.OpCode.Ldind_ref:  				instructions.Add (new MiscInstruction (offset' MiscOp.LdindRef));  				break;  			case PE.OpCode.Stind_ref:  				instructions.Add (new MiscInstruction (offset' MiscOp.StindRef));  				break;  			case PE.OpCode.Ldelem_ref:  				instructions.Add (new MiscInstruction (offset' MiscOp.LdelemRef));  				break;  			case PE.OpCode.Stelem_ref:  				instructions.Add (new MiscInstruction (offset' MiscOp.StelemRef));  				break;  			case PE.OpCode.Ldlen:  				instructions.Add (new MiscInstruction (offset' MiscOp.Ldlen));  				break;  			case PE.OpCode.Ret:  				if (ctxt.ResultType == null)  					instructions.Add (new MiscInstruction (offset' MiscOp.Ret));  				else  					instructions.Add (new MiscInstruction (offset' MiscOp.RetVal));  				break;  			case PE.OpCode.Endfilter:  				instructions.Add (new MiscInstruction (offset' MiscOp.Endfilter));  				break;  			case PE.OpCode.Endfinally:  				// aka EndFault  				instructions.Add (new MiscInstruction (offset' MiscOp.Endfinally));  				break;  			case PE.OpCode.Br_s:  			case PE.OpCode.Br:  				instructions.Add (new BranchInstruction (offset' BranchOp.Br' false' (int)instruction.Value));  				break;  			case PE.OpCode.Brtrue_s:  			// aka brinst.s  			case PE.OpCode.Brtrue:  				// aka brinst  				instructions.Add (new BranchInstruction (offset' BranchOp.Brtrue' false' (int)instruction.Value));  				break;  			case PE.OpCode.Brfalse_s:  			// aka brzero.s' brnull.s  			case PE.OpCode.Brfalse:  				// aka brzero' brnull  				instructions.Add (new BranchInstruction (offset' BranchOp.Brfalse' false' (int)instruction.Value));  				break;  			case PE.OpCode.Beq:  			case PE.OpCode.Beq_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.Breq' false' (int)instruction.Value));  				break;  			case PE.OpCode.Bne_un:  			case PE.OpCode.Bne_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.Brne' false' (int)instruction.Value));  				break;  			case PE.OpCode.Leave:  			case PE.OpCode.Leave_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.Leave' false' (int)instruction.Value));  				break;  			case PE.OpCode.Blt:  			case PE.OpCode.Blt_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' false' (int)instruction.Value));  				break;  			case PE.OpCode.Blt_un:  			case PE.OpCode.Blt_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' true' (int)instruction.Value));  				break;  			case PE.OpCode.Ble:  			case PE.OpCode.Ble_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' false' (int)instruction.Value));  				break;  			case PE.OpCode.Ble_un:  			case PE.OpCode.Ble_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' true' (int)instruction.Value));  				break;  			case PE.OpCode.Bgt:  			case PE.OpCode.Bgt_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' false' (int)instruction.Value));  				break;  			case PE.OpCode.Bgt_un:  			case PE.OpCode.Bgt_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' true' (int)instruction.Value));  				break;  			case PE.OpCode.Bge:  			case PE.OpCode.Bge_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' false' (int)instruction.Value));  				break;  			case PE.OpCode.Bge_un:  			case PE.OpCode.Bge_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' true' (int)instruction.Value));  				break;  			case PE.OpCode.Switch:  				instructions.Add (new SwitchInstruction (offset' (Seq<int>)instruction.Value));  				break;  			case PE.OpCode.Ceq:  				instructions.Add (new CompareInstruction (offset' CompareOp.Ceq' false));  				break;  			case PE.OpCode.Clt:  				instructions.Add (new CompareInstruction (offset' CompareOp.Clt' false));  				break;  			case PE.OpCode.Clt_un:  				instructions.Add (new CompareInstruction (offset' CompareOp.Clt' true));  				break;  			case PE.OpCode.Cgt:  				instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' false));  				break;  			case PE.OpCode.Cgt_un:  				instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' true));  				break;  			case PE.OpCode.Ldarg_0:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));  				break;  			case PE.OpCode.Ldarg_1:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));  				break;  			case PE.OpCode.Ldarg_2:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));  				break;  			case PE.OpCode.Ldarg_3:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));  				break;  			case PE.OpCode.Ldarg:  			case PE.OpCode.Ldarg_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));  				break;  			case PE.OpCode.Ldarga:  			case PE.OpCode.Ldarga_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));  				break;  			case PE.OpCode.Starg:  			case PE.OpCode.Starg_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));  				break;  			case PE.OpCode.Ldloc_0:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 0));  				break;  			case PE.OpCode.Ldloc_1:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 1));  				break;  			case PE.OpCode.Ldloc_2:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 2));  				break;  			case PE.OpCode.Ldloc_3:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 3));  				break;  			case PE.OpCode.Ldloc:  			case PE.OpCode.Ldloc_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));  				break;  			case PE.OpCode.Ldloca:  			case PE.OpCode.Ldloca_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));  				break;  			case PE.OpCode.Stloc_0:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 0));  				break;  			case PE.OpCode.Stloc_1:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 1));  				break;  			case PE.OpCode.Stloc_2:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 2));  				break;  			case PE.OpCode.Stloc_3:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 3));  				break;  			case PE.OpCode.Stloc:  			case PE.OpCode.Stloc_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));  				break;  			case PE.OpCode.Ldfld:  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));  				break;  			case PE.OpCode.Ldsfld:  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));  				break;  			case PE.OpCode.Ldflda:  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));  				break;  			case PE.OpCode.Ldsflda:  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));  				break;  			case PE.OpCode.Stfld:  				instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));  				break;  			case PE.OpCode.Stsfld:  				instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));  				break;  			case PE.OpCode.Ldtoken: {  				if (instruction.Value is FieldRef)  					instructions.Add (new FieldInstruction (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));  				else if (instruction.Value is MethodRef)  					instructions.Add (new MethodInstruction (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));  				else if (instruction.Value is TypeRef)  					// NOTE: May be a higher-kinded type  					instructions.Add (new TypeInstruction (offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));  				else  					throw new InvalidOperationException ("unexpected ldtoken instruction value");  				break;  			}  			case PE.OpCode.Constrained: {  				var constrained = (TypeRef)instruction.Value;  				if (i >= ctxt.Instructions.Length)  					throw new InvalidOperationException ("invalid instructions");  				instruction = ctxt.Instructions [i++];  				if (instruction.OpCode != PE.OpCode.Callvirt)  					throw new InvalidOperationException ("invalid instruction");  				instructions.Add (new MethodInstruction (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));  				break;  			}  			case PE.OpCode.Call:  				instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Callvirt:  				instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Ldftn:  				instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Ldvirtftn:  				instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Newobj:  				instructions.Add (new MethodInstruction (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Ldind_i1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int8Ref));  				break;  			case PE.OpCode.Ldind_u1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt8Ref));  				break;  			case PE.OpCode.Ldind_i2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int16Ref));  				break;  			case PE.OpCode.Ldind_u2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt16Ref));  				break;  			case PE.OpCode.Ldind_i4:  			case PE.OpCode.Ldind_u4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int32Ref));  				break;  			case PE.OpCode.Ldind_i8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int64Ref));  				break;  			case PE.OpCode.Ldind_i:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.IntNativeRef));  				break;  			case PE.OpCode.Ldind_r4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.SingleRef));  				break;  			case PE.OpCode.Ldind_r8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.DoubleRef));  				break;  			case PE.OpCode.Ldobj:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Stind_i1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int8Ref));  				break;  			case PE.OpCode.Stind_i2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int16Ref));  				break;  			case PE.OpCode.Stind_i4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int32Ref));  				break;  			case PE.OpCode.Stind_i8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int64Ref));  				break;  			case PE.OpCode.Stind_i:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.IntNativeRef));  				break;  			case PE.OpCode.Stind_r4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.SingleRef));  				break;  			case PE.OpCode.Stind_r8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.DoubleRef));  				break;  			case PE.OpCode.Stobj:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Cpobj:  				instructions.Add (new TypeInstruction (offset' TypeOp.Cpobj' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Newarr:  				instructions.Add (new TypeInstruction (offset' TypeOp.Newarr' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Initobj:  				instructions.Add (new TypeInstruction (offset' TypeOp.Initobj' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Castclass:  				instructions.Add (new TypeInstruction (offset' TypeOp.Castclass' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Isinst:  				instructions.Add (new TypeInstruction (offset' TypeOp.Isinst' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Box:  				instructions.Add (new TypeInstruction (offset' TypeOp.Box' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Unbox:  				instructions.Add (new TypeInstruction (offset' TypeOp.Unbox' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Unbox_any:  				instructions.Add (new TypeInstruction (offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Ldelem_i1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int8Ref));  				break;  			case PE.OpCode.Ldelem_u1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt8Ref));  				break;  			case PE.OpCode.Ldelem_i2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int16Ref));  				break;  			case PE.OpCode.Ldelem_u2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt16Ref));  				break;  			case PE.OpCode.Ldelem_i4:  			case PE.OpCode.Ldelem_u4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int32Ref));  				break;  			case PE.OpCode.Ldelem_i:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.IntNativeRef));  				break;  			case PE.OpCode.Ldelem_i8:  				// aka ldelem.u8  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int64Ref));  				break;  			case PE.OpCode.Ldelem_r4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.SingleRef));  				break;  			case PE.OpCode.Ldelem_r8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.DoubleRef));  				break;  			case PE.OpCode.Ldelem:  				// aka ldelem.any  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Stelem_i1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int8Ref));  				break;  			case PE.OpCode.Stelem_i2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int16Ref));  				break;  			case PE.OpCode.Stelem_i4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int32Ref));  				break;  			case PE.OpCode.Stelem_i8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int64Ref));  				break;  			case PE.OpCode.Stelem_i:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.IntNativeRef));  				break;  			case PE.OpCode.Stelem_r4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.SingleRef));  				break;  			case PE.OpCode.Stelem_r8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.DoubleRef));  				break;  			case PE.OpCode.Stelem:  				// aka stelem.any  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Readonly:  				if (i >= ctxt.Instructions.Length)  					throw new InvalidOperationException ("invalid instruction");  				instruction = ctxt.Instructions [i++];  				if (instruction.OpCode != PE.OpCode.Ldelema)  					throw new InvalidOperationException ("invalid instruction");  				instructions.Add (new LdElemAddrInstruction (offset' true' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Ldelema:  				instructions.Add (new LdElemAddrInstruction (offset' false' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Ldc_i4_0:  				instructions.Add (new LdInt32Instruction (offset' 0));  				break;  			case PE.OpCode.Ldc_i4_1:  				instructions.Add (new LdInt32Instruction (offset' 1));  				break;  			case PE.OpCode.Ldc_i4_2:  				instructions.Add (new LdInt32Instruction (offset' 2));  				break;  			case PE.OpCode.Ldc_i4_3:  				instructions.Add (new LdInt32Instruction (offset' 3));  				break;  			case PE.OpCode.Ldc_i4_4:  				instructions.Add (new LdInt32Instruction (offset' 4));  				break;  			case PE.OpCode.Ldc_i4_5:  				instructions.Add (new LdInt32Instruction (offset' 5));  				break;  			case PE.OpCode.Ldc_i4_6:  				instructions.Add (new LdInt32Instruction (offset' 6));  				break;  			case PE.OpCode.Ldc_i4_7:  				instructions.Add (new LdInt32Instruction (offset' 7));  				break;  			case PE.OpCode.Ldc_i4_8:  				instructions.Add (new LdInt32Instruction (offset' 8));  				break;  			case PE.OpCode.Ldc_i4_m1:  				instructions.Add (new LdInt32Instruction (offset' -1));  				break;  			case PE.OpCode.Ldc_i4:  			case PE.OpCode.Ldc_i4_s:  				instructions.Add (new LdInt32Instruction (offset' (int)instruction.Value));  				break;  			case PE.OpCode.Ldc_i8:  				instructions.Add (new LdInt64Instruction (offset' (long)instruction.Value));  				break;  			case PE.OpCode.Ldc_r4:  				instructions.Add (new LdSingleInstruction (offset' (float)instruction.Value));  				break;  			case PE.OpCode.Ldc_r8:  				instructions.Add (new LdDoubleInstruction (offset' (double)instruction.Value));  				break;  			case PE.OpCode.Ldstr:  				instructions.Add (new LdStringInstruction (offset' (string)instruction.Value));  				break;  			case PE.OpCode.Add:  				instructions.Add (new ArithInstruction (offset' ArithOp.Add' false' false));  				break;  			case PE.OpCode.Add_ovf:  				instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' false));  				break;  			case PE.OpCode.Add_ovf_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' true));  				break;  			case PE.OpCode.Sub:  				instructions.Add (new ArithInstruction (offset' ArithOp.Sub' false' false));  				break;  			case PE.OpCode.Sub_ovf:  				instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' false));  				break;  			case PE.OpCode.Sub_ovf_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' true));  				break;  			case PE.OpCode.Mul:  				instructions.Add (new ArithInstruction (offset' ArithOp.Mul' false' false));  				break;  			case PE.OpCode.Mul_ovf:  				instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' false));  				break;  			case PE.OpCode.Mul_ovf_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' true));  				break;  			case PE.OpCode.Div:  				instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' false));  				break;  			case PE.OpCode.Div_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' true));  				break;  			case PE.OpCode.Rem:  				instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' false));  				break;  			case PE.OpCode.Rem_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' true));  				break;  			case PE.OpCode.Neg:  				instructions.Add (new ArithInstruction (offset' ArithOp.Neg' false' false));  				break;  			case PE.OpCode.And:  				instructions.Add (new ArithInstruction (offset' ArithOp.BitAnd' false' false));  				break;  			case PE.OpCode.Or:  				instructions.Add (new ArithInstruction (offset' ArithOp.BitOr' false' false));  				break;  			case PE.OpCode.Xor:  				instructions.Add (new ArithInstruction (offset' ArithOp.BitXor' false' false));  				break;  			case PE.OpCode.Not:  				instructions.Add (new ArithInstruction (offset' ArithOp.BitNot' false' false));  				break;  			case PE.OpCode.Shl:  				instructions.Add (new ArithInstruction (offset' ArithOp.Shl' false' false));  				break;  			case PE.OpCode.Shr:  				instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' false));  				break;  			case PE.OpCode.Shr_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' true));  				break;  			case PE.OpCode.Conv_i1:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' false' false));  				break;  			case PE.OpCode.Conv_u1:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' false' false));  				break;  			case PE.OpCode.Conv_i2:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' false' false));  				break;  			case PE.OpCode.Conv_u2:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' false' false));  				break;  			case PE.OpCode.Conv_i4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' false' false));  				break;  			case PE.OpCode.Conv_u4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' false' false));  				break;  			case PE.OpCode.Conv_i8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' false' false));  				break;  			case PE.OpCode.Conv_u8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' false' false));  				break;  			case PE.OpCode.Conv_i:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' false' false));  				break;  			case PE.OpCode.Conv_u:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' false' false));  				break;  			case PE.OpCode.Conv_r4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Single' false' false));  				break;  			case PE.OpCode.Conv_r8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' false));  				break;  			case PE.OpCode.Conv_r_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' true));  				break;  			case PE.OpCode.Conv_ovf_i1:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' false));  				break;  			case PE.OpCode.Conv_ovf_u1:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' false));  				break;  			case PE.OpCode.Conv_ovf_i2:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' false));  				break;  			case PE.OpCode.Conv_ovf_u2:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' false));  				break;  			case PE.OpCode.Conv_ovf_i4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' false));  				break;  			case PE.OpCode.Conv_ovf_u4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' false));  				break;  			case PE.OpCode.Conv_ovf_i8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' false));  				break;  			case PE.OpCode.Conv_ovf_u8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' false));  				break;  			case PE.OpCode.Conv_ovf_i:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' false));  				break;  			case PE.OpCode.Conv_ovf_u:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' false));  				break;  			case PE.OpCode.Conv_ovf_i1_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' true));  				break;  			case PE.OpCode.Conv_ovf_u1_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' true));  				break;  			case PE.OpCode.Conv_ovf_i2_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' true));  				break;  			case PE.OpCode.Conv_ovf_u2_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' true));  				break;  			case PE.OpCode.Conv_ovf_i4_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' true));  				break;  			case PE.OpCode.Conv_ovf_u4_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' true));  				break;  			case PE.OpCode.Conv_ovf_i8_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' true));  				break;  			case PE.OpCode.Conv_ovf_u8_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' true));  				break;  			case PE.OpCode.Conv_ovf_i_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' true));  				break;  			case PE.OpCode.Conv_ovf_u_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' true));  				break;  			default:  				throw new InvalidOperationException ("invalid instruction");  			}  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: while (!ctxt.AtEnd (i)) {  	var j = i > ctxt.Start ? ctxt.JumpOverHandlers (i) : i;  	if (j > i)  		i = j;  	else {  		var ehcs = ctxt.OutermostTryBlocks (i);  		if (ehcs != null) {  			// A try instruction begins here with given handlers  			var offset = ctxt.Instructions [i].Offset;  			var tryCtxt = new TryTranslationContext (ctxt' i' ehcs);  			var tryBlock = InstructionsFromContext (tryCtxt);  			var handlers = new Seq<TryInstructionHandler> ();  			foreach (var ehc in ehcs) {  				var handlerCtxt = new HandlerTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.HandlerOffset]' ehc);  				var handlerBlock = InstructionsFromContext (handlerCtxt);  				switch (ehc.Flags) {  				case PE.CorILExceptionClause.Exception:  					handlers.Add (new CatchTryInstructionHandler ((TypeRef)ehc.Class' handlerBlock));  					break;  				case PE.CorILExceptionClause.Filter: {  					var filterCtxt = new FilterTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.FilterOffset]' ehc);  					var filterBlock = InstructionsFromContext (filterCtxt);  					handlers.Add (new FilterTryInstructionHandler (filterBlock' handlerBlock));  					break;  				}  				case PE.CorILExceptionClause.Finally:  					handlers.Add (new FinallyTryInstructionHandler (handlerBlock));  					break;  				case PE.CorILExceptionClause.Fault:  					handlers.Add (new FaultTryInstructionHandler (handlerBlock));  					break;  				default:  					throw new ArgumentOutOfRangeException ();  				}  			}  			instructions.Add (new TryInstruction (offset' tryBlock' handlers));  			// Jump over try block  			var nextOffset = ehcs [0].TryOffset + ehcs [0].TryLength;  			if (!ctxt.OffsetToIndex.TryGetValue (nextOffset' out i))  				i = ctxt.Instructions.Length;  		}  		else {  			var instruction = ctxt.Instructions [i++];  			var offset = instruction.Offset;  			while (instruction.OpCode == PE.OpCode.Unaligned || instruction.OpCode == PE.OpCode.Volatile || instruction.OpCode == PE.OpCode.Tailcall) {  				// Skip over any ignored prefixes' but remember instruction begins at original offset  				// NOTE: What ever happened to the "no." prefix mentioned in the spec?  				if (i >= ctxt.Instructions.Length)  					throw new InvalidOperationException ("invalid instructions");  				instruction = ctxt.Instructions [i++];  			}  			switch (instruction.OpCode) {  			case PE.OpCode.Cpblk:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Cpblk));  				break;  			case PE.OpCode.Initblk:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Initblk));  				break;  			case PE.OpCode.Arglist:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Arglist));  				break;  			case PE.OpCode.Localloc:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Localloc));  				break;  			case PE.OpCode.Jmp:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Jmp));  				break;  			case PE.OpCode.Calli:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Calli));  				break;  			case PE.OpCode.Sizeof:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Sizeof));  				break;  			case PE.OpCode.Mkrefany:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Mkrefany));  				break;  			case PE.OpCode.Refanytype:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanytype));  				break;  			case PE.OpCode.Refanyval:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanyval));  				break;  			case PE.OpCode.Nop:  				instructions.Add (new MiscInstruction (offset' MiscOp.Nop));  				break;  			case PE.OpCode.Break:  				instructions.Add (new MiscInstruction (offset' MiscOp.Break));  				break;  			case PE.OpCode.Dup:  				instructions.Add (new MiscInstruction (offset' MiscOp.Dup));  				break;  			case PE.OpCode.Pop:  				instructions.Add (new MiscInstruction (offset' MiscOp.Pop));  				break;  			case PE.OpCode.Ldnull:  				instructions.Add (new MiscInstruction (offset' MiscOp.Ldnull));  				break;  			case PE.OpCode.Ckfinite:  				instructions.Add (new MiscInstruction (offset' MiscOp.Ckfinite));  				break;  			case PE.OpCode.Throw:  				instructions.Add (new MiscInstruction (offset' MiscOp.Throw));  				break;  			case PE.OpCode.Rethrow:  				instructions.Add (new MiscInstruction (offset' MiscOp.Rethrow));  				break;  			case PE.OpCode.Ldind_ref:  				instructions.Add (new MiscInstruction (offset' MiscOp.LdindRef));  				break;  			case PE.OpCode.Stind_ref:  				instructions.Add (new MiscInstruction (offset' MiscOp.StindRef));  				break;  			case PE.OpCode.Ldelem_ref:  				instructions.Add (new MiscInstruction (offset' MiscOp.LdelemRef));  				break;  			case PE.OpCode.Stelem_ref:  				instructions.Add (new MiscInstruction (offset' MiscOp.StelemRef));  				break;  			case PE.OpCode.Ldlen:  				instructions.Add (new MiscInstruction (offset' MiscOp.Ldlen));  				break;  			case PE.OpCode.Ret:  				if (ctxt.ResultType == null)  					instructions.Add (new MiscInstruction (offset' MiscOp.Ret));  				else  					instructions.Add (new MiscInstruction (offset' MiscOp.RetVal));  				break;  			case PE.OpCode.Endfilter:  				instructions.Add (new MiscInstruction (offset' MiscOp.Endfilter));  				break;  			case PE.OpCode.Endfinally:  				// aka EndFault  				instructions.Add (new MiscInstruction (offset' MiscOp.Endfinally));  				break;  			case PE.OpCode.Br_s:  			case PE.OpCode.Br:  				instructions.Add (new BranchInstruction (offset' BranchOp.Br' false' (int)instruction.Value));  				break;  			case PE.OpCode.Brtrue_s:  			// aka brinst.s  			case PE.OpCode.Brtrue:  				// aka brinst  				instructions.Add (new BranchInstruction (offset' BranchOp.Brtrue' false' (int)instruction.Value));  				break;  			case PE.OpCode.Brfalse_s:  			// aka brzero.s' brnull.s  			case PE.OpCode.Brfalse:  				// aka brzero' brnull  				instructions.Add (new BranchInstruction (offset' BranchOp.Brfalse' false' (int)instruction.Value));  				break;  			case PE.OpCode.Beq:  			case PE.OpCode.Beq_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.Breq' false' (int)instruction.Value));  				break;  			case PE.OpCode.Bne_un:  			case PE.OpCode.Bne_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.Brne' false' (int)instruction.Value));  				break;  			case PE.OpCode.Leave:  			case PE.OpCode.Leave_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.Leave' false' (int)instruction.Value));  				break;  			case PE.OpCode.Blt:  			case PE.OpCode.Blt_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' false' (int)instruction.Value));  				break;  			case PE.OpCode.Blt_un:  			case PE.OpCode.Blt_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' true' (int)instruction.Value));  				break;  			case PE.OpCode.Ble:  			case PE.OpCode.Ble_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' false' (int)instruction.Value));  				break;  			case PE.OpCode.Ble_un:  			case PE.OpCode.Ble_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' true' (int)instruction.Value));  				break;  			case PE.OpCode.Bgt:  			case PE.OpCode.Bgt_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' false' (int)instruction.Value));  				break;  			case PE.OpCode.Bgt_un:  			case PE.OpCode.Bgt_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' true' (int)instruction.Value));  				break;  			case PE.OpCode.Bge:  			case PE.OpCode.Bge_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' false' (int)instruction.Value));  				break;  			case PE.OpCode.Bge_un:  			case PE.OpCode.Bge_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' true' (int)instruction.Value));  				break;  			case PE.OpCode.Switch:  				instructions.Add (new SwitchInstruction (offset' (Seq<int>)instruction.Value));  				break;  			case PE.OpCode.Ceq:  				instructions.Add (new CompareInstruction (offset' CompareOp.Ceq' false));  				break;  			case PE.OpCode.Clt:  				instructions.Add (new CompareInstruction (offset' CompareOp.Clt' false));  				break;  			case PE.OpCode.Clt_un:  				instructions.Add (new CompareInstruction (offset' CompareOp.Clt' true));  				break;  			case PE.OpCode.Cgt:  				instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' false));  				break;  			case PE.OpCode.Cgt_un:  				instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' true));  				break;  			case PE.OpCode.Ldarg_0:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));  				break;  			case PE.OpCode.Ldarg_1:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));  				break;  			case PE.OpCode.Ldarg_2:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));  				break;  			case PE.OpCode.Ldarg_3:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));  				break;  			case PE.OpCode.Ldarg:  			case PE.OpCode.Ldarg_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));  				break;  			case PE.OpCode.Ldarga:  			case PE.OpCode.Ldarga_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));  				break;  			case PE.OpCode.Starg:  			case PE.OpCode.Starg_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));  				break;  			case PE.OpCode.Ldloc_0:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 0));  				break;  			case PE.OpCode.Ldloc_1:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 1));  				break;  			case PE.OpCode.Ldloc_2:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 2));  				break;  			case PE.OpCode.Ldloc_3:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 3));  				break;  			case PE.OpCode.Ldloc:  			case PE.OpCode.Ldloc_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));  				break;  			case PE.OpCode.Ldloca:  			case PE.OpCode.Ldloca_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));  				break;  			case PE.OpCode.Stloc_0:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 0));  				break;  			case PE.OpCode.Stloc_1:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 1));  				break;  			case PE.OpCode.Stloc_2:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 2));  				break;  			case PE.OpCode.Stloc_3:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 3));  				break;  			case PE.OpCode.Stloc:  			case PE.OpCode.Stloc_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));  				break;  			case PE.OpCode.Ldfld:  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));  				break;  			case PE.OpCode.Ldsfld:  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));  				break;  			case PE.OpCode.Ldflda:  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));  				break;  			case PE.OpCode.Ldsflda:  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));  				break;  			case PE.OpCode.Stfld:  				instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));  				break;  			case PE.OpCode.Stsfld:  				instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));  				break;  			case PE.OpCode.Ldtoken: {  				if (instruction.Value is FieldRef)  					instructions.Add (new FieldInstruction (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));  				else if (instruction.Value is MethodRef)  					instructions.Add (new MethodInstruction (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));  				else if (instruction.Value is TypeRef)  					// NOTE: May be a higher-kinded type  					instructions.Add (new TypeInstruction (offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));  				else  					throw new InvalidOperationException ("unexpected ldtoken instruction value");  				break;  			}  			case PE.OpCode.Constrained: {  				var constrained = (TypeRef)instruction.Value;  				if (i >= ctxt.Instructions.Length)  					throw new InvalidOperationException ("invalid instructions");  				instruction = ctxt.Instructions [i++];  				if (instruction.OpCode != PE.OpCode.Callvirt)  					throw new InvalidOperationException ("invalid instruction");  				instructions.Add (new MethodInstruction (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));  				break;  			}  			case PE.OpCode.Call:  				instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Callvirt:  				instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Ldftn:  				instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Ldvirtftn:  				instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Newobj:  				instructions.Add (new MethodInstruction (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Ldind_i1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int8Ref));  				break;  			case PE.OpCode.Ldind_u1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt8Ref));  				break;  			case PE.OpCode.Ldind_i2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int16Ref));  				break;  			case PE.OpCode.Ldind_u2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt16Ref));  				break;  			case PE.OpCode.Ldind_i4:  			case PE.OpCode.Ldind_u4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int32Ref));  				break;  			case PE.OpCode.Ldind_i8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int64Ref));  				break;  			case PE.OpCode.Ldind_i:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.IntNativeRef));  				break;  			case PE.OpCode.Ldind_r4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.SingleRef));  				break;  			case PE.OpCode.Ldind_r8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.DoubleRef));  				break;  			case PE.OpCode.Ldobj:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Stind_i1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int8Ref));  				break;  			case PE.OpCode.Stind_i2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int16Ref));  				break;  			case PE.OpCode.Stind_i4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int32Ref));  				break;  			case PE.OpCode.Stind_i8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int64Ref));  				break;  			case PE.OpCode.Stind_i:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.IntNativeRef));  				break;  			case PE.OpCode.Stind_r4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.SingleRef));  				break;  			case PE.OpCode.Stind_r8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.DoubleRef));  				break;  			case PE.OpCode.Stobj:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Cpobj:  				instructions.Add (new TypeInstruction (offset' TypeOp.Cpobj' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Newarr:  				instructions.Add (new TypeInstruction (offset' TypeOp.Newarr' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Initobj:  				instructions.Add (new TypeInstruction (offset' TypeOp.Initobj' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Castclass:  				instructions.Add (new TypeInstruction (offset' TypeOp.Castclass' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Isinst:  				instructions.Add (new TypeInstruction (offset' TypeOp.Isinst' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Box:  				instructions.Add (new TypeInstruction (offset' TypeOp.Box' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Unbox:  				instructions.Add (new TypeInstruction (offset' TypeOp.Unbox' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Unbox_any:  				instructions.Add (new TypeInstruction (offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Ldelem_i1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int8Ref));  				break;  			case PE.OpCode.Ldelem_u1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt8Ref));  				break;  			case PE.OpCode.Ldelem_i2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int16Ref));  				break;  			case PE.OpCode.Ldelem_u2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt16Ref));  				break;  			case PE.OpCode.Ldelem_i4:  			case PE.OpCode.Ldelem_u4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int32Ref));  				break;  			case PE.OpCode.Ldelem_i:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.IntNativeRef));  				break;  			case PE.OpCode.Ldelem_i8:  				// aka ldelem.u8  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int64Ref));  				break;  			case PE.OpCode.Ldelem_r4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.SingleRef));  				break;  			case PE.OpCode.Ldelem_r8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.DoubleRef));  				break;  			case PE.OpCode.Ldelem:  				// aka ldelem.any  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Stelem_i1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int8Ref));  				break;  			case PE.OpCode.Stelem_i2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int16Ref));  				break;  			case PE.OpCode.Stelem_i4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int32Ref));  				break;  			case PE.OpCode.Stelem_i8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int64Ref));  				break;  			case PE.OpCode.Stelem_i:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.IntNativeRef));  				break;  			case PE.OpCode.Stelem_r4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.SingleRef));  				break;  			case PE.OpCode.Stelem_r8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.DoubleRef));  				break;  			case PE.OpCode.Stelem:  				// aka stelem.any  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Readonly:  				if (i >= ctxt.Instructions.Length)  					throw new InvalidOperationException ("invalid instruction");  				instruction = ctxt.Instructions [i++];  				if (instruction.OpCode != PE.OpCode.Ldelema)  					throw new InvalidOperationException ("invalid instruction");  				instructions.Add (new LdElemAddrInstruction (offset' true' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Ldelema:  				instructions.Add (new LdElemAddrInstruction (offset' false' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Ldc_i4_0:  				instructions.Add (new LdInt32Instruction (offset' 0));  				break;  			case PE.OpCode.Ldc_i4_1:  				instructions.Add (new LdInt32Instruction (offset' 1));  				break;  			case PE.OpCode.Ldc_i4_2:  				instructions.Add (new LdInt32Instruction (offset' 2));  				break;  			case PE.OpCode.Ldc_i4_3:  				instructions.Add (new LdInt32Instruction (offset' 3));  				break;  			case PE.OpCode.Ldc_i4_4:  				instructions.Add (new LdInt32Instruction (offset' 4));  				break;  			case PE.OpCode.Ldc_i4_5:  				instructions.Add (new LdInt32Instruction (offset' 5));  				break;  			case PE.OpCode.Ldc_i4_6:  				instructions.Add (new LdInt32Instruction (offset' 6));  				break;  			case PE.OpCode.Ldc_i4_7:  				instructions.Add (new LdInt32Instruction (offset' 7));  				break;  			case PE.OpCode.Ldc_i4_8:  				instructions.Add (new LdInt32Instruction (offset' 8));  				break;  			case PE.OpCode.Ldc_i4_m1:  				instructions.Add (new LdInt32Instruction (offset' -1));  				break;  			case PE.OpCode.Ldc_i4:  			case PE.OpCode.Ldc_i4_s:  				instructions.Add (new LdInt32Instruction (offset' (int)instruction.Value));  				break;  			case PE.OpCode.Ldc_i8:  				instructions.Add (new LdInt64Instruction (offset' (long)instruction.Value));  				break;  			case PE.OpCode.Ldc_r4:  				instructions.Add (new LdSingleInstruction (offset' (float)instruction.Value));  				break;  			case PE.OpCode.Ldc_r8:  				instructions.Add (new LdDoubleInstruction (offset' (double)instruction.Value));  				break;  			case PE.OpCode.Ldstr:  				instructions.Add (new LdStringInstruction (offset' (string)instruction.Value));  				break;  			case PE.OpCode.Add:  				instructions.Add (new ArithInstruction (offset' ArithOp.Add' false' false));  				break;  			case PE.OpCode.Add_ovf:  				instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' false));  				break;  			case PE.OpCode.Add_ovf_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' true));  				break;  			case PE.OpCode.Sub:  				instructions.Add (new ArithInstruction (offset' ArithOp.Sub' false' false));  				break;  			case PE.OpCode.Sub_ovf:  				instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' false));  				break;  			case PE.OpCode.Sub_ovf_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' true));  				break;  			case PE.OpCode.Mul:  				instructions.Add (new ArithInstruction (offset' ArithOp.Mul' false' false));  				break;  			case PE.OpCode.Mul_ovf:  				instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' false));  				break;  			case PE.OpCode.Mul_ovf_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' true));  				break;  			case PE.OpCode.Div:  				instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' false));  				break;  			case PE.OpCode.Div_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' true));  				break;  			case PE.OpCode.Rem:  				instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' false));  				break;  			case PE.OpCode.Rem_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' true));  				break;  			case PE.OpCode.Neg:  				instructions.Add (new ArithInstruction (offset' ArithOp.Neg' false' false));  				break;  			case PE.OpCode.And:  				instructions.Add (new ArithInstruction (offset' ArithOp.BitAnd' false' false));  				break;  			case PE.OpCode.Or:  				instructions.Add (new ArithInstruction (offset' ArithOp.BitOr' false' false));  				break;  			case PE.OpCode.Xor:  				instructions.Add (new ArithInstruction (offset' ArithOp.BitXor' false' false));  				break;  			case PE.OpCode.Not:  				instructions.Add (new ArithInstruction (offset' ArithOp.BitNot' false' false));  				break;  			case PE.OpCode.Shl:  				instructions.Add (new ArithInstruction (offset' ArithOp.Shl' false' false));  				break;  			case PE.OpCode.Shr:  				instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' false));  				break;  			case PE.OpCode.Shr_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' true));  				break;  			case PE.OpCode.Conv_i1:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' false' false));  				break;  			case PE.OpCode.Conv_u1:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' false' false));  				break;  			case PE.OpCode.Conv_i2:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' false' false));  				break;  			case PE.OpCode.Conv_u2:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' false' false));  				break;  			case PE.OpCode.Conv_i4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' false' false));  				break;  			case PE.OpCode.Conv_u4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' false' false));  				break;  			case PE.OpCode.Conv_i8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' false' false));  				break;  			case PE.OpCode.Conv_u8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' false' false));  				break;  			case PE.OpCode.Conv_i:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' false' false));  				break;  			case PE.OpCode.Conv_u:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' false' false));  				break;  			case PE.OpCode.Conv_r4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Single' false' false));  				break;  			case PE.OpCode.Conv_r8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' false));  				break;  			case PE.OpCode.Conv_r_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' true));  				break;  			case PE.OpCode.Conv_ovf_i1:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' false));  				break;  			case PE.OpCode.Conv_ovf_u1:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' false));  				break;  			case PE.OpCode.Conv_ovf_i2:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' false));  				break;  			case PE.OpCode.Conv_ovf_u2:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' false));  				break;  			case PE.OpCode.Conv_ovf_i4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' false));  				break;  			case PE.OpCode.Conv_ovf_u4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' false));  				break;  			case PE.OpCode.Conv_ovf_i8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' false));  				break;  			case PE.OpCode.Conv_ovf_u8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' false));  				break;  			case PE.OpCode.Conv_ovf_i:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' false));  				break;  			case PE.OpCode.Conv_ovf_u:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' false));  				break;  			case PE.OpCode.Conv_ovf_i1_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' true));  				break;  			case PE.OpCode.Conv_ovf_u1_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' true));  				break;  			case PE.OpCode.Conv_ovf_i2_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' true));  				break;  			case PE.OpCode.Conv_ovf_u2_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' true));  				break;  			case PE.OpCode.Conv_ovf_i4_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' true));  				break;  			case PE.OpCode.Conv_ovf_u4_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' true));  				break;  			case PE.OpCode.Conv_ovf_i8_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' true));  				break;  			case PE.OpCode.Conv_ovf_u8_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' true));  				break;  			case PE.OpCode.Conv_ovf_i_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' true));  				break;  			case PE.OpCode.Conv_ovf_u_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' true));  				break;  			default:  				throw new InvalidOperationException ("invalid instruction");  			}  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: while (!ctxt.AtEnd (i)) {  	var j = i > ctxt.Start ? ctxt.JumpOverHandlers (i) : i;  	if (j > i)  		i = j;  	else {  		var ehcs = ctxt.OutermostTryBlocks (i);  		if (ehcs != null) {  			// A try instruction begins here with given handlers  			var offset = ctxt.Instructions [i].Offset;  			var tryCtxt = new TryTranslationContext (ctxt' i' ehcs);  			var tryBlock = InstructionsFromContext (tryCtxt);  			var handlers = new Seq<TryInstructionHandler> ();  			foreach (var ehc in ehcs) {  				var handlerCtxt = new HandlerTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.HandlerOffset]' ehc);  				var handlerBlock = InstructionsFromContext (handlerCtxt);  				switch (ehc.Flags) {  				case PE.CorILExceptionClause.Exception:  					handlers.Add (new CatchTryInstructionHandler ((TypeRef)ehc.Class' handlerBlock));  					break;  				case PE.CorILExceptionClause.Filter: {  					var filterCtxt = new FilterTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.FilterOffset]' ehc);  					var filterBlock = InstructionsFromContext (filterCtxt);  					handlers.Add (new FilterTryInstructionHandler (filterBlock' handlerBlock));  					break;  				}  				case PE.CorILExceptionClause.Finally:  					handlers.Add (new FinallyTryInstructionHandler (handlerBlock));  					break;  				case PE.CorILExceptionClause.Fault:  					handlers.Add (new FaultTryInstructionHandler (handlerBlock));  					break;  				default:  					throw new ArgumentOutOfRangeException ();  				}  			}  			instructions.Add (new TryInstruction (offset' tryBlock' handlers));  			// Jump over try block  			var nextOffset = ehcs [0].TryOffset + ehcs [0].TryLength;  			if (!ctxt.OffsetToIndex.TryGetValue (nextOffset' out i))  				i = ctxt.Instructions.Length;  		}  		else {  			var instruction = ctxt.Instructions [i++];  			var offset = instruction.Offset;  			while (instruction.OpCode == PE.OpCode.Unaligned || instruction.OpCode == PE.OpCode.Volatile || instruction.OpCode == PE.OpCode.Tailcall) {  				// Skip over any ignored prefixes' but remember instruction begins at original offset  				// NOTE: What ever happened to the "no." prefix mentioned in the spec?  				if (i >= ctxt.Instructions.Length)  					throw new InvalidOperationException ("invalid instructions");  				instruction = ctxt.Instructions [i++];  			}  			switch (instruction.OpCode) {  			case PE.OpCode.Cpblk:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Cpblk));  				break;  			case PE.OpCode.Initblk:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Initblk));  				break;  			case PE.OpCode.Arglist:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Arglist));  				break;  			case PE.OpCode.Localloc:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Localloc));  				break;  			case PE.OpCode.Jmp:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Jmp));  				break;  			case PE.OpCode.Calli:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Calli));  				break;  			case PE.OpCode.Sizeof:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Sizeof));  				break;  			case PE.OpCode.Mkrefany:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Mkrefany));  				break;  			case PE.OpCode.Refanytype:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanytype));  				break;  			case PE.OpCode.Refanyval:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanyval));  				break;  			case PE.OpCode.Nop:  				instructions.Add (new MiscInstruction (offset' MiscOp.Nop));  				break;  			case PE.OpCode.Break:  				instructions.Add (new MiscInstruction (offset' MiscOp.Break));  				break;  			case PE.OpCode.Dup:  				instructions.Add (new MiscInstruction (offset' MiscOp.Dup));  				break;  			case PE.OpCode.Pop:  				instructions.Add (new MiscInstruction (offset' MiscOp.Pop));  				break;  			case PE.OpCode.Ldnull:  				instructions.Add (new MiscInstruction (offset' MiscOp.Ldnull));  				break;  			case PE.OpCode.Ckfinite:  				instructions.Add (new MiscInstruction (offset' MiscOp.Ckfinite));  				break;  			case PE.OpCode.Throw:  				instructions.Add (new MiscInstruction (offset' MiscOp.Throw));  				break;  			case PE.OpCode.Rethrow:  				instructions.Add (new MiscInstruction (offset' MiscOp.Rethrow));  				break;  			case PE.OpCode.Ldind_ref:  				instructions.Add (new MiscInstruction (offset' MiscOp.LdindRef));  				break;  			case PE.OpCode.Stind_ref:  				instructions.Add (new MiscInstruction (offset' MiscOp.StindRef));  				break;  			case PE.OpCode.Ldelem_ref:  				instructions.Add (new MiscInstruction (offset' MiscOp.LdelemRef));  				break;  			case PE.OpCode.Stelem_ref:  				instructions.Add (new MiscInstruction (offset' MiscOp.StelemRef));  				break;  			case PE.OpCode.Ldlen:  				instructions.Add (new MiscInstruction (offset' MiscOp.Ldlen));  				break;  			case PE.OpCode.Ret:  				if (ctxt.ResultType == null)  					instructions.Add (new MiscInstruction (offset' MiscOp.Ret));  				else  					instructions.Add (new MiscInstruction (offset' MiscOp.RetVal));  				break;  			case PE.OpCode.Endfilter:  				instructions.Add (new MiscInstruction (offset' MiscOp.Endfilter));  				break;  			case PE.OpCode.Endfinally:  				// aka EndFault  				instructions.Add (new MiscInstruction (offset' MiscOp.Endfinally));  				break;  			case PE.OpCode.Br_s:  			case PE.OpCode.Br:  				instructions.Add (new BranchInstruction (offset' BranchOp.Br' false' (int)instruction.Value));  				break;  			case PE.OpCode.Brtrue_s:  			// aka brinst.s  			case PE.OpCode.Brtrue:  				// aka brinst  				instructions.Add (new BranchInstruction (offset' BranchOp.Brtrue' false' (int)instruction.Value));  				break;  			case PE.OpCode.Brfalse_s:  			// aka brzero.s' brnull.s  			case PE.OpCode.Brfalse:  				// aka brzero' brnull  				instructions.Add (new BranchInstruction (offset' BranchOp.Brfalse' false' (int)instruction.Value));  				break;  			case PE.OpCode.Beq:  			case PE.OpCode.Beq_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.Breq' false' (int)instruction.Value));  				break;  			case PE.OpCode.Bne_un:  			case PE.OpCode.Bne_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.Brne' false' (int)instruction.Value));  				break;  			case PE.OpCode.Leave:  			case PE.OpCode.Leave_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.Leave' false' (int)instruction.Value));  				break;  			case PE.OpCode.Blt:  			case PE.OpCode.Blt_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' false' (int)instruction.Value));  				break;  			case PE.OpCode.Blt_un:  			case PE.OpCode.Blt_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' true' (int)instruction.Value));  				break;  			case PE.OpCode.Ble:  			case PE.OpCode.Ble_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' false' (int)instruction.Value));  				break;  			case PE.OpCode.Ble_un:  			case PE.OpCode.Ble_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' true' (int)instruction.Value));  				break;  			case PE.OpCode.Bgt:  			case PE.OpCode.Bgt_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' false' (int)instruction.Value));  				break;  			case PE.OpCode.Bgt_un:  			case PE.OpCode.Bgt_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' true' (int)instruction.Value));  				break;  			case PE.OpCode.Bge:  			case PE.OpCode.Bge_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' false' (int)instruction.Value));  				break;  			case PE.OpCode.Bge_un:  			case PE.OpCode.Bge_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' true' (int)instruction.Value));  				break;  			case PE.OpCode.Switch:  				instructions.Add (new SwitchInstruction (offset' (Seq<int>)instruction.Value));  				break;  			case PE.OpCode.Ceq:  				instructions.Add (new CompareInstruction (offset' CompareOp.Ceq' false));  				break;  			case PE.OpCode.Clt:  				instructions.Add (new CompareInstruction (offset' CompareOp.Clt' false));  				break;  			case PE.OpCode.Clt_un:  				instructions.Add (new CompareInstruction (offset' CompareOp.Clt' true));  				break;  			case PE.OpCode.Cgt:  				instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' false));  				break;  			case PE.OpCode.Cgt_un:  				instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' true));  				break;  			case PE.OpCode.Ldarg_0:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));  				break;  			case PE.OpCode.Ldarg_1:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));  				break;  			case PE.OpCode.Ldarg_2:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));  				break;  			case PE.OpCode.Ldarg_3:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));  				break;  			case PE.OpCode.Ldarg:  			case PE.OpCode.Ldarg_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));  				break;  			case PE.OpCode.Ldarga:  			case PE.OpCode.Ldarga_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));  				break;  			case PE.OpCode.Starg:  			case PE.OpCode.Starg_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));  				break;  			case PE.OpCode.Ldloc_0:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 0));  				break;  			case PE.OpCode.Ldloc_1:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 1));  				break;  			case PE.OpCode.Ldloc_2:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 2));  				break;  			case PE.OpCode.Ldloc_3:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 3));  				break;  			case PE.OpCode.Ldloc:  			case PE.OpCode.Ldloc_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));  				break;  			case PE.OpCode.Ldloca:  			case PE.OpCode.Ldloca_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));  				break;  			case PE.OpCode.Stloc_0:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 0));  				break;  			case PE.OpCode.Stloc_1:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 1));  				break;  			case PE.OpCode.Stloc_2:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 2));  				break;  			case PE.OpCode.Stloc_3:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 3));  				break;  			case PE.OpCode.Stloc:  			case PE.OpCode.Stloc_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));  				break;  			case PE.OpCode.Ldfld:  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));  				break;  			case PE.OpCode.Ldsfld:  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));  				break;  			case PE.OpCode.Ldflda:  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));  				break;  			case PE.OpCode.Ldsflda:  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));  				break;  			case PE.OpCode.Stfld:  				instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));  				break;  			case PE.OpCode.Stsfld:  				instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));  				break;  			case PE.OpCode.Ldtoken: {  				if (instruction.Value is FieldRef)  					instructions.Add (new FieldInstruction (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));  				else if (instruction.Value is MethodRef)  					instructions.Add (new MethodInstruction (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));  				else if (instruction.Value is TypeRef)  					// NOTE: May be a higher-kinded type  					instructions.Add (new TypeInstruction (offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));  				else  					throw new InvalidOperationException ("unexpected ldtoken instruction value");  				break;  			}  			case PE.OpCode.Constrained: {  				var constrained = (TypeRef)instruction.Value;  				if (i >= ctxt.Instructions.Length)  					throw new InvalidOperationException ("invalid instructions");  				instruction = ctxt.Instructions [i++];  				if (instruction.OpCode != PE.OpCode.Callvirt)  					throw new InvalidOperationException ("invalid instruction");  				instructions.Add (new MethodInstruction (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));  				break;  			}  			case PE.OpCode.Call:  				instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Callvirt:  				instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Ldftn:  				instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Ldvirtftn:  				instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Newobj:  				instructions.Add (new MethodInstruction (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Ldind_i1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int8Ref));  				break;  			case PE.OpCode.Ldind_u1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt8Ref));  				break;  			case PE.OpCode.Ldind_i2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int16Ref));  				break;  			case PE.OpCode.Ldind_u2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt16Ref));  				break;  			case PE.OpCode.Ldind_i4:  			case PE.OpCode.Ldind_u4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int32Ref));  				break;  			case PE.OpCode.Ldind_i8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int64Ref));  				break;  			case PE.OpCode.Ldind_i:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.IntNativeRef));  				break;  			case PE.OpCode.Ldind_r4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.SingleRef));  				break;  			case PE.OpCode.Ldind_r8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.DoubleRef));  				break;  			case PE.OpCode.Ldobj:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Stind_i1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int8Ref));  				break;  			case PE.OpCode.Stind_i2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int16Ref));  				break;  			case PE.OpCode.Stind_i4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int32Ref));  				break;  			case PE.OpCode.Stind_i8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int64Ref));  				break;  			case PE.OpCode.Stind_i:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.IntNativeRef));  				break;  			case PE.OpCode.Stind_r4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.SingleRef));  				break;  			case PE.OpCode.Stind_r8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.DoubleRef));  				break;  			case PE.OpCode.Stobj:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Cpobj:  				instructions.Add (new TypeInstruction (offset' TypeOp.Cpobj' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Newarr:  				instructions.Add (new TypeInstruction (offset' TypeOp.Newarr' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Initobj:  				instructions.Add (new TypeInstruction (offset' TypeOp.Initobj' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Castclass:  				instructions.Add (new TypeInstruction (offset' TypeOp.Castclass' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Isinst:  				instructions.Add (new TypeInstruction (offset' TypeOp.Isinst' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Box:  				instructions.Add (new TypeInstruction (offset' TypeOp.Box' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Unbox:  				instructions.Add (new TypeInstruction (offset' TypeOp.Unbox' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Unbox_any:  				instructions.Add (new TypeInstruction (offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Ldelem_i1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int8Ref));  				break;  			case PE.OpCode.Ldelem_u1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt8Ref));  				break;  			case PE.OpCode.Ldelem_i2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int16Ref));  				break;  			case PE.OpCode.Ldelem_u2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt16Ref));  				break;  			case PE.OpCode.Ldelem_i4:  			case PE.OpCode.Ldelem_u4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int32Ref));  				break;  			case PE.OpCode.Ldelem_i:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.IntNativeRef));  				break;  			case PE.OpCode.Ldelem_i8:  				// aka ldelem.u8  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int64Ref));  				break;  			case PE.OpCode.Ldelem_r4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.SingleRef));  				break;  			case PE.OpCode.Ldelem_r8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.DoubleRef));  				break;  			case PE.OpCode.Ldelem:  				// aka ldelem.any  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Stelem_i1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int8Ref));  				break;  			case PE.OpCode.Stelem_i2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int16Ref));  				break;  			case PE.OpCode.Stelem_i4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int32Ref));  				break;  			case PE.OpCode.Stelem_i8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int64Ref));  				break;  			case PE.OpCode.Stelem_i:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.IntNativeRef));  				break;  			case PE.OpCode.Stelem_r4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.SingleRef));  				break;  			case PE.OpCode.Stelem_r8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.DoubleRef));  				break;  			case PE.OpCode.Stelem:  				// aka stelem.any  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Readonly:  				if (i >= ctxt.Instructions.Length)  					throw new InvalidOperationException ("invalid instruction");  				instruction = ctxt.Instructions [i++];  				if (instruction.OpCode != PE.OpCode.Ldelema)  					throw new InvalidOperationException ("invalid instruction");  				instructions.Add (new LdElemAddrInstruction (offset' true' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Ldelema:  				instructions.Add (new LdElemAddrInstruction (offset' false' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Ldc_i4_0:  				instructions.Add (new LdInt32Instruction (offset' 0));  				break;  			case PE.OpCode.Ldc_i4_1:  				instructions.Add (new LdInt32Instruction (offset' 1));  				break;  			case PE.OpCode.Ldc_i4_2:  				instructions.Add (new LdInt32Instruction (offset' 2));  				break;  			case PE.OpCode.Ldc_i4_3:  				instructions.Add (new LdInt32Instruction (offset' 3));  				break;  			case PE.OpCode.Ldc_i4_4:  				instructions.Add (new LdInt32Instruction (offset' 4));  				break;  			case PE.OpCode.Ldc_i4_5:  				instructions.Add (new LdInt32Instruction (offset' 5));  				break;  			case PE.OpCode.Ldc_i4_6:  				instructions.Add (new LdInt32Instruction (offset' 6));  				break;  			case PE.OpCode.Ldc_i4_7:  				instructions.Add (new LdInt32Instruction (offset' 7));  				break;  			case PE.OpCode.Ldc_i4_8:  				instructions.Add (new LdInt32Instruction (offset' 8));  				break;  			case PE.OpCode.Ldc_i4_m1:  				instructions.Add (new LdInt32Instruction (offset' -1));  				break;  			case PE.OpCode.Ldc_i4:  			case PE.OpCode.Ldc_i4_s:  				instructions.Add (new LdInt32Instruction (offset' (int)instruction.Value));  				break;  			case PE.OpCode.Ldc_i8:  				instructions.Add (new LdInt64Instruction (offset' (long)instruction.Value));  				break;  			case PE.OpCode.Ldc_r4:  				instructions.Add (new LdSingleInstruction (offset' (float)instruction.Value));  				break;  			case PE.OpCode.Ldc_r8:  				instructions.Add (new LdDoubleInstruction (offset' (double)instruction.Value));  				break;  			case PE.OpCode.Ldstr:  				instructions.Add (new LdStringInstruction (offset' (string)instruction.Value));  				break;  			case PE.OpCode.Add:  				instructions.Add (new ArithInstruction (offset' ArithOp.Add' false' false));  				break;  			case PE.OpCode.Add_ovf:  				instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' false));  				break;  			case PE.OpCode.Add_ovf_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' true));  				break;  			case PE.OpCode.Sub:  				instructions.Add (new ArithInstruction (offset' ArithOp.Sub' false' false));  				break;  			case PE.OpCode.Sub_ovf:  				instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' false));  				break;  			case PE.OpCode.Sub_ovf_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' true));  				break;  			case PE.OpCode.Mul:  				instructions.Add (new ArithInstruction (offset' ArithOp.Mul' false' false));  				break;  			case PE.OpCode.Mul_ovf:  				instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' false));  				break;  			case PE.OpCode.Mul_ovf_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' true));  				break;  			case PE.OpCode.Div:  				instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' false));  				break;  			case PE.OpCode.Div_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' true));  				break;  			case PE.OpCode.Rem:  				instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' false));  				break;  			case PE.OpCode.Rem_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' true));  				break;  			case PE.OpCode.Neg:  				instructions.Add (new ArithInstruction (offset' ArithOp.Neg' false' false));  				break;  			case PE.OpCode.And:  				instructions.Add (new ArithInstruction (offset' ArithOp.BitAnd' false' false));  				break;  			case PE.OpCode.Or:  				instructions.Add (new ArithInstruction (offset' ArithOp.BitOr' false' false));  				break;  			case PE.OpCode.Xor:  				instructions.Add (new ArithInstruction (offset' ArithOp.BitXor' false' false));  				break;  			case PE.OpCode.Not:  				instructions.Add (new ArithInstruction (offset' ArithOp.BitNot' false' false));  				break;  			case PE.OpCode.Shl:  				instructions.Add (new ArithInstruction (offset' ArithOp.Shl' false' false));  				break;  			case PE.OpCode.Shr:  				instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' false));  				break;  			case PE.OpCode.Shr_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' true));  				break;  			case PE.OpCode.Conv_i1:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' false' false));  				break;  			case PE.OpCode.Conv_u1:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' false' false));  				break;  			case PE.OpCode.Conv_i2:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' false' false));  				break;  			case PE.OpCode.Conv_u2:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' false' false));  				break;  			case PE.OpCode.Conv_i4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' false' false));  				break;  			case PE.OpCode.Conv_u4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' false' false));  				break;  			case PE.OpCode.Conv_i8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' false' false));  				break;  			case PE.OpCode.Conv_u8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' false' false));  				break;  			case PE.OpCode.Conv_i:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' false' false));  				break;  			case PE.OpCode.Conv_u:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' false' false));  				break;  			case PE.OpCode.Conv_r4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Single' false' false));  				break;  			case PE.OpCode.Conv_r8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' false));  				break;  			case PE.OpCode.Conv_r_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' true));  				break;  			case PE.OpCode.Conv_ovf_i1:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' false));  				break;  			case PE.OpCode.Conv_ovf_u1:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' false));  				break;  			case PE.OpCode.Conv_ovf_i2:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' false));  				break;  			case PE.OpCode.Conv_ovf_u2:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' false));  				break;  			case PE.OpCode.Conv_ovf_i4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' false));  				break;  			case PE.OpCode.Conv_ovf_u4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' false));  				break;  			case PE.OpCode.Conv_ovf_i8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' false));  				break;  			case PE.OpCode.Conv_ovf_u8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' false));  				break;  			case PE.OpCode.Conv_ovf_i:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' false));  				break;  			case PE.OpCode.Conv_ovf_u:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' false));  				break;  			case PE.OpCode.Conv_ovf_i1_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' true));  				break;  			case PE.OpCode.Conv_ovf_u1_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' true));  				break;  			case PE.OpCode.Conv_ovf_i2_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' true));  				break;  			case PE.OpCode.Conv_ovf_u2_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' true));  				break;  			case PE.OpCode.Conv_ovf_i4_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' true));  				break;  			case PE.OpCode.Conv_ovf_u4_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' true));  				break;  			case PE.OpCode.Conv_ovf_i8_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' true));  				break;  			case PE.OpCode.Conv_ovf_u8_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' true));  				break;  			case PE.OpCode.Conv_ovf_i_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' true));  				break;  			case PE.OpCode.Conv_ovf_u_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' true));  				break;  			default:  				throw new InvalidOperationException ("invalid instruction");  			}  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: while (!ctxt.AtEnd (i)) {  	var j = i > ctxt.Start ? ctxt.JumpOverHandlers (i) : i;  	if (j > i)  		i = j;  	else {  		var ehcs = ctxt.OutermostTryBlocks (i);  		if (ehcs != null) {  			// A try instruction begins here with given handlers  			var offset = ctxt.Instructions [i].Offset;  			var tryCtxt = new TryTranslationContext (ctxt' i' ehcs);  			var tryBlock = InstructionsFromContext (tryCtxt);  			var handlers = new Seq<TryInstructionHandler> ();  			foreach (var ehc in ehcs) {  				var handlerCtxt = new HandlerTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.HandlerOffset]' ehc);  				var handlerBlock = InstructionsFromContext (handlerCtxt);  				switch (ehc.Flags) {  				case PE.CorILExceptionClause.Exception:  					handlers.Add (new CatchTryInstructionHandler ((TypeRef)ehc.Class' handlerBlock));  					break;  				case PE.CorILExceptionClause.Filter: {  					var filterCtxt = new FilterTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.FilterOffset]' ehc);  					var filterBlock = InstructionsFromContext (filterCtxt);  					handlers.Add (new FilterTryInstructionHandler (filterBlock' handlerBlock));  					break;  				}  				case PE.CorILExceptionClause.Finally:  					handlers.Add (new FinallyTryInstructionHandler (handlerBlock));  					break;  				case PE.CorILExceptionClause.Fault:  					handlers.Add (new FaultTryInstructionHandler (handlerBlock));  					break;  				default:  					throw new ArgumentOutOfRangeException ();  				}  			}  			instructions.Add (new TryInstruction (offset' tryBlock' handlers));  			// Jump over try block  			var nextOffset = ehcs [0].TryOffset + ehcs [0].TryLength;  			if (!ctxt.OffsetToIndex.TryGetValue (nextOffset' out i))  				i = ctxt.Instructions.Length;  		}  		else {  			var instruction = ctxt.Instructions [i++];  			var offset = instruction.Offset;  			while (instruction.OpCode == PE.OpCode.Unaligned || instruction.OpCode == PE.OpCode.Volatile || instruction.OpCode == PE.OpCode.Tailcall) {  				// Skip over any ignored prefixes' but remember instruction begins at original offset  				// NOTE: What ever happened to the "no." prefix mentioned in the spec?  				if (i >= ctxt.Instructions.Length)  					throw new InvalidOperationException ("invalid instructions");  				instruction = ctxt.Instructions [i++];  			}  			switch (instruction.OpCode) {  			case PE.OpCode.Cpblk:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Cpblk));  				break;  			case PE.OpCode.Initblk:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Initblk));  				break;  			case PE.OpCode.Arglist:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Arglist));  				break;  			case PE.OpCode.Localloc:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Localloc));  				break;  			case PE.OpCode.Jmp:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Jmp));  				break;  			case PE.OpCode.Calli:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Calli));  				break;  			case PE.OpCode.Sizeof:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Sizeof));  				break;  			case PE.OpCode.Mkrefany:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Mkrefany));  				break;  			case PE.OpCode.Refanytype:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanytype));  				break;  			case PE.OpCode.Refanyval:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanyval));  				break;  			case PE.OpCode.Nop:  				instructions.Add (new MiscInstruction (offset' MiscOp.Nop));  				break;  			case PE.OpCode.Break:  				instructions.Add (new MiscInstruction (offset' MiscOp.Break));  				break;  			case PE.OpCode.Dup:  				instructions.Add (new MiscInstruction (offset' MiscOp.Dup));  				break;  			case PE.OpCode.Pop:  				instructions.Add (new MiscInstruction (offset' MiscOp.Pop));  				break;  			case PE.OpCode.Ldnull:  				instructions.Add (new MiscInstruction (offset' MiscOp.Ldnull));  				break;  			case PE.OpCode.Ckfinite:  				instructions.Add (new MiscInstruction (offset' MiscOp.Ckfinite));  				break;  			case PE.OpCode.Throw:  				instructions.Add (new MiscInstruction (offset' MiscOp.Throw));  				break;  			case PE.OpCode.Rethrow:  				instructions.Add (new MiscInstruction (offset' MiscOp.Rethrow));  				break;  			case PE.OpCode.Ldind_ref:  				instructions.Add (new MiscInstruction (offset' MiscOp.LdindRef));  				break;  			case PE.OpCode.Stind_ref:  				instructions.Add (new MiscInstruction (offset' MiscOp.StindRef));  				break;  			case PE.OpCode.Ldelem_ref:  				instructions.Add (new MiscInstruction (offset' MiscOp.LdelemRef));  				break;  			case PE.OpCode.Stelem_ref:  				instructions.Add (new MiscInstruction (offset' MiscOp.StelemRef));  				break;  			case PE.OpCode.Ldlen:  				instructions.Add (new MiscInstruction (offset' MiscOp.Ldlen));  				break;  			case PE.OpCode.Ret:  				if (ctxt.ResultType == null)  					instructions.Add (new MiscInstruction (offset' MiscOp.Ret));  				else  					instructions.Add (new MiscInstruction (offset' MiscOp.RetVal));  				break;  			case PE.OpCode.Endfilter:  				instructions.Add (new MiscInstruction (offset' MiscOp.Endfilter));  				break;  			case PE.OpCode.Endfinally:  				// aka EndFault  				instructions.Add (new MiscInstruction (offset' MiscOp.Endfinally));  				break;  			case PE.OpCode.Br_s:  			case PE.OpCode.Br:  				instructions.Add (new BranchInstruction (offset' BranchOp.Br' false' (int)instruction.Value));  				break;  			case PE.OpCode.Brtrue_s:  			// aka brinst.s  			case PE.OpCode.Brtrue:  				// aka brinst  				instructions.Add (new BranchInstruction (offset' BranchOp.Brtrue' false' (int)instruction.Value));  				break;  			case PE.OpCode.Brfalse_s:  			// aka brzero.s' brnull.s  			case PE.OpCode.Brfalse:  				// aka brzero' brnull  				instructions.Add (new BranchInstruction (offset' BranchOp.Brfalse' false' (int)instruction.Value));  				break;  			case PE.OpCode.Beq:  			case PE.OpCode.Beq_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.Breq' false' (int)instruction.Value));  				break;  			case PE.OpCode.Bne_un:  			case PE.OpCode.Bne_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.Brne' false' (int)instruction.Value));  				break;  			case PE.OpCode.Leave:  			case PE.OpCode.Leave_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.Leave' false' (int)instruction.Value));  				break;  			case PE.OpCode.Blt:  			case PE.OpCode.Blt_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' false' (int)instruction.Value));  				break;  			case PE.OpCode.Blt_un:  			case PE.OpCode.Blt_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' true' (int)instruction.Value));  				break;  			case PE.OpCode.Ble:  			case PE.OpCode.Ble_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' false' (int)instruction.Value));  				break;  			case PE.OpCode.Ble_un:  			case PE.OpCode.Ble_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' true' (int)instruction.Value));  				break;  			case PE.OpCode.Bgt:  			case PE.OpCode.Bgt_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' false' (int)instruction.Value));  				break;  			case PE.OpCode.Bgt_un:  			case PE.OpCode.Bgt_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' true' (int)instruction.Value));  				break;  			case PE.OpCode.Bge:  			case PE.OpCode.Bge_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' false' (int)instruction.Value));  				break;  			case PE.OpCode.Bge_un:  			case PE.OpCode.Bge_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' true' (int)instruction.Value));  				break;  			case PE.OpCode.Switch:  				instructions.Add (new SwitchInstruction (offset' (Seq<int>)instruction.Value));  				break;  			case PE.OpCode.Ceq:  				instructions.Add (new CompareInstruction (offset' CompareOp.Ceq' false));  				break;  			case PE.OpCode.Clt:  				instructions.Add (new CompareInstruction (offset' CompareOp.Clt' false));  				break;  			case PE.OpCode.Clt_un:  				instructions.Add (new CompareInstruction (offset' CompareOp.Clt' true));  				break;  			case PE.OpCode.Cgt:  				instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' false));  				break;  			case PE.OpCode.Cgt_un:  				instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' true));  				break;  			case PE.OpCode.Ldarg_0:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));  				break;  			case PE.OpCode.Ldarg_1:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));  				break;  			case PE.OpCode.Ldarg_2:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));  				break;  			case PE.OpCode.Ldarg_3:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));  				break;  			case PE.OpCode.Ldarg:  			case PE.OpCode.Ldarg_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));  				break;  			case PE.OpCode.Ldarga:  			case PE.OpCode.Ldarga_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));  				break;  			case PE.OpCode.Starg:  			case PE.OpCode.Starg_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));  				break;  			case PE.OpCode.Ldloc_0:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 0));  				break;  			case PE.OpCode.Ldloc_1:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 1));  				break;  			case PE.OpCode.Ldloc_2:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 2));  				break;  			case PE.OpCode.Ldloc_3:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 3));  				break;  			case PE.OpCode.Ldloc:  			case PE.OpCode.Ldloc_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));  				break;  			case PE.OpCode.Ldloca:  			case PE.OpCode.Ldloca_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));  				break;  			case PE.OpCode.Stloc_0:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 0));  				break;  			case PE.OpCode.Stloc_1:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 1));  				break;  			case PE.OpCode.Stloc_2:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 2));  				break;  			case PE.OpCode.Stloc_3:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 3));  				break;  			case PE.OpCode.Stloc:  			case PE.OpCode.Stloc_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));  				break;  			case PE.OpCode.Ldfld:  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));  				break;  			case PE.OpCode.Ldsfld:  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));  				break;  			case PE.OpCode.Ldflda:  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));  				break;  			case PE.OpCode.Ldsflda:  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));  				break;  			case PE.OpCode.Stfld:  				instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));  				break;  			case PE.OpCode.Stsfld:  				instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));  				break;  			case PE.OpCode.Ldtoken: {  				if (instruction.Value is FieldRef)  					instructions.Add (new FieldInstruction (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));  				else if (instruction.Value is MethodRef)  					instructions.Add (new MethodInstruction (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));  				else if (instruction.Value is TypeRef)  					// NOTE: May be a higher-kinded type  					instructions.Add (new TypeInstruction (offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));  				else  					throw new InvalidOperationException ("unexpected ldtoken instruction value");  				break;  			}  			case PE.OpCode.Constrained: {  				var constrained = (TypeRef)instruction.Value;  				if (i >= ctxt.Instructions.Length)  					throw new InvalidOperationException ("invalid instructions");  				instruction = ctxt.Instructions [i++];  				if (instruction.OpCode != PE.OpCode.Callvirt)  					throw new InvalidOperationException ("invalid instruction");  				instructions.Add (new MethodInstruction (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));  				break;  			}  			case PE.OpCode.Call:  				instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Callvirt:  				instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Ldftn:  				instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Ldvirtftn:  				instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Newobj:  				instructions.Add (new MethodInstruction (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Ldind_i1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int8Ref));  				break;  			case PE.OpCode.Ldind_u1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt8Ref));  				break;  			case PE.OpCode.Ldind_i2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int16Ref));  				break;  			case PE.OpCode.Ldind_u2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt16Ref));  				break;  			case PE.OpCode.Ldind_i4:  			case PE.OpCode.Ldind_u4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int32Ref));  				break;  			case PE.OpCode.Ldind_i8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int64Ref));  				break;  			case PE.OpCode.Ldind_i:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.IntNativeRef));  				break;  			case PE.OpCode.Ldind_r4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.SingleRef));  				break;  			case PE.OpCode.Ldind_r8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.DoubleRef));  				break;  			case PE.OpCode.Ldobj:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Stind_i1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int8Ref));  				break;  			case PE.OpCode.Stind_i2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int16Ref));  				break;  			case PE.OpCode.Stind_i4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int32Ref));  				break;  			case PE.OpCode.Stind_i8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int64Ref));  				break;  			case PE.OpCode.Stind_i:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.IntNativeRef));  				break;  			case PE.OpCode.Stind_r4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.SingleRef));  				break;  			case PE.OpCode.Stind_r8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.DoubleRef));  				break;  			case PE.OpCode.Stobj:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Cpobj:  				instructions.Add (new TypeInstruction (offset' TypeOp.Cpobj' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Newarr:  				instructions.Add (new TypeInstruction (offset' TypeOp.Newarr' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Initobj:  				instructions.Add (new TypeInstruction (offset' TypeOp.Initobj' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Castclass:  				instructions.Add (new TypeInstruction (offset' TypeOp.Castclass' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Isinst:  				instructions.Add (new TypeInstruction (offset' TypeOp.Isinst' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Box:  				instructions.Add (new TypeInstruction (offset' TypeOp.Box' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Unbox:  				instructions.Add (new TypeInstruction (offset' TypeOp.Unbox' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Unbox_any:  				instructions.Add (new TypeInstruction (offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Ldelem_i1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int8Ref));  				break;  			case PE.OpCode.Ldelem_u1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt8Ref));  				break;  			case PE.OpCode.Ldelem_i2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int16Ref));  				break;  			case PE.OpCode.Ldelem_u2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt16Ref));  				break;  			case PE.OpCode.Ldelem_i4:  			case PE.OpCode.Ldelem_u4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int32Ref));  				break;  			case PE.OpCode.Ldelem_i:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.IntNativeRef));  				break;  			case PE.OpCode.Ldelem_i8:  				// aka ldelem.u8  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int64Ref));  				break;  			case PE.OpCode.Ldelem_r4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.SingleRef));  				break;  			case PE.OpCode.Ldelem_r8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.DoubleRef));  				break;  			case PE.OpCode.Ldelem:  				// aka ldelem.any  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Stelem_i1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int8Ref));  				break;  			case PE.OpCode.Stelem_i2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int16Ref));  				break;  			case PE.OpCode.Stelem_i4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int32Ref));  				break;  			case PE.OpCode.Stelem_i8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int64Ref));  				break;  			case PE.OpCode.Stelem_i:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.IntNativeRef));  				break;  			case PE.OpCode.Stelem_r4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.SingleRef));  				break;  			case PE.OpCode.Stelem_r8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.DoubleRef));  				break;  			case PE.OpCode.Stelem:  				// aka stelem.any  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Readonly:  				if (i >= ctxt.Instructions.Length)  					throw new InvalidOperationException ("invalid instruction");  				instruction = ctxt.Instructions [i++];  				if (instruction.OpCode != PE.OpCode.Ldelema)  					throw new InvalidOperationException ("invalid instruction");  				instructions.Add (new LdElemAddrInstruction (offset' true' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Ldelema:  				instructions.Add (new LdElemAddrInstruction (offset' false' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Ldc_i4_0:  				instructions.Add (new LdInt32Instruction (offset' 0));  				break;  			case PE.OpCode.Ldc_i4_1:  				instructions.Add (new LdInt32Instruction (offset' 1));  				break;  			case PE.OpCode.Ldc_i4_2:  				instructions.Add (new LdInt32Instruction (offset' 2));  				break;  			case PE.OpCode.Ldc_i4_3:  				instructions.Add (new LdInt32Instruction (offset' 3));  				break;  			case PE.OpCode.Ldc_i4_4:  				instructions.Add (new LdInt32Instruction (offset' 4));  				break;  			case PE.OpCode.Ldc_i4_5:  				instructions.Add (new LdInt32Instruction (offset' 5));  				break;  			case PE.OpCode.Ldc_i4_6:  				instructions.Add (new LdInt32Instruction (offset' 6));  				break;  			case PE.OpCode.Ldc_i4_7:  				instructions.Add (new LdInt32Instruction (offset' 7));  				break;  			case PE.OpCode.Ldc_i4_8:  				instructions.Add (new LdInt32Instruction (offset' 8));  				break;  			case PE.OpCode.Ldc_i4_m1:  				instructions.Add (new LdInt32Instruction (offset' -1));  				break;  			case PE.OpCode.Ldc_i4:  			case PE.OpCode.Ldc_i4_s:  				instructions.Add (new LdInt32Instruction (offset' (int)instruction.Value));  				break;  			case PE.OpCode.Ldc_i8:  				instructions.Add (new LdInt64Instruction (offset' (long)instruction.Value));  				break;  			case PE.OpCode.Ldc_r4:  				instructions.Add (new LdSingleInstruction (offset' (float)instruction.Value));  				break;  			case PE.OpCode.Ldc_r8:  				instructions.Add (new LdDoubleInstruction (offset' (double)instruction.Value));  				break;  			case PE.OpCode.Ldstr:  				instructions.Add (new LdStringInstruction (offset' (string)instruction.Value));  				break;  			case PE.OpCode.Add:  				instructions.Add (new ArithInstruction (offset' ArithOp.Add' false' false));  				break;  			case PE.OpCode.Add_ovf:  				instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' false));  				break;  			case PE.OpCode.Add_ovf_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' true));  				break;  			case PE.OpCode.Sub:  				instructions.Add (new ArithInstruction (offset' ArithOp.Sub' false' false));  				break;  			case PE.OpCode.Sub_ovf:  				instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' false));  				break;  			case PE.OpCode.Sub_ovf_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' true));  				break;  			case PE.OpCode.Mul:  				instructions.Add (new ArithInstruction (offset' ArithOp.Mul' false' false));  				break;  			case PE.OpCode.Mul_ovf:  				instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' false));  				break;  			case PE.OpCode.Mul_ovf_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' true));  				break;  			case PE.OpCode.Div:  				instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' false));  				break;  			case PE.OpCode.Div_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' true));  				break;  			case PE.OpCode.Rem:  				instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' false));  				break;  			case PE.OpCode.Rem_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' true));  				break;  			case PE.OpCode.Neg:  				instructions.Add (new ArithInstruction (offset' ArithOp.Neg' false' false));  				break;  			case PE.OpCode.And:  				instructions.Add (new ArithInstruction (offset' ArithOp.BitAnd' false' false));  				break;  			case PE.OpCode.Or:  				instructions.Add (new ArithInstruction (offset' ArithOp.BitOr' false' false));  				break;  			case PE.OpCode.Xor:  				instructions.Add (new ArithInstruction (offset' ArithOp.BitXor' false' false));  				break;  			case PE.OpCode.Not:  				instructions.Add (new ArithInstruction (offset' ArithOp.BitNot' false' false));  				break;  			case PE.OpCode.Shl:  				instructions.Add (new ArithInstruction (offset' ArithOp.Shl' false' false));  				break;  			case PE.OpCode.Shr:  				instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' false));  				break;  			case PE.OpCode.Shr_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' true));  				break;  			case PE.OpCode.Conv_i1:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' false' false));  				break;  			case PE.OpCode.Conv_u1:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' false' false));  				break;  			case PE.OpCode.Conv_i2:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' false' false));  				break;  			case PE.OpCode.Conv_u2:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' false' false));  				break;  			case PE.OpCode.Conv_i4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' false' false));  				break;  			case PE.OpCode.Conv_u4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' false' false));  				break;  			case PE.OpCode.Conv_i8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' false' false));  				break;  			case PE.OpCode.Conv_u8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' false' false));  				break;  			case PE.OpCode.Conv_i:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' false' false));  				break;  			case PE.OpCode.Conv_u:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' false' false));  				break;  			case PE.OpCode.Conv_r4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Single' false' false));  				break;  			case PE.OpCode.Conv_r8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' false));  				break;  			case PE.OpCode.Conv_r_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' true));  				break;  			case PE.OpCode.Conv_ovf_i1:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' false));  				break;  			case PE.OpCode.Conv_ovf_u1:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' false));  				break;  			case PE.OpCode.Conv_ovf_i2:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' false));  				break;  			case PE.OpCode.Conv_ovf_u2:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' false));  				break;  			case PE.OpCode.Conv_ovf_i4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' false));  				break;  			case PE.OpCode.Conv_ovf_u4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' false));  				break;  			case PE.OpCode.Conv_ovf_i8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' false));  				break;  			case PE.OpCode.Conv_ovf_u8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' false));  				break;  			case PE.OpCode.Conv_ovf_i:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' false));  				break;  			case PE.OpCode.Conv_ovf_u:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' false));  				break;  			case PE.OpCode.Conv_ovf_i1_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' true));  				break;  			case PE.OpCode.Conv_ovf_u1_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' true));  				break;  			case PE.OpCode.Conv_ovf_i2_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' true));  				break;  			case PE.OpCode.Conv_ovf_u2_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' true));  				break;  			case PE.OpCode.Conv_ovf_i4_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' true));  				break;  			case PE.OpCode.Conv_ovf_u4_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' true));  				break;  			case PE.OpCode.Conv_ovf_i8_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' true));  				break;  			case PE.OpCode.Conv_ovf_u8_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' true));  				break;  			case PE.OpCode.Conv_ovf_i_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' true));  				break;  			case PE.OpCode.Conv_ovf_u_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' true));  				break;  			default:  				throw new InvalidOperationException ("invalid instruction");  			}  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: while (!ctxt.AtEnd (i)) {  	var j = i > ctxt.Start ? ctxt.JumpOverHandlers (i) : i;  	if (j > i)  		i = j;  	else {  		var ehcs = ctxt.OutermostTryBlocks (i);  		if (ehcs != null) {  			// A try instruction begins here with given handlers  			var offset = ctxt.Instructions [i].Offset;  			var tryCtxt = new TryTranslationContext (ctxt' i' ehcs);  			var tryBlock = InstructionsFromContext (tryCtxt);  			var handlers = new Seq<TryInstructionHandler> ();  			foreach (var ehc in ehcs) {  				var handlerCtxt = new HandlerTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.HandlerOffset]' ehc);  				var handlerBlock = InstructionsFromContext (handlerCtxt);  				switch (ehc.Flags) {  				case PE.CorILExceptionClause.Exception:  					handlers.Add (new CatchTryInstructionHandler ((TypeRef)ehc.Class' handlerBlock));  					break;  				case PE.CorILExceptionClause.Filter: {  					var filterCtxt = new FilterTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.FilterOffset]' ehc);  					var filterBlock = InstructionsFromContext (filterCtxt);  					handlers.Add (new FilterTryInstructionHandler (filterBlock' handlerBlock));  					break;  				}  				case PE.CorILExceptionClause.Finally:  					handlers.Add (new FinallyTryInstructionHandler (handlerBlock));  					break;  				case PE.CorILExceptionClause.Fault:  					handlers.Add (new FaultTryInstructionHandler (handlerBlock));  					break;  				default:  					throw new ArgumentOutOfRangeException ();  				}  			}  			instructions.Add (new TryInstruction (offset' tryBlock' handlers));  			// Jump over try block  			var nextOffset = ehcs [0].TryOffset + ehcs [0].TryLength;  			if (!ctxt.OffsetToIndex.TryGetValue (nextOffset' out i))  				i = ctxt.Instructions.Length;  		}  		else {  			var instruction = ctxt.Instructions [i++];  			var offset = instruction.Offset;  			while (instruction.OpCode == PE.OpCode.Unaligned || instruction.OpCode == PE.OpCode.Volatile || instruction.OpCode == PE.OpCode.Tailcall) {  				// Skip over any ignored prefixes' but remember instruction begins at original offset  				// NOTE: What ever happened to the "no." prefix mentioned in the spec?  				if (i >= ctxt.Instructions.Length)  					throw new InvalidOperationException ("invalid instructions");  				instruction = ctxt.Instructions [i++];  			}  			switch (instruction.OpCode) {  			case PE.OpCode.Cpblk:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Cpblk));  				break;  			case PE.OpCode.Initblk:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Initblk));  				break;  			case PE.OpCode.Arglist:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Arglist));  				break;  			case PE.OpCode.Localloc:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Localloc));  				break;  			case PE.OpCode.Jmp:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Jmp));  				break;  			case PE.OpCode.Calli:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Calli));  				break;  			case PE.OpCode.Sizeof:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Sizeof));  				break;  			case PE.OpCode.Mkrefany:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Mkrefany));  				break;  			case PE.OpCode.Refanytype:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanytype));  				break;  			case PE.OpCode.Refanyval:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanyval));  				break;  			case PE.OpCode.Nop:  				instructions.Add (new MiscInstruction (offset' MiscOp.Nop));  				break;  			case PE.OpCode.Break:  				instructions.Add (new MiscInstruction (offset' MiscOp.Break));  				break;  			case PE.OpCode.Dup:  				instructions.Add (new MiscInstruction (offset' MiscOp.Dup));  				break;  			case PE.OpCode.Pop:  				instructions.Add (new MiscInstruction (offset' MiscOp.Pop));  				break;  			case PE.OpCode.Ldnull:  				instructions.Add (new MiscInstruction (offset' MiscOp.Ldnull));  				break;  			case PE.OpCode.Ckfinite:  				instructions.Add (new MiscInstruction (offset' MiscOp.Ckfinite));  				break;  			case PE.OpCode.Throw:  				instructions.Add (new MiscInstruction (offset' MiscOp.Throw));  				break;  			case PE.OpCode.Rethrow:  				instructions.Add (new MiscInstruction (offset' MiscOp.Rethrow));  				break;  			case PE.OpCode.Ldind_ref:  				instructions.Add (new MiscInstruction (offset' MiscOp.LdindRef));  				break;  			case PE.OpCode.Stind_ref:  				instructions.Add (new MiscInstruction (offset' MiscOp.StindRef));  				break;  			case PE.OpCode.Ldelem_ref:  				instructions.Add (new MiscInstruction (offset' MiscOp.LdelemRef));  				break;  			case PE.OpCode.Stelem_ref:  				instructions.Add (new MiscInstruction (offset' MiscOp.StelemRef));  				break;  			case PE.OpCode.Ldlen:  				instructions.Add (new MiscInstruction (offset' MiscOp.Ldlen));  				break;  			case PE.OpCode.Ret:  				if (ctxt.ResultType == null)  					instructions.Add (new MiscInstruction (offset' MiscOp.Ret));  				else  					instructions.Add (new MiscInstruction (offset' MiscOp.RetVal));  				break;  			case PE.OpCode.Endfilter:  				instructions.Add (new MiscInstruction (offset' MiscOp.Endfilter));  				break;  			case PE.OpCode.Endfinally:  				// aka EndFault  				instructions.Add (new MiscInstruction (offset' MiscOp.Endfinally));  				break;  			case PE.OpCode.Br_s:  			case PE.OpCode.Br:  				instructions.Add (new BranchInstruction (offset' BranchOp.Br' false' (int)instruction.Value));  				break;  			case PE.OpCode.Brtrue_s:  			// aka brinst.s  			case PE.OpCode.Brtrue:  				// aka brinst  				instructions.Add (new BranchInstruction (offset' BranchOp.Brtrue' false' (int)instruction.Value));  				break;  			case PE.OpCode.Brfalse_s:  			// aka brzero.s' brnull.s  			case PE.OpCode.Brfalse:  				// aka brzero' brnull  				instructions.Add (new BranchInstruction (offset' BranchOp.Brfalse' false' (int)instruction.Value));  				break;  			case PE.OpCode.Beq:  			case PE.OpCode.Beq_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.Breq' false' (int)instruction.Value));  				break;  			case PE.OpCode.Bne_un:  			case PE.OpCode.Bne_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.Brne' false' (int)instruction.Value));  				break;  			case PE.OpCode.Leave:  			case PE.OpCode.Leave_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.Leave' false' (int)instruction.Value));  				break;  			case PE.OpCode.Blt:  			case PE.OpCode.Blt_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' false' (int)instruction.Value));  				break;  			case PE.OpCode.Blt_un:  			case PE.OpCode.Blt_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' true' (int)instruction.Value));  				break;  			case PE.OpCode.Ble:  			case PE.OpCode.Ble_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' false' (int)instruction.Value));  				break;  			case PE.OpCode.Ble_un:  			case PE.OpCode.Ble_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' true' (int)instruction.Value));  				break;  			case PE.OpCode.Bgt:  			case PE.OpCode.Bgt_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' false' (int)instruction.Value));  				break;  			case PE.OpCode.Bgt_un:  			case PE.OpCode.Bgt_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' true' (int)instruction.Value));  				break;  			case PE.OpCode.Bge:  			case PE.OpCode.Bge_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' false' (int)instruction.Value));  				break;  			case PE.OpCode.Bge_un:  			case PE.OpCode.Bge_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' true' (int)instruction.Value));  				break;  			case PE.OpCode.Switch:  				instructions.Add (new SwitchInstruction (offset' (Seq<int>)instruction.Value));  				break;  			case PE.OpCode.Ceq:  				instructions.Add (new CompareInstruction (offset' CompareOp.Ceq' false));  				break;  			case PE.OpCode.Clt:  				instructions.Add (new CompareInstruction (offset' CompareOp.Clt' false));  				break;  			case PE.OpCode.Clt_un:  				instructions.Add (new CompareInstruction (offset' CompareOp.Clt' true));  				break;  			case PE.OpCode.Cgt:  				instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' false));  				break;  			case PE.OpCode.Cgt_un:  				instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' true));  				break;  			case PE.OpCode.Ldarg_0:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));  				break;  			case PE.OpCode.Ldarg_1:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));  				break;  			case PE.OpCode.Ldarg_2:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));  				break;  			case PE.OpCode.Ldarg_3:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));  				break;  			case PE.OpCode.Ldarg:  			case PE.OpCode.Ldarg_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));  				break;  			case PE.OpCode.Ldarga:  			case PE.OpCode.Ldarga_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));  				break;  			case PE.OpCode.Starg:  			case PE.OpCode.Starg_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));  				break;  			case PE.OpCode.Ldloc_0:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 0));  				break;  			case PE.OpCode.Ldloc_1:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 1));  				break;  			case PE.OpCode.Ldloc_2:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 2));  				break;  			case PE.OpCode.Ldloc_3:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 3));  				break;  			case PE.OpCode.Ldloc:  			case PE.OpCode.Ldloc_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));  				break;  			case PE.OpCode.Ldloca:  			case PE.OpCode.Ldloca_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));  				break;  			case PE.OpCode.Stloc_0:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 0));  				break;  			case PE.OpCode.Stloc_1:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 1));  				break;  			case PE.OpCode.Stloc_2:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 2));  				break;  			case PE.OpCode.Stloc_3:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 3));  				break;  			case PE.OpCode.Stloc:  			case PE.OpCode.Stloc_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));  				break;  			case PE.OpCode.Ldfld:  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));  				break;  			case PE.OpCode.Ldsfld:  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));  				break;  			case PE.OpCode.Ldflda:  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));  				break;  			case PE.OpCode.Ldsflda:  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));  				break;  			case PE.OpCode.Stfld:  				instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));  				break;  			case PE.OpCode.Stsfld:  				instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));  				break;  			case PE.OpCode.Ldtoken: {  				if (instruction.Value is FieldRef)  					instructions.Add (new FieldInstruction (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));  				else if (instruction.Value is MethodRef)  					instructions.Add (new MethodInstruction (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));  				else if (instruction.Value is TypeRef)  					// NOTE: May be a higher-kinded type  					instructions.Add (new TypeInstruction (offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));  				else  					throw new InvalidOperationException ("unexpected ldtoken instruction value");  				break;  			}  			case PE.OpCode.Constrained: {  				var constrained = (TypeRef)instruction.Value;  				if (i >= ctxt.Instructions.Length)  					throw new InvalidOperationException ("invalid instructions");  				instruction = ctxt.Instructions [i++];  				if (instruction.OpCode != PE.OpCode.Callvirt)  					throw new InvalidOperationException ("invalid instruction");  				instructions.Add (new MethodInstruction (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));  				break;  			}  			case PE.OpCode.Call:  				instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Callvirt:  				instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Ldftn:  				instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Ldvirtftn:  				instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Newobj:  				instructions.Add (new MethodInstruction (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Ldind_i1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int8Ref));  				break;  			case PE.OpCode.Ldind_u1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt8Ref));  				break;  			case PE.OpCode.Ldind_i2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int16Ref));  				break;  			case PE.OpCode.Ldind_u2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt16Ref));  				break;  			case PE.OpCode.Ldind_i4:  			case PE.OpCode.Ldind_u4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int32Ref));  				break;  			case PE.OpCode.Ldind_i8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int64Ref));  				break;  			case PE.OpCode.Ldind_i:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.IntNativeRef));  				break;  			case PE.OpCode.Ldind_r4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.SingleRef));  				break;  			case PE.OpCode.Ldind_r8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.DoubleRef));  				break;  			case PE.OpCode.Ldobj:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Stind_i1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int8Ref));  				break;  			case PE.OpCode.Stind_i2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int16Ref));  				break;  			case PE.OpCode.Stind_i4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int32Ref));  				break;  			case PE.OpCode.Stind_i8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int64Ref));  				break;  			case PE.OpCode.Stind_i:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.IntNativeRef));  				break;  			case PE.OpCode.Stind_r4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.SingleRef));  				break;  			case PE.OpCode.Stind_r8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.DoubleRef));  				break;  			case PE.OpCode.Stobj:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Cpobj:  				instructions.Add (new TypeInstruction (offset' TypeOp.Cpobj' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Newarr:  				instructions.Add (new TypeInstruction (offset' TypeOp.Newarr' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Initobj:  				instructions.Add (new TypeInstruction (offset' TypeOp.Initobj' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Castclass:  				instructions.Add (new TypeInstruction (offset' TypeOp.Castclass' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Isinst:  				instructions.Add (new TypeInstruction (offset' TypeOp.Isinst' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Box:  				instructions.Add (new TypeInstruction (offset' TypeOp.Box' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Unbox:  				instructions.Add (new TypeInstruction (offset' TypeOp.Unbox' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Unbox_any:  				instructions.Add (new TypeInstruction (offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Ldelem_i1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int8Ref));  				break;  			case PE.OpCode.Ldelem_u1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt8Ref));  				break;  			case PE.OpCode.Ldelem_i2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int16Ref));  				break;  			case PE.OpCode.Ldelem_u2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt16Ref));  				break;  			case PE.OpCode.Ldelem_i4:  			case PE.OpCode.Ldelem_u4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int32Ref));  				break;  			case PE.OpCode.Ldelem_i:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.IntNativeRef));  				break;  			case PE.OpCode.Ldelem_i8:  				// aka ldelem.u8  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int64Ref));  				break;  			case PE.OpCode.Ldelem_r4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.SingleRef));  				break;  			case PE.OpCode.Ldelem_r8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.DoubleRef));  				break;  			case PE.OpCode.Ldelem:  				// aka ldelem.any  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Stelem_i1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int8Ref));  				break;  			case PE.OpCode.Stelem_i2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int16Ref));  				break;  			case PE.OpCode.Stelem_i4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int32Ref));  				break;  			case PE.OpCode.Stelem_i8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int64Ref));  				break;  			case PE.OpCode.Stelem_i:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.IntNativeRef));  				break;  			case PE.OpCode.Stelem_r4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.SingleRef));  				break;  			case PE.OpCode.Stelem_r8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.DoubleRef));  				break;  			case PE.OpCode.Stelem:  				// aka stelem.any  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Readonly:  				if (i >= ctxt.Instructions.Length)  					throw new InvalidOperationException ("invalid instruction");  				instruction = ctxt.Instructions [i++];  				if (instruction.OpCode != PE.OpCode.Ldelema)  					throw new InvalidOperationException ("invalid instruction");  				instructions.Add (new LdElemAddrInstruction (offset' true' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Ldelema:  				instructions.Add (new LdElemAddrInstruction (offset' false' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Ldc_i4_0:  				instructions.Add (new LdInt32Instruction (offset' 0));  				break;  			case PE.OpCode.Ldc_i4_1:  				instructions.Add (new LdInt32Instruction (offset' 1));  				break;  			case PE.OpCode.Ldc_i4_2:  				instructions.Add (new LdInt32Instruction (offset' 2));  				break;  			case PE.OpCode.Ldc_i4_3:  				instructions.Add (new LdInt32Instruction (offset' 3));  				break;  			case PE.OpCode.Ldc_i4_4:  				instructions.Add (new LdInt32Instruction (offset' 4));  				break;  			case PE.OpCode.Ldc_i4_5:  				instructions.Add (new LdInt32Instruction (offset' 5));  				break;  			case PE.OpCode.Ldc_i4_6:  				instructions.Add (new LdInt32Instruction (offset' 6));  				break;  			case PE.OpCode.Ldc_i4_7:  				instructions.Add (new LdInt32Instruction (offset' 7));  				break;  			case PE.OpCode.Ldc_i4_8:  				instructions.Add (new LdInt32Instruction (offset' 8));  				break;  			case PE.OpCode.Ldc_i4_m1:  				instructions.Add (new LdInt32Instruction (offset' -1));  				break;  			case PE.OpCode.Ldc_i4:  			case PE.OpCode.Ldc_i4_s:  				instructions.Add (new LdInt32Instruction (offset' (int)instruction.Value));  				break;  			case PE.OpCode.Ldc_i8:  				instructions.Add (new LdInt64Instruction (offset' (long)instruction.Value));  				break;  			case PE.OpCode.Ldc_r4:  				instructions.Add (new LdSingleInstruction (offset' (float)instruction.Value));  				break;  			case PE.OpCode.Ldc_r8:  				instructions.Add (new LdDoubleInstruction (offset' (double)instruction.Value));  				break;  			case PE.OpCode.Ldstr:  				instructions.Add (new LdStringInstruction (offset' (string)instruction.Value));  				break;  			case PE.OpCode.Add:  				instructions.Add (new ArithInstruction (offset' ArithOp.Add' false' false));  				break;  			case PE.OpCode.Add_ovf:  				instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' false));  				break;  			case PE.OpCode.Add_ovf_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' true));  				break;  			case PE.OpCode.Sub:  				instructions.Add (new ArithInstruction (offset' ArithOp.Sub' false' false));  				break;  			case PE.OpCode.Sub_ovf:  				instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' false));  				break;  			case PE.OpCode.Sub_ovf_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' true));  				break;  			case PE.OpCode.Mul:  				instructions.Add (new ArithInstruction (offset' ArithOp.Mul' false' false));  				break;  			case PE.OpCode.Mul_ovf:  				instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' false));  				break;  			case PE.OpCode.Mul_ovf_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' true));  				break;  			case PE.OpCode.Div:  				instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' false));  				break;  			case PE.OpCode.Div_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' true));  				break;  			case PE.OpCode.Rem:  				instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' false));  				break;  			case PE.OpCode.Rem_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' true));  				break;  			case PE.OpCode.Neg:  				instructions.Add (new ArithInstruction (offset' ArithOp.Neg' false' false));  				break;  			case PE.OpCode.And:  				instructions.Add (new ArithInstruction (offset' ArithOp.BitAnd' false' false));  				break;  			case PE.OpCode.Or:  				instructions.Add (new ArithInstruction (offset' ArithOp.BitOr' false' false));  				break;  			case PE.OpCode.Xor:  				instructions.Add (new ArithInstruction (offset' ArithOp.BitXor' false' false));  				break;  			case PE.OpCode.Not:  				instructions.Add (new ArithInstruction (offset' ArithOp.BitNot' false' false));  				break;  			case PE.OpCode.Shl:  				instructions.Add (new ArithInstruction (offset' ArithOp.Shl' false' false));  				break;  			case PE.OpCode.Shr:  				instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' false));  				break;  			case PE.OpCode.Shr_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' true));  				break;  			case PE.OpCode.Conv_i1:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' false' false));  				break;  			case PE.OpCode.Conv_u1:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' false' false));  				break;  			case PE.OpCode.Conv_i2:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' false' false));  				break;  			case PE.OpCode.Conv_u2:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' false' false));  				break;  			case PE.OpCode.Conv_i4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' false' false));  				break;  			case PE.OpCode.Conv_u4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' false' false));  				break;  			case PE.OpCode.Conv_i8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' false' false));  				break;  			case PE.OpCode.Conv_u8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' false' false));  				break;  			case PE.OpCode.Conv_i:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' false' false));  				break;  			case PE.OpCode.Conv_u:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' false' false));  				break;  			case PE.OpCode.Conv_r4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Single' false' false));  				break;  			case PE.OpCode.Conv_r8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' false));  				break;  			case PE.OpCode.Conv_r_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' true));  				break;  			case PE.OpCode.Conv_ovf_i1:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' false));  				break;  			case PE.OpCode.Conv_ovf_u1:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' false));  				break;  			case PE.OpCode.Conv_ovf_i2:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' false));  				break;  			case PE.OpCode.Conv_ovf_u2:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' false));  				break;  			case PE.OpCode.Conv_ovf_i4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' false));  				break;  			case PE.OpCode.Conv_ovf_u4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' false));  				break;  			case PE.OpCode.Conv_ovf_i8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' false));  				break;  			case PE.OpCode.Conv_ovf_u8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' false));  				break;  			case PE.OpCode.Conv_ovf_i:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' false));  				break;  			case PE.OpCode.Conv_ovf_u:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' false));  				break;  			case PE.OpCode.Conv_ovf_i1_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' true));  				break;  			case PE.OpCode.Conv_ovf_u1_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' true));  				break;  			case PE.OpCode.Conv_ovf_i2_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' true));  				break;  			case PE.OpCode.Conv_ovf_u2_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' true));  				break;  			case PE.OpCode.Conv_ovf_i4_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' true));  				break;  			case PE.OpCode.Conv_ovf_u4_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' true));  				break;  			case PE.OpCode.Conv_ovf_i8_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' true));  				break;  			case PE.OpCode.Conv_ovf_u8_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' true));  				break;  			case PE.OpCode.Conv_ovf_i_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' true));  				break;  			case PE.OpCode.Conv_ovf_u_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' true));  				break;  			default:  				throw new InvalidOperationException ("invalid instruction");  			}  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: while (!ctxt.AtEnd (i)) {  	var j = i > ctxt.Start ? ctxt.JumpOverHandlers (i) : i;  	if (j > i)  		i = j;  	else {  		var ehcs = ctxt.OutermostTryBlocks (i);  		if (ehcs != null) {  			// A try instruction begins here with given handlers  			var offset = ctxt.Instructions [i].Offset;  			var tryCtxt = new TryTranslationContext (ctxt' i' ehcs);  			var tryBlock = InstructionsFromContext (tryCtxt);  			var handlers = new Seq<TryInstructionHandler> ();  			foreach (var ehc in ehcs) {  				var handlerCtxt = new HandlerTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.HandlerOffset]' ehc);  				var handlerBlock = InstructionsFromContext (handlerCtxt);  				switch (ehc.Flags) {  				case PE.CorILExceptionClause.Exception:  					handlers.Add (new CatchTryInstructionHandler ((TypeRef)ehc.Class' handlerBlock));  					break;  				case PE.CorILExceptionClause.Filter: {  					var filterCtxt = new FilterTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.FilterOffset]' ehc);  					var filterBlock = InstructionsFromContext (filterCtxt);  					handlers.Add (new FilterTryInstructionHandler (filterBlock' handlerBlock));  					break;  				}  				case PE.CorILExceptionClause.Finally:  					handlers.Add (new FinallyTryInstructionHandler (handlerBlock));  					break;  				case PE.CorILExceptionClause.Fault:  					handlers.Add (new FaultTryInstructionHandler (handlerBlock));  					break;  				default:  					throw new ArgumentOutOfRangeException ();  				}  			}  			instructions.Add (new TryInstruction (offset' tryBlock' handlers));  			// Jump over try block  			var nextOffset = ehcs [0].TryOffset + ehcs [0].TryLength;  			if (!ctxt.OffsetToIndex.TryGetValue (nextOffset' out i))  				i = ctxt.Instructions.Length;  		}  		else {  			var instruction = ctxt.Instructions [i++];  			var offset = instruction.Offset;  			while (instruction.OpCode == PE.OpCode.Unaligned || instruction.OpCode == PE.OpCode.Volatile || instruction.OpCode == PE.OpCode.Tailcall) {  				// Skip over any ignored prefixes' but remember instruction begins at original offset  				// NOTE: What ever happened to the "no." prefix mentioned in the spec?  				if (i >= ctxt.Instructions.Length)  					throw new InvalidOperationException ("invalid instructions");  				instruction = ctxt.Instructions [i++];  			}  			switch (instruction.OpCode) {  			case PE.OpCode.Cpblk:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Cpblk));  				break;  			case PE.OpCode.Initblk:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Initblk));  				break;  			case PE.OpCode.Arglist:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Arglist));  				break;  			case PE.OpCode.Localloc:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Localloc));  				break;  			case PE.OpCode.Jmp:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Jmp));  				break;  			case PE.OpCode.Calli:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Calli));  				break;  			case PE.OpCode.Sizeof:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Sizeof));  				break;  			case PE.OpCode.Mkrefany:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Mkrefany));  				break;  			case PE.OpCode.Refanytype:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanytype));  				break;  			case PE.OpCode.Refanyval:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanyval));  				break;  			case PE.OpCode.Nop:  				instructions.Add (new MiscInstruction (offset' MiscOp.Nop));  				break;  			case PE.OpCode.Break:  				instructions.Add (new MiscInstruction (offset' MiscOp.Break));  				break;  			case PE.OpCode.Dup:  				instructions.Add (new MiscInstruction (offset' MiscOp.Dup));  				break;  			case PE.OpCode.Pop:  				instructions.Add (new MiscInstruction (offset' MiscOp.Pop));  				break;  			case PE.OpCode.Ldnull:  				instructions.Add (new MiscInstruction (offset' MiscOp.Ldnull));  				break;  			case PE.OpCode.Ckfinite:  				instructions.Add (new MiscInstruction (offset' MiscOp.Ckfinite));  				break;  			case PE.OpCode.Throw:  				instructions.Add (new MiscInstruction (offset' MiscOp.Throw));  				break;  			case PE.OpCode.Rethrow:  				instructions.Add (new MiscInstruction (offset' MiscOp.Rethrow));  				break;  			case PE.OpCode.Ldind_ref:  				instructions.Add (new MiscInstruction (offset' MiscOp.LdindRef));  				break;  			case PE.OpCode.Stind_ref:  				instructions.Add (new MiscInstruction (offset' MiscOp.StindRef));  				break;  			case PE.OpCode.Ldelem_ref:  				instructions.Add (new MiscInstruction (offset' MiscOp.LdelemRef));  				break;  			case PE.OpCode.Stelem_ref:  				instructions.Add (new MiscInstruction (offset' MiscOp.StelemRef));  				break;  			case PE.OpCode.Ldlen:  				instructions.Add (new MiscInstruction (offset' MiscOp.Ldlen));  				break;  			case PE.OpCode.Ret:  				if (ctxt.ResultType == null)  					instructions.Add (new MiscInstruction (offset' MiscOp.Ret));  				else  					instructions.Add (new MiscInstruction (offset' MiscOp.RetVal));  				break;  			case PE.OpCode.Endfilter:  				instructions.Add (new MiscInstruction (offset' MiscOp.Endfilter));  				break;  			case PE.OpCode.Endfinally:  				// aka EndFault  				instructions.Add (new MiscInstruction (offset' MiscOp.Endfinally));  				break;  			case PE.OpCode.Br_s:  			case PE.OpCode.Br:  				instructions.Add (new BranchInstruction (offset' BranchOp.Br' false' (int)instruction.Value));  				break;  			case PE.OpCode.Brtrue_s:  			// aka brinst.s  			case PE.OpCode.Brtrue:  				// aka brinst  				instructions.Add (new BranchInstruction (offset' BranchOp.Brtrue' false' (int)instruction.Value));  				break;  			case PE.OpCode.Brfalse_s:  			// aka brzero.s' brnull.s  			case PE.OpCode.Brfalse:  				// aka brzero' brnull  				instructions.Add (new BranchInstruction (offset' BranchOp.Brfalse' false' (int)instruction.Value));  				break;  			case PE.OpCode.Beq:  			case PE.OpCode.Beq_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.Breq' false' (int)instruction.Value));  				break;  			case PE.OpCode.Bne_un:  			case PE.OpCode.Bne_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.Brne' false' (int)instruction.Value));  				break;  			case PE.OpCode.Leave:  			case PE.OpCode.Leave_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.Leave' false' (int)instruction.Value));  				break;  			case PE.OpCode.Blt:  			case PE.OpCode.Blt_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' false' (int)instruction.Value));  				break;  			case PE.OpCode.Blt_un:  			case PE.OpCode.Blt_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' true' (int)instruction.Value));  				break;  			case PE.OpCode.Ble:  			case PE.OpCode.Ble_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' false' (int)instruction.Value));  				break;  			case PE.OpCode.Ble_un:  			case PE.OpCode.Ble_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' true' (int)instruction.Value));  				break;  			case PE.OpCode.Bgt:  			case PE.OpCode.Bgt_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' false' (int)instruction.Value));  				break;  			case PE.OpCode.Bgt_un:  			case PE.OpCode.Bgt_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' true' (int)instruction.Value));  				break;  			case PE.OpCode.Bge:  			case PE.OpCode.Bge_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' false' (int)instruction.Value));  				break;  			case PE.OpCode.Bge_un:  			case PE.OpCode.Bge_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' true' (int)instruction.Value));  				break;  			case PE.OpCode.Switch:  				instructions.Add (new SwitchInstruction (offset' (Seq<int>)instruction.Value));  				break;  			case PE.OpCode.Ceq:  				instructions.Add (new CompareInstruction (offset' CompareOp.Ceq' false));  				break;  			case PE.OpCode.Clt:  				instructions.Add (new CompareInstruction (offset' CompareOp.Clt' false));  				break;  			case PE.OpCode.Clt_un:  				instructions.Add (new CompareInstruction (offset' CompareOp.Clt' true));  				break;  			case PE.OpCode.Cgt:  				instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' false));  				break;  			case PE.OpCode.Cgt_un:  				instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' true));  				break;  			case PE.OpCode.Ldarg_0:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));  				break;  			case PE.OpCode.Ldarg_1:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));  				break;  			case PE.OpCode.Ldarg_2:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));  				break;  			case PE.OpCode.Ldarg_3:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));  				break;  			case PE.OpCode.Ldarg:  			case PE.OpCode.Ldarg_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));  				break;  			case PE.OpCode.Ldarga:  			case PE.OpCode.Ldarga_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));  				break;  			case PE.OpCode.Starg:  			case PE.OpCode.Starg_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));  				break;  			case PE.OpCode.Ldloc_0:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 0));  				break;  			case PE.OpCode.Ldloc_1:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 1));  				break;  			case PE.OpCode.Ldloc_2:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 2));  				break;  			case PE.OpCode.Ldloc_3:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 3));  				break;  			case PE.OpCode.Ldloc:  			case PE.OpCode.Ldloc_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));  				break;  			case PE.OpCode.Ldloca:  			case PE.OpCode.Ldloca_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));  				break;  			case PE.OpCode.Stloc_0:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 0));  				break;  			case PE.OpCode.Stloc_1:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 1));  				break;  			case PE.OpCode.Stloc_2:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 2));  				break;  			case PE.OpCode.Stloc_3:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 3));  				break;  			case PE.OpCode.Stloc:  			case PE.OpCode.Stloc_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));  				break;  			case PE.OpCode.Ldfld:  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));  				break;  			case PE.OpCode.Ldsfld:  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));  				break;  			case PE.OpCode.Ldflda:  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));  				break;  			case PE.OpCode.Ldsflda:  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));  				break;  			case PE.OpCode.Stfld:  				instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));  				break;  			case PE.OpCode.Stsfld:  				instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));  				break;  			case PE.OpCode.Ldtoken: {  				if (instruction.Value is FieldRef)  					instructions.Add (new FieldInstruction (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));  				else if (instruction.Value is MethodRef)  					instructions.Add (new MethodInstruction (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));  				else if (instruction.Value is TypeRef)  					// NOTE: May be a higher-kinded type  					instructions.Add (new TypeInstruction (offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));  				else  					throw new InvalidOperationException ("unexpected ldtoken instruction value");  				break;  			}  			case PE.OpCode.Constrained: {  				var constrained = (TypeRef)instruction.Value;  				if (i >= ctxt.Instructions.Length)  					throw new InvalidOperationException ("invalid instructions");  				instruction = ctxt.Instructions [i++];  				if (instruction.OpCode != PE.OpCode.Callvirt)  					throw new InvalidOperationException ("invalid instruction");  				instructions.Add (new MethodInstruction (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));  				break;  			}  			case PE.OpCode.Call:  				instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Callvirt:  				instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Ldftn:  				instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Ldvirtftn:  				instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Newobj:  				instructions.Add (new MethodInstruction (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Ldind_i1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int8Ref));  				break;  			case PE.OpCode.Ldind_u1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt8Ref));  				break;  			case PE.OpCode.Ldind_i2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int16Ref));  				break;  			case PE.OpCode.Ldind_u2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt16Ref));  				break;  			case PE.OpCode.Ldind_i4:  			case PE.OpCode.Ldind_u4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int32Ref));  				break;  			case PE.OpCode.Ldind_i8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int64Ref));  				break;  			case PE.OpCode.Ldind_i:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.IntNativeRef));  				break;  			case PE.OpCode.Ldind_r4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.SingleRef));  				break;  			case PE.OpCode.Ldind_r8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.DoubleRef));  				break;  			case PE.OpCode.Ldobj:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Stind_i1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int8Ref));  				break;  			case PE.OpCode.Stind_i2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int16Ref));  				break;  			case PE.OpCode.Stind_i4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int32Ref));  				break;  			case PE.OpCode.Stind_i8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int64Ref));  				break;  			case PE.OpCode.Stind_i:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.IntNativeRef));  				break;  			case PE.OpCode.Stind_r4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.SingleRef));  				break;  			case PE.OpCode.Stind_r8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.DoubleRef));  				break;  			case PE.OpCode.Stobj:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Cpobj:  				instructions.Add (new TypeInstruction (offset' TypeOp.Cpobj' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Newarr:  				instructions.Add (new TypeInstruction (offset' TypeOp.Newarr' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Initobj:  				instructions.Add (new TypeInstruction (offset' TypeOp.Initobj' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Castclass:  				instructions.Add (new TypeInstruction (offset' TypeOp.Castclass' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Isinst:  				instructions.Add (new TypeInstruction (offset' TypeOp.Isinst' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Box:  				instructions.Add (new TypeInstruction (offset' TypeOp.Box' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Unbox:  				instructions.Add (new TypeInstruction (offset' TypeOp.Unbox' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Unbox_any:  				instructions.Add (new TypeInstruction (offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Ldelem_i1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int8Ref));  				break;  			case PE.OpCode.Ldelem_u1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt8Ref));  				break;  			case PE.OpCode.Ldelem_i2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int16Ref));  				break;  			case PE.OpCode.Ldelem_u2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt16Ref));  				break;  			case PE.OpCode.Ldelem_i4:  			case PE.OpCode.Ldelem_u4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int32Ref));  				break;  			case PE.OpCode.Ldelem_i:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.IntNativeRef));  				break;  			case PE.OpCode.Ldelem_i8:  				// aka ldelem.u8  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int64Ref));  				break;  			case PE.OpCode.Ldelem_r4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.SingleRef));  				break;  			case PE.OpCode.Ldelem_r8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.DoubleRef));  				break;  			case PE.OpCode.Ldelem:  				// aka ldelem.any  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Stelem_i1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int8Ref));  				break;  			case PE.OpCode.Stelem_i2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int16Ref));  				break;  			case PE.OpCode.Stelem_i4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int32Ref));  				break;  			case PE.OpCode.Stelem_i8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int64Ref));  				break;  			case PE.OpCode.Stelem_i:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.IntNativeRef));  				break;  			case PE.OpCode.Stelem_r4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.SingleRef));  				break;  			case PE.OpCode.Stelem_r8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.DoubleRef));  				break;  			case PE.OpCode.Stelem:  				// aka stelem.any  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Readonly:  				if (i >= ctxt.Instructions.Length)  					throw new InvalidOperationException ("invalid instruction");  				instruction = ctxt.Instructions [i++];  				if (instruction.OpCode != PE.OpCode.Ldelema)  					throw new InvalidOperationException ("invalid instruction");  				instructions.Add (new LdElemAddrInstruction (offset' true' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Ldelema:  				instructions.Add (new LdElemAddrInstruction (offset' false' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Ldc_i4_0:  				instructions.Add (new LdInt32Instruction (offset' 0));  				break;  			case PE.OpCode.Ldc_i4_1:  				instructions.Add (new LdInt32Instruction (offset' 1));  				break;  			case PE.OpCode.Ldc_i4_2:  				instructions.Add (new LdInt32Instruction (offset' 2));  				break;  			case PE.OpCode.Ldc_i4_3:  				instructions.Add (new LdInt32Instruction (offset' 3));  				break;  			case PE.OpCode.Ldc_i4_4:  				instructions.Add (new LdInt32Instruction (offset' 4));  				break;  			case PE.OpCode.Ldc_i4_5:  				instructions.Add (new LdInt32Instruction (offset' 5));  				break;  			case PE.OpCode.Ldc_i4_6:  				instructions.Add (new LdInt32Instruction (offset' 6));  				break;  			case PE.OpCode.Ldc_i4_7:  				instructions.Add (new LdInt32Instruction (offset' 7));  				break;  			case PE.OpCode.Ldc_i4_8:  				instructions.Add (new LdInt32Instruction (offset' 8));  				break;  			case PE.OpCode.Ldc_i4_m1:  				instructions.Add (new LdInt32Instruction (offset' -1));  				break;  			case PE.OpCode.Ldc_i4:  			case PE.OpCode.Ldc_i4_s:  				instructions.Add (new LdInt32Instruction (offset' (int)instruction.Value));  				break;  			case PE.OpCode.Ldc_i8:  				instructions.Add (new LdInt64Instruction (offset' (long)instruction.Value));  				break;  			case PE.OpCode.Ldc_r4:  				instructions.Add (new LdSingleInstruction (offset' (float)instruction.Value));  				break;  			case PE.OpCode.Ldc_r8:  				instructions.Add (new LdDoubleInstruction (offset' (double)instruction.Value));  				break;  			case PE.OpCode.Ldstr:  				instructions.Add (new LdStringInstruction (offset' (string)instruction.Value));  				break;  			case PE.OpCode.Add:  				instructions.Add (new ArithInstruction (offset' ArithOp.Add' false' false));  				break;  			case PE.OpCode.Add_ovf:  				instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' false));  				break;  			case PE.OpCode.Add_ovf_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' true));  				break;  			case PE.OpCode.Sub:  				instructions.Add (new ArithInstruction (offset' ArithOp.Sub' false' false));  				break;  			case PE.OpCode.Sub_ovf:  				instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' false));  				break;  			case PE.OpCode.Sub_ovf_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' true));  				break;  			case PE.OpCode.Mul:  				instructions.Add (new ArithInstruction (offset' ArithOp.Mul' false' false));  				break;  			case PE.OpCode.Mul_ovf:  				instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' false));  				break;  			case PE.OpCode.Mul_ovf_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' true));  				break;  			case PE.OpCode.Div:  				instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' false));  				break;  			case PE.OpCode.Div_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' true));  				break;  			case PE.OpCode.Rem:  				instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' false));  				break;  			case PE.OpCode.Rem_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' true));  				break;  			case PE.OpCode.Neg:  				instructions.Add (new ArithInstruction (offset' ArithOp.Neg' false' false));  				break;  			case PE.OpCode.And:  				instructions.Add (new ArithInstruction (offset' ArithOp.BitAnd' false' false));  				break;  			case PE.OpCode.Or:  				instructions.Add (new ArithInstruction (offset' ArithOp.BitOr' false' false));  				break;  			case PE.OpCode.Xor:  				instructions.Add (new ArithInstruction (offset' ArithOp.BitXor' false' false));  				break;  			case PE.OpCode.Not:  				instructions.Add (new ArithInstruction (offset' ArithOp.BitNot' false' false));  				break;  			case PE.OpCode.Shl:  				instructions.Add (new ArithInstruction (offset' ArithOp.Shl' false' false));  				break;  			case PE.OpCode.Shr:  				instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' false));  				break;  			case PE.OpCode.Shr_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' true));  				break;  			case PE.OpCode.Conv_i1:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' false' false));  				break;  			case PE.OpCode.Conv_u1:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' false' false));  				break;  			case PE.OpCode.Conv_i2:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' false' false));  				break;  			case PE.OpCode.Conv_u2:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' false' false));  				break;  			case PE.OpCode.Conv_i4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' false' false));  				break;  			case PE.OpCode.Conv_u4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' false' false));  				break;  			case PE.OpCode.Conv_i8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' false' false));  				break;  			case PE.OpCode.Conv_u8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' false' false));  				break;  			case PE.OpCode.Conv_i:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' false' false));  				break;  			case PE.OpCode.Conv_u:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' false' false));  				break;  			case PE.OpCode.Conv_r4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Single' false' false));  				break;  			case PE.OpCode.Conv_r8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' false));  				break;  			case PE.OpCode.Conv_r_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' true));  				break;  			case PE.OpCode.Conv_ovf_i1:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' false));  				break;  			case PE.OpCode.Conv_ovf_u1:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' false));  				break;  			case PE.OpCode.Conv_ovf_i2:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' false));  				break;  			case PE.OpCode.Conv_ovf_u2:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' false));  				break;  			case PE.OpCode.Conv_ovf_i4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' false));  				break;  			case PE.OpCode.Conv_ovf_u4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' false));  				break;  			case PE.OpCode.Conv_ovf_i8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' false));  				break;  			case PE.OpCode.Conv_ovf_u8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' false));  				break;  			case PE.OpCode.Conv_ovf_i:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' false));  				break;  			case PE.OpCode.Conv_ovf_u:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' false));  				break;  			case PE.OpCode.Conv_ovf_i1_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' true));  				break;  			case PE.OpCode.Conv_ovf_u1_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' true));  				break;  			case PE.OpCode.Conv_ovf_i2_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' true));  				break;  			case PE.OpCode.Conv_ovf_u2_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' true));  				break;  			case PE.OpCode.Conv_ovf_i4_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' true));  				break;  			case PE.OpCode.Conv_ovf_u4_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' true));  				break;  			case PE.OpCode.Conv_ovf_i8_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' true));  				break;  			case PE.OpCode.Conv_ovf_u8_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' true));  				break;  			case PE.OpCode.Conv_ovf_i_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' true));  				break;  			case PE.OpCode.Conv_ovf_u_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' true));  				break;  			default:  				throw new InvalidOperationException ("invalid instruction");  			}  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: while (!ctxt.AtEnd (i)) {  	var j = i > ctxt.Start ? ctxt.JumpOverHandlers (i) : i;  	if (j > i)  		i = j;  	else {  		var ehcs = ctxt.OutermostTryBlocks (i);  		if (ehcs != null) {  			// A try instruction begins here with given handlers  			var offset = ctxt.Instructions [i].Offset;  			var tryCtxt = new TryTranslationContext (ctxt' i' ehcs);  			var tryBlock = InstructionsFromContext (tryCtxt);  			var handlers = new Seq<TryInstructionHandler> ();  			foreach (var ehc in ehcs) {  				var handlerCtxt = new HandlerTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.HandlerOffset]' ehc);  				var handlerBlock = InstructionsFromContext (handlerCtxt);  				switch (ehc.Flags) {  				case PE.CorILExceptionClause.Exception:  					handlers.Add (new CatchTryInstructionHandler ((TypeRef)ehc.Class' handlerBlock));  					break;  				case PE.CorILExceptionClause.Filter: {  					var filterCtxt = new FilterTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.FilterOffset]' ehc);  					var filterBlock = InstructionsFromContext (filterCtxt);  					handlers.Add (new FilterTryInstructionHandler (filterBlock' handlerBlock));  					break;  				}  				case PE.CorILExceptionClause.Finally:  					handlers.Add (new FinallyTryInstructionHandler (handlerBlock));  					break;  				case PE.CorILExceptionClause.Fault:  					handlers.Add (new FaultTryInstructionHandler (handlerBlock));  					break;  				default:  					throw new ArgumentOutOfRangeException ();  				}  			}  			instructions.Add (new TryInstruction (offset' tryBlock' handlers));  			// Jump over try block  			var nextOffset = ehcs [0].TryOffset + ehcs [0].TryLength;  			if (!ctxt.OffsetToIndex.TryGetValue (nextOffset' out i))  				i = ctxt.Instructions.Length;  		}  		else {  			var instruction = ctxt.Instructions [i++];  			var offset = instruction.Offset;  			while (instruction.OpCode == PE.OpCode.Unaligned || instruction.OpCode == PE.OpCode.Volatile || instruction.OpCode == PE.OpCode.Tailcall) {  				// Skip over any ignored prefixes' but remember instruction begins at original offset  				// NOTE: What ever happened to the "no." prefix mentioned in the spec?  				if (i >= ctxt.Instructions.Length)  					throw new InvalidOperationException ("invalid instructions");  				instruction = ctxt.Instructions [i++];  			}  			switch (instruction.OpCode) {  			case PE.OpCode.Cpblk:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Cpblk));  				break;  			case PE.OpCode.Initblk:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Initblk));  				break;  			case PE.OpCode.Arglist:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Arglist));  				break;  			case PE.OpCode.Localloc:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Localloc));  				break;  			case PE.OpCode.Jmp:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Jmp));  				break;  			case PE.OpCode.Calli:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Calli));  				break;  			case PE.OpCode.Sizeof:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Sizeof));  				break;  			case PE.OpCode.Mkrefany:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Mkrefany));  				break;  			case PE.OpCode.Refanytype:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanytype));  				break;  			case PE.OpCode.Refanyval:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanyval));  				break;  			case PE.OpCode.Nop:  				instructions.Add (new MiscInstruction (offset' MiscOp.Nop));  				break;  			case PE.OpCode.Break:  				instructions.Add (new MiscInstruction (offset' MiscOp.Break));  				break;  			case PE.OpCode.Dup:  				instructions.Add (new MiscInstruction (offset' MiscOp.Dup));  				break;  			case PE.OpCode.Pop:  				instructions.Add (new MiscInstruction (offset' MiscOp.Pop));  				break;  			case PE.OpCode.Ldnull:  				instructions.Add (new MiscInstruction (offset' MiscOp.Ldnull));  				break;  			case PE.OpCode.Ckfinite:  				instructions.Add (new MiscInstruction (offset' MiscOp.Ckfinite));  				break;  			case PE.OpCode.Throw:  				instructions.Add (new MiscInstruction (offset' MiscOp.Throw));  				break;  			case PE.OpCode.Rethrow:  				instructions.Add (new MiscInstruction (offset' MiscOp.Rethrow));  				break;  			case PE.OpCode.Ldind_ref:  				instructions.Add (new MiscInstruction (offset' MiscOp.LdindRef));  				break;  			case PE.OpCode.Stind_ref:  				instructions.Add (new MiscInstruction (offset' MiscOp.StindRef));  				break;  			case PE.OpCode.Ldelem_ref:  				instructions.Add (new MiscInstruction (offset' MiscOp.LdelemRef));  				break;  			case PE.OpCode.Stelem_ref:  				instructions.Add (new MiscInstruction (offset' MiscOp.StelemRef));  				break;  			case PE.OpCode.Ldlen:  				instructions.Add (new MiscInstruction (offset' MiscOp.Ldlen));  				break;  			case PE.OpCode.Ret:  				if (ctxt.ResultType == null)  					instructions.Add (new MiscInstruction (offset' MiscOp.Ret));  				else  					instructions.Add (new MiscInstruction (offset' MiscOp.RetVal));  				break;  			case PE.OpCode.Endfilter:  				instructions.Add (new MiscInstruction (offset' MiscOp.Endfilter));  				break;  			case PE.OpCode.Endfinally:  				// aka EndFault  				instructions.Add (new MiscInstruction (offset' MiscOp.Endfinally));  				break;  			case PE.OpCode.Br_s:  			case PE.OpCode.Br:  				instructions.Add (new BranchInstruction (offset' BranchOp.Br' false' (int)instruction.Value));  				break;  			case PE.OpCode.Brtrue_s:  			// aka brinst.s  			case PE.OpCode.Brtrue:  				// aka brinst  				instructions.Add (new BranchInstruction (offset' BranchOp.Brtrue' false' (int)instruction.Value));  				break;  			case PE.OpCode.Brfalse_s:  			// aka brzero.s' brnull.s  			case PE.OpCode.Brfalse:  				// aka brzero' brnull  				instructions.Add (new BranchInstruction (offset' BranchOp.Brfalse' false' (int)instruction.Value));  				break;  			case PE.OpCode.Beq:  			case PE.OpCode.Beq_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.Breq' false' (int)instruction.Value));  				break;  			case PE.OpCode.Bne_un:  			case PE.OpCode.Bne_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.Brne' false' (int)instruction.Value));  				break;  			case PE.OpCode.Leave:  			case PE.OpCode.Leave_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.Leave' false' (int)instruction.Value));  				break;  			case PE.OpCode.Blt:  			case PE.OpCode.Blt_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' false' (int)instruction.Value));  				break;  			case PE.OpCode.Blt_un:  			case PE.OpCode.Blt_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' true' (int)instruction.Value));  				break;  			case PE.OpCode.Ble:  			case PE.OpCode.Ble_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' false' (int)instruction.Value));  				break;  			case PE.OpCode.Ble_un:  			case PE.OpCode.Ble_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' true' (int)instruction.Value));  				break;  			case PE.OpCode.Bgt:  			case PE.OpCode.Bgt_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' false' (int)instruction.Value));  				break;  			case PE.OpCode.Bgt_un:  			case PE.OpCode.Bgt_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' true' (int)instruction.Value));  				break;  			case PE.OpCode.Bge:  			case PE.OpCode.Bge_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' false' (int)instruction.Value));  				break;  			case PE.OpCode.Bge_un:  			case PE.OpCode.Bge_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' true' (int)instruction.Value));  				break;  			case PE.OpCode.Switch:  				instructions.Add (new SwitchInstruction (offset' (Seq<int>)instruction.Value));  				break;  			case PE.OpCode.Ceq:  				instructions.Add (new CompareInstruction (offset' CompareOp.Ceq' false));  				break;  			case PE.OpCode.Clt:  				instructions.Add (new CompareInstruction (offset' CompareOp.Clt' false));  				break;  			case PE.OpCode.Clt_un:  				instructions.Add (new CompareInstruction (offset' CompareOp.Clt' true));  				break;  			case PE.OpCode.Cgt:  				instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' false));  				break;  			case PE.OpCode.Cgt_un:  				instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' true));  				break;  			case PE.OpCode.Ldarg_0:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));  				break;  			case PE.OpCode.Ldarg_1:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));  				break;  			case PE.OpCode.Ldarg_2:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));  				break;  			case PE.OpCode.Ldarg_3:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));  				break;  			case PE.OpCode.Ldarg:  			case PE.OpCode.Ldarg_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));  				break;  			case PE.OpCode.Ldarga:  			case PE.OpCode.Ldarga_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));  				break;  			case PE.OpCode.Starg:  			case PE.OpCode.Starg_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));  				break;  			case PE.OpCode.Ldloc_0:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 0));  				break;  			case PE.OpCode.Ldloc_1:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 1));  				break;  			case PE.OpCode.Ldloc_2:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 2));  				break;  			case PE.OpCode.Ldloc_3:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 3));  				break;  			case PE.OpCode.Ldloc:  			case PE.OpCode.Ldloc_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));  				break;  			case PE.OpCode.Ldloca:  			case PE.OpCode.Ldloca_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));  				break;  			case PE.OpCode.Stloc_0:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 0));  				break;  			case PE.OpCode.Stloc_1:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 1));  				break;  			case PE.OpCode.Stloc_2:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 2));  				break;  			case PE.OpCode.Stloc_3:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 3));  				break;  			case PE.OpCode.Stloc:  			case PE.OpCode.Stloc_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));  				break;  			case PE.OpCode.Ldfld:  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));  				break;  			case PE.OpCode.Ldsfld:  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));  				break;  			case PE.OpCode.Ldflda:  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));  				break;  			case PE.OpCode.Ldsflda:  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));  				break;  			case PE.OpCode.Stfld:  				instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));  				break;  			case PE.OpCode.Stsfld:  				instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));  				break;  			case PE.OpCode.Ldtoken: {  				if (instruction.Value is FieldRef)  					instructions.Add (new FieldInstruction (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));  				else if (instruction.Value is MethodRef)  					instructions.Add (new MethodInstruction (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));  				else if (instruction.Value is TypeRef)  					// NOTE: May be a higher-kinded type  					instructions.Add (new TypeInstruction (offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));  				else  					throw new InvalidOperationException ("unexpected ldtoken instruction value");  				break;  			}  			case PE.OpCode.Constrained: {  				var constrained = (TypeRef)instruction.Value;  				if (i >= ctxt.Instructions.Length)  					throw new InvalidOperationException ("invalid instructions");  				instruction = ctxt.Instructions [i++];  				if (instruction.OpCode != PE.OpCode.Callvirt)  					throw new InvalidOperationException ("invalid instruction");  				instructions.Add (new MethodInstruction (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));  				break;  			}  			case PE.OpCode.Call:  				instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Callvirt:  				instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Ldftn:  				instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Ldvirtftn:  				instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Newobj:  				instructions.Add (new MethodInstruction (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Ldind_i1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int8Ref));  				break;  			case PE.OpCode.Ldind_u1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt8Ref));  				break;  			case PE.OpCode.Ldind_i2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int16Ref));  				break;  			case PE.OpCode.Ldind_u2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt16Ref));  				break;  			case PE.OpCode.Ldind_i4:  			case PE.OpCode.Ldind_u4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int32Ref));  				break;  			case PE.OpCode.Ldind_i8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int64Ref));  				break;  			case PE.OpCode.Ldind_i:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.IntNativeRef));  				break;  			case PE.OpCode.Ldind_r4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.SingleRef));  				break;  			case PE.OpCode.Ldind_r8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.DoubleRef));  				break;  			case PE.OpCode.Ldobj:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Stind_i1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int8Ref));  				break;  			case PE.OpCode.Stind_i2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int16Ref));  				break;  			case PE.OpCode.Stind_i4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int32Ref));  				break;  			case PE.OpCode.Stind_i8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int64Ref));  				break;  			case PE.OpCode.Stind_i:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.IntNativeRef));  				break;  			case PE.OpCode.Stind_r4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.SingleRef));  				break;  			case PE.OpCode.Stind_r8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.DoubleRef));  				break;  			case PE.OpCode.Stobj:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Cpobj:  				instructions.Add (new TypeInstruction (offset' TypeOp.Cpobj' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Newarr:  				instructions.Add (new TypeInstruction (offset' TypeOp.Newarr' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Initobj:  				instructions.Add (new TypeInstruction (offset' TypeOp.Initobj' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Castclass:  				instructions.Add (new TypeInstruction (offset' TypeOp.Castclass' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Isinst:  				instructions.Add (new TypeInstruction (offset' TypeOp.Isinst' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Box:  				instructions.Add (new TypeInstruction (offset' TypeOp.Box' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Unbox:  				instructions.Add (new TypeInstruction (offset' TypeOp.Unbox' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Unbox_any:  				instructions.Add (new TypeInstruction (offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Ldelem_i1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int8Ref));  				break;  			case PE.OpCode.Ldelem_u1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt8Ref));  				break;  			case PE.OpCode.Ldelem_i2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int16Ref));  				break;  			case PE.OpCode.Ldelem_u2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt16Ref));  				break;  			case PE.OpCode.Ldelem_i4:  			case PE.OpCode.Ldelem_u4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int32Ref));  				break;  			case PE.OpCode.Ldelem_i:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.IntNativeRef));  				break;  			case PE.OpCode.Ldelem_i8:  				// aka ldelem.u8  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int64Ref));  				break;  			case PE.OpCode.Ldelem_r4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.SingleRef));  				break;  			case PE.OpCode.Ldelem_r8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.DoubleRef));  				break;  			case PE.OpCode.Ldelem:  				// aka ldelem.any  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Stelem_i1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int8Ref));  				break;  			case PE.OpCode.Stelem_i2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int16Ref));  				break;  			case PE.OpCode.Stelem_i4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int32Ref));  				break;  			case PE.OpCode.Stelem_i8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int64Ref));  				break;  			case PE.OpCode.Stelem_i:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.IntNativeRef));  				break;  			case PE.OpCode.Stelem_r4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.SingleRef));  				break;  			case PE.OpCode.Stelem_r8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.DoubleRef));  				break;  			case PE.OpCode.Stelem:  				// aka stelem.any  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Readonly:  				if (i >= ctxt.Instructions.Length)  					throw new InvalidOperationException ("invalid instruction");  				instruction = ctxt.Instructions [i++];  				if (instruction.OpCode != PE.OpCode.Ldelema)  					throw new InvalidOperationException ("invalid instruction");  				instructions.Add (new LdElemAddrInstruction (offset' true' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Ldelema:  				instructions.Add (new LdElemAddrInstruction (offset' false' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Ldc_i4_0:  				instructions.Add (new LdInt32Instruction (offset' 0));  				break;  			case PE.OpCode.Ldc_i4_1:  				instructions.Add (new LdInt32Instruction (offset' 1));  				break;  			case PE.OpCode.Ldc_i4_2:  				instructions.Add (new LdInt32Instruction (offset' 2));  				break;  			case PE.OpCode.Ldc_i4_3:  				instructions.Add (new LdInt32Instruction (offset' 3));  				break;  			case PE.OpCode.Ldc_i4_4:  				instructions.Add (new LdInt32Instruction (offset' 4));  				break;  			case PE.OpCode.Ldc_i4_5:  				instructions.Add (new LdInt32Instruction (offset' 5));  				break;  			case PE.OpCode.Ldc_i4_6:  				instructions.Add (new LdInt32Instruction (offset' 6));  				break;  			case PE.OpCode.Ldc_i4_7:  				instructions.Add (new LdInt32Instruction (offset' 7));  				break;  			case PE.OpCode.Ldc_i4_8:  				instructions.Add (new LdInt32Instruction (offset' 8));  				break;  			case PE.OpCode.Ldc_i4_m1:  				instructions.Add (new LdInt32Instruction (offset' -1));  				break;  			case PE.OpCode.Ldc_i4:  			case PE.OpCode.Ldc_i4_s:  				instructions.Add (new LdInt32Instruction (offset' (int)instruction.Value));  				break;  			case PE.OpCode.Ldc_i8:  				instructions.Add (new LdInt64Instruction (offset' (long)instruction.Value));  				break;  			case PE.OpCode.Ldc_r4:  				instructions.Add (new LdSingleInstruction (offset' (float)instruction.Value));  				break;  			case PE.OpCode.Ldc_r8:  				instructions.Add (new LdDoubleInstruction (offset' (double)instruction.Value));  				break;  			case PE.OpCode.Ldstr:  				instructions.Add (new LdStringInstruction (offset' (string)instruction.Value));  				break;  			case PE.OpCode.Add:  				instructions.Add (new ArithInstruction (offset' ArithOp.Add' false' false));  				break;  			case PE.OpCode.Add_ovf:  				instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' false));  				break;  			case PE.OpCode.Add_ovf_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' true));  				break;  			case PE.OpCode.Sub:  				instructions.Add (new ArithInstruction (offset' ArithOp.Sub' false' false));  				break;  			case PE.OpCode.Sub_ovf:  				instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' false));  				break;  			case PE.OpCode.Sub_ovf_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' true));  				break;  			case PE.OpCode.Mul:  				instructions.Add (new ArithInstruction (offset' ArithOp.Mul' false' false));  				break;  			case PE.OpCode.Mul_ovf:  				instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' false));  				break;  			case PE.OpCode.Mul_ovf_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' true));  				break;  			case PE.OpCode.Div:  				instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' false));  				break;  			case PE.OpCode.Div_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' true));  				break;  			case PE.OpCode.Rem:  				instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' false));  				break;  			case PE.OpCode.Rem_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' true));  				break;  			case PE.OpCode.Neg:  				instructions.Add (new ArithInstruction (offset' ArithOp.Neg' false' false));  				break;  			case PE.OpCode.And:  				instructions.Add (new ArithInstruction (offset' ArithOp.BitAnd' false' false));  				break;  			case PE.OpCode.Or:  				instructions.Add (new ArithInstruction (offset' ArithOp.BitOr' false' false));  				break;  			case PE.OpCode.Xor:  				instructions.Add (new ArithInstruction (offset' ArithOp.BitXor' false' false));  				break;  			case PE.OpCode.Not:  				instructions.Add (new ArithInstruction (offset' ArithOp.BitNot' false' false));  				break;  			case PE.OpCode.Shl:  				instructions.Add (new ArithInstruction (offset' ArithOp.Shl' false' false));  				break;  			case PE.OpCode.Shr:  				instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' false));  				break;  			case PE.OpCode.Shr_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' true));  				break;  			case PE.OpCode.Conv_i1:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' false' false));  				break;  			case PE.OpCode.Conv_u1:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' false' false));  				break;  			case PE.OpCode.Conv_i2:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' false' false));  				break;  			case PE.OpCode.Conv_u2:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' false' false));  				break;  			case PE.OpCode.Conv_i4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' false' false));  				break;  			case PE.OpCode.Conv_u4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' false' false));  				break;  			case PE.OpCode.Conv_i8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' false' false));  				break;  			case PE.OpCode.Conv_u8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' false' false));  				break;  			case PE.OpCode.Conv_i:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' false' false));  				break;  			case PE.OpCode.Conv_u:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' false' false));  				break;  			case PE.OpCode.Conv_r4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Single' false' false));  				break;  			case PE.OpCode.Conv_r8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' false));  				break;  			case PE.OpCode.Conv_r_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' true));  				break;  			case PE.OpCode.Conv_ovf_i1:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' false));  				break;  			case PE.OpCode.Conv_ovf_u1:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' false));  				break;  			case PE.OpCode.Conv_ovf_i2:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' false));  				break;  			case PE.OpCode.Conv_ovf_u2:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' false));  				break;  			case PE.OpCode.Conv_ovf_i4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' false));  				break;  			case PE.OpCode.Conv_ovf_u4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' false));  				break;  			case PE.OpCode.Conv_ovf_i8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' false));  				break;  			case PE.OpCode.Conv_ovf_u8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' false));  				break;  			case PE.OpCode.Conv_ovf_i:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' false));  				break;  			case PE.OpCode.Conv_ovf_u:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' false));  				break;  			case PE.OpCode.Conv_ovf_i1_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' true));  				break;  			case PE.OpCode.Conv_ovf_u1_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' true));  				break;  			case PE.OpCode.Conv_ovf_i2_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' true));  				break;  			case PE.OpCode.Conv_ovf_u2_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' true));  				break;  			case PE.OpCode.Conv_ovf_i4_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' true));  				break;  			case PE.OpCode.Conv_ovf_u4_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' true));  				break;  			case PE.OpCode.Conv_ovf_i8_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' true));  				break;  			case PE.OpCode.Conv_ovf_u8_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' true));  				break;  			case PE.OpCode.Conv_ovf_i_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' true));  				break;  			case PE.OpCode.Conv_ovf_u_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' true));  				break;  			default:  				throw new InvalidOperationException ("invalid instruction");  			}  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: while (!ctxt.AtEnd (i)) {  	var j = i > ctxt.Start ? ctxt.JumpOverHandlers (i) : i;  	if (j > i)  		i = j;  	else {  		var ehcs = ctxt.OutermostTryBlocks (i);  		if (ehcs != null) {  			// A try instruction begins here with given handlers  			var offset = ctxt.Instructions [i].Offset;  			var tryCtxt = new TryTranslationContext (ctxt' i' ehcs);  			var tryBlock = InstructionsFromContext (tryCtxt);  			var handlers = new Seq<TryInstructionHandler> ();  			foreach (var ehc in ehcs) {  				var handlerCtxt = new HandlerTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.HandlerOffset]' ehc);  				var handlerBlock = InstructionsFromContext (handlerCtxt);  				switch (ehc.Flags) {  				case PE.CorILExceptionClause.Exception:  					handlers.Add (new CatchTryInstructionHandler ((TypeRef)ehc.Class' handlerBlock));  					break;  				case PE.CorILExceptionClause.Filter: {  					var filterCtxt = new FilterTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.FilterOffset]' ehc);  					var filterBlock = InstructionsFromContext (filterCtxt);  					handlers.Add (new FilterTryInstructionHandler (filterBlock' handlerBlock));  					break;  				}  				case PE.CorILExceptionClause.Finally:  					handlers.Add (new FinallyTryInstructionHandler (handlerBlock));  					break;  				case PE.CorILExceptionClause.Fault:  					handlers.Add (new FaultTryInstructionHandler (handlerBlock));  					break;  				default:  					throw new ArgumentOutOfRangeException ();  				}  			}  			instructions.Add (new TryInstruction (offset' tryBlock' handlers));  			// Jump over try block  			var nextOffset = ehcs [0].TryOffset + ehcs [0].TryLength;  			if (!ctxt.OffsetToIndex.TryGetValue (nextOffset' out i))  				i = ctxt.Instructions.Length;  		}  		else {  			var instruction = ctxt.Instructions [i++];  			var offset = instruction.Offset;  			while (instruction.OpCode == PE.OpCode.Unaligned || instruction.OpCode == PE.OpCode.Volatile || instruction.OpCode == PE.OpCode.Tailcall) {  				// Skip over any ignored prefixes' but remember instruction begins at original offset  				// NOTE: What ever happened to the "no." prefix mentioned in the spec?  				if (i >= ctxt.Instructions.Length)  					throw new InvalidOperationException ("invalid instructions");  				instruction = ctxt.Instructions [i++];  			}  			switch (instruction.OpCode) {  			case PE.OpCode.Cpblk:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Cpblk));  				break;  			case PE.OpCode.Initblk:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Initblk));  				break;  			case PE.OpCode.Arglist:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Arglist));  				break;  			case PE.OpCode.Localloc:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Localloc));  				break;  			case PE.OpCode.Jmp:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Jmp));  				break;  			case PE.OpCode.Calli:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Calli));  				break;  			case PE.OpCode.Sizeof:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Sizeof));  				break;  			case PE.OpCode.Mkrefany:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Mkrefany));  				break;  			case PE.OpCode.Refanytype:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanytype));  				break;  			case PE.OpCode.Refanyval:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanyval));  				break;  			case PE.OpCode.Nop:  				instructions.Add (new MiscInstruction (offset' MiscOp.Nop));  				break;  			case PE.OpCode.Break:  				instructions.Add (new MiscInstruction (offset' MiscOp.Break));  				break;  			case PE.OpCode.Dup:  				instructions.Add (new MiscInstruction (offset' MiscOp.Dup));  				break;  			case PE.OpCode.Pop:  				instructions.Add (new MiscInstruction (offset' MiscOp.Pop));  				break;  			case PE.OpCode.Ldnull:  				instructions.Add (new MiscInstruction (offset' MiscOp.Ldnull));  				break;  			case PE.OpCode.Ckfinite:  				instructions.Add (new MiscInstruction (offset' MiscOp.Ckfinite));  				break;  			case PE.OpCode.Throw:  				instructions.Add (new MiscInstruction (offset' MiscOp.Throw));  				break;  			case PE.OpCode.Rethrow:  				instructions.Add (new MiscInstruction (offset' MiscOp.Rethrow));  				break;  			case PE.OpCode.Ldind_ref:  				instructions.Add (new MiscInstruction (offset' MiscOp.LdindRef));  				break;  			case PE.OpCode.Stind_ref:  				instructions.Add (new MiscInstruction (offset' MiscOp.StindRef));  				break;  			case PE.OpCode.Ldelem_ref:  				instructions.Add (new MiscInstruction (offset' MiscOp.LdelemRef));  				break;  			case PE.OpCode.Stelem_ref:  				instructions.Add (new MiscInstruction (offset' MiscOp.StelemRef));  				break;  			case PE.OpCode.Ldlen:  				instructions.Add (new MiscInstruction (offset' MiscOp.Ldlen));  				break;  			case PE.OpCode.Ret:  				if (ctxt.ResultType == null)  					instructions.Add (new MiscInstruction (offset' MiscOp.Ret));  				else  					instructions.Add (new MiscInstruction (offset' MiscOp.RetVal));  				break;  			case PE.OpCode.Endfilter:  				instructions.Add (new MiscInstruction (offset' MiscOp.Endfilter));  				break;  			case PE.OpCode.Endfinally:  				// aka EndFault  				instructions.Add (new MiscInstruction (offset' MiscOp.Endfinally));  				break;  			case PE.OpCode.Br_s:  			case PE.OpCode.Br:  				instructions.Add (new BranchInstruction (offset' BranchOp.Br' false' (int)instruction.Value));  				break;  			case PE.OpCode.Brtrue_s:  			// aka brinst.s  			case PE.OpCode.Brtrue:  				// aka brinst  				instructions.Add (new BranchInstruction (offset' BranchOp.Brtrue' false' (int)instruction.Value));  				break;  			case PE.OpCode.Brfalse_s:  			// aka brzero.s' brnull.s  			case PE.OpCode.Brfalse:  				// aka brzero' brnull  				instructions.Add (new BranchInstruction (offset' BranchOp.Brfalse' false' (int)instruction.Value));  				break;  			case PE.OpCode.Beq:  			case PE.OpCode.Beq_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.Breq' false' (int)instruction.Value));  				break;  			case PE.OpCode.Bne_un:  			case PE.OpCode.Bne_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.Brne' false' (int)instruction.Value));  				break;  			case PE.OpCode.Leave:  			case PE.OpCode.Leave_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.Leave' false' (int)instruction.Value));  				break;  			case PE.OpCode.Blt:  			case PE.OpCode.Blt_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' false' (int)instruction.Value));  				break;  			case PE.OpCode.Blt_un:  			case PE.OpCode.Blt_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' true' (int)instruction.Value));  				break;  			case PE.OpCode.Ble:  			case PE.OpCode.Ble_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' false' (int)instruction.Value));  				break;  			case PE.OpCode.Ble_un:  			case PE.OpCode.Ble_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' true' (int)instruction.Value));  				break;  			case PE.OpCode.Bgt:  			case PE.OpCode.Bgt_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' false' (int)instruction.Value));  				break;  			case PE.OpCode.Bgt_un:  			case PE.OpCode.Bgt_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' true' (int)instruction.Value));  				break;  			case PE.OpCode.Bge:  			case PE.OpCode.Bge_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' false' (int)instruction.Value));  				break;  			case PE.OpCode.Bge_un:  			case PE.OpCode.Bge_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' true' (int)instruction.Value));  				break;  			case PE.OpCode.Switch:  				instructions.Add (new SwitchInstruction (offset' (Seq<int>)instruction.Value));  				break;  			case PE.OpCode.Ceq:  				instructions.Add (new CompareInstruction (offset' CompareOp.Ceq' false));  				break;  			case PE.OpCode.Clt:  				instructions.Add (new CompareInstruction (offset' CompareOp.Clt' false));  				break;  			case PE.OpCode.Clt_un:  				instructions.Add (new CompareInstruction (offset' CompareOp.Clt' true));  				break;  			case PE.OpCode.Cgt:  				instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' false));  				break;  			case PE.OpCode.Cgt_un:  				instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' true));  				break;  			case PE.OpCode.Ldarg_0:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));  				break;  			case PE.OpCode.Ldarg_1:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));  				break;  			case PE.OpCode.Ldarg_2:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));  				break;  			case PE.OpCode.Ldarg_3:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));  				break;  			case PE.OpCode.Ldarg:  			case PE.OpCode.Ldarg_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));  				break;  			case PE.OpCode.Ldarga:  			case PE.OpCode.Ldarga_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));  				break;  			case PE.OpCode.Starg:  			case PE.OpCode.Starg_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));  				break;  			case PE.OpCode.Ldloc_0:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 0));  				break;  			case PE.OpCode.Ldloc_1:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 1));  				break;  			case PE.OpCode.Ldloc_2:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 2));  				break;  			case PE.OpCode.Ldloc_3:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 3));  				break;  			case PE.OpCode.Ldloc:  			case PE.OpCode.Ldloc_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));  				break;  			case PE.OpCode.Ldloca:  			case PE.OpCode.Ldloca_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));  				break;  			case PE.OpCode.Stloc_0:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 0));  				break;  			case PE.OpCode.Stloc_1:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 1));  				break;  			case PE.OpCode.Stloc_2:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 2));  				break;  			case PE.OpCode.Stloc_3:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 3));  				break;  			case PE.OpCode.Stloc:  			case PE.OpCode.Stloc_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));  				break;  			case PE.OpCode.Ldfld:  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));  				break;  			case PE.OpCode.Ldsfld:  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));  				break;  			case PE.OpCode.Ldflda:  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));  				break;  			case PE.OpCode.Ldsflda:  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));  				break;  			case PE.OpCode.Stfld:  				instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));  				break;  			case PE.OpCode.Stsfld:  				instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));  				break;  			case PE.OpCode.Ldtoken: {  				if (instruction.Value is FieldRef)  					instructions.Add (new FieldInstruction (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));  				else if (instruction.Value is MethodRef)  					instructions.Add (new MethodInstruction (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));  				else if (instruction.Value is TypeRef)  					// NOTE: May be a higher-kinded type  					instructions.Add (new TypeInstruction (offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));  				else  					throw new InvalidOperationException ("unexpected ldtoken instruction value");  				break;  			}  			case PE.OpCode.Constrained: {  				var constrained = (TypeRef)instruction.Value;  				if (i >= ctxt.Instructions.Length)  					throw new InvalidOperationException ("invalid instructions");  				instruction = ctxt.Instructions [i++];  				if (instruction.OpCode != PE.OpCode.Callvirt)  					throw new InvalidOperationException ("invalid instruction");  				instructions.Add (new MethodInstruction (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));  				break;  			}  			case PE.OpCode.Call:  				instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Callvirt:  				instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Ldftn:  				instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Ldvirtftn:  				instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Newobj:  				instructions.Add (new MethodInstruction (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Ldind_i1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int8Ref));  				break;  			case PE.OpCode.Ldind_u1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt8Ref));  				break;  			case PE.OpCode.Ldind_i2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int16Ref));  				break;  			case PE.OpCode.Ldind_u2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt16Ref));  				break;  			case PE.OpCode.Ldind_i4:  			case PE.OpCode.Ldind_u4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int32Ref));  				break;  			case PE.OpCode.Ldind_i8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int64Ref));  				break;  			case PE.OpCode.Ldind_i:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.IntNativeRef));  				break;  			case PE.OpCode.Ldind_r4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.SingleRef));  				break;  			case PE.OpCode.Ldind_r8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.DoubleRef));  				break;  			case PE.OpCode.Ldobj:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Stind_i1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int8Ref));  				break;  			case PE.OpCode.Stind_i2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int16Ref));  				break;  			case PE.OpCode.Stind_i4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int32Ref));  				break;  			case PE.OpCode.Stind_i8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int64Ref));  				break;  			case PE.OpCode.Stind_i:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.IntNativeRef));  				break;  			case PE.OpCode.Stind_r4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.SingleRef));  				break;  			case PE.OpCode.Stind_r8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.DoubleRef));  				break;  			case PE.OpCode.Stobj:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Cpobj:  				instructions.Add (new TypeInstruction (offset' TypeOp.Cpobj' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Newarr:  				instructions.Add (new TypeInstruction (offset' TypeOp.Newarr' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Initobj:  				instructions.Add (new TypeInstruction (offset' TypeOp.Initobj' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Castclass:  				instructions.Add (new TypeInstruction (offset' TypeOp.Castclass' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Isinst:  				instructions.Add (new TypeInstruction (offset' TypeOp.Isinst' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Box:  				instructions.Add (new TypeInstruction (offset' TypeOp.Box' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Unbox:  				instructions.Add (new TypeInstruction (offset' TypeOp.Unbox' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Unbox_any:  				instructions.Add (new TypeInstruction (offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Ldelem_i1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int8Ref));  				break;  			case PE.OpCode.Ldelem_u1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt8Ref));  				break;  			case PE.OpCode.Ldelem_i2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int16Ref));  				break;  			case PE.OpCode.Ldelem_u2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt16Ref));  				break;  			case PE.OpCode.Ldelem_i4:  			case PE.OpCode.Ldelem_u4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int32Ref));  				break;  			case PE.OpCode.Ldelem_i:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.IntNativeRef));  				break;  			case PE.OpCode.Ldelem_i8:  				// aka ldelem.u8  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int64Ref));  				break;  			case PE.OpCode.Ldelem_r4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.SingleRef));  				break;  			case PE.OpCode.Ldelem_r8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.DoubleRef));  				break;  			case PE.OpCode.Ldelem:  				// aka ldelem.any  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Stelem_i1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int8Ref));  				break;  			case PE.OpCode.Stelem_i2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int16Ref));  				break;  			case PE.OpCode.Stelem_i4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int32Ref));  				break;  			case PE.OpCode.Stelem_i8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int64Ref));  				break;  			case PE.OpCode.Stelem_i:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.IntNativeRef));  				break;  			case PE.OpCode.Stelem_r4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.SingleRef));  				break;  			case PE.OpCode.Stelem_r8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.DoubleRef));  				break;  			case PE.OpCode.Stelem:  				// aka stelem.any  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Readonly:  				if (i >= ctxt.Instructions.Length)  					throw new InvalidOperationException ("invalid instruction");  				instruction = ctxt.Instructions [i++];  				if (instruction.OpCode != PE.OpCode.Ldelema)  					throw new InvalidOperationException ("invalid instruction");  				instructions.Add (new LdElemAddrInstruction (offset' true' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Ldelema:  				instructions.Add (new LdElemAddrInstruction (offset' false' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Ldc_i4_0:  				instructions.Add (new LdInt32Instruction (offset' 0));  				break;  			case PE.OpCode.Ldc_i4_1:  				instructions.Add (new LdInt32Instruction (offset' 1));  				break;  			case PE.OpCode.Ldc_i4_2:  				instructions.Add (new LdInt32Instruction (offset' 2));  				break;  			case PE.OpCode.Ldc_i4_3:  				instructions.Add (new LdInt32Instruction (offset' 3));  				break;  			case PE.OpCode.Ldc_i4_4:  				instructions.Add (new LdInt32Instruction (offset' 4));  				break;  			case PE.OpCode.Ldc_i4_5:  				instructions.Add (new LdInt32Instruction (offset' 5));  				break;  			case PE.OpCode.Ldc_i4_6:  				instructions.Add (new LdInt32Instruction (offset' 6));  				break;  			case PE.OpCode.Ldc_i4_7:  				instructions.Add (new LdInt32Instruction (offset' 7));  				break;  			case PE.OpCode.Ldc_i4_8:  				instructions.Add (new LdInt32Instruction (offset' 8));  				break;  			case PE.OpCode.Ldc_i4_m1:  				instructions.Add (new LdInt32Instruction (offset' -1));  				break;  			case PE.OpCode.Ldc_i4:  			case PE.OpCode.Ldc_i4_s:  				instructions.Add (new LdInt32Instruction (offset' (int)instruction.Value));  				break;  			case PE.OpCode.Ldc_i8:  				instructions.Add (new LdInt64Instruction (offset' (long)instruction.Value));  				break;  			case PE.OpCode.Ldc_r4:  				instructions.Add (new LdSingleInstruction (offset' (float)instruction.Value));  				break;  			case PE.OpCode.Ldc_r8:  				instructions.Add (new LdDoubleInstruction (offset' (double)instruction.Value));  				break;  			case PE.OpCode.Ldstr:  				instructions.Add (new LdStringInstruction (offset' (string)instruction.Value));  				break;  			case PE.OpCode.Add:  				instructions.Add (new ArithInstruction (offset' ArithOp.Add' false' false));  				break;  			case PE.OpCode.Add_ovf:  				instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' false));  				break;  			case PE.OpCode.Add_ovf_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' true));  				break;  			case PE.OpCode.Sub:  				instructions.Add (new ArithInstruction (offset' ArithOp.Sub' false' false));  				break;  			case PE.OpCode.Sub_ovf:  				instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' false));  				break;  			case PE.OpCode.Sub_ovf_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' true));  				break;  			case PE.OpCode.Mul:  				instructions.Add (new ArithInstruction (offset' ArithOp.Mul' false' false));  				break;  			case PE.OpCode.Mul_ovf:  				instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' false));  				break;  			case PE.OpCode.Mul_ovf_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' true));  				break;  			case PE.OpCode.Div:  				instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' false));  				break;  			case PE.OpCode.Div_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' true));  				break;  			case PE.OpCode.Rem:  				instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' false));  				break;  			case PE.OpCode.Rem_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' true));  				break;  			case PE.OpCode.Neg:  				instructions.Add (new ArithInstruction (offset' ArithOp.Neg' false' false));  				break;  			case PE.OpCode.And:  				instructions.Add (new ArithInstruction (offset' ArithOp.BitAnd' false' false));  				break;  			case PE.OpCode.Or:  				instructions.Add (new ArithInstruction (offset' ArithOp.BitOr' false' false));  				break;  			case PE.OpCode.Xor:  				instructions.Add (new ArithInstruction (offset' ArithOp.BitXor' false' false));  				break;  			case PE.OpCode.Not:  				instructions.Add (new ArithInstruction (offset' ArithOp.BitNot' false' false));  				break;  			case PE.OpCode.Shl:  				instructions.Add (new ArithInstruction (offset' ArithOp.Shl' false' false));  				break;  			case PE.OpCode.Shr:  				instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' false));  				break;  			case PE.OpCode.Shr_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' true));  				break;  			case PE.OpCode.Conv_i1:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' false' false));  				break;  			case PE.OpCode.Conv_u1:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' false' false));  				break;  			case PE.OpCode.Conv_i2:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' false' false));  				break;  			case PE.OpCode.Conv_u2:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' false' false));  				break;  			case PE.OpCode.Conv_i4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' false' false));  				break;  			case PE.OpCode.Conv_u4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' false' false));  				break;  			case PE.OpCode.Conv_i8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' false' false));  				break;  			case PE.OpCode.Conv_u8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' false' false));  				break;  			case PE.OpCode.Conv_i:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' false' false));  				break;  			case PE.OpCode.Conv_u:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' false' false));  				break;  			case PE.OpCode.Conv_r4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Single' false' false));  				break;  			case PE.OpCode.Conv_r8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' false));  				break;  			case PE.OpCode.Conv_r_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' true));  				break;  			case PE.OpCode.Conv_ovf_i1:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' false));  				break;  			case PE.OpCode.Conv_ovf_u1:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' false));  				break;  			case PE.OpCode.Conv_ovf_i2:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' false));  				break;  			case PE.OpCode.Conv_ovf_u2:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' false));  				break;  			case PE.OpCode.Conv_ovf_i4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' false));  				break;  			case PE.OpCode.Conv_ovf_u4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' false));  				break;  			case PE.OpCode.Conv_ovf_i8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' false));  				break;  			case PE.OpCode.Conv_ovf_u8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' false));  				break;  			case PE.OpCode.Conv_ovf_i:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' false));  				break;  			case PE.OpCode.Conv_ovf_u:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' false));  				break;  			case PE.OpCode.Conv_ovf_i1_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' true));  				break;  			case PE.OpCode.Conv_ovf_u1_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' true));  				break;  			case PE.OpCode.Conv_ovf_i2_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' true));  				break;  			case PE.OpCode.Conv_ovf_u2_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' true));  				break;  			case PE.OpCode.Conv_ovf_i4_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' true));  				break;  			case PE.OpCode.Conv_ovf_u4_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' true));  				break;  			case PE.OpCode.Conv_ovf_i8_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' true));  				break;  			case PE.OpCode.Conv_ovf_u8_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' true));  				break;  			case PE.OpCode.Conv_ovf_i_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' true));  				break;  			case PE.OpCode.Conv_ovf_u_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' true));  				break;  			default:  				throw new InvalidOperationException ("invalid instruction");  			}  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: while (!ctxt.AtEnd (i)) {  	var j = i > ctxt.Start ? ctxt.JumpOverHandlers (i) : i;  	if (j > i)  		i = j;  	else {  		var ehcs = ctxt.OutermostTryBlocks (i);  		if (ehcs != null) {  			// A try instruction begins here with given handlers  			var offset = ctxt.Instructions [i].Offset;  			var tryCtxt = new TryTranslationContext (ctxt' i' ehcs);  			var tryBlock = InstructionsFromContext (tryCtxt);  			var handlers = new Seq<TryInstructionHandler> ();  			foreach (var ehc in ehcs) {  				var handlerCtxt = new HandlerTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.HandlerOffset]' ehc);  				var handlerBlock = InstructionsFromContext (handlerCtxt);  				switch (ehc.Flags) {  				case PE.CorILExceptionClause.Exception:  					handlers.Add (new CatchTryInstructionHandler ((TypeRef)ehc.Class' handlerBlock));  					break;  				case PE.CorILExceptionClause.Filter: {  					var filterCtxt = new FilterTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.FilterOffset]' ehc);  					var filterBlock = InstructionsFromContext (filterCtxt);  					handlers.Add (new FilterTryInstructionHandler (filterBlock' handlerBlock));  					break;  				}  				case PE.CorILExceptionClause.Finally:  					handlers.Add (new FinallyTryInstructionHandler (handlerBlock));  					break;  				case PE.CorILExceptionClause.Fault:  					handlers.Add (new FaultTryInstructionHandler (handlerBlock));  					break;  				default:  					throw new ArgumentOutOfRangeException ();  				}  			}  			instructions.Add (new TryInstruction (offset' tryBlock' handlers));  			// Jump over try block  			var nextOffset = ehcs [0].TryOffset + ehcs [0].TryLength;  			if (!ctxt.OffsetToIndex.TryGetValue (nextOffset' out i))  				i = ctxt.Instructions.Length;  		}  		else {  			var instruction = ctxt.Instructions [i++];  			var offset = instruction.Offset;  			while (instruction.OpCode == PE.OpCode.Unaligned || instruction.OpCode == PE.OpCode.Volatile || instruction.OpCode == PE.OpCode.Tailcall) {  				// Skip over any ignored prefixes' but remember instruction begins at original offset  				// NOTE: What ever happened to the "no." prefix mentioned in the spec?  				if (i >= ctxt.Instructions.Length)  					throw new InvalidOperationException ("invalid instructions");  				instruction = ctxt.Instructions [i++];  			}  			switch (instruction.OpCode) {  			case PE.OpCode.Cpblk:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Cpblk));  				break;  			case PE.OpCode.Initblk:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Initblk));  				break;  			case PE.OpCode.Arglist:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Arglist));  				break;  			case PE.OpCode.Localloc:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Localloc));  				break;  			case PE.OpCode.Jmp:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Jmp));  				break;  			case PE.OpCode.Calli:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Calli));  				break;  			case PE.OpCode.Sizeof:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Sizeof));  				break;  			case PE.OpCode.Mkrefany:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Mkrefany));  				break;  			case PE.OpCode.Refanytype:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanytype));  				break;  			case PE.OpCode.Refanyval:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanyval));  				break;  			case PE.OpCode.Nop:  				instructions.Add (new MiscInstruction (offset' MiscOp.Nop));  				break;  			case PE.OpCode.Break:  				instructions.Add (new MiscInstruction (offset' MiscOp.Break));  				break;  			case PE.OpCode.Dup:  				instructions.Add (new MiscInstruction (offset' MiscOp.Dup));  				break;  			case PE.OpCode.Pop:  				instructions.Add (new MiscInstruction (offset' MiscOp.Pop));  				break;  			case PE.OpCode.Ldnull:  				instructions.Add (new MiscInstruction (offset' MiscOp.Ldnull));  				break;  			case PE.OpCode.Ckfinite:  				instructions.Add (new MiscInstruction (offset' MiscOp.Ckfinite));  				break;  			case PE.OpCode.Throw:  				instructions.Add (new MiscInstruction (offset' MiscOp.Throw));  				break;  			case PE.OpCode.Rethrow:  				instructions.Add (new MiscInstruction (offset' MiscOp.Rethrow));  				break;  			case PE.OpCode.Ldind_ref:  				instructions.Add (new MiscInstruction (offset' MiscOp.LdindRef));  				break;  			case PE.OpCode.Stind_ref:  				instructions.Add (new MiscInstruction (offset' MiscOp.StindRef));  				break;  			case PE.OpCode.Ldelem_ref:  				instructions.Add (new MiscInstruction (offset' MiscOp.LdelemRef));  				break;  			case PE.OpCode.Stelem_ref:  				instructions.Add (new MiscInstruction (offset' MiscOp.StelemRef));  				break;  			case PE.OpCode.Ldlen:  				instructions.Add (new MiscInstruction (offset' MiscOp.Ldlen));  				break;  			case PE.OpCode.Ret:  				if (ctxt.ResultType == null)  					instructions.Add (new MiscInstruction (offset' MiscOp.Ret));  				else  					instructions.Add (new MiscInstruction (offset' MiscOp.RetVal));  				break;  			case PE.OpCode.Endfilter:  				instructions.Add (new MiscInstruction (offset' MiscOp.Endfilter));  				break;  			case PE.OpCode.Endfinally:  				// aka EndFault  				instructions.Add (new MiscInstruction (offset' MiscOp.Endfinally));  				break;  			case PE.OpCode.Br_s:  			case PE.OpCode.Br:  				instructions.Add (new BranchInstruction (offset' BranchOp.Br' false' (int)instruction.Value));  				break;  			case PE.OpCode.Brtrue_s:  			// aka brinst.s  			case PE.OpCode.Brtrue:  				// aka brinst  				instructions.Add (new BranchInstruction (offset' BranchOp.Brtrue' false' (int)instruction.Value));  				break;  			case PE.OpCode.Brfalse_s:  			// aka brzero.s' brnull.s  			case PE.OpCode.Brfalse:  				// aka brzero' brnull  				instructions.Add (new BranchInstruction (offset' BranchOp.Brfalse' false' (int)instruction.Value));  				break;  			case PE.OpCode.Beq:  			case PE.OpCode.Beq_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.Breq' false' (int)instruction.Value));  				break;  			case PE.OpCode.Bne_un:  			case PE.OpCode.Bne_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.Brne' false' (int)instruction.Value));  				break;  			case PE.OpCode.Leave:  			case PE.OpCode.Leave_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.Leave' false' (int)instruction.Value));  				break;  			case PE.OpCode.Blt:  			case PE.OpCode.Blt_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' false' (int)instruction.Value));  				break;  			case PE.OpCode.Blt_un:  			case PE.OpCode.Blt_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' true' (int)instruction.Value));  				break;  			case PE.OpCode.Ble:  			case PE.OpCode.Ble_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' false' (int)instruction.Value));  				break;  			case PE.OpCode.Ble_un:  			case PE.OpCode.Ble_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' true' (int)instruction.Value));  				break;  			case PE.OpCode.Bgt:  			case PE.OpCode.Bgt_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' false' (int)instruction.Value));  				break;  			case PE.OpCode.Bgt_un:  			case PE.OpCode.Bgt_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' true' (int)instruction.Value));  				break;  			case PE.OpCode.Bge:  			case PE.OpCode.Bge_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' false' (int)instruction.Value));  				break;  			case PE.OpCode.Bge_un:  			case PE.OpCode.Bge_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' true' (int)instruction.Value));  				break;  			case PE.OpCode.Switch:  				instructions.Add (new SwitchInstruction (offset' (Seq<int>)instruction.Value));  				break;  			case PE.OpCode.Ceq:  				instructions.Add (new CompareInstruction (offset' CompareOp.Ceq' false));  				break;  			case PE.OpCode.Clt:  				instructions.Add (new CompareInstruction (offset' CompareOp.Clt' false));  				break;  			case PE.OpCode.Clt_un:  				instructions.Add (new CompareInstruction (offset' CompareOp.Clt' true));  				break;  			case PE.OpCode.Cgt:  				instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' false));  				break;  			case PE.OpCode.Cgt_un:  				instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' true));  				break;  			case PE.OpCode.Ldarg_0:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));  				break;  			case PE.OpCode.Ldarg_1:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));  				break;  			case PE.OpCode.Ldarg_2:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));  				break;  			case PE.OpCode.Ldarg_3:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));  				break;  			case PE.OpCode.Ldarg:  			case PE.OpCode.Ldarg_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));  				break;  			case PE.OpCode.Ldarga:  			case PE.OpCode.Ldarga_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));  				break;  			case PE.OpCode.Starg:  			case PE.OpCode.Starg_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));  				break;  			case PE.OpCode.Ldloc_0:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 0));  				break;  			case PE.OpCode.Ldloc_1:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 1));  				break;  			case PE.OpCode.Ldloc_2:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 2));  				break;  			case PE.OpCode.Ldloc_3:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 3));  				break;  			case PE.OpCode.Ldloc:  			case PE.OpCode.Ldloc_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));  				break;  			case PE.OpCode.Ldloca:  			case PE.OpCode.Ldloca_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));  				break;  			case PE.OpCode.Stloc_0:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 0));  				break;  			case PE.OpCode.Stloc_1:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 1));  				break;  			case PE.OpCode.Stloc_2:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 2));  				break;  			case PE.OpCode.Stloc_3:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 3));  				break;  			case PE.OpCode.Stloc:  			case PE.OpCode.Stloc_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));  				break;  			case PE.OpCode.Ldfld:  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));  				break;  			case PE.OpCode.Ldsfld:  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));  				break;  			case PE.OpCode.Ldflda:  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));  				break;  			case PE.OpCode.Ldsflda:  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));  				break;  			case PE.OpCode.Stfld:  				instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));  				break;  			case PE.OpCode.Stsfld:  				instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));  				break;  			case PE.OpCode.Ldtoken: {  				if (instruction.Value is FieldRef)  					instructions.Add (new FieldInstruction (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));  				else if (instruction.Value is MethodRef)  					instructions.Add (new MethodInstruction (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));  				else if (instruction.Value is TypeRef)  					// NOTE: May be a higher-kinded type  					instructions.Add (new TypeInstruction (offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));  				else  					throw new InvalidOperationException ("unexpected ldtoken instruction value");  				break;  			}  			case PE.OpCode.Constrained: {  				var constrained = (TypeRef)instruction.Value;  				if (i >= ctxt.Instructions.Length)  					throw new InvalidOperationException ("invalid instructions");  				instruction = ctxt.Instructions [i++];  				if (instruction.OpCode != PE.OpCode.Callvirt)  					throw new InvalidOperationException ("invalid instruction");  				instructions.Add (new MethodInstruction (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));  				break;  			}  			case PE.OpCode.Call:  				instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Callvirt:  				instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Ldftn:  				instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Ldvirtftn:  				instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Newobj:  				instructions.Add (new MethodInstruction (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Ldind_i1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int8Ref));  				break;  			case PE.OpCode.Ldind_u1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt8Ref));  				break;  			case PE.OpCode.Ldind_i2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int16Ref));  				break;  			case PE.OpCode.Ldind_u2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt16Ref));  				break;  			case PE.OpCode.Ldind_i4:  			case PE.OpCode.Ldind_u4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int32Ref));  				break;  			case PE.OpCode.Ldind_i8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int64Ref));  				break;  			case PE.OpCode.Ldind_i:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.IntNativeRef));  				break;  			case PE.OpCode.Ldind_r4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.SingleRef));  				break;  			case PE.OpCode.Ldind_r8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.DoubleRef));  				break;  			case PE.OpCode.Ldobj:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Stind_i1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int8Ref));  				break;  			case PE.OpCode.Stind_i2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int16Ref));  				break;  			case PE.OpCode.Stind_i4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int32Ref));  				break;  			case PE.OpCode.Stind_i8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int64Ref));  				break;  			case PE.OpCode.Stind_i:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.IntNativeRef));  				break;  			case PE.OpCode.Stind_r4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.SingleRef));  				break;  			case PE.OpCode.Stind_r8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.DoubleRef));  				break;  			case PE.OpCode.Stobj:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Cpobj:  				instructions.Add (new TypeInstruction (offset' TypeOp.Cpobj' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Newarr:  				instructions.Add (new TypeInstruction (offset' TypeOp.Newarr' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Initobj:  				instructions.Add (new TypeInstruction (offset' TypeOp.Initobj' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Castclass:  				instructions.Add (new TypeInstruction (offset' TypeOp.Castclass' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Isinst:  				instructions.Add (new TypeInstruction (offset' TypeOp.Isinst' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Box:  				instructions.Add (new TypeInstruction (offset' TypeOp.Box' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Unbox:  				instructions.Add (new TypeInstruction (offset' TypeOp.Unbox' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Unbox_any:  				instructions.Add (new TypeInstruction (offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Ldelem_i1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int8Ref));  				break;  			case PE.OpCode.Ldelem_u1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt8Ref));  				break;  			case PE.OpCode.Ldelem_i2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int16Ref));  				break;  			case PE.OpCode.Ldelem_u2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt16Ref));  				break;  			case PE.OpCode.Ldelem_i4:  			case PE.OpCode.Ldelem_u4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int32Ref));  				break;  			case PE.OpCode.Ldelem_i:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.IntNativeRef));  				break;  			case PE.OpCode.Ldelem_i8:  				// aka ldelem.u8  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int64Ref));  				break;  			case PE.OpCode.Ldelem_r4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.SingleRef));  				break;  			case PE.OpCode.Ldelem_r8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.DoubleRef));  				break;  			case PE.OpCode.Ldelem:  				// aka ldelem.any  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Stelem_i1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int8Ref));  				break;  			case PE.OpCode.Stelem_i2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int16Ref));  				break;  			case PE.OpCode.Stelem_i4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int32Ref));  				break;  			case PE.OpCode.Stelem_i8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int64Ref));  				break;  			case PE.OpCode.Stelem_i:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.IntNativeRef));  				break;  			case PE.OpCode.Stelem_r4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.SingleRef));  				break;  			case PE.OpCode.Stelem_r8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.DoubleRef));  				break;  			case PE.OpCode.Stelem:  				// aka stelem.any  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Readonly:  				if (i >= ctxt.Instructions.Length)  					throw new InvalidOperationException ("invalid instruction");  				instruction = ctxt.Instructions [i++];  				if (instruction.OpCode != PE.OpCode.Ldelema)  					throw new InvalidOperationException ("invalid instruction");  				instructions.Add (new LdElemAddrInstruction (offset' true' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Ldelema:  				instructions.Add (new LdElemAddrInstruction (offset' false' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Ldc_i4_0:  				instructions.Add (new LdInt32Instruction (offset' 0));  				break;  			case PE.OpCode.Ldc_i4_1:  				instructions.Add (new LdInt32Instruction (offset' 1));  				break;  			case PE.OpCode.Ldc_i4_2:  				instructions.Add (new LdInt32Instruction (offset' 2));  				break;  			case PE.OpCode.Ldc_i4_3:  				instructions.Add (new LdInt32Instruction (offset' 3));  				break;  			case PE.OpCode.Ldc_i4_4:  				instructions.Add (new LdInt32Instruction (offset' 4));  				break;  			case PE.OpCode.Ldc_i4_5:  				instructions.Add (new LdInt32Instruction (offset' 5));  				break;  			case PE.OpCode.Ldc_i4_6:  				instructions.Add (new LdInt32Instruction (offset' 6));  				break;  			case PE.OpCode.Ldc_i4_7:  				instructions.Add (new LdInt32Instruction (offset' 7));  				break;  			case PE.OpCode.Ldc_i4_8:  				instructions.Add (new LdInt32Instruction (offset' 8));  				break;  			case PE.OpCode.Ldc_i4_m1:  				instructions.Add (new LdInt32Instruction (offset' -1));  				break;  			case PE.OpCode.Ldc_i4:  			case PE.OpCode.Ldc_i4_s:  				instructions.Add (new LdInt32Instruction (offset' (int)instruction.Value));  				break;  			case PE.OpCode.Ldc_i8:  				instructions.Add (new LdInt64Instruction (offset' (long)instruction.Value));  				break;  			case PE.OpCode.Ldc_r4:  				instructions.Add (new LdSingleInstruction (offset' (float)instruction.Value));  				break;  			case PE.OpCode.Ldc_r8:  				instructions.Add (new LdDoubleInstruction (offset' (double)instruction.Value));  				break;  			case PE.OpCode.Ldstr:  				instructions.Add (new LdStringInstruction (offset' (string)instruction.Value));  				break;  			case PE.OpCode.Add:  				instructions.Add (new ArithInstruction (offset' ArithOp.Add' false' false));  				break;  			case PE.OpCode.Add_ovf:  				instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' false));  				break;  			case PE.OpCode.Add_ovf_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' true));  				break;  			case PE.OpCode.Sub:  				instructions.Add (new ArithInstruction (offset' ArithOp.Sub' false' false));  				break;  			case PE.OpCode.Sub_ovf:  				instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' false));  				break;  			case PE.OpCode.Sub_ovf_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' true));  				break;  			case PE.OpCode.Mul:  				instructions.Add (new ArithInstruction (offset' ArithOp.Mul' false' false));  				break;  			case PE.OpCode.Mul_ovf:  				instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' false));  				break;  			case PE.OpCode.Mul_ovf_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' true));  				break;  			case PE.OpCode.Div:  				instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' false));  				break;  			case PE.OpCode.Div_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' true));  				break;  			case PE.OpCode.Rem:  				instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' false));  				break;  			case PE.OpCode.Rem_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' true));  				break;  			case PE.OpCode.Neg:  				instructions.Add (new ArithInstruction (offset' ArithOp.Neg' false' false));  				break;  			case PE.OpCode.And:  				instructions.Add (new ArithInstruction (offset' ArithOp.BitAnd' false' false));  				break;  			case PE.OpCode.Or:  				instructions.Add (new ArithInstruction (offset' ArithOp.BitOr' false' false));  				break;  			case PE.OpCode.Xor:  				instructions.Add (new ArithInstruction (offset' ArithOp.BitXor' false' false));  				break;  			case PE.OpCode.Not:  				instructions.Add (new ArithInstruction (offset' ArithOp.BitNot' false' false));  				break;  			case PE.OpCode.Shl:  				instructions.Add (new ArithInstruction (offset' ArithOp.Shl' false' false));  				break;  			case PE.OpCode.Shr:  				instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' false));  				break;  			case PE.OpCode.Shr_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' true));  				break;  			case PE.OpCode.Conv_i1:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' false' false));  				break;  			case PE.OpCode.Conv_u1:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' false' false));  				break;  			case PE.OpCode.Conv_i2:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' false' false));  				break;  			case PE.OpCode.Conv_u2:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' false' false));  				break;  			case PE.OpCode.Conv_i4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' false' false));  				break;  			case PE.OpCode.Conv_u4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' false' false));  				break;  			case PE.OpCode.Conv_i8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' false' false));  				break;  			case PE.OpCode.Conv_u8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' false' false));  				break;  			case PE.OpCode.Conv_i:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' false' false));  				break;  			case PE.OpCode.Conv_u:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' false' false));  				break;  			case PE.OpCode.Conv_r4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Single' false' false));  				break;  			case PE.OpCode.Conv_r8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' false));  				break;  			case PE.OpCode.Conv_r_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' true));  				break;  			case PE.OpCode.Conv_ovf_i1:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' false));  				break;  			case PE.OpCode.Conv_ovf_u1:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' false));  				break;  			case PE.OpCode.Conv_ovf_i2:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' false));  				break;  			case PE.OpCode.Conv_ovf_u2:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' false));  				break;  			case PE.OpCode.Conv_ovf_i4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' false));  				break;  			case PE.OpCode.Conv_ovf_u4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' false));  				break;  			case PE.OpCode.Conv_ovf_i8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' false));  				break;  			case PE.OpCode.Conv_ovf_u8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' false));  				break;  			case PE.OpCode.Conv_ovf_i:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' false));  				break;  			case PE.OpCode.Conv_ovf_u:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' false));  				break;  			case PE.OpCode.Conv_ovf_i1_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' true));  				break;  			case PE.OpCode.Conv_ovf_u1_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' true));  				break;  			case PE.OpCode.Conv_ovf_i2_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' true));  				break;  			case PE.OpCode.Conv_ovf_u2_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' true));  				break;  			case PE.OpCode.Conv_ovf_i4_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' true));  				break;  			case PE.OpCode.Conv_ovf_u4_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' true));  				break;  			case PE.OpCode.Conv_ovf_i8_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' true));  				break;  			case PE.OpCode.Conv_ovf_u8_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' true));  				break;  			case PE.OpCode.Conv_ovf_i_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' true));  				break;  			case PE.OpCode.Conv_ovf_u_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' true));  				break;  			default:  				throw new InvalidOperationException ("invalid instruction");  			}  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: while (!ctxt.AtEnd (i)) {  	var j = i > ctxt.Start ? ctxt.JumpOverHandlers (i) : i;  	if (j > i)  		i = j;  	else {  		var ehcs = ctxt.OutermostTryBlocks (i);  		if (ehcs != null) {  			// A try instruction begins here with given handlers  			var offset = ctxt.Instructions [i].Offset;  			var tryCtxt = new TryTranslationContext (ctxt' i' ehcs);  			var tryBlock = InstructionsFromContext (tryCtxt);  			var handlers = new Seq<TryInstructionHandler> ();  			foreach (var ehc in ehcs) {  				var handlerCtxt = new HandlerTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.HandlerOffset]' ehc);  				var handlerBlock = InstructionsFromContext (handlerCtxt);  				switch (ehc.Flags) {  				case PE.CorILExceptionClause.Exception:  					handlers.Add (new CatchTryInstructionHandler ((TypeRef)ehc.Class' handlerBlock));  					break;  				case PE.CorILExceptionClause.Filter: {  					var filterCtxt = new FilterTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.FilterOffset]' ehc);  					var filterBlock = InstructionsFromContext (filterCtxt);  					handlers.Add (new FilterTryInstructionHandler (filterBlock' handlerBlock));  					break;  				}  				case PE.CorILExceptionClause.Finally:  					handlers.Add (new FinallyTryInstructionHandler (handlerBlock));  					break;  				case PE.CorILExceptionClause.Fault:  					handlers.Add (new FaultTryInstructionHandler (handlerBlock));  					break;  				default:  					throw new ArgumentOutOfRangeException ();  				}  			}  			instructions.Add (new TryInstruction (offset' tryBlock' handlers));  			// Jump over try block  			var nextOffset = ehcs [0].TryOffset + ehcs [0].TryLength;  			if (!ctxt.OffsetToIndex.TryGetValue (nextOffset' out i))  				i = ctxt.Instructions.Length;  		}  		else {  			var instruction = ctxt.Instructions [i++];  			var offset = instruction.Offset;  			while (instruction.OpCode == PE.OpCode.Unaligned || instruction.OpCode == PE.OpCode.Volatile || instruction.OpCode == PE.OpCode.Tailcall) {  				// Skip over any ignored prefixes' but remember instruction begins at original offset  				// NOTE: What ever happened to the "no." prefix mentioned in the spec?  				if (i >= ctxt.Instructions.Length)  					throw new InvalidOperationException ("invalid instructions");  				instruction = ctxt.Instructions [i++];  			}  			switch (instruction.OpCode) {  			case PE.OpCode.Cpblk:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Cpblk));  				break;  			case PE.OpCode.Initblk:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Initblk));  				break;  			case PE.OpCode.Arglist:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Arglist));  				break;  			case PE.OpCode.Localloc:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Localloc));  				break;  			case PE.OpCode.Jmp:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Jmp));  				break;  			case PE.OpCode.Calli:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Calli));  				break;  			case PE.OpCode.Sizeof:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Sizeof));  				break;  			case PE.OpCode.Mkrefany:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Mkrefany));  				break;  			case PE.OpCode.Refanytype:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanytype));  				break;  			case PE.OpCode.Refanyval:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanyval));  				break;  			case PE.OpCode.Nop:  				instructions.Add (new MiscInstruction (offset' MiscOp.Nop));  				break;  			case PE.OpCode.Break:  				instructions.Add (new MiscInstruction (offset' MiscOp.Break));  				break;  			case PE.OpCode.Dup:  				instructions.Add (new MiscInstruction (offset' MiscOp.Dup));  				break;  			case PE.OpCode.Pop:  				instructions.Add (new MiscInstruction (offset' MiscOp.Pop));  				break;  			case PE.OpCode.Ldnull:  				instructions.Add (new MiscInstruction (offset' MiscOp.Ldnull));  				break;  			case PE.OpCode.Ckfinite:  				instructions.Add (new MiscInstruction (offset' MiscOp.Ckfinite));  				break;  			case PE.OpCode.Throw:  				instructions.Add (new MiscInstruction (offset' MiscOp.Throw));  				break;  			case PE.OpCode.Rethrow:  				instructions.Add (new MiscInstruction (offset' MiscOp.Rethrow));  				break;  			case PE.OpCode.Ldind_ref:  				instructions.Add (new MiscInstruction (offset' MiscOp.LdindRef));  				break;  			case PE.OpCode.Stind_ref:  				instructions.Add (new MiscInstruction (offset' MiscOp.StindRef));  				break;  			case PE.OpCode.Ldelem_ref:  				instructions.Add (new MiscInstruction (offset' MiscOp.LdelemRef));  				break;  			case PE.OpCode.Stelem_ref:  				instructions.Add (new MiscInstruction (offset' MiscOp.StelemRef));  				break;  			case PE.OpCode.Ldlen:  				instructions.Add (new MiscInstruction (offset' MiscOp.Ldlen));  				break;  			case PE.OpCode.Ret:  				if (ctxt.ResultType == null)  					instructions.Add (new MiscInstruction (offset' MiscOp.Ret));  				else  					instructions.Add (new MiscInstruction (offset' MiscOp.RetVal));  				break;  			case PE.OpCode.Endfilter:  				instructions.Add (new MiscInstruction (offset' MiscOp.Endfilter));  				break;  			case PE.OpCode.Endfinally:  				// aka EndFault  				instructions.Add (new MiscInstruction (offset' MiscOp.Endfinally));  				break;  			case PE.OpCode.Br_s:  			case PE.OpCode.Br:  				instructions.Add (new BranchInstruction (offset' BranchOp.Br' false' (int)instruction.Value));  				break;  			case PE.OpCode.Brtrue_s:  			// aka brinst.s  			case PE.OpCode.Brtrue:  				// aka brinst  				instructions.Add (new BranchInstruction (offset' BranchOp.Brtrue' false' (int)instruction.Value));  				break;  			case PE.OpCode.Brfalse_s:  			// aka brzero.s' brnull.s  			case PE.OpCode.Brfalse:  				// aka brzero' brnull  				instructions.Add (new BranchInstruction (offset' BranchOp.Brfalse' false' (int)instruction.Value));  				break;  			case PE.OpCode.Beq:  			case PE.OpCode.Beq_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.Breq' false' (int)instruction.Value));  				break;  			case PE.OpCode.Bne_un:  			case PE.OpCode.Bne_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.Brne' false' (int)instruction.Value));  				break;  			case PE.OpCode.Leave:  			case PE.OpCode.Leave_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.Leave' false' (int)instruction.Value));  				break;  			case PE.OpCode.Blt:  			case PE.OpCode.Blt_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' false' (int)instruction.Value));  				break;  			case PE.OpCode.Blt_un:  			case PE.OpCode.Blt_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' true' (int)instruction.Value));  				break;  			case PE.OpCode.Ble:  			case PE.OpCode.Ble_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' false' (int)instruction.Value));  				break;  			case PE.OpCode.Ble_un:  			case PE.OpCode.Ble_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' true' (int)instruction.Value));  				break;  			case PE.OpCode.Bgt:  			case PE.OpCode.Bgt_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' false' (int)instruction.Value));  				break;  			case PE.OpCode.Bgt_un:  			case PE.OpCode.Bgt_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' true' (int)instruction.Value));  				break;  			case PE.OpCode.Bge:  			case PE.OpCode.Bge_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' false' (int)instruction.Value));  				break;  			case PE.OpCode.Bge_un:  			case PE.OpCode.Bge_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' true' (int)instruction.Value));  				break;  			case PE.OpCode.Switch:  				instructions.Add (new SwitchInstruction (offset' (Seq<int>)instruction.Value));  				break;  			case PE.OpCode.Ceq:  				instructions.Add (new CompareInstruction (offset' CompareOp.Ceq' false));  				break;  			case PE.OpCode.Clt:  				instructions.Add (new CompareInstruction (offset' CompareOp.Clt' false));  				break;  			case PE.OpCode.Clt_un:  				instructions.Add (new CompareInstruction (offset' CompareOp.Clt' true));  				break;  			case PE.OpCode.Cgt:  				instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' false));  				break;  			case PE.OpCode.Cgt_un:  				instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' true));  				break;  			case PE.OpCode.Ldarg_0:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));  				break;  			case PE.OpCode.Ldarg_1:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));  				break;  			case PE.OpCode.Ldarg_2:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));  				break;  			case PE.OpCode.Ldarg_3:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));  				break;  			case PE.OpCode.Ldarg:  			case PE.OpCode.Ldarg_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));  				break;  			case PE.OpCode.Ldarga:  			case PE.OpCode.Ldarga_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));  				break;  			case PE.OpCode.Starg:  			case PE.OpCode.Starg_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));  				break;  			case PE.OpCode.Ldloc_0:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 0));  				break;  			case PE.OpCode.Ldloc_1:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 1));  				break;  			case PE.OpCode.Ldloc_2:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 2));  				break;  			case PE.OpCode.Ldloc_3:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 3));  				break;  			case PE.OpCode.Ldloc:  			case PE.OpCode.Ldloc_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));  				break;  			case PE.OpCode.Ldloca:  			case PE.OpCode.Ldloca_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));  				break;  			case PE.OpCode.Stloc_0:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 0));  				break;  			case PE.OpCode.Stloc_1:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 1));  				break;  			case PE.OpCode.Stloc_2:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 2));  				break;  			case PE.OpCode.Stloc_3:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 3));  				break;  			case PE.OpCode.Stloc:  			case PE.OpCode.Stloc_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));  				break;  			case PE.OpCode.Ldfld:  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));  				break;  			case PE.OpCode.Ldsfld:  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));  				break;  			case PE.OpCode.Ldflda:  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));  				break;  			case PE.OpCode.Ldsflda:  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));  				break;  			case PE.OpCode.Stfld:  				instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));  				break;  			case PE.OpCode.Stsfld:  				instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));  				break;  			case PE.OpCode.Ldtoken: {  				if (instruction.Value is FieldRef)  					instructions.Add (new FieldInstruction (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));  				else if (instruction.Value is MethodRef)  					instructions.Add (new MethodInstruction (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));  				else if (instruction.Value is TypeRef)  					// NOTE: May be a higher-kinded type  					instructions.Add (new TypeInstruction (offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));  				else  					throw new InvalidOperationException ("unexpected ldtoken instruction value");  				break;  			}  			case PE.OpCode.Constrained: {  				var constrained = (TypeRef)instruction.Value;  				if (i >= ctxt.Instructions.Length)  					throw new InvalidOperationException ("invalid instructions");  				instruction = ctxt.Instructions [i++];  				if (instruction.OpCode != PE.OpCode.Callvirt)  					throw new InvalidOperationException ("invalid instruction");  				instructions.Add (new MethodInstruction (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));  				break;  			}  			case PE.OpCode.Call:  				instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Callvirt:  				instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Ldftn:  				instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Ldvirtftn:  				instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Newobj:  				instructions.Add (new MethodInstruction (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Ldind_i1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int8Ref));  				break;  			case PE.OpCode.Ldind_u1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt8Ref));  				break;  			case PE.OpCode.Ldind_i2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int16Ref));  				break;  			case PE.OpCode.Ldind_u2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt16Ref));  				break;  			case PE.OpCode.Ldind_i4:  			case PE.OpCode.Ldind_u4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int32Ref));  				break;  			case PE.OpCode.Ldind_i8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int64Ref));  				break;  			case PE.OpCode.Ldind_i:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.IntNativeRef));  				break;  			case PE.OpCode.Ldind_r4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.SingleRef));  				break;  			case PE.OpCode.Ldind_r8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.DoubleRef));  				break;  			case PE.OpCode.Ldobj:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Stind_i1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int8Ref));  				break;  			case PE.OpCode.Stind_i2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int16Ref));  				break;  			case PE.OpCode.Stind_i4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int32Ref));  				break;  			case PE.OpCode.Stind_i8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int64Ref));  				break;  			case PE.OpCode.Stind_i:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.IntNativeRef));  				break;  			case PE.OpCode.Stind_r4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.SingleRef));  				break;  			case PE.OpCode.Stind_r8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.DoubleRef));  				break;  			case PE.OpCode.Stobj:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Cpobj:  				instructions.Add (new TypeInstruction (offset' TypeOp.Cpobj' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Newarr:  				instructions.Add (new TypeInstruction (offset' TypeOp.Newarr' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Initobj:  				instructions.Add (new TypeInstruction (offset' TypeOp.Initobj' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Castclass:  				instructions.Add (new TypeInstruction (offset' TypeOp.Castclass' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Isinst:  				instructions.Add (new TypeInstruction (offset' TypeOp.Isinst' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Box:  				instructions.Add (new TypeInstruction (offset' TypeOp.Box' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Unbox:  				instructions.Add (new TypeInstruction (offset' TypeOp.Unbox' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Unbox_any:  				instructions.Add (new TypeInstruction (offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Ldelem_i1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int8Ref));  				break;  			case PE.OpCode.Ldelem_u1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt8Ref));  				break;  			case PE.OpCode.Ldelem_i2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int16Ref));  				break;  			case PE.OpCode.Ldelem_u2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt16Ref));  				break;  			case PE.OpCode.Ldelem_i4:  			case PE.OpCode.Ldelem_u4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int32Ref));  				break;  			case PE.OpCode.Ldelem_i:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.IntNativeRef));  				break;  			case PE.OpCode.Ldelem_i8:  				// aka ldelem.u8  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int64Ref));  				break;  			case PE.OpCode.Ldelem_r4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.SingleRef));  				break;  			case PE.OpCode.Ldelem_r8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.DoubleRef));  				break;  			case PE.OpCode.Ldelem:  				// aka ldelem.any  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Stelem_i1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int8Ref));  				break;  			case PE.OpCode.Stelem_i2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int16Ref));  				break;  			case PE.OpCode.Stelem_i4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int32Ref));  				break;  			case PE.OpCode.Stelem_i8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int64Ref));  				break;  			case PE.OpCode.Stelem_i:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.IntNativeRef));  				break;  			case PE.OpCode.Stelem_r4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.SingleRef));  				break;  			case PE.OpCode.Stelem_r8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.DoubleRef));  				break;  			case PE.OpCode.Stelem:  				// aka stelem.any  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Readonly:  				if (i >= ctxt.Instructions.Length)  					throw new InvalidOperationException ("invalid instruction");  				instruction = ctxt.Instructions [i++];  				if (instruction.OpCode != PE.OpCode.Ldelema)  					throw new InvalidOperationException ("invalid instruction");  				instructions.Add (new LdElemAddrInstruction (offset' true' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Ldelema:  				instructions.Add (new LdElemAddrInstruction (offset' false' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Ldc_i4_0:  				instructions.Add (new LdInt32Instruction (offset' 0));  				break;  			case PE.OpCode.Ldc_i4_1:  				instructions.Add (new LdInt32Instruction (offset' 1));  				break;  			case PE.OpCode.Ldc_i4_2:  				instructions.Add (new LdInt32Instruction (offset' 2));  				break;  			case PE.OpCode.Ldc_i4_3:  				instructions.Add (new LdInt32Instruction (offset' 3));  				break;  			case PE.OpCode.Ldc_i4_4:  				instructions.Add (new LdInt32Instruction (offset' 4));  				break;  			case PE.OpCode.Ldc_i4_5:  				instructions.Add (new LdInt32Instruction (offset' 5));  				break;  			case PE.OpCode.Ldc_i4_6:  				instructions.Add (new LdInt32Instruction (offset' 6));  				break;  			case PE.OpCode.Ldc_i4_7:  				instructions.Add (new LdInt32Instruction (offset' 7));  				break;  			case PE.OpCode.Ldc_i4_8:  				instructions.Add (new LdInt32Instruction (offset' 8));  				break;  			case PE.OpCode.Ldc_i4_m1:  				instructions.Add (new LdInt32Instruction (offset' -1));  				break;  			case PE.OpCode.Ldc_i4:  			case PE.OpCode.Ldc_i4_s:  				instructions.Add (new LdInt32Instruction (offset' (int)instruction.Value));  				break;  			case PE.OpCode.Ldc_i8:  				instructions.Add (new LdInt64Instruction (offset' (long)instruction.Value));  				break;  			case PE.OpCode.Ldc_r4:  				instructions.Add (new LdSingleInstruction (offset' (float)instruction.Value));  				break;  			case PE.OpCode.Ldc_r8:  				instructions.Add (new LdDoubleInstruction (offset' (double)instruction.Value));  				break;  			case PE.OpCode.Ldstr:  				instructions.Add (new LdStringInstruction (offset' (string)instruction.Value));  				break;  			case PE.OpCode.Add:  				instructions.Add (new ArithInstruction (offset' ArithOp.Add' false' false));  				break;  			case PE.OpCode.Add_ovf:  				instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' false));  				break;  			case PE.OpCode.Add_ovf_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' true));  				break;  			case PE.OpCode.Sub:  				instructions.Add (new ArithInstruction (offset' ArithOp.Sub' false' false));  				break;  			case PE.OpCode.Sub_ovf:  				instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' false));  				break;  			case PE.OpCode.Sub_ovf_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' true));  				break;  			case PE.OpCode.Mul:  				instructions.Add (new ArithInstruction (offset' ArithOp.Mul' false' false));  				break;  			case PE.OpCode.Mul_ovf:  				instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' false));  				break;  			case PE.OpCode.Mul_ovf_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' true));  				break;  			case PE.OpCode.Div:  				instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' false));  				break;  			case PE.OpCode.Div_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' true));  				break;  			case PE.OpCode.Rem:  				instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' false));  				break;  			case PE.OpCode.Rem_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' true));  				break;  			case PE.OpCode.Neg:  				instructions.Add (new ArithInstruction (offset' ArithOp.Neg' false' false));  				break;  			case PE.OpCode.And:  				instructions.Add (new ArithInstruction (offset' ArithOp.BitAnd' false' false));  				break;  			case PE.OpCode.Or:  				instructions.Add (new ArithInstruction (offset' ArithOp.BitOr' false' false));  				break;  			case PE.OpCode.Xor:  				instructions.Add (new ArithInstruction (offset' ArithOp.BitXor' false' false));  				break;  			case PE.OpCode.Not:  				instructions.Add (new ArithInstruction (offset' ArithOp.BitNot' false' false));  				break;  			case PE.OpCode.Shl:  				instructions.Add (new ArithInstruction (offset' ArithOp.Shl' false' false));  				break;  			case PE.OpCode.Shr:  				instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' false));  				break;  			case PE.OpCode.Shr_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' true));  				break;  			case PE.OpCode.Conv_i1:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' false' false));  				break;  			case PE.OpCode.Conv_u1:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' false' false));  				break;  			case PE.OpCode.Conv_i2:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' false' false));  				break;  			case PE.OpCode.Conv_u2:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' false' false));  				break;  			case PE.OpCode.Conv_i4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' false' false));  				break;  			case PE.OpCode.Conv_u4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' false' false));  				break;  			case PE.OpCode.Conv_i8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' false' false));  				break;  			case PE.OpCode.Conv_u8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' false' false));  				break;  			case PE.OpCode.Conv_i:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' false' false));  				break;  			case PE.OpCode.Conv_u:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' false' false));  				break;  			case PE.OpCode.Conv_r4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Single' false' false));  				break;  			case PE.OpCode.Conv_r8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' false));  				break;  			case PE.OpCode.Conv_r_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' true));  				break;  			case PE.OpCode.Conv_ovf_i1:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' false));  				break;  			case PE.OpCode.Conv_ovf_u1:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' false));  				break;  			case PE.OpCode.Conv_ovf_i2:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' false));  				break;  			case PE.OpCode.Conv_ovf_u2:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' false));  				break;  			case PE.OpCode.Conv_ovf_i4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' false));  				break;  			case PE.OpCode.Conv_ovf_u4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' false));  				break;  			case PE.OpCode.Conv_ovf_i8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' false));  				break;  			case PE.OpCode.Conv_ovf_u8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' false));  				break;  			case PE.OpCode.Conv_ovf_i:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' false));  				break;  			case PE.OpCode.Conv_ovf_u:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' false));  				break;  			case PE.OpCode.Conv_ovf_i1_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' true));  				break;  			case PE.OpCode.Conv_ovf_u1_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' true));  				break;  			case PE.OpCode.Conv_ovf_i2_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' true));  				break;  			case PE.OpCode.Conv_ovf_u2_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' true));  				break;  			case PE.OpCode.Conv_ovf_i4_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' true));  				break;  			case PE.OpCode.Conv_ovf_u4_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' true));  				break;  			case PE.OpCode.Conv_ovf_i8_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' true));  				break;  			case PE.OpCode.Conv_ovf_u8_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' true));  				break;  			case PE.OpCode.Conv_ovf_i_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' true));  				break;  			case PE.OpCode.Conv_ovf_u_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' true));  				break;  			default:  				throw new InvalidOperationException ("invalid instruction");  			}  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: while (!ctxt.AtEnd (i)) {  	var j = i > ctxt.Start ? ctxt.JumpOverHandlers (i) : i;  	if (j > i)  		i = j;  	else {  		var ehcs = ctxt.OutermostTryBlocks (i);  		if (ehcs != null) {  			// A try instruction begins here with given handlers  			var offset = ctxt.Instructions [i].Offset;  			var tryCtxt = new TryTranslationContext (ctxt' i' ehcs);  			var tryBlock = InstructionsFromContext (tryCtxt);  			var handlers = new Seq<TryInstructionHandler> ();  			foreach (var ehc in ehcs) {  				var handlerCtxt = new HandlerTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.HandlerOffset]' ehc);  				var handlerBlock = InstructionsFromContext (handlerCtxt);  				switch (ehc.Flags) {  				case PE.CorILExceptionClause.Exception:  					handlers.Add (new CatchTryInstructionHandler ((TypeRef)ehc.Class' handlerBlock));  					break;  				case PE.CorILExceptionClause.Filter: {  					var filterCtxt = new FilterTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.FilterOffset]' ehc);  					var filterBlock = InstructionsFromContext (filterCtxt);  					handlers.Add (new FilterTryInstructionHandler (filterBlock' handlerBlock));  					break;  				}  				case PE.CorILExceptionClause.Finally:  					handlers.Add (new FinallyTryInstructionHandler (handlerBlock));  					break;  				case PE.CorILExceptionClause.Fault:  					handlers.Add (new FaultTryInstructionHandler (handlerBlock));  					break;  				default:  					throw new ArgumentOutOfRangeException ();  				}  			}  			instructions.Add (new TryInstruction (offset' tryBlock' handlers));  			// Jump over try block  			var nextOffset = ehcs [0].TryOffset + ehcs [0].TryLength;  			if (!ctxt.OffsetToIndex.TryGetValue (nextOffset' out i))  				i = ctxt.Instructions.Length;  		}  		else {  			var instruction = ctxt.Instructions [i++];  			var offset = instruction.Offset;  			while (instruction.OpCode == PE.OpCode.Unaligned || instruction.OpCode == PE.OpCode.Volatile || instruction.OpCode == PE.OpCode.Tailcall) {  				// Skip over any ignored prefixes' but remember instruction begins at original offset  				// NOTE: What ever happened to the "no." prefix mentioned in the spec?  				if (i >= ctxt.Instructions.Length)  					throw new InvalidOperationException ("invalid instructions");  				instruction = ctxt.Instructions [i++];  			}  			switch (instruction.OpCode) {  			case PE.OpCode.Cpblk:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Cpblk));  				break;  			case PE.OpCode.Initblk:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Initblk));  				break;  			case PE.OpCode.Arglist:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Arglist));  				break;  			case PE.OpCode.Localloc:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Localloc));  				break;  			case PE.OpCode.Jmp:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Jmp));  				break;  			case PE.OpCode.Calli:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Calli));  				break;  			case PE.OpCode.Sizeof:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Sizeof));  				break;  			case PE.OpCode.Mkrefany:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Mkrefany));  				break;  			case PE.OpCode.Refanytype:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanytype));  				break;  			case PE.OpCode.Refanyval:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanyval));  				break;  			case PE.OpCode.Nop:  				instructions.Add (new MiscInstruction (offset' MiscOp.Nop));  				break;  			case PE.OpCode.Break:  				instructions.Add (new MiscInstruction (offset' MiscOp.Break));  				break;  			case PE.OpCode.Dup:  				instructions.Add (new MiscInstruction (offset' MiscOp.Dup));  				break;  			case PE.OpCode.Pop:  				instructions.Add (new MiscInstruction (offset' MiscOp.Pop));  				break;  			case PE.OpCode.Ldnull:  				instructions.Add (new MiscInstruction (offset' MiscOp.Ldnull));  				break;  			case PE.OpCode.Ckfinite:  				instructions.Add (new MiscInstruction (offset' MiscOp.Ckfinite));  				break;  			case PE.OpCode.Throw:  				instructions.Add (new MiscInstruction (offset' MiscOp.Throw));  				break;  			case PE.OpCode.Rethrow:  				instructions.Add (new MiscInstruction (offset' MiscOp.Rethrow));  				break;  			case PE.OpCode.Ldind_ref:  				instructions.Add (new MiscInstruction (offset' MiscOp.LdindRef));  				break;  			case PE.OpCode.Stind_ref:  				instructions.Add (new MiscInstruction (offset' MiscOp.StindRef));  				break;  			case PE.OpCode.Ldelem_ref:  				instructions.Add (new MiscInstruction (offset' MiscOp.LdelemRef));  				break;  			case PE.OpCode.Stelem_ref:  				instructions.Add (new MiscInstruction (offset' MiscOp.StelemRef));  				break;  			case PE.OpCode.Ldlen:  				instructions.Add (new MiscInstruction (offset' MiscOp.Ldlen));  				break;  			case PE.OpCode.Ret:  				if (ctxt.ResultType == null)  					instructions.Add (new MiscInstruction (offset' MiscOp.Ret));  				else  					instructions.Add (new MiscInstruction (offset' MiscOp.RetVal));  				break;  			case PE.OpCode.Endfilter:  				instructions.Add (new MiscInstruction (offset' MiscOp.Endfilter));  				break;  			case PE.OpCode.Endfinally:  				// aka EndFault  				instructions.Add (new MiscInstruction (offset' MiscOp.Endfinally));  				break;  			case PE.OpCode.Br_s:  			case PE.OpCode.Br:  				instructions.Add (new BranchInstruction (offset' BranchOp.Br' false' (int)instruction.Value));  				break;  			case PE.OpCode.Brtrue_s:  			// aka brinst.s  			case PE.OpCode.Brtrue:  				// aka brinst  				instructions.Add (new BranchInstruction (offset' BranchOp.Brtrue' false' (int)instruction.Value));  				break;  			case PE.OpCode.Brfalse_s:  			// aka brzero.s' brnull.s  			case PE.OpCode.Brfalse:  				// aka brzero' brnull  				instructions.Add (new BranchInstruction (offset' BranchOp.Brfalse' false' (int)instruction.Value));  				break;  			case PE.OpCode.Beq:  			case PE.OpCode.Beq_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.Breq' false' (int)instruction.Value));  				break;  			case PE.OpCode.Bne_un:  			case PE.OpCode.Bne_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.Brne' false' (int)instruction.Value));  				break;  			case PE.OpCode.Leave:  			case PE.OpCode.Leave_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.Leave' false' (int)instruction.Value));  				break;  			case PE.OpCode.Blt:  			case PE.OpCode.Blt_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' false' (int)instruction.Value));  				break;  			case PE.OpCode.Blt_un:  			case PE.OpCode.Blt_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' true' (int)instruction.Value));  				break;  			case PE.OpCode.Ble:  			case PE.OpCode.Ble_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' false' (int)instruction.Value));  				break;  			case PE.OpCode.Ble_un:  			case PE.OpCode.Ble_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' true' (int)instruction.Value));  				break;  			case PE.OpCode.Bgt:  			case PE.OpCode.Bgt_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' false' (int)instruction.Value));  				break;  			case PE.OpCode.Bgt_un:  			case PE.OpCode.Bgt_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' true' (int)instruction.Value));  				break;  			case PE.OpCode.Bge:  			case PE.OpCode.Bge_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' false' (int)instruction.Value));  				break;  			case PE.OpCode.Bge_un:  			case PE.OpCode.Bge_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' true' (int)instruction.Value));  				break;  			case PE.OpCode.Switch:  				instructions.Add (new SwitchInstruction (offset' (Seq<int>)instruction.Value));  				break;  			case PE.OpCode.Ceq:  				instructions.Add (new CompareInstruction (offset' CompareOp.Ceq' false));  				break;  			case PE.OpCode.Clt:  				instructions.Add (new CompareInstruction (offset' CompareOp.Clt' false));  				break;  			case PE.OpCode.Clt_un:  				instructions.Add (new CompareInstruction (offset' CompareOp.Clt' true));  				break;  			case PE.OpCode.Cgt:  				instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' false));  				break;  			case PE.OpCode.Cgt_un:  				instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' true));  				break;  			case PE.OpCode.Ldarg_0:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));  				break;  			case PE.OpCode.Ldarg_1:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));  				break;  			case PE.OpCode.Ldarg_2:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));  				break;  			case PE.OpCode.Ldarg_3:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));  				break;  			case PE.OpCode.Ldarg:  			case PE.OpCode.Ldarg_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));  				break;  			case PE.OpCode.Ldarga:  			case PE.OpCode.Ldarga_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));  				break;  			case PE.OpCode.Starg:  			case PE.OpCode.Starg_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));  				break;  			case PE.OpCode.Ldloc_0:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 0));  				break;  			case PE.OpCode.Ldloc_1:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 1));  				break;  			case PE.OpCode.Ldloc_2:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 2));  				break;  			case PE.OpCode.Ldloc_3:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 3));  				break;  			case PE.OpCode.Ldloc:  			case PE.OpCode.Ldloc_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));  				break;  			case PE.OpCode.Ldloca:  			case PE.OpCode.Ldloca_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));  				break;  			case PE.OpCode.Stloc_0:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 0));  				break;  			case PE.OpCode.Stloc_1:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 1));  				break;  			case PE.OpCode.Stloc_2:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 2));  				break;  			case PE.OpCode.Stloc_3:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 3));  				break;  			case PE.OpCode.Stloc:  			case PE.OpCode.Stloc_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));  				break;  			case PE.OpCode.Ldfld:  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));  				break;  			case PE.OpCode.Ldsfld:  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));  				break;  			case PE.OpCode.Ldflda:  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));  				break;  			case PE.OpCode.Ldsflda:  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));  				break;  			case PE.OpCode.Stfld:  				instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));  				break;  			case PE.OpCode.Stsfld:  				instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));  				break;  			case PE.OpCode.Ldtoken: {  				if (instruction.Value is FieldRef)  					instructions.Add (new FieldInstruction (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));  				else if (instruction.Value is MethodRef)  					instructions.Add (new MethodInstruction (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));  				else if (instruction.Value is TypeRef)  					// NOTE: May be a higher-kinded type  					instructions.Add (new TypeInstruction (offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));  				else  					throw new InvalidOperationException ("unexpected ldtoken instruction value");  				break;  			}  			case PE.OpCode.Constrained: {  				var constrained = (TypeRef)instruction.Value;  				if (i >= ctxt.Instructions.Length)  					throw new InvalidOperationException ("invalid instructions");  				instruction = ctxt.Instructions [i++];  				if (instruction.OpCode != PE.OpCode.Callvirt)  					throw new InvalidOperationException ("invalid instruction");  				instructions.Add (new MethodInstruction (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));  				break;  			}  			case PE.OpCode.Call:  				instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Callvirt:  				instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Ldftn:  				instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Ldvirtftn:  				instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Newobj:  				instructions.Add (new MethodInstruction (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Ldind_i1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int8Ref));  				break;  			case PE.OpCode.Ldind_u1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt8Ref));  				break;  			case PE.OpCode.Ldind_i2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int16Ref));  				break;  			case PE.OpCode.Ldind_u2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt16Ref));  				break;  			case PE.OpCode.Ldind_i4:  			case PE.OpCode.Ldind_u4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int32Ref));  				break;  			case PE.OpCode.Ldind_i8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int64Ref));  				break;  			case PE.OpCode.Ldind_i:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.IntNativeRef));  				break;  			case PE.OpCode.Ldind_r4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.SingleRef));  				break;  			case PE.OpCode.Ldind_r8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.DoubleRef));  				break;  			case PE.OpCode.Ldobj:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Stind_i1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int8Ref));  				break;  			case PE.OpCode.Stind_i2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int16Ref));  				break;  			case PE.OpCode.Stind_i4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int32Ref));  				break;  			case PE.OpCode.Stind_i8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int64Ref));  				break;  			case PE.OpCode.Stind_i:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.IntNativeRef));  				break;  			case PE.OpCode.Stind_r4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.SingleRef));  				break;  			case PE.OpCode.Stind_r8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.DoubleRef));  				break;  			case PE.OpCode.Stobj:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Cpobj:  				instructions.Add (new TypeInstruction (offset' TypeOp.Cpobj' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Newarr:  				instructions.Add (new TypeInstruction (offset' TypeOp.Newarr' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Initobj:  				instructions.Add (new TypeInstruction (offset' TypeOp.Initobj' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Castclass:  				instructions.Add (new TypeInstruction (offset' TypeOp.Castclass' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Isinst:  				instructions.Add (new TypeInstruction (offset' TypeOp.Isinst' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Box:  				instructions.Add (new TypeInstruction (offset' TypeOp.Box' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Unbox:  				instructions.Add (new TypeInstruction (offset' TypeOp.Unbox' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Unbox_any:  				instructions.Add (new TypeInstruction (offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Ldelem_i1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int8Ref));  				break;  			case PE.OpCode.Ldelem_u1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt8Ref));  				break;  			case PE.OpCode.Ldelem_i2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int16Ref));  				break;  			case PE.OpCode.Ldelem_u2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt16Ref));  				break;  			case PE.OpCode.Ldelem_i4:  			case PE.OpCode.Ldelem_u4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int32Ref));  				break;  			case PE.OpCode.Ldelem_i:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.IntNativeRef));  				break;  			case PE.OpCode.Ldelem_i8:  				// aka ldelem.u8  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int64Ref));  				break;  			case PE.OpCode.Ldelem_r4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.SingleRef));  				break;  			case PE.OpCode.Ldelem_r8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.DoubleRef));  				break;  			case PE.OpCode.Ldelem:  				// aka ldelem.any  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Stelem_i1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int8Ref));  				break;  			case PE.OpCode.Stelem_i2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int16Ref));  				break;  			case PE.OpCode.Stelem_i4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int32Ref));  				break;  			case PE.OpCode.Stelem_i8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int64Ref));  				break;  			case PE.OpCode.Stelem_i:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.IntNativeRef));  				break;  			case PE.OpCode.Stelem_r4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.SingleRef));  				break;  			case PE.OpCode.Stelem_r8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.DoubleRef));  				break;  			case PE.OpCode.Stelem:  				// aka stelem.any  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Readonly:  				if (i >= ctxt.Instructions.Length)  					throw new InvalidOperationException ("invalid instruction");  				instruction = ctxt.Instructions [i++];  				if (instruction.OpCode != PE.OpCode.Ldelema)  					throw new InvalidOperationException ("invalid instruction");  				instructions.Add (new LdElemAddrInstruction (offset' true' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Ldelema:  				instructions.Add (new LdElemAddrInstruction (offset' false' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Ldc_i4_0:  				instructions.Add (new LdInt32Instruction (offset' 0));  				break;  			case PE.OpCode.Ldc_i4_1:  				instructions.Add (new LdInt32Instruction (offset' 1));  				break;  			case PE.OpCode.Ldc_i4_2:  				instructions.Add (new LdInt32Instruction (offset' 2));  				break;  			case PE.OpCode.Ldc_i4_3:  				instructions.Add (new LdInt32Instruction (offset' 3));  				break;  			case PE.OpCode.Ldc_i4_4:  				instructions.Add (new LdInt32Instruction (offset' 4));  				break;  			case PE.OpCode.Ldc_i4_5:  				instructions.Add (new LdInt32Instruction (offset' 5));  				break;  			case PE.OpCode.Ldc_i4_6:  				instructions.Add (new LdInt32Instruction (offset' 6));  				break;  			case PE.OpCode.Ldc_i4_7:  				instructions.Add (new LdInt32Instruction (offset' 7));  				break;  			case PE.OpCode.Ldc_i4_8:  				instructions.Add (new LdInt32Instruction (offset' 8));  				break;  			case PE.OpCode.Ldc_i4_m1:  				instructions.Add (new LdInt32Instruction (offset' -1));  				break;  			case PE.OpCode.Ldc_i4:  			case PE.OpCode.Ldc_i4_s:  				instructions.Add (new LdInt32Instruction (offset' (int)instruction.Value));  				break;  			case PE.OpCode.Ldc_i8:  				instructions.Add (new LdInt64Instruction (offset' (long)instruction.Value));  				break;  			case PE.OpCode.Ldc_r4:  				instructions.Add (new LdSingleInstruction (offset' (float)instruction.Value));  				break;  			case PE.OpCode.Ldc_r8:  				instructions.Add (new LdDoubleInstruction (offset' (double)instruction.Value));  				break;  			case PE.OpCode.Ldstr:  				instructions.Add (new LdStringInstruction (offset' (string)instruction.Value));  				break;  			case PE.OpCode.Add:  				instructions.Add (new ArithInstruction (offset' ArithOp.Add' false' false));  				break;  			case PE.OpCode.Add_ovf:  				instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' false));  				break;  			case PE.OpCode.Add_ovf_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' true));  				break;  			case PE.OpCode.Sub:  				instructions.Add (new ArithInstruction (offset' ArithOp.Sub' false' false));  				break;  			case PE.OpCode.Sub_ovf:  				instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' false));  				break;  			case PE.OpCode.Sub_ovf_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' true));  				break;  			case PE.OpCode.Mul:  				instructions.Add (new ArithInstruction (offset' ArithOp.Mul' false' false));  				break;  			case PE.OpCode.Mul_ovf:  				instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' false));  				break;  			case PE.OpCode.Mul_ovf_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' true));  				break;  			case PE.OpCode.Div:  				instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' false));  				break;  			case PE.OpCode.Div_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' true));  				break;  			case PE.OpCode.Rem:  				instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' false));  				break;  			case PE.OpCode.Rem_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' true));  				break;  			case PE.OpCode.Neg:  				instructions.Add (new ArithInstruction (offset' ArithOp.Neg' false' false));  				break;  			case PE.OpCode.And:  				instructions.Add (new ArithInstruction (offset' ArithOp.BitAnd' false' false));  				break;  			case PE.OpCode.Or:  				instructions.Add (new ArithInstruction (offset' ArithOp.BitOr' false' false));  				break;  			case PE.OpCode.Xor:  				instructions.Add (new ArithInstruction (offset' ArithOp.BitXor' false' false));  				break;  			case PE.OpCode.Not:  				instructions.Add (new ArithInstruction (offset' ArithOp.BitNot' false' false));  				break;  			case PE.OpCode.Shl:  				instructions.Add (new ArithInstruction (offset' ArithOp.Shl' false' false));  				break;  			case PE.OpCode.Shr:  				instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' false));  				break;  			case PE.OpCode.Shr_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' true));  				break;  			case PE.OpCode.Conv_i1:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' false' false));  				break;  			case PE.OpCode.Conv_u1:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' false' false));  				break;  			case PE.OpCode.Conv_i2:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' false' false));  				break;  			case PE.OpCode.Conv_u2:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' false' false));  				break;  			case PE.OpCode.Conv_i4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' false' false));  				break;  			case PE.OpCode.Conv_u4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' false' false));  				break;  			case PE.OpCode.Conv_i8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' false' false));  				break;  			case PE.OpCode.Conv_u8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' false' false));  				break;  			case PE.OpCode.Conv_i:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' false' false));  				break;  			case PE.OpCode.Conv_u:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' false' false));  				break;  			case PE.OpCode.Conv_r4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Single' false' false));  				break;  			case PE.OpCode.Conv_r8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' false));  				break;  			case PE.OpCode.Conv_r_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' true));  				break;  			case PE.OpCode.Conv_ovf_i1:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' false));  				break;  			case PE.OpCode.Conv_ovf_u1:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' false));  				break;  			case PE.OpCode.Conv_ovf_i2:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' false));  				break;  			case PE.OpCode.Conv_ovf_u2:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' false));  				break;  			case PE.OpCode.Conv_ovf_i4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' false));  				break;  			case PE.OpCode.Conv_ovf_u4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' false));  				break;  			case PE.OpCode.Conv_ovf_i8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' false));  				break;  			case PE.OpCode.Conv_ovf_u8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' false));  				break;  			case PE.OpCode.Conv_ovf_i:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' false));  				break;  			case PE.OpCode.Conv_ovf_u:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' false));  				break;  			case PE.OpCode.Conv_ovf_i1_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' true));  				break;  			case PE.OpCode.Conv_ovf_u1_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' true));  				break;  			case PE.OpCode.Conv_ovf_i2_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' true));  				break;  			case PE.OpCode.Conv_ovf_u2_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' true));  				break;  			case PE.OpCode.Conv_ovf_i4_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' true));  				break;  			case PE.OpCode.Conv_ovf_u4_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' true));  				break;  			case PE.OpCode.Conv_ovf_i8_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' true));  				break;  			case PE.OpCode.Conv_ovf_u8_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' true));  				break;  			case PE.OpCode.Conv_ovf_i_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' true));  				break;  			case PE.OpCode.Conv_ovf_u_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' true));  				break;  			default:  				throw new InvalidOperationException ("invalid instruction");  			}  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: while (!ctxt.AtEnd (i)) {  	var j = i > ctxt.Start ? ctxt.JumpOverHandlers (i) : i;  	if (j > i)  		i = j;  	else {  		var ehcs = ctxt.OutermostTryBlocks (i);  		if (ehcs != null) {  			// A try instruction begins here with given handlers  			var offset = ctxt.Instructions [i].Offset;  			var tryCtxt = new TryTranslationContext (ctxt' i' ehcs);  			var tryBlock = InstructionsFromContext (tryCtxt);  			var handlers = new Seq<TryInstructionHandler> ();  			foreach (var ehc in ehcs) {  				var handlerCtxt = new HandlerTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.HandlerOffset]' ehc);  				var handlerBlock = InstructionsFromContext (handlerCtxt);  				switch (ehc.Flags) {  				case PE.CorILExceptionClause.Exception:  					handlers.Add (new CatchTryInstructionHandler ((TypeRef)ehc.Class' handlerBlock));  					break;  				case PE.CorILExceptionClause.Filter: {  					var filterCtxt = new FilterTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.FilterOffset]' ehc);  					var filterBlock = InstructionsFromContext (filterCtxt);  					handlers.Add (new FilterTryInstructionHandler (filterBlock' handlerBlock));  					break;  				}  				case PE.CorILExceptionClause.Finally:  					handlers.Add (new FinallyTryInstructionHandler (handlerBlock));  					break;  				case PE.CorILExceptionClause.Fault:  					handlers.Add (new FaultTryInstructionHandler (handlerBlock));  					break;  				default:  					throw new ArgumentOutOfRangeException ();  				}  			}  			instructions.Add (new TryInstruction (offset' tryBlock' handlers));  			// Jump over try block  			var nextOffset = ehcs [0].TryOffset + ehcs [0].TryLength;  			if (!ctxt.OffsetToIndex.TryGetValue (nextOffset' out i))  				i = ctxt.Instructions.Length;  		}  		else {  			var instruction = ctxt.Instructions [i++];  			var offset = instruction.Offset;  			while (instruction.OpCode == PE.OpCode.Unaligned || instruction.OpCode == PE.OpCode.Volatile || instruction.OpCode == PE.OpCode.Tailcall) {  				// Skip over any ignored prefixes' but remember instruction begins at original offset  				// NOTE: What ever happened to the "no." prefix mentioned in the spec?  				if (i >= ctxt.Instructions.Length)  					throw new InvalidOperationException ("invalid instructions");  				instruction = ctxt.Instructions [i++];  			}  			switch (instruction.OpCode) {  			case PE.OpCode.Cpblk:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Cpblk));  				break;  			case PE.OpCode.Initblk:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Initblk));  				break;  			case PE.OpCode.Arglist:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Arglist));  				break;  			case PE.OpCode.Localloc:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Localloc));  				break;  			case PE.OpCode.Jmp:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Jmp));  				break;  			case PE.OpCode.Calli:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Calli));  				break;  			case PE.OpCode.Sizeof:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Sizeof));  				break;  			case PE.OpCode.Mkrefany:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Mkrefany));  				break;  			case PE.OpCode.Refanytype:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanytype));  				break;  			case PE.OpCode.Refanyval:  				instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanyval));  				break;  			case PE.OpCode.Nop:  				instructions.Add (new MiscInstruction (offset' MiscOp.Nop));  				break;  			case PE.OpCode.Break:  				instructions.Add (new MiscInstruction (offset' MiscOp.Break));  				break;  			case PE.OpCode.Dup:  				instructions.Add (new MiscInstruction (offset' MiscOp.Dup));  				break;  			case PE.OpCode.Pop:  				instructions.Add (new MiscInstruction (offset' MiscOp.Pop));  				break;  			case PE.OpCode.Ldnull:  				instructions.Add (new MiscInstruction (offset' MiscOp.Ldnull));  				break;  			case PE.OpCode.Ckfinite:  				instructions.Add (new MiscInstruction (offset' MiscOp.Ckfinite));  				break;  			case PE.OpCode.Throw:  				instructions.Add (new MiscInstruction (offset' MiscOp.Throw));  				break;  			case PE.OpCode.Rethrow:  				instructions.Add (new MiscInstruction (offset' MiscOp.Rethrow));  				break;  			case PE.OpCode.Ldind_ref:  				instructions.Add (new MiscInstruction (offset' MiscOp.LdindRef));  				break;  			case PE.OpCode.Stind_ref:  				instructions.Add (new MiscInstruction (offset' MiscOp.StindRef));  				break;  			case PE.OpCode.Ldelem_ref:  				instructions.Add (new MiscInstruction (offset' MiscOp.LdelemRef));  				break;  			case PE.OpCode.Stelem_ref:  				instructions.Add (new MiscInstruction (offset' MiscOp.StelemRef));  				break;  			case PE.OpCode.Ldlen:  				instructions.Add (new MiscInstruction (offset' MiscOp.Ldlen));  				break;  			case PE.OpCode.Ret:  				if (ctxt.ResultType == null)  					instructions.Add (new MiscInstruction (offset' MiscOp.Ret));  				else  					instructions.Add (new MiscInstruction (offset' MiscOp.RetVal));  				break;  			case PE.OpCode.Endfilter:  				instructions.Add (new MiscInstruction (offset' MiscOp.Endfilter));  				break;  			case PE.OpCode.Endfinally:  				// aka EndFault  				instructions.Add (new MiscInstruction (offset' MiscOp.Endfinally));  				break;  			case PE.OpCode.Br_s:  			case PE.OpCode.Br:  				instructions.Add (new BranchInstruction (offset' BranchOp.Br' false' (int)instruction.Value));  				break;  			case PE.OpCode.Brtrue_s:  			// aka brinst.s  			case PE.OpCode.Brtrue:  				// aka brinst  				instructions.Add (new BranchInstruction (offset' BranchOp.Brtrue' false' (int)instruction.Value));  				break;  			case PE.OpCode.Brfalse_s:  			// aka brzero.s' brnull.s  			case PE.OpCode.Brfalse:  				// aka brzero' brnull  				instructions.Add (new BranchInstruction (offset' BranchOp.Brfalse' false' (int)instruction.Value));  				break;  			case PE.OpCode.Beq:  			case PE.OpCode.Beq_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.Breq' false' (int)instruction.Value));  				break;  			case PE.OpCode.Bne_un:  			case PE.OpCode.Bne_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.Brne' false' (int)instruction.Value));  				break;  			case PE.OpCode.Leave:  			case PE.OpCode.Leave_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.Leave' false' (int)instruction.Value));  				break;  			case PE.OpCode.Blt:  			case PE.OpCode.Blt_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' false' (int)instruction.Value));  				break;  			case PE.OpCode.Blt_un:  			case PE.OpCode.Blt_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' true' (int)instruction.Value));  				break;  			case PE.OpCode.Ble:  			case PE.OpCode.Ble_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' false' (int)instruction.Value));  				break;  			case PE.OpCode.Ble_un:  			case PE.OpCode.Ble_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' true' (int)instruction.Value));  				break;  			case PE.OpCode.Bgt:  			case PE.OpCode.Bgt_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' false' (int)instruction.Value));  				break;  			case PE.OpCode.Bgt_un:  			case PE.OpCode.Bgt_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' true' (int)instruction.Value));  				break;  			case PE.OpCode.Bge:  			case PE.OpCode.Bge_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' false' (int)instruction.Value));  				break;  			case PE.OpCode.Bge_un:  			case PE.OpCode.Bge_un_s:  				instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' true' (int)instruction.Value));  				break;  			case PE.OpCode.Switch:  				instructions.Add (new SwitchInstruction (offset' (Seq<int>)instruction.Value));  				break;  			case PE.OpCode.Ceq:  				instructions.Add (new CompareInstruction (offset' CompareOp.Ceq' false));  				break;  			case PE.OpCode.Clt:  				instructions.Add (new CompareInstruction (offset' CompareOp.Clt' false));  				break;  			case PE.OpCode.Clt_un:  				instructions.Add (new CompareInstruction (offset' CompareOp.Clt' true));  				break;  			case PE.OpCode.Cgt:  				instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' false));  				break;  			case PE.OpCode.Cgt_un:  				instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' true));  				break;  			case PE.OpCode.Ldarg_0:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));  				break;  			case PE.OpCode.Ldarg_1:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));  				break;  			case PE.OpCode.Ldarg_2:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));  				break;  			case PE.OpCode.Ldarg_3:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));  				break;  			case PE.OpCode.Ldarg:  			case PE.OpCode.Ldarg_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));  				break;  			case PE.OpCode.Ldarga:  			case PE.OpCode.Ldarga_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));  				break;  			case PE.OpCode.Starg:  			case PE.OpCode.Starg_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));  				break;  			case PE.OpCode.Ldloc_0:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 0));  				break;  			case PE.OpCode.Ldloc_1:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 1));  				break;  			case PE.OpCode.Ldloc_2:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 2));  				break;  			case PE.OpCode.Ldloc_3:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 3));  				break;  			case PE.OpCode.Ldloc:  			case PE.OpCode.Ldloc_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));  				break;  			case PE.OpCode.Ldloca:  			case PE.OpCode.Ldloca_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));  				break;  			case PE.OpCode.Stloc_0:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 0));  				break;  			case PE.OpCode.Stloc_1:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 1));  				break;  			case PE.OpCode.Stloc_2:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 2));  				break;  			case PE.OpCode.Stloc_3:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 3));  				break;  			case PE.OpCode.Stloc:  			case PE.OpCode.Stloc_s:  				instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));  				break;  			case PE.OpCode.Ldfld:  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));  				break;  			case PE.OpCode.Ldsfld:  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));  				break;  			case PE.OpCode.Ldflda:  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));  				break;  			case PE.OpCode.Ldsflda:  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));  				break;  			case PE.OpCode.Stfld:  				instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));  				break;  			case PE.OpCode.Stsfld:  				instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));  				break;  			case PE.OpCode.Ldtoken: {  				if (instruction.Value is FieldRef)  					instructions.Add (new FieldInstruction (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));  				else if (instruction.Value is MethodRef)  					instructions.Add (new MethodInstruction (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));  				else if (instruction.Value is TypeRef)  					// NOTE: May be a higher-kinded type  					instructions.Add (new TypeInstruction (offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));  				else  					throw new InvalidOperationException ("unexpected ldtoken instruction value");  				break;  			}  			case PE.OpCode.Constrained: {  				var constrained = (TypeRef)instruction.Value;  				if (i >= ctxt.Instructions.Length)  					throw new InvalidOperationException ("invalid instructions");  				instruction = ctxt.Instructions [i++];  				if (instruction.OpCode != PE.OpCode.Callvirt)  					throw new InvalidOperationException ("invalid instruction");  				instructions.Add (new MethodInstruction (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));  				break;  			}  			case PE.OpCode.Call:  				instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Callvirt:  				instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Ldftn:  				instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Ldvirtftn:  				instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Newobj:  				instructions.Add (new MethodInstruction (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));  				break;  			case PE.OpCode.Ldind_i1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int8Ref));  				break;  			case PE.OpCode.Ldind_u1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt8Ref));  				break;  			case PE.OpCode.Ldind_i2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int16Ref));  				break;  			case PE.OpCode.Ldind_u2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt16Ref));  				break;  			case PE.OpCode.Ldind_i4:  			case PE.OpCode.Ldind_u4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int32Ref));  				break;  			case PE.OpCode.Ldind_i8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int64Ref));  				break;  			case PE.OpCode.Ldind_i:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.IntNativeRef));  				break;  			case PE.OpCode.Ldind_r4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.SingleRef));  				break;  			case PE.OpCode.Ldind_r8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.DoubleRef));  				break;  			case PE.OpCode.Ldobj:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Stind_i1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int8Ref));  				break;  			case PE.OpCode.Stind_i2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int16Ref));  				break;  			case PE.OpCode.Stind_i4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int32Ref));  				break;  			case PE.OpCode.Stind_i8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int64Ref));  				break;  			case PE.OpCode.Stind_i:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.IntNativeRef));  				break;  			case PE.OpCode.Stind_r4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.SingleRef));  				break;  			case PE.OpCode.Stind_r8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.DoubleRef));  				break;  			case PE.OpCode.Stobj:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Cpobj:  				instructions.Add (new TypeInstruction (offset' TypeOp.Cpobj' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Newarr:  				instructions.Add (new TypeInstruction (offset' TypeOp.Newarr' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Initobj:  				instructions.Add (new TypeInstruction (offset' TypeOp.Initobj' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Castclass:  				instructions.Add (new TypeInstruction (offset' TypeOp.Castclass' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Isinst:  				instructions.Add (new TypeInstruction (offset' TypeOp.Isinst' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Box:  				instructions.Add (new TypeInstruction (offset' TypeOp.Box' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Unbox:  				instructions.Add (new TypeInstruction (offset' TypeOp.Unbox' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Unbox_any:  				instructions.Add (new TypeInstruction (offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Ldelem_i1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int8Ref));  				break;  			case PE.OpCode.Ldelem_u1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt8Ref));  				break;  			case PE.OpCode.Ldelem_i2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int16Ref));  				break;  			case PE.OpCode.Ldelem_u2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt16Ref));  				break;  			case PE.OpCode.Ldelem_i4:  			case PE.OpCode.Ldelem_u4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int32Ref));  				break;  			case PE.OpCode.Ldelem_i:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.IntNativeRef));  				break;  			case PE.OpCode.Ldelem_i8:  				// aka ldelem.u8  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int64Ref));  				break;  			case PE.OpCode.Ldelem_r4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.SingleRef));  				break;  			case PE.OpCode.Ldelem_r8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.DoubleRef));  				break;  			case PE.OpCode.Ldelem:  				// aka ldelem.any  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Stelem_i1:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int8Ref));  				break;  			case PE.OpCode.Stelem_i2:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int16Ref));  				break;  			case PE.OpCode.Stelem_i4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int32Ref));  				break;  			case PE.OpCode.Stelem_i8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int64Ref));  				break;  			case PE.OpCode.Stelem_i:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.IntNativeRef));  				break;  			case PE.OpCode.Stelem_r4:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.SingleRef));  				break;  			case PE.OpCode.Stelem_r8:  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.DoubleRef));  				break;  			case PE.OpCode.Stelem:  				// aka stelem.any  				instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Readonly:  				if (i >= ctxt.Instructions.Length)  					throw new InvalidOperationException ("invalid instruction");  				instruction = ctxt.Instructions [i++];  				if (instruction.OpCode != PE.OpCode.Ldelema)  					throw new InvalidOperationException ("invalid instruction");  				instructions.Add (new LdElemAddrInstruction (offset' true' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Ldelema:  				instructions.Add (new LdElemAddrInstruction (offset' false' (TypeRef)instruction.Value));  				break;  			case PE.OpCode.Ldc_i4_0:  				instructions.Add (new LdInt32Instruction (offset' 0));  				break;  			case PE.OpCode.Ldc_i4_1:  				instructions.Add (new LdInt32Instruction (offset' 1));  				break;  			case PE.OpCode.Ldc_i4_2:  				instructions.Add (new LdInt32Instruction (offset' 2));  				break;  			case PE.OpCode.Ldc_i4_3:  				instructions.Add (new LdInt32Instruction (offset' 3));  				break;  			case PE.OpCode.Ldc_i4_4:  				instructions.Add (new LdInt32Instruction (offset' 4));  				break;  			case PE.OpCode.Ldc_i4_5:  				instructions.Add (new LdInt32Instruction (offset' 5));  				break;  			case PE.OpCode.Ldc_i4_6:  				instructions.Add (new LdInt32Instruction (offset' 6));  				break;  			case PE.OpCode.Ldc_i4_7:  				instructions.Add (new LdInt32Instruction (offset' 7));  				break;  			case PE.OpCode.Ldc_i4_8:  				instructions.Add (new LdInt32Instruction (offset' 8));  				break;  			case PE.OpCode.Ldc_i4_m1:  				instructions.Add (new LdInt32Instruction (offset' -1));  				break;  			case PE.OpCode.Ldc_i4:  			case PE.OpCode.Ldc_i4_s:  				instructions.Add (new LdInt32Instruction (offset' (int)instruction.Value));  				break;  			case PE.OpCode.Ldc_i8:  				instructions.Add (new LdInt64Instruction (offset' (long)instruction.Value));  				break;  			case PE.OpCode.Ldc_r4:  				instructions.Add (new LdSingleInstruction (offset' (float)instruction.Value));  				break;  			case PE.OpCode.Ldc_r8:  				instructions.Add (new LdDoubleInstruction (offset' (double)instruction.Value));  				break;  			case PE.OpCode.Ldstr:  				instructions.Add (new LdStringInstruction (offset' (string)instruction.Value));  				break;  			case PE.OpCode.Add:  				instructions.Add (new ArithInstruction (offset' ArithOp.Add' false' false));  				break;  			case PE.OpCode.Add_ovf:  				instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' false));  				break;  			case PE.OpCode.Add_ovf_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' true));  				break;  			case PE.OpCode.Sub:  				instructions.Add (new ArithInstruction (offset' ArithOp.Sub' false' false));  				break;  			case PE.OpCode.Sub_ovf:  				instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' false));  				break;  			case PE.OpCode.Sub_ovf_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' true));  				break;  			case PE.OpCode.Mul:  				instructions.Add (new ArithInstruction (offset' ArithOp.Mul' false' false));  				break;  			case PE.OpCode.Mul_ovf:  				instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' false));  				break;  			case PE.OpCode.Mul_ovf_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' true));  				break;  			case PE.OpCode.Div:  				instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' false));  				break;  			case PE.OpCode.Div_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' true));  				break;  			case PE.OpCode.Rem:  				instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' false));  				break;  			case PE.OpCode.Rem_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' true));  				break;  			case PE.OpCode.Neg:  				instructions.Add (new ArithInstruction (offset' ArithOp.Neg' false' false));  				break;  			case PE.OpCode.And:  				instructions.Add (new ArithInstruction (offset' ArithOp.BitAnd' false' false));  				break;  			case PE.OpCode.Or:  				instructions.Add (new ArithInstruction (offset' ArithOp.BitOr' false' false));  				break;  			case PE.OpCode.Xor:  				instructions.Add (new ArithInstruction (offset' ArithOp.BitXor' false' false));  				break;  			case PE.OpCode.Not:  				instructions.Add (new ArithInstruction (offset' ArithOp.BitNot' false' false));  				break;  			case PE.OpCode.Shl:  				instructions.Add (new ArithInstruction (offset' ArithOp.Shl' false' false));  				break;  			case PE.OpCode.Shr:  				instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' false));  				break;  			case PE.OpCode.Shr_un:  				instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' true));  				break;  			case PE.OpCode.Conv_i1:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' false' false));  				break;  			case PE.OpCode.Conv_u1:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' false' false));  				break;  			case PE.OpCode.Conv_i2:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' false' false));  				break;  			case PE.OpCode.Conv_u2:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' false' false));  				break;  			case PE.OpCode.Conv_i4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' false' false));  				break;  			case PE.OpCode.Conv_u4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' false' false));  				break;  			case PE.OpCode.Conv_i8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' false' false));  				break;  			case PE.OpCode.Conv_u8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' false' false));  				break;  			case PE.OpCode.Conv_i:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' false' false));  				break;  			case PE.OpCode.Conv_u:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' false' false));  				break;  			case PE.OpCode.Conv_r4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Single' false' false));  				break;  			case PE.OpCode.Conv_r8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' false));  				break;  			case PE.OpCode.Conv_r_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' true));  				break;  			case PE.OpCode.Conv_ovf_i1:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' false));  				break;  			case PE.OpCode.Conv_ovf_u1:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' false));  				break;  			case PE.OpCode.Conv_ovf_i2:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' false));  				break;  			case PE.OpCode.Conv_ovf_u2:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' false));  				break;  			case PE.OpCode.Conv_ovf_i4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' false));  				break;  			case PE.OpCode.Conv_ovf_u4:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' false));  				break;  			case PE.OpCode.Conv_ovf_i8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' false));  				break;  			case PE.OpCode.Conv_ovf_u8:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' false));  				break;  			case PE.OpCode.Conv_ovf_i:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' false));  				break;  			case PE.OpCode.Conv_ovf_u:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' false));  				break;  			case PE.OpCode.Conv_ovf_i1_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' true));  				break;  			case PE.OpCode.Conv_ovf_u1_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' true));  				break;  			case PE.OpCode.Conv_ovf_i2_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' true));  				break;  			case PE.OpCode.Conv_ovf_u2_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' true));  				break;  			case PE.OpCode.Conv_ovf_i4_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' true));  				break;  			case PE.OpCode.Conv_ovf_u4_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' true));  				break;  			case PE.OpCode.Conv_ovf_i8_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' true));  				break;  			case PE.OpCode.Conv_ovf_u8_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' true));  				break;  			case PE.OpCode.Conv_ovf_i_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' true));  				break;  			case PE.OpCode.Conv_ovf_u_un:  				instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' true));  				break;  			default:  				throw new InvalidOperationException ("invalid instruction");  			}  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: if (j > i)  	i = j;  else {  	var ehcs = ctxt.OutermostTryBlocks (i);  	if (ehcs != null) {  		// A try instruction begins here with given handlers  		var offset = ctxt.Instructions [i].Offset;  		var tryCtxt = new TryTranslationContext (ctxt' i' ehcs);  		var tryBlock = InstructionsFromContext (tryCtxt);  		var handlers = new Seq<TryInstructionHandler> ();  		foreach (var ehc in ehcs) {  			var handlerCtxt = new HandlerTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.HandlerOffset]' ehc);  			var handlerBlock = InstructionsFromContext (handlerCtxt);  			switch (ehc.Flags) {  			case PE.CorILExceptionClause.Exception:  				handlers.Add (new CatchTryInstructionHandler ((TypeRef)ehc.Class' handlerBlock));  				break;  			case PE.CorILExceptionClause.Filter: {  				var filterCtxt = new FilterTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.FilterOffset]' ehc);  				var filterBlock = InstructionsFromContext (filterCtxt);  				handlers.Add (new FilterTryInstructionHandler (filterBlock' handlerBlock));  				break;  			}  			case PE.CorILExceptionClause.Finally:  				handlers.Add (new FinallyTryInstructionHandler (handlerBlock));  				break;  			case PE.CorILExceptionClause.Fault:  				handlers.Add (new FaultTryInstructionHandler (handlerBlock));  				break;  			default:  				throw new ArgumentOutOfRangeException ();  			}  		}  		instructions.Add (new TryInstruction (offset' tryBlock' handlers));  		// Jump over try block  		var nextOffset = ehcs [0].TryOffset + ehcs [0].TryLength;  		if (!ctxt.OffsetToIndex.TryGetValue (nextOffset' out i))  			i = ctxt.Instructions.Length;  	}  	else {  		var instruction = ctxt.Instructions [i++];  		var offset = instruction.Offset;  		while (instruction.OpCode == PE.OpCode.Unaligned || instruction.OpCode == PE.OpCode.Volatile || instruction.OpCode == PE.OpCode.Tailcall) {  			// Skip over any ignored prefixes' but remember instruction begins at original offset  			// NOTE: What ever happened to the "no." prefix mentioned in the spec?  			if (i >= ctxt.Instructions.Length)  				throw new InvalidOperationException ("invalid instructions");  			instruction = ctxt.Instructions [i++];  		}  		switch (instruction.OpCode) {  		case PE.OpCode.Cpblk:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Cpblk));  			break;  		case PE.OpCode.Initblk:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Initblk));  			break;  		case PE.OpCode.Arglist:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Arglist));  			break;  		case PE.OpCode.Localloc:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Localloc));  			break;  		case PE.OpCode.Jmp:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Jmp));  			break;  		case PE.OpCode.Calli:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Calli));  			break;  		case PE.OpCode.Sizeof:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Sizeof));  			break;  		case PE.OpCode.Mkrefany:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Mkrefany));  			break;  		case PE.OpCode.Refanytype:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanytype));  			break;  		case PE.OpCode.Refanyval:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanyval));  			break;  		case PE.OpCode.Nop:  			instructions.Add (new MiscInstruction (offset' MiscOp.Nop));  			break;  		case PE.OpCode.Break:  			instructions.Add (new MiscInstruction (offset' MiscOp.Break));  			break;  		case PE.OpCode.Dup:  			instructions.Add (new MiscInstruction (offset' MiscOp.Dup));  			break;  		case PE.OpCode.Pop:  			instructions.Add (new MiscInstruction (offset' MiscOp.Pop));  			break;  		case PE.OpCode.Ldnull:  			instructions.Add (new MiscInstruction (offset' MiscOp.Ldnull));  			break;  		case PE.OpCode.Ckfinite:  			instructions.Add (new MiscInstruction (offset' MiscOp.Ckfinite));  			break;  		case PE.OpCode.Throw:  			instructions.Add (new MiscInstruction (offset' MiscOp.Throw));  			break;  		case PE.OpCode.Rethrow:  			instructions.Add (new MiscInstruction (offset' MiscOp.Rethrow));  			break;  		case PE.OpCode.Ldind_ref:  			instructions.Add (new MiscInstruction (offset' MiscOp.LdindRef));  			break;  		case PE.OpCode.Stind_ref:  			instructions.Add (new MiscInstruction (offset' MiscOp.StindRef));  			break;  		case PE.OpCode.Ldelem_ref:  			instructions.Add (new MiscInstruction (offset' MiscOp.LdelemRef));  			break;  		case PE.OpCode.Stelem_ref:  			instructions.Add (new MiscInstruction (offset' MiscOp.StelemRef));  			break;  		case PE.OpCode.Ldlen:  			instructions.Add (new MiscInstruction (offset' MiscOp.Ldlen));  			break;  		case PE.OpCode.Ret:  			if (ctxt.ResultType == null)  				instructions.Add (new MiscInstruction (offset' MiscOp.Ret));  			else  				instructions.Add (new MiscInstruction (offset' MiscOp.RetVal));  			break;  		case PE.OpCode.Endfilter:  			instructions.Add (new MiscInstruction (offset' MiscOp.Endfilter));  			break;  		case PE.OpCode.Endfinally:  			// aka EndFault  			instructions.Add (new MiscInstruction (offset' MiscOp.Endfinally));  			break;  		case PE.OpCode.Br_s:  		case PE.OpCode.Br:  			instructions.Add (new BranchInstruction (offset' BranchOp.Br' false' (int)instruction.Value));  			break;  		case PE.OpCode.Brtrue_s:  		// aka brinst.s  		case PE.OpCode.Brtrue:  			// aka brinst  			instructions.Add (new BranchInstruction (offset' BranchOp.Brtrue' false' (int)instruction.Value));  			break;  		case PE.OpCode.Brfalse_s:  		// aka brzero.s' brnull.s  		case PE.OpCode.Brfalse:  			// aka brzero' brnull  			instructions.Add (new BranchInstruction (offset' BranchOp.Brfalse' false' (int)instruction.Value));  			break;  		case PE.OpCode.Beq:  		case PE.OpCode.Beq_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.Breq' false' (int)instruction.Value));  			break;  		case PE.OpCode.Bne_un:  		case PE.OpCode.Bne_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.Brne' false' (int)instruction.Value));  			break;  		case PE.OpCode.Leave:  		case PE.OpCode.Leave_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.Leave' false' (int)instruction.Value));  			break;  		case PE.OpCode.Blt:  		case PE.OpCode.Blt_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' false' (int)instruction.Value));  			break;  		case PE.OpCode.Blt_un:  		case PE.OpCode.Blt_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' true' (int)instruction.Value));  			break;  		case PE.OpCode.Ble:  		case PE.OpCode.Ble_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' false' (int)instruction.Value));  			break;  		case PE.OpCode.Ble_un:  		case PE.OpCode.Ble_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' true' (int)instruction.Value));  			break;  		case PE.OpCode.Bgt:  		case PE.OpCode.Bgt_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' false' (int)instruction.Value));  			break;  		case PE.OpCode.Bgt_un:  		case PE.OpCode.Bgt_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' true' (int)instruction.Value));  			break;  		case PE.OpCode.Bge:  		case PE.OpCode.Bge_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' false' (int)instruction.Value));  			break;  		case PE.OpCode.Bge_un:  		case PE.OpCode.Bge_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' true' (int)instruction.Value));  			break;  		case PE.OpCode.Switch:  			instructions.Add (new SwitchInstruction (offset' (Seq<int>)instruction.Value));  			break;  		case PE.OpCode.Ceq:  			instructions.Add (new CompareInstruction (offset' CompareOp.Ceq' false));  			break;  		case PE.OpCode.Clt:  			instructions.Add (new CompareInstruction (offset' CompareOp.Clt' false));  			break;  		case PE.OpCode.Clt_un:  			instructions.Add (new CompareInstruction (offset' CompareOp.Clt' true));  			break;  		case PE.OpCode.Cgt:  			instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' false));  			break;  		case PE.OpCode.Cgt_un:  			instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' true));  			break;  		case PE.OpCode.Ldarg_0:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));  			break;  		case PE.OpCode.Ldarg_1:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));  			break;  		case PE.OpCode.Ldarg_2:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));  			break;  		case PE.OpCode.Ldarg_3:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));  			break;  		case PE.OpCode.Ldarg:  		case PE.OpCode.Ldarg_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));  			break;  		case PE.OpCode.Ldarga:  		case PE.OpCode.Ldarga_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));  			break;  		case PE.OpCode.Starg:  		case PE.OpCode.Starg_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));  			break;  		case PE.OpCode.Ldloc_0:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 0));  			break;  		case PE.OpCode.Ldloc_1:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 1));  			break;  		case PE.OpCode.Ldloc_2:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 2));  			break;  		case PE.OpCode.Ldloc_3:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 3));  			break;  		case PE.OpCode.Ldloc:  		case PE.OpCode.Ldloc_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));  			break;  		case PE.OpCode.Ldloca:  		case PE.OpCode.Ldloca_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));  			break;  		case PE.OpCode.Stloc_0:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 0));  			break;  		case PE.OpCode.Stloc_1:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 1));  			break;  		case PE.OpCode.Stloc_2:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 2));  			break;  		case PE.OpCode.Stloc_3:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 3));  			break;  		case PE.OpCode.Stloc:  		case PE.OpCode.Stloc_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));  			break;  		case PE.OpCode.Ldfld:  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));  			break;  		case PE.OpCode.Ldsfld:  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));  			break;  		case PE.OpCode.Ldflda:  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));  			break;  		case PE.OpCode.Ldsflda:  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));  			break;  		case PE.OpCode.Stfld:  			instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));  			break;  		case PE.OpCode.Stsfld:  			instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));  			break;  		case PE.OpCode.Ldtoken: {  			if (instruction.Value is FieldRef)  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));  			else if (instruction.Value is MethodRef)  				instructions.Add (new MethodInstruction (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));  			else if (instruction.Value is TypeRef)  				// NOTE: May be a higher-kinded type  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));  			else  				throw new InvalidOperationException ("unexpected ldtoken instruction value");  			break;  		}  		case PE.OpCode.Constrained: {  			var constrained = (TypeRef)instruction.Value;  			if (i >= ctxt.Instructions.Length)  				throw new InvalidOperationException ("invalid instructions");  			instruction = ctxt.Instructions [i++];  			if (instruction.OpCode != PE.OpCode.Callvirt)  				throw new InvalidOperationException ("invalid instruction");  			instructions.Add (new MethodInstruction (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));  			break;  		}  		case PE.OpCode.Call:  			instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Callvirt:  			instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Ldftn:  			instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Ldvirtftn:  			instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Newobj:  			instructions.Add (new MethodInstruction (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Ldind_i1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int8Ref));  			break;  		case PE.OpCode.Ldind_u1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt8Ref));  			break;  		case PE.OpCode.Ldind_i2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int16Ref));  			break;  		case PE.OpCode.Ldind_u2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt16Ref));  			break;  		case PE.OpCode.Ldind_i4:  		case PE.OpCode.Ldind_u4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int32Ref));  			break;  		case PE.OpCode.Ldind_i8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int64Ref));  			break;  		case PE.OpCode.Ldind_i:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.IntNativeRef));  			break;  		case PE.OpCode.Ldind_r4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.SingleRef));  			break;  		case PE.OpCode.Ldind_r8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.DoubleRef));  			break;  		case PE.OpCode.Ldobj:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Stind_i1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int8Ref));  			break;  		case PE.OpCode.Stind_i2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int16Ref));  			break;  		case PE.OpCode.Stind_i4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int32Ref));  			break;  		case PE.OpCode.Stind_i8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int64Ref));  			break;  		case PE.OpCode.Stind_i:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.IntNativeRef));  			break;  		case PE.OpCode.Stind_r4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.SingleRef));  			break;  		case PE.OpCode.Stind_r8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.DoubleRef));  			break;  		case PE.OpCode.Stobj:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Cpobj:  			instructions.Add (new TypeInstruction (offset' TypeOp.Cpobj' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Newarr:  			instructions.Add (new TypeInstruction (offset' TypeOp.Newarr' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Initobj:  			instructions.Add (new TypeInstruction (offset' TypeOp.Initobj' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Castclass:  			instructions.Add (new TypeInstruction (offset' TypeOp.Castclass' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Isinst:  			instructions.Add (new TypeInstruction (offset' TypeOp.Isinst' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Box:  			instructions.Add (new TypeInstruction (offset' TypeOp.Box' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Unbox:  			instructions.Add (new TypeInstruction (offset' TypeOp.Unbox' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Unbox_any:  			instructions.Add (new TypeInstruction (offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Ldelem_i1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int8Ref));  			break;  		case PE.OpCode.Ldelem_u1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt8Ref));  			break;  		case PE.OpCode.Ldelem_i2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int16Ref));  			break;  		case PE.OpCode.Ldelem_u2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt16Ref));  			break;  		case PE.OpCode.Ldelem_i4:  		case PE.OpCode.Ldelem_u4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int32Ref));  			break;  		case PE.OpCode.Ldelem_i:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.IntNativeRef));  			break;  		case PE.OpCode.Ldelem_i8:  			// aka ldelem.u8  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int64Ref));  			break;  		case PE.OpCode.Ldelem_r4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.SingleRef));  			break;  		case PE.OpCode.Ldelem_r8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.DoubleRef));  			break;  		case PE.OpCode.Ldelem:  			// aka ldelem.any  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Stelem_i1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int8Ref));  			break;  		case PE.OpCode.Stelem_i2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int16Ref));  			break;  		case PE.OpCode.Stelem_i4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int32Ref));  			break;  		case PE.OpCode.Stelem_i8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int64Ref));  			break;  		case PE.OpCode.Stelem_i:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.IntNativeRef));  			break;  		case PE.OpCode.Stelem_r4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.SingleRef));  			break;  		case PE.OpCode.Stelem_r8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.DoubleRef));  			break;  		case PE.OpCode.Stelem:  			// aka stelem.any  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Readonly:  			if (i >= ctxt.Instructions.Length)  				throw new InvalidOperationException ("invalid instruction");  			instruction = ctxt.Instructions [i++];  			if (instruction.OpCode != PE.OpCode.Ldelema)  				throw new InvalidOperationException ("invalid instruction");  			instructions.Add (new LdElemAddrInstruction (offset' true' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Ldelema:  			instructions.Add (new LdElemAddrInstruction (offset' false' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Ldc_i4_0:  			instructions.Add (new LdInt32Instruction (offset' 0));  			break;  		case PE.OpCode.Ldc_i4_1:  			instructions.Add (new LdInt32Instruction (offset' 1));  			break;  		case PE.OpCode.Ldc_i4_2:  			instructions.Add (new LdInt32Instruction (offset' 2));  			break;  		case PE.OpCode.Ldc_i4_3:  			instructions.Add (new LdInt32Instruction (offset' 3));  			break;  		case PE.OpCode.Ldc_i4_4:  			instructions.Add (new LdInt32Instruction (offset' 4));  			break;  		case PE.OpCode.Ldc_i4_5:  			instructions.Add (new LdInt32Instruction (offset' 5));  			break;  		case PE.OpCode.Ldc_i4_6:  			instructions.Add (new LdInt32Instruction (offset' 6));  			break;  		case PE.OpCode.Ldc_i4_7:  			instructions.Add (new LdInt32Instruction (offset' 7));  			break;  		case PE.OpCode.Ldc_i4_8:  			instructions.Add (new LdInt32Instruction (offset' 8));  			break;  		case PE.OpCode.Ldc_i4_m1:  			instructions.Add (new LdInt32Instruction (offset' -1));  			break;  		case PE.OpCode.Ldc_i4:  		case PE.OpCode.Ldc_i4_s:  			instructions.Add (new LdInt32Instruction (offset' (int)instruction.Value));  			break;  		case PE.OpCode.Ldc_i8:  			instructions.Add (new LdInt64Instruction (offset' (long)instruction.Value));  			break;  		case PE.OpCode.Ldc_r4:  			instructions.Add (new LdSingleInstruction (offset' (float)instruction.Value));  			break;  		case PE.OpCode.Ldc_r8:  			instructions.Add (new LdDoubleInstruction (offset' (double)instruction.Value));  			break;  		case PE.OpCode.Ldstr:  			instructions.Add (new LdStringInstruction (offset' (string)instruction.Value));  			break;  		case PE.OpCode.Add:  			instructions.Add (new ArithInstruction (offset' ArithOp.Add' false' false));  			break;  		case PE.OpCode.Add_ovf:  			instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' false));  			break;  		case PE.OpCode.Add_ovf_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' true));  			break;  		case PE.OpCode.Sub:  			instructions.Add (new ArithInstruction (offset' ArithOp.Sub' false' false));  			break;  		case PE.OpCode.Sub_ovf:  			instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' false));  			break;  		case PE.OpCode.Sub_ovf_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' true));  			break;  		case PE.OpCode.Mul:  			instructions.Add (new ArithInstruction (offset' ArithOp.Mul' false' false));  			break;  		case PE.OpCode.Mul_ovf:  			instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' false));  			break;  		case PE.OpCode.Mul_ovf_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' true));  			break;  		case PE.OpCode.Div:  			instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' false));  			break;  		case PE.OpCode.Div_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' true));  			break;  		case PE.OpCode.Rem:  			instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' false));  			break;  		case PE.OpCode.Rem_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' true));  			break;  		case PE.OpCode.Neg:  			instructions.Add (new ArithInstruction (offset' ArithOp.Neg' false' false));  			break;  		case PE.OpCode.And:  			instructions.Add (new ArithInstruction (offset' ArithOp.BitAnd' false' false));  			break;  		case PE.OpCode.Or:  			instructions.Add (new ArithInstruction (offset' ArithOp.BitOr' false' false));  			break;  		case PE.OpCode.Xor:  			instructions.Add (new ArithInstruction (offset' ArithOp.BitXor' false' false));  			break;  		case PE.OpCode.Not:  			instructions.Add (new ArithInstruction (offset' ArithOp.BitNot' false' false));  			break;  		case PE.OpCode.Shl:  			instructions.Add (new ArithInstruction (offset' ArithOp.Shl' false' false));  			break;  		case PE.OpCode.Shr:  			instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' false));  			break;  		case PE.OpCode.Shr_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' true));  			break;  		case PE.OpCode.Conv_i1:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' false' false));  			break;  		case PE.OpCode.Conv_u1:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' false' false));  			break;  		case PE.OpCode.Conv_i2:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' false' false));  			break;  		case PE.OpCode.Conv_u2:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' false' false));  			break;  		case PE.OpCode.Conv_i4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' false' false));  			break;  		case PE.OpCode.Conv_u4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' false' false));  			break;  		case PE.OpCode.Conv_i8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' false' false));  			break;  		case PE.OpCode.Conv_u8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' false' false));  			break;  		case PE.OpCode.Conv_i:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' false' false));  			break;  		case PE.OpCode.Conv_u:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' false' false));  			break;  		case PE.OpCode.Conv_r4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Single' false' false));  			break;  		case PE.OpCode.Conv_r8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' false));  			break;  		case PE.OpCode.Conv_r_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' true));  			break;  		case PE.OpCode.Conv_ovf_i1:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' false));  			break;  		case PE.OpCode.Conv_ovf_u1:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' false));  			break;  		case PE.OpCode.Conv_ovf_i2:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' false));  			break;  		case PE.OpCode.Conv_ovf_u2:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' false));  			break;  		case PE.OpCode.Conv_ovf_i4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' false));  			break;  		case PE.OpCode.Conv_ovf_u4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' false));  			break;  		case PE.OpCode.Conv_ovf_i8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' false));  			break;  		case PE.OpCode.Conv_ovf_u8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' false));  			break;  		case PE.OpCode.Conv_ovf_i:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' false));  			break;  		case PE.OpCode.Conv_ovf_u:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' false));  			break;  		case PE.OpCode.Conv_ovf_i1_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' true));  			break;  		case PE.OpCode.Conv_ovf_u1_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' true));  			break;  		case PE.OpCode.Conv_ovf_i2_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' true));  			break;  		case PE.OpCode.Conv_ovf_u2_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' true));  			break;  		case PE.OpCode.Conv_ovf_i4_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' true));  			break;  		case PE.OpCode.Conv_ovf_u4_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' true));  			break;  		case PE.OpCode.Conv_ovf_i8_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' true));  			break;  		case PE.OpCode.Conv_ovf_u8_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' true));  			break;  		case PE.OpCode.Conv_ovf_i_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' true));  			break;  		case PE.OpCode.Conv_ovf_u_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' true));  			break;  		default:  			throw new InvalidOperationException ("invalid instruction");  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: if (j > i)  	i = j;  else {  	var ehcs = ctxt.OutermostTryBlocks (i);  	if (ehcs != null) {  		// A try instruction begins here with given handlers  		var offset = ctxt.Instructions [i].Offset;  		var tryCtxt = new TryTranslationContext (ctxt' i' ehcs);  		var tryBlock = InstructionsFromContext (tryCtxt);  		var handlers = new Seq<TryInstructionHandler> ();  		foreach (var ehc in ehcs) {  			var handlerCtxt = new HandlerTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.HandlerOffset]' ehc);  			var handlerBlock = InstructionsFromContext (handlerCtxt);  			switch (ehc.Flags) {  			case PE.CorILExceptionClause.Exception:  				handlers.Add (new CatchTryInstructionHandler ((TypeRef)ehc.Class' handlerBlock));  				break;  			case PE.CorILExceptionClause.Filter: {  				var filterCtxt = new FilterTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.FilterOffset]' ehc);  				var filterBlock = InstructionsFromContext (filterCtxt);  				handlers.Add (new FilterTryInstructionHandler (filterBlock' handlerBlock));  				break;  			}  			case PE.CorILExceptionClause.Finally:  				handlers.Add (new FinallyTryInstructionHandler (handlerBlock));  				break;  			case PE.CorILExceptionClause.Fault:  				handlers.Add (new FaultTryInstructionHandler (handlerBlock));  				break;  			default:  				throw new ArgumentOutOfRangeException ();  			}  		}  		instructions.Add (new TryInstruction (offset' tryBlock' handlers));  		// Jump over try block  		var nextOffset = ehcs [0].TryOffset + ehcs [0].TryLength;  		if (!ctxt.OffsetToIndex.TryGetValue (nextOffset' out i))  			i = ctxt.Instructions.Length;  	}  	else {  		var instruction = ctxt.Instructions [i++];  		var offset = instruction.Offset;  		while (instruction.OpCode == PE.OpCode.Unaligned || instruction.OpCode == PE.OpCode.Volatile || instruction.OpCode == PE.OpCode.Tailcall) {  			// Skip over any ignored prefixes' but remember instruction begins at original offset  			// NOTE: What ever happened to the "no." prefix mentioned in the spec?  			if (i >= ctxt.Instructions.Length)  				throw new InvalidOperationException ("invalid instructions");  			instruction = ctxt.Instructions [i++];  		}  		switch (instruction.OpCode) {  		case PE.OpCode.Cpblk:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Cpblk));  			break;  		case PE.OpCode.Initblk:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Initblk));  			break;  		case PE.OpCode.Arglist:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Arglist));  			break;  		case PE.OpCode.Localloc:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Localloc));  			break;  		case PE.OpCode.Jmp:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Jmp));  			break;  		case PE.OpCode.Calli:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Calli));  			break;  		case PE.OpCode.Sizeof:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Sizeof));  			break;  		case PE.OpCode.Mkrefany:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Mkrefany));  			break;  		case PE.OpCode.Refanytype:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanytype));  			break;  		case PE.OpCode.Refanyval:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanyval));  			break;  		case PE.OpCode.Nop:  			instructions.Add (new MiscInstruction (offset' MiscOp.Nop));  			break;  		case PE.OpCode.Break:  			instructions.Add (new MiscInstruction (offset' MiscOp.Break));  			break;  		case PE.OpCode.Dup:  			instructions.Add (new MiscInstruction (offset' MiscOp.Dup));  			break;  		case PE.OpCode.Pop:  			instructions.Add (new MiscInstruction (offset' MiscOp.Pop));  			break;  		case PE.OpCode.Ldnull:  			instructions.Add (new MiscInstruction (offset' MiscOp.Ldnull));  			break;  		case PE.OpCode.Ckfinite:  			instructions.Add (new MiscInstruction (offset' MiscOp.Ckfinite));  			break;  		case PE.OpCode.Throw:  			instructions.Add (new MiscInstruction (offset' MiscOp.Throw));  			break;  		case PE.OpCode.Rethrow:  			instructions.Add (new MiscInstruction (offset' MiscOp.Rethrow));  			break;  		case PE.OpCode.Ldind_ref:  			instructions.Add (new MiscInstruction (offset' MiscOp.LdindRef));  			break;  		case PE.OpCode.Stind_ref:  			instructions.Add (new MiscInstruction (offset' MiscOp.StindRef));  			break;  		case PE.OpCode.Ldelem_ref:  			instructions.Add (new MiscInstruction (offset' MiscOp.LdelemRef));  			break;  		case PE.OpCode.Stelem_ref:  			instructions.Add (new MiscInstruction (offset' MiscOp.StelemRef));  			break;  		case PE.OpCode.Ldlen:  			instructions.Add (new MiscInstruction (offset' MiscOp.Ldlen));  			break;  		case PE.OpCode.Ret:  			if (ctxt.ResultType == null)  				instructions.Add (new MiscInstruction (offset' MiscOp.Ret));  			else  				instructions.Add (new MiscInstruction (offset' MiscOp.RetVal));  			break;  		case PE.OpCode.Endfilter:  			instructions.Add (new MiscInstruction (offset' MiscOp.Endfilter));  			break;  		case PE.OpCode.Endfinally:  			// aka EndFault  			instructions.Add (new MiscInstruction (offset' MiscOp.Endfinally));  			break;  		case PE.OpCode.Br_s:  		case PE.OpCode.Br:  			instructions.Add (new BranchInstruction (offset' BranchOp.Br' false' (int)instruction.Value));  			break;  		case PE.OpCode.Brtrue_s:  		// aka brinst.s  		case PE.OpCode.Brtrue:  			// aka brinst  			instructions.Add (new BranchInstruction (offset' BranchOp.Brtrue' false' (int)instruction.Value));  			break;  		case PE.OpCode.Brfalse_s:  		// aka brzero.s' brnull.s  		case PE.OpCode.Brfalse:  			// aka brzero' brnull  			instructions.Add (new BranchInstruction (offset' BranchOp.Brfalse' false' (int)instruction.Value));  			break;  		case PE.OpCode.Beq:  		case PE.OpCode.Beq_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.Breq' false' (int)instruction.Value));  			break;  		case PE.OpCode.Bne_un:  		case PE.OpCode.Bne_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.Brne' false' (int)instruction.Value));  			break;  		case PE.OpCode.Leave:  		case PE.OpCode.Leave_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.Leave' false' (int)instruction.Value));  			break;  		case PE.OpCode.Blt:  		case PE.OpCode.Blt_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' false' (int)instruction.Value));  			break;  		case PE.OpCode.Blt_un:  		case PE.OpCode.Blt_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' true' (int)instruction.Value));  			break;  		case PE.OpCode.Ble:  		case PE.OpCode.Ble_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' false' (int)instruction.Value));  			break;  		case PE.OpCode.Ble_un:  		case PE.OpCode.Ble_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' true' (int)instruction.Value));  			break;  		case PE.OpCode.Bgt:  		case PE.OpCode.Bgt_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' false' (int)instruction.Value));  			break;  		case PE.OpCode.Bgt_un:  		case PE.OpCode.Bgt_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' true' (int)instruction.Value));  			break;  		case PE.OpCode.Bge:  		case PE.OpCode.Bge_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' false' (int)instruction.Value));  			break;  		case PE.OpCode.Bge_un:  		case PE.OpCode.Bge_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' true' (int)instruction.Value));  			break;  		case PE.OpCode.Switch:  			instructions.Add (new SwitchInstruction (offset' (Seq<int>)instruction.Value));  			break;  		case PE.OpCode.Ceq:  			instructions.Add (new CompareInstruction (offset' CompareOp.Ceq' false));  			break;  		case PE.OpCode.Clt:  			instructions.Add (new CompareInstruction (offset' CompareOp.Clt' false));  			break;  		case PE.OpCode.Clt_un:  			instructions.Add (new CompareInstruction (offset' CompareOp.Clt' true));  			break;  		case PE.OpCode.Cgt:  			instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' false));  			break;  		case PE.OpCode.Cgt_un:  			instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' true));  			break;  		case PE.OpCode.Ldarg_0:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));  			break;  		case PE.OpCode.Ldarg_1:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));  			break;  		case PE.OpCode.Ldarg_2:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));  			break;  		case PE.OpCode.Ldarg_3:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));  			break;  		case PE.OpCode.Ldarg:  		case PE.OpCode.Ldarg_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));  			break;  		case PE.OpCode.Ldarga:  		case PE.OpCode.Ldarga_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));  			break;  		case PE.OpCode.Starg:  		case PE.OpCode.Starg_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));  			break;  		case PE.OpCode.Ldloc_0:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 0));  			break;  		case PE.OpCode.Ldloc_1:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 1));  			break;  		case PE.OpCode.Ldloc_2:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 2));  			break;  		case PE.OpCode.Ldloc_3:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 3));  			break;  		case PE.OpCode.Ldloc:  		case PE.OpCode.Ldloc_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));  			break;  		case PE.OpCode.Ldloca:  		case PE.OpCode.Ldloca_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));  			break;  		case PE.OpCode.Stloc_0:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 0));  			break;  		case PE.OpCode.Stloc_1:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 1));  			break;  		case PE.OpCode.Stloc_2:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 2));  			break;  		case PE.OpCode.Stloc_3:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 3));  			break;  		case PE.OpCode.Stloc:  		case PE.OpCode.Stloc_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));  			break;  		case PE.OpCode.Ldfld:  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));  			break;  		case PE.OpCode.Ldsfld:  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));  			break;  		case PE.OpCode.Ldflda:  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));  			break;  		case PE.OpCode.Ldsflda:  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));  			break;  		case PE.OpCode.Stfld:  			instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));  			break;  		case PE.OpCode.Stsfld:  			instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));  			break;  		case PE.OpCode.Ldtoken: {  			if (instruction.Value is FieldRef)  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));  			else if (instruction.Value is MethodRef)  				instructions.Add (new MethodInstruction (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));  			else if (instruction.Value is TypeRef)  				// NOTE: May be a higher-kinded type  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));  			else  				throw new InvalidOperationException ("unexpected ldtoken instruction value");  			break;  		}  		case PE.OpCode.Constrained: {  			var constrained = (TypeRef)instruction.Value;  			if (i >= ctxt.Instructions.Length)  				throw new InvalidOperationException ("invalid instructions");  			instruction = ctxt.Instructions [i++];  			if (instruction.OpCode != PE.OpCode.Callvirt)  				throw new InvalidOperationException ("invalid instruction");  			instructions.Add (new MethodInstruction (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));  			break;  		}  		case PE.OpCode.Call:  			instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Callvirt:  			instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Ldftn:  			instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Ldvirtftn:  			instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Newobj:  			instructions.Add (new MethodInstruction (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Ldind_i1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int8Ref));  			break;  		case PE.OpCode.Ldind_u1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt8Ref));  			break;  		case PE.OpCode.Ldind_i2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int16Ref));  			break;  		case PE.OpCode.Ldind_u2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt16Ref));  			break;  		case PE.OpCode.Ldind_i4:  		case PE.OpCode.Ldind_u4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int32Ref));  			break;  		case PE.OpCode.Ldind_i8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int64Ref));  			break;  		case PE.OpCode.Ldind_i:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.IntNativeRef));  			break;  		case PE.OpCode.Ldind_r4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.SingleRef));  			break;  		case PE.OpCode.Ldind_r8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.DoubleRef));  			break;  		case PE.OpCode.Ldobj:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Stind_i1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int8Ref));  			break;  		case PE.OpCode.Stind_i2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int16Ref));  			break;  		case PE.OpCode.Stind_i4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int32Ref));  			break;  		case PE.OpCode.Stind_i8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int64Ref));  			break;  		case PE.OpCode.Stind_i:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.IntNativeRef));  			break;  		case PE.OpCode.Stind_r4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.SingleRef));  			break;  		case PE.OpCode.Stind_r8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.DoubleRef));  			break;  		case PE.OpCode.Stobj:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Cpobj:  			instructions.Add (new TypeInstruction (offset' TypeOp.Cpobj' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Newarr:  			instructions.Add (new TypeInstruction (offset' TypeOp.Newarr' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Initobj:  			instructions.Add (new TypeInstruction (offset' TypeOp.Initobj' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Castclass:  			instructions.Add (new TypeInstruction (offset' TypeOp.Castclass' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Isinst:  			instructions.Add (new TypeInstruction (offset' TypeOp.Isinst' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Box:  			instructions.Add (new TypeInstruction (offset' TypeOp.Box' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Unbox:  			instructions.Add (new TypeInstruction (offset' TypeOp.Unbox' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Unbox_any:  			instructions.Add (new TypeInstruction (offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Ldelem_i1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int8Ref));  			break;  		case PE.OpCode.Ldelem_u1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt8Ref));  			break;  		case PE.OpCode.Ldelem_i2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int16Ref));  			break;  		case PE.OpCode.Ldelem_u2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt16Ref));  			break;  		case PE.OpCode.Ldelem_i4:  		case PE.OpCode.Ldelem_u4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int32Ref));  			break;  		case PE.OpCode.Ldelem_i:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.IntNativeRef));  			break;  		case PE.OpCode.Ldelem_i8:  			// aka ldelem.u8  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int64Ref));  			break;  		case PE.OpCode.Ldelem_r4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.SingleRef));  			break;  		case PE.OpCode.Ldelem_r8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.DoubleRef));  			break;  		case PE.OpCode.Ldelem:  			// aka ldelem.any  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Stelem_i1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int8Ref));  			break;  		case PE.OpCode.Stelem_i2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int16Ref));  			break;  		case PE.OpCode.Stelem_i4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int32Ref));  			break;  		case PE.OpCode.Stelem_i8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int64Ref));  			break;  		case PE.OpCode.Stelem_i:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.IntNativeRef));  			break;  		case PE.OpCode.Stelem_r4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.SingleRef));  			break;  		case PE.OpCode.Stelem_r8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.DoubleRef));  			break;  		case PE.OpCode.Stelem:  			// aka stelem.any  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Readonly:  			if (i >= ctxt.Instructions.Length)  				throw new InvalidOperationException ("invalid instruction");  			instruction = ctxt.Instructions [i++];  			if (instruction.OpCode != PE.OpCode.Ldelema)  				throw new InvalidOperationException ("invalid instruction");  			instructions.Add (new LdElemAddrInstruction (offset' true' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Ldelema:  			instructions.Add (new LdElemAddrInstruction (offset' false' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Ldc_i4_0:  			instructions.Add (new LdInt32Instruction (offset' 0));  			break;  		case PE.OpCode.Ldc_i4_1:  			instructions.Add (new LdInt32Instruction (offset' 1));  			break;  		case PE.OpCode.Ldc_i4_2:  			instructions.Add (new LdInt32Instruction (offset' 2));  			break;  		case PE.OpCode.Ldc_i4_3:  			instructions.Add (new LdInt32Instruction (offset' 3));  			break;  		case PE.OpCode.Ldc_i4_4:  			instructions.Add (new LdInt32Instruction (offset' 4));  			break;  		case PE.OpCode.Ldc_i4_5:  			instructions.Add (new LdInt32Instruction (offset' 5));  			break;  		case PE.OpCode.Ldc_i4_6:  			instructions.Add (new LdInt32Instruction (offset' 6));  			break;  		case PE.OpCode.Ldc_i4_7:  			instructions.Add (new LdInt32Instruction (offset' 7));  			break;  		case PE.OpCode.Ldc_i4_8:  			instructions.Add (new LdInt32Instruction (offset' 8));  			break;  		case PE.OpCode.Ldc_i4_m1:  			instructions.Add (new LdInt32Instruction (offset' -1));  			break;  		case PE.OpCode.Ldc_i4:  		case PE.OpCode.Ldc_i4_s:  			instructions.Add (new LdInt32Instruction (offset' (int)instruction.Value));  			break;  		case PE.OpCode.Ldc_i8:  			instructions.Add (new LdInt64Instruction (offset' (long)instruction.Value));  			break;  		case PE.OpCode.Ldc_r4:  			instructions.Add (new LdSingleInstruction (offset' (float)instruction.Value));  			break;  		case PE.OpCode.Ldc_r8:  			instructions.Add (new LdDoubleInstruction (offset' (double)instruction.Value));  			break;  		case PE.OpCode.Ldstr:  			instructions.Add (new LdStringInstruction (offset' (string)instruction.Value));  			break;  		case PE.OpCode.Add:  			instructions.Add (new ArithInstruction (offset' ArithOp.Add' false' false));  			break;  		case PE.OpCode.Add_ovf:  			instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' false));  			break;  		case PE.OpCode.Add_ovf_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' true));  			break;  		case PE.OpCode.Sub:  			instructions.Add (new ArithInstruction (offset' ArithOp.Sub' false' false));  			break;  		case PE.OpCode.Sub_ovf:  			instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' false));  			break;  		case PE.OpCode.Sub_ovf_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' true));  			break;  		case PE.OpCode.Mul:  			instructions.Add (new ArithInstruction (offset' ArithOp.Mul' false' false));  			break;  		case PE.OpCode.Mul_ovf:  			instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' false));  			break;  		case PE.OpCode.Mul_ovf_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' true));  			break;  		case PE.OpCode.Div:  			instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' false));  			break;  		case PE.OpCode.Div_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' true));  			break;  		case PE.OpCode.Rem:  			instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' false));  			break;  		case PE.OpCode.Rem_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' true));  			break;  		case PE.OpCode.Neg:  			instructions.Add (new ArithInstruction (offset' ArithOp.Neg' false' false));  			break;  		case PE.OpCode.And:  			instructions.Add (new ArithInstruction (offset' ArithOp.BitAnd' false' false));  			break;  		case PE.OpCode.Or:  			instructions.Add (new ArithInstruction (offset' ArithOp.BitOr' false' false));  			break;  		case PE.OpCode.Xor:  			instructions.Add (new ArithInstruction (offset' ArithOp.BitXor' false' false));  			break;  		case PE.OpCode.Not:  			instructions.Add (new ArithInstruction (offset' ArithOp.BitNot' false' false));  			break;  		case PE.OpCode.Shl:  			instructions.Add (new ArithInstruction (offset' ArithOp.Shl' false' false));  			break;  		case PE.OpCode.Shr:  			instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' false));  			break;  		case PE.OpCode.Shr_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' true));  			break;  		case PE.OpCode.Conv_i1:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' false' false));  			break;  		case PE.OpCode.Conv_u1:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' false' false));  			break;  		case PE.OpCode.Conv_i2:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' false' false));  			break;  		case PE.OpCode.Conv_u2:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' false' false));  			break;  		case PE.OpCode.Conv_i4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' false' false));  			break;  		case PE.OpCode.Conv_u4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' false' false));  			break;  		case PE.OpCode.Conv_i8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' false' false));  			break;  		case PE.OpCode.Conv_u8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' false' false));  			break;  		case PE.OpCode.Conv_i:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' false' false));  			break;  		case PE.OpCode.Conv_u:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' false' false));  			break;  		case PE.OpCode.Conv_r4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Single' false' false));  			break;  		case PE.OpCode.Conv_r8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' false));  			break;  		case PE.OpCode.Conv_r_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' true));  			break;  		case PE.OpCode.Conv_ovf_i1:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' false));  			break;  		case PE.OpCode.Conv_ovf_u1:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' false));  			break;  		case PE.OpCode.Conv_ovf_i2:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' false));  			break;  		case PE.OpCode.Conv_ovf_u2:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' false));  			break;  		case PE.OpCode.Conv_ovf_i4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' false));  			break;  		case PE.OpCode.Conv_ovf_u4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' false));  			break;  		case PE.OpCode.Conv_ovf_i8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' false));  			break;  		case PE.OpCode.Conv_ovf_u8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' false));  			break;  		case PE.OpCode.Conv_ovf_i:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' false));  			break;  		case PE.OpCode.Conv_ovf_u:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' false));  			break;  		case PE.OpCode.Conv_ovf_i1_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' true));  			break;  		case PE.OpCode.Conv_ovf_u1_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' true));  			break;  		case PE.OpCode.Conv_ovf_i2_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' true));  			break;  		case PE.OpCode.Conv_ovf_u2_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' true));  			break;  		case PE.OpCode.Conv_ovf_i4_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' true));  			break;  		case PE.OpCode.Conv_ovf_u4_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' true));  			break;  		case PE.OpCode.Conv_ovf_i8_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' true));  			break;  		case PE.OpCode.Conv_ovf_u8_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' true));  			break;  		case PE.OpCode.Conv_ovf_i_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' true));  			break;  		case PE.OpCode.Conv_ovf_u_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' true));  			break;  		default:  			throw new InvalidOperationException ("invalid instruction");  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: if (j > i)  	i = j;  else {  	var ehcs = ctxt.OutermostTryBlocks (i);  	if (ehcs != null) {  		// A try instruction begins here with given handlers  		var offset = ctxt.Instructions [i].Offset;  		var tryCtxt = new TryTranslationContext (ctxt' i' ehcs);  		var tryBlock = InstructionsFromContext (tryCtxt);  		var handlers = new Seq<TryInstructionHandler> ();  		foreach (var ehc in ehcs) {  			var handlerCtxt = new HandlerTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.HandlerOffset]' ehc);  			var handlerBlock = InstructionsFromContext (handlerCtxt);  			switch (ehc.Flags) {  			case PE.CorILExceptionClause.Exception:  				handlers.Add (new CatchTryInstructionHandler ((TypeRef)ehc.Class' handlerBlock));  				break;  			case PE.CorILExceptionClause.Filter: {  				var filterCtxt = new FilterTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.FilterOffset]' ehc);  				var filterBlock = InstructionsFromContext (filterCtxt);  				handlers.Add (new FilterTryInstructionHandler (filterBlock' handlerBlock));  				break;  			}  			case PE.CorILExceptionClause.Finally:  				handlers.Add (new FinallyTryInstructionHandler (handlerBlock));  				break;  			case PE.CorILExceptionClause.Fault:  				handlers.Add (new FaultTryInstructionHandler (handlerBlock));  				break;  			default:  				throw new ArgumentOutOfRangeException ();  			}  		}  		instructions.Add (new TryInstruction (offset' tryBlock' handlers));  		// Jump over try block  		var nextOffset = ehcs [0].TryOffset + ehcs [0].TryLength;  		if (!ctxt.OffsetToIndex.TryGetValue (nextOffset' out i))  			i = ctxt.Instructions.Length;  	}  	else {  		var instruction = ctxt.Instructions [i++];  		var offset = instruction.Offset;  		while (instruction.OpCode == PE.OpCode.Unaligned || instruction.OpCode == PE.OpCode.Volatile || instruction.OpCode == PE.OpCode.Tailcall) {  			// Skip over any ignored prefixes' but remember instruction begins at original offset  			// NOTE: What ever happened to the "no." prefix mentioned in the spec?  			if (i >= ctxt.Instructions.Length)  				throw new InvalidOperationException ("invalid instructions");  			instruction = ctxt.Instructions [i++];  		}  		switch (instruction.OpCode) {  		case PE.OpCode.Cpblk:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Cpblk));  			break;  		case PE.OpCode.Initblk:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Initblk));  			break;  		case PE.OpCode.Arglist:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Arglist));  			break;  		case PE.OpCode.Localloc:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Localloc));  			break;  		case PE.OpCode.Jmp:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Jmp));  			break;  		case PE.OpCode.Calli:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Calli));  			break;  		case PE.OpCode.Sizeof:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Sizeof));  			break;  		case PE.OpCode.Mkrefany:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Mkrefany));  			break;  		case PE.OpCode.Refanytype:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanytype));  			break;  		case PE.OpCode.Refanyval:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanyval));  			break;  		case PE.OpCode.Nop:  			instructions.Add (new MiscInstruction (offset' MiscOp.Nop));  			break;  		case PE.OpCode.Break:  			instructions.Add (new MiscInstruction (offset' MiscOp.Break));  			break;  		case PE.OpCode.Dup:  			instructions.Add (new MiscInstruction (offset' MiscOp.Dup));  			break;  		case PE.OpCode.Pop:  			instructions.Add (new MiscInstruction (offset' MiscOp.Pop));  			break;  		case PE.OpCode.Ldnull:  			instructions.Add (new MiscInstruction (offset' MiscOp.Ldnull));  			break;  		case PE.OpCode.Ckfinite:  			instructions.Add (new MiscInstruction (offset' MiscOp.Ckfinite));  			break;  		case PE.OpCode.Throw:  			instructions.Add (new MiscInstruction (offset' MiscOp.Throw));  			break;  		case PE.OpCode.Rethrow:  			instructions.Add (new MiscInstruction (offset' MiscOp.Rethrow));  			break;  		case PE.OpCode.Ldind_ref:  			instructions.Add (new MiscInstruction (offset' MiscOp.LdindRef));  			break;  		case PE.OpCode.Stind_ref:  			instructions.Add (new MiscInstruction (offset' MiscOp.StindRef));  			break;  		case PE.OpCode.Ldelem_ref:  			instructions.Add (new MiscInstruction (offset' MiscOp.LdelemRef));  			break;  		case PE.OpCode.Stelem_ref:  			instructions.Add (new MiscInstruction (offset' MiscOp.StelemRef));  			break;  		case PE.OpCode.Ldlen:  			instructions.Add (new MiscInstruction (offset' MiscOp.Ldlen));  			break;  		case PE.OpCode.Ret:  			if (ctxt.ResultType == null)  				instructions.Add (new MiscInstruction (offset' MiscOp.Ret));  			else  				instructions.Add (new MiscInstruction (offset' MiscOp.RetVal));  			break;  		case PE.OpCode.Endfilter:  			instructions.Add (new MiscInstruction (offset' MiscOp.Endfilter));  			break;  		case PE.OpCode.Endfinally:  			// aka EndFault  			instructions.Add (new MiscInstruction (offset' MiscOp.Endfinally));  			break;  		case PE.OpCode.Br_s:  		case PE.OpCode.Br:  			instructions.Add (new BranchInstruction (offset' BranchOp.Br' false' (int)instruction.Value));  			break;  		case PE.OpCode.Brtrue_s:  		// aka brinst.s  		case PE.OpCode.Brtrue:  			// aka brinst  			instructions.Add (new BranchInstruction (offset' BranchOp.Brtrue' false' (int)instruction.Value));  			break;  		case PE.OpCode.Brfalse_s:  		// aka brzero.s' brnull.s  		case PE.OpCode.Brfalse:  			// aka brzero' brnull  			instructions.Add (new BranchInstruction (offset' BranchOp.Brfalse' false' (int)instruction.Value));  			break;  		case PE.OpCode.Beq:  		case PE.OpCode.Beq_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.Breq' false' (int)instruction.Value));  			break;  		case PE.OpCode.Bne_un:  		case PE.OpCode.Bne_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.Brne' false' (int)instruction.Value));  			break;  		case PE.OpCode.Leave:  		case PE.OpCode.Leave_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.Leave' false' (int)instruction.Value));  			break;  		case PE.OpCode.Blt:  		case PE.OpCode.Blt_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' false' (int)instruction.Value));  			break;  		case PE.OpCode.Blt_un:  		case PE.OpCode.Blt_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' true' (int)instruction.Value));  			break;  		case PE.OpCode.Ble:  		case PE.OpCode.Ble_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' false' (int)instruction.Value));  			break;  		case PE.OpCode.Ble_un:  		case PE.OpCode.Ble_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' true' (int)instruction.Value));  			break;  		case PE.OpCode.Bgt:  		case PE.OpCode.Bgt_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' false' (int)instruction.Value));  			break;  		case PE.OpCode.Bgt_un:  		case PE.OpCode.Bgt_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' true' (int)instruction.Value));  			break;  		case PE.OpCode.Bge:  		case PE.OpCode.Bge_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' false' (int)instruction.Value));  			break;  		case PE.OpCode.Bge_un:  		case PE.OpCode.Bge_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' true' (int)instruction.Value));  			break;  		case PE.OpCode.Switch:  			instructions.Add (new SwitchInstruction (offset' (Seq<int>)instruction.Value));  			break;  		case PE.OpCode.Ceq:  			instructions.Add (new CompareInstruction (offset' CompareOp.Ceq' false));  			break;  		case PE.OpCode.Clt:  			instructions.Add (new CompareInstruction (offset' CompareOp.Clt' false));  			break;  		case PE.OpCode.Clt_un:  			instructions.Add (new CompareInstruction (offset' CompareOp.Clt' true));  			break;  		case PE.OpCode.Cgt:  			instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' false));  			break;  		case PE.OpCode.Cgt_un:  			instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' true));  			break;  		case PE.OpCode.Ldarg_0:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));  			break;  		case PE.OpCode.Ldarg_1:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));  			break;  		case PE.OpCode.Ldarg_2:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));  			break;  		case PE.OpCode.Ldarg_3:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));  			break;  		case PE.OpCode.Ldarg:  		case PE.OpCode.Ldarg_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));  			break;  		case PE.OpCode.Ldarga:  		case PE.OpCode.Ldarga_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));  			break;  		case PE.OpCode.Starg:  		case PE.OpCode.Starg_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));  			break;  		case PE.OpCode.Ldloc_0:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 0));  			break;  		case PE.OpCode.Ldloc_1:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 1));  			break;  		case PE.OpCode.Ldloc_2:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 2));  			break;  		case PE.OpCode.Ldloc_3:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 3));  			break;  		case PE.OpCode.Ldloc:  		case PE.OpCode.Ldloc_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));  			break;  		case PE.OpCode.Ldloca:  		case PE.OpCode.Ldloca_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));  			break;  		case PE.OpCode.Stloc_0:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 0));  			break;  		case PE.OpCode.Stloc_1:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 1));  			break;  		case PE.OpCode.Stloc_2:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 2));  			break;  		case PE.OpCode.Stloc_3:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 3));  			break;  		case PE.OpCode.Stloc:  		case PE.OpCode.Stloc_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));  			break;  		case PE.OpCode.Ldfld:  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));  			break;  		case PE.OpCode.Ldsfld:  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));  			break;  		case PE.OpCode.Ldflda:  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));  			break;  		case PE.OpCode.Ldsflda:  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));  			break;  		case PE.OpCode.Stfld:  			instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));  			break;  		case PE.OpCode.Stsfld:  			instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));  			break;  		case PE.OpCode.Ldtoken: {  			if (instruction.Value is FieldRef)  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));  			else if (instruction.Value is MethodRef)  				instructions.Add (new MethodInstruction (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));  			else if (instruction.Value is TypeRef)  				// NOTE: May be a higher-kinded type  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));  			else  				throw new InvalidOperationException ("unexpected ldtoken instruction value");  			break;  		}  		case PE.OpCode.Constrained: {  			var constrained = (TypeRef)instruction.Value;  			if (i >= ctxt.Instructions.Length)  				throw new InvalidOperationException ("invalid instructions");  			instruction = ctxt.Instructions [i++];  			if (instruction.OpCode != PE.OpCode.Callvirt)  				throw new InvalidOperationException ("invalid instruction");  			instructions.Add (new MethodInstruction (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));  			break;  		}  		case PE.OpCode.Call:  			instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Callvirt:  			instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Ldftn:  			instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Ldvirtftn:  			instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Newobj:  			instructions.Add (new MethodInstruction (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Ldind_i1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int8Ref));  			break;  		case PE.OpCode.Ldind_u1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt8Ref));  			break;  		case PE.OpCode.Ldind_i2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int16Ref));  			break;  		case PE.OpCode.Ldind_u2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt16Ref));  			break;  		case PE.OpCode.Ldind_i4:  		case PE.OpCode.Ldind_u4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int32Ref));  			break;  		case PE.OpCode.Ldind_i8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int64Ref));  			break;  		case PE.OpCode.Ldind_i:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.IntNativeRef));  			break;  		case PE.OpCode.Ldind_r4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.SingleRef));  			break;  		case PE.OpCode.Ldind_r8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.DoubleRef));  			break;  		case PE.OpCode.Ldobj:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Stind_i1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int8Ref));  			break;  		case PE.OpCode.Stind_i2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int16Ref));  			break;  		case PE.OpCode.Stind_i4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int32Ref));  			break;  		case PE.OpCode.Stind_i8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int64Ref));  			break;  		case PE.OpCode.Stind_i:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.IntNativeRef));  			break;  		case PE.OpCode.Stind_r4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.SingleRef));  			break;  		case PE.OpCode.Stind_r8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.DoubleRef));  			break;  		case PE.OpCode.Stobj:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Cpobj:  			instructions.Add (new TypeInstruction (offset' TypeOp.Cpobj' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Newarr:  			instructions.Add (new TypeInstruction (offset' TypeOp.Newarr' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Initobj:  			instructions.Add (new TypeInstruction (offset' TypeOp.Initobj' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Castclass:  			instructions.Add (new TypeInstruction (offset' TypeOp.Castclass' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Isinst:  			instructions.Add (new TypeInstruction (offset' TypeOp.Isinst' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Box:  			instructions.Add (new TypeInstruction (offset' TypeOp.Box' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Unbox:  			instructions.Add (new TypeInstruction (offset' TypeOp.Unbox' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Unbox_any:  			instructions.Add (new TypeInstruction (offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Ldelem_i1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int8Ref));  			break;  		case PE.OpCode.Ldelem_u1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt8Ref));  			break;  		case PE.OpCode.Ldelem_i2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int16Ref));  			break;  		case PE.OpCode.Ldelem_u2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt16Ref));  			break;  		case PE.OpCode.Ldelem_i4:  		case PE.OpCode.Ldelem_u4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int32Ref));  			break;  		case PE.OpCode.Ldelem_i:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.IntNativeRef));  			break;  		case PE.OpCode.Ldelem_i8:  			// aka ldelem.u8  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int64Ref));  			break;  		case PE.OpCode.Ldelem_r4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.SingleRef));  			break;  		case PE.OpCode.Ldelem_r8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.DoubleRef));  			break;  		case PE.OpCode.Ldelem:  			// aka ldelem.any  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Stelem_i1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int8Ref));  			break;  		case PE.OpCode.Stelem_i2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int16Ref));  			break;  		case PE.OpCode.Stelem_i4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int32Ref));  			break;  		case PE.OpCode.Stelem_i8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int64Ref));  			break;  		case PE.OpCode.Stelem_i:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.IntNativeRef));  			break;  		case PE.OpCode.Stelem_r4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.SingleRef));  			break;  		case PE.OpCode.Stelem_r8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.DoubleRef));  			break;  		case PE.OpCode.Stelem:  			// aka stelem.any  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Readonly:  			if (i >= ctxt.Instructions.Length)  				throw new InvalidOperationException ("invalid instruction");  			instruction = ctxt.Instructions [i++];  			if (instruction.OpCode != PE.OpCode.Ldelema)  				throw new InvalidOperationException ("invalid instruction");  			instructions.Add (new LdElemAddrInstruction (offset' true' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Ldelema:  			instructions.Add (new LdElemAddrInstruction (offset' false' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Ldc_i4_0:  			instructions.Add (new LdInt32Instruction (offset' 0));  			break;  		case PE.OpCode.Ldc_i4_1:  			instructions.Add (new LdInt32Instruction (offset' 1));  			break;  		case PE.OpCode.Ldc_i4_2:  			instructions.Add (new LdInt32Instruction (offset' 2));  			break;  		case PE.OpCode.Ldc_i4_3:  			instructions.Add (new LdInt32Instruction (offset' 3));  			break;  		case PE.OpCode.Ldc_i4_4:  			instructions.Add (new LdInt32Instruction (offset' 4));  			break;  		case PE.OpCode.Ldc_i4_5:  			instructions.Add (new LdInt32Instruction (offset' 5));  			break;  		case PE.OpCode.Ldc_i4_6:  			instructions.Add (new LdInt32Instruction (offset' 6));  			break;  		case PE.OpCode.Ldc_i4_7:  			instructions.Add (new LdInt32Instruction (offset' 7));  			break;  		case PE.OpCode.Ldc_i4_8:  			instructions.Add (new LdInt32Instruction (offset' 8));  			break;  		case PE.OpCode.Ldc_i4_m1:  			instructions.Add (new LdInt32Instruction (offset' -1));  			break;  		case PE.OpCode.Ldc_i4:  		case PE.OpCode.Ldc_i4_s:  			instructions.Add (new LdInt32Instruction (offset' (int)instruction.Value));  			break;  		case PE.OpCode.Ldc_i8:  			instructions.Add (new LdInt64Instruction (offset' (long)instruction.Value));  			break;  		case PE.OpCode.Ldc_r4:  			instructions.Add (new LdSingleInstruction (offset' (float)instruction.Value));  			break;  		case PE.OpCode.Ldc_r8:  			instructions.Add (new LdDoubleInstruction (offset' (double)instruction.Value));  			break;  		case PE.OpCode.Ldstr:  			instructions.Add (new LdStringInstruction (offset' (string)instruction.Value));  			break;  		case PE.OpCode.Add:  			instructions.Add (new ArithInstruction (offset' ArithOp.Add' false' false));  			break;  		case PE.OpCode.Add_ovf:  			instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' false));  			break;  		case PE.OpCode.Add_ovf_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' true));  			break;  		case PE.OpCode.Sub:  			instructions.Add (new ArithInstruction (offset' ArithOp.Sub' false' false));  			break;  		case PE.OpCode.Sub_ovf:  			instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' false));  			break;  		case PE.OpCode.Sub_ovf_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' true));  			break;  		case PE.OpCode.Mul:  			instructions.Add (new ArithInstruction (offset' ArithOp.Mul' false' false));  			break;  		case PE.OpCode.Mul_ovf:  			instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' false));  			break;  		case PE.OpCode.Mul_ovf_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' true));  			break;  		case PE.OpCode.Div:  			instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' false));  			break;  		case PE.OpCode.Div_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' true));  			break;  		case PE.OpCode.Rem:  			instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' false));  			break;  		case PE.OpCode.Rem_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' true));  			break;  		case PE.OpCode.Neg:  			instructions.Add (new ArithInstruction (offset' ArithOp.Neg' false' false));  			break;  		case PE.OpCode.And:  			instructions.Add (new ArithInstruction (offset' ArithOp.BitAnd' false' false));  			break;  		case PE.OpCode.Or:  			instructions.Add (new ArithInstruction (offset' ArithOp.BitOr' false' false));  			break;  		case PE.OpCode.Xor:  			instructions.Add (new ArithInstruction (offset' ArithOp.BitXor' false' false));  			break;  		case PE.OpCode.Not:  			instructions.Add (new ArithInstruction (offset' ArithOp.BitNot' false' false));  			break;  		case PE.OpCode.Shl:  			instructions.Add (new ArithInstruction (offset' ArithOp.Shl' false' false));  			break;  		case PE.OpCode.Shr:  			instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' false));  			break;  		case PE.OpCode.Shr_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' true));  			break;  		case PE.OpCode.Conv_i1:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' false' false));  			break;  		case PE.OpCode.Conv_u1:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' false' false));  			break;  		case PE.OpCode.Conv_i2:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' false' false));  			break;  		case PE.OpCode.Conv_u2:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' false' false));  			break;  		case PE.OpCode.Conv_i4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' false' false));  			break;  		case PE.OpCode.Conv_u4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' false' false));  			break;  		case PE.OpCode.Conv_i8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' false' false));  			break;  		case PE.OpCode.Conv_u8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' false' false));  			break;  		case PE.OpCode.Conv_i:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' false' false));  			break;  		case PE.OpCode.Conv_u:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' false' false));  			break;  		case PE.OpCode.Conv_r4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Single' false' false));  			break;  		case PE.OpCode.Conv_r8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' false));  			break;  		case PE.OpCode.Conv_r_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' true));  			break;  		case PE.OpCode.Conv_ovf_i1:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' false));  			break;  		case PE.OpCode.Conv_ovf_u1:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' false));  			break;  		case PE.OpCode.Conv_ovf_i2:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' false));  			break;  		case PE.OpCode.Conv_ovf_u2:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' false));  			break;  		case PE.OpCode.Conv_ovf_i4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' false));  			break;  		case PE.OpCode.Conv_ovf_u4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' false));  			break;  		case PE.OpCode.Conv_ovf_i8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' false));  			break;  		case PE.OpCode.Conv_ovf_u8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' false));  			break;  		case PE.OpCode.Conv_ovf_i:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' false));  			break;  		case PE.OpCode.Conv_ovf_u:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' false));  			break;  		case PE.OpCode.Conv_ovf_i1_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' true));  			break;  		case PE.OpCode.Conv_ovf_u1_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' true));  			break;  		case PE.OpCode.Conv_ovf_i2_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' true));  			break;  		case PE.OpCode.Conv_ovf_u2_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' true));  			break;  		case PE.OpCode.Conv_ovf_i4_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' true));  			break;  		case PE.OpCode.Conv_ovf_u4_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' true));  			break;  		case PE.OpCode.Conv_ovf_i8_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' true));  			break;  		case PE.OpCode.Conv_ovf_u8_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' true));  			break;  		case PE.OpCode.Conv_ovf_i_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' true));  			break;  		case PE.OpCode.Conv_ovf_u_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' true));  			break;  		default:  			throw new InvalidOperationException ("invalid instruction");  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: if (j > i)  	i = j;  else {  	var ehcs = ctxt.OutermostTryBlocks (i);  	if (ehcs != null) {  		// A try instruction begins here with given handlers  		var offset = ctxt.Instructions [i].Offset;  		var tryCtxt = new TryTranslationContext (ctxt' i' ehcs);  		var tryBlock = InstructionsFromContext (tryCtxt);  		var handlers = new Seq<TryInstructionHandler> ();  		foreach (var ehc in ehcs) {  			var handlerCtxt = new HandlerTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.HandlerOffset]' ehc);  			var handlerBlock = InstructionsFromContext (handlerCtxt);  			switch (ehc.Flags) {  			case PE.CorILExceptionClause.Exception:  				handlers.Add (new CatchTryInstructionHandler ((TypeRef)ehc.Class' handlerBlock));  				break;  			case PE.CorILExceptionClause.Filter: {  				var filterCtxt = new FilterTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.FilterOffset]' ehc);  				var filterBlock = InstructionsFromContext (filterCtxt);  				handlers.Add (new FilterTryInstructionHandler (filterBlock' handlerBlock));  				break;  			}  			case PE.CorILExceptionClause.Finally:  				handlers.Add (new FinallyTryInstructionHandler (handlerBlock));  				break;  			case PE.CorILExceptionClause.Fault:  				handlers.Add (new FaultTryInstructionHandler (handlerBlock));  				break;  			default:  				throw new ArgumentOutOfRangeException ();  			}  		}  		instructions.Add (new TryInstruction (offset' tryBlock' handlers));  		// Jump over try block  		var nextOffset = ehcs [0].TryOffset + ehcs [0].TryLength;  		if (!ctxt.OffsetToIndex.TryGetValue (nextOffset' out i))  			i = ctxt.Instructions.Length;  	}  	else {  		var instruction = ctxt.Instructions [i++];  		var offset = instruction.Offset;  		while (instruction.OpCode == PE.OpCode.Unaligned || instruction.OpCode == PE.OpCode.Volatile || instruction.OpCode == PE.OpCode.Tailcall) {  			// Skip over any ignored prefixes' but remember instruction begins at original offset  			// NOTE: What ever happened to the "no." prefix mentioned in the spec?  			if (i >= ctxt.Instructions.Length)  				throw new InvalidOperationException ("invalid instructions");  			instruction = ctxt.Instructions [i++];  		}  		switch (instruction.OpCode) {  		case PE.OpCode.Cpblk:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Cpblk));  			break;  		case PE.OpCode.Initblk:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Initblk));  			break;  		case PE.OpCode.Arglist:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Arglist));  			break;  		case PE.OpCode.Localloc:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Localloc));  			break;  		case PE.OpCode.Jmp:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Jmp));  			break;  		case PE.OpCode.Calli:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Calli));  			break;  		case PE.OpCode.Sizeof:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Sizeof));  			break;  		case PE.OpCode.Mkrefany:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Mkrefany));  			break;  		case PE.OpCode.Refanytype:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanytype));  			break;  		case PE.OpCode.Refanyval:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanyval));  			break;  		case PE.OpCode.Nop:  			instructions.Add (new MiscInstruction (offset' MiscOp.Nop));  			break;  		case PE.OpCode.Break:  			instructions.Add (new MiscInstruction (offset' MiscOp.Break));  			break;  		case PE.OpCode.Dup:  			instructions.Add (new MiscInstruction (offset' MiscOp.Dup));  			break;  		case PE.OpCode.Pop:  			instructions.Add (new MiscInstruction (offset' MiscOp.Pop));  			break;  		case PE.OpCode.Ldnull:  			instructions.Add (new MiscInstruction (offset' MiscOp.Ldnull));  			break;  		case PE.OpCode.Ckfinite:  			instructions.Add (new MiscInstruction (offset' MiscOp.Ckfinite));  			break;  		case PE.OpCode.Throw:  			instructions.Add (new MiscInstruction (offset' MiscOp.Throw));  			break;  		case PE.OpCode.Rethrow:  			instructions.Add (new MiscInstruction (offset' MiscOp.Rethrow));  			break;  		case PE.OpCode.Ldind_ref:  			instructions.Add (new MiscInstruction (offset' MiscOp.LdindRef));  			break;  		case PE.OpCode.Stind_ref:  			instructions.Add (new MiscInstruction (offset' MiscOp.StindRef));  			break;  		case PE.OpCode.Ldelem_ref:  			instructions.Add (new MiscInstruction (offset' MiscOp.LdelemRef));  			break;  		case PE.OpCode.Stelem_ref:  			instructions.Add (new MiscInstruction (offset' MiscOp.StelemRef));  			break;  		case PE.OpCode.Ldlen:  			instructions.Add (new MiscInstruction (offset' MiscOp.Ldlen));  			break;  		case PE.OpCode.Ret:  			if (ctxt.ResultType == null)  				instructions.Add (new MiscInstruction (offset' MiscOp.Ret));  			else  				instructions.Add (new MiscInstruction (offset' MiscOp.RetVal));  			break;  		case PE.OpCode.Endfilter:  			instructions.Add (new MiscInstruction (offset' MiscOp.Endfilter));  			break;  		case PE.OpCode.Endfinally:  			// aka EndFault  			instructions.Add (new MiscInstruction (offset' MiscOp.Endfinally));  			break;  		case PE.OpCode.Br_s:  		case PE.OpCode.Br:  			instructions.Add (new BranchInstruction (offset' BranchOp.Br' false' (int)instruction.Value));  			break;  		case PE.OpCode.Brtrue_s:  		// aka brinst.s  		case PE.OpCode.Brtrue:  			// aka brinst  			instructions.Add (new BranchInstruction (offset' BranchOp.Brtrue' false' (int)instruction.Value));  			break;  		case PE.OpCode.Brfalse_s:  		// aka brzero.s' brnull.s  		case PE.OpCode.Brfalse:  			// aka brzero' brnull  			instructions.Add (new BranchInstruction (offset' BranchOp.Brfalse' false' (int)instruction.Value));  			break;  		case PE.OpCode.Beq:  		case PE.OpCode.Beq_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.Breq' false' (int)instruction.Value));  			break;  		case PE.OpCode.Bne_un:  		case PE.OpCode.Bne_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.Brne' false' (int)instruction.Value));  			break;  		case PE.OpCode.Leave:  		case PE.OpCode.Leave_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.Leave' false' (int)instruction.Value));  			break;  		case PE.OpCode.Blt:  		case PE.OpCode.Blt_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' false' (int)instruction.Value));  			break;  		case PE.OpCode.Blt_un:  		case PE.OpCode.Blt_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' true' (int)instruction.Value));  			break;  		case PE.OpCode.Ble:  		case PE.OpCode.Ble_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' false' (int)instruction.Value));  			break;  		case PE.OpCode.Ble_un:  		case PE.OpCode.Ble_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' true' (int)instruction.Value));  			break;  		case PE.OpCode.Bgt:  		case PE.OpCode.Bgt_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' false' (int)instruction.Value));  			break;  		case PE.OpCode.Bgt_un:  		case PE.OpCode.Bgt_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' true' (int)instruction.Value));  			break;  		case PE.OpCode.Bge:  		case PE.OpCode.Bge_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' false' (int)instruction.Value));  			break;  		case PE.OpCode.Bge_un:  		case PE.OpCode.Bge_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' true' (int)instruction.Value));  			break;  		case PE.OpCode.Switch:  			instructions.Add (new SwitchInstruction (offset' (Seq<int>)instruction.Value));  			break;  		case PE.OpCode.Ceq:  			instructions.Add (new CompareInstruction (offset' CompareOp.Ceq' false));  			break;  		case PE.OpCode.Clt:  			instructions.Add (new CompareInstruction (offset' CompareOp.Clt' false));  			break;  		case PE.OpCode.Clt_un:  			instructions.Add (new CompareInstruction (offset' CompareOp.Clt' true));  			break;  		case PE.OpCode.Cgt:  			instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' false));  			break;  		case PE.OpCode.Cgt_un:  			instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' true));  			break;  		case PE.OpCode.Ldarg_0:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));  			break;  		case PE.OpCode.Ldarg_1:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));  			break;  		case PE.OpCode.Ldarg_2:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));  			break;  		case PE.OpCode.Ldarg_3:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));  			break;  		case PE.OpCode.Ldarg:  		case PE.OpCode.Ldarg_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));  			break;  		case PE.OpCode.Ldarga:  		case PE.OpCode.Ldarga_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));  			break;  		case PE.OpCode.Starg:  		case PE.OpCode.Starg_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));  			break;  		case PE.OpCode.Ldloc_0:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 0));  			break;  		case PE.OpCode.Ldloc_1:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 1));  			break;  		case PE.OpCode.Ldloc_2:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 2));  			break;  		case PE.OpCode.Ldloc_3:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 3));  			break;  		case PE.OpCode.Ldloc:  		case PE.OpCode.Ldloc_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));  			break;  		case PE.OpCode.Ldloca:  		case PE.OpCode.Ldloca_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));  			break;  		case PE.OpCode.Stloc_0:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 0));  			break;  		case PE.OpCode.Stloc_1:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 1));  			break;  		case PE.OpCode.Stloc_2:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 2));  			break;  		case PE.OpCode.Stloc_3:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 3));  			break;  		case PE.OpCode.Stloc:  		case PE.OpCode.Stloc_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));  			break;  		case PE.OpCode.Ldfld:  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));  			break;  		case PE.OpCode.Ldsfld:  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));  			break;  		case PE.OpCode.Ldflda:  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));  			break;  		case PE.OpCode.Ldsflda:  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));  			break;  		case PE.OpCode.Stfld:  			instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));  			break;  		case PE.OpCode.Stsfld:  			instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));  			break;  		case PE.OpCode.Ldtoken: {  			if (instruction.Value is FieldRef)  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));  			else if (instruction.Value is MethodRef)  				instructions.Add (new MethodInstruction (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));  			else if (instruction.Value is TypeRef)  				// NOTE: May be a higher-kinded type  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));  			else  				throw new InvalidOperationException ("unexpected ldtoken instruction value");  			break;  		}  		case PE.OpCode.Constrained: {  			var constrained = (TypeRef)instruction.Value;  			if (i >= ctxt.Instructions.Length)  				throw new InvalidOperationException ("invalid instructions");  			instruction = ctxt.Instructions [i++];  			if (instruction.OpCode != PE.OpCode.Callvirt)  				throw new InvalidOperationException ("invalid instruction");  			instructions.Add (new MethodInstruction (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));  			break;  		}  		case PE.OpCode.Call:  			instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Callvirt:  			instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Ldftn:  			instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Ldvirtftn:  			instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Newobj:  			instructions.Add (new MethodInstruction (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Ldind_i1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int8Ref));  			break;  		case PE.OpCode.Ldind_u1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt8Ref));  			break;  		case PE.OpCode.Ldind_i2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int16Ref));  			break;  		case PE.OpCode.Ldind_u2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt16Ref));  			break;  		case PE.OpCode.Ldind_i4:  		case PE.OpCode.Ldind_u4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int32Ref));  			break;  		case PE.OpCode.Ldind_i8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int64Ref));  			break;  		case PE.OpCode.Ldind_i:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.IntNativeRef));  			break;  		case PE.OpCode.Ldind_r4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.SingleRef));  			break;  		case PE.OpCode.Ldind_r8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.DoubleRef));  			break;  		case PE.OpCode.Ldobj:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Stind_i1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int8Ref));  			break;  		case PE.OpCode.Stind_i2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int16Ref));  			break;  		case PE.OpCode.Stind_i4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int32Ref));  			break;  		case PE.OpCode.Stind_i8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int64Ref));  			break;  		case PE.OpCode.Stind_i:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.IntNativeRef));  			break;  		case PE.OpCode.Stind_r4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.SingleRef));  			break;  		case PE.OpCode.Stind_r8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.DoubleRef));  			break;  		case PE.OpCode.Stobj:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Cpobj:  			instructions.Add (new TypeInstruction (offset' TypeOp.Cpobj' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Newarr:  			instructions.Add (new TypeInstruction (offset' TypeOp.Newarr' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Initobj:  			instructions.Add (new TypeInstruction (offset' TypeOp.Initobj' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Castclass:  			instructions.Add (new TypeInstruction (offset' TypeOp.Castclass' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Isinst:  			instructions.Add (new TypeInstruction (offset' TypeOp.Isinst' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Box:  			instructions.Add (new TypeInstruction (offset' TypeOp.Box' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Unbox:  			instructions.Add (new TypeInstruction (offset' TypeOp.Unbox' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Unbox_any:  			instructions.Add (new TypeInstruction (offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Ldelem_i1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int8Ref));  			break;  		case PE.OpCode.Ldelem_u1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt8Ref));  			break;  		case PE.OpCode.Ldelem_i2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int16Ref));  			break;  		case PE.OpCode.Ldelem_u2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt16Ref));  			break;  		case PE.OpCode.Ldelem_i4:  		case PE.OpCode.Ldelem_u4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int32Ref));  			break;  		case PE.OpCode.Ldelem_i:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.IntNativeRef));  			break;  		case PE.OpCode.Ldelem_i8:  			// aka ldelem.u8  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int64Ref));  			break;  		case PE.OpCode.Ldelem_r4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.SingleRef));  			break;  		case PE.OpCode.Ldelem_r8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.DoubleRef));  			break;  		case PE.OpCode.Ldelem:  			// aka ldelem.any  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Stelem_i1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int8Ref));  			break;  		case PE.OpCode.Stelem_i2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int16Ref));  			break;  		case PE.OpCode.Stelem_i4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int32Ref));  			break;  		case PE.OpCode.Stelem_i8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int64Ref));  			break;  		case PE.OpCode.Stelem_i:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.IntNativeRef));  			break;  		case PE.OpCode.Stelem_r4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.SingleRef));  			break;  		case PE.OpCode.Stelem_r8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.DoubleRef));  			break;  		case PE.OpCode.Stelem:  			// aka stelem.any  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Readonly:  			if (i >= ctxt.Instructions.Length)  				throw new InvalidOperationException ("invalid instruction");  			instruction = ctxt.Instructions [i++];  			if (instruction.OpCode != PE.OpCode.Ldelema)  				throw new InvalidOperationException ("invalid instruction");  			instructions.Add (new LdElemAddrInstruction (offset' true' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Ldelema:  			instructions.Add (new LdElemAddrInstruction (offset' false' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Ldc_i4_0:  			instructions.Add (new LdInt32Instruction (offset' 0));  			break;  		case PE.OpCode.Ldc_i4_1:  			instructions.Add (new LdInt32Instruction (offset' 1));  			break;  		case PE.OpCode.Ldc_i4_2:  			instructions.Add (new LdInt32Instruction (offset' 2));  			break;  		case PE.OpCode.Ldc_i4_3:  			instructions.Add (new LdInt32Instruction (offset' 3));  			break;  		case PE.OpCode.Ldc_i4_4:  			instructions.Add (new LdInt32Instruction (offset' 4));  			break;  		case PE.OpCode.Ldc_i4_5:  			instructions.Add (new LdInt32Instruction (offset' 5));  			break;  		case PE.OpCode.Ldc_i4_6:  			instructions.Add (new LdInt32Instruction (offset' 6));  			break;  		case PE.OpCode.Ldc_i4_7:  			instructions.Add (new LdInt32Instruction (offset' 7));  			break;  		case PE.OpCode.Ldc_i4_8:  			instructions.Add (new LdInt32Instruction (offset' 8));  			break;  		case PE.OpCode.Ldc_i4_m1:  			instructions.Add (new LdInt32Instruction (offset' -1));  			break;  		case PE.OpCode.Ldc_i4:  		case PE.OpCode.Ldc_i4_s:  			instructions.Add (new LdInt32Instruction (offset' (int)instruction.Value));  			break;  		case PE.OpCode.Ldc_i8:  			instructions.Add (new LdInt64Instruction (offset' (long)instruction.Value));  			break;  		case PE.OpCode.Ldc_r4:  			instructions.Add (new LdSingleInstruction (offset' (float)instruction.Value));  			break;  		case PE.OpCode.Ldc_r8:  			instructions.Add (new LdDoubleInstruction (offset' (double)instruction.Value));  			break;  		case PE.OpCode.Ldstr:  			instructions.Add (new LdStringInstruction (offset' (string)instruction.Value));  			break;  		case PE.OpCode.Add:  			instructions.Add (new ArithInstruction (offset' ArithOp.Add' false' false));  			break;  		case PE.OpCode.Add_ovf:  			instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' false));  			break;  		case PE.OpCode.Add_ovf_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' true));  			break;  		case PE.OpCode.Sub:  			instructions.Add (new ArithInstruction (offset' ArithOp.Sub' false' false));  			break;  		case PE.OpCode.Sub_ovf:  			instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' false));  			break;  		case PE.OpCode.Sub_ovf_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' true));  			break;  		case PE.OpCode.Mul:  			instructions.Add (new ArithInstruction (offset' ArithOp.Mul' false' false));  			break;  		case PE.OpCode.Mul_ovf:  			instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' false));  			break;  		case PE.OpCode.Mul_ovf_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' true));  			break;  		case PE.OpCode.Div:  			instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' false));  			break;  		case PE.OpCode.Div_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' true));  			break;  		case PE.OpCode.Rem:  			instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' false));  			break;  		case PE.OpCode.Rem_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' true));  			break;  		case PE.OpCode.Neg:  			instructions.Add (new ArithInstruction (offset' ArithOp.Neg' false' false));  			break;  		case PE.OpCode.And:  			instructions.Add (new ArithInstruction (offset' ArithOp.BitAnd' false' false));  			break;  		case PE.OpCode.Or:  			instructions.Add (new ArithInstruction (offset' ArithOp.BitOr' false' false));  			break;  		case PE.OpCode.Xor:  			instructions.Add (new ArithInstruction (offset' ArithOp.BitXor' false' false));  			break;  		case PE.OpCode.Not:  			instructions.Add (new ArithInstruction (offset' ArithOp.BitNot' false' false));  			break;  		case PE.OpCode.Shl:  			instructions.Add (new ArithInstruction (offset' ArithOp.Shl' false' false));  			break;  		case PE.OpCode.Shr:  			instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' false));  			break;  		case PE.OpCode.Shr_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' true));  			break;  		case PE.OpCode.Conv_i1:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' false' false));  			break;  		case PE.OpCode.Conv_u1:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' false' false));  			break;  		case PE.OpCode.Conv_i2:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' false' false));  			break;  		case PE.OpCode.Conv_u2:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' false' false));  			break;  		case PE.OpCode.Conv_i4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' false' false));  			break;  		case PE.OpCode.Conv_u4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' false' false));  			break;  		case PE.OpCode.Conv_i8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' false' false));  			break;  		case PE.OpCode.Conv_u8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' false' false));  			break;  		case PE.OpCode.Conv_i:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' false' false));  			break;  		case PE.OpCode.Conv_u:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' false' false));  			break;  		case PE.OpCode.Conv_r4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Single' false' false));  			break;  		case PE.OpCode.Conv_r8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' false));  			break;  		case PE.OpCode.Conv_r_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' true));  			break;  		case PE.OpCode.Conv_ovf_i1:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' false));  			break;  		case PE.OpCode.Conv_ovf_u1:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' false));  			break;  		case PE.OpCode.Conv_ovf_i2:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' false));  			break;  		case PE.OpCode.Conv_ovf_u2:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' false));  			break;  		case PE.OpCode.Conv_ovf_i4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' false));  			break;  		case PE.OpCode.Conv_ovf_u4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' false));  			break;  		case PE.OpCode.Conv_ovf_i8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' false));  			break;  		case PE.OpCode.Conv_ovf_u8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' false));  			break;  		case PE.OpCode.Conv_ovf_i:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' false));  			break;  		case PE.OpCode.Conv_ovf_u:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' false));  			break;  		case PE.OpCode.Conv_ovf_i1_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' true));  			break;  		case PE.OpCode.Conv_ovf_u1_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' true));  			break;  		case PE.OpCode.Conv_ovf_i2_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' true));  			break;  		case PE.OpCode.Conv_ovf_u2_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' true));  			break;  		case PE.OpCode.Conv_ovf_i4_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' true));  			break;  		case PE.OpCode.Conv_ovf_u4_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' true));  			break;  		case PE.OpCode.Conv_ovf_i8_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' true));  			break;  		case PE.OpCode.Conv_ovf_u8_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' true));  			break;  		case PE.OpCode.Conv_ovf_i_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' true));  			break;  		case PE.OpCode.Conv_ovf_u_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' true));  			break;  		default:  			throw new InvalidOperationException ("invalid instruction");  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: if (j > i)  	i = j;  else {  	var ehcs = ctxt.OutermostTryBlocks (i);  	if (ehcs != null) {  		// A try instruction begins here with given handlers  		var offset = ctxt.Instructions [i].Offset;  		var tryCtxt = new TryTranslationContext (ctxt' i' ehcs);  		var tryBlock = InstructionsFromContext (tryCtxt);  		var handlers = new Seq<TryInstructionHandler> ();  		foreach (var ehc in ehcs) {  			var handlerCtxt = new HandlerTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.HandlerOffset]' ehc);  			var handlerBlock = InstructionsFromContext (handlerCtxt);  			switch (ehc.Flags) {  			case PE.CorILExceptionClause.Exception:  				handlers.Add (new CatchTryInstructionHandler ((TypeRef)ehc.Class' handlerBlock));  				break;  			case PE.CorILExceptionClause.Filter: {  				var filterCtxt = new FilterTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.FilterOffset]' ehc);  				var filterBlock = InstructionsFromContext (filterCtxt);  				handlers.Add (new FilterTryInstructionHandler (filterBlock' handlerBlock));  				break;  			}  			case PE.CorILExceptionClause.Finally:  				handlers.Add (new FinallyTryInstructionHandler (handlerBlock));  				break;  			case PE.CorILExceptionClause.Fault:  				handlers.Add (new FaultTryInstructionHandler (handlerBlock));  				break;  			default:  				throw new ArgumentOutOfRangeException ();  			}  		}  		instructions.Add (new TryInstruction (offset' tryBlock' handlers));  		// Jump over try block  		var nextOffset = ehcs [0].TryOffset + ehcs [0].TryLength;  		if (!ctxt.OffsetToIndex.TryGetValue (nextOffset' out i))  			i = ctxt.Instructions.Length;  	}  	else {  		var instruction = ctxt.Instructions [i++];  		var offset = instruction.Offset;  		while (instruction.OpCode == PE.OpCode.Unaligned || instruction.OpCode == PE.OpCode.Volatile || instruction.OpCode == PE.OpCode.Tailcall) {  			// Skip over any ignored prefixes' but remember instruction begins at original offset  			// NOTE: What ever happened to the "no." prefix mentioned in the spec?  			if (i >= ctxt.Instructions.Length)  				throw new InvalidOperationException ("invalid instructions");  			instruction = ctxt.Instructions [i++];  		}  		switch (instruction.OpCode) {  		case PE.OpCode.Cpblk:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Cpblk));  			break;  		case PE.OpCode.Initblk:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Initblk));  			break;  		case PE.OpCode.Arglist:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Arglist));  			break;  		case PE.OpCode.Localloc:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Localloc));  			break;  		case PE.OpCode.Jmp:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Jmp));  			break;  		case PE.OpCode.Calli:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Calli));  			break;  		case PE.OpCode.Sizeof:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Sizeof));  			break;  		case PE.OpCode.Mkrefany:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Mkrefany));  			break;  		case PE.OpCode.Refanytype:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanytype));  			break;  		case PE.OpCode.Refanyval:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanyval));  			break;  		case PE.OpCode.Nop:  			instructions.Add (new MiscInstruction (offset' MiscOp.Nop));  			break;  		case PE.OpCode.Break:  			instructions.Add (new MiscInstruction (offset' MiscOp.Break));  			break;  		case PE.OpCode.Dup:  			instructions.Add (new MiscInstruction (offset' MiscOp.Dup));  			break;  		case PE.OpCode.Pop:  			instructions.Add (new MiscInstruction (offset' MiscOp.Pop));  			break;  		case PE.OpCode.Ldnull:  			instructions.Add (new MiscInstruction (offset' MiscOp.Ldnull));  			break;  		case PE.OpCode.Ckfinite:  			instructions.Add (new MiscInstruction (offset' MiscOp.Ckfinite));  			break;  		case PE.OpCode.Throw:  			instructions.Add (new MiscInstruction (offset' MiscOp.Throw));  			break;  		case PE.OpCode.Rethrow:  			instructions.Add (new MiscInstruction (offset' MiscOp.Rethrow));  			break;  		case PE.OpCode.Ldind_ref:  			instructions.Add (new MiscInstruction (offset' MiscOp.LdindRef));  			break;  		case PE.OpCode.Stind_ref:  			instructions.Add (new MiscInstruction (offset' MiscOp.StindRef));  			break;  		case PE.OpCode.Ldelem_ref:  			instructions.Add (new MiscInstruction (offset' MiscOp.LdelemRef));  			break;  		case PE.OpCode.Stelem_ref:  			instructions.Add (new MiscInstruction (offset' MiscOp.StelemRef));  			break;  		case PE.OpCode.Ldlen:  			instructions.Add (new MiscInstruction (offset' MiscOp.Ldlen));  			break;  		case PE.OpCode.Ret:  			if (ctxt.ResultType == null)  				instructions.Add (new MiscInstruction (offset' MiscOp.Ret));  			else  				instructions.Add (new MiscInstruction (offset' MiscOp.RetVal));  			break;  		case PE.OpCode.Endfilter:  			instructions.Add (new MiscInstruction (offset' MiscOp.Endfilter));  			break;  		case PE.OpCode.Endfinally:  			// aka EndFault  			instructions.Add (new MiscInstruction (offset' MiscOp.Endfinally));  			break;  		case PE.OpCode.Br_s:  		case PE.OpCode.Br:  			instructions.Add (new BranchInstruction (offset' BranchOp.Br' false' (int)instruction.Value));  			break;  		case PE.OpCode.Brtrue_s:  		// aka brinst.s  		case PE.OpCode.Brtrue:  			// aka brinst  			instructions.Add (new BranchInstruction (offset' BranchOp.Brtrue' false' (int)instruction.Value));  			break;  		case PE.OpCode.Brfalse_s:  		// aka brzero.s' brnull.s  		case PE.OpCode.Brfalse:  			// aka brzero' brnull  			instructions.Add (new BranchInstruction (offset' BranchOp.Brfalse' false' (int)instruction.Value));  			break;  		case PE.OpCode.Beq:  		case PE.OpCode.Beq_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.Breq' false' (int)instruction.Value));  			break;  		case PE.OpCode.Bne_un:  		case PE.OpCode.Bne_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.Brne' false' (int)instruction.Value));  			break;  		case PE.OpCode.Leave:  		case PE.OpCode.Leave_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.Leave' false' (int)instruction.Value));  			break;  		case PE.OpCode.Blt:  		case PE.OpCode.Blt_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' false' (int)instruction.Value));  			break;  		case PE.OpCode.Blt_un:  		case PE.OpCode.Blt_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' true' (int)instruction.Value));  			break;  		case PE.OpCode.Ble:  		case PE.OpCode.Ble_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' false' (int)instruction.Value));  			break;  		case PE.OpCode.Ble_un:  		case PE.OpCode.Ble_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' true' (int)instruction.Value));  			break;  		case PE.OpCode.Bgt:  		case PE.OpCode.Bgt_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' false' (int)instruction.Value));  			break;  		case PE.OpCode.Bgt_un:  		case PE.OpCode.Bgt_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' true' (int)instruction.Value));  			break;  		case PE.OpCode.Bge:  		case PE.OpCode.Bge_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' false' (int)instruction.Value));  			break;  		case PE.OpCode.Bge_un:  		case PE.OpCode.Bge_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' true' (int)instruction.Value));  			break;  		case PE.OpCode.Switch:  			instructions.Add (new SwitchInstruction (offset' (Seq<int>)instruction.Value));  			break;  		case PE.OpCode.Ceq:  			instructions.Add (new CompareInstruction (offset' CompareOp.Ceq' false));  			break;  		case PE.OpCode.Clt:  			instructions.Add (new CompareInstruction (offset' CompareOp.Clt' false));  			break;  		case PE.OpCode.Clt_un:  			instructions.Add (new CompareInstruction (offset' CompareOp.Clt' true));  			break;  		case PE.OpCode.Cgt:  			instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' false));  			break;  		case PE.OpCode.Cgt_un:  			instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' true));  			break;  		case PE.OpCode.Ldarg_0:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));  			break;  		case PE.OpCode.Ldarg_1:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));  			break;  		case PE.OpCode.Ldarg_2:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));  			break;  		case PE.OpCode.Ldarg_3:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));  			break;  		case PE.OpCode.Ldarg:  		case PE.OpCode.Ldarg_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));  			break;  		case PE.OpCode.Ldarga:  		case PE.OpCode.Ldarga_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));  			break;  		case PE.OpCode.Starg:  		case PE.OpCode.Starg_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));  			break;  		case PE.OpCode.Ldloc_0:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 0));  			break;  		case PE.OpCode.Ldloc_1:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 1));  			break;  		case PE.OpCode.Ldloc_2:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 2));  			break;  		case PE.OpCode.Ldloc_3:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 3));  			break;  		case PE.OpCode.Ldloc:  		case PE.OpCode.Ldloc_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));  			break;  		case PE.OpCode.Ldloca:  		case PE.OpCode.Ldloca_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));  			break;  		case PE.OpCode.Stloc_0:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 0));  			break;  		case PE.OpCode.Stloc_1:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 1));  			break;  		case PE.OpCode.Stloc_2:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 2));  			break;  		case PE.OpCode.Stloc_3:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 3));  			break;  		case PE.OpCode.Stloc:  		case PE.OpCode.Stloc_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));  			break;  		case PE.OpCode.Ldfld:  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));  			break;  		case PE.OpCode.Ldsfld:  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));  			break;  		case PE.OpCode.Ldflda:  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));  			break;  		case PE.OpCode.Ldsflda:  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));  			break;  		case PE.OpCode.Stfld:  			instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));  			break;  		case PE.OpCode.Stsfld:  			instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));  			break;  		case PE.OpCode.Ldtoken: {  			if (instruction.Value is FieldRef)  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));  			else if (instruction.Value is MethodRef)  				instructions.Add (new MethodInstruction (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));  			else if (instruction.Value is TypeRef)  				// NOTE: May be a higher-kinded type  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));  			else  				throw new InvalidOperationException ("unexpected ldtoken instruction value");  			break;  		}  		case PE.OpCode.Constrained: {  			var constrained = (TypeRef)instruction.Value;  			if (i >= ctxt.Instructions.Length)  				throw new InvalidOperationException ("invalid instructions");  			instruction = ctxt.Instructions [i++];  			if (instruction.OpCode != PE.OpCode.Callvirt)  				throw new InvalidOperationException ("invalid instruction");  			instructions.Add (new MethodInstruction (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));  			break;  		}  		case PE.OpCode.Call:  			instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Callvirt:  			instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Ldftn:  			instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Ldvirtftn:  			instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Newobj:  			instructions.Add (new MethodInstruction (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Ldind_i1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int8Ref));  			break;  		case PE.OpCode.Ldind_u1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt8Ref));  			break;  		case PE.OpCode.Ldind_i2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int16Ref));  			break;  		case PE.OpCode.Ldind_u2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt16Ref));  			break;  		case PE.OpCode.Ldind_i4:  		case PE.OpCode.Ldind_u4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int32Ref));  			break;  		case PE.OpCode.Ldind_i8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int64Ref));  			break;  		case PE.OpCode.Ldind_i:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.IntNativeRef));  			break;  		case PE.OpCode.Ldind_r4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.SingleRef));  			break;  		case PE.OpCode.Ldind_r8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.DoubleRef));  			break;  		case PE.OpCode.Ldobj:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Stind_i1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int8Ref));  			break;  		case PE.OpCode.Stind_i2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int16Ref));  			break;  		case PE.OpCode.Stind_i4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int32Ref));  			break;  		case PE.OpCode.Stind_i8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int64Ref));  			break;  		case PE.OpCode.Stind_i:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.IntNativeRef));  			break;  		case PE.OpCode.Stind_r4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.SingleRef));  			break;  		case PE.OpCode.Stind_r8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.DoubleRef));  			break;  		case PE.OpCode.Stobj:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Cpobj:  			instructions.Add (new TypeInstruction (offset' TypeOp.Cpobj' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Newarr:  			instructions.Add (new TypeInstruction (offset' TypeOp.Newarr' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Initobj:  			instructions.Add (new TypeInstruction (offset' TypeOp.Initobj' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Castclass:  			instructions.Add (new TypeInstruction (offset' TypeOp.Castclass' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Isinst:  			instructions.Add (new TypeInstruction (offset' TypeOp.Isinst' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Box:  			instructions.Add (new TypeInstruction (offset' TypeOp.Box' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Unbox:  			instructions.Add (new TypeInstruction (offset' TypeOp.Unbox' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Unbox_any:  			instructions.Add (new TypeInstruction (offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Ldelem_i1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int8Ref));  			break;  		case PE.OpCode.Ldelem_u1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt8Ref));  			break;  		case PE.OpCode.Ldelem_i2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int16Ref));  			break;  		case PE.OpCode.Ldelem_u2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt16Ref));  			break;  		case PE.OpCode.Ldelem_i4:  		case PE.OpCode.Ldelem_u4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int32Ref));  			break;  		case PE.OpCode.Ldelem_i:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.IntNativeRef));  			break;  		case PE.OpCode.Ldelem_i8:  			// aka ldelem.u8  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int64Ref));  			break;  		case PE.OpCode.Ldelem_r4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.SingleRef));  			break;  		case PE.OpCode.Ldelem_r8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.DoubleRef));  			break;  		case PE.OpCode.Ldelem:  			// aka ldelem.any  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Stelem_i1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int8Ref));  			break;  		case PE.OpCode.Stelem_i2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int16Ref));  			break;  		case PE.OpCode.Stelem_i4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int32Ref));  			break;  		case PE.OpCode.Stelem_i8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int64Ref));  			break;  		case PE.OpCode.Stelem_i:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.IntNativeRef));  			break;  		case PE.OpCode.Stelem_r4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.SingleRef));  			break;  		case PE.OpCode.Stelem_r8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.DoubleRef));  			break;  		case PE.OpCode.Stelem:  			// aka stelem.any  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Readonly:  			if (i >= ctxt.Instructions.Length)  				throw new InvalidOperationException ("invalid instruction");  			instruction = ctxt.Instructions [i++];  			if (instruction.OpCode != PE.OpCode.Ldelema)  				throw new InvalidOperationException ("invalid instruction");  			instructions.Add (new LdElemAddrInstruction (offset' true' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Ldelema:  			instructions.Add (new LdElemAddrInstruction (offset' false' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Ldc_i4_0:  			instructions.Add (new LdInt32Instruction (offset' 0));  			break;  		case PE.OpCode.Ldc_i4_1:  			instructions.Add (new LdInt32Instruction (offset' 1));  			break;  		case PE.OpCode.Ldc_i4_2:  			instructions.Add (new LdInt32Instruction (offset' 2));  			break;  		case PE.OpCode.Ldc_i4_3:  			instructions.Add (new LdInt32Instruction (offset' 3));  			break;  		case PE.OpCode.Ldc_i4_4:  			instructions.Add (new LdInt32Instruction (offset' 4));  			break;  		case PE.OpCode.Ldc_i4_5:  			instructions.Add (new LdInt32Instruction (offset' 5));  			break;  		case PE.OpCode.Ldc_i4_6:  			instructions.Add (new LdInt32Instruction (offset' 6));  			break;  		case PE.OpCode.Ldc_i4_7:  			instructions.Add (new LdInt32Instruction (offset' 7));  			break;  		case PE.OpCode.Ldc_i4_8:  			instructions.Add (new LdInt32Instruction (offset' 8));  			break;  		case PE.OpCode.Ldc_i4_m1:  			instructions.Add (new LdInt32Instruction (offset' -1));  			break;  		case PE.OpCode.Ldc_i4:  		case PE.OpCode.Ldc_i4_s:  			instructions.Add (new LdInt32Instruction (offset' (int)instruction.Value));  			break;  		case PE.OpCode.Ldc_i8:  			instructions.Add (new LdInt64Instruction (offset' (long)instruction.Value));  			break;  		case PE.OpCode.Ldc_r4:  			instructions.Add (new LdSingleInstruction (offset' (float)instruction.Value));  			break;  		case PE.OpCode.Ldc_r8:  			instructions.Add (new LdDoubleInstruction (offset' (double)instruction.Value));  			break;  		case PE.OpCode.Ldstr:  			instructions.Add (new LdStringInstruction (offset' (string)instruction.Value));  			break;  		case PE.OpCode.Add:  			instructions.Add (new ArithInstruction (offset' ArithOp.Add' false' false));  			break;  		case PE.OpCode.Add_ovf:  			instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' false));  			break;  		case PE.OpCode.Add_ovf_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' true));  			break;  		case PE.OpCode.Sub:  			instructions.Add (new ArithInstruction (offset' ArithOp.Sub' false' false));  			break;  		case PE.OpCode.Sub_ovf:  			instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' false));  			break;  		case PE.OpCode.Sub_ovf_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' true));  			break;  		case PE.OpCode.Mul:  			instructions.Add (new ArithInstruction (offset' ArithOp.Mul' false' false));  			break;  		case PE.OpCode.Mul_ovf:  			instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' false));  			break;  		case PE.OpCode.Mul_ovf_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' true));  			break;  		case PE.OpCode.Div:  			instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' false));  			break;  		case PE.OpCode.Div_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' true));  			break;  		case PE.OpCode.Rem:  			instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' false));  			break;  		case PE.OpCode.Rem_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' true));  			break;  		case PE.OpCode.Neg:  			instructions.Add (new ArithInstruction (offset' ArithOp.Neg' false' false));  			break;  		case PE.OpCode.And:  			instructions.Add (new ArithInstruction (offset' ArithOp.BitAnd' false' false));  			break;  		case PE.OpCode.Or:  			instructions.Add (new ArithInstruction (offset' ArithOp.BitOr' false' false));  			break;  		case PE.OpCode.Xor:  			instructions.Add (new ArithInstruction (offset' ArithOp.BitXor' false' false));  			break;  		case PE.OpCode.Not:  			instructions.Add (new ArithInstruction (offset' ArithOp.BitNot' false' false));  			break;  		case PE.OpCode.Shl:  			instructions.Add (new ArithInstruction (offset' ArithOp.Shl' false' false));  			break;  		case PE.OpCode.Shr:  			instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' false));  			break;  		case PE.OpCode.Shr_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' true));  			break;  		case PE.OpCode.Conv_i1:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' false' false));  			break;  		case PE.OpCode.Conv_u1:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' false' false));  			break;  		case PE.OpCode.Conv_i2:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' false' false));  			break;  		case PE.OpCode.Conv_u2:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' false' false));  			break;  		case PE.OpCode.Conv_i4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' false' false));  			break;  		case PE.OpCode.Conv_u4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' false' false));  			break;  		case PE.OpCode.Conv_i8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' false' false));  			break;  		case PE.OpCode.Conv_u8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' false' false));  			break;  		case PE.OpCode.Conv_i:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' false' false));  			break;  		case PE.OpCode.Conv_u:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' false' false));  			break;  		case PE.OpCode.Conv_r4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Single' false' false));  			break;  		case PE.OpCode.Conv_r8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' false));  			break;  		case PE.OpCode.Conv_r_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' true));  			break;  		case PE.OpCode.Conv_ovf_i1:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' false));  			break;  		case PE.OpCode.Conv_ovf_u1:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' false));  			break;  		case PE.OpCode.Conv_ovf_i2:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' false));  			break;  		case PE.OpCode.Conv_ovf_u2:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' false));  			break;  		case PE.OpCode.Conv_ovf_i4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' false));  			break;  		case PE.OpCode.Conv_ovf_u4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' false));  			break;  		case PE.OpCode.Conv_ovf_i8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' false));  			break;  		case PE.OpCode.Conv_ovf_u8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' false));  			break;  		case PE.OpCode.Conv_ovf_i:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' false));  			break;  		case PE.OpCode.Conv_ovf_u:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' false));  			break;  		case PE.OpCode.Conv_ovf_i1_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' true));  			break;  		case PE.OpCode.Conv_ovf_u1_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' true));  			break;  		case PE.OpCode.Conv_ovf_i2_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' true));  			break;  		case PE.OpCode.Conv_ovf_u2_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' true));  			break;  		case PE.OpCode.Conv_ovf_i4_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' true));  			break;  		case PE.OpCode.Conv_ovf_u4_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' true));  			break;  		case PE.OpCode.Conv_ovf_i8_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' true));  			break;  		case PE.OpCode.Conv_ovf_u8_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' true));  			break;  		case PE.OpCode.Conv_ovf_i_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' true));  			break;  		case PE.OpCode.Conv_ovf_u_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' true));  			break;  		default:  			throw new InvalidOperationException ("invalid instruction");  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: if (j > i)  	i = j;  else {  	var ehcs = ctxt.OutermostTryBlocks (i);  	if (ehcs != null) {  		// A try instruction begins here with given handlers  		var offset = ctxt.Instructions [i].Offset;  		var tryCtxt = new TryTranslationContext (ctxt' i' ehcs);  		var tryBlock = InstructionsFromContext (tryCtxt);  		var handlers = new Seq<TryInstructionHandler> ();  		foreach (var ehc in ehcs) {  			var handlerCtxt = new HandlerTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.HandlerOffset]' ehc);  			var handlerBlock = InstructionsFromContext (handlerCtxt);  			switch (ehc.Flags) {  			case PE.CorILExceptionClause.Exception:  				handlers.Add (new CatchTryInstructionHandler ((TypeRef)ehc.Class' handlerBlock));  				break;  			case PE.CorILExceptionClause.Filter: {  				var filterCtxt = new FilterTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.FilterOffset]' ehc);  				var filterBlock = InstructionsFromContext (filterCtxt);  				handlers.Add (new FilterTryInstructionHandler (filterBlock' handlerBlock));  				break;  			}  			case PE.CorILExceptionClause.Finally:  				handlers.Add (new FinallyTryInstructionHandler (handlerBlock));  				break;  			case PE.CorILExceptionClause.Fault:  				handlers.Add (new FaultTryInstructionHandler (handlerBlock));  				break;  			default:  				throw new ArgumentOutOfRangeException ();  			}  		}  		instructions.Add (new TryInstruction (offset' tryBlock' handlers));  		// Jump over try block  		var nextOffset = ehcs [0].TryOffset + ehcs [0].TryLength;  		if (!ctxt.OffsetToIndex.TryGetValue (nextOffset' out i))  			i = ctxt.Instructions.Length;  	}  	else {  		var instruction = ctxt.Instructions [i++];  		var offset = instruction.Offset;  		while (instruction.OpCode == PE.OpCode.Unaligned || instruction.OpCode == PE.OpCode.Volatile || instruction.OpCode == PE.OpCode.Tailcall) {  			// Skip over any ignored prefixes' but remember instruction begins at original offset  			// NOTE: What ever happened to the "no." prefix mentioned in the spec?  			if (i >= ctxt.Instructions.Length)  				throw new InvalidOperationException ("invalid instructions");  			instruction = ctxt.Instructions [i++];  		}  		switch (instruction.OpCode) {  		case PE.OpCode.Cpblk:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Cpblk));  			break;  		case PE.OpCode.Initblk:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Initblk));  			break;  		case PE.OpCode.Arglist:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Arglist));  			break;  		case PE.OpCode.Localloc:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Localloc));  			break;  		case PE.OpCode.Jmp:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Jmp));  			break;  		case PE.OpCode.Calli:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Calli));  			break;  		case PE.OpCode.Sizeof:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Sizeof));  			break;  		case PE.OpCode.Mkrefany:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Mkrefany));  			break;  		case PE.OpCode.Refanytype:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanytype));  			break;  		case PE.OpCode.Refanyval:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanyval));  			break;  		case PE.OpCode.Nop:  			instructions.Add (new MiscInstruction (offset' MiscOp.Nop));  			break;  		case PE.OpCode.Break:  			instructions.Add (new MiscInstruction (offset' MiscOp.Break));  			break;  		case PE.OpCode.Dup:  			instructions.Add (new MiscInstruction (offset' MiscOp.Dup));  			break;  		case PE.OpCode.Pop:  			instructions.Add (new MiscInstruction (offset' MiscOp.Pop));  			break;  		case PE.OpCode.Ldnull:  			instructions.Add (new MiscInstruction (offset' MiscOp.Ldnull));  			break;  		case PE.OpCode.Ckfinite:  			instructions.Add (new MiscInstruction (offset' MiscOp.Ckfinite));  			break;  		case PE.OpCode.Throw:  			instructions.Add (new MiscInstruction (offset' MiscOp.Throw));  			break;  		case PE.OpCode.Rethrow:  			instructions.Add (new MiscInstruction (offset' MiscOp.Rethrow));  			break;  		case PE.OpCode.Ldind_ref:  			instructions.Add (new MiscInstruction (offset' MiscOp.LdindRef));  			break;  		case PE.OpCode.Stind_ref:  			instructions.Add (new MiscInstruction (offset' MiscOp.StindRef));  			break;  		case PE.OpCode.Ldelem_ref:  			instructions.Add (new MiscInstruction (offset' MiscOp.LdelemRef));  			break;  		case PE.OpCode.Stelem_ref:  			instructions.Add (new MiscInstruction (offset' MiscOp.StelemRef));  			break;  		case PE.OpCode.Ldlen:  			instructions.Add (new MiscInstruction (offset' MiscOp.Ldlen));  			break;  		case PE.OpCode.Ret:  			if (ctxt.ResultType == null)  				instructions.Add (new MiscInstruction (offset' MiscOp.Ret));  			else  				instructions.Add (new MiscInstruction (offset' MiscOp.RetVal));  			break;  		case PE.OpCode.Endfilter:  			instructions.Add (new MiscInstruction (offset' MiscOp.Endfilter));  			break;  		case PE.OpCode.Endfinally:  			// aka EndFault  			instructions.Add (new MiscInstruction (offset' MiscOp.Endfinally));  			break;  		case PE.OpCode.Br_s:  		case PE.OpCode.Br:  			instructions.Add (new BranchInstruction (offset' BranchOp.Br' false' (int)instruction.Value));  			break;  		case PE.OpCode.Brtrue_s:  		// aka brinst.s  		case PE.OpCode.Brtrue:  			// aka brinst  			instructions.Add (new BranchInstruction (offset' BranchOp.Brtrue' false' (int)instruction.Value));  			break;  		case PE.OpCode.Brfalse_s:  		// aka brzero.s' brnull.s  		case PE.OpCode.Brfalse:  			// aka brzero' brnull  			instructions.Add (new BranchInstruction (offset' BranchOp.Brfalse' false' (int)instruction.Value));  			break;  		case PE.OpCode.Beq:  		case PE.OpCode.Beq_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.Breq' false' (int)instruction.Value));  			break;  		case PE.OpCode.Bne_un:  		case PE.OpCode.Bne_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.Brne' false' (int)instruction.Value));  			break;  		case PE.OpCode.Leave:  		case PE.OpCode.Leave_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.Leave' false' (int)instruction.Value));  			break;  		case PE.OpCode.Blt:  		case PE.OpCode.Blt_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' false' (int)instruction.Value));  			break;  		case PE.OpCode.Blt_un:  		case PE.OpCode.Blt_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' true' (int)instruction.Value));  			break;  		case PE.OpCode.Ble:  		case PE.OpCode.Ble_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' false' (int)instruction.Value));  			break;  		case PE.OpCode.Ble_un:  		case PE.OpCode.Ble_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' true' (int)instruction.Value));  			break;  		case PE.OpCode.Bgt:  		case PE.OpCode.Bgt_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' false' (int)instruction.Value));  			break;  		case PE.OpCode.Bgt_un:  		case PE.OpCode.Bgt_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' true' (int)instruction.Value));  			break;  		case PE.OpCode.Bge:  		case PE.OpCode.Bge_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' false' (int)instruction.Value));  			break;  		case PE.OpCode.Bge_un:  		case PE.OpCode.Bge_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' true' (int)instruction.Value));  			break;  		case PE.OpCode.Switch:  			instructions.Add (new SwitchInstruction (offset' (Seq<int>)instruction.Value));  			break;  		case PE.OpCode.Ceq:  			instructions.Add (new CompareInstruction (offset' CompareOp.Ceq' false));  			break;  		case PE.OpCode.Clt:  			instructions.Add (new CompareInstruction (offset' CompareOp.Clt' false));  			break;  		case PE.OpCode.Clt_un:  			instructions.Add (new CompareInstruction (offset' CompareOp.Clt' true));  			break;  		case PE.OpCode.Cgt:  			instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' false));  			break;  		case PE.OpCode.Cgt_un:  			instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' true));  			break;  		case PE.OpCode.Ldarg_0:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));  			break;  		case PE.OpCode.Ldarg_1:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));  			break;  		case PE.OpCode.Ldarg_2:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));  			break;  		case PE.OpCode.Ldarg_3:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));  			break;  		case PE.OpCode.Ldarg:  		case PE.OpCode.Ldarg_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));  			break;  		case PE.OpCode.Ldarga:  		case PE.OpCode.Ldarga_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));  			break;  		case PE.OpCode.Starg:  		case PE.OpCode.Starg_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));  			break;  		case PE.OpCode.Ldloc_0:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 0));  			break;  		case PE.OpCode.Ldloc_1:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 1));  			break;  		case PE.OpCode.Ldloc_2:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 2));  			break;  		case PE.OpCode.Ldloc_3:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 3));  			break;  		case PE.OpCode.Ldloc:  		case PE.OpCode.Ldloc_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));  			break;  		case PE.OpCode.Ldloca:  		case PE.OpCode.Ldloca_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));  			break;  		case PE.OpCode.Stloc_0:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 0));  			break;  		case PE.OpCode.Stloc_1:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 1));  			break;  		case PE.OpCode.Stloc_2:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 2));  			break;  		case PE.OpCode.Stloc_3:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 3));  			break;  		case PE.OpCode.Stloc:  		case PE.OpCode.Stloc_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));  			break;  		case PE.OpCode.Ldfld:  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));  			break;  		case PE.OpCode.Ldsfld:  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));  			break;  		case PE.OpCode.Ldflda:  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));  			break;  		case PE.OpCode.Ldsflda:  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));  			break;  		case PE.OpCode.Stfld:  			instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));  			break;  		case PE.OpCode.Stsfld:  			instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));  			break;  		case PE.OpCode.Ldtoken: {  			if (instruction.Value is FieldRef)  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));  			else if (instruction.Value is MethodRef)  				instructions.Add (new MethodInstruction (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));  			else if (instruction.Value is TypeRef)  				// NOTE: May be a higher-kinded type  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));  			else  				throw new InvalidOperationException ("unexpected ldtoken instruction value");  			break;  		}  		case PE.OpCode.Constrained: {  			var constrained = (TypeRef)instruction.Value;  			if (i >= ctxt.Instructions.Length)  				throw new InvalidOperationException ("invalid instructions");  			instruction = ctxt.Instructions [i++];  			if (instruction.OpCode != PE.OpCode.Callvirt)  				throw new InvalidOperationException ("invalid instruction");  			instructions.Add (new MethodInstruction (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));  			break;  		}  		case PE.OpCode.Call:  			instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Callvirt:  			instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Ldftn:  			instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Ldvirtftn:  			instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Newobj:  			instructions.Add (new MethodInstruction (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Ldind_i1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int8Ref));  			break;  		case PE.OpCode.Ldind_u1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt8Ref));  			break;  		case PE.OpCode.Ldind_i2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int16Ref));  			break;  		case PE.OpCode.Ldind_u2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt16Ref));  			break;  		case PE.OpCode.Ldind_i4:  		case PE.OpCode.Ldind_u4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int32Ref));  			break;  		case PE.OpCode.Ldind_i8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int64Ref));  			break;  		case PE.OpCode.Ldind_i:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.IntNativeRef));  			break;  		case PE.OpCode.Ldind_r4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.SingleRef));  			break;  		case PE.OpCode.Ldind_r8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.DoubleRef));  			break;  		case PE.OpCode.Ldobj:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Stind_i1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int8Ref));  			break;  		case PE.OpCode.Stind_i2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int16Ref));  			break;  		case PE.OpCode.Stind_i4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int32Ref));  			break;  		case PE.OpCode.Stind_i8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int64Ref));  			break;  		case PE.OpCode.Stind_i:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.IntNativeRef));  			break;  		case PE.OpCode.Stind_r4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.SingleRef));  			break;  		case PE.OpCode.Stind_r8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.DoubleRef));  			break;  		case PE.OpCode.Stobj:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Cpobj:  			instructions.Add (new TypeInstruction (offset' TypeOp.Cpobj' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Newarr:  			instructions.Add (new TypeInstruction (offset' TypeOp.Newarr' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Initobj:  			instructions.Add (new TypeInstruction (offset' TypeOp.Initobj' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Castclass:  			instructions.Add (new TypeInstruction (offset' TypeOp.Castclass' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Isinst:  			instructions.Add (new TypeInstruction (offset' TypeOp.Isinst' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Box:  			instructions.Add (new TypeInstruction (offset' TypeOp.Box' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Unbox:  			instructions.Add (new TypeInstruction (offset' TypeOp.Unbox' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Unbox_any:  			instructions.Add (new TypeInstruction (offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Ldelem_i1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int8Ref));  			break;  		case PE.OpCode.Ldelem_u1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt8Ref));  			break;  		case PE.OpCode.Ldelem_i2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int16Ref));  			break;  		case PE.OpCode.Ldelem_u2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt16Ref));  			break;  		case PE.OpCode.Ldelem_i4:  		case PE.OpCode.Ldelem_u4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int32Ref));  			break;  		case PE.OpCode.Ldelem_i:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.IntNativeRef));  			break;  		case PE.OpCode.Ldelem_i8:  			// aka ldelem.u8  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int64Ref));  			break;  		case PE.OpCode.Ldelem_r4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.SingleRef));  			break;  		case PE.OpCode.Ldelem_r8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.DoubleRef));  			break;  		case PE.OpCode.Ldelem:  			// aka ldelem.any  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Stelem_i1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int8Ref));  			break;  		case PE.OpCode.Stelem_i2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int16Ref));  			break;  		case PE.OpCode.Stelem_i4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int32Ref));  			break;  		case PE.OpCode.Stelem_i8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int64Ref));  			break;  		case PE.OpCode.Stelem_i:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.IntNativeRef));  			break;  		case PE.OpCode.Stelem_r4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.SingleRef));  			break;  		case PE.OpCode.Stelem_r8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.DoubleRef));  			break;  		case PE.OpCode.Stelem:  			// aka stelem.any  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Readonly:  			if (i >= ctxt.Instructions.Length)  				throw new InvalidOperationException ("invalid instruction");  			instruction = ctxt.Instructions [i++];  			if (instruction.OpCode != PE.OpCode.Ldelema)  				throw new InvalidOperationException ("invalid instruction");  			instructions.Add (new LdElemAddrInstruction (offset' true' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Ldelema:  			instructions.Add (new LdElemAddrInstruction (offset' false' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Ldc_i4_0:  			instructions.Add (new LdInt32Instruction (offset' 0));  			break;  		case PE.OpCode.Ldc_i4_1:  			instructions.Add (new LdInt32Instruction (offset' 1));  			break;  		case PE.OpCode.Ldc_i4_2:  			instructions.Add (new LdInt32Instruction (offset' 2));  			break;  		case PE.OpCode.Ldc_i4_3:  			instructions.Add (new LdInt32Instruction (offset' 3));  			break;  		case PE.OpCode.Ldc_i4_4:  			instructions.Add (new LdInt32Instruction (offset' 4));  			break;  		case PE.OpCode.Ldc_i4_5:  			instructions.Add (new LdInt32Instruction (offset' 5));  			break;  		case PE.OpCode.Ldc_i4_6:  			instructions.Add (new LdInt32Instruction (offset' 6));  			break;  		case PE.OpCode.Ldc_i4_7:  			instructions.Add (new LdInt32Instruction (offset' 7));  			break;  		case PE.OpCode.Ldc_i4_8:  			instructions.Add (new LdInt32Instruction (offset' 8));  			break;  		case PE.OpCode.Ldc_i4_m1:  			instructions.Add (new LdInt32Instruction (offset' -1));  			break;  		case PE.OpCode.Ldc_i4:  		case PE.OpCode.Ldc_i4_s:  			instructions.Add (new LdInt32Instruction (offset' (int)instruction.Value));  			break;  		case PE.OpCode.Ldc_i8:  			instructions.Add (new LdInt64Instruction (offset' (long)instruction.Value));  			break;  		case PE.OpCode.Ldc_r4:  			instructions.Add (new LdSingleInstruction (offset' (float)instruction.Value));  			break;  		case PE.OpCode.Ldc_r8:  			instructions.Add (new LdDoubleInstruction (offset' (double)instruction.Value));  			break;  		case PE.OpCode.Ldstr:  			instructions.Add (new LdStringInstruction (offset' (string)instruction.Value));  			break;  		case PE.OpCode.Add:  			instructions.Add (new ArithInstruction (offset' ArithOp.Add' false' false));  			break;  		case PE.OpCode.Add_ovf:  			instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' false));  			break;  		case PE.OpCode.Add_ovf_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' true));  			break;  		case PE.OpCode.Sub:  			instructions.Add (new ArithInstruction (offset' ArithOp.Sub' false' false));  			break;  		case PE.OpCode.Sub_ovf:  			instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' false));  			break;  		case PE.OpCode.Sub_ovf_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' true));  			break;  		case PE.OpCode.Mul:  			instructions.Add (new ArithInstruction (offset' ArithOp.Mul' false' false));  			break;  		case PE.OpCode.Mul_ovf:  			instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' false));  			break;  		case PE.OpCode.Mul_ovf_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' true));  			break;  		case PE.OpCode.Div:  			instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' false));  			break;  		case PE.OpCode.Div_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' true));  			break;  		case PE.OpCode.Rem:  			instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' false));  			break;  		case PE.OpCode.Rem_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' true));  			break;  		case PE.OpCode.Neg:  			instructions.Add (new ArithInstruction (offset' ArithOp.Neg' false' false));  			break;  		case PE.OpCode.And:  			instructions.Add (new ArithInstruction (offset' ArithOp.BitAnd' false' false));  			break;  		case PE.OpCode.Or:  			instructions.Add (new ArithInstruction (offset' ArithOp.BitOr' false' false));  			break;  		case PE.OpCode.Xor:  			instructions.Add (new ArithInstruction (offset' ArithOp.BitXor' false' false));  			break;  		case PE.OpCode.Not:  			instructions.Add (new ArithInstruction (offset' ArithOp.BitNot' false' false));  			break;  		case PE.OpCode.Shl:  			instructions.Add (new ArithInstruction (offset' ArithOp.Shl' false' false));  			break;  		case PE.OpCode.Shr:  			instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' false));  			break;  		case PE.OpCode.Shr_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' true));  			break;  		case PE.OpCode.Conv_i1:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' false' false));  			break;  		case PE.OpCode.Conv_u1:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' false' false));  			break;  		case PE.OpCode.Conv_i2:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' false' false));  			break;  		case PE.OpCode.Conv_u2:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' false' false));  			break;  		case PE.OpCode.Conv_i4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' false' false));  			break;  		case PE.OpCode.Conv_u4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' false' false));  			break;  		case PE.OpCode.Conv_i8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' false' false));  			break;  		case PE.OpCode.Conv_u8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' false' false));  			break;  		case PE.OpCode.Conv_i:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' false' false));  			break;  		case PE.OpCode.Conv_u:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' false' false));  			break;  		case PE.OpCode.Conv_r4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Single' false' false));  			break;  		case PE.OpCode.Conv_r8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' false));  			break;  		case PE.OpCode.Conv_r_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' true));  			break;  		case PE.OpCode.Conv_ovf_i1:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' false));  			break;  		case PE.OpCode.Conv_ovf_u1:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' false));  			break;  		case PE.OpCode.Conv_ovf_i2:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' false));  			break;  		case PE.OpCode.Conv_ovf_u2:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' false));  			break;  		case PE.OpCode.Conv_ovf_i4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' false));  			break;  		case PE.OpCode.Conv_ovf_u4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' false));  			break;  		case PE.OpCode.Conv_ovf_i8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' false));  			break;  		case PE.OpCode.Conv_ovf_u8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' false));  			break;  		case PE.OpCode.Conv_ovf_i:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' false));  			break;  		case PE.OpCode.Conv_ovf_u:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' false));  			break;  		case PE.OpCode.Conv_ovf_i1_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' true));  			break;  		case PE.OpCode.Conv_ovf_u1_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' true));  			break;  		case PE.OpCode.Conv_ovf_i2_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' true));  			break;  		case PE.OpCode.Conv_ovf_u2_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' true));  			break;  		case PE.OpCode.Conv_ovf_i4_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' true));  			break;  		case PE.OpCode.Conv_ovf_u4_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' true));  			break;  		case PE.OpCode.Conv_ovf_i8_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' true));  			break;  		case PE.OpCode.Conv_ovf_u8_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' true));  			break;  		case PE.OpCode.Conv_ovf_i_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' true));  			break;  		case PE.OpCode.Conv_ovf_u_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' true));  			break;  		default:  			throw new InvalidOperationException ("invalid instruction");  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: if (j > i)  	i = j;  else {  	var ehcs = ctxt.OutermostTryBlocks (i);  	if (ehcs != null) {  		// A try instruction begins here with given handlers  		var offset = ctxt.Instructions [i].Offset;  		var tryCtxt = new TryTranslationContext (ctxt' i' ehcs);  		var tryBlock = InstructionsFromContext (tryCtxt);  		var handlers = new Seq<TryInstructionHandler> ();  		foreach (var ehc in ehcs) {  			var handlerCtxt = new HandlerTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.HandlerOffset]' ehc);  			var handlerBlock = InstructionsFromContext (handlerCtxt);  			switch (ehc.Flags) {  			case PE.CorILExceptionClause.Exception:  				handlers.Add (new CatchTryInstructionHandler ((TypeRef)ehc.Class' handlerBlock));  				break;  			case PE.CorILExceptionClause.Filter: {  				var filterCtxt = new FilterTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.FilterOffset]' ehc);  				var filterBlock = InstructionsFromContext (filterCtxt);  				handlers.Add (new FilterTryInstructionHandler (filterBlock' handlerBlock));  				break;  			}  			case PE.CorILExceptionClause.Finally:  				handlers.Add (new FinallyTryInstructionHandler (handlerBlock));  				break;  			case PE.CorILExceptionClause.Fault:  				handlers.Add (new FaultTryInstructionHandler (handlerBlock));  				break;  			default:  				throw new ArgumentOutOfRangeException ();  			}  		}  		instructions.Add (new TryInstruction (offset' tryBlock' handlers));  		// Jump over try block  		var nextOffset = ehcs [0].TryOffset + ehcs [0].TryLength;  		if (!ctxt.OffsetToIndex.TryGetValue (nextOffset' out i))  			i = ctxt.Instructions.Length;  	}  	else {  		var instruction = ctxt.Instructions [i++];  		var offset = instruction.Offset;  		while (instruction.OpCode == PE.OpCode.Unaligned || instruction.OpCode == PE.OpCode.Volatile || instruction.OpCode == PE.OpCode.Tailcall) {  			// Skip over any ignored prefixes' but remember instruction begins at original offset  			// NOTE: What ever happened to the "no." prefix mentioned in the spec?  			if (i >= ctxt.Instructions.Length)  				throw new InvalidOperationException ("invalid instructions");  			instruction = ctxt.Instructions [i++];  		}  		switch (instruction.OpCode) {  		case PE.OpCode.Cpblk:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Cpblk));  			break;  		case PE.OpCode.Initblk:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Initblk));  			break;  		case PE.OpCode.Arglist:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Arglist));  			break;  		case PE.OpCode.Localloc:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Localloc));  			break;  		case PE.OpCode.Jmp:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Jmp));  			break;  		case PE.OpCode.Calli:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Calli));  			break;  		case PE.OpCode.Sizeof:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Sizeof));  			break;  		case PE.OpCode.Mkrefany:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Mkrefany));  			break;  		case PE.OpCode.Refanytype:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanytype));  			break;  		case PE.OpCode.Refanyval:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanyval));  			break;  		case PE.OpCode.Nop:  			instructions.Add (new MiscInstruction (offset' MiscOp.Nop));  			break;  		case PE.OpCode.Break:  			instructions.Add (new MiscInstruction (offset' MiscOp.Break));  			break;  		case PE.OpCode.Dup:  			instructions.Add (new MiscInstruction (offset' MiscOp.Dup));  			break;  		case PE.OpCode.Pop:  			instructions.Add (new MiscInstruction (offset' MiscOp.Pop));  			break;  		case PE.OpCode.Ldnull:  			instructions.Add (new MiscInstruction (offset' MiscOp.Ldnull));  			break;  		case PE.OpCode.Ckfinite:  			instructions.Add (new MiscInstruction (offset' MiscOp.Ckfinite));  			break;  		case PE.OpCode.Throw:  			instructions.Add (new MiscInstruction (offset' MiscOp.Throw));  			break;  		case PE.OpCode.Rethrow:  			instructions.Add (new MiscInstruction (offset' MiscOp.Rethrow));  			break;  		case PE.OpCode.Ldind_ref:  			instructions.Add (new MiscInstruction (offset' MiscOp.LdindRef));  			break;  		case PE.OpCode.Stind_ref:  			instructions.Add (new MiscInstruction (offset' MiscOp.StindRef));  			break;  		case PE.OpCode.Ldelem_ref:  			instructions.Add (new MiscInstruction (offset' MiscOp.LdelemRef));  			break;  		case PE.OpCode.Stelem_ref:  			instructions.Add (new MiscInstruction (offset' MiscOp.StelemRef));  			break;  		case PE.OpCode.Ldlen:  			instructions.Add (new MiscInstruction (offset' MiscOp.Ldlen));  			break;  		case PE.OpCode.Ret:  			if (ctxt.ResultType == null)  				instructions.Add (new MiscInstruction (offset' MiscOp.Ret));  			else  				instructions.Add (new MiscInstruction (offset' MiscOp.RetVal));  			break;  		case PE.OpCode.Endfilter:  			instructions.Add (new MiscInstruction (offset' MiscOp.Endfilter));  			break;  		case PE.OpCode.Endfinally:  			// aka EndFault  			instructions.Add (new MiscInstruction (offset' MiscOp.Endfinally));  			break;  		case PE.OpCode.Br_s:  		case PE.OpCode.Br:  			instructions.Add (new BranchInstruction (offset' BranchOp.Br' false' (int)instruction.Value));  			break;  		case PE.OpCode.Brtrue_s:  		// aka brinst.s  		case PE.OpCode.Brtrue:  			// aka brinst  			instructions.Add (new BranchInstruction (offset' BranchOp.Brtrue' false' (int)instruction.Value));  			break;  		case PE.OpCode.Brfalse_s:  		// aka brzero.s' brnull.s  		case PE.OpCode.Brfalse:  			// aka brzero' brnull  			instructions.Add (new BranchInstruction (offset' BranchOp.Brfalse' false' (int)instruction.Value));  			break;  		case PE.OpCode.Beq:  		case PE.OpCode.Beq_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.Breq' false' (int)instruction.Value));  			break;  		case PE.OpCode.Bne_un:  		case PE.OpCode.Bne_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.Brne' false' (int)instruction.Value));  			break;  		case PE.OpCode.Leave:  		case PE.OpCode.Leave_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.Leave' false' (int)instruction.Value));  			break;  		case PE.OpCode.Blt:  		case PE.OpCode.Blt_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' false' (int)instruction.Value));  			break;  		case PE.OpCode.Blt_un:  		case PE.OpCode.Blt_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' true' (int)instruction.Value));  			break;  		case PE.OpCode.Ble:  		case PE.OpCode.Ble_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' false' (int)instruction.Value));  			break;  		case PE.OpCode.Ble_un:  		case PE.OpCode.Ble_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' true' (int)instruction.Value));  			break;  		case PE.OpCode.Bgt:  		case PE.OpCode.Bgt_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' false' (int)instruction.Value));  			break;  		case PE.OpCode.Bgt_un:  		case PE.OpCode.Bgt_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' true' (int)instruction.Value));  			break;  		case PE.OpCode.Bge:  		case PE.OpCode.Bge_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' false' (int)instruction.Value));  			break;  		case PE.OpCode.Bge_un:  		case PE.OpCode.Bge_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' true' (int)instruction.Value));  			break;  		case PE.OpCode.Switch:  			instructions.Add (new SwitchInstruction (offset' (Seq<int>)instruction.Value));  			break;  		case PE.OpCode.Ceq:  			instructions.Add (new CompareInstruction (offset' CompareOp.Ceq' false));  			break;  		case PE.OpCode.Clt:  			instructions.Add (new CompareInstruction (offset' CompareOp.Clt' false));  			break;  		case PE.OpCode.Clt_un:  			instructions.Add (new CompareInstruction (offset' CompareOp.Clt' true));  			break;  		case PE.OpCode.Cgt:  			instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' false));  			break;  		case PE.OpCode.Cgt_un:  			instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' true));  			break;  		case PE.OpCode.Ldarg_0:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));  			break;  		case PE.OpCode.Ldarg_1:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));  			break;  		case PE.OpCode.Ldarg_2:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));  			break;  		case PE.OpCode.Ldarg_3:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));  			break;  		case PE.OpCode.Ldarg:  		case PE.OpCode.Ldarg_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));  			break;  		case PE.OpCode.Ldarga:  		case PE.OpCode.Ldarga_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));  			break;  		case PE.OpCode.Starg:  		case PE.OpCode.Starg_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));  			break;  		case PE.OpCode.Ldloc_0:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 0));  			break;  		case PE.OpCode.Ldloc_1:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 1));  			break;  		case PE.OpCode.Ldloc_2:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 2));  			break;  		case PE.OpCode.Ldloc_3:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 3));  			break;  		case PE.OpCode.Ldloc:  		case PE.OpCode.Ldloc_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));  			break;  		case PE.OpCode.Ldloca:  		case PE.OpCode.Ldloca_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));  			break;  		case PE.OpCode.Stloc_0:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 0));  			break;  		case PE.OpCode.Stloc_1:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 1));  			break;  		case PE.OpCode.Stloc_2:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 2));  			break;  		case PE.OpCode.Stloc_3:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 3));  			break;  		case PE.OpCode.Stloc:  		case PE.OpCode.Stloc_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));  			break;  		case PE.OpCode.Ldfld:  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));  			break;  		case PE.OpCode.Ldsfld:  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));  			break;  		case PE.OpCode.Ldflda:  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));  			break;  		case PE.OpCode.Ldsflda:  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));  			break;  		case PE.OpCode.Stfld:  			instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));  			break;  		case PE.OpCode.Stsfld:  			instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));  			break;  		case PE.OpCode.Ldtoken: {  			if (instruction.Value is FieldRef)  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));  			else if (instruction.Value is MethodRef)  				instructions.Add (new MethodInstruction (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));  			else if (instruction.Value is TypeRef)  				// NOTE: May be a higher-kinded type  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));  			else  				throw new InvalidOperationException ("unexpected ldtoken instruction value");  			break;  		}  		case PE.OpCode.Constrained: {  			var constrained = (TypeRef)instruction.Value;  			if (i >= ctxt.Instructions.Length)  				throw new InvalidOperationException ("invalid instructions");  			instruction = ctxt.Instructions [i++];  			if (instruction.OpCode != PE.OpCode.Callvirt)  				throw new InvalidOperationException ("invalid instruction");  			instructions.Add (new MethodInstruction (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));  			break;  		}  		case PE.OpCode.Call:  			instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Callvirt:  			instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Ldftn:  			instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Ldvirtftn:  			instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Newobj:  			instructions.Add (new MethodInstruction (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Ldind_i1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int8Ref));  			break;  		case PE.OpCode.Ldind_u1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt8Ref));  			break;  		case PE.OpCode.Ldind_i2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int16Ref));  			break;  		case PE.OpCode.Ldind_u2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt16Ref));  			break;  		case PE.OpCode.Ldind_i4:  		case PE.OpCode.Ldind_u4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int32Ref));  			break;  		case PE.OpCode.Ldind_i8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int64Ref));  			break;  		case PE.OpCode.Ldind_i:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.IntNativeRef));  			break;  		case PE.OpCode.Ldind_r4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.SingleRef));  			break;  		case PE.OpCode.Ldind_r8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.DoubleRef));  			break;  		case PE.OpCode.Ldobj:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Stind_i1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int8Ref));  			break;  		case PE.OpCode.Stind_i2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int16Ref));  			break;  		case PE.OpCode.Stind_i4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int32Ref));  			break;  		case PE.OpCode.Stind_i8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int64Ref));  			break;  		case PE.OpCode.Stind_i:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.IntNativeRef));  			break;  		case PE.OpCode.Stind_r4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.SingleRef));  			break;  		case PE.OpCode.Stind_r8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.DoubleRef));  			break;  		case PE.OpCode.Stobj:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Cpobj:  			instructions.Add (new TypeInstruction (offset' TypeOp.Cpobj' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Newarr:  			instructions.Add (new TypeInstruction (offset' TypeOp.Newarr' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Initobj:  			instructions.Add (new TypeInstruction (offset' TypeOp.Initobj' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Castclass:  			instructions.Add (new TypeInstruction (offset' TypeOp.Castclass' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Isinst:  			instructions.Add (new TypeInstruction (offset' TypeOp.Isinst' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Box:  			instructions.Add (new TypeInstruction (offset' TypeOp.Box' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Unbox:  			instructions.Add (new TypeInstruction (offset' TypeOp.Unbox' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Unbox_any:  			instructions.Add (new TypeInstruction (offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Ldelem_i1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int8Ref));  			break;  		case PE.OpCode.Ldelem_u1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt8Ref));  			break;  		case PE.OpCode.Ldelem_i2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int16Ref));  			break;  		case PE.OpCode.Ldelem_u2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt16Ref));  			break;  		case PE.OpCode.Ldelem_i4:  		case PE.OpCode.Ldelem_u4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int32Ref));  			break;  		case PE.OpCode.Ldelem_i:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.IntNativeRef));  			break;  		case PE.OpCode.Ldelem_i8:  			// aka ldelem.u8  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int64Ref));  			break;  		case PE.OpCode.Ldelem_r4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.SingleRef));  			break;  		case PE.OpCode.Ldelem_r8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.DoubleRef));  			break;  		case PE.OpCode.Ldelem:  			// aka ldelem.any  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Stelem_i1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int8Ref));  			break;  		case PE.OpCode.Stelem_i2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int16Ref));  			break;  		case PE.OpCode.Stelem_i4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int32Ref));  			break;  		case PE.OpCode.Stelem_i8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int64Ref));  			break;  		case PE.OpCode.Stelem_i:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.IntNativeRef));  			break;  		case PE.OpCode.Stelem_r4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.SingleRef));  			break;  		case PE.OpCode.Stelem_r8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.DoubleRef));  			break;  		case PE.OpCode.Stelem:  			// aka stelem.any  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Readonly:  			if (i >= ctxt.Instructions.Length)  				throw new InvalidOperationException ("invalid instruction");  			instruction = ctxt.Instructions [i++];  			if (instruction.OpCode != PE.OpCode.Ldelema)  				throw new InvalidOperationException ("invalid instruction");  			instructions.Add (new LdElemAddrInstruction (offset' true' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Ldelema:  			instructions.Add (new LdElemAddrInstruction (offset' false' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Ldc_i4_0:  			instructions.Add (new LdInt32Instruction (offset' 0));  			break;  		case PE.OpCode.Ldc_i4_1:  			instructions.Add (new LdInt32Instruction (offset' 1));  			break;  		case PE.OpCode.Ldc_i4_2:  			instructions.Add (new LdInt32Instruction (offset' 2));  			break;  		case PE.OpCode.Ldc_i4_3:  			instructions.Add (new LdInt32Instruction (offset' 3));  			break;  		case PE.OpCode.Ldc_i4_4:  			instructions.Add (new LdInt32Instruction (offset' 4));  			break;  		case PE.OpCode.Ldc_i4_5:  			instructions.Add (new LdInt32Instruction (offset' 5));  			break;  		case PE.OpCode.Ldc_i4_6:  			instructions.Add (new LdInt32Instruction (offset' 6));  			break;  		case PE.OpCode.Ldc_i4_7:  			instructions.Add (new LdInt32Instruction (offset' 7));  			break;  		case PE.OpCode.Ldc_i4_8:  			instructions.Add (new LdInt32Instruction (offset' 8));  			break;  		case PE.OpCode.Ldc_i4_m1:  			instructions.Add (new LdInt32Instruction (offset' -1));  			break;  		case PE.OpCode.Ldc_i4:  		case PE.OpCode.Ldc_i4_s:  			instructions.Add (new LdInt32Instruction (offset' (int)instruction.Value));  			break;  		case PE.OpCode.Ldc_i8:  			instructions.Add (new LdInt64Instruction (offset' (long)instruction.Value));  			break;  		case PE.OpCode.Ldc_r4:  			instructions.Add (new LdSingleInstruction (offset' (float)instruction.Value));  			break;  		case PE.OpCode.Ldc_r8:  			instructions.Add (new LdDoubleInstruction (offset' (double)instruction.Value));  			break;  		case PE.OpCode.Ldstr:  			instructions.Add (new LdStringInstruction (offset' (string)instruction.Value));  			break;  		case PE.OpCode.Add:  			instructions.Add (new ArithInstruction (offset' ArithOp.Add' false' false));  			break;  		case PE.OpCode.Add_ovf:  			instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' false));  			break;  		case PE.OpCode.Add_ovf_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' true));  			break;  		case PE.OpCode.Sub:  			instructions.Add (new ArithInstruction (offset' ArithOp.Sub' false' false));  			break;  		case PE.OpCode.Sub_ovf:  			instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' false));  			break;  		case PE.OpCode.Sub_ovf_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' true));  			break;  		case PE.OpCode.Mul:  			instructions.Add (new ArithInstruction (offset' ArithOp.Mul' false' false));  			break;  		case PE.OpCode.Mul_ovf:  			instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' false));  			break;  		case PE.OpCode.Mul_ovf_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' true));  			break;  		case PE.OpCode.Div:  			instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' false));  			break;  		case PE.OpCode.Div_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' true));  			break;  		case PE.OpCode.Rem:  			instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' false));  			break;  		case PE.OpCode.Rem_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' true));  			break;  		case PE.OpCode.Neg:  			instructions.Add (new ArithInstruction (offset' ArithOp.Neg' false' false));  			break;  		case PE.OpCode.And:  			instructions.Add (new ArithInstruction (offset' ArithOp.BitAnd' false' false));  			break;  		case PE.OpCode.Or:  			instructions.Add (new ArithInstruction (offset' ArithOp.BitOr' false' false));  			break;  		case PE.OpCode.Xor:  			instructions.Add (new ArithInstruction (offset' ArithOp.BitXor' false' false));  			break;  		case PE.OpCode.Not:  			instructions.Add (new ArithInstruction (offset' ArithOp.BitNot' false' false));  			break;  		case PE.OpCode.Shl:  			instructions.Add (new ArithInstruction (offset' ArithOp.Shl' false' false));  			break;  		case PE.OpCode.Shr:  			instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' false));  			break;  		case PE.OpCode.Shr_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' true));  			break;  		case PE.OpCode.Conv_i1:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' false' false));  			break;  		case PE.OpCode.Conv_u1:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' false' false));  			break;  		case PE.OpCode.Conv_i2:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' false' false));  			break;  		case PE.OpCode.Conv_u2:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' false' false));  			break;  		case PE.OpCode.Conv_i4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' false' false));  			break;  		case PE.OpCode.Conv_u4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' false' false));  			break;  		case PE.OpCode.Conv_i8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' false' false));  			break;  		case PE.OpCode.Conv_u8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' false' false));  			break;  		case PE.OpCode.Conv_i:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' false' false));  			break;  		case PE.OpCode.Conv_u:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' false' false));  			break;  		case PE.OpCode.Conv_r4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Single' false' false));  			break;  		case PE.OpCode.Conv_r8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' false));  			break;  		case PE.OpCode.Conv_r_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' true));  			break;  		case PE.OpCode.Conv_ovf_i1:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' false));  			break;  		case PE.OpCode.Conv_ovf_u1:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' false));  			break;  		case PE.OpCode.Conv_ovf_i2:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' false));  			break;  		case PE.OpCode.Conv_ovf_u2:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' false));  			break;  		case PE.OpCode.Conv_ovf_i4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' false));  			break;  		case PE.OpCode.Conv_ovf_u4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' false));  			break;  		case PE.OpCode.Conv_ovf_i8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' false));  			break;  		case PE.OpCode.Conv_ovf_u8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' false));  			break;  		case PE.OpCode.Conv_ovf_i:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' false));  			break;  		case PE.OpCode.Conv_ovf_u:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' false));  			break;  		case PE.OpCode.Conv_ovf_i1_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' true));  			break;  		case PE.OpCode.Conv_ovf_u1_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' true));  			break;  		case PE.OpCode.Conv_ovf_i2_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' true));  			break;  		case PE.OpCode.Conv_ovf_u2_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' true));  			break;  		case PE.OpCode.Conv_ovf_i4_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' true));  			break;  		case PE.OpCode.Conv_ovf_u4_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' true));  			break;  		case PE.OpCode.Conv_ovf_i8_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' true));  			break;  		case PE.OpCode.Conv_ovf_u8_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' true));  			break;  		case PE.OpCode.Conv_ovf_i_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' true));  			break;  		case PE.OpCode.Conv_ovf_u_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' true));  			break;  		default:  			throw new InvalidOperationException ("invalid instruction");  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: if (j > i)  	i = j;  else {  	var ehcs = ctxt.OutermostTryBlocks (i);  	if (ehcs != null) {  		// A try instruction begins here with given handlers  		var offset = ctxt.Instructions [i].Offset;  		var tryCtxt = new TryTranslationContext (ctxt' i' ehcs);  		var tryBlock = InstructionsFromContext (tryCtxt);  		var handlers = new Seq<TryInstructionHandler> ();  		foreach (var ehc in ehcs) {  			var handlerCtxt = new HandlerTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.HandlerOffset]' ehc);  			var handlerBlock = InstructionsFromContext (handlerCtxt);  			switch (ehc.Flags) {  			case PE.CorILExceptionClause.Exception:  				handlers.Add (new CatchTryInstructionHandler ((TypeRef)ehc.Class' handlerBlock));  				break;  			case PE.CorILExceptionClause.Filter: {  				var filterCtxt = new FilterTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.FilterOffset]' ehc);  				var filterBlock = InstructionsFromContext (filterCtxt);  				handlers.Add (new FilterTryInstructionHandler (filterBlock' handlerBlock));  				break;  			}  			case PE.CorILExceptionClause.Finally:  				handlers.Add (new FinallyTryInstructionHandler (handlerBlock));  				break;  			case PE.CorILExceptionClause.Fault:  				handlers.Add (new FaultTryInstructionHandler (handlerBlock));  				break;  			default:  				throw new ArgumentOutOfRangeException ();  			}  		}  		instructions.Add (new TryInstruction (offset' tryBlock' handlers));  		// Jump over try block  		var nextOffset = ehcs [0].TryOffset + ehcs [0].TryLength;  		if (!ctxt.OffsetToIndex.TryGetValue (nextOffset' out i))  			i = ctxt.Instructions.Length;  	}  	else {  		var instruction = ctxt.Instructions [i++];  		var offset = instruction.Offset;  		while (instruction.OpCode == PE.OpCode.Unaligned || instruction.OpCode == PE.OpCode.Volatile || instruction.OpCode == PE.OpCode.Tailcall) {  			// Skip over any ignored prefixes' but remember instruction begins at original offset  			// NOTE: What ever happened to the "no." prefix mentioned in the spec?  			if (i >= ctxt.Instructions.Length)  				throw new InvalidOperationException ("invalid instructions");  			instruction = ctxt.Instructions [i++];  		}  		switch (instruction.OpCode) {  		case PE.OpCode.Cpblk:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Cpblk));  			break;  		case PE.OpCode.Initblk:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Initblk));  			break;  		case PE.OpCode.Arglist:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Arglist));  			break;  		case PE.OpCode.Localloc:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Localloc));  			break;  		case PE.OpCode.Jmp:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Jmp));  			break;  		case PE.OpCode.Calli:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Calli));  			break;  		case PE.OpCode.Sizeof:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Sizeof));  			break;  		case PE.OpCode.Mkrefany:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Mkrefany));  			break;  		case PE.OpCode.Refanytype:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanytype));  			break;  		case PE.OpCode.Refanyval:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanyval));  			break;  		case PE.OpCode.Nop:  			instructions.Add (new MiscInstruction (offset' MiscOp.Nop));  			break;  		case PE.OpCode.Break:  			instructions.Add (new MiscInstruction (offset' MiscOp.Break));  			break;  		case PE.OpCode.Dup:  			instructions.Add (new MiscInstruction (offset' MiscOp.Dup));  			break;  		case PE.OpCode.Pop:  			instructions.Add (new MiscInstruction (offset' MiscOp.Pop));  			break;  		case PE.OpCode.Ldnull:  			instructions.Add (new MiscInstruction (offset' MiscOp.Ldnull));  			break;  		case PE.OpCode.Ckfinite:  			instructions.Add (new MiscInstruction (offset' MiscOp.Ckfinite));  			break;  		case PE.OpCode.Throw:  			instructions.Add (new MiscInstruction (offset' MiscOp.Throw));  			break;  		case PE.OpCode.Rethrow:  			instructions.Add (new MiscInstruction (offset' MiscOp.Rethrow));  			break;  		case PE.OpCode.Ldind_ref:  			instructions.Add (new MiscInstruction (offset' MiscOp.LdindRef));  			break;  		case PE.OpCode.Stind_ref:  			instructions.Add (new MiscInstruction (offset' MiscOp.StindRef));  			break;  		case PE.OpCode.Ldelem_ref:  			instructions.Add (new MiscInstruction (offset' MiscOp.LdelemRef));  			break;  		case PE.OpCode.Stelem_ref:  			instructions.Add (new MiscInstruction (offset' MiscOp.StelemRef));  			break;  		case PE.OpCode.Ldlen:  			instructions.Add (new MiscInstruction (offset' MiscOp.Ldlen));  			break;  		case PE.OpCode.Ret:  			if (ctxt.ResultType == null)  				instructions.Add (new MiscInstruction (offset' MiscOp.Ret));  			else  				instructions.Add (new MiscInstruction (offset' MiscOp.RetVal));  			break;  		case PE.OpCode.Endfilter:  			instructions.Add (new MiscInstruction (offset' MiscOp.Endfilter));  			break;  		case PE.OpCode.Endfinally:  			// aka EndFault  			instructions.Add (new MiscInstruction (offset' MiscOp.Endfinally));  			break;  		case PE.OpCode.Br_s:  		case PE.OpCode.Br:  			instructions.Add (new BranchInstruction (offset' BranchOp.Br' false' (int)instruction.Value));  			break;  		case PE.OpCode.Brtrue_s:  		// aka brinst.s  		case PE.OpCode.Brtrue:  			// aka brinst  			instructions.Add (new BranchInstruction (offset' BranchOp.Brtrue' false' (int)instruction.Value));  			break;  		case PE.OpCode.Brfalse_s:  		// aka brzero.s' brnull.s  		case PE.OpCode.Brfalse:  			// aka brzero' brnull  			instructions.Add (new BranchInstruction (offset' BranchOp.Brfalse' false' (int)instruction.Value));  			break;  		case PE.OpCode.Beq:  		case PE.OpCode.Beq_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.Breq' false' (int)instruction.Value));  			break;  		case PE.OpCode.Bne_un:  		case PE.OpCode.Bne_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.Brne' false' (int)instruction.Value));  			break;  		case PE.OpCode.Leave:  		case PE.OpCode.Leave_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.Leave' false' (int)instruction.Value));  			break;  		case PE.OpCode.Blt:  		case PE.OpCode.Blt_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' false' (int)instruction.Value));  			break;  		case PE.OpCode.Blt_un:  		case PE.OpCode.Blt_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' true' (int)instruction.Value));  			break;  		case PE.OpCode.Ble:  		case PE.OpCode.Ble_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' false' (int)instruction.Value));  			break;  		case PE.OpCode.Ble_un:  		case PE.OpCode.Ble_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' true' (int)instruction.Value));  			break;  		case PE.OpCode.Bgt:  		case PE.OpCode.Bgt_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' false' (int)instruction.Value));  			break;  		case PE.OpCode.Bgt_un:  		case PE.OpCode.Bgt_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' true' (int)instruction.Value));  			break;  		case PE.OpCode.Bge:  		case PE.OpCode.Bge_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' false' (int)instruction.Value));  			break;  		case PE.OpCode.Bge_un:  		case PE.OpCode.Bge_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' true' (int)instruction.Value));  			break;  		case PE.OpCode.Switch:  			instructions.Add (new SwitchInstruction (offset' (Seq<int>)instruction.Value));  			break;  		case PE.OpCode.Ceq:  			instructions.Add (new CompareInstruction (offset' CompareOp.Ceq' false));  			break;  		case PE.OpCode.Clt:  			instructions.Add (new CompareInstruction (offset' CompareOp.Clt' false));  			break;  		case PE.OpCode.Clt_un:  			instructions.Add (new CompareInstruction (offset' CompareOp.Clt' true));  			break;  		case PE.OpCode.Cgt:  			instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' false));  			break;  		case PE.OpCode.Cgt_un:  			instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' true));  			break;  		case PE.OpCode.Ldarg_0:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));  			break;  		case PE.OpCode.Ldarg_1:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));  			break;  		case PE.OpCode.Ldarg_2:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));  			break;  		case PE.OpCode.Ldarg_3:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));  			break;  		case PE.OpCode.Ldarg:  		case PE.OpCode.Ldarg_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));  			break;  		case PE.OpCode.Ldarga:  		case PE.OpCode.Ldarga_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));  			break;  		case PE.OpCode.Starg:  		case PE.OpCode.Starg_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));  			break;  		case PE.OpCode.Ldloc_0:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 0));  			break;  		case PE.OpCode.Ldloc_1:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 1));  			break;  		case PE.OpCode.Ldloc_2:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 2));  			break;  		case PE.OpCode.Ldloc_3:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 3));  			break;  		case PE.OpCode.Ldloc:  		case PE.OpCode.Ldloc_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));  			break;  		case PE.OpCode.Ldloca:  		case PE.OpCode.Ldloca_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));  			break;  		case PE.OpCode.Stloc_0:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 0));  			break;  		case PE.OpCode.Stloc_1:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 1));  			break;  		case PE.OpCode.Stloc_2:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 2));  			break;  		case PE.OpCode.Stloc_3:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 3));  			break;  		case PE.OpCode.Stloc:  		case PE.OpCode.Stloc_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));  			break;  		case PE.OpCode.Ldfld:  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));  			break;  		case PE.OpCode.Ldsfld:  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));  			break;  		case PE.OpCode.Ldflda:  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));  			break;  		case PE.OpCode.Ldsflda:  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));  			break;  		case PE.OpCode.Stfld:  			instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));  			break;  		case PE.OpCode.Stsfld:  			instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));  			break;  		case PE.OpCode.Ldtoken: {  			if (instruction.Value is FieldRef)  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));  			else if (instruction.Value is MethodRef)  				instructions.Add (new MethodInstruction (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));  			else if (instruction.Value is TypeRef)  				// NOTE: May be a higher-kinded type  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));  			else  				throw new InvalidOperationException ("unexpected ldtoken instruction value");  			break;  		}  		case PE.OpCode.Constrained: {  			var constrained = (TypeRef)instruction.Value;  			if (i >= ctxt.Instructions.Length)  				throw new InvalidOperationException ("invalid instructions");  			instruction = ctxt.Instructions [i++];  			if (instruction.OpCode != PE.OpCode.Callvirt)  				throw new InvalidOperationException ("invalid instruction");  			instructions.Add (new MethodInstruction (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));  			break;  		}  		case PE.OpCode.Call:  			instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Callvirt:  			instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Ldftn:  			instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Ldvirtftn:  			instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Newobj:  			instructions.Add (new MethodInstruction (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Ldind_i1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int8Ref));  			break;  		case PE.OpCode.Ldind_u1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt8Ref));  			break;  		case PE.OpCode.Ldind_i2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int16Ref));  			break;  		case PE.OpCode.Ldind_u2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt16Ref));  			break;  		case PE.OpCode.Ldind_i4:  		case PE.OpCode.Ldind_u4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int32Ref));  			break;  		case PE.OpCode.Ldind_i8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int64Ref));  			break;  		case PE.OpCode.Ldind_i:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.IntNativeRef));  			break;  		case PE.OpCode.Ldind_r4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.SingleRef));  			break;  		case PE.OpCode.Ldind_r8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.DoubleRef));  			break;  		case PE.OpCode.Ldobj:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Stind_i1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int8Ref));  			break;  		case PE.OpCode.Stind_i2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int16Ref));  			break;  		case PE.OpCode.Stind_i4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int32Ref));  			break;  		case PE.OpCode.Stind_i8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int64Ref));  			break;  		case PE.OpCode.Stind_i:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.IntNativeRef));  			break;  		case PE.OpCode.Stind_r4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.SingleRef));  			break;  		case PE.OpCode.Stind_r8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.DoubleRef));  			break;  		case PE.OpCode.Stobj:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Cpobj:  			instructions.Add (new TypeInstruction (offset' TypeOp.Cpobj' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Newarr:  			instructions.Add (new TypeInstruction (offset' TypeOp.Newarr' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Initobj:  			instructions.Add (new TypeInstruction (offset' TypeOp.Initobj' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Castclass:  			instructions.Add (new TypeInstruction (offset' TypeOp.Castclass' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Isinst:  			instructions.Add (new TypeInstruction (offset' TypeOp.Isinst' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Box:  			instructions.Add (new TypeInstruction (offset' TypeOp.Box' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Unbox:  			instructions.Add (new TypeInstruction (offset' TypeOp.Unbox' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Unbox_any:  			instructions.Add (new TypeInstruction (offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Ldelem_i1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int8Ref));  			break;  		case PE.OpCode.Ldelem_u1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt8Ref));  			break;  		case PE.OpCode.Ldelem_i2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int16Ref));  			break;  		case PE.OpCode.Ldelem_u2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt16Ref));  			break;  		case PE.OpCode.Ldelem_i4:  		case PE.OpCode.Ldelem_u4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int32Ref));  			break;  		case PE.OpCode.Ldelem_i:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.IntNativeRef));  			break;  		case PE.OpCode.Ldelem_i8:  			// aka ldelem.u8  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int64Ref));  			break;  		case PE.OpCode.Ldelem_r4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.SingleRef));  			break;  		case PE.OpCode.Ldelem_r8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.DoubleRef));  			break;  		case PE.OpCode.Ldelem:  			// aka ldelem.any  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Stelem_i1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int8Ref));  			break;  		case PE.OpCode.Stelem_i2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int16Ref));  			break;  		case PE.OpCode.Stelem_i4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int32Ref));  			break;  		case PE.OpCode.Stelem_i8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int64Ref));  			break;  		case PE.OpCode.Stelem_i:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.IntNativeRef));  			break;  		case PE.OpCode.Stelem_r4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.SingleRef));  			break;  		case PE.OpCode.Stelem_r8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.DoubleRef));  			break;  		case PE.OpCode.Stelem:  			// aka stelem.any  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Readonly:  			if (i >= ctxt.Instructions.Length)  				throw new InvalidOperationException ("invalid instruction");  			instruction = ctxt.Instructions [i++];  			if (instruction.OpCode != PE.OpCode.Ldelema)  				throw new InvalidOperationException ("invalid instruction");  			instructions.Add (new LdElemAddrInstruction (offset' true' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Ldelema:  			instructions.Add (new LdElemAddrInstruction (offset' false' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Ldc_i4_0:  			instructions.Add (new LdInt32Instruction (offset' 0));  			break;  		case PE.OpCode.Ldc_i4_1:  			instructions.Add (new LdInt32Instruction (offset' 1));  			break;  		case PE.OpCode.Ldc_i4_2:  			instructions.Add (new LdInt32Instruction (offset' 2));  			break;  		case PE.OpCode.Ldc_i4_3:  			instructions.Add (new LdInt32Instruction (offset' 3));  			break;  		case PE.OpCode.Ldc_i4_4:  			instructions.Add (new LdInt32Instruction (offset' 4));  			break;  		case PE.OpCode.Ldc_i4_5:  			instructions.Add (new LdInt32Instruction (offset' 5));  			break;  		case PE.OpCode.Ldc_i4_6:  			instructions.Add (new LdInt32Instruction (offset' 6));  			break;  		case PE.OpCode.Ldc_i4_7:  			instructions.Add (new LdInt32Instruction (offset' 7));  			break;  		case PE.OpCode.Ldc_i4_8:  			instructions.Add (new LdInt32Instruction (offset' 8));  			break;  		case PE.OpCode.Ldc_i4_m1:  			instructions.Add (new LdInt32Instruction (offset' -1));  			break;  		case PE.OpCode.Ldc_i4:  		case PE.OpCode.Ldc_i4_s:  			instructions.Add (new LdInt32Instruction (offset' (int)instruction.Value));  			break;  		case PE.OpCode.Ldc_i8:  			instructions.Add (new LdInt64Instruction (offset' (long)instruction.Value));  			break;  		case PE.OpCode.Ldc_r4:  			instructions.Add (new LdSingleInstruction (offset' (float)instruction.Value));  			break;  		case PE.OpCode.Ldc_r8:  			instructions.Add (new LdDoubleInstruction (offset' (double)instruction.Value));  			break;  		case PE.OpCode.Ldstr:  			instructions.Add (new LdStringInstruction (offset' (string)instruction.Value));  			break;  		case PE.OpCode.Add:  			instructions.Add (new ArithInstruction (offset' ArithOp.Add' false' false));  			break;  		case PE.OpCode.Add_ovf:  			instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' false));  			break;  		case PE.OpCode.Add_ovf_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' true));  			break;  		case PE.OpCode.Sub:  			instructions.Add (new ArithInstruction (offset' ArithOp.Sub' false' false));  			break;  		case PE.OpCode.Sub_ovf:  			instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' false));  			break;  		case PE.OpCode.Sub_ovf_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' true));  			break;  		case PE.OpCode.Mul:  			instructions.Add (new ArithInstruction (offset' ArithOp.Mul' false' false));  			break;  		case PE.OpCode.Mul_ovf:  			instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' false));  			break;  		case PE.OpCode.Mul_ovf_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' true));  			break;  		case PE.OpCode.Div:  			instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' false));  			break;  		case PE.OpCode.Div_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' true));  			break;  		case PE.OpCode.Rem:  			instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' false));  			break;  		case PE.OpCode.Rem_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' true));  			break;  		case PE.OpCode.Neg:  			instructions.Add (new ArithInstruction (offset' ArithOp.Neg' false' false));  			break;  		case PE.OpCode.And:  			instructions.Add (new ArithInstruction (offset' ArithOp.BitAnd' false' false));  			break;  		case PE.OpCode.Or:  			instructions.Add (new ArithInstruction (offset' ArithOp.BitOr' false' false));  			break;  		case PE.OpCode.Xor:  			instructions.Add (new ArithInstruction (offset' ArithOp.BitXor' false' false));  			break;  		case PE.OpCode.Not:  			instructions.Add (new ArithInstruction (offset' ArithOp.BitNot' false' false));  			break;  		case PE.OpCode.Shl:  			instructions.Add (new ArithInstruction (offset' ArithOp.Shl' false' false));  			break;  		case PE.OpCode.Shr:  			instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' false));  			break;  		case PE.OpCode.Shr_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' true));  			break;  		case PE.OpCode.Conv_i1:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' false' false));  			break;  		case PE.OpCode.Conv_u1:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' false' false));  			break;  		case PE.OpCode.Conv_i2:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' false' false));  			break;  		case PE.OpCode.Conv_u2:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' false' false));  			break;  		case PE.OpCode.Conv_i4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' false' false));  			break;  		case PE.OpCode.Conv_u4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' false' false));  			break;  		case PE.OpCode.Conv_i8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' false' false));  			break;  		case PE.OpCode.Conv_u8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' false' false));  			break;  		case PE.OpCode.Conv_i:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' false' false));  			break;  		case PE.OpCode.Conv_u:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' false' false));  			break;  		case PE.OpCode.Conv_r4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Single' false' false));  			break;  		case PE.OpCode.Conv_r8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' false));  			break;  		case PE.OpCode.Conv_r_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' true));  			break;  		case PE.OpCode.Conv_ovf_i1:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' false));  			break;  		case PE.OpCode.Conv_ovf_u1:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' false));  			break;  		case PE.OpCode.Conv_ovf_i2:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' false));  			break;  		case PE.OpCode.Conv_ovf_u2:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' false));  			break;  		case PE.OpCode.Conv_ovf_i4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' false));  			break;  		case PE.OpCode.Conv_ovf_u4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' false));  			break;  		case PE.OpCode.Conv_ovf_i8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' false));  			break;  		case PE.OpCode.Conv_ovf_u8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' false));  			break;  		case PE.OpCode.Conv_ovf_i:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' false));  			break;  		case PE.OpCode.Conv_ovf_u:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' false));  			break;  		case PE.OpCode.Conv_ovf_i1_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' true));  			break;  		case PE.OpCode.Conv_ovf_u1_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' true));  			break;  		case PE.OpCode.Conv_ovf_i2_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' true));  			break;  		case PE.OpCode.Conv_ovf_u2_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' true));  			break;  		case PE.OpCode.Conv_ovf_i4_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' true));  			break;  		case PE.OpCode.Conv_ovf_u4_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' true));  			break;  		case PE.OpCode.Conv_ovf_i8_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' true));  			break;  		case PE.OpCode.Conv_ovf_u8_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' true));  			break;  		case PE.OpCode.Conv_ovf_i_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' true));  			break;  		case PE.OpCode.Conv_ovf_u_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' true));  			break;  		default:  			throw new InvalidOperationException ("invalid instruction");  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: if (j > i)  	i = j;  else {  	var ehcs = ctxt.OutermostTryBlocks (i);  	if (ehcs != null) {  		// A try instruction begins here with given handlers  		var offset = ctxt.Instructions [i].Offset;  		var tryCtxt = new TryTranslationContext (ctxt' i' ehcs);  		var tryBlock = InstructionsFromContext (tryCtxt);  		var handlers = new Seq<TryInstructionHandler> ();  		foreach (var ehc in ehcs) {  			var handlerCtxt = new HandlerTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.HandlerOffset]' ehc);  			var handlerBlock = InstructionsFromContext (handlerCtxt);  			switch (ehc.Flags) {  			case PE.CorILExceptionClause.Exception:  				handlers.Add (new CatchTryInstructionHandler ((TypeRef)ehc.Class' handlerBlock));  				break;  			case PE.CorILExceptionClause.Filter: {  				var filterCtxt = new FilterTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.FilterOffset]' ehc);  				var filterBlock = InstructionsFromContext (filterCtxt);  				handlers.Add (new FilterTryInstructionHandler (filterBlock' handlerBlock));  				break;  			}  			case PE.CorILExceptionClause.Finally:  				handlers.Add (new FinallyTryInstructionHandler (handlerBlock));  				break;  			case PE.CorILExceptionClause.Fault:  				handlers.Add (new FaultTryInstructionHandler (handlerBlock));  				break;  			default:  				throw new ArgumentOutOfRangeException ();  			}  		}  		instructions.Add (new TryInstruction (offset' tryBlock' handlers));  		// Jump over try block  		var nextOffset = ehcs [0].TryOffset + ehcs [0].TryLength;  		if (!ctxt.OffsetToIndex.TryGetValue (nextOffset' out i))  			i = ctxt.Instructions.Length;  	}  	else {  		var instruction = ctxt.Instructions [i++];  		var offset = instruction.Offset;  		while (instruction.OpCode == PE.OpCode.Unaligned || instruction.OpCode == PE.OpCode.Volatile || instruction.OpCode == PE.OpCode.Tailcall) {  			// Skip over any ignored prefixes' but remember instruction begins at original offset  			// NOTE: What ever happened to the "no." prefix mentioned in the spec?  			if (i >= ctxt.Instructions.Length)  				throw new InvalidOperationException ("invalid instructions");  			instruction = ctxt.Instructions [i++];  		}  		switch (instruction.OpCode) {  		case PE.OpCode.Cpblk:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Cpblk));  			break;  		case PE.OpCode.Initblk:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Initblk));  			break;  		case PE.OpCode.Arglist:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Arglist));  			break;  		case PE.OpCode.Localloc:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Localloc));  			break;  		case PE.OpCode.Jmp:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Jmp));  			break;  		case PE.OpCode.Calli:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Calli));  			break;  		case PE.OpCode.Sizeof:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Sizeof));  			break;  		case PE.OpCode.Mkrefany:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Mkrefany));  			break;  		case PE.OpCode.Refanytype:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanytype));  			break;  		case PE.OpCode.Refanyval:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanyval));  			break;  		case PE.OpCode.Nop:  			instructions.Add (new MiscInstruction (offset' MiscOp.Nop));  			break;  		case PE.OpCode.Break:  			instructions.Add (new MiscInstruction (offset' MiscOp.Break));  			break;  		case PE.OpCode.Dup:  			instructions.Add (new MiscInstruction (offset' MiscOp.Dup));  			break;  		case PE.OpCode.Pop:  			instructions.Add (new MiscInstruction (offset' MiscOp.Pop));  			break;  		case PE.OpCode.Ldnull:  			instructions.Add (new MiscInstruction (offset' MiscOp.Ldnull));  			break;  		case PE.OpCode.Ckfinite:  			instructions.Add (new MiscInstruction (offset' MiscOp.Ckfinite));  			break;  		case PE.OpCode.Throw:  			instructions.Add (new MiscInstruction (offset' MiscOp.Throw));  			break;  		case PE.OpCode.Rethrow:  			instructions.Add (new MiscInstruction (offset' MiscOp.Rethrow));  			break;  		case PE.OpCode.Ldind_ref:  			instructions.Add (new MiscInstruction (offset' MiscOp.LdindRef));  			break;  		case PE.OpCode.Stind_ref:  			instructions.Add (new MiscInstruction (offset' MiscOp.StindRef));  			break;  		case PE.OpCode.Ldelem_ref:  			instructions.Add (new MiscInstruction (offset' MiscOp.LdelemRef));  			break;  		case PE.OpCode.Stelem_ref:  			instructions.Add (new MiscInstruction (offset' MiscOp.StelemRef));  			break;  		case PE.OpCode.Ldlen:  			instructions.Add (new MiscInstruction (offset' MiscOp.Ldlen));  			break;  		case PE.OpCode.Ret:  			if (ctxt.ResultType == null)  				instructions.Add (new MiscInstruction (offset' MiscOp.Ret));  			else  				instructions.Add (new MiscInstruction (offset' MiscOp.RetVal));  			break;  		case PE.OpCode.Endfilter:  			instructions.Add (new MiscInstruction (offset' MiscOp.Endfilter));  			break;  		case PE.OpCode.Endfinally:  			// aka EndFault  			instructions.Add (new MiscInstruction (offset' MiscOp.Endfinally));  			break;  		case PE.OpCode.Br_s:  		case PE.OpCode.Br:  			instructions.Add (new BranchInstruction (offset' BranchOp.Br' false' (int)instruction.Value));  			break;  		case PE.OpCode.Brtrue_s:  		// aka brinst.s  		case PE.OpCode.Brtrue:  			// aka brinst  			instructions.Add (new BranchInstruction (offset' BranchOp.Brtrue' false' (int)instruction.Value));  			break;  		case PE.OpCode.Brfalse_s:  		// aka brzero.s' brnull.s  		case PE.OpCode.Brfalse:  			// aka brzero' brnull  			instructions.Add (new BranchInstruction (offset' BranchOp.Brfalse' false' (int)instruction.Value));  			break;  		case PE.OpCode.Beq:  		case PE.OpCode.Beq_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.Breq' false' (int)instruction.Value));  			break;  		case PE.OpCode.Bne_un:  		case PE.OpCode.Bne_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.Brne' false' (int)instruction.Value));  			break;  		case PE.OpCode.Leave:  		case PE.OpCode.Leave_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.Leave' false' (int)instruction.Value));  			break;  		case PE.OpCode.Blt:  		case PE.OpCode.Blt_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' false' (int)instruction.Value));  			break;  		case PE.OpCode.Blt_un:  		case PE.OpCode.Blt_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' true' (int)instruction.Value));  			break;  		case PE.OpCode.Ble:  		case PE.OpCode.Ble_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' false' (int)instruction.Value));  			break;  		case PE.OpCode.Ble_un:  		case PE.OpCode.Ble_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' true' (int)instruction.Value));  			break;  		case PE.OpCode.Bgt:  		case PE.OpCode.Bgt_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' false' (int)instruction.Value));  			break;  		case PE.OpCode.Bgt_un:  		case PE.OpCode.Bgt_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' true' (int)instruction.Value));  			break;  		case PE.OpCode.Bge:  		case PE.OpCode.Bge_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' false' (int)instruction.Value));  			break;  		case PE.OpCode.Bge_un:  		case PE.OpCode.Bge_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' true' (int)instruction.Value));  			break;  		case PE.OpCode.Switch:  			instructions.Add (new SwitchInstruction (offset' (Seq<int>)instruction.Value));  			break;  		case PE.OpCode.Ceq:  			instructions.Add (new CompareInstruction (offset' CompareOp.Ceq' false));  			break;  		case PE.OpCode.Clt:  			instructions.Add (new CompareInstruction (offset' CompareOp.Clt' false));  			break;  		case PE.OpCode.Clt_un:  			instructions.Add (new CompareInstruction (offset' CompareOp.Clt' true));  			break;  		case PE.OpCode.Cgt:  			instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' false));  			break;  		case PE.OpCode.Cgt_un:  			instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' true));  			break;  		case PE.OpCode.Ldarg_0:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));  			break;  		case PE.OpCode.Ldarg_1:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));  			break;  		case PE.OpCode.Ldarg_2:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));  			break;  		case PE.OpCode.Ldarg_3:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));  			break;  		case PE.OpCode.Ldarg:  		case PE.OpCode.Ldarg_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));  			break;  		case PE.OpCode.Ldarga:  		case PE.OpCode.Ldarga_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));  			break;  		case PE.OpCode.Starg:  		case PE.OpCode.Starg_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));  			break;  		case PE.OpCode.Ldloc_0:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 0));  			break;  		case PE.OpCode.Ldloc_1:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 1));  			break;  		case PE.OpCode.Ldloc_2:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 2));  			break;  		case PE.OpCode.Ldloc_3:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 3));  			break;  		case PE.OpCode.Ldloc:  		case PE.OpCode.Ldloc_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));  			break;  		case PE.OpCode.Ldloca:  		case PE.OpCode.Ldloca_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));  			break;  		case PE.OpCode.Stloc_0:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 0));  			break;  		case PE.OpCode.Stloc_1:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 1));  			break;  		case PE.OpCode.Stloc_2:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 2));  			break;  		case PE.OpCode.Stloc_3:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 3));  			break;  		case PE.OpCode.Stloc:  		case PE.OpCode.Stloc_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));  			break;  		case PE.OpCode.Ldfld:  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));  			break;  		case PE.OpCode.Ldsfld:  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));  			break;  		case PE.OpCode.Ldflda:  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));  			break;  		case PE.OpCode.Ldsflda:  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));  			break;  		case PE.OpCode.Stfld:  			instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));  			break;  		case PE.OpCode.Stsfld:  			instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));  			break;  		case PE.OpCode.Ldtoken: {  			if (instruction.Value is FieldRef)  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));  			else if (instruction.Value is MethodRef)  				instructions.Add (new MethodInstruction (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));  			else if (instruction.Value is TypeRef)  				// NOTE: May be a higher-kinded type  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));  			else  				throw new InvalidOperationException ("unexpected ldtoken instruction value");  			break;  		}  		case PE.OpCode.Constrained: {  			var constrained = (TypeRef)instruction.Value;  			if (i >= ctxt.Instructions.Length)  				throw new InvalidOperationException ("invalid instructions");  			instruction = ctxt.Instructions [i++];  			if (instruction.OpCode != PE.OpCode.Callvirt)  				throw new InvalidOperationException ("invalid instruction");  			instructions.Add (new MethodInstruction (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));  			break;  		}  		case PE.OpCode.Call:  			instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Callvirt:  			instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Ldftn:  			instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Ldvirtftn:  			instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Newobj:  			instructions.Add (new MethodInstruction (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Ldind_i1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int8Ref));  			break;  		case PE.OpCode.Ldind_u1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt8Ref));  			break;  		case PE.OpCode.Ldind_i2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int16Ref));  			break;  		case PE.OpCode.Ldind_u2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt16Ref));  			break;  		case PE.OpCode.Ldind_i4:  		case PE.OpCode.Ldind_u4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int32Ref));  			break;  		case PE.OpCode.Ldind_i8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int64Ref));  			break;  		case PE.OpCode.Ldind_i:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.IntNativeRef));  			break;  		case PE.OpCode.Ldind_r4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.SingleRef));  			break;  		case PE.OpCode.Ldind_r8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.DoubleRef));  			break;  		case PE.OpCode.Ldobj:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Stind_i1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int8Ref));  			break;  		case PE.OpCode.Stind_i2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int16Ref));  			break;  		case PE.OpCode.Stind_i4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int32Ref));  			break;  		case PE.OpCode.Stind_i8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int64Ref));  			break;  		case PE.OpCode.Stind_i:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.IntNativeRef));  			break;  		case PE.OpCode.Stind_r4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.SingleRef));  			break;  		case PE.OpCode.Stind_r8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.DoubleRef));  			break;  		case PE.OpCode.Stobj:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Cpobj:  			instructions.Add (new TypeInstruction (offset' TypeOp.Cpobj' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Newarr:  			instructions.Add (new TypeInstruction (offset' TypeOp.Newarr' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Initobj:  			instructions.Add (new TypeInstruction (offset' TypeOp.Initobj' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Castclass:  			instructions.Add (new TypeInstruction (offset' TypeOp.Castclass' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Isinst:  			instructions.Add (new TypeInstruction (offset' TypeOp.Isinst' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Box:  			instructions.Add (new TypeInstruction (offset' TypeOp.Box' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Unbox:  			instructions.Add (new TypeInstruction (offset' TypeOp.Unbox' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Unbox_any:  			instructions.Add (new TypeInstruction (offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Ldelem_i1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int8Ref));  			break;  		case PE.OpCode.Ldelem_u1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt8Ref));  			break;  		case PE.OpCode.Ldelem_i2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int16Ref));  			break;  		case PE.OpCode.Ldelem_u2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt16Ref));  			break;  		case PE.OpCode.Ldelem_i4:  		case PE.OpCode.Ldelem_u4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int32Ref));  			break;  		case PE.OpCode.Ldelem_i:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.IntNativeRef));  			break;  		case PE.OpCode.Ldelem_i8:  			// aka ldelem.u8  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int64Ref));  			break;  		case PE.OpCode.Ldelem_r4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.SingleRef));  			break;  		case PE.OpCode.Ldelem_r8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.DoubleRef));  			break;  		case PE.OpCode.Ldelem:  			// aka ldelem.any  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Stelem_i1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int8Ref));  			break;  		case PE.OpCode.Stelem_i2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int16Ref));  			break;  		case PE.OpCode.Stelem_i4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int32Ref));  			break;  		case PE.OpCode.Stelem_i8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int64Ref));  			break;  		case PE.OpCode.Stelem_i:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.IntNativeRef));  			break;  		case PE.OpCode.Stelem_r4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.SingleRef));  			break;  		case PE.OpCode.Stelem_r8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.DoubleRef));  			break;  		case PE.OpCode.Stelem:  			// aka stelem.any  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Readonly:  			if (i >= ctxt.Instructions.Length)  				throw new InvalidOperationException ("invalid instruction");  			instruction = ctxt.Instructions [i++];  			if (instruction.OpCode != PE.OpCode.Ldelema)  				throw new InvalidOperationException ("invalid instruction");  			instructions.Add (new LdElemAddrInstruction (offset' true' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Ldelema:  			instructions.Add (new LdElemAddrInstruction (offset' false' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Ldc_i4_0:  			instructions.Add (new LdInt32Instruction (offset' 0));  			break;  		case PE.OpCode.Ldc_i4_1:  			instructions.Add (new LdInt32Instruction (offset' 1));  			break;  		case PE.OpCode.Ldc_i4_2:  			instructions.Add (new LdInt32Instruction (offset' 2));  			break;  		case PE.OpCode.Ldc_i4_3:  			instructions.Add (new LdInt32Instruction (offset' 3));  			break;  		case PE.OpCode.Ldc_i4_4:  			instructions.Add (new LdInt32Instruction (offset' 4));  			break;  		case PE.OpCode.Ldc_i4_5:  			instructions.Add (new LdInt32Instruction (offset' 5));  			break;  		case PE.OpCode.Ldc_i4_6:  			instructions.Add (new LdInt32Instruction (offset' 6));  			break;  		case PE.OpCode.Ldc_i4_7:  			instructions.Add (new LdInt32Instruction (offset' 7));  			break;  		case PE.OpCode.Ldc_i4_8:  			instructions.Add (new LdInt32Instruction (offset' 8));  			break;  		case PE.OpCode.Ldc_i4_m1:  			instructions.Add (new LdInt32Instruction (offset' -1));  			break;  		case PE.OpCode.Ldc_i4:  		case PE.OpCode.Ldc_i4_s:  			instructions.Add (new LdInt32Instruction (offset' (int)instruction.Value));  			break;  		case PE.OpCode.Ldc_i8:  			instructions.Add (new LdInt64Instruction (offset' (long)instruction.Value));  			break;  		case PE.OpCode.Ldc_r4:  			instructions.Add (new LdSingleInstruction (offset' (float)instruction.Value));  			break;  		case PE.OpCode.Ldc_r8:  			instructions.Add (new LdDoubleInstruction (offset' (double)instruction.Value));  			break;  		case PE.OpCode.Ldstr:  			instructions.Add (new LdStringInstruction (offset' (string)instruction.Value));  			break;  		case PE.OpCode.Add:  			instructions.Add (new ArithInstruction (offset' ArithOp.Add' false' false));  			break;  		case PE.OpCode.Add_ovf:  			instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' false));  			break;  		case PE.OpCode.Add_ovf_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' true));  			break;  		case PE.OpCode.Sub:  			instructions.Add (new ArithInstruction (offset' ArithOp.Sub' false' false));  			break;  		case PE.OpCode.Sub_ovf:  			instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' false));  			break;  		case PE.OpCode.Sub_ovf_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' true));  			break;  		case PE.OpCode.Mul:  			instructions.Add (new ArithInstruction (offset' ArithOp.Mul' false' false));  			break;  		case PE.OpCode.Mul_ovf:  			instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' false));  			break;  		case PE.OpCode.Mul_ovf_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' true));  			break;  		case PE.OpCode.Div:  			instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' false));  			break;  		case PE.OpCode.Div_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' true));  			break;  		case PE.OpCode.Rem:  			instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' false));  			break;  		case PE.OpCode.Rem_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' true));  			break;  		case PE.OpCode.Neg:  			instructions.Add (new ArithInstruction (offset' ArithOp.Neg' false' false));  			break;  		case PE.OpCode.And:  			instructions.Add (new ArithInstruction (offset' ArithOp.BitAnd' false' false));  			break;  		case PE.OpCode.Or:  			instructions.Add (new ArithInstruction (offset' ArithOp.BitOr' false' false));  			break;  		case PE.OpCode.Xor:  			instructions.Add (new ArithInstruction (offset' ArithOp.BitXor' false' false));  			break;  		case PE.OpCode.Not:  			instructions.Add (new ArithInstruction (offset' ArithOp.BitNot' false' false));  			break;  		case PE.OpCode.Shl:  			instructions.Add (new ArithInstruction (offset' ArithOp.Shl' false' false));  			break;  		case PE.OpCode.Shr:  			instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' false));  			break;  		case PE.OpCode.Shr_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' true));  			break;  		case PE.OpCode.Conv_i1:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' false' false));  			break;  		case PE.OpCode.Conv_u1:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' false' false));  			break;  		case PE.OpCode.Conv_i2:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' false' false));  			break;  		case PE.OpCode.Conv_u2:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' false' false));  			break;  		case PE.OpCode.Conv_i4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' false' false));  			break;  		case PE.OpCode.Conv_u4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' false' false));  			break;  		case PE.OpCode.Conv_i8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' false' false));  			break;  		case PE.OpCode.Conv_u8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' false' false));  			break;  		case PE.OpCode.Conv_i:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' false' false));  			break;  		case PE.OpCode.Conv_u:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' false' false));  			break;  		case PE.OpCode.Conv_r4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Single' false' false));  			break;  		case PE.OpCode.Conv_r8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' false));  			break;  		case PE.OpCode.Conv_r_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' true));  			break;  		case PE.OpCode.Conv_ovf_i1:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' false));  			break;  		case PE.OpCode.Conv_ovf_u1:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' false));  			break;  		case PE.OpCode.Conv_ovf_i2:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' false));  			break;  		case PE.OpCode.Conv_ovf_u2:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' false));  			break;  		case PE.OpCode.Conv_ovf_i4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' false));  			break;  		case PE.OpCode.Conv_ovf_u4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' false));  			break;  		case PE.OpCode.Conv_ovf_i8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' false));  			break;  		case PE.OpCode.Conv_ovf_u8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' false));  			break;  		case PE.OpCode.Conv_ovf_i:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' false));  			break;  		case PE.OpCode.Conv_ovf_u:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' false));  			break;  		case PE.OpCode.Conv_ovf_i1_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' true));  			break;  		case PE.OpCode.Conv_ovf_u1_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' true));  			break;  		case PE.OpCode.Conv_ovf_i2_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' true));  			break;  		case PE.OpCode.Conv_ovf_u2_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' true));  			break;  		case PE.OpCode.Conv_ovf_i4_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' true));  			break;  		case PE.OpCode.Conv_ovf_u4_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' true));  			break;  		case PE.OpCode.Conv_ovf_i8_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' true));  			break;  		case PE.OpCode.Conv_ovf_u8_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' true));  			break;  		case PE.OpCode.Conv_ovf_i_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' true));  			break;  		case PE.OpCode.Conv_ovf_u_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' true));  			break;  		default:  			throw new InvalidOperationException ("invalid instruction");  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: if (j > i)  	i = j;  else {  	var ehcs = ctxt.OutermostTryBlocks (i);  	if (ehcs != null) {  		// A try instruction begins here with given handlers  		var offset = ctxt.Instructions [i].Offset;  		var tryCtxt = new TryTranslationContext (ctxt' i' ehcs);  		var tryBlock = InstructionsFromContext (tryCtxt);  		var handlers = new Seq<TryInstructionHandler> ();  		foreach (var ehc in ehcs) {  			var handlerCtxt = new HandlerTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.HandlerOffset]' ehc);  			var handlerBlock = InstructionsFromContext (handlerCtxt);  			switch (ehc.Flags) {  			case PE.CorILExceptionClause.Exception:  				handlers.Add (new CatchTryInstructionHandler ((TypeRef)ehc.Class' handlerBlock));  				break;  			case PE.CorILExceptionClause.Filter: {  				var filterCtxt = new FilterTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.FilterOffset]' ehc);  				var filterBlock = InstructionsFromContext (filterCtxt);  				handlers.Add (new FilterTryInstructionHandler (filterBlock' handlerBlock));  				break;  			}  			case PE.CorILExceptionClause.Finally:  				handlers.Add (new FinallyTryInstructionHandler (handlerBlock));  				break;  			case PE.CorILExceptionClause.Fault:  				handlers.Add (new FaultTryInstructionHandler (handlerBlock));  				break;  			default:  				throw new ArgumentOutOfRangeException ();  			}  		}  		instructions.Add (new TryInstruction (offset' tryBlock' handlers));  		// Jump over try block  		var nextOffset = ehcs [0].TryOffset + ehcs [0].TryLength;  		if (!ctxt.OffsetToIndex.TryGetValue (nextOffset' out i))  			i = ctxt.Instructions.Length;  	}  	else {  		var instruction = ctxt.Instructions [i++];  		var offset = instruction.Offset;  		while (instruction.OpCode == PE.OpCode.Unaligned || instruction.OpCode == PE.OpCode.Volatile || instruction.OpCode == PE.OpCode.Tailcall) {  			// Skip over any ignored prefixes' but remember instruction begins at original offset  			// NOTE: What ever happened to the "no." prefix mentioned in the spec?  			if (i >= ctxt.Instructions.Length)  				throw new InvalidOperationException ("invalid instructions");  			instruction = ctxt.Instructions [i++];  		}  		switch (instruction.OpCode) {  		case PE.OpCode.Cpblk:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Cpblk));  			break;  		case PE.OpCode.Initblk:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Initblk));  			break;  		case PE.OpCode.Arglist:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Arglist));  			break;  		case PE.OpCode.Localloc:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Localloc));  			break;  		case PE.OpCode.Jmp:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Jmp));  			break;  		case PE.OpCode.Calli:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Calli));  			break;  		case PE.OpCode.Sizeof:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Sizeof));  			break;  		case PE.OpCode.Mkrefany:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Mkrefany));  			break;  		case PE.OpCode.Refanytype:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanytype));  			break;  		case PE.OpCode.Refanyval:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanyval));  			break;  		case PE.OpCode.Nop:  			instructions.Add (new MiscInstruction (offset' MiscOp.Nop));  			break;  		case PE.OpCode.Break:  			instructions.Add (new MiscInstruction (offset' MiscOp.Break));  			break;  		case PE.OpCode.Dup:  			instructions.Add (new MiscInstruction (offset' MiscOp.Dup));  			break;  		case PE.OpCode.Pop:  			instructions.Add (new MiscInstruction (offset' MiscOp.Pop));  			break;  		case PE.OpCode.Ldnull:  			instructions.Add (new MiscInstruction (offset' MiscOp.Ldnull));  			break;  		case PE.OpCode.Ckfinite:  			instructions.Add (new MiscInstruction (offset' MiscOp.Ckfinite));  			break;  		case PE.OpCode.Throw:  			instructions.Add (new MiscInstruction (offset' MiscOp.Throw));  			break;  		case PE.OpCode.Rethrow:  			instructions.Add (new MiscInstruction (offset' MiscOp.Rethrow));  			break;  		case PE.OpCode.Ldind_ref:  			instructions.Add (new MiscInstruction (offset' MiscOp.LdindRef));  			break;  		case PE.OpCode.Stind_ref:  			instructions.Add (new MiscInstruction (offset' MiscOp.StindRef));  			break;  		case PE.OpCode.Ldelem_ref:  			instructions.Add (new MiscInstruction (offset' MiscOp.LdelemRef));  			break;  		case PE.OpCode.Stelem_ref:  			instructions.Add (new MiscInstruction (offset' MiscOp.StelemRef));  			break;  		case PE.OpCode.Ldlen:  			instructions.Add (new MiscInstruction (offset' MiscOp.Ldlen));  			break;  		case PE.OpCode.Ret:  			if (ctxt.ResultType == null)  				instructions.Add (new MiscInstruction (offset' MiscOp.Ret));  			else  				instructions.Add (new MiscInstruction (offset' MiscOp.RetVal));  			break;  		case PE.OpCode.Endfilter:  			instructions.Add (new MiscInstruction (offset' MiscOp.Endfilter));  			break;  		case PE.OpCode.Endfinally:  			// aka EndFault  			instructions.Add (new MiscInstruction (offset' MiscOp.Endfinally));  			break;  		case PE.OpCode.Br_s:  		case PE.OpCode.Br:  			instructions.Add (new BranchInstruction (offset' BranchOp.Br' false' (int)instruction.Value));  			break;  		case PE.OpCode.Brtrue_s:  		// aka brinst.s  		case PE.OpCode.Brtrue:  			// aka brinst  			instructions.Add (new BranchInstruction (offset' BranchOp.Brtrue' false' (int)instruction.Value));  			break;  		case PE.OpCode.Brfalse_s:  		// aka brzero.s' brnull.s  		case PE.OpCode.Brfalse:  			// aka brzero' brnull  			instructions.Add (new BranchInstruction (offset' BranchOp.Brfalse' false' (int)instruction.Value));  			break;  		case PE.OpCode.Beq:  		case PE.OpCode.Beq_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.Breq' false' (int)instruction.Value));  			break;  		case PE.OpCode.Bne_un:  		case PE.OpCode.Bne_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.Brne' false' (int)instruction.Value));  			break;  		case PE.OpCode.Leave:  		case PE.OpCode.Leave_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.Leave' false' (int)instruction.Value));  			break;  		case PE.OpCode.Blt:  		case PE.OpCode.Blt_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' false' (int)instruction.Value));  			break;  		case PE.OpCode.Blt_un:  		case PE.OpCode.Blt_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' true' (int)instruction.Value));  			break;  		case PE.OpCode.Ble:  		case PE.OpCode.Ble_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' false' (int)instruction.Value));  			break;  		case PE.OpCode.Ble_un:  		case PE.OpCode.Ble_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' true' (int)instruction.Value));  			break;  		case PE.OpCode.Bgt:  		case PE.OpCode.Bgt_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' false' (int)instruction.Value));  			break;  		case PE.OpCode.Bgt_un:  		case PE.OpCode.Bgt_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' true' (int)instruction.Value));  			break;  		case PE.OpCode.Bge:  		case PE.OpCode.Bge_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' false' (int)instruction.Value));  			break;  		case PE.OpCode.Bge_un:  		case PE.OpCode.Bge_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' true' (int)instruction.Value));  			break;  		case PE.OpCode.Switch:  			instructions.Add (new SwitchInstruction (offset' (Seq<int>)instruction.Value));  			break;  		case PE.OpCode.Ceq:  			instructions.Add (new CompareInstruction (offset' CompareOp.Ceq' false));  			break;  		case PE.OpCode.Clt:  			instructions.Add (new CompareInstruction (offset' CompareOp.Clt' false));  			break;  		case PE.OpCode.Clt_un:  			instructions.Add (new CompareInstruction (offset' CompareOp.Clt' true));  			break;  		case PE.OpCode.Cgt:  			instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' false));  			break;  		case PE.OpCode.Cgt_un:  			instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' true));  			break;  		case PE.OpCode.Ldarg_0:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));  			break;  		case PE.OpCode.Ldarg_1:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));  			break;  		case PE.OpCode.Ldarg_2:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));  			break;  		case PE.OpCode.Ldarg_3:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));  			break;  		case PE.OpCode.Ldarg:  		case PE.OpCode.Ldarg_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));  			break;  		case PE.OpCode.Ldarga:  		case PE.OpCode.Ldarga_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));  			break;  		case PE.OpCode.Starg:  		case PE.OpCode.Starg_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));  			break;  		case PE.OpCode.Ldloc_0:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 0));  			break;  		case PE.OpCode.Ldloc_1:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 1));  			break;  		case PE.OpCode.Ldloc_2:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 2));  			break;  		case PE.OpCode.Ldloc_3:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 3));  			break;  		case PE.OpCode.Ldloc:  		case PE.OpCode.Ldloc_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));  			break;  		case PE.OpCode.Ldloca:  		case PE.OpCode.Ldloca_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));  			break;  		case PE.OpCode.Stloc_0:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 0));  			break;  		case PE.OpCode.Stloc_1:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 1));  			break;  		case PE.OpCode.Stloc_2:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 2));  			break;  		case PE.OpCode.Stloc_3:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 3));  			break;  		case PE.OpCode.Stloc:  		case PE.OpCode.Stloc_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));  			break;  		case PE.OpCode.Ldfld:  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));  			break;  		case PE.OpCode.Ldsfld:  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));  			break;  		case PE.OpCode.Ldflda:  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));  			break;  		case PE.OpCode.Ldsflda:  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));  			break;  		case PE.OpCode.Stfld:  			instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));  			break;  		case PE.OpCode.Stsfld:  			instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));  			break;  		case PE.OpCode.Ldtoken: {  			if (instruction.Value is FieldRef)  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));  			else if (instruction.Value is MethodRef)  				instructions.Add (new MethodInstruction (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));  			else if (instruction.Value is TypeRef)  				// NOTE: May be a higher-kinded type  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));  			else  				throw new InvalidOperationException ("unexpected ldtoken instruction value");  			break;  		}  		case PE.OpCode.Constrained: {  			var constrained = (TypeRef)instruction.Value;  			if (i >= ctxt.Instructions.Length)  				throw new InvalidOperationException ("invalid instructions");  			instruction = ctxt.Instructions [i++];  			if (instruction.OpCode != PE.OpCode.Callvirt)  				throw new InvalidOperationException ("invalid instruction");  			instructions.Add (new MethodInstruction (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));  			break;  		}  		case PE.OpCode.Call:  			instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Callvirt:  			instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Ldftn:  			instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Ldvirtftn:  			instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Newobj:  			instructions.Add (new MethodInstruction (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Ldind_i1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int8Ref));  			break;  		case PE.OpCode.Ldind_u1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt8Ref));  			break;  		case PE.OpCode.Ldind_i2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int16Ref));  			break;  		case PE.OpCode.Ldind_u2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt16Ref));  			break;  		case PE.OpCode.Ldind_i4:  		case PE.OpCode.Ldind_u4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int32Ref));  			break;  		case PE.OpCode.Ldind_i8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int64Ref));  			break;  		case PE.OpCode.Ldind_i:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.IntNativeRef));  			break;  		case PE.OpCode.Ldind_r4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.SingleRef));  			break;  		case PE.OpCode.Ldind_r8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.DoubleRef));  			break;  		case PE.OpCode.Ldobj:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Stind_i1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int8Ref));  			break;  		case PE.OpCode.Stind_i2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int16Ref));  			break;  		case PE.OpCode.Stind_i4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int32Ref));  			break;  		case PE.OpCode.Stind_i8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int64Ref));  			break;  		case PE.OpCode.Stind_i:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.IntNativeRef));  			break;  		case PE.OpCode.Stind_r4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.SingleRef));  			break;  		case PE.OpCode.Stind_r8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.DoubleRef));  			break;  		case PE.OpCode.Stobj:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Cpobj:  			instructions.Add (new TypeInstruction (offset' TypeOp.Cpobj' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Newarr:  			instructions.Add (new TypeInstruction (offset' TypeOp.Newarr' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Initobj:  			instructions.Add (new TypeInstruction (offset' TypeOp.Initobj' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Castclass:  			instructions.Add (new TypeInstruction (offset' TypeOp.Castclass' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Isinst:  			instructions.Add (new TypeInstruction (offset' TypeOp.Isinst' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Box:  			instructions.Add (new TypeInstruction (offset' TypeOp.Box' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Unbox:  			instructions.Add (new TypeInstruction (offset' TypeOp.Unbox' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Unbox_any:  			instructions.Add (new TypeInstruction (offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Ldelem_i1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int8Ref));  			break;  		case PE.OpCode.Ldelem_u1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt8Ref));  			break;  		case PE.OpCode.Ldelem_i2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int16Ref));  			break;  		case PE.OpCode.Ldelem_u2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt16Ref));  			break;  		case PE.OpCode.Ldelem_i4:  		case PE.OpCode.Ldelem_u4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int32Ref));  			break;  		case PE.OpCode.Ldelem_i:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.IntNativeRef));  			break;  		case PE.OpCode.Ldelem_i8:  			// aka ldelem.u8  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int64Ref));  			break;  		case PE.OpCode.Ldelem_r4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.SingleRef));  			break;  		case PE.OpCode.Ldelem_r8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.DoubleRef));  			break;  		case PE.OpCode.Ldelem:  			// aka ldelem.any  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Stelem_i1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int8Ref));  			break;  		case PE.OpCode.Stelem_i2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int16Ref));  			break;  		case PE.OpCode.Stelem_i4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int32Ref));  			break;  		case PE.OpCode.Stelem_i8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int64Ref));  			break;  		case PE.OpCode.Stelem_i:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.IntNativeRef));  			break;  		case PE.OpCode.Stelem_r4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.SingleRef));  			break;  		case PE.OpCode.Stelem_r8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.DoubleRef));  			break;  		case PE.OpCode.Stelem:  			// aka stelem.any  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Readonly:  			if (i >= ctxt.Instructions.Length)  				throw new InvalidOperationException ("invalid instruction");  			instruction = ctxt.Instructions [i++];  			if (instruction.OpCode != PE.OpCode.Ldelema)  				throw new InvalidOperationException ("invalid instruction");  			instructions.Add (new LdElemAddrInstruction (offset' true' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Ldelema:  			instructions.Add (new LdElemAddrInstruction (offset' false' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Ldc_i4_0:  			instructions.Add (new LdInt32Instruction (offset' 0));  			break;  		case PE.OpCode.Ldc_i4_1:  			instructions.Add (new LdInt32Instruction (offset' 1));  			break;  		case PE.OpCode.Ldc_i4_2:  			instructions.Add (new LdInt32Instruction (offset' 2));  			break;  		case PE.OpCode.Ldc_i4_3:  			instructions.Add (new LdInt32Instruction (offset' 3));  			break;  		case PE.OpCode.Ldc_i4_4:  			instructions.Add (new LdInt32Instruction (offset' 4));  			break;  		case PE.OpCode.Ldc_i4_5:  			instructions.Add (new LdInt32Instruction (offset' 5));  			break;  		case PE.OpCode.Ldc_i4_6:  			instructions.Add (new LdInt32Instruction (offset' 6));  			break;  		case PE.OpCode.Ldc_i4_7:  			instructions.Add (new LdInt32Instruction (offset' 7));  			break;  		case PE.OpCode.Ldc_i4_8:  			instructions.Add (new LdInt32Instruction (offset' 8));  			break;  		case PE.OpCode.Ldc_i4_m1:  			instructions.Add (new LdInt32Instruction (offset' -1));  			break;  		case PE.OpCode.Ldc_i4:  		case PE.OpCode.Ldc_i4_s:  			instructions.Add (new LdInt32Instruction (offset' (int)instruction.Value));  			break;  		case PE.OpCode.Ldc_i8:  			instructions.Add (new LdInt64Instruction (offset' (long)instruction.Value));  			break;  		case PE.OpCode.Ldc_r4:  			instructions.Add (new LdSingleInstruction (offset' (float)instruction.Value));  			break;  		case PE.OpCode.Ldc_r8:  			instructions.Add (new LdDoubleInstruction (offset' (double)instruction.Value));  			break;  		case PE.OpCode.Ldstr:  			instructions.Add (new LdStringInstruction (offset' (string)instruction.Value));  			break;  		case PE.OpCode.Add:  			instructions.Add (new ArithInstruction (offset' ArithOp.Add' false' false));  			break;  		case PE.OpCode.Add_ovf:  			instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' false));  			break;  		case PE.OpCode.Add_ovf_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' true));  			break;  		case PE.OpCode.Sub:  			instructions.Add (new ArithInstruction (offset' ArithOp.Sub' false' false));  			break;  		case PE.OpCode.Sub_ovf:  			instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' false));  			break;  		case PE.OpCode.Sub_ovf_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' true));  			break;  		case PE.OpCode.Mul:  			instructions.Add (new ArithInstruction (offset' ArithOp.Mul' false' false));  			break;  		case PE.OpCode.Mul_ovf:  			instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' false));  			break;  		case PE.OpCode.Mul_ovf_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' true));  			break;  		case PE.OpCode.Div:  			instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' false));  			break;  		case PE.OpCode.Div_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' true));  			break;  		case PE.OpCode.Rem:  			instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' false));  			break;  		case PE.OpCode.Rem_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' true));  			break;  		case PE.OpCode.Neg:  			instructions.Add (new ArithInstruction (offset' ArithOp.Neg' false' false));  			break;  		case PE.OpCode.And:  			instructions.Add (new ArithInstruction (offset' ArithOp.BitAnd' false' false));  			break;  		case PE.OpCode.Or:  			instructions.Add (new ArithInstruction (offset' ArithOp.BitOr' false' false));  			break;  		case PE.OpCode.Xor:  			instructions.Add (new ArithInstruction (offset' ArithOp.BitXor' false' false));  			break;  		case PE.OpCode.Not:  			instructions.Add (new ArithInstruction (offset' ArithOp.BitNot' false' false));  			break;  		case PE.OpCode.Shl:  			instructions.Add (new ArithInstruction (offset' ArithOp.Shl' false' false));  			break;  		case PE.OpCode.Shr:  			instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' false));  			break;  		case PE.OpCode.Shr_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' true));  			break;  		case PE.OpCode.Conv_i1:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' false' false));  			break;  		case PE.OpCode.Conv_u1:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' false' false));  			break;  		case PE.OpCode.Conv_i2:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' false' false));  			break;  		case PE.OpCode.Conv_u2:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' false' false));  			break;  		case PE.OpCode.Conv_i4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' false' false));  			break;  		case PE.OpCode.Conv_u4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' false' false));  			break;  		case PE.OpCode.Conv_i8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' false' false));  			break;  		case PE.OpCode.Conv_u8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' false' false));  			break;  		case PE.OpCode.Conv_i:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' false' false));  			break;  		case PE.OpCode.Conv_u:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' false' false));  			break;  		case PE.OpCode.Conv_r4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Single' false' false));  			break;  		case PE.OpCode.Conv_r8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' false));  			break;  		case PE.OpCode.Conv_r_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' true));  			break;  		case PE.OpCode.Conv_ovf_i1:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' false));  			break;  		case PE.OpCode.Conv_ovf_u1:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' false));  			break;  		case PE.OpCode.Conv_ovf_i2:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' false));  			break;  		case PE.OpCode.Conv_ovf_u2:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' false));  			break;  		case PE.OpCode.Conv_ovf_i4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' false));  			break;  		case PE.OpCode.Conv_ovf_u4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' false));  			break;  		case PE.OpCode.Conv_ovf_i8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' false));  			break;  		case PE.OpCode.Conv_ovf_u8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' false));  			break;  		case PE.OpCode.Conv_ovf_i:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' false));  			break;  		case PE.OpCode.Conv_ovf_u:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' false));  			break;  		case PE.OpCode.Conv_ovf_i1_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' true));  			break;  		case PE.OpCode.Conv_ovf_u1_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' true));  			break;  		case PE.OpCode.Conv_ovf_i2_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' true));  			break;  		case PE.OpCode.Conv_ovf_u2_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' true));  			break;  		case PE.OpCode.Conv_ovf_i4_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' true));  			break;  		case PE.OpCode.Conv_ovf_u4_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' true));  			break;  		case PE.OpCode.Conv_ovf_i8_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' true));  			break;  		case PE.OpCode.Conv_ovf_u8_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' true));  			break;  		case PE.OpCode.Conv_ovf_i_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' true));  			break;  		case PE.OpCode.Conv_ovf_u_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' true));  			break;  		default:  			throw new InvalidOperationException ("invalid instruction");  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: if (j > i)  	i = j;  else {  	var ehcs = ctxt.OutermostTryBlocks (i);  	if (ehcs != null) {  		// A try instruction begins here with given handlers  		var offset = ctxt.Instructions [i].Offset;  		var tryCtxt = new TryTranslationContext (ctxt' i' ehcs);  		var tryBlock = InstructionsFromContext (tryCtxt);  		var handlers = new Seq<TryInstructionHandler> ();  		foreach (var ehc in ehcs) {  			var handlerCtxt = new HandlerTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.HandlerOffset]' ehc);  			var handlerBlock = InstructionsFromContext (handlerCtxt);  			switch (ehc.Flags) {  			case PE.CorILExceptionClause.Exception:  				handlers.Add (new CatchTryInstructionHandler ((TypeRef)ehc.Class' handlerBlock));  				break;  			case PE.CorILExceptionClause.Filter: {  				var filterCtxt = new FilterTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.FilterOffset]' ehc);  				var filterBlock = InstructionsFromContext (filterCtxt);  				handlers.Add (new FilterTryInstructionHandler (filterBlock' handlerBlock));  				break;  			}  			case PE.CorILExceptionClause.Finally:  				handlers.Add (new FinallyTryInstructionHandler (handlerBlock));  				break;  			case PE.CorILExceptionClause.Fault:  				handlers.Add (new FaultTryInstructionHandler (handlerBlock));  				break;  			default:  				throw new ArgumentOutOfRangeException ();  			}  		}  		instructions.Add (new TryInstruction (offset' tryBlock' handlers));  		// Jump over try block  		var nextOffset = ehcs [0].TryOffset + ehcs [0].TryLength;  		if (!ctxt.OffsetToIndex.TryGetValue (nextOffset' out i))  			i = ctxt.Instructions.Length;  	}  	else {  		var instruction = ctxt.Instructions [i++];  		var offset = instruction.Offset;  		while (instruction.OpCode == PE.OpCode.Unaligned || instruction.OpCode == PE.OpCode.Volatile || instruction.OpCode == PE.OpCode.Tailcall) {  			// Skip over any ignored prefixes' but remember instruction begins at original offset  			// NOTE: What ever happened to the "no." prefix mentioned in the spec?  			if (i >= ctxt.Instructions.Length)  				throw new InvalidOperationException ("invalid instructions");  			instruction = ctxt.Instructions [i++];  		}  		switch (instruction.OpCode) {  		case PE.OpCode.Cpblk:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Cpblk));  			break;  		case PE.OpCode.Initblk:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Initblk));  			break;  		case PE.OpCode.Arglist:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Arglist));  			break;  		case PE.OpCode.Localloc:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Localloc));  			break;  		case PE.OpCode.Jmp:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Jmp));  			break;  		case PE.OpCode.Calli:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Calli));  			break;  		case PE.OpCode.Sizeof:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Sizeof));  			break;  		case PE.OpCode.Mkrefany:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Mkrefany));  			break;  		case PE.OpCode.Refanytype:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanytype));  			break;  		case PE.OpCode.Refanyval:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanyval));  			break;  		case PE.OpCode.Nop:  			instructions.Add (new MiscInstruction (offset' MiscOp.Nop));  			break;  		case PE.OpCode.Break:  			instructions.Add (new MiscInstruction (offset' MiscOp.Break));  			break;  		case PE.OpCode.Dup:  			instructions.Add (new MiscInstruction (offset' MiscOp.Dup));  			break;  		case PE.OpCode.Pop:  			instructions.Add (new MiscInstruction (offset' MiscOp.Pop));  			break;  		case PE.OpCode.Ldnull:  			instructions.Add (new MiscInstruction (offset' MiscOp.Ldnull));  			break;  		case PE.OpCode.Ckfinite:  			instructions.Add (new MiscInstruction (offset' MiscOp.Ckfinite));  			break;  		case PE.OpCode.Throw:  			instructions.Add (new MiscInstruction (offset' MiscOp.Throw));  			break;  		case PE.OpCode.Rethrow:  			instructions.Add (new MiscInstruction (offset' MiscOp.Rethrow));  			break;  		case PE.OpCode.Ldind_ref:  			instructions.Add (new MiscInstruction (offset' MiscOp.LdindRef));  			break;  		case PE.OpCode.Stind_ref:  			instructions.Add (new MiscInstruction (offset' MiscOp.StindRef));  			break;  		case PE.OpCode.Ldelem_ref:  			instructions.Add (new MiscInstruction (offset' MiscOp.LdelemRef));  			break;  		case PE.OpCode.Stelem_ref:  			instructions.Add (new MiscInstruction (offset' MiscOp.StelemRef));  			break;  		case PE.OpCode.Ldlen:  			instructions.Add (new MiscInstruction (offset' MiscOp.Ldlen));  			break;  		case PE.OpCode.Ret:  			if (ctxt.ResultType == null)  				instructions.Add (new MiscInstruction (offset' MiscOp.Ret));  			else  				instructions.Add (new MiscInstruction (offset' MiscOp.RetVal));  			break;  		case PE.OpCode.Endfilter:  			instructions.Add (new MiscInstruction (offset' MiscOp.Endfilter));  			break;  		case PE.OpCode.Endfinally:  			// aka EndFault  			instructions.Add (new MiscInstruction (offset' MiscOp.Endfinally));  			break;  		case PE.OpCode.Br_s:  		case PE.OpCode.Br:  			instructions.Add (new BranchInstruction (offset' BranchOp.Br' false' (int)instruction.Value));  			break;  		case PE.OpCode.Brtrue_s:  		// aka brinst.s  		case PE.OpCode.Brtrue:  			// aka brinst  			instructions.Add (new BranchInstruction (offset' BranchOp.Brtrue' false' (int)instruction.Value));  			break;  		case PE.OpCode.Brfalse_s:  		// aka brzero.s' brnull.s  		case PE.OpCode.Brfalse:  			// aka brzero' brnull  			instructions.Add (new BranchInstruction (offset' BranchOp.Brfalse' false' (int)instruction.Value));  			break;  		case PE.OpCode.Beq:  		case PE.OpCode.Beq_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.Breq' false' (int)instruction.Value));  			break;  		case PE.OpCode.Bne_un:  		case PE.OpCode.Bne_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.Brne' false' (int)instruction.Value));  			break;  		case PE.OpCode.Leave:  		case PE.OpCode.Leave_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.Leave' false' (int)instruction.Value));  			break;  		case PE.OpCode.Blt:  		case PE.OpCode.Blt_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' false' (int)instruction.Value));  			break;  		case PE.OpCode.Blt_un:  		case PE.OpCode.Blt_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' true' (int)instruction.Value));  			break;  		case PE.OpCode.Ble:  		case PE.OpCode.Ble_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' false' (int)instruction.Value));  			break;  		case PE.OpCode.Ble_un:  		case PE.OpCode.Ble_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' true' (int)instruction.Value));  			break;  		case PE.OpCode.Bgt:  		case PE.OpCode.Bgt_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' false' (int)instruction.Value));  			break;  		case PE.OpCode.Bgt_un:  		case PE.OpCode.Bgt_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' true' (int)instruction.Value));  			break;  		case PE.OpCode.Bge:  		case PE.OpCode.Bge_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' false' (int)instruction.Value));  			break;  		case PE.OpCode.Bge_un:  		case PE.OpCode.Bge_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' true' (int)instruction.Value));  			break;  		case PE.OpCode.Switch:  			instructions.Add (new SwitchInstruction (offset' (Seq<int>)instruction.Value));  			break;  		case PE.OpCode.Ceq:  			instructions.Add (new CompareInstruction (offset' CompareOp.Ceq' false));  			break;  		case PE.OpCode.Clt:  			instructions.Add (new CompareInstruction (offset' CompareOp.Clt' false));  			break;  		case PE.OpCode.Clt_un:  			instructions.Add (new CompareInstruction (offset' CompareOp.Clt' true));  			break;  		case PE.OpCode.Cgt:  			instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' false));  			break;  		case PE.OpCode.Cgt_un:  			instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' true));  			break;  		case PE.OpCode.Ldarg_0:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));  			break;  		case PE.OpCode.Ldarg_1:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));  			break;  		case PE.OpCode.Ldarg_2:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));  			break;  		case PE.OpCode.Ldarg_3:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));  			break;  		case PE.OpCode.Ldarg:  		case PE.OpCode.Ldarg_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));  			break;  		case PE.OpCode.Ldarga:  		case PE.OpCode.Ldarga_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));  			break;  		case PE.OpCode.Starg:  		case PE.OpCode.Starg_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));  			break;  		case PE.OpCode.Ldloc_0:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 0));  			break;  		case PE.OpCode.Ldloc_1:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 1));  			break;  		case PE.OpCode.Ldloc_2:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 2));  			break;  		case PE.OpCode.Ldloc_3:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 3));  			break;  		case PE.OpCode.Ldloc:  		case PE.OpCode.Ldloc_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));  			break;  		case PE.OpCode.Ldloca:  		case PE.OpCode.Ldloca_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));  			break;  		case PE.OpCode.Stloc_0:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 0));  			break;  		case PE.OpCode.Stloc_1:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 1));  			break;  		case PE.OpCode.Stloc_2:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 2));  			break;  		case PE.OpCode.Stloc_3:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 3));  			break;  		case PE.OpCode.Stloc:  		case PE.OpCode.Stloc_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));  			break;  		case PE.OpCode.Ldfld:  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));  			break;  		case PE.OpCode.Ldsfld:  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));  			break;  		case PE.OpCode.Ldflda:  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));  			break;  		case PE.OpCode.Ldsflda:  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));  			break;  		case PE.OpCode.Stfld:  			instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));  			break;  		case PE.OpCode.Stsfld:  			instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));  			break;  		case PE.OpCode.Ldtoken: {  			if (instruction.Value is FieldRef)  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));  			else if (instruction.Value is MethodRef)  				instructions.Add (new MethodInstruction (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));  			else if (instruction.Value is TypeRef)  				// NOTE: May be a higher-kinded type  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));  			else  				throw new InvalidOperationException ("unexpected ldtoken instruction value");  			break;  		}  		case PE.OpCode.Constrained: {  			var constrained = (TypeRef)instruction.Value;  			if (i >= ctxt.Instructions.Length)  				throw new InvalidOperationException ("invalid instructions");  			instruction = ctxt.Instructions [i++];  			if (instruction.OpCode != PE.OpCode.Callvirt)  				throw new InvalidOperationException ("invalid instruction");  			instructions.Add (new MethodInstruction (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));  			break;  		}  		case PE.OpCode.Call:  			instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Callvirt:  			instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Ldftn:  			instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Ldvirtftn:  			instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Newobj:  			instructions.Add (new MethodInstruction (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Ldind_i1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int8Ref));  			break;  		case PE.OpCode.Ldind_u1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt8Ref));  			break;  		case PE.OpCode.Ldind_i2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int16Ref));  			break;  		case PE.OpCode.Ldind_u2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt16Ref));  			break;  		case PE.OpCode.Ldind_i4:  		case PE.OpCode.Ldind_u4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int32Ref));  			break;  		case PE.OpCode.Ldind_i8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int64Ref));  			break;  		case PE.OpCode.Ldind_i:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.IntNativeRef));  			break;  		case PE.OpCode.Ldind_r4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.SingleRef));  			break;  		case PE.OpCode.Ldind_r8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.DoubleRef));  			break;  		case PE.OpCode.Ldobj:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Stind_i1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int8Ref));  			break;  		case PE.OpCode.Stind_i2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int16Ref));  			break;  		case PE.OpCode.Stind_i4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int32Ref));  			break;  		case PE.OpCode.Stind_i8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int64Ref));  			break;  		case PE.OpCode.Stind_i:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.IntNativeRef));  			break;  		case PE.OpCode.Stind_r4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.SingleRef));  			break;  		case PE.OpCode.Stind_r8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.DoubleRef));  			break;  		case PE.OpCode.Stobj:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Cpobj:  			instructions.Add (new TypeInstruction (offset' TypeOp.Cpobj' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Newarr:  			instructions.Add (new TypeInstruction (offset' TypeOp.Newarr' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Initobj:  			instructions.Add (new TypeInstruction (offset' TypeOp.Initobj' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Castclass:  			instructions.Add (new TypeInstruction (offset' TypeOp.Castclass' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Isinst:  			instructions.Add (new TypeInstruction (offset' TypeOp.Isinst' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Box:  			instructions.Add (new TypeInstruction (offset' TypeOp.Box' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Unbox:  			instructions.Add (new TypeInstruction (offset' TypeOp.Unbox' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Unbox_any:  			instructions.Add (new TypeInstruction (offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Ldelem_i1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int8Ref));  			break;  		case PE.OpCode.Ldelem_u1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt8Ref));  			break;  		case PE.OpCode.Ldelem_i2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int16Ref));  			break;  		case PE.OpCode.Ldelem_u2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt16Ref));  			break;  		case PE.OpCode.Ldelem_i4:  		case PE.OpCode.Ldelem_u4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int32Ref));  			break;  		case PE.OpCode.Ldelem_i:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.IntNativeRef));  			break;  		case PE.OpCode.Ldelem_i8:  			// aka ldelem.u8  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int64Ref));  			break;  		case PE.OpCode.Ldelem_r4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.SingleRef));  			break;  		case PE.OpCode.Ldelem_r8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.DoubleRef));  			break;  		case PE.OpCode.Ldelem:  			// aka ldelem.any  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Stelem_i1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int8Ref));  			break;  		case PE.OpCode.Stelem_i2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int16Ref));  			break;  		case PE.OpCode.Stelem_i4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int32Ref));  			break;  		case PE.OpCode.Stelem_i8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int64Ref));  			break;  		case PE.OpCode.Stelem_i:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.IntNativeRef));  			break;  		case PE.OpCode.Stelem_r4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.SingleRef));  			break;  		case PE.OpCode.Stelem_r8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.DoubleRef));  			break;  		case PE.OpCode.Stelem:  			// aka stelem.any  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Readonly:  			if (i >= ctxt.Instructions.Length)  				throw new InvalidOperationException ("invalid instruction");  			instruction = ctxt.Instructions [i++];  			if (instruction.OpCode != PE.OpCode.Ldelema)  				throw new InvalidOperationException ("invalid instruction");  			instructions.Add (new LdElemAddrInstruction (offset' true' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Ldelema:  			instructions.Add (new LdElemAddrInstruction (offset' false' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Ldc_i4_0:  			instructions.Add (new LdInt32Instruction (offset' 0));  			break;  		case PE.OpCode.Ldc_i4_1:  			instructions.Add (new LdInt32Instruction (offset' 1));  			break;  		case PE.OpCode.Ldc_i4_2:  			instructions.Add (new LdInt32Instruction (offset' 2));  			break;  		case PE.OpCode.Ldc_i4_3:  			instructions.Add (new LdInt32Instruction (offset' 3));  			break;  		case PE.OpCode.Ldc_i4_4:  			instructions.Add (new LdInt32Instruction (offset' 4));  			break;  		case PE.OpCode.Ldc_i4_5:  			instructions.Add (new LdInt32Instruction (offset' 5));  			break;  		case PE.OpCode.Ldc_i4_6:  			instructions.Add (new LdInt32Instruction (offset' 6));  			break;  		case PE.OpCode.Ldc_i4_7:  			instructions.Add (new LdInt32Instruction (offset' 7));  			break;  		case PE.OpCode.Ldc_i4_8:  			instructions.Add (new LdInt32Instruction (offset' 8));  			break;  		case PE.OpCode.Ldc_i4_m1:  			instructions.Add (new LdInt32Instruction (offset' -1));  			break;  		case PE.OpCode.Ldc_i4:  		case PE.OpCode.Ldc_i4_s:  			instructions.Add (new LdInt32Instruction (offset' (int)instruction.Value));  			break;  		case PE.OpCode.Ldc_i8:  			instructions.Add (new LdInt64Instruction (offset' (long)instruction.Value));  			break;  		case PE.OpCode.Ldc_r4:  			instructions.Add (new LdSingleInstruction (offset' (float)instruction.Value));  			break;  		case PE.OpCode.Ldc_r8:  			instructions.Add (new LdDoubleInstruction (offset' (double)instruction.Value));  			break;  		case PE.OpCode.Ldstr:  			instructions.Add (new LdStringInstruction (offset' (string)instruction.Value));  			break;  		case PE.OpCode.Add:  			instructions.Add (new ArithInstruction (offset' ArithOp.Add' false' false));  			break;  		case PE.OpCode.Add_ovf:  			instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' false));  			break;  		case PE.OpCode.Add_ovf_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' true));  			break;  		case PE.OpCode.Sub:  			instructions.Add (new ArithInstruction (offset' ArithOp.Sub' false' false));  			break;  		case PE.OpCode.Sub_ovf:  			instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' false));  			break;  		case PE.OpCode.Sub_ovf_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' true));  			break;  		case PE.OpCode.Mul:  			instructions.Add (new ArithInstruction (offset' ArithOp.Mul' false' false));  			break;  		case PE.OpCode.Mul_ovf:  			instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' false));  			break;  		case PE.OpCode.Mul_ovf_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' true));  			break;  		case PE.OpCode.Div:  			instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' false));  			break;  		case PE.OpCode.Div_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' true));  			break;  		case PE.OpCode.Rem:  			instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' false));  			break;  		case PE.OpCode.Rem_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' true));  			break;  		case PE.OpCode.Neg:  			instructions.Add (new ArithInstruction (offset' ArithOp.Neg' false' false));  			break;  		case PE.OpCode.And:  			instructions.Add (new ArithInstruction (offset' ArithOp.BitAnd' false' false));  			break;  		case PE.OpCode.Or:  			instructions.Add (new ArithInstruction (offset' ArithOp.BitOr' false' false));  			break;  		case PE.OpCode.Xor:  			instructions.Add (new ArithInstruction (offset' ArithOp.BitXor' false' false));  			break;  		case PE.OpCode.Not:  			instructions.Add (new ArithInstruction (offset' ArithOp.BitNot' false' false));  			break;  		case PE.OpCode.Shl:  			instructions.Add (new ArithInstruction (offset' ArithOp.Shl' false' false));  			break;  		case PE.OpCode.Shr:  			instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' false));  			break;  		case PE.OpCode.Shr_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' true));  			break;  		case PE.OpCode.Conv_i1:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' false' false));  			break;  		case PE.OpCode.Conv_u1:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' false' false));  			break;  		case PE.OpCode.Conv_i2:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' false' false));  			break;  		case PE.OpCode.Conv_u2:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' false' false));  			break;  		case PE.OpCode.Conv_i4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' false' false));  			break;  		case PE.OpCode.Conv_u4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' false' false));  			break;  		case PE.OpCode.Conv_i8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' false' false));  			break;  		case PE.OpCode.Conv_u8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' false' false));  			break;  		case PE.OpCode.Conv_i:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' false' false));  			break;  		case PE.OpCode.Conv_u:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' false' false));  			break;  		case PE.OpCode.Conv_r4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Single' false' false));  			break;  		case PE.OpCode.Conv_r8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' false));  			break;  		case PE.OpCode.Conv_r_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' true));  			break;  		case PE.OpCode.Conv_ovf_i1:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' false));  			break;  		case PE.OpCode.Conv_ovf_u1:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' false));  			break;  		case PE.OpCode.Conv_ovf_i2:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' false));  			break;  		case PE.OpCode.Conv_ovf_u2:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' false));  			break;  		case PE.OpCode.Conv_ovf_i4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' false));  			break;  		case PE.OpCode.Conv_ovf_u4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' false));  			break;  		case PE.OpCode.Conv_ovf_i8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' false));  			break;  		case PE.OpCode.Conv_ovf_u8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' false));  			break;  		case PE.OpCode.Conv_ovf_i:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' false));  			break;  		case PE.OpCode.Conv_ovf_u:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' false));  			break;  		case PE.OpCode.Conv_ovf_i1_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' true));  			break;  		case PE.OpCode.Conv_ovf_u1_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' true));  			break;  		case PE.OpCode.Conv_ovf_i2_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' true));  			break;  		case PE.OpCode.Conv_ovf_u2_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' true));  			break;  		case PE.OpCode.Conv_ovf_i4_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' true));  			break;  		case PE.OpCode.Conv_ovf_u4_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' true));  			break;  		case PE.OpCode.Conv_ovf_i8_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' true));  			break;  		case PE.OpCode.Conv_ovf_u8_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' true));  			break;  		case PE.OpCode.Conv_ovf_i_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' true));  			break;  		case PE.OpCode.Conv_ovf_u_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' true));  			break;  		default:  			throw new InvalidOperationException ("invalid instruction");  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: if (j > i)  	i = j;  else {  	var ehcs = ctxt.OutermostTryBlocks (i);  	if (ehcs != null) {  		// A try instruction begins here with given handlers  		var offset = ctxt.Instructions [i].Offset;  		var tryCtxt = new TryTranslationContext (ctxt' i' ehcs);  		var tryBlock = InstructionsFromContext (tryCtxt);  		var handlers = new Seq<TryInstructionHandler> ();  		foreach (var ehc in ehcs) {  			var handlerCtxt = new HandlerTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.HandlerOffset]' ehc);  			var handlerBlock = InstructionsFromContext (handlerCtxt);  			switch (ehc.Flags) {  			case PE.CorILExceptionClause.Exception:  				handlers.Add (new CatchTryInstructionHandler ((TypeRef)ehc.Class' handlerBlock));  				break;  			case PE.CorILExceptionClause.Filter: {  				var filterCtxt = new FilterTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.FilterOffset]' ehc);  				var filterBlock = InstructionsFromContext (filterCtxt);  				handlers.Add (new FilterTryInstructionHandler (filterBlock' handlerBlock));  				break;  			}  			case PE.CorILExceptionClause.Finally:  				handlers.Add (new FinallyTryInstructionHandler (handlerBlock));  				break;  			case PE.CorILExceptionClause.Fault:  				handlers.Add (new FaultTryInstructionHandler (handlerBlock));  				break;  			default:  				throw new ArgumentOutOfRangeException ();  			}  		}  		instructions.Add (new TryInstruction (offset' tryBlock' handlers));  		// Jump over try block  		var nextOffset = ehcs [0].TryOffset + ehcs [0].TryLength;  		if (!ctxt.OffsetToIndex.TryGetValue (nextOffset' out i))  			i = ctxt.Instructions.Length;  	}  	else {  		var instruction = ctxt.Instructions [i++];  		var offset = instruction.Offset;  		while (instruction.OpCode == PE.OpCode.Unaligned || instruction.OpCode == PE.OpCode.Volatile || instruction.OpCode == PE.OpCode.Tailcall) {  			// Skip over any ignored prefixes' but remember instruction begins at original offset  			// NOTE: What ever happened to the "no." prefix mentioned in the spec?  			if (i >= ctxt.Instructions.Length)  				throw new InvalidOperationException ("invalid instructions");  			instruction = ctxt.Instructions [i++];  		}  		switch (instruction.OpCode) {  		case PE.OpCode.Cpblk:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Cpblk));  			break;  		case PE.OpCode.Initblk:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Initblk));  			break;  		case PE.OpCode.Arglist:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Arglist));  			break;  		case PE.OpCode.Localloc:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Localloc));  			break;  		case PE.OpCode.Jmp:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Jmp));  			break;  		case PE.OpCode.Calli:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Calli));  			break;  		case PE.OpCode.Sizeof:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Sizeof));  			break;  		case PE.OpCode.Mkrefany:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Mkrefany));  			break;  		case PE.OpCode.Refanytype:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanytype));  			break;  		case PE.OpCode.Refanyval:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanyval));  			break;  		case PE.OpCode.Nop:  			instructions.Add (new MiscInstruction (offset' MiscOp.Nop));  			break;  		case PE.OpCode.Break:  			instructions.Add (new MiscInstruction (offset' MiscOp.Break));  			break;  		case PE.OpCode.Dup:  			instructions.Add (new MiscInstruction (offset' MiscOp.Dup));  			break;  		case PE.OpCode.Pop:  			instructions.Add (new MiscInstruction (offset' MiscOp.Pop));  			break;  		case PE.OpCode.Ldnull:  			instructions.Add (new MiscInstruction (offset' MiscOp.Ldnull));  			break;  		case PE.OpCode.Ckfinite:  			instructions.Add (new MiscInstruction (offset' MiscOp.Ckfinite));  			break;  		case PE.OpCode.Throw:  			instructions.Add (new MiscInstruction (offset' MiscOp.Throw));  			break;  		case PE.OpCode.Rethrow:  			instructions.Add (new MiscInstruction (offset' MiscOp.Rethrow));  			break;  		case PE.OpCode.Ldind_ref:  			instructions.Add (new MiscInstruction (offset' MiscOp.LdindRef));  			break;  		case PE.OpCode.Stind_ref:  			instructions.Add (new MiscInstruction (offset' MiscOp.StindRef));  			break;  		case PE.OpCode.Ldelem_ref:  			instructions.Add (new MiscInstruction (offset' MiscOp.LdelemRef));  			break;  		case PE.OpCode.Stelem_ref:  			instructions.Add (new MiscInstruction (offset' MiscOp.StelemRef));  			break;  		case PE.OpCode.Ldlen:  			instructions.Add (new MiscInstruction (offset' MiscOp.Ldlen));  			break;  		case PE.OpCode.Ret:  			if (ctxt.ResultType == null)  				instructions.Add (new MiscInstruction (offset' MiscOp.Ret));  			else  				instructions.Add (new MiscInstruction (offset' MiscOp.RetVal));  			break;  		case PE.OpCode.Endfilter:  			instructions.Add (new MiscInstruction (offset' MiscOp.Endfilter));  			break;  		case PE.OpCode.Endfinally:  			// aka EndFault  			instructions.Add (new MiscInstruction (offset' MiscOp.Endfinally));  			break;  		case PE.OpCode.Br_s:  		case PE.OpCode.Br:  			instructions.Add (new BranchInstruction (offset' BranchOp.Br' false' (int)instruction.Value));  			break;  		case PE.OpCode.Brtrue_s:  		// aka brinst.s  		case PE.OpCode.Brtrue:  			// aka brinst  			instructions.Add (new BranchInstruction (offset' BranchOp.Brtrue' false' (int)instruction.Value));  			break;  		case PE.OpCode.Brfalse_s:  		// aka brzero.s' brnull.s  		case PE.OpCode.Brfalse:  			// aka brzero' brnull  			instructions.Add (new BranchInstruction (offset' BranchOp.Brfalse' false' (int)instruction.Value));  			break;  		case PE.OpCode.Beq:  		case PE.OpCode.Beq_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.Breq' false' (int)instruction.Value));  			break;  		case PE.OpCode.Bne_un:  		case PE.OpCode.Bne_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.Brne' false' (int)instruction.Value));  			break;  		case PE.OpCode.Leave:  		case PE.OpCode.Leave_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.Leave' false' (int)instruction.Value));  			break;  		case PE.OpCode.Blt:  		case PE.OpCode.Blt_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' false' (int)instruction.Value));  			break;  		case PE.OpCode.Blt_un:  		case PE.OpCode.Blt_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' true' (int)instruction.Value));  			break;  		case PE.OpCode.Ble:  		case PE.OpCode.Ble_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' false' (int)instruction.Value));  			break;  		case PE.OpCode.Ble_un:  		case PE.OpCode.Ble_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' true' (int)instruction.Value));  			break;  		case PE.OpCode.Bgt:  		case PE.OpCode.Bgt_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' false' (int)instruction.Value));  			break;  		case PE.OpCode.Bgt_un:  		case PE.OpCode.Bgt_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' true' (int)instruction.Value));  			break;  		case PE.OpCode.Bge:  		case PE.OpCode.Bge_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' false' (int)instruction.Value));  			break;  		case PE.OpCode.Bge_un:  		case PE.OpCode.Bge_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' true' (int)instruction.Value));  			break;  		case PE.OpCode.Switch:  			instructions.Add (new SwitchInstruction (offset' (Seq<int>)instruction.Value));  			break;  		case PE.OpCode.Ceq:  			instructions.Add (new CompareInstruction (offset' CompareOp.Ceq' false));  			break;  		case PE.OpCode.Clt:  			instructions.Add (new CompareInstruction (offset' CompareOp.Clt' false));  			break;  		case PE.OpCode.Clt_un:  			instructions.Add (new CompareInstruction (offset' CompareOp.Clt' true));  			break;  		case PE.OpCode.Cgt:  			instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' false));  			break;  		case PE.OpCode.Cgt_un:  			instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' true));  			break;  		case PE.OpCode.Ldarg_0:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));  			break;  		case PE.OpCode.Ldarg_1:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));  			break;  		case PE.OpCode.Ldarg_2:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));  			break;  		case PE.OpCode.Ldarg_3:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));  			break;  		case PE.OpCode.Ldarg:  		case PE.OpCode.Ldarg_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));  			break;  		case PE.OpCode.Ldarga:  		case PE.OpCode.Ldarga_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));  			break;  		case PE.OpCode.Starg:  		case PE.OpCode.Starg_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));  			break;  		case PE.OpCode.Ldloc_0:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 0));  			break;  		case PE.OpCode.Ldloc_1:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 1));  			break;  		case PE.OpCode.Ldloc_2:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 2));  			break;  		case PE.OpCode.Ldloc_3:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 3));  			break;  		case PE.OpCode.Ldloc:  		case PE.OpCode.Ldloc_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));  			break;  		case PE.OpCode.Ldloca:  		case PE.OpCode.Ldloca_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));  			break;  		case PE.OpCode.Stloc_0:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 0));  			break;  		case PE.OpCode.Stloc_1:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 1));  			break;  		case PE.OpCode.Stloc_2:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 2));  			break;  		case PE.OpCode.Stloc_3:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 3));  			break;  		case PE.OpCode.Stloc:  		case PE.OpCode.Stloc_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));  			break;  		case PE.OpCode.Ldfld:  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));  			break;  		case PE.OpCode.Ldsfld:  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));  			break;  		case PE.OpCode.Ldflda:  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));  			break;  		case PE.OpCode.Ldsflda:  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));  			break;  		case PE.OpCode.Stfld:  			instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));  			break;  		case PE.OpCode.Stsfld:  			instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));  			break;  		case PE.OpCode.Ldtoken: {  			if (instruction.Value is FieldRef)  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));  			else if (instruction.Value is MethodRef)  				instructions.Add (new MethodInstruction (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));  			else if (instruction.Value is TypeRef)  				// NOTE: May be a higher-kinded type  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));  			else  				throw new InvalidOperationException ("unexpected ldtoken instruction value");  			break;  		}  		case PE.OpCode.Constrained: {  			var constrained = (TypeRef)instruction.Value;  			if (i >= ctxt.Instructions.Length)  				throw new InvalidOperationException ("invalid instructions");  			instruction = ctxt.Instructions [i++];  			if (instruction.OpCode != PE.OpCode.Callvirt)  				throw new InvalidOperationException ("invalid instruction");  			instructions.Add (new MethodInstruction (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));  			break;  		}  		case PE.OpCode.Call:  			instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Callvirt:  			instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Ldftn:  			instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Ldvirtftn:  			instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Newobj:  			instructions.Add (new MethodInstruction (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Ldind_i1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int8Ref));  			break;  		case PE.OpCode.Ldind_u1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt8Ref));  			break;  		case PE.OpCode.Ldind_i2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int16Ref));  			break;  		case PE.OpCode.Ldind_u2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt16Ref));  			break;  		case PE.OpCode.Ldind_i4:  		case PE.OpCode.Ldind_u4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int32Ref));  			break;  		case PE.OpCode.Ldind_i8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int64Ref));  			break;  		case PE.OpCode.Ldind_i:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.IntNativeRef));  			break;  		case PE.OpCode.Ldind_r4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.SingleRef));  			break;  		case PE.OpCode.Ldind_r8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.DoubleRef));  			break;  		case PE.OpCode.Ldobj:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Stind_i1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int8Ref));  			break;  		case PE.OpCode.Stind_i2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int16Ref));  			break;  		case PE.OpCode.Stind_i4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int32Ref));  			break;  		case PE.OpCode.Stind_i8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int64Ref));  			break;  		case PE.OpCode.Stind_i:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.IntNativeRef));  			break;  		case PE.OpCode.Stind_r4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.SingleRef));  			break;  		case PE.OpCode.Stind_r8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.DoubleRef));  			break;  		case PE.OpCode.Stobj:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Cpobj:  			instructions.Add (new TypeInstruction (offset' TypeOp.Cpobj' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Newarr:  			instructions.Add (new TypeInstruction (offset' TypeOp.Newarr' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Initobj:  			instructions.Add (new TypeInstruction (offset' TypeOp.Initobj' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Castclass:  			instructions.Add (new TypeInstruction (offset' TypeOp.Castclass' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Isinst:  			instructions.Add (new TypeInstruction (offset' TypeOp.Isinst' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Box:  			instructions.Add (new TypeInstruction (offset' TypeOp.Box' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Unbox:  			instructions.Add (new TypeInstruction (offset' TypeOp.Unbox' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Unbox_any:  			instructions.Add (new TypeInstruction (offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Ldelem_i1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int8Ref));  			break;  		case PE.OpCode.Ldelem_u1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt8Ref));  			break;  		case PE.OpCode.Ldelem_i2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int16Ref));  			break;  		case PE.OpCode.Ldelem_u2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt16Ref));  			break;  		case PE.OpCode.Ldelem_i4:  		case PE.OpCode.Ldelem_u4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int32Ref));  			break;  		case PE.OpCode.Ldelem_i:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.IntNativeRef));  			break;  		case PE.OpCode.Ldelem_i8:  			// aka ldelem.u8  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int64Ref));  			break;  		case PE.OpCode.Ldelem_r4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.SingleRef));  			break;  		case PE.OpCode.Ldelem_r8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.DoubleRef));  			break;  		case PE.OpCode.Ldelem:  			// aka ldelem.any  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Stelem_i1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int8Ref));  			break;  		case PE.OpCode.Stelem_i2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int16Ref));  			break;  		case PE.OpCode.Stelem_i4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int32Ref));  			break;  		case PE.OpCode.Stelem_i8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int64Ref));  			break;  		case PE.OpCode.Stelem_i:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.IntNativeRef));  			break;  		case PE.OpCode.Stelem_r4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.SingleRef));  			break;  		case PE.OpCode.Stelem_r8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.DoubleRef));  			break;  		case PE.OpCode.Stelem:  			// aka stelem.any  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Readonly:  			if (i >= ctxt.Instructions.Length)  				throw new InvalidOperationException ("invalid instruction");  			instruction = ctxt.Instructions [i++];  			if (instruction.OpCode != PE.OpCode.Ldelema)  				throw new InvalidOperationException ("invalid instruction");  			instructions.Add (new LdElemAddrInstruction (offset' true' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Ldelema:  			instructions.Add (new LdElemAddrInstruction (offset' false' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Ldc_i4_0:  			instructions.Add (new LdInt32Instruction (offset' 0));  			break;  		case PE.OpCode.Ldc_i4_1:  			instructions.Add (new LdInt32Instruction (offset' 1));  			break;  		case PE.OpCode.Ldc_i4_2:  			instructions.Add (new LdInt32Instruction (offset' 2));  			break;  		case PE.OpCode.Ldc_i4_3:  			instructions.Add (new LdInt32Instruction (offset' 3));  			break;  		case PE.OpCode.Ldc_i4_4:  			instructions.Add (new LdInt32Instruction (offset' 4));  			break;  		case PE.OpCode.Ldc_i4_5:  			instructions.Add (new LdInt32Instruction (offset' 5));  			break;  		case PE.OpCode.Ldc_i4_6:  			instructions.Add (new LdInt32Instruction (offset' 6));  			break;  		case PE.OpCode.Ldc_i4_7:  			instructions.Add (new LdInt32Instruction (offset' 7));  			break;  		case PE.OpCode.Ldc_i4_8:  			instructions.Add (new LdInt32Instruction (offset' 8));  			break;  		case PE.OpCode.Ldc_i4_m1:  			instructions.Add (new LdInt32Instruction (offset' -1));  			break;  		case PE.OpCode.Ldc_i4:  		case PE.OpCode.Ldc_i4_s:  			instructions.Add (new LdInt32Instruction (offset' (int)instruction.Value));  			break;  		case PE.OpCode.Ldc_i8:  			instructions.Add (new LdInt64Instruction (offset' (long)instruction.Value));  			break;  		case PE.OpCode.Ldc_r4:  			instructions.Add (new LdSingleInstruction (offset' (float)instruction.Value));  			break;  		case PE.OpCode.Ldc_r8:  			instructions.Add (new LdDoubleInstruction (offset' (double)instruction.Value));  			break;  		case PE.OpCode.Ldstr:  			instructions.Add (new LdStringInstruction (offset' (string)instruction.Value));  			break;  		case PE.OpCode.Add:  			instructions.Add (new ArithInstruction (offset' ArithOp.Add' false' false));  			break;  		case PE.OpCode.Add_ovf:  			instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' false));  			break;  		case PE.OpCode.Add_ovf_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' true));  			break;  		case PE.OpCode.Sub:  			instructions.Add (new ArithInstruction (offset' ArithOp.Sub' false' false));  			break;  		case PE.OpCode.Sub_ovf:  			instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' false));  			break;  		case PE.OpCode.Sub_ovf_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' true));  			break;  		case PE.OpCode.Mul:  			instructions.Add (new ArithInstruction (offset' ArithOp.Mul' false' false));  			break;  		case PE.OpCode.Mul_ovf:  			instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' false));  			break;  		case PE.OpCode.Mul_ovf_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' true));  			break;  		case PE.OpCode.Div:  			instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' false));  			break;  		case PE.OpCode.Div_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' true));  			break;  		case PE.OpCode.Rem:  			instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' false));  			break;  		case PE.OpCode.Rem_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' true));  			break;  		case PE.OpCode.Neg:  			instructions.Add (new ArithInstruction (offset' ArithOp.Neg' false' false));  			break;  		case PE.OpCode.And:  			instructions.Add (new ArithInstruction (offset' ArithOp.BitAnd' false' false));  			break;  		case PE.OpCode.Or:  			instructions.Add (new ArithInstruction (offset' ArithOp.BitOr' false' false));  			break;  		case PE.OpCode.Xor:  			instructions.Add (new ArithInstruction (offset' ArithOp.BitXor' false' false));  			break;  		case PE.OpCode.Not:  			instructions.Add (new ArithInstruction (offset' ArithOp.BitNot' false' false));  			break;  		case PE.OpCode.Shl:  			instructions.Add (new ArithInstruction (offset' ArithOp.Shl' false' false));  			break;  		case PE.OpCode.Shr:  			instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' false));  			break;  		case PE.OpCode.Shr_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' true));  			break;  		case PE.OpCode.Conv_i1:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' false' false));  			break;  		case PE.OpCode.Conv_u1:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' false' false));  			break;  		case PE.OpCode.Conv_i2:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' false' false));  			break;  		case PE.OpCode.Conv_u2:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' false' false));  			break;  		case PE.OpCode.Conv_i4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' false' false));  			break;  		case PE.OpCode.Conv_u4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' false' false));  			break;  		case PE.OpCode.Conv_i8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' false' false));  			break;  		case PE.OpCode.Conv_u8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' false' false));  			break;  		case PE.OpCode.Conv_i:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' false' false));  			break;  		case PE.OpCode.Conv_u:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' false' false));  			break;  		case PE.OpCode.Conv_r4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Single' false' false));  			break;  		case PE.OpCode.Conv_r8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' false));  			break;  		case PE.OpCode.Conv_r_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' true));  			break;  		case PE.OpCode.Conv_ovf_i1:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' false));  			break;  		case PE.OpCode.Conv_ovf_u1:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' false));  			break;  		case PE.OpCode.Conv_ovf_i2:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' false));  			break;  		case PE.OpCode.Conv_ovf_u2:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' false));  			break;  		case PE.OpCode.Conv_ovf_i4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' false));  			break;  		case PE.OpCode.Conv_ovf_u4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' false));  			break;  		case PE.OpCode.Conv_ovf_i8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' false));  			break;  		case PE.OpCode.Conv_ovf_u8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' false));  			break;  		case PE.OpCode.Conv_ovf_i:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' false));  			break;  		case PE.OpCode.Conv_ovf_u:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' false));  			break;  		case PE.OpCode.Conv_ovf_i1_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' true));  			break;  		case PE.OpCode.Conv_ovf_u1_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' true));  			break;  		case PE.OpCode.Conv_ovf_i2_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' true));  			break;  		case PE.OpCode.Conv_ovf_u2_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' true));  			break;  		case PE.OpCode.Conv_ovf_i4_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' true));  			break;  		case PE.OpCode.Conv_ovf_u4_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' true));  			break;  		case PE.OpCode.Conv_ovf_i8_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' true));  			break;  		case PE.OpCode.Conv_ovf_u8_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' true));  			break;  		case PE.OpCode.Conv_ovf_i_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' true));  			break;  		case PE.OpCode.Conv_ovf_u_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' true));  			break;  		default:  			throw new InvalidOperationException ("invalid instruction");  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: if (j > i)  	i = j;  else {  	var ehcs = ctxt.OutermostTryBlocks (i);  	if (ehcs != null) {  		// A try instruction begins here with given handlers  		var offset = ctxt.Instructions [i].Offset;  		var tryCtxt = new TryTranslationContext (ctxt' i' ehcs);  		var tryBlock = InstructionsFromContext (tryCtxt);  		var handlers = new Seq<TryInstructionHandler> ();  		foreach (var ehc in ehcs) {  			var handlerCtxt = new HandlerTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.HandlerOffset]' ehc);  			var handlerBlock = InstructionsFromContext (handlerCtxt);  			switch (ehc.Flags) {  			case PE.CorILExceptionClause.Exception:  				handlers.Add (new CatchTryInstructionHandler ((TypeRef)ehc.Class' handlerBlock));  				break;  			case PE.CorILExceptionClause.Filter: {  				var filterCtxt = new FilterTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.FilterOffset]' ehc);  				var filterBlock = InstructionsFromContext (filterCtxt);  				handlers.Add (new FilterTryInstructionHandler (filterBlock' handlerBlock));  				break;  			}  			case PE.CorILExceptionClause.Finally:  				handlers.Add (new FinallyTryInstructionHandler (handlerBlock));  				break;  			case PE.CorILExceptionClause.Fault:  				handlers.Add (new FaultTryInstructionHandler (handlerBlock));  				break;  			default:  				throw new ArgumentOutOfRangeException ();  			}  		}  		instructions.Add (new TryInstruction (offset' tryBlock' handlers));  		// Jump over try block  		var nextOffset = ehcs [0].TryOffset + ehcs [0].TryLength;  		if (!ctxt.OffsetToIndex.TryGetValue (nextOffset' out i))  			i = ctxt.Instructions.Length;  	}  	else {  		var instruction = ctxt.Instructions [i++];  		var offset = instruction.Offset;  		while (instruction.OpCode == PE.OpCode.Unaligned || instruction.OpCode == PE.OpCode.Volatile || instruction.OpCode == PE.OpCode.Tailcall) {  			// Skip over any ignored prefixes' but remember instruction begins at original offset  			// NOTE: What ever happened to the "no." prefix mentioned in the spec?  			if (i >= ctxt.Instructions.Length)  				throw new InvalidOperationException ("invalid instructions");  			instruction = ctxt.Instructions [i++];  		}  		switch (instruction.OpCode) {  		case PE.OpCode.Cpblk:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Cpblk));  			break;  		case PE.OpCode.Initblk:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Initblk));  			break;  		case PE.OpCode.Arglist:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Arglist));  			break;  		case PE.OpCode.Localloc:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Localloc));  			break;  		case PE.OpCode.Jmp:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Jmp));  			break;  		case PE.OpCode.Calli:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Calli));  			break;  		case PE.OpCode.Sizeof:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Sizeof));  			break;  		case PE.OpCode.Mkrefany:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Mkrefany));  			break;  		case PE.OpCode.Refanytype:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanytype));  			break;  		case PE.OpCode.Refanyval:  			instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanyval));  			break;  		case PE.OpCode.Nop:  			instructions.Add (new MiscInstruction (offset' MiscOp.Nop));  			break;  		case PE.OpCode.Break:  			instructions.Add (new MiscInstruction (offset' MiscOp.Break));  			break;  		case PE.OpCode.Dup:  			instructions.Add (new MiscInstruction (offset' MiscOp.Dup));  			break;  		case PE.OpCode.Pop:  			instructions.Add (new MiscInstruction (offset' MiscOp.Pop));  			break;  		case PE.OpCode.Ldnull:  			instructions.Add (new MiscInstruction (offset' MiscOp.Ldnull));  			break;  		case PE.OpCode.Ckfinite:  			instructions.Add (new MiscInstruction (offset' MiscOp.Ckfinite));  			break;  		case PE.OpCode.Throw:  			instructions.Add (new MiscInstruction (offset' MiscOp.Throw));  			break;  		case PE.OpCode.Rethrow:  			instructions.Add (new MiscInstruction (offset' MiscOp.Rethrow));  			break;  		case PE.OpCode.Ldind_ref:  			instructions.Add (new MiscInstruction (offset' MiscOp.LdindRef));  			break;  		case PE.OpCode.Stind_ref:  			instructions.Add (new MiscInstruction (offset' MiscOp.StindRef));  			break;  		case PE.OpCode.Ldelem_ref:  			instructions.Add (new MiscInstruction (offset' MiscOp.LdelemRef));  			break;  		case PE.OpCode.Stelem_ref:  			instructions.Add (new MiscInstruction (offset' MiscOp.StelemRef));  			break;  		case PE.OpCode.Ldlen:  			instructions.Add (new MiscInstruction (offset' MiscOp.Ldlen));  			break;  		case PE.OpCode.Ret:  			if (ctxt.ResultType == null)  				instructions.Add (new MiscInstruction (offset' MiscOp.Ret));  			else  				instructions.Add (new MiscInstruction (offset' MiscOp.RetVal));  			break;  		case PE.OpCode.Endfilter:  			instructions.Add (new MiscInstruction (offset' MiscOp.Endfilter));  			break;  		case PE.OpCode.Endfinally:  			// aka EndFault  			instructions.Add (new MiscInstruction (offset' MiscOp.Endfinally));  			break;  		case PE.OpCode.Br_s:  		case PE.OpCode.Br:  			instructions.Add (new BranchInstruction (offset' BranchOp.Br' false' (int)instruction.Value));  			break;  		case PE.OpCode.Brtrue_s:  		// aka brinst.s  		case PE.OpCode.Brtrue:  			// aka brinst  			instructions.Add (new BranchInstruction (offset' BranchOp.Brtrue' false' (int)instruction.Value));  			break;  		case PE.OpCode.Brfalse_s:  		// aka brzero.s' brnull.s  		case PE.OpCode.Brfalse:  			// aka brzero' brnull  			instructions.Add (new BranchInstruction (offset' BranchOp.Brfalse' false' (int)instruction.Value));  			break;  		case PE.OpCode.Beq:  		case PE.OpCode.Beq_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.Breq' false' (int)instruction.Value));  			break;  		case PE.OpCode.Bne_un:  		case PE.OpCode.Bne_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.Brne' false' (int)instruction.Value));  			break;  		case PE.OpCode.Leave:  		case PE.OpCode.Leave_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.Leave' false' (int)instruction.Value));  			break;  		case PE.OpCode.Blt:  		case PE.OpCode.Blt_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' false' (int)instruction.Value));  			break;  		case PE.OpCode.Blt_un:  		case PE.OpCode.Blt_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' true' (int)instruction.Value));  			break;  		case PE.OpCode.Ble:  		case PE.OpCode.Ble_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' false' (int)instruction.Value));  			break;  		case PE.OpCode.Ble_un:  		case PE.OpCode.Ble_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' true' (int)instruction.Value));  			break;  		case PE.OpCode.Bgt:  		case PE.OpCode.Bgt_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' false' (int)instruction.Value));  			break;  		case PE.OpCode.Bgt_un:  		case PE.OpCode.Bgt_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' true' (int)instruction.Value));  			break;  		case PE.OpCode.Bge:  		case PE.OpCode.Bge_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' false' (int)instruction.Value));  			break;  		case PE.OpCode.Bge_un:  		case PE.OpCode.Bge_un_s:  			instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' true' (int)instruction.Value));  			break;  		case PE.OpCode.Switch:  			instructions.Add (new SwitchInstruction (offset' (Seq<int>)instruction.Value));  			break;  		case PE.OpCode.Ceq:  			instructions.Add (new CompareInstruction (offset' CompareOp.Ceq' false));  			break;  		case PE.OpCode.Clt:  			instructions.Add (new CompareInstruction (offset' CompareOp.Clt' false));  			break;  		case PE.OpCode.Clt_un:  			instructions.Add (new CompareInstruction (offset' CompareOp.Clt' true));  			break;  		case PE.OpCode.Cgt:  			instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' false));  			break;  		case PE.OpCode.Cgt_un:  			instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' true));  			break;  		case PE.OpCode.Ldarg_0:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));  			break;  		case PE.OpCode.Ldarg_1:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));  			break;  		case PE.OpCode.Ldarg_2:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));  			break;  		case PE.OpCode.Ldarg_3:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));  			break;  		case PE.OpCode.Ldarg:  		case PE.OpCode.Ldarg_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));  			break;  		case PE.OpCode.Ldarga:  		case PE.OpCode.Ldarga_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));  			break;  		case PE.OpCode.Starg:  		case PE.OpCode.Starg_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));  			break;  		case PE.OpCode.Ldloc_0:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 0));  			break;  		case PE.OpCode.Ldloc_1:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 1));  			break;  		case PE.OpCode.Ldloc_2:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 2));  			break;  		case PE.OpCode.Ldloc_3:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 3));  			break;  		case PE.OpCode.Ldloc:  		case PE.OpCode.Ldloc_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));  			break;  		case PE.OpCode.Ldloca:  		case PE.OpCode.Ldloca_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));  			break;  		case PE.OpCode.Stloc_0:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 0));  			break;  		case PE.OpCode.Stloc_1:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 1));  			break;  		case PE.OpCode.Stloc_2:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 2));  			break;  		case PE.OpCode.Stloc_3:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 3));  			break;  		case PE.OpCode.Stloc:  		case PE.OpCode.Stloc_s:  			instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));  			break;  		case PE.OpCode.Ldfld:  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));  			break;  		case PE.OpCode.Ldsfld:  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));  			break;  		case PE.OpCode.Ldflda:  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));  			break;  		case PE.OpCode.Ldsflda:  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));  			break;  		case PE.OpCode.Stfld:  			instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));  			break;  		case PE.OpCode.Stsfld:  			instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));  			break;  		case PE.OpCode.Ldtoken: {  			if (instruction.Value is FieldRef)  				instructions.Add (new FieldInstruction (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));  			else if (instruction.Value is MethodRef)  				instructions.Add (new MethodInstruction (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));  			else if (instruction.Value is TypeRef)  				// NOTE: May be a higher-kinded type  				instructions.Add (new TypeInstruction (offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));  			else  				throw new InvalidOperationException ("unexpected ldtoken instruction value");  			break;  		}  		case PE.OpCode.Constrained: {  			var constrained = (TypeRef)instruction.Value;  			if (i >= ctxt.Instructions.Length)  				throw new InvalidOperationException ("invalid instructions");  			instruction = ctxt.Instructions [i++];  			if (instruction.OpCode != PE.OpCode.Callvirt)  				throw new InvalidOperationException ("invalid instruction");  			instructions.Add (new MethodInstruction (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));  			break;  		}  		case PE.OpCode.Call:  			instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Callvirt:  			instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Ldftn:  			instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Ldvirtftn:  			instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Newobj:  			instructions.Add (new MethodInstruction (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));  			break;  		case PE.OpCode.Ldind_i1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int8Ref));  			break;  		case PE.OpCode.Ldind_u1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt8Ref));  			break;  		case PE.OpCode.Ldind_i2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int16Ref));  			break;  		case PE.OpCode.Ldind_u2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt16Ref));  			break;  		case PE.OpCode.Ldind_i4:  		case PE.OpCode.Ldind_u4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int32Ref));  			break;  		case PE.OpCode.Ldind_i8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int64Ref));  			break;  		case PE.OpCode.Ldind_i:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.IntNativeRef));  			break;  		case PE.OpCode.Ldind_r4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.SingleRef));  			break;  		case PE.OpCode.Ldind_r8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.DoubleRef));  			break;  		case PE.OpCode.Ldobj:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Stind_i1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int8Ref));  			break;  		case PE.OpCode.Stind_i2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int16Ref));  			break;  		case PE.OpCode.Stind_i4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int32Ref));  			break;  		case PE.OpCode.Stind_i8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int64Ref));  			break;  		case PE.OpCode.Stind_i:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.IntNativeRef));  			break;  		case PE.OpCode.Stind_r4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.SingleRef));  			break;  		case PE.OpCode.Stind_r8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.DoubleRef));  			break;  		case PE.OpCode.Stobj:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Cpobj:  			instructions.Add (new TypeInstruction (offset' TypeOp.Cpobj' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Newarr:  			instructions.Add (new TypeInstruction (offset' TypeOp.Newarr' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Initobj:  			instructions.Add (new TypeInstruction (offset' TypeOp.Initobj' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Castclass:  			instructions.Add (new TypeInstruction (offset' TypeOp.Castclass' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Isinst:  			instructions.Add (new TypeInstruction (offset' TypeOp.Isinst' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Box:  			instructions.Add (new TypeInstruction (offset' TypeOp.Box' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Unbox:  			instructions.Add (new TypeInstruction (offset' TypeOp.Unbox' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Unbox_any:  			instructions.Add (new TypeInstruction (offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Ldelem_i1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int8Ref));  			break;  		case PE.OpCode.Ldelem_u1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt8Ref));  			break;  		case PE.OpCode.Ldelem_i2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int16Ref));  			break;  		case PE.OpCode.Ldelem_u2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt16Ref));  			break;  		case PE.OpCode.Ldelem_i4:  		case PE.OpCode.Ldelem_u4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int32Ref));  			break;  		case PE.OpCode.Ldelem_i:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.IntNativeRef));  			break;  		case PE.OpCode.Ldelem_i8:  			// aka ldelem.u8  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int64Ref));  			break;  		case PE.OpCode.Ldelem_r4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.SingleRef));  			break;  		case PE.OpCode.Ldelem_r8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.DoubleRef));  			break;  		case PE.OpCode.Ldelem:  			// aka ldelem.any  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Stelem_i1:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int8Ref));  			break;  		case PE.OpCode.Stelem_i2:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int16Ref));  			break;  		case PE.OpCode.Stelem_i4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int32Ref));  			break;  		case PE.OpCode.Stelem_i8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int64Ref));  			break;  		case PE.OpCode.Stelem_i:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.IntNativeRef));  			break;  		case PE.OpCode.Stelem_r4:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.SingleRef));  			break;  		case PE.OpCode.Stelem_r8:  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.DoubleRef));  			break;  		case PE.OpCode.Stelem:  			// aka stelem.any  			instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Readonly:  			if (i >= ctxt.Instructions.Length)  				throw new InvalidOperationException ("invalid instruction");  			instruction = ctxt.Instructions [i++];  			if (instruction.OpCode != PE.OpCode.Ldelema)  				throw new InvalidOperationException ("invalid instruction");  			instructions.Add (new LdElemAddrInstruction (offset' true' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Ldelema:  			instructions.Add (new LdElemAddrInstruction (offset' false' (TypeRef)instruction.Value));  			break;  		case PE.OpCode.Ldc_i4_0:  			instructions.Add (new LdInt32Instruction (offset' 0));  			break;  		case PE.OpCode.Ldc_i4_1:  			instructions.Add (new LdInt32Instruction (offset' 1));  			break;  		case PE.OpCode.Ldc_i4_2:  			instructions.Add (new LdInt32Instruction (offset' 2));  			break;  		case PE.OpCode.Ldc_i4_3:  			instructions.Add (new LdInt32Instruction (offset' 3));  			break;  		case PE.OpCode.Ldc_i4_4:  			instructions.Add (new LdInt32Instruction (offset' 4));  			break;  		case PE.OpCode.Ldc_i4_5:  			instructions.Add (new LdInt32Instruction (offset' 5));  			break;  		case PE.OpCode.Ldc_i4_6:  			instructions.Add (new LdInt32Instruction (offset' 6));  			break;  		case PE.OpCode.Ldc_i4_7:  			instructions.Add (new LdInt32Instruction (offset' 7));  			break;  		case PE.OpCode.Ldc_i4_8:  			instructions.Add (new LdInt32Instruction (offset' 8));  			break;  		case PE.OpCode.Ldc_i4_m1:  			instructions.Add (new LdInt32Instruction (offset' -1));  			break;  		case PE.OpCode.Ldc_i4:  		case PE.OpCode.Ldc_i4_s:  			instructions.Add (new LdInt32Instruction (offset' (int)instruction.Value));  			break;  		case PE.OpCode.Ldc_i8:  			instructions.Add (new LdInt64Instruction (offset' (long)instruction.Value));  			break;  		case PE.OpCode.Ldc_r4:  			instructions.Add (new LdSingleInstruction (offset' (float)instruction.Value));  			break;  		case PE.OpCode.Ldc_r8:  			instructions.Add (new LdDoubleInstruction (offset' (double)instruction.Value));  			break;  		case PE.OpCode.Ldstr:  			instructions.Add (new LdStringInstruction (offset' (string)instruction.Value));  			break;  		case PE.OpCode.Add:  			instructions.Add (new ArithInstruction (offset' ArithOp.Add' false' false));  			break;  		case PE.OpCode.Add_ovf:  			instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' false));  			break;  		case PE.OpCode.Add_ovf_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' true));  			break;  		case PE.OpCode.Sub:  			instructions.Add (new ArithInstruction (offset' ArithOp.Sub' false' false));  			break;  		case PE.OpCode.Sub_ovf:  			instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' false));  			break;  		case PE.OpCode.Sub_ovf_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' true));  			break;  		case PE.OpCode.Mul:  			instructions.Add (new ArithInstruction (offset' ArithOp.Mul' false' false));  			break;  		case PE.OpCode.Mul_ovf:  			instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' false));  			break;  		case PE.OpCode.Mul_ovf_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' true));  			break;  		case PE.OpCode.Div:  			instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' false));  			break;  		case PE.OpCode.Div_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' true));  			break;  		case PE.OpCode.Rem:  			instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' false));  			break;  		case PE.OpCode.Rem_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' true));  			break;  		case PE.OpCode.Neg:  			instructions.Add (new ArithInstruction (offset' ArithOp.Neg' false' false));  			break;  		case PE.OpCode.And:  			instructions.Add (new ArithInstruction (offset' ArithOp.BitAnd' false' false));  			break;  		case PE.OpCode.Or:  			instructions.Add (new ArithInstruction (offset' ArithOp.BitOr' false' false));  			break;  		case PE.OpCode.Xor:  			instructions.Add (new ArithInstruction (offset' ArithOp.BitXor' false' false));  			break;  		case PE.OpCode.Not:  			instructions.Add (new ArithInstruction (offset' ArithOp.BitNot' false' false));  			break;  		case PE.OpCode.Shl:  			instructions.Add (new ArithInstruction (offset' ArithOp.Shl' false' false));  			break;  		case PE.OpCode.Shr:  			instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' false));  			break;  		case PE.OpCode.Shr_un:  			instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' true));  			break;  		case PE.OpCode.Conv_i1:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' false' false));  			break;  		case PE.OpCode.Conv_u1:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' false' false));  			break;  		case PE.OpCode.Conv_i2:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' false' false));  			break;  		case PE.OpCode.Conv_u2:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' false' false));  			break;  		case PE.OpCode.Conv_i4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' false' false));  			break;  		case PE.OpCode.Conv_u4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' false' false));  			break;  		case PE.OpCode.Conv_i8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' false' false));  			break;  		case PE.OpCode.Conv_u8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' false' false));  			break;  		case PE.OpCode.Conv_i:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' false' false));  			break;  		case PE.OpCode.Conv_u:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' false' false));  			break;  		case PE.OpCode.Conv_r4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Single' false' false));  			break;  		case PE.OpCode.Conv_r8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' false));  			break;  		case PE.OpCode.Conv_r_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' true));  			break;  		case PE.OpCode.Conv_ovf_i1:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' false));  			break;  		case PE.OpCode.Conv_ovf_u1:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' false));  			break;  		case PE.OpCode.Conv_ovf_i2:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' false));  			break;  		case PE.OpCode.Conv_ovf_u2:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' false));  			break;  		case PE.OpCode.Conv_ovf_i4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' false));  			break;  		case PE.OpCode.Conv_ovf_u4:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' false));  			break;  		case PE.OpCode.Conv_ovf_i8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' false));  			break;  		case PE.OpCode.Conv_ovf_u8:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' false));  			break;  		case PE.OpCode.Conv_ovf_i:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' false));  			break;  		case PE.OpCode.Conv_ovf_u:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' false));  			break;  		case PE.OpCode.Conv_ovf_i1_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' true));  			break;  		case PE.OpCode.Conv_ovf_u1_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' true));  			break;  		case PE.OpCode.Conv_ovf_i2_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' true));  			break;  		case PE.OpCode.Conv_ovf_u2_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' true));  			break;  		case PE.OpCode.Conv_ovf_i4_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' true));  			break;  		case PE.OpCode.Conv_ovf_u4_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' true));  			break;  		case PE.OpCode.Conv_ovf_i8_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' true));  			break;  		case PE.OpCode.Conv_ovf_u8_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' true));  			break;  		case PE.OpCode.Conv_ovf_i_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' true));  			break;  		case PE.OpCode.Conv_ovf_u_un:  			instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' true));  			break;  		default:  			throw new InvalidOperationException ("invalid instruction");  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: if (ehcs != null) {  	// A try instruction begins here with given handlers  	var offset = ctxt.Instructions [i].Offset;  	var tryCtxt = new TryTranslationContext (ctxt' i' ehcs);  	var tryBlock = InstructionsFromContext (tryCtxt);  	var handlers = new Seq<TryInstructionHandler> ();  	foreach (var ehc in ehcs) {  		var handlerCtxt = new HandlerTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.HandlerOffset]' ehc);  		var handlerBlock = InstructionsFromContext (handlerCtxt);  		switch (ehc.Flags) {  		case PE.CorILExceptionClause.Exception:  			handlers.Add (new CatchTryInstructionHandler ((TypeRef)ehc.Class' handlerBlock));  			break;  		case PE.CorILExceptionClause.Filter: {  			var filterCtxt = new FilterTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.FilterOffset]' ehc);  			var filterBlock = InstructionsFromContext (filterCtxt);  			handlers.Add (new FilterTryInstructionHandler (filterBlock' handlerBlock));  			break;  		}  		case PE.CorILExceptionClause.Finally:  			handlers.Add (new FinallyTryInstructionHandler (handlerBlock));  			break;  		case PE.CorILExceptionClause.Fault:  			handlers.Add (new FaultTryInstructionHandler (handlerBlock));  			break;  		default:  			throw new ArgumentOutOfRangeException ();  		}  	}  	instructions.Add (new TryInstruction (offset' tryBlock' handlers));  	// Jump over try block  	var nextOffset = ehcs [0].TryOffset + ehcs [0].TryLength;  	if (!ctxt.OffsetToIndex.TryGetValue (nextOffset' out i))  		i = ctxt.Instructions.Length;  }  else {  	var instruction = ctxt.Instructions [i++];  	var offset = instruction.Offset;  	while (instruction.OpCode == PE.OpCode.Unaligned || instruction.OpCode == PE.OpCode.Volatile || instruction.OpCode == PE.OpCode.Tailcall) {  		// Skip over any ignored prefixes' but remember instruction begins at original offset  		// NOTE: What ever happened to the "no." prefix mentioned in the spec?  		if (i >= ctxt.Instructions.Length)  			throw new InvalidOperationException ("invalid instructions");  		instruction = ctxt.Instructions [i++];  	}  	switch (instruction.OpCode) {  	case PE.OpCode.Cpblk:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Cpblk));  		break;  	case PE.OpCode.Initblk:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Initblk));  		break;  	case PE.OpCode.Arglist:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Arglist));  		break;  	case PE.OpCode.Localloc:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Localloc));  		break;  	case PE.OpCode.Jmp:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Jmp));  		break;  	case PE.OpCode.Calli:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Calli));  		break;  	case PE.OpCode.Sizeof:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Sizeof));  		break;  	case PE.OpCode.Mkrefany:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Mkrefany));  		break;  	case PE.OpCode.Refanytype:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanytype));  		break;  	case PE.OpCode.Refanyval:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanyval));  		break;  	case PE.OpCode.Nop:  		instructions.Add (new MiscInstruction (offset' MiscOp.Nop));  		break;  	case PE.OpCode.Break:  		instructions.Add (new MiscInstruction (offset' MiscOp.Break));  		break;  	case PE.OpCode.Dup:  		instructions.Add (new MiscInstruction (offset' MiscOp.Dup));  		break;  	case PE.OpCode.Pop:  		instructions.Add (new MiscInstruction (offset' MiscOp.Pop));  		break;  	case PE.OpCode.Ldnull:  		instructions.Add (new MiscInstruction (offset' MiscOp.Ldnull));  		break;  	case PE.OpCode.Ckfinite:  		instructions.Add (new MiscInstruction (offset' MiscOp.Ckfinite));  		break;  	case PE.OpCode.Throw:  		instructions.Add (new MiscInstruction (offset' MiscOp.Throw));  		break;  	case PE.OpCode.Rethrow:  		instructions.Add (new MiscInstruction (offset' MiscOp.Rethrow));  		break;  	case PE.OpCode.Ldind_ref:  		instructions.Add (new MiscInstruction (offset' MiscOp.LdindRef));  		break;  	case PE.OpCode.Stind_ref:  		instructions.Add (new MiscInstruction (offset' MiscOp.StindRef));  		break;  	case PE.OpCode.Ldelem_ref:  		instructions.Add (new MiscInstruction (offset' MiscOp.LdelemRef));  		break;  	case PE.OpCode.Stelem_ref:  		instructions.Add (new MiscInstruction (offset' MiscOp.StelemRef));  		break;  	case PE.OpCode.Ldlen:  		instructions.Add (new MiscInstruction (offset' MiscOp.Ldlen));  		break;  	case PE.OpCode.Ret:  		if (ctxt.ResultType == null)  			instructions.Add (new MiscInstruction (offset' MiscOp.Ret));  		else  			instructions.Add (new MiscInstruction (offset' MiscOp.RetVal));  		break;  	case PE.OpCode.Endfilter:  		instructions.Add (new MiscInstruction (offset' MiscOp.Endfilter));  		break;  	case PE.OpCode.Endfinally:  		// aka EndFault  		instructions.Add (new MiscInstruction (offset' MiscOp.Endfinally));  		break;  	case PE.OpCode.Br_s:  	case PE.OpCode.Br:  		instructions.Add (new BranchInstruction (offset' BranchOp.Br' false' (int)instruction.Value));  		break;  	case PE.OpCode.Brtrue_s:  	// aka brinst.s  	case PE.OpCode.Brtrue:  		// aka brinst  		instructions.Add (new BranchInstruction (offset' BranchOp.Brtrue' false' (int)instruction.Value));  		break;  	case PE.OpCode.Brfalse_s:  	// aka brzero.s' brnull.s  	case PE.OpCode.Brfalse:  		// aka brzero' brnull  		instructions.Add (new BranchInstruction (offset' BranchOp.Brfalse' false' (int)instruction.Value));  		break;  	case PE.OpCode.Beq:  	case PE.OpCode.Beq_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.Breq' false' (int)instruction.Value));  		break;  	case PE.OpCode.Bne_un:  	case PE.OpCode.Bne_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.Brne' false' (int)instruction.Value));  		break;  	case PE.OpCode.Leave:  	case PE.OpCode.Leave_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.Leave' false' (int)instruction.Value));  		break;  	case PE.OpCode.Blt:  	case PE.OpCode.Blt_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' false' (int)instruction.Value));  		break;  	case PE.OpCode.Blt_un:  	case PE.OpCode.Blt_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' true' (int)instruction.Value));  		break;  	case PE.OpCode.Ble:  	case PE.OpCode.Ble_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' false' (int)instruction.Value));  		break;  	case PE.OpCode.Ble_un:  	case PE.OpCode.Ble_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' true' (int)instruction.Value));  		break;  	case PE.OpCode.Bgt:  	case PE.OpCode.Bgt_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' false' (int)instruction.Value));  		break;  	case PE.OpCode.Bgt_un:  	case PE.OpCode.Bgt_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' true' (int)instruction.Value));  		break;  	case PE.OpCode.Bge:  	case PE.OpCode.Bge_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' false' (int)instruction.Value));  		break;  	case PE.OpCode.Bge_un:  	case PE.OpCode.Bge_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' true' (int)instruction.Value));  		break;  	case PE.OpCode.Switch:  		instructions.Add (new SwitchInstruction (offset' (Seq<int>)instruction.Value));  		break;  	case PE.OpCode.Ceq:  		instructions.Add (new CompareInstruction (offset' CompareOp.Ceq' false));  		break;  	case PE.OpCode.Clt:  		instructions.Add (new CompareInstruction (offset' CompareOp.Clt' false));  		break;  	case PE.OpCode.Clt_un:  		instructions.Add (new CompareInstruction (offset' CompareOp.Clt' true));  		break;  	case PE.OpCode.Cgt:  		instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' false));  		break;  	case PE.OpCode.Cgt_un:  		instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' true));  		break;  	case PE.OpCode.Ldarg_0:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));  		break;  	case PE.OpCode.Ldarg_1:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));  		break;  	case PE.OpCode.Ldarg_2:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));  		break;  	case PE.OpCode.Ldarg_3:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));  		break;  	case PE.OpCode.Ldarg:  	case PE.OpCode.Ldarg_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));  		break;  	case PE.OpCode.Ldarga:  	case PE.OpCode.Ldarga_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));  		break;  	case PE.OpCode.Starg:  	case PE.OpCode.Starg_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));  		break;  	case PE.OpCode.Ldloc_0:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 0));  		break;  	case PE.OpCode.Ldloc_1:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 1));  		break;  	case PE.OpCode.Ldloc_2:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 2));  		break;  	case PE.OpCode.Ldloc_3:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 3));  		break;  	case PE.OpCode.Ldloc:  	case PE.OpCode.Ldloc_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));  		break;  	case PE.OpCode.Ldloca:  	case PE.OpCode.Ldloca_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));  		break;  	case PE.OpCode.Stloc_0:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 0));  		break;  	case PE.OpCode.Stloc_1:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 1));  		break;  	case PE.OpCode.Stloc_2:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 2));  		break;  	case PE.OpCode.Stloc_3:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 3));  		break;  	case PE.OpCode.Stloc:  	case PE.OpCode.Stloc_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));  		break;  	case PE.OpCode.Ldfld:  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));  		break;  	case PE.OpCode.Ldsfld:  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));  		break;  	case PE.OpCode.Ldflda:  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));  		break;  	case PE.OpCode.Ldsflda:  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));  		break;  	case PE.OpCode.Stfld:  		instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));  		break;  	case PE.OpCode.Stsfld:  		instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));  		break;  	case PE.OpCode.Ldtoken: {  		if (instruction.Value is FieldRef)  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));  		else if (instruction.Value is MethodRef)  			instructions.Add (new MethodInstruction (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));  		else if (instruction.Value is TypeRef)  			// NOTE: May be a higher-kinded type  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));  		else  			throw new InvalidOperationException ("unexpected ldtoken instruction value");  		break;  	}  	case PE.OpCode.Constrained: {  		var constrained = (TypeRef)instruction.Value;  		if (i >= ctxt.Instructions.Length)  			throw new InvalidOperationException ("invalid instructions");  		instruction = ctxt.Instructions [i++];  		if (instruction.OpCode != PE.OpCode.Callvirt)  			throw new InvalidOperationException ("invalid instruction");  		instructions.Add (new MethodInstruction (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));  		break;  	}  	case PE.OpCode.Call:  		instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Callvirt:  		instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Ldftn:  		instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Ldvirtftn:  		instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Newobj:  		instructions.Add (new MethodInstruction (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Ldind_i1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int8Ref));  		break;  	case PE.OpCode.Ldind_u1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt8Ref));  		break;  	case PE.OpCode.Ldind_i2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int16Ref));  		break;  	case PE.OpCode.Ldind_u2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt16Ref));  		break;  	case PE.OpCode.Ldind_i4:  	case PE.OpCode.Ldind_u4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int32Ref));  		break;  	case PE.OpCode.Ldind_i8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int64Ref));  		break;  	case PE.OpCode.Ldind_i:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.IntNativeRef));  		break;  	case PE.OpCode.Ldind_r4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.SingleRef));  		break;  	case PE.OpCode.Ldind_r8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.DoubleRef));  		break;  	case PE.OpCode.Ldobj:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Stind_i1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int8Ref));  		break;  	case PE.OpCode.Stind_i2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int16Ref));  		break;  	case PE.OpCode.Stind_i4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int32Ref));  		break;  	case PE.OpCode.Stind_i8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int64Ref));  		break;  	case PE.OpCode.Stind_i:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.IntNativeRef));  		break;  	case PE.OpCode.Stind_r4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.SingleRef));  		break;  	case PE.OpCode.Stind_r8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.DoubleRef));  		break;  	case PE.OpCode.Stobj:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Cpobj:  		instructions.Add (new TypeInstruction (offset' TypeOp.Cpobj' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Newarr:  		instructions.Add (new TypeInstruction (offset' TypeOp.Newarr' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Initobj:  		instructions.Add (new TypeInstruction (offset' TypeOp.Initobj' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Castclass:  		instructions.Add (new TypeInstruction (offset' TypeOp.Castclass' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Isinst:  		instructions.Add (new TypeInstruction (offset' TypeOp.Isinst' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Box:  		instructions.Add (new TypeInstruction (offset' TypeOp.Box' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Unbox:  		instructions.Add (new TypeInstruction (offset' TypeOp.Unbox' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Unbox_any:  		instructions.Add (new TypeInstruction (offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Ldelem_i1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int8Ref));  		break;  	case PE.OpCode.Ldelem_u1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt8Ref));  		break;  	case PE.OpCode.Ldelem_i2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int16Ref));  		break;  	case PE.OpCode.Ldelem_u2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt16Ref));  		break;  	case PE.OpCode.Ldelem_i4:  	case PE.OpCode.Ldelem_u4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int32Ref));  		break;  	case PE.OpCode.Ldelem_i:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.IntNativeRef));  		break;  	case PE.OpCode.Ldelem_i8:  		// aka ldelem.u8  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int64Ref));  		break;  	case PE.OpCode.Ldelem_r4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.SingleRef));  		break;  	case PE.OpCode.Ldelem_r8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.DoubleRef));  		break;  	case PE.OpCode.Ldelem:  		// aka ldelem.any  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Stelem_i1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int8Ref));  		break;  	case PE.OpCode.Stelem_i2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int16Ref));  		break;  	case PE.OpCode.Stelem_i4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int32Ref));  		break;  	case PE.OpCode.Stelem_i8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int64Ref));  		break;  	case PE.OpCode.Stelem_i:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.IntNativeRef));  		break;  	case PE.OpCode.Stelem_r4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.SingleRef));  		break;  	case PE.OpCode.Stelem_r8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.DoubleRef));  		break;  	case PE.OpCode.Stelem:  		// aka stelem.any  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Readonly:  		if (i >= ctxt.Instructions.Length)  			throw new InvalidOperationException ("invalid instruction");  		instruction = ctxt.Instructions [i++];  		if (instruction.OpCode != PE.OpCode.Ldelema)  			throw new InvalidOperationException ("invalid instruction");  		instructions.Add (new LdElemAddrInstruction (offset' true' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Ldelema:  		instructions.Add (new LdElemAddrInstruction (offset' false' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Ldc_i4_0:  		instructions.Add (new LdInt32Instruction (offset' 0));  		break;  	case PE.OpCode.Ldc_i4_1:  		instructions.Add (new LdInt32Instruction (offset' 1));  		break;  	case PE.OpCode.Ldc_i4_2:  		instructions.Add (new LdInt32Instruction (offset' 2));  		break;  	case PE.OpCode.Ldc_i4_3:  		instructions.Add (new LdInt32Instruction (offset' 3));  		break;  	case PE.OpCode.Ldc_i4_4:  		instructions.Add (new LdInt32Instruction (offset' 4));  		break;  	case PE.OpCode.Ldc_i4_5:  		instructions.Add (new LdInt32Instruction (offset' 5));  		break;  	case PE.OpCode.Ldc_i4_6:  		instructions.Add (new LdInt32Instruction (offset' 6));  		break;  	case PE.OpCode.Ldc_i4_7:  		instructions.Add (new LdInt32Instruction (offset' 7));  		break;  	case PE.OpCode.Ldc_i4_8:  		instructions.Add (new LdInt32Instruction (offset' 8));  		break;  	case PE.OpCode.Ldc_i4_m1:  		instructions.Add (new LdInt32Instruction (offset' -1));  		break;  	case PE.OpCode.Ldc_i4:  	case PE.OpCode.Ldc_i4_s:  		instructions.Add (new LdInt32Instruction (offset' (int)instruction.Value));  		break;  	case PE.OpCode.Ldc_i8:  		instructions.Add (new LdInt64Instruction (offset' (long)instruction.Value));  		break;  	case PE.OpCode.Ldc_r4:  		instructions.Add (new LdSingleInstruction (offset' (float)instruction.Value));  		break;  	case PE.OpCode.Ldc_r8:  		instructions.Add (new LdDoubleInstruction (offset' (double)instruction.Value));  		break;  	case PE.OpCode.Ldstr:  		instructions.Add (new LdStringInstruction (offset' (string)instruction.Value));  		break;  	case PE.OpCode.Add:  		instructions.Add (new ArithInstruction (offset' ArithOp.Add' false' false));  		break;  	case PE.OpCode.Add_ovf:  		instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' false));  		break;  	case PE.OpCode.Add_ovf_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' true));  		break;  	case PE.OpCode.Sub:  		instructions.Add (new ArithInstruction (offset' ArithOp.Sub' false' false));  		break;  	case PE.OpCode.Sub_ovf:  		instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' false));  		break;  	case PE.OpCode.Sub_ovf_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' true));  		break;  	case PE.OpCode.Mul:  		instructions.Add (new ArithInstruction (offset' ArithOp.Mul' false' false));  		break;  	case PE.OpCode.Mul_ovf:  		instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' false));  		break;  	case PE.OpCode.Mul_ovf_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' true));  		break;  	case PE.OpCode.Div:  		instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' false));  		break;  	case PE.OpCode.Div_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' true));  		break;  	case PE.OpCode.Rem:  		instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' false));  		break;  	case PE.OpCode.Rem_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' true));  		break;  	case PE.OpCode.Neg:  		instructions.Add (new ArithInstruction (offset' ArithOp.Neg' false' false));  		break;  	case PE.OpCode.And:  		instructions.Add (new ArithInstruction (offset' ArithOp.BitAnd' false' false));  		break;  	case PE.OpCode.Or:  		instructions.Add (new ArithInstruction (offset' ArithOp.BitOr' false' false));  		break;  	case PE.OpCode.Xor:  		instructions.Add (new ArithInstruction (offset' ArithOp.BitXor' false' false));  		break;  	case PE.OpCode.Not:  		instructions.Add (new ArithInstruction (offset' ArithOp.BitNot' false' false));  		break;  	case PE.OpCode.Shl:  		instructions.Add (new ArithInstruction (offset' ArithOp.Shl' false' false));  		break;  	case PE.OpCode.Shr:  		instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' false));  		break;  	case PE.OpCode.Shr_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' true));  		break;  	case PE.OpCode.Conv_i1:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' false' false));  		break;  	case PE.OpCode.Conv_u1:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' false' false));  		break;  	case PE.OpCode.Conv_i2:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' false' false));  		break;  	case PE.OpCode.Conv_u2:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' false' false));  		break;  	case PE.OpCode.Conv_i4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' false' false));  		break;  	case PE.OpCode.Conv_u4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' false' false));  		break;  	case PE.OpCode.Conv_i8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' false' false));  		break;  	case PE.OpCode.Conv_u8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' false' false));  		break;  	case PE.OpCode.Conv_i:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' false' false));  		break;  	case PE.OpCode.Conv_u:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' false' false));  		break;  	case PE.OpCode.Conv_r4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Single' false' false));  		break;  	case PE.OpCode.Conv_r8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' false));  		break;  	case PE.OpCode.Conv_r_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' true));  		break;  	case PE.OpCode.Conv_ovf_i1:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' false));  		break;  	case PE.OpCode.Conv_ovf_u1:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' false));  		break;  	case PE.OpCode.Conv_ovf_i2:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' false));  		break;  	case PE.OpCode.Conv_ovf_u2:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' false));  		break;  	case PE.OpCode.Conv_ovf_i4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' false));  		break;  	case PE.OpCode.Conv_ovf_u4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' false));  		break;  	case PE.OpCode.Conv_ovf_i8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' false));  		break;  	case PE.OpCode.Conv_ovf_u8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' false));  		break;  	case PE.OpCode.Conv_ovf_i:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' false));  		break;  	case PE.OpCode.Conv_ovf_u:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' false));  		break;  	case PE.OpCode.Conv_ovf_i1_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' true));  		break;  	case PE.OpCode.Conv_ovf_u1_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' true));  		break;  	case PE.OpCode.Conv_ovf_i2_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' true));  		break;  	case PE.OpCode.Conv_ovf_u2_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' true));  		break;  	case PE.OpCode.Conv_ovf_i4_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' true));  		break;  	case PE.OpCode.Conv_ovf_u4_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' true));  		break;  	case PE.OpCode.Conv_ovf_i8_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' true));  		break;  	case PE.OpCode.Conv_ovf_u8_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' true));  		break;  	case PE.OpCode.Conv_ovf_i_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' true));  		break;  	case PE.OpCode.Conv_ovf_u_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' true));  		break;  	default:  		throw new InvalidOperationException ("invalid instruction");  	}  }  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: if (ehcs != null) {  	// A try instruction begins here with given handlers  	var offset = ctxt.Instructions [i].Offset;  	var tryCtxt = new TryTranslationContext (ctxt' i' ehcs);  	var tryBlock = InstructionsFromContext (tryCtxt);  	var handlers = new Seq<TryInstructionHandler> ();  	foreach (var ehc in ehcs) {  		var handlerCtxt = new HandlerTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.HandlerOffset]' ehc);  		var handlerBlock = InstructionsFromContext (handlerCtxt);  		switch (ehc.Flags) {  		case PE.CorILExceptionClause.Exception:  			handlers.Add (new CatchTryInstructionHandler ((TypeRef)ehc.Class' handlerBlock));  			break;  		case PE.CorILExceptionClause.Filter: {  			var filterCtxt = new FilterTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.FilterOffset]' ehc);  			var filterBlock = InstructionsFromContext (filterCtxt);  			handlers.Add (new FilterTryInstructionHandler (filterBlock' handlerBlock));  			break;  		}  		case PE.CorILExceptionClause.Finally:  			handlers.Add (new FinallyTryInstructionHandler (handlerBlock));  			break;  		case PE.CorILExceptionClause.Fault:  			handlers.Add (new FaultTryInstructionHandler (handlerBlock));  			break;  		default:  			throw new ArgumentOutOfRangeException ();  		}  	}  	instructions.Add (new TryInstruction (offset' tryBlock' handlers));  	// Jump over try block  	var nextOffset = ehcs [0].TryOffset + ehcs [0].TryLength;  	if (!ctxt.OffsetToIndex.TryGetValue (nextOffset' out i))  		i = ctxt.Instructions.Length;  }  else {  	var instruction = ctxt.Instructions [i++];  	var offset = instruction.Offset;  	while (instruction.OpCode == PE.OpCode.Unaligned || instruction.OpCode == PE.OpCode.Volatile || instruction.OpCode == PE.OpCode.Tailcall) {  		// Skip over any ignored prefixes' but remember instruction begins at original offset  		// NOTE: What ever happened to the "no." prefix mentioned in the spec?  		if (i >= ctxt.Instructions.Length)  			throw new InvalidOperationException ("invalid instructions");  		instruction = ctxt.Instructions [i++];  	}  	switch (instruction.OpCode) {  	case PE.OpCode.Cpblk:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Cpblk));  		break;  	case PE.OpCode.Initblk:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Initblk));  		break;  	case PE.OpCode.Arglist:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Arglist));  		break;  	case PE.OpCode.Localloc:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Localloc));  		break;  	case PE.OpCode.Jmp:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Jmp));  		break;  	case PE.OpCode.Calli:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Calli));  		break;  	case PE.OpCode.Sizeof:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Sizeof));  		break;  	case PE.OpCode.Mkrefany:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Mkrefany));  		break;  	case PE.OpCode.Refanytype:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanytype));  		break;  	case PE.OpCode.Refanyval:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanyval));  		break;  	case PE.OpCode.Nop:  		instructions.Add (new MiscInstruction (offset' MiscOp.Nop));  		break;  	case PE.OpCode.Break:  		instructions.Add (new MiscInstruction (offset' MiscOp.Break));  		break;  	case PE.OpCode.Dup:  		instructions.Add (new MiscInstruction (offset' MiscOp.Dup));  		break;  	case PE.OpCode.Pop:  		instructions.Add (new MiscInstruction (offset' MiscOp.Pop));  		break;  	case PE.OpCode.Ldnull:  		instructions.Add (new MiscInstruction (offset' MiscOp.Ldnull));  		break;  	case PE.OpCode.Ckfinite:  		instructions.Add (new MiscInstruction (offset' MiscOp.Ckfinite));  		break;  	case PE.OpCode.Throw:  		instructions.Add (new MiscInstruction (offset' MiscOp.Throw));  		break;  	case PE.OpCode.Rethrow:  		instructions.Add (new MiscInstruction (offset' MiscOp.Rethrow));  		break;  	case PE.OpCode.Ldind_ref:  		instructions.Add (new MiscInstruction (offset' MiscOp.LdindRef));  		break;  	case PE.OpCode.Stind_ref:  		instructions.Add (new MiscInstruction (offset' MiscOp.StindRef));  		break;  	case PE.OpCode.Ldelem_ref:  		instructions.Add (new MiscInstruction (offset' MiscOp.LdelemRef));  		break;  	case PE.OpCode.Stelem_ref:  		instructions.Add (new MiscInstruction (offset' MiscOp.StelemRef));  		break;  	case PE.OpCode.Ldlen:  		instructions.Add (new MiscInstruction (offset' MiscOp.Ldlen));  		break;  	case PE.OpCode.Ret:  		if (ctxt.ResultType == null)  			instructions.Add (new MiscInstruction (offset' MiscOp.Ret));  		else  			instructions.Add (new MiscInstruction (offset' MiscOp.RetVal));  		break;  	case PE.OpCode.Endfilter:  		instructions.Add (new MiscInstruction (offset' MiscOp.Endfilter));  		break;  	case PE.OpCode.Endfinally:  		// aka EndFault  		instructions.Add (new MiscInstruction (offset' MiscOp.Endfinally));  		break;  	case PE.OpCode.Br_s:  	case PE.OpCode.Br:  		instructions.Add (new BranchInstruction (offset' BranchOp.Br' false' (int)instruction.Value));  		break;  	case PE.OpCode.Brtrue_s:  	// aka brinst.s  	case PE.OpCode.Brtrue:  		// aka brinst  		instructions.Add (new BranchInstruction (offset' BranchOp.Brtrue' false' (int)instruction.Value));  		break;  	case PE.OpCode.Brfalse_s:  	// aka brzero.s' brnull.s  	case PE.OpCode.Brfalse:  		// aka brzero' brnull  		instructions.Add (new BranchInstruction (offset' BranchOp.Brfalse' false' (int)instruction.Value));  		break;  	case PE.OpCode.Beq:  	case PE.OpCode.Beq_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.Breq' false' (int)instruction.Value));  		break;  	case PE.OpCode.Bne_un:  	case PE.OpCode.Bne_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.Brne' false' (int)instruction.Value));  		break;  	case PE.OpCode.Leave:  	case PE.OpCode.Leave_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.Leave' false' (int)instruction.Value));  		break;  	case PE.OpCode.Blt:  	case PE.OpCode.Blt_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' false' (int)instruction.Value));  		break;  	case PE.OpCode.Blt_un:  	case PE.OpCode.Blt_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' true' (int)instruction.Value));  		break;  	case PE.OpCode.Ble:  	case PE.OpCode.Ble_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' false' (int)instruction.Value));  		break;  	case PE.OpCode.Ble_un:  	case PE.OpCode.Ble_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' true' (int)instruction.Value));  		break;  	case PE.OpCode.Bgt:  	case PE.OpCode.Bgt_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' false' (int)instruction.Value));  		break;  	case PE.OpCode.Bgt_un:  	case PE.OpCode.Bgt_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' true' (int)instruction.Value));  		break;  	case PE.OpCode.Bge:  	case PE.OpCode.Bge_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' false' (int)instruction.Value));  		break;  	case PE.OpCode.Bge_un:  	case PE.OpCode.Bge_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' true' (int)instruction.Value));  		break;  	case PE.OpCode.Switch:  		instructions.Add (new SwitchInstruction (offset' (Seq<int>)instruction.Value));  		break;  	case PE.OpCode.Ceq:  		instructions.Add (new CompareInstruction (offset' CompareOp.Ceq' false));  		break;  	case PE.OpCode.Clt:  		instructions.Add (new CompareInstruction (offset' CompareOp.Clt' false));  		break;  	case PE.OpCode.Clt_un:  		instructions.Add (new CompareInstruction (offset' CompareOp.Clt' true));  		break;  	case PE.OpCode.Cgt:  		instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' false));  		break;  	case PE.OpCode.Cgt_un:  		instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' true));  		break;  	case PE.OpCode.Ldarg_0:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));  		break;  	case PE.OpCode.Ldarg_1:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));  		break;  	case PE.OpCode.Ldarg_2:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));  		break;  	case PE.OpCode.Ldarg_3:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));  		break;  	case PE.OpCode.Ldarg:  	case PE.OpCode.Ldarg_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));  		break;  	case PE.OpCode.Ldarga:  	case PE.OpCode.Ldarga_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));  		break;  	case PE.OpCode.Starg:  	case PE.OpCode.Starg_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));  		break;  	case PE.OpCode.Ldloc_0:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 0));  		break;  	case PE.OpCode.Ldloc_1:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 1));  		break;  	case PE.OpCode.Ldloc_2:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 2));  		break;  	case PE.OpCode.Ldloc_3:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 3));  		break;  	case PE.OpCode.Ldloc:  	case PE.OpCode.Ldloc_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));  		break;  	case PE.OpCode.Ldloca:  	case PE.OpCode.Ldloca_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));  		break;  	case PE.OpCode.Stloc_0:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 0));  		break;  	case PE.OpCode.Stloc_1:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 1));  		break;  	case PE.OpCode.Stloc_2:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 2));  		break;  	case PE.OpCode.Stloc_3:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 3));  		break;  	case PE.OpCode.Stloc:  	case PE.OpCode.Stloc_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));  		break;  	case PE.OpCode.Ldfld:  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));  		break;  	case PE.OpCode.Ldsfld:  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));  		break;  	case PE.OpCode.Ldflda:  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));  		break;  	case PE.OpCode.Ldsflda:  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));  		break;  	case PE.OpCode.Stfld:  		instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));  		break;  	case PE.OpCode.Stsfld:  		instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));  		break;  	case PE.OpCode.Ldtoken: {  		if (instruction.Value is FieldRef)  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));  		else if (instruction.Value is MethodRef)  			instructions.Add (new MethodInstruction (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));  		else if (instruction.Value is TypeRef)  			// NOTE: May be a higher-kinded type  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));  		else  			throw new InvalidOperationException ("unexpected ldtoken instruction value");  		break;  	}  	case PE.OpCode.Constrained: {  		var constrained = (TypeRef)instruction.Value;  		if (i >= ctxt.Instructions.Length)  			throw new InvalidOperationException ("invalid instructions");  		instruction = ctxt.Instructions [i++];  		if (instruction.OpCode != PE.OpCode.Callvirt)  			throw new InvalidOperationException ("invalid instruction");  		instructions.Add (new MethodInstruction (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));  		break;  	}  	case PE.OpCode.Call:  		instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Callvirt:  		instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Ldftn:  		instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Ldvirtftn:  		instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Newobj:  		instructions.Add (new MethodInstruction (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Ldind_i1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int8Ref));  		break;  	case PE.OpCode.Ldind_u1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt8Ref));  		break;  	case PE.OpCode.Ldind_i2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int16Ref));  		break;  	case PE.OpCode.Ldind_u2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt16Ref));  		break;  	case PE.OpCode.Ldind_i4:  	case PE.OpCode.Ldind_u4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int32Ref));  		break;  	case PE.OpCode.Ldind_i8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int64Ref));  		break;  	case PE.OpCode.Ldind_i:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.IntNativeRef));  		break;  	case PE.OpCode.Ldind_r4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.SingleRef));  		break;  	case PE.OpCode.Ldind_r8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.DoubleRef));  		break;  	case PE.OpCode.Ldobj:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Stind_i1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int8Ref));  		break;  	case PE.OpCode.Stind_i2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int16Ref));  		break;  	case PE.OpCode.Stind_i4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int32Ref));  		break;  	case PE.OpCode.Stind_i8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int64Ref));  		break;  	case PE.OpCode.Stind_i:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.IntNativeRef));  		break;  	case PE.OpCode.Stind_r4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.SingleRef));  		break;  	case PE.OpCode.Stind_r8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.DoubleRef));  		break;  	case PE.OpCode.Stobj:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Cpobj:  		instructions.Add (new TypeInstruction (offset' TypeOp.Cpobj' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Newarr:  		instructions.Add (new TypeInstruction (offset' TypeOp.Newarr' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Initobj:  		instructions.Add (new TypeInstruction (offset' TypeOp.Initobj' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Castclass:  		instructions.Add (new TypeInstruction (offset' TypeOp.Castclass' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Isinst:  		instructions.Add (new TypeInstruction (offset' TypeOp.Isinst' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Box:  		instructions.Add (new TypeInstruction (offset' TypeOp.Box' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Unbox:  		instructions.Add (new TypeInstruction (offset' TypeOp.Unbox' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Unbox_any:  		instructions.Add (new TypeInstruction (offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Ldelem_i1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int8Ref));  		break;  	case PE.OpCode.Ldelem_u1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt8Ref));  		break;  	case PE.OpCode.Ldelem_i2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int16Ref));  		break;  	case PE.OpCode.Ldelem_u2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt16Ref));  		break;  	case PE.OpCode.Ldelem_i4:  	case PE.OpCode.Ldelem_u4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int32Ref));  		break;  	case PE.OpCode.Ldelem_i:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.IntNativeRef));  		break;  	case PE.OpCode.Ldelem_i8:  		// aka ldelem.u8  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int64Ref));  		break;  	case PE.OpCode.Ldelem_r4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.SingleRef));  		break;  	case PE.OpCode.Ldelem_r8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.DoubleRef));  		break;  	case PE.OpCode.Ldelem:  		// aka ldelem.any  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Stelem_i1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int8Ref));  		break;  	case PE.OpCode.Stelem_i2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int16Ref));  		break;  	case PE.OpCode.Stelem_i4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int32Ref));  		break;  	case PE.OpCode.Stelem_i8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int64Ref));  		break;  	case PE.OpCode.Stelem_i:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.IntNativeRef));  		break;  	case PE.OpCode.Stelem_r4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.SingleRef));  		break;  	case PE.OpCode.Stelem_r8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.DoubleRef));  		break;  	case PE.OpCode.Stelem:  		// aka stelem.any  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Readonly:  		if (i >= ctxt.Instructions.Length)  			throw new InvalidOperationException ("invalid instruction");  		instruction = ctxt.Instructions [i++];  		if (instruction.OpCode != PE.OpCode.Ldelema)  			throw new InvalidOperationException ("invalid instruction");  		instructions.Add (new LdElemAddrInstruction (offset' true' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Ldelema:  		instructions.Add (new LdElemAddrInstruction (offset' false' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Ldc_i4_0:  		instructions.Add (new LdInt32Instruction (offset' 0));  		break;  	case PE.OpCode.Ldc_i4_1:  		instructions.Add (new LdInt32Instruction (offset' 1));  		break;  	case PE.OpCode.Ldc_i4_2:  		instructions.Add (new LdInt32Instruction (offset' 2));  		break;  	case PE.OpCode.Ldc_i4_3:  		instructions.Add (new LdInt32Instruction (offset' 3));  		break;  	case PE.OpCode.Ldc_i4_4:  		instructions.Add (new LdInt32Instruction (offset' 4));  		break;  	case PE.OpCode.Ldc_i4_5:  		instructions.Add (new LdInt32Instruction (offset' 5));  		break;  	case PE.OpCode.Ldc_i4_6:  		instructions.Add (new LdInt32Instruction (offset' 6));  		break;  	case PE.OpCode.Ldc_i4_7:  		instructions.Add (new LdInt32Instruction (offset' 7));  		break;  	case PE.OpCode.Ldc_i4_8:  		instructions.Add (new LdInt32Instruction (offset' 8));  		break;  	case PE.OpCode.Ldc_i4_m1:  		instructions.Add (new LdInt32Instruction (offset' -1));  		break;  	case PE.OpCode.Ldc_i4:  	case PE.OpCode.Ldc_i4_s:  		instructions.Add (new LdInt32Instruction (offset' (int)instruction.Value));  		break;  	case PE.OpCode.Ldc_i8:  		instructions.Add (new LdInt64Instruction (offset' (long)instruction.Value));  		break;  	case PE.OpCode.Ldc_r4:  		instructions.Add (new LdSingleInstruction (offset' (float)instruction.Value));  		break;  	case PE.OpCode.Ldc_r8:  		instructions.Add (new LdDoubleInstruction (offset' (double)instruction.Value));  		break;  	case PE.OpCode.Ldstr:  		instructions.Add (new LdStringInstruction (offset' (string)instruction.Value));  		break;  	case PE.OpCode.Add:  		instructions.Add (new ArithInstruction (offset' ArithOp.Add' false' false));  		break;  	case PE.OpCode.Add_ovf:  		instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' false));  		break;  	case PE.OpCode.Add_ovf_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' true));  		break;  	case PE.OpCode.Sub:  		instructions.Add (new ArithInstruction (offset' ArithOp.Sub' false' false));  		break;  	case PE.OpCode.Sub_ovf:  		instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' false));  		break;  	case PE.OpCode.Sub_ovf_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' true));  		break;  	case PE.OpCode.Mul:  		instructions.Add (new ArithInstruction (offset' ArithOp.Mul' false' false));  		break;  	case PE.OpCode.Mul_ovf:  		instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' false));  		break;  	case PE.OpCode.Mul_ovf_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' true));  		break;  	case PE.OpCode.Div:  		instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' false));  		break;  	case PE.OpCode.Div_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' true));  		break;  	case PE.OpCode.Rem:  		instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' false));  		break;  	case PE.OpCode.Rem_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' true));  		break;  	case PE.OpCode.Neg:  		instructions.Add (new ArithInstruction (offset' ArithOp.Neg' false' false));  		break;  	case PE.OpCode.And:  		instructions.Add (new ArithInstruction (offset' ArithOp.BitAnd' false' false));  		break;  	case PE.OpCode.Or:  		instructions.Add (new ArithInstruction (offset' ArithOp.BitOr' false' false));  		break;  	case PE.OpCode.Xor:  		instructions.Add (new ArithInstruction (offset' ArithOp.BitXor' false' false));  		break;  	case PE.OpCode.Not:  		instructions.Add (new ArithInstruction (offset' ArithOp.BitNot' false' false));  		break;  	case PE.OpCode.Shl:  		instructions.Add (new ArithInstruction (offset' ArithOp.Shl' false' false));  		break;  	case PE.OpCode.Shr:  		instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' false));  		break;  	case PE.OpCode.Shr_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' true));  		break;  	case PE.OpCode.Conv_i1:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' false' false));  		break;  	case PE.OpCode.Conv_u1:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' false' false));  		break;  	case PE.OpCode.Conv_i2:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' false' false));  		break;  	case PE.OpCode.Conv_u2:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' false' false));  		break;  	case PE.OpCode.Conv_i4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' false' false));  		break;  	case PE.OpCode.Conv_u4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' false' false));  		break;  	case PE.OpCode.Conv_i8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' false' false));  		break;  	case PE.OpCode.Conv_u8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' false' false));  		break;  	case PE.OpCode.Conv_i:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' false' false));  		break;  	case PE.OpCode.Conv_u:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' false' false));  		break;  	case PE.OpCode.Conv_r4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Single' false' false));  		break;  	case PE.OpCode.Conv_r8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' false));  		break;  	case PE.OpCode.Conv_r_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' true));  		break;  	case PE.OpCode.Conv_ovf_i1:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' false));  		break;  	case PE.OpCode.Conv_ovf_u1:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' false));  		break;  	case PE.OpCode.Conv_ovf_i2:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' false));  		break;  	case PE.OpCode.Conv_ovf_u2:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' false));  		break;  	case PE.OpCode.Conv_ovf_i4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' false));  		break;  	case PE.OpCode.Conv_ovf_u4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' false));  		break;  	case PE.OpCode.Conv_ovf_i8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' false));  		break;  	case PE.OpCode.Conv_ovf_u8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' false));  		break;  	case PE.OpCode.Conv_ovf_i:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' false));  		break;  	case PE.OpCode.Conv_ovf_u:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' false));  		break;  	case PE.OpCode.Conv_ovf_i1_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' true));  		break;  	case PE.OpCode.Conv_ovf_u1_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' true));  		break;  	case PE.OpCode.Conv_ovf_i2_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' true));  		break;  	case PE.OpCode.Conv_ovf_u2_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' true));  		break;  	case PE.OpCode.Conv_ovf_i4_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' true));  		break;  	case PE.OpCode.Conv_ovf_u4_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' true));  		break;  	case PE.OpCode.Conv_ovf_i8_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' true));  		break;  	case PE.OpCode.Conv_ovf_u8_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' true));  		break;  	case PE.OpCode.Conv_ovf_i_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' true));  		break;  	case PE.OpCode.Conv_ovf_u_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' true));  		break;  	default:  		throw new InvalidOperationException ("invalid instruction");  	}  }  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: if (ehcs != null) {  	// A try instruction begins here with given handlers  	var offset = ctxt.Instructions [i].Offset;  	var tryCtxt = new TryTranslationContext (ctxt' i' ehcs);  	var tryBlock = InstructionsFromContext (tryCtxt);  	var handlers = new Seq<TryInstructionHandler> ();  	foreach (var ehc in ehcs) {  		var handlerCtxt = new HandlerTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.HandlerOffset]' ehc);  		var handlerBlock = InstructionsFromContext (handlerCtxt);  		switch (ehc.Flags) {  		case PE.CorILExceptionClause.Exception:  			handlers.Add (new CatchTryInstructionHandler ((TypeRef)ehc.Class' handlerBlock));  			break;  		case PE.CorILExceptionClause.Filter: {  			var filterCtxt = new FilterTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.FilterOffset]' ehc);  			var filterBlock = InstructionsFromContext (filterCtxt);  			handlers.Add (new FilterTryInstructionHandler (filterBlock' handlerBlock));  			break;  		}  		case PE.CorILExceptionClause.Finally:  			handlers.Add (new FinallyTryInstructionHandler (handlerBlock));  			break;  		case PE.CorILExceptionClause.Fault:  			handlers.Add (new FaultTryInstructionHandler (handlerBlock));  			break;  		default:  			throw new ArgumentOutOfRangeException ();  		}  	}  	instructions.Add (new TryInstruction (offset' tryBlock' handlers));  	// Jump over try block  	var nextOffset = ehcs [0].TryOffset + ehcs [0].TryLength;  	if (!ctxt.OffsetToIndex.TryGetValue (nextOffset' out i))  		i = ctxt.Instructions.Length;  }  else {  	var instruction = ctxt.Instructions [i++];  	var offset = instruction.Offset;  	while (instruction.OpCode == PE.OpCode.Unaligned || instruction.OpCode == PE.OpCode.Volatile || instruction.OpCode == PE.OpCode.Tailcall) {  		// Skip over any ignored prefixes' but remember instruction begins at original offset  		// NOTE: What ever happened to the "no." prefix mentioned in the spec?  		if (i >= ctxt.Instructions.Length)  			throw new InvalidOperationException ("invalid instructions");  		instruction = ctxt.Instructions [i++];  	}  	switch (instruction.OpCode) {  	case PE.OpCode.Cpblk:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Cpblk));  		break;  	case PE.OpCode.Initblk:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Initblk));  		break;  	case PE.OpCode.Arglist:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Arglist));  		break;  	case PE.OpCode.Localloc:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Localloc));  		break;  	case PE.OpCode.Jmp:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Jmp));  		break;  	case PE.OpCode.Calli:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Calli));  		break;  	case PE.OpCode.Sizeof:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Sizeof));  		break;  	case PE.OpCode.Mkrefany:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Mkrefany));  		break;  	case PE.OpCode.Refanytype:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanytype));  		break;  	case PE.OpCode.Refanyval:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanyval));  		break;  	case PE.OpCode.Nop:  		instructions.Add (new MiscInstruction (offset' MiscOp.Nop));  		break;  	case PE.OpCode.Break:  		instructions.Add (new MiscInstruction (offset' MiscOp.Break));  		break;  	case PE.OpCode.Dup:  		instructions.Add (new MiscInstruction (offset' MiscOp.Dup));  		break;  	case PE.OpCode.Pop:  		instructions.Add (new MiscInstruction (offset' MiscOp.Pop));  		break;  	case PE.OpCode.Ldnull:  		instructions.Add (new MiscInstruction (offset' MiscOp.Ldnull));  		break;  	case PE.OpCode.Ckfinite:  		instructions.Add (new MiscInstruction (offset' MiscOp.Ckfinite));  		break;  	case PE.OpCode.Throw:  		instructions.Add (new MiscInstruction (offset' MiscOp.Throw));  		break;  	case PE.OpCode.Rethrow:  		instructions.Add (new MiscInstruction (offset' MiscOp.Rethrow));  		break;  	case PE.OpCode.Ldind_ref:  		instructions.Add (new MiscInstruction (offset' MiscOp.LdindRef));  		break;  	case PE.OpCode.Stind_ref:  		instructions.Add (new MiscInstruction (offset' MiscOp.StindRef));  		break;  	case PE.OpCode.Ldelem_ref:  		instructions.Add (new MiscInstruction (offset' MiscOp.LdelemRef));  		break;  	case PE.OpCode.Stelem_ref:  		instructions.Add (new MiscInstruction (offset' MiscOp.StelemRef));  		break;  	case PE.OpCode.Ldlen:  		instructions.Add (new MiscInstruction (offset' MiscOp.Ldlen));  		break;  	case PE.OpCode.Ret:  		if (ctxt.ResultType == null)  			instructions.Add (new MiscInstruction (offset' MiscOp.Ret));  		else  			instructions.Add (new MiscInstruction (offset' MiscOp.RetVal));  		break;  	case PE.OpCode.Endfilter:  		instructions.Add (new MiscInstruction (offset' MiscOp.Endfilter));  		break;  	case PE.OpCode.Endfinally:  		// aka EndFault  		instructions.Add (new MiscInstruction (offset' MiscOp.Endfinally));  		break;  	case PE.OpCode.Br_s:  	case PE.OpCode.Br:  		instructions.Add (new BranchInstruction (offset' BranchOp.Br' false' (int)instruction.Value));  		break;  	case PE.OpCode.Brtrue_s:  	// aka brinst.s  	case PE.OpCode.Brtrue:  		// aka brinst  		instructions.Add (new BranchInstruction (offset' BranchOp.Brtrue' false' (int)instruction.Value));  		break;  	case PE.OpCode.Brfalse_s:  	// aka brzero.s' brnull.s  	case PE.OpCode.Brfalse:  		// aka brzero' brnull  		instructions.Add (new BranchInstruction (offset' BranchOp.Brfalse' false' (int)instruction.Value));  		break;  	case PE.OpCode.Beq:  	case PE.OpCode.Beq_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.Breq' false' (int)instruction.Value));  		break;  	case PE.OpCode.Bne_un:  	case PE.OpCode.Bne_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.Brne' false' (int)instruction.Value));  		break;  	case PE.OpCode.Leave:  	case PE.OpCode.Leave_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.Leave' false' (int)instruction.Value));  		break;  	case PE.OpCode.Blt:  	case PE.OpCode.Blt_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' false' (int)instruction.Value));  		break;  	case PE.OpCode.Blt_un:  	case PE.OpCode.Blt_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' true' (int)instruction.Value));  		break;  	case PE.OpCode.Ble:  	case PE.OpCode.Ble_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' false' (int)instruction.Value));  		break;  	case PE.OpCode.Ble_un:  	case PE.OpCode.Ble_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' true' (int)instruction.Value));  		break;  	case PE.OpCode.Bgt:  	case PE.OpCode.Bgt_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' false' (int)instruction.Value));  		break;  	case PE.OpCode.Bgt_un:  	case PE.OpCode.Bgt_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' true' (int)instruction.Value));  		break;  	case PE.OpCode.Bge:  	case PE.OpCode.Bge_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' false' (int)instruction.Value));  		break;  	case PE.OpCode.Bge_un:  	case PE.OpCode.Bge_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' true' (int)instruction.Value));  		break;  	case PE.OpCode.Switch:  		instructions.Add (new SwitchInstruction (offset' (Seq<int>)instruction.Value));  		break;  	case PE.OpCode.Ceq:  		instructions.Add (new CompareInstruction (offset' CompareOp.Ceq' false));  		break;  	case PE.OpCode.Clt:  		instructions.Add (new CompareInstruction (offset' CompareOp.Clt' false));  		break;  	case PE.OpCode.Clt_un:  		instructions.Add (new CompareInstruction (offset' CompareOp.Clt' true));  		break;  	case PE.OpCode.Cgt:  		instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' false));  		break;  	case PE.OpCode.Cgt_un:  		instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' true));  		break;  	case PE.OpCode.Ldarg_0:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));  		break;  	case PE.OpCode.Ldarg_1:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));  		break;  	case PE.OpCode.Ldarg_2:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));  		break;  	case PE.OpCode.Ldarg_3:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));  		break;  	case PE.OpCode.Ldarg:  	case PE.OpCode.Ldarg_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));  		break;  	case PE.OpCode.Ldarga:  	case PE.OpCode.Ldarga_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));  		break;  	case PE.OpCode.Starg:  	case PE.OpCode.Starg_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));  		break;  	case PE.OpCode.Ldloc_0:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 0));  		break;  	case PE.OpCode.Ldloc_1:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 1));  		break;  	case PE.OpCode.Ldloc_2:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 2));  		break;  	case PE.OpCode.Ldloc_3:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 3));  		break;  	case PE.OpCode.Ldloc:  	case PE.OpCode.Ldloc_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));  		break;  	case PE.OpCode.Ldloca:  	case PE.OpCode.Ldloca_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));  		break;  	case PE.OpCode.Stloc_0:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 0));  		break;  	case PE.OpCode.Stloc_1:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 1));  		break;  	case PE.OpCode.Stloc_2:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 2));  		break;  	case PE.OpCode.Stloc_3:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 3));  		break;  	case PE.OpCode.Stloc:  	case PE.OpCode.Stloc_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));  		break;  	case PE.OpCode.Ldfld:  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));  		break;  	case PE.OpCode.Ldsfld:  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));  		break;  	case PE.OpCode.Ldflda:  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));  		break;  	case PE.OpCode.Ldsflda:  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));  		break;  	case PE.OpCode.Stfld:  		instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));  		break;  	case PE.OpCode.Stsfld:  		instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));  		break;  	case PE.OpCode.Ldtoken: {  		if (instruction.Value is FieldRef)  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));  		else if (instruction.Value is MethodRef)  			instructions.Add (new MethodInstruction (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));  		else if (instruction.Value is TypeRef)  			// NOTE: May be a higher-kinded type  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));  		else  			throw new InvalidOperationException ("unexpected ldtoken instruction value");  		break;  	}  	case PE.OpCode.Constrained: {  		var constrained = (TypeRef)instruction.Value;  		if (i >= ctxt.Instructions.Length)  			throw new InvalidOperationException ("invalid instructions");  		instruction = ctxt.Instructions [i++];  		if (instruction.OpCode != PE.OpCode.Callvirt)  			throw new InvalidOperationException ("invalid instruction");  		instructions.Add (new MethodInstruction (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));  		break;  	}  	case PE.OpCode.Call:  		instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Callvirt:  		instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Ldftn:  		instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Ldvirtftn:  		instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Newobj:  		instructions.Add (new MethodInstruction (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Ldind_i1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int8Ref));  		break;  	case PE.OpCode.Ldind_u1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt8Ref));  		break;  	case PE.OpCode.Ldind_i2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int16Ref));  		break;  	case PE.OpCode.Ldind_u2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt16Ref));  		break;  	case PE.OpCode.Ldind_i4:  	case PE.OpCode.Ldind_u4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int32Ref));  		break;  	case PE.OpCode.Ldind_i8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int64Ref));  		break;  	case PE.OpCode.Ldind_i:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.IntNativeRef));  		break;  	case PE.OpCode.Ldind_r4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.SingleRef));  		break;  	case PE.OpCode.Ldind_r8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.DoubleRef));  		break;  	case PE.OpCode.Ldobj:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Stind_i1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int8Ref));  		break;  	case PE.OpCode.Stind_i2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int16Ref));  		break;  	case PE.OpCode.Stind_i4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int32Ref));  		break;  	case PE.OpCode.Stind_i8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int64Ref));  		break;  	case PE.OpCode.Stind_i:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.IntNativeRef));  		break;  	case PE.OpCode.Stind_r4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.SingleRef));  		break;  	case PE.OpCode.Stind_r8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.DoubleRef));  		break;  	case PE.OpCode.Stobj:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Cpobj:  		instructions.Add (new TypeInstruction (offset' TypeOp.Cpobj' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Newarr:  		instructions.Add (new TypeInstruction (offset' TypeOp.Newarr' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Initobj:  		instructions.Add (new TypeInstruction (offset' TypeOp.Initobj' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Castclass:  		instructions.Add (new TypeInstruction (offset' TypeOp.Castclass' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Isinst:  		instructions.Add (new TypeInstruction (offset' TypeOp.Isinst' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Box:  		instructions.Add (new TypeInstruction (offset' TypeOp.Box' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Unbox:  		instructions.Add (new TypeInstruction (offset' TypeOp.Unbox' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Unbox_any:  		instructions.Add (new TypeInstruction (offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Ldelem_i1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int8Ref));  		break;  	case PE.OpCode.Ldelem_u1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt8Ref));  		break;  	case PE.OpCode.Ldelem_i2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int16Ref));  		break;  	case PE.OpCode.Ldelem_u2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt16Ref));  		break;  	case PE.OpCode.Ldelem_i4:  	case PE.OpCode.Ldelem_u4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int32Ref));  		break;  	case PE.OpCode.Ldelem_i:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.IntNativeRef));  		break;  	case PE.OpCode.Ldelem_i8:  		// aka ldelem.u8  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int64Ref));  		break;  	case PE.OpCode.Ldelem_r4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.SingleRef));  		break;  	case PE.OpCode.Ldelem_r8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.DoubleRef));  		break;  	case PE.OpCode.Ldelem:  		// aka ldelem.any  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Stelem_i1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int8Ref));  		break;  	case PE.OpCode.Stelem_i2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int16Ref));  		break;  	case PE.OpCode.Stelem_i4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int32Ref));  		break;  	case PE.OpCode.Stelem_i8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int64Ref));  		break;  	case PE.OpCode.Stelem_i:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.IntNativeRef));  		break;  	case PE.OpCode.Stelem_r4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.SingleRef));  		break;  	case PE.OpCode.Stelem_r8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.DoubleRef));  		break;  	case PE.OpCode.Stelem:  		// aka stelem.any  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Readonly:  		if (i >= ctxt.Instructions.Length)  			throw new InvalidOperationException ("invalid instruction");  		instruction = ctxt.Instructions [i++];  		if (instruction.OpCode != PE.OpCode.Ldelema)  			throw new InvalidOperationException ("invalid instruction");  		instructions.Add (new LdElemAddrInstruction (offset' true' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Ldelema:  		instructions.Add (new LdElemAddrInstruction (offset' false' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Ldc_i4_0:  		instructions.Add (new LdInt32Instruction (offset' 0));  		break;  	case PE.OpCode.Ldc_i4_1:  		instructions.Add (new LdInt32Instruction (offset' 1));  		break;  	case PE.OpCode.Ldc_i4_2:  		instructions.Add (new LdInt32Instruction (offset' 2));  		break;  	case PE.OpCode.Ldc_i4_3:  		instructions.Add (new LdInt32Instruction (offset' 3));  		break;  	case PE.OpCode.Ldc_i4_4:  		instructions.Add (new LdInt32Instruction (offset' 4));  		break;  	case PE.OpCode.Ldc_i4_5:  		instructions.Add (new LdInt32Instruction (offset' 5));  		break;  	case PE.OpCode.Ldc_i4_6:  		instructions.Add (new LdInt32Instruction (offset' 6));  		break;  	case PE.OpCode.Ldc_i4_7:  		instructions.Add (new LdInt32Instruction (offset' 7));  		break;  	case PE.OpCode.Ldc_i4_8:  		instructions.Add (new LdInt32Instruction (offset' 8));  		break;  	case PE.OpCode.Ldc_i4_m1:  		instructions.Add (new LdInt32Instruction (offset' -1));  		break;  	case PE.OpCode.Ldc_i4:  	case PE.OpCode.Ldc_i4_s:  		instructions.Add (new LdInt32Instruction (offset' (int)instruction.Value));  		break;  	case PE.OpCode.Ldc_i8:  		instructions.Add (new LdInt64Instruction (offset' (long)instruction.Value));  		break;  	case PE.OpCode.Ldc_r4:  		instructions.Add (new LdSingleInstruction (offset' (float)instruction.Value));  		break;  	case PE.OpCode.Ldc_r8:  		instructions.Add (new LdDoubleInstruction (offset' (double)instruction.Value));  		break;  	case PE.OpCode.Ldstr:  		instructions.Add (new LdStringInstruction (offset' (string)instruction.Value));  		break;  	case PE.OpCode.Add:  		instructions.Add (new ArithInstruction (offset' ArithOp.Add' false' false));  		break;  	case PE.OpCode.Add_ovf:  		instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' false));  		break;  	case PE.OpCode.Add_ovf_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' true));  		break;  	case PE.OpCode.Sub:  		instructions.Add (new ArithInstruction (offset' ArithOp.Sub' false' false));  		break;  	case PE.OpCode.Sub_ovf:  		instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' false));  		break;  	case PE.OpCode.Sub_ovf_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' true));  		break;  	case PE.OpCode.Mul:  		instructions.Add (new ArithInstruction (offset' ArithOp.Mul' false' false));  		break;  	case PE.OpCode.Mul_ovf:  		instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' false));  		break;  	case PE.OpCode.Mul_ovf_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' true));  		break;  	case PE.OpCode.Div:  		instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' false));  		break;  	case PE.OpCode.Div_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' true));  		break;  	case PE.OpCode.Rem:  		instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' false));  		break;  	case PE.OpCode.Rem_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' true));  		break;  	case PE.OpCode.Neg:  		instructions.Add (new ArithInstruction (offset' ArithOp.Neg' false' false));  		break;  	case PE.OpCode.And:  		instructions.Add (new ArithInstruction (offset' ArithOp.BitAnd' false' false));  		break;  	case PE.OpCode.Or:  		instructions.Add (new ArithInstruction (offset' ArithOp.BitOr' false' false));  		break;  	case PE.OpCode.Xor:  		instructions.Add (new ArithInstruction (offset' ArithOp.BitXor' false' false));  		break;  	case PE.OpCode.Not:  		instructions.Add (new ArithInstruction (offset' ArithOp.BitNot' false' false));  		break;  	case PE.OpCode.Shl:  		instructions.Add (new ArithInstruction (offset' ArithOp.Shl' false' false));  		break;  	case PE.OpCode.Shr:  		instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' false));  		break;  	case PE.OpCode.Shr_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' true));  		break;  	case PE.OpCode.Conv_i1:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' false' false));  		break;  	case PE.OpCode.Conv_u1:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' false' false));  		break;  	case PE.OpCode.Conv_i2:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' false' false));  		break;  	case PE.OpCode.Conv_u2:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' false' false));  		break;  	case PE.OpCode.Conv_i4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' false' false));  		break;  	case PE.OpCode.Conv_u4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' false' false));  		break;  	case PE.OpCode.Conv_i8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' false' false));  		break;  	case PE.OpCode.Conv_u8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' false' false));  		break;  	case PE.OpCode.Conv_i:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' false' false));  		break;  	case PE.OpCode.Conv_u:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' false' false));  		break;  	case PE.OpCode.Conv_r4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Single' false' false));  		break;  	case PE.OpCode.Conv_r8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' false));  		break;  	case PE.OpCode.Conv_r_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' true));  		break;  	case PE.OpCode.Conv_ovf_i1:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' false));  		break;  	case PE.OpCode.Conv_ovf_u1:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' false));  		break;  	case PE.OpCode.Conv_ovf_i2:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' false));  		break;  	case PE.OpCode.Conv_ovf_u2:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' false));  		break;  	case PE.OpCode.Conv_ovf_i4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' false));  		break;  	case PE.OpCode.Conv_ovf_u4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' false));  		break;  	case PE.OpCode.Conv_ovf_i8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' false));  		break;  	case PE.OpCode.Conv_ovf_u8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' false));  		break;  	case PE.OpCode.Conv_ovf_i:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' false));  		break;  	case PE.OpCode.Conv_ovf_u:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' false));  		break;  	case PE.OpCode.Conv_ovf_i1_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' true));  		break;  	case PE.OpCode.Conv_ovf_u1_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' true));  		break;  	case PE.OpCode.Conv_ovf_i2_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' true));  		break;  	case PE.OpCode.Conv_ovf_u2_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' true));  		break;  	case PE.OpCode.Conv_ovf_i4_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' true));  		break;  	case PE.OpCode.Conv_ovf_u4_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' true));  		break;  	case PE.OpCode.Conv_ovf_i8_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' true));  		break;  	case PE.OpCode.Conv_ovf_u8_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' true));  		break;  	case PE.OpCode.Conv_ovf_i_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' true));  		break;  	case PE.OpCode.Conv_ovf_u_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' true));  		break;  	default:  		throw new InvalidOperationException ("invalid instruction");  	}  }  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: if (ehcs != null) {  	// A try instruction begins here with given handlers  	var offset = ctxt.Instructions [i].Offset;  	var tryCtxt = new TryTranslationContext (ctxt' i' ehcs);  	var tryBlock = InstructionsFromContext (tryCtxt);  	var handlers = new Seq<TryInstructionHandler> ();  	foreach (var ehc in ehcs) {  		var handlerCtxt = new HandlerTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.HandlerOffset]' ehc);  		var handlerBlock = InstructionsFromContext (handlerCtxt);  		switch (ehc.Flags) {  		case PE.CorILExceptionClause.Exception:  			handlers.Add (new CatchTryInstructionHandler ((TypeRef)ehc.Class' handlerBlock));  			break;  		case PE.CorILExceptionClause.Filter: {  			var filterCtxt = new FilterTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.FilterOffset]' ehc);  			var filterBlock = InstructionsFromContext (filterCtxt);  			handlers.Add (new FilterTryInstructionHandler (filterBlock' handlerBlock));  			break;  		}  		case PE.CorILExceptionClause.Finally:  			handlers.Add (new FinallyTryInstructionHandler (handlerBlock));  			break;  		case PE.CorILExceptionClause.Fault:  			handlers.Add (new FaultTryInstructionHandler (handlerBlock));  			break;  		default:  			throw new ArgumentOutOfRangeException ();  		}  	}  	instructions.Add (new TryInstruction (offset' tryBlock' handlers));  	// Jump over try block  	var nextOffset = ehcs [0].TryOffset + ehcs [0].TryLength;  	if (!ctxt.OffsetToIndex.TryGetValue (nextOffset' out i))  		i = ctxt.Instructions.Length;  }  else {  	var instruction = ctxt.Instructions [i++];  	var offset = instruction.Offset;  	while (instruction.OpCode == PE.OpCode.Unaligned || instruction.OpCode == PE.OpCode.Volatile || instruction.OpCode == PE.OpCode.Tailcall) {  		// Skip over any ignored prefixes' but remember instruction begins at original offset  		// NOTE: What ever happened to the "no." prefix mentioned in the spec?  		if (i >= ctxt.Instructions.Length)  			throw new InvalidOperationException ("invalid instructions");  		instruction = ctxt.Instructions [i++];  	}  	switch (instruction.OpCode) {  	case PE.OpCode.Cpblk:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Cpblk));  		break;  	case PE.OpCode.Initblk:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Initblk));  		break;  	case PE.OpCode.Arglist:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Arglist));  		break;  	case PE.OpCode.Localloc:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Localloc));  		break;  	case PE.OpCode.Jmp:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Jmp));  		break;  	case PE.OpCode.Calli:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Calli));  		break;  	case PE.OpCode.Sizeof:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Sizeof));  		break;  	case PE.OpCode.Mkrefany:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Mkrefany));  		break;  	case PE.OpCode.Refanytype:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanytype));  		break;  	case PE.OpCode.Refanyval:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanyval));  		break;  	case PE.OpCode.Nop:  		instructions.Add (new MiscInstruction (offset' MiscOp.Nop));  		break;  	case PE.OpCode.Break:  		instructions.Add (new MiscInstruction (offset' MiscOp.Break));  		break;  	case PE.OpCode.Dup:  		instructions.Add (new MiscInstruction (offset' MiscOp.Dup));  		break;  	case PE.OpCode.Pop:  		instructions.Add (new MiscInstruction (offset' MiscOp.Pop));  		break;  	case PE.OpCode.Ldnull:  		instructions.Add (new MiscInstruction (offset' MiscOp.Ldnull));  		break;  	case PE.OpCode.Ckfinite:  		instructions.Add (new MiscInstruction (offset' MiscOp.Ckfinite));  		break;  	case PE.OpCode.Throw:  		instructions.Add (new MiscInstruction (offset' MiscOp.Throw));  		break;  	case PE.OpCode.Rethrow:  		instructions.Add (new MiscInstruction (offset' MiscOp.Rethrow));  		break;  	case PE.OpCode.Ldind_ref:  		instructions.Add (new MiscInstruction (offset' MiscOp.LdindRef));  		break;  	case PE.OpCode.Stind_ref:  		instructions.Add (new MiscInstruction (offset' MiscOp.StindRef));  		break;  	case PE.OpCode.Ldelem_ref:  		instructions.Add (new MiscInstruction (offset' MiscOp.LdelemRef));  		break;  	case PE.OpCode.Stelem_ref:  		instructions.Add (new MiscInstruction (offset' MiscOp.StelemRef));  		break;  	case PE.OpCode.Ldlen:  		instructions.Add (new MiscInstruction (offset' MiscOp.Ldlen));  		break;  	case PE.OpCode.Ret:  		if (ctxt.ResultType == null)  			instructions.Add (new MiscInstruction (offset' MiscOp.Ret));  		else  			instructions.Add (new MiscInstruction (offset' MiscOp.RetVal));  		break;  	case PE.OpCode.Endfilter:  		instructions.Add (new MiscInstruction (offset' MiscOp.Endfilter));  		break;  	case PE.OpCode.Endfinally:  		// aka EndFault  		instructions.Add (new MiscInstruction (offset' MiscOp.Endfinally));  		break;  	case PE.OpCode.Br_s:  	case PE.OpCode.Br:  		instructions.Add (new BranchInstruction (offset' BranchOp.Br' false' (int)instruction.Value));  		break;  	case PE.OpCode.Brtrue_s:  	// aka brinst.s  	case PE.OpCode.Brtrue:  		// aka brinst  		instructions.Add (new BranchInstruction (offset' BranchOp.Brtrue' false' (int)instruction.Value));  		break;  	case PE.OpCode.Brfalse_s:  	// aka brzero.s' brnull.s  	case PE.OpCode.Brfalse:  		// aka brzero' brnull  		instructions.Add (new BranchInstruction (offset' BranchOp.Brfalse' false' (int)instruction.Value));  		break;  	case PE.OpCode.Beq:  	case PE.OpCode.Beq_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.Breq' false' (int)instruction.Value));  		break;  	case PE.OpCode.Bne_un:  	case PE.OpCode.Bne_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.Brne' false' (int)instruction.Value));  		break;  	case PE.OpCode.Leave:  	case PE.OpCode.Leave_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.Leave' false' (int)instruction.Value));  		break;  	case PE.OpCode.Blt:  	case PE.OpCode.Blt_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' false' (int)instruction.Value));  		break;  	case PE.OpCode.Blt_un:  	case PE.OpCode.Blt_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' true' (int)instruction.Value));  		break;  	case PE.OpCode.Ble:  	case PE.OpCode.Ble_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' false' (int)instruction.Value));  		break;  	case PE.OpCode.Ble_un:  	case PE.OpCode.Ble_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' true' (int)instruction.Value));  		break;  	case PE.OpCode.Bgt:  	case PE.OpCode.Bgt_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' false' (int)instruction.Value));  		break;  	case PE.OpCode.Bgt_un:  	case PE.OpCode.Bgt_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' true' (int)instruction.Value));  		break;  	case PE.OpCode.Bge:  	case PE.OpCode.Bge_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' false' (int)instruction.Value));  		break;  	case PE.OpCode.Bge_un:  	case PE.OpCode.Bge_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' true' (int)instruction.Value));  		break;  	case PE.OpCode.Switch:  		instructions.Add (new SwitchInstruction (offset' (Seq<int>)instruction.Value));  		break;  	case PE.OpCode.Ceq:  		instructions.Add (new CompareInstruction (offset' CompareOp.Ceq' false));  		break;  	case PE.OpCode.Clt:  		instructions.Add (new CompareInstruction (offset' CompareOp.Clt' false));  		break;  	case PE.OpCode.Clt_un:  		instructions.Add (new CompareInstruction (offset' CompareOp.Clt' true));  		break;  	case PE.OpCode.Cgt:  		instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' false));  		break;  	case PE.OpCode.Cgt_un:  		instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' true));  		break;  	case PE.OpCode.Ldarg_0:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));  		break;  	case PE.OpCode.Ldarg_1:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));  		break;  	case PE.OpCode.Ldarg_2:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));  		break;  	case PE.OpCode.Ldarg_3:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));  		break;  	case PE.OpCode.Ldarg:  	case PE.OpCode.Ldarg_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));  		break;  	case PE.OpCode.Ldarga:  	case PE.OpCode.Ldarga_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));  		break;  	case PE.OpCode.Starg:  	case PE.OpCode.Starg_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));  		break;  	case PE.OpCode.Ldloc_0:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 0));  		break;  	case PE.OpCode.Ldloc_1:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 1));  		break;  	case PE.OpCode.Ldloc_2:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 2));  		break;  	case PE.OpCode.Ldloc_3:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 3));  		break;  	case PE.OpCode.Ldloc:  	case PE.OpCode.Ldloc_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));  		break;  	case PE.OpCode.Ldloca:  	case PE.OpCode.Ldloca_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));  		break;  	case PE.OpCode.Stloc_0:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 0));  		break;  	case PE.OpCode.Stloc_1:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 1));  		break;  	case PE.OpCode.Stloc_2:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 2));  		break;  	case PE.OpCode.Stloc_3:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 3));  		break;  	case PE.OpCode.Stloc:  	case PE.OpCode.Stloc_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));  		break;  	case PE.OpCode.Ldfld:  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));  		break;  	case PE.OpCode.Ldsfld:  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));  		break;  	case PE.OpCode.Ldflda:  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));  		break;  	case PE.OpCode.Ldsflda:  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));  		break;  	case PE.OpCode.Stfld:  		instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));  		break;  	case PE.OpCode.Stsfld:  		instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));  		break;  	case PE.OpCode.Ldtoken: {  		if (instruction.Value is FieldRef)  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));  		else if (instruction.Value is MethodRef)  			instructions.Add (new MethodInstruction (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));  		else if (instruction.Value is TypeRef)  			// NOTE: May be a higher-kinded type  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));  		else  			throw new InvalidOperationException ("unexpected ldtoken instruction value");  		break;  	}  	case PE.OpCode.Constrained: {  		var constrained = (TypeRef)instruction.Value;  		if (i >= ctxt.Instructions.Length)  			throw new InvalidOperationException ("invalid instructions");  		instruction = ctxt.Instructions [i++];  		if (instruction.OpCode != PE.OpCode.Callvirt)  			throw new InvalidOperationException ("invalid instruction");  		instructions.Add (new MethodInstruction (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));  		break;  	}  	case PE.OpCode.Call:  		instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Callvirt:  		instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Ldftn:  		instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Ldvirtftn:  		instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Newobj:  		instructions.Add (new MethodInstruction (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Ldind_i1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int8Ref));  		break;  	case PE.OpCode.Ldind_u1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt8Ref));  		break;  	case PE.OpCode.Ldind_i2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int16Ref));  		break;  	case PE.OpCode.Ldind_u2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt16Ref));  		break;  	case PE.OpCode.Ldind_i4:  	case PE.OpCode.Ldind_u4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int32Ref));  		break;  	case PE.OpCode.Ldind_i8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int64Ref));  		break;  	case PE.OpCode.Ldind_i:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.IntNativeRef));  		break;  	case PE.OpCode.Ldind_r4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.SingleRef));  		break;  	case PE.OpCode.Ldind_r8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.DoubleRef));  		break;  	case PE.OpCode.Ldobj:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Stind_i1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int8Ref));  		break;  	case PE.OpCode.Stind_i2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int16Ref));  		break;  	case PE.OpCode.Stind_i4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int32Ref));  		break;  	case PE.OpCode.Stind_i8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int64Ref));  		break;  	case PE.OpCode.Stind_i:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.IntNativeRef));  		break;  	case PE.OpCode.Stind_r4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.SingleRef));  		break;  	case PE.OpCode.Stind_r8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.DoubleRef));  		break;  	case PE.OpCode.Stobj:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Cpobj:  		instructions.Add (new TypeInstruction (offset' TypeOp.Cpobj' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Newarr:  		instructions.Add (new TypeInstruction (offset' TypeOp.Newarr' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Initobj:  		instructions.Add (new TypeInstruction (offset' TypeOp.Initobj' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Castclass:  		instructions.Add (new TypeInstruction (offset' TypeOp.Castclass' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Isinst:  		instructions.Add (new TypeInstruction (offset' TypeOp.Isinst' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Box:  		instructions.Add (new TypeInstruction (offset' TypeOp.Box' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Unbox:  		instructions.Add (new TypeInstruction (offset' TypeOp.Unbox' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Unbox_any:  		instructions.Add (new TypeInstruction (offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Ldelem_i1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int8Ref));  		break;  	case PE.OpCode.Ldelem_u1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt8Ref));  		break;  	case PE.OpCode.Ldelem_i2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int16Ref));  		break;  	case PE.OpCode.Ldelem_u2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt16Ref));  		break;  	case PE.OpCode.Ldelem_i4:  	case PE.OpCode.Ldelem_u4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int32Ref));  		break;  	case PE.OpCode.Ldelem_i:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.IntNativeRef));  		break;  	case PE.OpCode.Ldelem_i8:  		// aka ldelem.u8  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int64Ref));  		break;  	case PE.OpCode.Ldelem_r4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.SingleRef));  		break;  	case PE.OpCode.Ldelem_r8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.DoubleRef));  		break;  	case PE.OpCode.Ldelem:  		// aka ldelem.any  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Stelem_i1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int8Ref));  		break;  	case PE.OpCode.Stelem_i2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int16Ref));  		break;  	case PE.OpCode.Stelem_i4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int32Ref));  		break;  	case PE.OpCode.Stelem_i8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int64Ref));  		break;  	case PE.OpCode.Stelem_i:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.IntNativeRef));  		break;  	case PE.OpCode.Stelem_r4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.SingleRef));  		break;  	case PE.OpCode.Stelem_r8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.DoubleRef));  		break;  	case PE.OpCode.Stelem:  		// aka stelem.any  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Readonly:  		if (i >= ctxt.Instructions.Length)  			throw new InvalidOperationException ("invalid instruction");  		instruction = ctxt.Instructions [i++];  		if (instruction.OpCode != PE.OpCode.Ldelema)  			throw new InvalidOperationException ("invalid instruction");  		instructions.Add (new LdElemAddrInstruction (offset' true' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Ldelema:  		instructions.Add (new LdElemAddrInstruction (offset' false' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Ldc_i4_0:  		instructions.Add (new LdInt32Instruction (offset' 0));  		break;  	case PE.OpCode.Ldc_i4_1:  		instructions.Add (new LdInt32Instruction (offset' 1));  		break;  	case PE.OpCode.Ldc_i4_2:  		instructions.Add (new LdInt32Instruction (offset' 2));  		break;  	case PE.OpCode.Ldc_i4_3:  		instructions.Add (new LdInt32Instruction (offset' 3));  		break;  	case PE.OpCode.Ldc_i4_4:  		instructions.Add (new LdInt32Instruction (offset' 4));  		break;  	case PE.OpCode.Ldc_i4_5:  		instructions.Add (new LdInt32Instruction (offset' 5));  		break;  	case PE.OpCode.Ldc_i4_6:  		instructions.Add (new LdInt32Instruction (offset' 6));  		break;  	case PE.OpCode.Ldc_i4_7:  		instructions.Add (new LdInt32Instruction (offset' 7));  		break;  	case PE.OpCode.Ldc_i4_8:  		instructions.Add (new LdInt32Instruction (offset' 8));  		break;  	case PE.OpCode.Ldc_i4_m1:  		instructions.Add (new LdInt32Instruction (offset' -1));  		break;  	case PE.OpCode.Ldc_i4:  	case PE.OpCode.Ldc_i4_s:  		instructions.Add (new LdInt32Instruction (offset' (int)instruction.Value));  		break;  	case PE.OpCode.Ldc_i8:  		instructions.Add (new LdInt64Instruction (offset' (long)instruction.Value));  		break;  	case PE.OpCode.Ldc_r4:  		instructions.Add (new LdSingleInstruction (offset' (float)instruction.Value));  		break;  	case PE.OpCode.Ldc_r8:  		instructions.Add (new LdDoubleInstruction (offset' (double)instruction.Value));  		break;  	case PE.OpCode.Ldstr:  		instructions.Add (new LdStringInstruction (offset' (string)instruction.Value));  		break;  	case PE.OpCode.Add:  		instructions.Add (new ArithInstruction (offset' ArithOp.Add' false' false));  		break;  	case PE.OpCode.Add_ovf:  		instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' false));  		break;  	case PE.OpCode.Add_ovf_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' true));  		break;  	case PE.OpCode.Sub:  		instructions.Add (new ArithInstruction (offset' ArithOp.Sub' false' false));  		break;  	case PE.OpCode.Sub_ovf:  		instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' false));  		break;  	case PE.OpCode.Sub_ovf_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' true));  		break;  	case PE.OpCode.Mul:  		instructions.Add (new ArithInstruction (offset' ArithOp.Mul' false' false));  		break;  	case PE.OpCode.Mul_ovf:  		instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' false));  		break;  	case PE.OpCode.Mul_ovf_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' true));  		break;  	case PE.OpCode.Div:  		instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' false));  		break;  	case PE.OpCode.Div_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' true));  		break;  	case PE.OpCode.Rem:  		instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' false));  		break;  	case PE.OpCode.Rem_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' true));  		break;  	case PE.OpCode.Neg:  		instructions.Add (new ArithInstruction (offset' ArithOp.Neg' false' false));  		break;  	case PE.OpCode.And:  		instructions.Add (new ArithInstruction (offset' ArithOp.BitAnd' false' false));  		break;  	case PE.OpCode.Or:  		instructions.Add (new ArithInstruction (offset' ArithOp.BitOr' false' false));  		break;  	case PE.OpCode.Xor:  		instructions.Add (new ArithInstruction (offset' ArithOp.BitXor' false' false));  		break;  	case PE.OpCode.Not:  		instructions.Add (new ArithInstruction (offset' ArithOp.BitNot' false' false));  		break;  	case PE.OpCode.Shl:  		instructions.Add (new ArithInstruction (offset' ArithOp.Shl' false' false));  		break;  	case PE.OpCode.Shr:  		instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' false));  		break;  	case PE.OpCode.Shr_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' true));  		break;  	case PE.OpCode.Conv_i1:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' false' false));  		break;  	case PE.OpCode.Conv_u1:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' false' false));  		break;  	case PE.OpCode.Conv_i2:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' false' false));  		break;  	case PE.OpCode.Conv_u2:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' false' false));  		break;  	case PE.OpCode.Conv_i4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' false' false));  		break;  	case PE.OpCode.Conv_u4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' false' false));  		break;  	case PE.OpCode.Conv_i8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' false' false));  		break;  	case PE.OpCode.Conv_u8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' false' false));  		break;  	case PE.OpCode.Conv_i:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' false' false));  		break;  	case PE.OpCode.Conv_u:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' false' false));  		break;  	case PE.OpCode.Conv_r4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Single' false' false));  		break;  	case PE.OpCode.Conv_r8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' false));  		break;  	case PE.OpCode.Conv_r_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' true));  		break;  	case PE.OpCode.Conv_ovf_i1:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' false));  		break;  	case PE.OpCode.Conv_ovf_u1:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' false));  		break;  	case PE.OpCode.Conv_ovf_i2:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' false));  		break;  	case PE.OpCode.Conv_ovf_u2:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' false));  		break;  	case PE.OpCode.Conv_ovf_i4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' false));  		break;  	case PE.OpCode.Conv_ovf_u4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' false));  		break;  	case PE.OpCode.Conv_ovf_i8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' false));  		break;  	case PE.OpCode.Conv_ovf_u8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' false));  		break;  	case PE.OpCode.Conv_ovf_i:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' false));  		break;  	case PE.OpCode.Conv_ovf_u:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' false));  		break;  	case PE.OpCode.Conv_ovf_i1_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' true));  		break;  	case PE.OpCode.Conv_ovf_u1_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' true));  		break;  	case PE.OpCode.Conv_ovf_i2_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' true));  		break;  	case PE.OpCode.Conv_ovf_u2_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' true));  		break;  	case PE.OpCode.Conv_ovf_i4_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' true));  		break;  	case PE.OpCode.Conv_ovf_u4_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' true));  		break;  	case PE.OpCode.Conv_ovf_i8_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' true));  		break;  	case PE.OpCode.Conv_ovf_u8_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' true));  		break;  	case PE.OpCode.Conv_ovf_i_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' true));  		break;  	case PE.OpCode.Conv_ovf_u_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' true));  		break;  	default:  		throw new InvalidOperationException ("invalid instruction");  	}  }  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: if (ehcs != null) {  	// A try instruction begins here with given handlers  	var offset = ctxt.Instructions [i].Offset;  	var tryCtxt = new TryTranslationContext (ctxt' i' ehcs);  	var tryBlock = InstructionsFromContext (tryCtxt);  	var handlers = new Seq<TryInstructionHandler> ();  	foreach (var ehc in ehcs) {  		var handlerCtxt = new HandlerTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.HandlerOffset]' ehc);  		var handlerBlock = InstructionsFromContext (handlerCtxt);  		switch (ehc.Flags) {  		case PE.CorILExceptionClause.Exception:  			handlers.Add (new CatchTryInstructionHandler ((TypeRef)ehc.Class' handlerBlock));  			break;  		case PE.CorILExceptionClause.Filter: {  			var filterCtxt = new FilterTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.FilterOffset]' ehc);  			var filterBlock = InstructionsFromContext (filterCtxt);  			handlers.Add (new FilterTryInstructionHandler (filterBlock' handlerBlock));  			break;  		}  		case PE.CorILExceptionClause.Finally:  			handlers.Add (new FinallyTryInstructionHandler (handlerBlock));  			break;  		case PE.CorILExceptionClause.Fault:  			handlers.Add (new FaultTryInstructionHandler (handlerBlock));  			break;  		default:  			throw new ArgumentOutOfRangeException ();  		}  	}  	instructions.Add (new TryInstruction (offset' tryBlock' handlers));  	// Jump over try block  	var nextOffset = ehcs [0].TryOffset + ehcs [0].TryLength;  	if (!ctxt.OffsetToIndex.TryGetValue (nextOffset' out i))  		i = ctxt.Instructions.Length;  }  else {  	var instruction = ctxt.Instructions [i++];  	var offset = instruction.Offset;  	while (instruction.OpCode == PE.OpCode.Unaligned || instruction.OpCode == PE.OpCode.Volatile || instruction.OpCode == PE.OpCode.Tailcall) {  		// Skip over any ignored prefixes' but remember instruction begins at original offset  		// NOTE: What ever happened to the "no." prefix mentioned in the spec?  		if (i >= ctxt.Instructions.Length)  			throw new InvalidOperationException ("invalid instructions");  		instruction = ctxt.Instructions [i++];  	}  	switch (instruction.OpCode) {  	case PE.OpCode.Cpblk:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Cpblk));  		break;  	case PE.OpCode.Initblk:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Initblk));  		break;  	case PE.OpCode.Arglist:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Arglist));  		break;  	case PE.OpCode.Localloc:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Localloc));  		break;  	case PE.OpCode.Jmp:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Jmp));  		break;  	case PE.OpCode.Calli:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Calli));  		break;  	case PE.OpCode.Sizeof:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Sizeof));  		break;  	case PE.OpCode.Mkrefany:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Mkrefany));  		break;  	case PE.OpCode.Refanytype:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanytype));  		break;  	case PE.OpCode.Refanyval:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanyval));  		break;  	case PE.OpCode.Nop:  		instructions.Add (new MiscInstruction (offset' MiscOp.Nop));  		break;  	case PE.OpCode.Break:  		instructions.Add (new MiscInstruction (offset' MiscOp.Break));  		break;  	case PE.OpCode.Dup:  		instructions.Add (new MiscInstruction (offset' MiscOp.Dup));  		break;  	case PE.OpCode.Pop:  		instructions.Add (new MiscInstruction (offset' MiscOp.Pop));  		break;  	case PE.OpCode.Ldnull:  		instructions.Add (new MiscInstruction (offset' MiscOp.Ldnull));  		break;  	case PE.OpCode.Ckfinite:  		instructions.Add (new MiscInstruction (offset' MiscOp.Ckfinite));  		break;  	case PE.OpCode.Throw:  		instructions.Add (new MiscInstruction (offset' MiscOp.Throw));  		break;  	case PE.OpCode.Rethrow:  		instructions.Add (new MiscInstruction (offset' MiscOp.Rethrow));  		break;  	case PE.OpCode.Ldind_ref:  		instructions.Add (new MiscInstruction (offset' MiscOp.LdindRef));  		break;  	case PE.OpCode.Stind_ref:  		instructions.Add (new MiscInstruction (offset' MiscOp.StindRef));  		break;  	case PE.OpCode.Ldelem_ref:  		instructions.Add (new MiscInstruction (offset' MiscOp.LdelemRef));  		break;  	case PE.OpCode.Stelem_ref:  		instructions.Add (new MiscInstruction (offset' MiscOp.StelemRef));  		break;  	case PE.OpCode.Ldlen:  		instructions.Add (new MiscInstruction (offset' MiscOp.Ldlen));  		break;  	case PE.OpCode.Ret:  		if (ctxt.ResultType == null)  			instructions.Add (new MiscInstruction (offset' MiscOp.Ret));  		else  			instructions.Add (new MiscInstruction (offset' MiscOp.RetVal));  		break;  	case PE.OpCode.Endfilter:  		instructions.Add (new MiscInstruction (offset' MiscOp.Endfilter));  		break;  	case PE.OpCode.Endfinally:  		// aka EndFault  		instructions.Add (new MiscInstruction (offset' MiscOp.Endfinally));  		break;  	case PE.OpCode.Br_s:  	case PE.OpCode.Br:  		instructions.Add (new BranchInstruction (offset' BranchOp.Br' false' (int)instruction.Value));  		break;  	case PE.OpCode.Brtrue_s:  	// aka brinst.s  	case PE.OpCode.Brtrue:  		// aka brinst  		instructions.Add (new BranchInstruction (offset' BranchOp.Brtrue' false' (int)instruction.Value));  		break;  	case PE.OpCode.Brfalse_s:  	// aka brzero.s' brnull.s  	case PE.OpCode.Brfalse:  		// aka brzero' brnull  		instructions.Add (new BranchInstruction (offset' BranchOp.Brfalse' false' (int)instruction.Value));  		break;  	case PE.OpCode.Beq:  	case PE.OpCode.Beq_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.Breq' false' (int)instruction.Value));  		break;  	case PE.OpCode.Bne_un:  	case PE.OpCode.Bne_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.Brne' false' (int)instruction.Value));  		break;  	case PE.OpCode.Leave:  	case PE.OpCode.Leave_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.Leave' false' (int)instruction.Value));  		break;  	case PE.OpCode.Blt:  	case PE.OpCode.Blt_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' false' (int)instruction.Value));  		break;  	case PE.OpCode.Blt_un:  	case PE.OpCode.Blt_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' true' (int)instruction.Value));  		break;  	case PE.OpCode.Ble:  	case PE.OpCode.Ble_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' false' (int)instruction.Value));  		break;  	case PE.OpCode.Ble_un:  	case PE.OpCode.Ble_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' true' (int)instruction.Value));  		break;  	case PE.OpCode.Bgt:  	case PE.OpCode.Bgt_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' false' (int)instruction.Value));  		break;  	case PE.OpCode.Bgt_un:  	case PE.OpCode.Bgt_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' true' (int)instruction.Value));  		break;  	case PE.OpCode.Bge:  	case PE.OpCode.Bge_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' false' (int)instruction.Value));  		break;  	case PE.OpCode.Bge_un:  	case PE.OpCode.Bge_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' true' (int)instruction.Value));  		break;  	case PE.OpCode.Switch:  		instructions.Add (new SwitchInstruction (offset' (Seq<int>)instruction.Value));  		break;  	case PE.OpCode.Ceq:  		instructions.Add (new CompareInstruction (offset' CompareOp.Ceq' false));  		break;  	case PE.OpCode.Clt:  		instructions.Add (new CompareInstruction (offset' CompareOp.Clt' false));  		break;  	case PE.OpCode.Clt_un:  		instructions.Add (new CompareInstruction (offset' CompareOp.Clt' true));  		break;  	case PE.OpCode.Cgt:  		instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' false));  		break;  	case PE.OpCode.Cgt_un:  		instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' true));  		break;  	case PE.OpCode.Ldarg_0:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));  		break;  	case PE.OpCode.Ldarg_1:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));  		break;  	case PE.OpCode.Ldarg_2:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));  		break;  	case PE.OpCode.Ldarg_3:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));  		break;  	case PE.OpCode.Ldarg:  	case PE.OpCode.Ldarg_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));  		break;  	case PE.OpCode.Ldarga:  	case PE.OpCode.Ldarga_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));  		break;  	case PE.OpCode.Starg:  	case PE.OpCode.Starg_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));  		break;  	case PE.OpCode.Ldloc_0:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 0));  		break;  	case PE.OpCode.Ldloc_1:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 1));  		break;  	case PE.OpCode.Ldloc_2:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 2));  		break;  	case PE.OpCode.Ldloc_3:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 3));  		break;  	case PE.OpCode.Ldloc:  	case PE.OpCode.Ldloc_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));  		break;  	case PE.OpCode.Ldloca:  	case PE.OpCode.Ldloca_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));  		break;  	case PE.OpCode.Stloc_0:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 0));  		break;  	case PE.OpCode.Stloc_1:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 1));  		break;  	case PE.OpCode.Stloc_2:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 2));  		break;  	case PE.OpCode.Stloc_3:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 3));  		break;  	case PE.OpCode.Stloc:  	case PE.OpCode.Stloc_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));  		break;  	case PE.OpCode.Ldfld:  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));  		break;  	case PE.OpCode.Ldsfld:  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));  		break;  	case PE.OpCode.Ldflda:  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));  		break;  	case PE.OpCode.Ldsflda:  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));  		break;  	case PE.OpCode.Stfld:  		instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));  		break;  	case PE.OpCode.Stsfld:  		instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));  		break;  	case PE.OpCode.Ldtoken: {  		if (instruction.Value is FieldRef)  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));  		else if (instruction.Value is MethodRef)  			instructions.Add (new MethodInstruction (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));  		else if (instruction.Value is TypeRef)  			// NOTE: May be a higher-kinded type  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));  		else  			throw new InvalidOperationException ("unexpected ldtoken instruction value");  		break;  	}  	case PE.OpCode.Constrained: {  		var constrained = (TypeRef)instruction.Value;  		if (i >= ctxt.Instructions.Length)  			throw new InvalidOperationException ("invalid instructions");  		instruction = ctxt.Instructions [i++];  		if (instruction.OpCode != PE.OpCode.Callvirt)  			throw new InvalidOperationException ("invalid instruction");  		instructions.Add (new MethodInstruction (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));  		break;  	}  	case PE.OpCode.Call:  		instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Callvirt:  		instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Ldftn:  		instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Ldvirtftn:  		instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Newobj:  		instructions.Add (new MethodInstruction (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Ldind_i1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int8Ref));  		break;  	case PE.OpCode.Ldind_u1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt8Ref));  		break;  	case PE.OpCode.Ldind_i2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int16Ref));  		break;  	case PE.OpCode.Ldind_u2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt16Ref));  		break;  	case PE.OpCode.Ldind_i4:  	case PE.OpCode.Ldind_u4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int32Ref));  		break;  	case PE.OpCode.Ldind_i8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int64Ref));  		break;  	case PE.OpCode.Ldind_i:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.IntNativeRef));  		break;  	case PE.OpCode.Ldind_r4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.SingleRef));  		break;  	case PE.OpCode.Ldind_r8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.DoubleRef));  		break;  	case PE.OpCode.Ldobj:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Stind_i1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int8Ref));  		break;  	case PE.OpCode.Stind_i2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int16Ref));  		break;  	case PE.OpCode.Stind_i4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int32Ref));  		break;  	case PE.OpCode.Stind_i8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int64Ref));  		break;  	case PE.OpCode.Stind_i:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.IntNativeRef));  		break;  	case PE.OpCode.Stind_r4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.SingleRef));  		break;  	case PE.OpCode.Stind_r8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.DoubleRef));  		break;  	case PE.OpCode.Stobj:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Cpobj:  		instructions.Add (new TypeInstruction (offset' TypeOp.Cpobj' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Newarr:  		instructions.Add (new TypeInstruction (offset' TypeOp.Newarr' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Initobj:  		instructions.Add (new TypeInstruction (offset' TypeOp.Initobj' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Castclass:  		instructions.Add (new TypeInstruction (offset' TypeOp.Castclass' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Isinst:  		instructions.Add (new TypeInstruction (offset' TypeOp.Isinst' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Box:  		instructions.Add (new TypeInstruction (offset' TypeOp.Box' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Unbox:  		instructions.Add (new TypeInstruction (offset' TypeOp.Unbox' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Unbox_any:  		instructions.Add (new TypeInstruction (offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Ldelem_i1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int8Ref));  		break;  	case PE.OpCode.Ldelem_u1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt8Ref));  		break;  	case PE.OpCode.Ldelem_i2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int16Ref));  		break;  	case PE.OpCode.Ldelem_u2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt16Ref));  		break;  	case PE.OpCode.Ldelem_i4:  	case PE.OpCode.Ldelem_u4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int32Ref));  		break;  	case PE.OpCode.Ldelem_i:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.IntNativeRef));  		break;  	case PE.OpCode.Ldelem_i8:  		// aka ldelem.u8  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int64Ref));  		break;  	case PE.OpCode.Ldelem_r4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.SingleRef));  		break;  	case PE.OpCode.Ldelem_r8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.DoubleRef));  		break;  	case PE.OpCode.Ldelem:  		// aka ldelem.any  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Stelem_i1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int8Ref));  		break;  	case PE.OpCode.Stelem_i2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int16Ref));  		break;  	case PE.OpCode.Stelem_i4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int32Ref));  		break;  	case PE.OpCode.Stelem_i8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int64Ref));  		break;  	case PE.OpCode.Stelem_i:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.IntNativeRef));  		break;  	case PE.OpCode.Stelem_r4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.SingleRef));  		break;  	case PE.OpCode.Stelem_r8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.DoubleRef));  		break;  	case PE.OpCode.Stelem:  		// aka stelem.any  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Readonly:  		if (i >= ctxt.Instructions.Length)  			throw new InvalidOperationException ("invalid instruction");  		instruction = ctxt.Instructions [i++];  		if (instruction.OpCode != PE.OpCode.Ldelema)  			throw new InvalidOperationException ("invalid instruction");  		instructions.Add (new LdElemAddrInstruction (offset' true' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Ldelema:  		instructions.Add (new LdElemAddrInstruction (offset' false' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Ldc_i4_0:  		instructions.Add (new LdInt32Instruction (offset' 0));  		break;  	case PE.OpCode.Ldc_i4_1:  		instructions.Add (new LdInt32Instruction (offset' 1));  		break;  	case PE.OpCode.Ldc_i4_2:  		instructions.Add (new LdInt32Instruction (offset' 2));  		break;  	case PE.OpCode.Ldc_i4_3:  		instructions.Add (new LdInt32Instruction (offset' 3));  		break;  	case PE.OpCode.Ldc_i4_4:  		instructions.Add (new LdInt32Instruction (offset' 4));  		break;  	case PE.OpCode.Ldc_i4_5:  		instructions.Add (new LdInt32Instruction (offset' 5));  		break;  	case PE.OpCode.Ldc_i4_6:  		instructions.Add (new LdInt32Instruction (offset' 6));  		break;  	case PE.OpCode.Ldc_i4_7:  		instructions.Add (new LdInt32Instruction (offset' 7));  		break;  	case PE.OpCode.Ldc_i4_8:  		instructions.Add (new LdInt32Instruction (offset' 8));  		break;  	case PE.OpCode.Ldc_i4_m1:  		instructions.Add (new LdInt32Instruction (offset' -1));  		break;  	case PE.OpCode.Ldc_i4:  	case PE.OpCode.Ldc_i4_s:  		instructions.Add (new LdInt32Instruction (offset' (int)instruction.Value));  		break;  	case PE.OpCode.Ldc_i8:  		instructions.Add (new LdInt64Instruction (offset' (long)instruction.Value));  		break;  	case PE.OpCode.Ldc_r4:  		instructions.Add (new LdSingleInstruction (offset' (float)instruction.Value));  		break;  	case PE.OpCode.Ldc_r8:  		instructions.Add (new LdDoubleInstruction (offset' (double)instruction.Value));  		break;  	case PE.OpCode.Ldstr:  		instructions.Add (new LdStringInstruction (offset' (string)instruction.Value));  		break;  	case PE.OpCode.Add:  		instructions.Add (new ArithInstruction (offset' ArithOp.Add' false' false));  		break;  	case PE.OpCode.Add_ovf:  		instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' false));  		break;  	case PE.OpCode.Add_ovf_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' true));  		break;  	case PE.OpCode.Sub:  		instructions.Add (new ArithInstruction (offset' ArithOp.Sub' false' false));  		break;  	case PE.OpCode.Sub_ovf:  		instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' false));  		break;  	case PE.OpCode.Sub_ovf_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' true));  		break;  	case PE.OpCode.Mul:  		instructions.Add (new ArithInstruction (offset' ArithOp.Mul' false' false));  		break;  	case PE.OpCode.Mul_ovf:  		instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' false));  		break;  	case PE.OpCode.Mul_ovf_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' true));  		break;  	case PE.OpCode.Div:  		instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' false));  		break;  	case PE.OpCode.Div_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' true));  		break;  	case PE.OpCode.Rem:  		instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' false));  		break;  	case PE.OpCode.Rem_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' true));  		break;  	case PE.OpCode.Neg:  		instructions.Add (new ArithInstruction (offset' ArithOp.Neg' false' false));  		break;  	case PE.OpCode.And:  		instructions.Add (new ArithInstruction (offset' ArithOp.BitAnd' false' false));  		break;  	case PE.OpCode.Or:  		instructions.Add (new ArithInstruction (offset' ArithOp.BitOr' false' false));  		break;  	case PE.OpCode.Xor:  		instructions.Add (new ArithInstruction (offset' ArithOp.BitXor' false' false));  		break;  	case PE.OpCode.Not:  		instructions.Add (new ArithInstruction (offset' ArithOp.BitNot' false' false));  		break;  	case PE.OpCode.Shl:  		instructions.Add (new ArithInstruction (offset' ArithOp.Shl' false' false));  		break;  	case PE.OpCode.Shr:  		instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' false));  		break;  	case PE.OpCode.Shr_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' true));  		break;  	case PE.OpCode.Conv_i1:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' false' false));  		break;  	case PE.OpCode.Conv_u1:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' false' false));  		break;  	case PE.OpCode.Conv_i2:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' false' false));  		break;  	case PE.OpCode.Conv_u2:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' false' false));  		break;  	case PE.OpCode.Conv_i4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' false' false));  		break;  	case PE.OpCode.Conv_u4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' false' false));  		break;  	case PE.OpCode.Conv_i8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' false' false));  		break;  	case PE.OpCode.Conv_u8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' false' false));  		break;  	case PE.OpCode.Conv_i:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' false' false));  		break;  	case PE.OpCode.Conv_u:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' false' false));  		break;  	case PE.OpCode.Conv_r4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Single' false' false));  		break;  	case PE.OpCode.Conv_r8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' false));  		break;  	case PE.OpCode.Conv_r_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' true));  		break;  	case PE.OpCode.Conv_ovf_i1:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' false));  		break;  	case PE.OpCode.Conv_ovf_u1:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' false));  		break;  	case PE.OpCode.Conv_ovf_i2:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' false));  		break;  	case PE.OpCode.Conv_ovf_u2:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' false));  		break;  	case PE.OpCode.Conv_ovf_i4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' false));  		break;  	case PE.OpCode.Conv_ovf_u4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' false));  		break;  	case PE.OpCode.Conv_ovf_i8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' false));  		break;  	case PE.OpCode.Conv_ovf_u8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' false));  		break;  	case PE.OpCode.Conv_ovf_i:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' false));  		break;  	case PE.OpCode.Conv_ovf_u:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' false));  		break;  	case PE.OpCode.Conv_ovf_i1_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' true));  		break;  	case PE.OpCode.Conv_ovf_u1_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' true));  		break;  	case PE.OpCode.Conv_ovf_i2_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' true));  		break;  	case PE.OpCode.Conv_ovf_u2_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' true));  		break;  	case PE.OpCode.Conv_ovf_i4_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' true));  		break;  	case PE.OpCode.Conv_ovf_u4_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' true));  		break;  	case PE.OpCode.Conv_ovf_i8_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' true));  		break;  	case PE.OpCode.Conv_ovf_u8_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' true));  		break;  	case PE.OpCode.Conv_ovf_i_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' true));  		break;  	case PE.OpCode.Conv_ovf_u_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' true));  		break;  	default:  		throw new InvalidOperationException ("invalid instruction");  	}  }  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: if (ehcs != null) {  	// A try instruction begins here with given handlers  	var offset = ctxt.Instructions [i].Offset;  	var tryCtxt = new TryTranslationContext (ctxt' i' ehcs);  	var tryBlock = InstructionsFromContext (tryCtxt);  	var handlers = new Seq<TryInstructionHandler> ();  	foreach (var ehc in ehcs) {  		var handlerCtxt = new HandlerTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.HandlerOffset]' ehc);  		var handlerBlock = InstructionsFromContext (handlerCtxt);  		switch (ehc.Flags) {  		case PE.CorILExceptionClause.Exception:  			handlers.Add (new CatchTryInstructionHandler ((TypeRef)ehc.Class' handlerBlock));  			break;  		case PE.CorILExceptionClause.Filter: {  			var filterCtxt = new FilterTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.FilterOffset]' ehc);  			var filterBlock = InstructionsFromContext (filterCtxt);  			handlers.Add (new FilterTryInstructionHandler (filterBlock' handlerBlock));  			break;  		}  		case PE.CorILExceptionClause.Finally:  			handlers.Add (new FinallyTryInstructionHandler (handlerBlock));  			break;  		case PE.CorILExceptionClause.Fault:  			handlers.Add (new FaultTryInstructionHandler (handlerBlock));  			break;  		default:  			throw new ArgumentOutOfRangeException ();  		}  	}  	instructions.Add (new TryInstruction (offset' tryBlock' handlers));  	// Jump over try block  	var nextOffset = ehcs [0].TryOffset + ehcs [0].TryLength;  	if (!ctxt.OffsetToIndex.TryGetValue (nextOffset' out i))  		i = ctxt.Instructions.Length;  }  else {  	var instruction = ctxt.Instructions [i++];  	var offset = instruction.Offset;  	while (instruction.OpCode == PE.OpCode.Unaligned || instruction.OpCode == PE.OpCode.Volatile || instruction.OpCode == PE.OpCode.Tailcall) {  		// Skip over any ignored prefixes' but remember instruction begins at original offset  		// NOTE: What ever happened to the "no." prefix mentioned in the spec?  		if (i >= ctxt.Instructions.Length)  			throw new InvalidOperationException ("invalid instructions");  		instruction = ctxt.Instructions [i++];  	}  	switch (instruction.OpCode) {  	case PE.OpCode.Cpblk:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Cpblk));  		break;  	case PE.OpCode.Initblk:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Initblk));  		break;  	case PE.OpCode.Arglist:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Arglist));  		break;  	case PE.OpCode.Localloc:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Localloc));  		break;  	case PE.OpCode.Jmp:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Jmp));  		break;  	case PE.OpCode.Calli:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Calli));  		break;  	case PE.OpCode.Sizeof:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Sizeof));  		break;  	case PE.OpCode.Mkrefany:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Mkrefany));  		break;  	case PE.OpCode.Refanytype:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanytype));  		break;  	case PE.OpCode.Refanyval:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanyval));  		break;  	case PE.OpCode.Nop:  		instructions.Add (new MiscInstruction (offset' MiscOp.Nop));  		break;  	case PE.OpCode.Break:  		instructions.Add (new MiscInstruction (offset' MiscOp.Break));  		break;  	case PE.OpCode.Dup:  		instructions.Add (new MiscInstruction (offset' MiscOp.Dup));  		break;  	case PE.OpCode.Pop:  		instructions.Add (new MiscInstruction (offset' MiscOp.Pop));  		break;  	case PE.OpCode.Ldnull:  		instructions.Add (new MiscInstruction (offset' MiscOp.Ldnull));  		break;  	case PE.OpCode.Ckfinite:  		instructions.Add (new MiscInstruction (offset' MiscOp.Ckfinite));  		break;  	case PE.OpCode.Throw:  		instructions.Add (new MiscInstruction (offset' MiscOp.Throw));  		break;  	case PE.OpCode.Rethrow:  		instructions.Add (new MiscInstruction (offset' MiscOp.Rethrow));  		break;  	case PE.OpCode.Ldind_ref:  		instructions.Add (new MiscInstruction (offset' MiscOp.LdindRef));  		break;  	case PE.OpCode.Stind_ref:  		instructions.Add (new MiscInstruction (offset' MiscOp.StindRef));  		break;  	case PE.OpCode.Ldelem_ref:  		instructions.Add (new MiscInstruction (offset' MiscOp.LdelemRef));  		break;  	case PE.OpCode.Stelem_ref:  		instructions.Add (new MiscInstruction (offset' MiscOp.StelemRef));  		break;  	case PE.OpCode.Ldlen:  		instructions.Add (new MiscInstruction (offset' MiscOp.Ldlen));  		break;  	case PE.OpCode.Ret:  		if (ctxt.ResultType == null)  			instructions.Add (new MiscInstruction (offset' MiscOp.Ret));  		else  			instructions.Add (new MiscInstruction (offset' MiscOp.RetVal));  		break;  	case PE.OpCode.Endfilter:  		instructions.Add (new MiscInstruction (offset' MiscOp.Endfilter));  		break;  	case PE.OpCode.Endfinally:  		// aka EndFault  		instructions.Add (new MiscInstruction (offset' MiscOp.Endfinally));  		break;  	case PE.OpCode.Br_s:  	case PE.OpCode.Br:  		instructions.Add (new BranchInstruction (offset' BranchOp.Br' false' (int)instruction.Value));  		break;  	case PE.OpCode.Brtrue_s:  	// aka brinst.s  	case PE.OpCode.Brtrue:  		// aka brinst  		instructions.Add (new BranchInstruction (offset' BranchOp.Brtrue' false' (int)instruction.Value));  		break;  	case PE.OpCode.Brfalse_s:  	// aka brzero.s' brnull.s  	case PE.OpCode.Brfalse:  		// aka brzero' brnull  		instructions.Add (new BranchInstruction (offset' BranchOp.Brfalse' false' (int)instruction.Value));  		break;  	case PE.OpCode.Beq:  	case PE.OpCode.Beq_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.Breq' false' (int)instruction.Value));  		break;  	case PE.OpCode.Bne_un:  	case PE.OpCode.Bne_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.Brne' false' (int)instruction.Value));  		break;  	case PE.OpCode.Leave:  	case PE.OpCode.Leave_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.Leave' false' (int)instruction.Value));  		break;  	case PE.OpCode.Blt:  	case PE.OpCode.Blt_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' false' (int)instruction.Value));  		break;  	case PE.OpCode.Blt_un:  	case PE.OpCode.Blt_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' true' (int)instruction.Value));  		break;  	case PE.OpCode.Ble:  	case PE.OpCode.Ble_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' false' (int)instruction.Value));  		break;  	case PE.OpCode.Ble_un:  	case PE.OpCode.Ble_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' true' (int)instruction.Value));  		break;  	case PE.OpCode.Bgt:  	case PE.OpCode.Bgt_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' false' (int)instruction.Value));  		break;  	case PE.OpCode.Bgt_un:  	case PE.OpCode.Bgt_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' true' (int)instruction.Value));  		break;  	case PE.OpCode.Bge:  	case PE.OpCode.Bge_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' false' (int)instruction.Value));  		break;  	case PE.OpCode.Bge_un:  	case PE.OpCode.Bge_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' true' (int)instruction.Value));  		break;  	case PE.OpCode.Switch:  		instructions.Add (new SwitchInstruction (offset' (Seq<int>)instruction.Value));  		break;  	case PE.OpCode.Ceq:  		instructions.Add (new CompareInstruction (offset' CompareOp.Ceq' false));  		break;  	case PE.OpCode.Clt:  		instructions.Add (new CompareInstruction (offset' CompareOp.Clt' false));  		break;  	case PE.OpCode.Clt_un:  		instructions.Add (new CompareInstruction (offset' CompareOp.Clt' true));  		break;  	case PE.OpCode.Cgt:  		instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' false));  		break;  	case PE.OpCode.Cgt_un:  		instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' true));  		break;  	case PE.OpCode.Ldarg_0:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));  		break;  	case PE.OpCode.Ldarg_1:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));  		break;  	case PE.OpCode.Ldarg_2:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));  		break;  	case PE.OpCode.Ldarg_3:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));  		break;  	case PE.OpCode.Ldarg:  	case PE.OpCode.Ldarg_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));  		break;  	case PE.OpCode.Ldarga:  	case PE.OpCode.Ldarga_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));  		break;  	case PE.OpCode.Starg:  	case PE.OpCode.Starg_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));  		break;  	case PE.OpCode.Ldloc_0:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 0));  		break;  	case PE.OpCode.Ldloc_1:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 1));  		break;  	case PE.OpCode.Ldloc_2:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 2));  		break;  	case PE.OpCode.Ldloc_3:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 3));  		break;  	case PE.OpCode.Ldloc:  	case PE.OpCode.Ldloc_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));  		break;  	case PE.OpCode.Ldloca:  	case PE.OpCode.Ldloca_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));  		break;  	case PE.OpCode.Stloc_0:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 0));  		break;  	case PE.OpCode.Stloc_1:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 1));  		break;  	case PE.OpCode.Stloc_2:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 2));  		break;  	case PE.OpCode.Stloc_3:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 3));  		break;  	case PE.OpCode.Stloc:  	case PE.OpCode.Stloc_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));  		break;  	case PE.OpCode.Ldfld:  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));  		break;  	case PE.OpCode.Ldsfld:  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));  		break;  	case PE.OpCode.Ldflda:  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));  		break;  	case PE.OpCode.Ldsflda:  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));  		break;  	case PE.OpCode.Stfld:  		instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));  		break;  	case PE.OpCode.Stsfld:  		instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));  		break;  	case PE.OpCode.Ldtoken: {  		if (instruction.Value is FieldRef)  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));  		else if (instruction.Value is MethodRef)  			instructions.Add (new MethodInstruction (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));  		else if (instruction.Value is TypeRef)  			// NOTE: May be a higher-kinded type  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));  		else  			throw new InvalidOperationException ("unexpected ldtoken instruction value");  		break;  	}  	case PE.OpCode.Constrained: {  		var constrained = (TypeRef)instruction.Value;  		if (i >= ctxt.Instructions.Length)  			throw new InvalidOperationException ("invalid instructions");  		instruction = ctxt.Instructions [i++];  		if (instruction.OpCode != PE.OpCode.Callvirt)  			throw new InvalidOperationException ("invalid instruction");  		instructions.Add (new MethodInstruction (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));  		break;  	}  	case PE.OpCode.Call:  		instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Callvirt:  		instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Ldftn:  		instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Ldvirtftn:  		instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Newobj:  		instructions.Add (new MethodInstruction (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Ldind_i1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int8Ref));  		break;  	case PE.OpCode.Ldind_u1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt8Ref));  		break;  	case PE.OpCode.Ldind_i2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int16Ref));  		break;  	case PE.OpCode.Ldind_u2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt16Ref));  		break;  	case PE.OpCode.Ldind_i4:  	case PE.OpCode.Ldind_u4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int32Ref));  		break;  	case PE.OpCode.Ldind_i8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int64Ref));  		break;  	case PE.OpCode.Ldind_i:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.IntNativeRef));  		break;  	case PE.OpCode.Ldind_r4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.SingleRef));  		break;  	case PE.OpCode.Ldind_r8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.DoubleRef));  		break;  	case PE.OpCode.Ldobj:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Stind_i1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int8Ref));  		break;  	case PE.OpCode.Stind_i2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int16Ref));  		break;  	case PE.OpCode.Stind_i4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int32Ref));  		break;  	case PE.OpCode.Stind_i8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int64Ref));  		break;  	case PE.OpCode.Stind_i:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.IntNativeRef));  		break;  	case PE.OpCode.Stind_r4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.SingleRef));  		break;  	case PE.OpCode.Stind_r8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.DoubleRef));  		break;  	case PE.OpCode.Stobj:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Cpobj:  		instructions.Add (new TypeInstruction (offset' TypeOp.Cpobj' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Newarr:  		instructions.Add (new TypeInstruction (offset' TypeOp.Newarr' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Initobj:  		instructions.Add (new TypeInstruction (offset' TypeOp.Initobj' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Castclass:  		instructions.Add (new TypeInstruction (offset' TypeOp.Castclass' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Isinst:  		instructions.Add (new TypeInstruction (offset' TypeOp.Isinst' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Box:  		instructions.Add (new TypeInstruction (offset' TypeOp.Box' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Unbox:  		instructions.Add (new TypeInstruction (offset' TypeOp.Unbox' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Unbox_any:  		instructions.Add (new TypeInstruction (offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Ldelem_i1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int8Ref));  		break;  	case PE.OpCode.Ldelem_u1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt8Ref));  		break;  	case PE.OpCode.Ldelem_i2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int16Ref));  		break;  	case PE.OpCode.Ldelem_u2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt16Ref));  		break;  	case PE.OpCode.Ldelem_i4:  	case PE.OpCode.Ldelem_u4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int32Ref));  		break;  	case PE.OpCode.Ldelem_i:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.IntNativeRef));  		break;  	case PE.OpCode.Ldelem_i8:  		// aka ldelem.u8  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int64Ref));  		break;  	case PE.OpCode.Ldelem_r4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.SingleRef));  		break;  	case PE.OpCode.Ldelem_r8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.DoubleRef));  		break;  	case PE.OpCode.Ldelem:  		// aka ldelem.any  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Stelem_i1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int8Ref));  		break;  	case PE.OpCode.Stelem_i2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int16Ref));  		break;  	case PE.OpCode.Stelem_i4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int32Ref));  		break;  	case PE.OpCode.Stelem_i8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int64Ref));  		break;  	case PE.OpCode.Stelem_i:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.IntNativeRef));  		break;  	case PE.OpCode.Stelem_r4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.SingleRef));  		break;  	case PE.OpCode.Stelem_r8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.DoubleRef));  		break;  	case PE.OpCode.Stelem:  		// aka stelem.any  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Readonly:  		if (i >= ctxt.Instructions.Length)  			throw new InvalidOperationException ("invalid instruction");  		instruction = ctxt.Instructions [i++];  		if (instruction.OpCode != PE.OpCode.Ldelema)  			throw new InvalidOperationException ("invalid instruction");  		instructions.Add (new LdElemAddrInstruction (offset' true' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Ldelema:  		instructions.Add (new LdElemAddrInstruction (offset' false' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Ldc_i4_0:  		instructions.Add (new LdInt32Instruction (offset' 0));  		break;  	case PE.OpCode.Ldc_i4_1:  		instructions.Add (new LdInt32Instruction (offset' 1));  		break;  	case PE.OpCode.Ldc_i4_2:  		instructions.Add (new LdInt32Instruction (offset' 2));  		break;  	case PE.OpCode.Ldc_i4_3:  		instructions.Add (new LdInt32Instruction (offset' 3));  		break;  	case PE.OpCode.Ldc_i4_4:  		instructions.Add (new LdInt32Instruction (offset' 4));  		break;  	case PE.OpCode.Ldc_i4_5:  		instructions.Add (new LdInt32Instruction (offset' 5));  		break;  	case PE.OpCode.Ldc_i4_6:  		instructions.Add (new LdInt32Instruction (offset' 6));  		break;  	case PE.OpCode.Ldc_i4_7:  		instructions.Add (new LdInt32Instruction (offset' 7));  		break;  	case PE.OpCode.Ldc_i4_8:  		instructions.Add (new LdInt32Instruction (offset' 8));  		break;  	case PE.OpCode.Ldc_i4_m1:  		instructions.Add (new LdInt32Instruction (offset' -1));  		break;  	case PE.OpCode.Ldc_i4:  	case PE.OpCode.Ldc_i4_s:  		instructions.Add (new LdInt32Instruction (offset' (int)instruction.Value));  		break;  	case PE.OpCode.Ldc_i8:  		instructions.Add (new LdInt64Instruction (offset' (long)instruction.Value));  		break;  	case PE.OpCode.Ldc_r4:  		instructions.Add (new LdSingleInstruction (offset' (float)instruction.Value));  		break;  	case PE.OpCode.Ldc_r8:  		instructions.Add (new LdDoubleInstruction (offset' (double)instruction.Value));  		break;  	case PE.OpCode.Ldstr:  		instructions.Add (new LdStringInstruction (offset' (string)instruction.Value));  		break;  	case PE.OpCode.Add:  		instructions.Add (new ArithInstruction (offset' ArithOp.Add' false' false));  		break;  	case PE.OpCode.Add_ovf:  		instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' false));  		break;  	case PE.OpCode.Add_ovf_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' true));  		break;  	case PE.OpCode.Sub:  		instructions.Add (new ArithInstruction (offset' ArithOp.Sub' false' false));  		break;  	case PE.OpCode.Sub_ovf:  		instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' false));  		break;  	case PE.OpCode.Sub_ovf_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' true));  		break;  	case PE.OpCode.Mul:  		instructions.Add (new ArithInstruction (offset' ArithOp.Mul' false' false));  		break;  	case PE.OpCode.Mul_ovf:  		instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' false));  		break;  	case PE.OpCode.Mul_ovf_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' true));  		break;  	case PE.OpCode.Div:  		instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' false));  		break;  	case PE.OpCode.Div_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' true));  		break;  	case PE.OpCode.Rem:  		instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' false));  		break;  	case PE.OpCode.Rem_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' true));  		break;  	case PE.OpCode.Neg:  		instructions.Add (new ArithInstruction (offset' ArithOp.Neg' false' false));  		break;  	case PE.OpCode.And:  		instructions.Add (new ArithInstruction (offset' ArithOp.BitAnd' false' false));  		break;  	case PE.OpCode.Or:  		instructions.Add (new ArithInstruction (offset' ArithOp.BitOr' false' false));  		break;  	case PE.OpCode.Xor:  		instructions.Add (new ArithInstruction (offset' ArithOp.BitXor' false' false));  		break;  	case PE.OpCode.Not:  		instructions.Add (new ArithInstruction (offset' ArithOp.BitNot' false' false));  		break;  	case PE.OpCode.Shl:  		instructions.Add (new ArithInstruction (offset' ArithOp.Shl' false' false));  		break;  	case PE.OpCode.Shr:  		instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' false));  		break;  	case PE.OpCode.Shr_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' true));  		break;  	case PE.OpCode.Conv_i1:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' false' false));  		break;  	case PE.OpCode.Conv_u1:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' false' false));  		break;  	case PE.OpCode.Conv_i2:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' false' false));  		break;  	case PE.OpCode.Conv_u2:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' false' false));  		break;  	case PE.OpCode.Conv_i4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' false' false));  		break;  	case PE.OpCode.Conv_u4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' false' false));  		break;  	case PE.OpCode.Conv_i8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' false' false));  		break;  	case PE.OpCode.Conv_u8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' false' false));  		break;  	case PE.OpCode.Conv_i:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' false' false));  		break;  	case PE.OpCode.Conv_u:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' false' false));  		break;  	case PE.OpCode.Conv_r4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Single' false' false));  		break;  	case PE.OpCode.Conv_r8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' false));  		break;  	case PE.OpCode.Conv_r_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' true));  		break;  	case PE.OpCode.Conv_ovf_i1:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' false));  		break;  	case PE.OpCode.Conv_ovf_u1:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' false));  		break;  	case PE.OpCode.Conv_ovf_i2:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' false));  		break;  	case PE.OpCode.Conv_ovf_u2:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' false));  		break;  	case PE.OpCode.Conv_ovf_i4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' false));  		break;  	case PE.OpCode.Conv_ovf_u4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' false));  		break;  	case PE.OpCode.Conv_ovf_i8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' false));  		break;  	case PE.OpCode.Conv_ovf_u8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' false));  		break;  	case PE.OpCode.Conv_ovf_i:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' false));  		break;  	case PE.OpCode.Conv_ovf_u:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' false));  		break;  	case PE.OpCode.Conv_ovf_i1_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' true));  		break;  	case PE.OpCode.Conv_ovf_u1_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' true));  		break;  	case PE.OpCode.Conv_ovf_i2_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' true));  		break;  	case PE.OpCode.Conv_ovf_u2_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' true));  		break;  	case PE.OpCode.Conv_ovf_i4_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' true));  		break;  	case PE.OpCode.Conv_ovf_u4_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' true));  		break;  	case PE.OpCode.Conv_ovf_i8_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' true));  		break;  	case PE.OpCode.Conv_ovf_u8_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' true));  		break;  	case PE.OpCode.Conv_ovf_i_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' true));  		break;  	case PE.OpCode.Conv_ovf_u_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' true));  		break;  	default:  		throw new InvalidOperationException ("invalid instruction");  	}  }  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: if (ehcs != null) {  	// A try instruction begins here with given handlers  	var offset = ctxt.Instructions [i].Offset;  	var tryCtxt = new TryTranslationContext (ctxt' i' ehcs);  	var tryBlock = InstructionsFromContext (tryCtxt);  	var handlers = new Seq<TryInstructionHandler> ();  	foreach (var ehc in ehcs) {  		var handlerCtxt = new HandlerTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.HandlerOffset]' ehc);  		var handlerBlock = InstructionsFromContext (handlerCtxt);  		switch (ehc.Flags) {  		case PE.CorILExceptionClause.Exception:  			handlers.Add (new CatchTryInstructionHandler ((TypeRef)ehc.Class' handlerBlock));  			break;  		case PE.CorILExceptionClause.Filter: {  			var filterCtxt = new FilterTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.FilterOffset]' ehc);  			var filterBlock = InstructionsFromContext (filterCtxt);  			handlers.Add (new FilterTryInstructionHandler (filterBlock' handlerBlock));  			break;  		}  		case PE.CorILExceptionClause.Finally:  			handlers.Add (new FinallyTryInstructionHandler (handlerBlock));  			break;  		case PE.CorILExceptionClause.Fault:  			handlers.Add (new FaultTryInstructionHandler (handlerBlock));  			break;  		default:  			throw new ArgumentOutOfRangeException ();  		}  	}  	instructions.Add (new TryInstruction (offset' tryBlock' handlers));  	// Jump over try block  	var nextOffset = ehcs [0].TryOffset + ehcs [0].TryLength;  	if (!ctxt.OffsetToIndex.TryGetValue (nextOffset' out i))  		i = ctxt.Instructions.Length;  }  else {  	var instruction = ctxt.Instructions [i++];  	var offset = instruction.Offset;  	while (instruction.OpCode == PE.OpCode.Unaligned || instruction.OpCode == PE.OpCode.Volatile || instruction.OpCode == PE.OpCode.Tailcall) {  		// Skip over any ignored prefixes' but remember instruction begins at original offset  		// NOTE: What ever happened to the "no." prefix mentioned in the spec?  		if (i >= ctxt.Instructions.Length)  			throw new InvalidOperationException ("invalid instructions");  		instruction = ctxt.Instructions [i++];  	}  	switch (instruction.OpCode) {  	case PE.OpCode.Cpblk:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Cpblk));  		break;  	case PE.OpCode.Initblk:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Initblk));  		break;  	case PE.OpCode.Arglist:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Arglist));  		break;  	case PE.OpCode.Localloc:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Localloc));  		break;  	case PE.OpCode.Jmp:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Jmp));  		break;  	case PE.OpCode.Calli:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Calli));  		break;  	case PE.OpCode.Sizeof:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Sizeof));  		break;  	case PE.OpCode.Mkrefany:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Mkrefany));  		break;  	case PE.OpCode.Refanytype:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanytype));  		break;  	case PE.OpCode.Refanyval:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanyval));  		break;  	case PE.OpCode.Nop:  		instructions.Add (new MiscInstruction (offset' MiscOp.Nop));  		break;  	case PE.OpCode.Break:  		instructions.Add (new MiscInstruction (offset' MiscOp.Break));  		break;  	case PE.OpCode.Dup:  		instructions.Add (new MiscInstruction (offset' MiscOp.Dup));  		break;  	case PE.OpCode.Pop:  		instructions.Add (new MiscInstruction (offset' MiscOp.Pop));  		break;  	case PE.OpCode.Ldnull:  		instructions.Add (new MiscInstruction (offset' MiscOp.Ldnull));  		break;  	case PE.OpCode.Ckfinite:  		instructions.Add (new MiscInstruction (offset' MiscOp.Ckfinite));  		break;  	case PE.OpCode.Throw:  		instructions.Add (new MiscInstruction (offset' MiscOp.Throw));  		break;  	case PE.OpCode.Rethrow:  		instructions.Add (new MiscInstruction (offset' MiscOp.Rethrow));  		break;  	case PE.OpCode.Ldind_ref:  		instructions.Add (new MiscInstruction (offset' MiscOp.LdindRef));  		break;  	case PE.OpCode.Stind_ref:  		instructions.Add (new MiscInstruction (offset' MiscOp.StindRef));  		break;  	case PE.OpCode.Ldelem_ref:  		instructions.Add (new MiscInstruction (offset' MiscOp.LdelemRef));  		break;  	case PE.OpCode.Stelem_ref:  		instructions.Add (new MiscInstruction (offset' MiscOp.StelemRef));  		break;  	case PE.OpCode.Ldlen:  		instructions.Add (new MiscInstruction (offset' MiscOp.Ldlen));  		break;  	case PE.OpCode.Ret:  		if (ctxt.ResultType == null)  			instructions.Add (new MiscInstruction (offset' MiscOp.Ret));  		else  			instructions.Add (new MiscInstruction (offset' MiscOp.RetVal));  		break;  	case PE.OpCode.Endfilter:  		instructions.Add (new MiscInstruction (offset' MiscOp.Endfilter));  		break;  	case PE.OpCode.Endfinally:  		// aka EndFault  		instructions.Add (new MiscInstruction (offset' MiscOp.Endfinally));  		break;  	case PE.OpCode.Br_s:  	case PE.OpCode.Br:  		instructions.Add (new BranchInstruction (offset' BranchOp.Br' false' (int)instruction.Value));  		break;  	case PE.OpCode.Brtrue_s:  	// aka brinst.s  	case PE.OpCode.Brtrue:  		// aka brinst  		instructions.Add (new BranchInstruction (offset' BranchOp.Brtrue' false' (int)instruction.Value));  		break;  	case PE.OpCode.Brfalse_s:  	// aka brzero.s' brnull.s  	case PE.OpCode.Brfalse:  		// aka brzero' brnull  		instructions.Add (new BranchInstruction (offset' BranchOp.Brfalse' false' (int)instruction.Value));  		break;  	case PE.OpCode.Beq:  	case PE.OpCode.Beq_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.Breq' false' (int)instruction.Value));  		break;  	case PE.OpCode.Bne_un:  	case PE.OpCode.Bne_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.Brne' false' (int)instruction.Value));  		break;  	case PE.OpCode.Leave:  	case PE.OpCode.Leave_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.Leave' false' (int)instruction.Value));  		break;  	case PE.OpCode.Blt:  	case PE.OpCode.Blt_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' false' (int)instruction.Value));  		break;  	case PE.OpCode.Blt_un:  	case PE.OpCode.Blt_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' true' (int)instruction.Value));  		break;  	case PE.OpCode.Ble:  	case PE.OpCode.Ble_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' false' (int)instruction.Value));  		break;  	case PE.OpCode.Ble_un:  	case PE.OpCode.Ble_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' true' (int)instruction.Value));  		break;  	case PE.OpCode.Bgt:  	case PE.OpCode.Bgt_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' false' (int)instruction.Value));  		break;  	case PE.OpCode.Bgt_un:  	case PE.OpCode.Bgt_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' true' (int)instruction.Value));  		break;  	case PE.OpCode.Bge:  	case PE.OpCode.Bge_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' false' (int)instruction.Value));  		break;  	case PE.OpCode.Bge_un:  	case PE.OpCode.Bge_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' true' (int)instruction.Value));  		break;  	case PE.OpCode.Switch:  		instructions.Add (new SwitchInstruction (offset' (Seq<int>)instruction.Value));  		break;  	case PE.OpCode.Ceq:  		instructions.Add (new CompareInstruction (offset' CompareOp.Ceq' false));  		break;  	case PE.OpCode.Clt:  		instructions.Add (new CompareInstruction (offset' CompareOp.Clt' false));  		break;  	case PE.OpCode.Clt_un:  		instructions.Add (new CompareInstruction (offset' CompareOp.Clt' true));  		break;  	case PE.OpCode.Cgt:  		instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' false));  		break;  	case PE.OpCode.Cgt_un:  		instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' true));  		break;  	case PE.OpCode.Ldarg_0:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));  		break;  	case PE.OpCode.Ldarg_1:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));  		break;  	case PE.OpCode.Ldarg_2:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));  		break;  	case PE.OpCode.Ldarg_3:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));  		break;  	case PE.OpCode.Ldarg:  	case PE.OpCode.Ldarg_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));  		break;  	case PE.OpCode.Ldarga:  	case PE.OpCode.Ldarga_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));  		break;  	case PE.OpCode.Starg:  	case PE.OpCode.Starg_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));  		break;  	case PE.OpCode.Ldloc_0:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 0));  		break;  	case PE.OpCode.Ldloc_1:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 1));  		break;  	case PE.OpCode.Ldloc_2:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 2));  		break;  	case PE.OpCode.Ldloc_3:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 3));  		break;  	case PE.OpCode.Ldloc:  	case PE.OpCode.Ldloc_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));  		break;  	case PE.OpCode.Ldloca:  	case PE.OpCode.Ldloca_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));  		break;  	case PE.OpCode.Stloc_0:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 0));  		break;  	case PE.OpCode.Stloc_1:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 1));  		break;  	case PE.OpCode.Stloc_2:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 2));  		break;  	case PE.OpCode.Stloc_3:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 3));  		break;  	case PE.OpCode.Stloc:  	case PE.OpCode.Stloc_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));  		break;  	case PE.OpCode.Ldfld:  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));  		break;  	case PE.OpCode.Ldsfld:  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));  		break;  	case PE.OpCode.Ldflda:  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));  		break;  	case PE.OpCode.Ldsflda:  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));  		break;  	case PE.OpCode.Stfld:  		instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));  		break;  	case PE.OpCode.Stsfld:  		instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));  		break;  	case PE.OpCode.Ldtoken: {  		if (instruction.Value is FieldRef)  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));  		else if (instruction.Value is MethodRef)  			instructions.Add (new MethodInstruction (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));  		else if (instruction.Value is TypeRef)  			// NOTE: May be a higher-kinded type  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));  		else  			throw new InvalidOperationException ("unexpected ldtoken instruction value");  		break;  	}  	case PE.OpCode.Constrained: {  		var constrained = (TypeRef)instruction.Value;  		if (i >= ctxt.Instructions.Length)  			throw new InvalidOperationException ("invalid instructions");  		instruction = ctxt.Instructions [i++];  		if (instruction.OpCode != PE.OpCode.Callvirt)  			throw new InvalidOperationException ("invalid instruction");  		instructions.Add (new MethodInstruction (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));  		break;  	}  	case PE.OpCode.Call:  		instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Callvirt:  		instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Ldftn:  		instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Ldvirtftn:  		instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Newobj:  		instructions.Add (new MethodInstruction (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Ldind_i1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int8Ref));  		break;  	case PE.OpCode.Ldind_u1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt8Ref));  		break;  	case PE.OpCode.Ldind_i2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int16Ref));  		break;  	case PE.OpCode.Ldind_u2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt16Ref));  		break;  	case PE.OpCode.Ldind_i4:  	case PE.OpCode.Ldind_u4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int32Ref));  		break;  	case PE.OpCode.Ldind_i8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int64Ref));  		break;  	case PE.OpCode.Ldind_i:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.IntNativeRef));  		break;  	case PE.OpCode.Ldind_r4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.SingleRef));  		break;  	case PE.OpCode.Ldind_r8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.DoubleRef));  		break;  	case PE.OpCode.Ldobj:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Stind_i1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int8Ref));  		break;  	case PE.OpCode.Stind_i2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int16Ref));  		break;  	case PE.OpCode.Stind_i4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int32Ref));  		break;  	case PE.OpCode.Stind_i8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int64Ref));  		break;  	case PE.OpCode.Stind_i:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.IntNativeRef));  		break;  	case PE.OpCode.Stind_r4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.SingleRef));  		break;  	case PE.OpCode.Stind_r8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.DoubleRef));  		break;  	case PE.OpCode.Stobj:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Cpobj:  		instructions.Add (new TypeInstruction (offset' TypeOp.Cpobj' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Newarr:  		instructions.Add (new TypeInstruction (offset' TypeOp.Newarr' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Initobj:  		instructions.Add (new TypeInstruction (offset' TypeOp.Initobj' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Castclass:  		instructions.Add (new TypeInstruction (offset' TypeOp.Castclass' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Isinst:  		instructions.Add (new TypeInstruction (offset' TypeOp.Isinst' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Box:  		instructions.Add (new TypeInstruction (offset' TypeOp.Box' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Unbox:  		instructions.Add (new TypeInstruction (offset' TypeOp.Unbox' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Unbox_any:  		instructions.Add (new TypeInstruction (offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Ldelem_i1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int8Ref));  		break;  	case PE.OpCode.Ldelem_u1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt8Ref));  		break;  	case PE.OpCode.Ldelem_i2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int16Ref));  		break;  	case PE.OpCode.Ldelem_u2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt16Ref));  		break;  	case PE.OpCode.Ldelem_i4:  	case PE.OpCode.Ldelem_u4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int32Ref));  		break;  	case PE.OpCode.Ldelem_i:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.IntNativeRef));  		break;  	case PE.OpCode.Ldelem_i8:  		// aka ldelem.u8  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int64Ref));  		break;  	case PE.OpCode.Ldelem_r4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.SingleRef));  		break;  	case PE.OpCode.Ldelem_r8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.DoubleRef));  		break;  	case PE.OpCode.Ldelem:  		// aka ldelem.any  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Stelem_i1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int8Ref));  		break;  	case PE.OpCode.Stelem_i2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int16Ref));  		break;  	case PE.OpCode.Stelem_i4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int32Ref));  		break;  	case PE.OpCode.Stelem_i8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int64Ref));  		break;  	case PE.OpCode.Stelem_i:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.IntNativeRef));  		break;  	case PE.OpCode.Stelem_r4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.SingleRef));  		break;  	case PE.OpCode.Stelem_r8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.DoubleRef));  		break;  	case PE.OpCode.Stelem:  		// aka stelem.any  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Readonly:  		if (i >= ctxt.Instructions.Length)  			throw new InvalidOperationException ("invalid instruction");  		instruction = ctxt.Instructions [i++];  		if (instruction.OpCode != PE.OpCode.Ldelema)  			throw new InvalidOperationException ("invalid instruction");  		instructions.Add (new LdElemAddrInstruction (offset' true' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Ldelema:  		instructions.Add (new LdElemAddrInstruction (offset' false' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Ldc_i4_0:  		instructions.Add (new LdInt32Instruction (offset' 0));  		break;  	case PE.OpCode.Ldc_i4_1:  		instructions.Add (new LdInt32Instruction (offset' 1));  		break;  	case PE.OpCode.Ldc_i4_2:  		instructions.Add (new LdInt32Instruction (offset' 2));  		break;  	case PE.OpCode.Ldc_i4_3:  		instructions.Add (new LdInt32Instruction (offset' 3));  		break;  	case PE.OpCode.Ldc_i4_4:  		instructions.Add (new LdInt32Instruction (offset' 4));  		break;  	case PE.OpCode.Ldc_i4_5:  		instructions.Add (new LdInt32Instruction (offset' 5));  		break;  	case PE.OpCode.Ldc_i4_6:  		instructions.Add (new LdInt32Instruction (offset' 6));  		break;  	case PE.OpCode.Ldc_i4_7:  		instructions.Add (new LdInt32Instruction (offset' 7));  		break;  	case PE.OpCode.Ldc_i4_8:  		instructions.Add (new LdInt32Instruction (offset' 8));  		break;  	case PE.OpCode.Ldc_i4_m1:  		instructions.Add (new LdInt32Instruction (offset' -1));  		break;  	case PE.OpCode.Ldc_i4:  	case PE.OpCode.Ldc_i4_s:  		instructions.Add (new LdInt32Instruction (offset' (int)instruction.Value));  		break;  	case PE.OpCode.Ldc_i8:  		instructions.Add (new LdInt64Instruction (offset' (long)instruction.Value));  		break;  	case PE.OpCode.Ldc_r4:  		instructions.Add (new LdSingleInstruction (offset' (float)instruction.Value));  		break;  	case PE.OpCode.Ldc_r8:  		instructions.Add (new LdDoubleInstruction (offset' (double)instruction.Value));  		break;  	case PE.OpCode.Ldstr:  		instructions.Add (new LdStringInstruction (offset' (string)instruction.Value));  		break;  	case PE.OpCode.Add:  		instructions.Add (new ArithInstruction (offset' ArithOp.Add' false' false));  		break;  	case PE.OpCode.Add_ovf:  		instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' false));  		break;  	case PE.OpCode.Add_ovf_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' true));  		break;  	case PE.OpCode.Sub:  		instructions.Add (new ArithInstruction (offset' ArithOp.Sub' false' false));  		break;  	case PE.OpCode.Sub_ovf:  		instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' false));  		break;  	case PE.OpCode.Sub_ovf_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' true));  		break;  	case PE.OpCode.Mul:  		instructions.Add (new ArithInstruction (offset' ArithOp.Mul' false' false));  		break;  	case PE.OpCode.Mul_ovf:  		instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' false));  		break;  	case PE.OpCode.Mul_ovf_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' true));  		break;  	case PE.OpCode.Div:  		instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' false));  		break;  	case PE.OpCode.Div_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' true));  		break;  	case PE.OpCode.Rem:  		instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' false));  		break;  	case PE.OpCode.Rem_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' true));  		break;  	case PE.OpCode.Neg:  		instructions.Add (new ArithInstruction (offset' ArithOp.Neg' false' false));  		break;  	case PE.OpCode.And:  		instructions.Add (new ArithInstruction (offset' ArithOp.BitAnd' false' false));  		break;  	case PE.OpCode.Or:  		instructions.Add (new ArithInstruction (offset' ArithOp.BitOr' false' false));  		break;  	case PE.OpCode.Xor:  		instructions.Add (new ArithInstruction (offset' ArithOp.BitXor' false' false));  		break;  	case PE.OpCode.Not:  		instructions.Add (new ArithInstruction (offset' ArithOp.BitNot' false' false));  		break;  	case PE.OpCode.Shl:  		instructions.Add (new ArithInstruction (offset' ArithOp.Shl' false' false));  		break;  	case PE.OpCode.Shr:  		instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' false));  		break;  	case PE.OpCode.Shr_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' true));  		break;  	case PE.OpCode.Conv_i1:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' false' false));  		break;  	case PE.OpCode.Conv_u1:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' false' false));  		break;  	case PE.OpCode.Conv_i2:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' false' false));  		break;  	case PE.OpCode.Conv_u2:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' false' false));  		break;  	case PE.OpCode.Conv_i4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' false' false));  		break;  	case PE.OpCode.Conv_u4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' false' false));  		break;  	case PE.OpCode.Conv_i8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' false' false));  		break;  	case PE.OpCode.Conv_u8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' false' false));  		break;  	case PE.OpCode.Conv_i:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' false' false));  		break;  	case PE.OpCode.Conv_u:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' false' false));  		break;  	case PE.OpCode.Conv_r4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Single' false' false));  		break;  	case PE.OpCode.Conv_r8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' false));  		break;  	case PE.OpCode.Conv_r_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' true));  		break;  	case PE.OpCode.Conv_ovf_i1:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' false));  		break;  	case PE.OpCode.Conv_ovf_u1:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' false));  		break;  	case PE.OpCode.Conv_ovf_i2:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' false));  		break;  	case PE.OpCode.Conv_ovf_u2:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' false));  		break;  	case PE.OpCode.Conv_ovf_i4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' false));  		break;  	case PE.OpCode.Conv_ovf_u4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' false));  		break;  	case PE.OpCode.Conv_ovf_i8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' false));  		break;  	case PE.OpCode.Conv_ovf_u8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' false));  		break;  	case PE.OpCode.Conv_ovf_i:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' false));  		break;  	case PE.OpCode.Conv_ovf_u:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' false));  		break;  	case PE.OpCode.Conv_ovf_i1_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' true));  		break;  	case PE.OpCode.Conv_ovf_u1_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' true));  		break;  	case PE.OpCode.Conv_ovf_i2_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' true));  		break;  	case PE.OpCode.Conv_ovf_u2_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' true));  		break;  	case PE.OpCode.Conv_ovf_i4_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' true));  		break;  	case PE.OpCode.Conv_ovf_u4_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' true));  		break;  	case PE.OpCode.Conv_ovf_i8_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' true));  		break;  	case PE.OpCode.Conv_ovf_u8_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' true));  		break;  	case PE.OpCode.Conv_ovf_i_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' true));  		break;  	case PE.OpCode.Conv_ovf_u_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' true));  		break;  	default:  		throw new InvalidOperationException ("invalid instruction");  	}  }  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: if (ehcs != null) {  	// A try instruction begins here with given handlers  	var offset = ctxt.Instructions [i].Offset;  	var tryCtxt = new TryTranslationContext (ctxt' i' ehcs);  	var tryBlock = InstructionsFromContext (tryCtxt);  	var handlers = new Seq<TryInstructionHandler> ();  	foreach (var ehc in ehcs) {  		var handlerCtxt = new HandlerTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.HandlerOffset]' ehc);  		var handlerBlock = InstructionsFromContext (handlerCtxt);  		switch (ehc.Flags) {  		case PE.CorILExceptionClause.Exception:  			handlers.Add (new CatchTryInstructionHandler ((TypeRef)ehc.Class' handlerBlock));  			break;  		case PE.CorILExceptionClause.Filter: {  			var filterCtxt = new FilterTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.FilterOffset]' ehc);  			var filterBlock = InstructionsFromContext (filterCtxt);  			handlers.Add (new FilterTryInstructionHandler (filterBlock' handlerBlock));  			break;  		}  		case PE.CorILExceptionClause.Finally:  			handlers.Add (new FinallyTryInstructionHandler (handlerBlock));  			break;  		case PE.CorILExceptionClause.Fault:  			handlers.Add (new FaultTryInstructionHandler (handlerBlock));  			break;  		default:  			throw new ArgumentOutOfRangeException ();  		}  	}  	instructions.Add (new TryInstruction (offset' tryBlock' handlers));  	// Jump over try block  	var nextOffset = ehcs [0].TryOffset + ehcs [0].TryLength;  	if (!ctxt.OffsetToIndex.TryGetValue (nextOffset' out i))  		i = ctxt.Instructions.Length;  }  else {  	var instruction = ctxt.Instructions [i++];  	var offset = instruction.Offset;  	while (instruction.OpCode == PE.OpCode.Unaligned || instruction.OpCode == PE.OpCode.Volatile || instruction.OpCode == PE.OpCode.Tailcall) {  		// Skip over any ignored prefixes' but remember instruction begins at original offset  		// NOTE: What ever happened to the "no." prefix mentioned in the spec?  		if (i >= ctxt.Instructions.Length)  			throw new InvalidOperationException ("invalid instructions");  		instruction = ctxt.Instructions [i++];  	}  	switch (instruction.OpCode) {  	case PE.OpCode.Cpblk:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Cpblk));  		break;  	case PE.OpCode.Initblk:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Initblk));  		break;  	case PE.OpCode.Arglist:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Arglist));  		break;  	case PE.OpCode.Localloc:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Localloc));  		break;  	case PE.OpCode.Jmp:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Jmp));  		break;  	case PE.OpCode.Calli:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Calli));  		break;  	case PE.OpCode.Sizeof:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Sizeof));  		break;  	case PE.OpCode.Mkrefany:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Mkrefany));  		break;  	case PE.OpCode.Refanytype:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanytype));  		break;  	case PE.OpCode.Refanyval:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanyval));  		break;  	case PE.OpCode.Nop:  		instructions.Add (new MiscInstruction (offset' MiscOp.Nop));  		break;  	case PE.OpCode.Break:  		instructions.Add (new MiscInstruction (offset' MiscOp.Break));  		break;  	case PE.OpCode.Dup:  		instructions.Add (new MiscInstruction (offset' MiscOp.Dup));  		break;  	case PE.OpCode.Pop:  		instructions.Add (new MiscInstruction (offset' MiscOp.Pop));  		break;  	case PE.OpCode.Ldnull:  		instructions.Add (new MiscInstruction (offset' MiscOp.Ldnull));  		break;  	case PE.OpCode.Ckfinite:  		instructions.Add (new MiscInstruction (offset' MiscOp.Ckfinite));  		break;  	case PE.OpCode.Throw:  		instructions.Add (new MiscInstruction (offset' MiscOp.Throw));  		break;  	case PE.OpCode.Rethrow:  		instructions.Add (new MiscInstruction (offset' MiscOp.Rethrow));  		break;  	case PE.OpCode.Ldind_ref:  		instructions.Add (new MiscInstruction (offset' MiscOp.LdindRef));  		break;  	case PE.OpCode.Stind_ref:  		instructions.Add (new MiscInstruction (offset' MiscOp.StindRef));  		break;  	case PE.OpCode.Ldelem_ref:  		instructions.Add (new MiscInstruction (offset' MiscOp.LdelemRef));  		break;  	case PE.OpCode.Stelem_ref:  		instructions.Add (new MiscInstruction (offset' MiscOp.StelemRef));  		break;  	case PE.OpCode.Ldlen:  		instructions.Add (new MiscInstruction (offset' MiscOp.Ldlen));  		break;  	case PE.OpCode.Ret:  		if (ctxt.ResultType == null)  			instructions.Add (new MiscInstruction (offset' MiscOp.Ret));  		else  			instructions.Add (new MiscInstruction (offset' MiscOp.RetVal));  		break;  	case PE.OpCode.Endfilter:  		instructions.Add (new MiscInstruction (offset' MiscOp.Endfilter));  		break;  	case PE.OpCode.Endfinally:  		// aka EndFault  		instructions.Add (new MiscInstruction (offset' MiscOp.Endfinally));  		break;  	case PE.OpCode.Br_s:  	case PE.OpCode.Br:  		instructions.Add (new BranchInstruction (offset' BranchOp.Br' false' (int)instruction.Value));  		break;  	case PE.OpCode.Brtrue_s:  	// aka brinst.s  	case PE.OpCode.Brtrue:  		// aka brinst  		instructions.Add (new BranchInstruction (offset' BranchOp.Brtrue' false' (int)instruction.Value));  		break;  	case PE.OpCode.Brfalse_s:  	// aka brzero.s' brnull.s  	case PE.OpCode.Brfalse:  		// aka brzero' brnull  		instructions.Add (new BranchInstruction (offset' BranchOp.Brfalse' false' (int)instruction.Value));  		break;  	case PE.OpCode.Beq:  	case PE.OpCode.Beq_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.Breq' false' (int)instruction.Value));  		break;  	case PE.OpCode.Bne_un:  	case PE.OpCode.Bne_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.Brne' false' (int)instruction.Value));  		break;  	case PE.OpCode.Leave:  	case PE.OpCode.Leave_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.Leave' false' (int)instruction.Value));  		break;  	case PE.OpCode.Blt:  	case PE.OpCode.Blt_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' false' (int)instruction.Value));  		break;  	case PE.OpCode.Blt_un:  	case PE.OpCode.Blt_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' true' (int)instruction.Value));  		break;  	case PE.OpCode.Ble:  	case PE.OpCode.Ble_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' false' (int)instruction.Value));  		break;  	case PE.OpCode.Ble_un:  	case PE.OpCode.Ble_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' true' (int)instruction.Value));  		break;  	case PE.OpCode.Bgt:  	case PE.OpCode.Bgt_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' false' (int)instruction.Value));  		break;  	case PE.OpCode.Bgt_un:  	case PE.OpCode.Bgt_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' true' (int)instruction.Value));  		break;  	case PE.OpCode.Bge:  	case PE.OpCode.Bge_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' false' (int)instruction.Value));  		break;  	case PE.OpCode.Bge_un:  	case PE.OpCode.Bge_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' true' (int)instruction.Value));  		break;  	case PE.OpCode.Switch:  		instructions.Add (new SwitchInstruction (offset' (Seq<int>)instruction.Value));  		break;  	case PE.OpCode.Ceq:  		instructions.Add (new CompareInstruction (offset' CompareOp.Ceq' false));  		break;  	case PE.OpCode.Clt:  		instructions.Add (new CompareInstruction (offset' CompareOp.Clt' false));  		break;  	case PE.OpCode.Clt_un:  		instructions.Add (new CompareInstruction (offset' CompareOp.Clt' true));  		break;  	case PE.OpCode.Cgt:  		instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' false));  		break;  	case PE.OpCode.Cgt_un:  		instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' true));  		break;  	case PE.OpCode.Ldarg_0:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));  		break;  	case PE.OpCode.Ldarg_1:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));  		break;  	case PE.OpCode.Ldarg_2:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));  		break;  	case PE.OpCode.Ldarg_3:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));  		break;  	case PE.OpCode.Ldarg:  	case PE.OpCode.Ldarg_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));  		break;  	case PE.OpCode.Ldarga:  	case PE.OpCode.Ldarga_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));  		break;  	case PE.OpCode.Starg:  	case PE.OpCode.Starg_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));  		break;  	case PE.OpCode.Ldloc_0:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 0));  		break;  	case PE.OpCode.Ldloc_1:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 1));  		break;  	case PE.OpCode.Ldloc_2:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 2));  		break;  	case PE.OpCode.Ldloc_3:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 3));  		break;  	case PE.OpCode.Ldloc:  	case PE.OpCode.Ldloc_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));  		break;  	case PE.OpCode.Ldloca:  	case PE.OpCode.Ldloca_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));  		break;  	case PE.OpCode.Stloc_0:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 0));  		break;  	case PE.OpCode.Stloc_1:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 1));  		break;  	case PE.OpCode.Stloc_2:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 2));  		break;  	case PE.OpCode.Stloc_3:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 3));  		break;  	case PE.OpCode.Stloc:  	case PE.OpCode.Stloc_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));  		break;  	case PE.OpCode.Ldfld:  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));  		break;  	case PE.OpCode.Ldsfld:  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));  		break;  	case PE.OpCode.Ldflda:  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));  		break;  	case PE.OpCode.Ldsflda:  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));  		break;  	case PE.OpCode.Stfld:  		instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));  		break;  	case PE.OpCode.Stsfld:  		instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));  		break;  	case PE.OpCode.Ldtoken: {  		if (instruction.Value is FieldRef)  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));  		else if (instruction.Value is MethodRef)  			instructions.Add (new MethodInstruction (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));  		else if (instruction.Value is TypeRef)  			// NOTE: May be a higher-kinded type  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));  		else  			throw new InvalidOperationException ("unexpected ldtoken instruction value");  		break;  	}  	case PE.OpCode.Constrained: {  		var constrained = (TypeRef)instruction.Value;  		if (i >= ctxt.Instructions.Length)  			throw new InvalidOperationException ("invalid instructions");  		instruction = ctxt.Instructions [i++];  		if (instruction.OpCode != PE.OpCode.Callvirt)  			throw new InvalidOperationException ("invalid instruction");  		instructions.Add (new MethodInstruction (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));  		break;  	}  	case PE.OpCode.Call:  		instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Callvirt:  		instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Ldftn:  		instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Ldvirtftn:  		instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Newobj:  		instructions.Add (new MethodInstruction (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Ldind_i1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int8Ref));  		break;  	case PE.OpCode.Ldind_u1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt8Ref));  		break;  	case PE.OpCode.Ldind_i2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int16Ref));  		break;  	case PE.OpCode.Ldind_u2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt16Ref));  		break;  	case PE.OpCode.Ldind_i4:  	case PE.OpCode.Ldind_u4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int32Ref));  		break;  	case PE.OpCode.Ldind_i8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int64Ref));  		break;  	case PE.OpCode.Ldind_i:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.IntNativeRef));  		break;  	case PE.OpCode.Ldind_r4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.SingleRef));  		break;  	case PE.OpCode.Ldind_r8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.DoubleRef));  		break;  	case PE.OpCode.Ldobj:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Stind_i1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int8Ref));  		break;  	case PE.OpCode.Stind_i2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int16Ref));  		break;  	case PE.OpCode.Stind_i4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int32Ref));  		break;  	case PE.OpCode.Stind_i8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int64Ref));  		break;  	case PE.OpCode.Stind_i:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.IntNativeRef));  		break;  	case PE.OpCode.Stind_r4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.SingleRef));  		break;  	case PE.OpCode.Stind_r8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.DoubleRef));  		break;  	case PE.OpCode.Stobj:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Cpobj:  		instructions.Add (new TypeInstruction (offset' TypeOp.Cpobj' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Newarr:  		instructions.Add (new TypeInstruction (offset' TypeOp.Newarr' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Initobj:  		instructions.Add (new TypeInstruction (offset' TypeOp.Initobj' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Castclass:  		instructions.Add (new TypeInstruction (offset' TypeOp.Castclass' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Isinst:  		instructions.Add (new TypeInstruction (offset' TypeOp.Isinst' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Box:  		instructions.Add (new TypeInstruction (offset' TypeOp.Box' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Unbox:  		instructions.Add (new TypeInstruction (offset' TypeOp.Unbox' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Unbox_any:  		instructions.Add (new TypeInstruction (offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Ldelem_i1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int8Ref));  		break;  	case PE.OpCode.Ldelem_u1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt8Ref));  		break;  	case PE.OpCode.Ldelem_i2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int16Ref));  		break;  	case PE.OpCode.Ldelem_u2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt16Ref));  		break;  	case PE.OpCode.Ldelem_i4:  	case PE.OpCode.Ldelem_u4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int32Ref));  		break;  	case PE.OpCode.Ldelem_i:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.IntNativeRef));  		break;  	case PE.OpCode.Ldelem_i8:  		// aka ldelem.u8  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int64Ref));  		break;  	case PE.OpCode.Ldelem_r4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.SingleRef));  		break;  	case PE.OpCode.Ldelem_r8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.DoubleRef));  		break;  	case PE.OpCode.Ldelem:  		// aka ldelem.any  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Stelem_i1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int8Ref));  		break;  	case PE.OpCode.Stelem_i2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int16Ref));  		break;  	case PE.OpCode.Stelem_i4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int32Ref));  		break;  	case PE.OpCode.Stelem_i8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int64Ref));  		break;  	case PE.OpCode.Stelem_i:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.IntNativeRef));  		break;  	case PE.OpCode.Stelem_r4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.SingleRef));  		break;  	case PE.OpCode.Stelem_r8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.DoubleRef));  		break;  	case PE.OpCode.Stelem:  		// aka stelem.any  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Readonly:  		if (i >= ctxt.Instructions.Length)  			throw new InvalidOperationException ("invalid instruction");  		instruction = ctxt.Instructions [i++];  		if (instruction.OpCode != PE.OpCode.Ldelema)  			throw new InvalidOperationException ("invalid instruction");  		instructions.Add (new LdElemAddrInstruction (offset' true' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Ldelema:  		instructions.Add (new LdElemAddrInstruction (offset' false' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Ldc_i4_0:  		instructions.Add (new LdInt32Instruction (offset' 0));  		break;  	case PE.OpCode.Ldc_i4_1:  		instructions.Add (new LdInt32Instruction (offset' 1));  		break;  	case PE.OpCode.Ldc_i4_2:  		instructions.Add (new LdInt32Instruction (offset' 2));  		break;  	case PE.OpCode.Ldc_i4_3:  		instructions.Add (new LdInt32Instruction (offset' 3));  		break;  	case PE.OpCode.Ldc_i4_4:  		instructions.Add (new LdInt32Instruction (offset' 4));  		break;  	case PE.OpCode.Ldc_i4_5:  		instructions.Add (new LdInt32Instruction (offset' 5));  		break;  	case PE.OpCode.Ldc_i4_6:  		instructions.Add (new LdInt32Instruction (offset' 6));  		break;  	case PE.OpCode.Ldc_i4_7:  		instructions.Add (new LdInt32Instruction (offset' 7));  		break;  	case PE.OpCode.Ldc_i4_8:  		instructions.Add (new LdInt32Instruction (offset' 8));  		break;  	case PE.OpCode.Ldc_i4_m1:  		instructions.Add (new LdInt32Instruction (offset' -1));  		break;  	case PE.OpCode.Ldc_i4:  	case PE.OpCode.Ldc_i4_s:  		instructions.Add (new LdInt32Instruction (offset' (int)instruction.Value));  		break;  	case PE.OpCode.Ldc_i8:  		instructions.Add (new LdInt64Instruction (offset' (long)instruction.Value));  		break;  	case PE.OpCode.Ldc_r4:  		instructions.Add (new LdSingleInstruction (offset' (float)instruction.Value));  		break;  	case PE.OpCode.Ldc_r8:  		instructions.Add (new LdDoubleInstruction (offset' (double)instruction.Value));  		break;  	case PE.OpCode.Ldstr:  		instructions.Add (new LdStringInstruction (offset' (string)instruction.Value));  		break;  	case PE.OpCode.Add:  		instructions.Add (new ArithInstruction (offset' ArithOp.Add' false' false));  		break;  	case PE.OpCode.Add_ovf:  		instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' false));  		break;  	case PE.OpCode.Add_ovf_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' true));  		break;  	case PE.OpCode.Sub:  		instructions.Add (new ArithInstruction (offset' ArithOp.Sub' false' false));  		break;  	case PE.OpCode.Sub_ovf:  		instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' false));  		break;  	case PE.OpCode.Sub_ovf_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' true));  		break;  	case PE.OpCode.Mul:  		instructions.Add (new ArithInstruction (offset' ArithOp.Mul' false' false));  		break;  	case PE.OpCode.Mul_ovf:  		instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' false));  		break;  	case PE.OpCode.Mul_ovf_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' true));  		break;  	case PE.OpCode.Div:  		instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' false));  		break;  	case PE.OpCode.Div_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' true));  		break;  	case PE.OpCode.Rem:  		instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' false));  		break;  	case PE.OpCode.Rem_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' true));  		break;  	case PE.OpCode.Neg:  		instructions.Add (new ArithInstruction (offset' ArithOp.Neg' false' false));  		break;  	case PE.OpCode.And:  		instructions.Add (new ArithInstruction (offset' ArithOp.BitAnd' false' false));  		break;  	case PE.OpCode.Or:  		instructions.Add (new ArithInstruction (offset' ArithOp.BitOr' false' false));  		break;  	case PE.OpCode.Xor:  		instructions.Add (new ArithInstruction (offset' ArithOp.BitXor' false' false));  		break;  	case PE.OpCode.Not:  		instructions.Add (new ArithInstruction (offset' ArithOp.BitNot' false' false));  		break;  	case PE.OpCode.Shl:  		instructions.Add (new ArithInstruction (offset' ArithOp.Shl' false' false));  		break;  	case PE.OpCode.Shr:  		instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' false));  		break;  	case PE.OpCode.Shr_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' true));  		break;  	case PE.OpCode.Conv_i1:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' false' false));  		break;  	case PE.OpCode.Conv_u1:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' false' false));  		break;  	case PE.OpCode.Conv_i2:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' false' false));  		break;  	case PE.OpCode.Conv_u2:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' false' false));  		break;  	case PE.OpCode.Conv_i4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' false' false));  		break;  	case PE.OpCode.Conv_u4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' false' false));  		break;  	case PE.OpCode.Conv_i8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' false' false));  		break;  	case PE.OpCode.Conv_u8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' false' false));  		break;  	case PE.OpCode.Conv_i:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' false' false));  		break;  	case PE.OpCode.Conv_u:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' false' false));  		break;  	case PE.OpCode.Conv_r4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Single' false' false));  		break;  	case PE.OpCode.Conv_r8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' false));  		break;  	case PE.OpCode.Conv_r_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' true));  		break;  	case PE.OpCode.Conv_ovf_i1:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' false));  		break;  	case PE.OpCode.Conv_ovf_u1:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' false));  		break;  	case PE.OpCode.Conv_ovf_i2:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' false));  		break;  	case PE.OpCode.Conv_ovf_u2:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' false));  		break;  	case PE.OpCode.Conv_ovf_i4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' false));  		break;  	case PE.OpCode.Conv_ovf_u4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' false));  		break;  	case PE.OpCode.Conv_ovf_i8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' false));  		break;  	case PE.OpCode.Conv_ovf_u8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' false));  		break;  	case PE.OpCode.Conv_ovf_i:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' false));  		break;  	case PE.OpCode.Conv_ovf_u:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' false));  		break;  	case PE.OpCode.Conv_ovf_i1_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' true));  		break;  	case PE.OpCode.Conv_ovf_u1_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' true));  		break;  	case PE.OpCode.Conv_ovf_i2_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' true));  		break;  	case PE.OpCode.Conv_ovf_u2_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' true));  		break;  	case PE.OpCode.Conv_ovf_i4_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' true));  		break;  	case PE.OpCode.Conv_ovf_u4_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' true));  		break;  	case PE.OpCode.Conv_ovf_i8_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' true));  		break;  	case PE.OpCode.Conv_ovf_u8_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' true));  		break;  	case PE.OpCode.Conv_ovf_i_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' true));  		break;  	case PE.OpCode.Conv_ovf_u_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' true));  		break;  	default:  		throw new InvalidOperationException ("invalid instruction");  	}  }  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: if (ehcs != null) {  	// A try instruction begins here with given handlers  	var offset = ctxt.Instructions [i].Offset;  	var tryCtxt = new TryTranslationContext (ctxt' i' ehcs);  	var tryBlock = InstructionsFromContext (tryCtxt);  	var handlers = new Seq<TryInstructionHandler> ();  	foreach (var ehc in ehcs) {  		var handlerCtxt = new HandlerTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.HandlerOffset]' ehc);  		var handlerBlock = InstructionsFromContext (handlerCtxt);  		switch (ehc.Flags) {  		case PE.CorILExceptionClause.Exception:  			handlers.Add (new CatchTryInstructionHandler ((TypeRef)ehc.Class' handlerBlock));  			break;  		case PE.CorILExceptionClause.Filter: {  			var filterCtxt = new FilterTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.FilterOffset]' ehc);  			var filterBlock = InstructionsFromContext (filterCtxt);  			handlers.Add (new FilterTryInstructionHandler (filterBlock' handlerBlock));  			break;  		}  		case PE.CorILExceptionClause.Finally:  			handlers.Add (new FinallyTryInstructionHandler (handlerBlock));  			break;  		case PE.CorILExceptionClause.Fault:  			handlers.Add (new FaultTryInstructionHandler (handlerBlock));  			break;  		default:  			throw new ArgumentOutOfRangeException ();  		}  	}  	instructions.Add (new TryInstruction (offset' tryBlock' handlers));  	// Jump over try block  	var nextOffset = ehcs [0].TryOffset + ehcs [0].TryLength;  	if (!ctxt.OffsetToIndex.TryGetValue (nextOffset' out i))  		i = ctxt.Instructions.Length;  }  else {  	var instruction = ctxt.Instructions [i++];  	var offset = instruction.Offset;  	while (instruction.OpCode == PE.OpCode.Unaligned || instruction.OpCode == PE.OpCode.Volatile || instruction.OpCode == PE.OpCode.Tailcall) {  		// Skip over any ignored prefixes' but remember instruction begins at original offset  		// NOTE: What ever happened to the "no." prefix mentioned in the spec?  		if (i >= ctxt.Instructions.Length)  			throw new InvalidOperationException ("invalid instructions");  		instruction = ctxt.Instructions [i++];  	}  	switch (instruction.OpCode) {  	case PE.OpCode.Cpblk:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Cpblk));  		break;  	case PE.OpCode.Initblk:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Initblk));  		break;  	case PE.OpCode.Arglist:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Arglist));  		break;  	case PE.OpCode.Localloc:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Localloc));  		break;  	case PE.OpCode.Jmp:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Jmp));  		break;  	case PE.OpCode.Calli:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Calli));  		break;  	case PE.OpCode.Sizeof:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Sizeof));  		break;  	case PE.OpCode.Mkrefany:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Mkrefany));  		break;  	case PE.OpCode.Refanytype:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanytype));  		break;  	case PE.OpCode.Refanyval:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanyval));  		break;  	case PE.OpCode.Nop:  		instructions.Add (new MiscInstruction (offset' MiscOp.Nop));  		break;  	case PE.OpCode.Break:  		instructions.Add (new MiscInstruction (offset' MiscOp.Break));  		break;  	case PE.OpCode.Dup:  		instructions.Add (new MiscInstruction (offset' MiscOp.Dup));  		break;  	case PE.OpCode.Pop:  		instructions.Add (new MiscInstruction (offset' MiscOp.Pop));  		break;  	case PE.OpCode.Ldnull:  		instructions.Add (new MiscInstruction (offset' MiscOp.Ldnull));  		break;  	case PE.OpCode.Ckfinite:  		instructions.Add (new MiscInstruction (offset' MiscOp.Ckfinite));  		break;  	case PE.OpCode.Throw:  		instructions.Add (new MiscInstruction (offset' MiscOp.Throw));  		break;  	case PE.OpCode.Rethrow:  		instructions.Add (new MiscInstruction (offset' MiscOp.Rethrow));  		break;  	case PE.OpCode.Ldind_ref:  		instructions.Add (new MiscInstruction (offset' MiscOp.LdindRef));  		break;  	case PE.OpCode.Stind_ref:  		instructions.Add (new MiscInstruction (offset' MiscOp.StindRef));  		break;  	case PE.OpCode.Ldelem_ref:  		instructions.Add (new MiscInstruction (offset' MiscOp.LdelemRef));  		break;  	case PE.OpCode.Stelem_ref:  		instructions.Add (new MiscInstruction (offset' MiscOp.StelemRef));  		break;  	case PE.OpCode.Ldlen:  		instructions.Add (new MiscInstruction (offset' MiscOp.Ldlen));  		break;  	case PE.OpCode.Ret:  		if (ctxt.ResultType == null)  			instructions.Add (new MiscInstruction (offset' MiscOp.Ret));  		else  			instructions.Add (new MiscInstruction (offset' MiscOp.RetVal));  		break;  	case PE.OpCode.Endfilter:  		instructions.Add (new MiscInstruction (offset' MiscOp.Endfilter));  		break;  	case PE.OpCode.Endfinally:  		// aka EndFault  		instructions.Add (new MiscInstruction (offset' MiscOp.Endfinally));  		break;  	case PE.OpCode.Br_s:  	case PE.OpCode.Br:  		instructions.Add (new BranchInstruction (offset' BranchOp.Br' false' (int)instruction.Value));  		break;  	case PE.OpCode.Brtrue_s:  	// aka brinst.s  	case PE.OpCode.Brtrue:  		// aka brinst  		instructions.Add (new BranchInstruction (offset' BranchOp.Brtrue' false' (int)instruction.Value));  		break;  	case PE.OpCode.Brfalse_s:  	// aka brzero.s' brnull.s  	case PE.OpCode.Brfalse:  		// aka brzero' brnull  		instructions.Add (new BranchInstruction (offset' BranchOp.Brfalse' false' (int)instruction.Value));  		break;  	case PE.OpCode.Beq:  	case PE.OpCode.Beq_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.Breq' false' (int)instruction.Value));  		break;  	case PE.OpCode.Bne_un:  	case PE.OpCode.Bne_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.Brne' false' (int)instruction.Value));  		break;  	case PE.OpCode.Leave:  	case PE.OpCode.Leave_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.Leave' false' (int)instruction.Value));  		break;  	case PE.OpCode.Blt:  	case PE.OpCode.Blt_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' false' (int)instruction.Value));  		break;  	case PE.OpCode.Blt_un:  	case PE.OpCode.Blt_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' true' (int)instruction.Value));  		break;  	case PE.OpCode.Ble:  	case PE.OpCode.Ble_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' false' (int)instruction.Value));  		break;  	case PE.OpCode.Ble_un:  	case PE.OpCode.Ble_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' true' (int)instruction.Value));  		break;  	case PE.OpCode.Bgt:  	case PE.OpCode.Bgt_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' false' (int)instruction.Value));  		break;  	case PE.OpCode.Bgt_un:  	case PE.OpCode.Bgt_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' true' (int)instruction.Value));  		break;  	case PE.OpCode.Bge:  	case PE.OpCode.Bge_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' false' (int)instruction.Value));  		break;  	case PE.OpCode.Bge_un:  	case PE.OpCode.Bge_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' true' (int)instruction.Value));  		break;  	case PE.OpCode.Switch:  		instructions.Add (new SwitchInstruction (offset' (Seq<int>)instruction.Value));  		break;  	case PE.OpCode.Ceq:  		instructions.Add (new CompareInstruction (offset' CompareOp.Ceq' false));  		break;  	case PE.OpCode.Clt:  		instructions.Add (new CompareInstruction (offset' CompareOp.Clt' false));  		break;  	case PE.OpCode.Clt_un:  		instructions.Add (new CompareInstruction (offset' CompareOp.Clt' true));  		break;  	case PE.OpCode.Cgt:  		instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' false));  		break;  	case PE.OpCode.Cgt_un:  		instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' true));  		break;  	case PE.OpCode.Ldarg_0:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));  		break;  	case PE.OpCode.Ldarg_1:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));  		break;  	case PE.OpCode.Ldarg_2:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));  		break;  	case PE.OpCode.Ldarg_3:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));  		break;  	case PE.OpCode.Ldarg:  	case PE.OpCode.Ldarg_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));  		break;  	case PE.OpCode.Ldarga:  	case PE.OpCode.Ldarga_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));  		break;  	case PE.OpCode.Starg:  	case PE.OpCode.Starg_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));  		break;  	case PE.OpCode.Ldloc_0:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 0));  		break;  	case PE.OpCode.Ldloc_1:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 1));  		break;  	case PE.OpCode.Ldloc_2:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 2));  		break;  	case PE.OpCode.Ldloc_3:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 3));  		break;  	case PE.OpCode.Ldloc:  	case PE.OpCode.Ldloc_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));  		break;  	case PE.OpCode.Ldloca:  	case PE.OpCode.Ldloca_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));  		break;  	case PE.OpCode.Stloc_0:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 0));  		break;  	case PE.OpCode.Stloc_1:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 1));  		break;  	case PE.OpCode.Stloc_2:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 2));  		break;  	case PE.OpCode.Stloc_3:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 3));  		break;  	case PE.OpCode.Stloc:  	case PE.OpCode.Stloc_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));  		break;  	case PE.OpCode.Ldfld:  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));  		break;  	case PE.OpCode.Ldsfld:  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));  		break;  	case PE.OpCode.Ldflda:  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));  		break;  	case PE.OpCode.Ldsflda:  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));  		break;  	case PE.OpCode.Stfld:  		instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));  		break;  	case PE.OpCode.Stsfld:  		instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));  		break;  	case PE.OpCode.Ldtoken: {  		if (instruction.Value is FieldRef)  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));  		else if (instruction.Value is MethodRef)  			instructions.Add (new MethodInstruction (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));  		else if (instruction.Value is TypeRef)  			// NOTE: May be a higher-kinded type  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));  		else  			throw new InvalidOperationException ("unexpected ldtoken instruction value");  		break;  	}  	case PE.OpCode.Constrained: {  		var constrained = (TypeRef)instruction.Value;  		if (i >= ctxt.Instructions.Length)  			throw new InvalidOperationException ("invalid instructions");  		instruction = ctxt.Instructions [i++];  		if (instruction.OpCode != PE.OpCode.Callvirt)  			throw new InvalidOperationException ("invalid instruction");  		instructions.Add (new MethodInstruction (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));  		break;  	}  	case PE.OpCode.Call:  		instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Callvirt:  		instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Ldftn:  		instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Ldvirtftn:  		instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Newobj:  		instructions.Add (new MethodInstruction (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Ldind_i1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int8Ref));  		break;  	case PE.OpCode.Ldind_u1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt8Ref));  		break;  	case PE.OpCode.Ldind_i2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int16Ref));  		break;  	case PE.OpCode.Ldind_u2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt16Ref));  		break;  	case PE.OpCode.Ldind_i4:  	case PE.OpCode.Ldind_u4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int32Ref));  		break;  	case PE.OpCode.Ldind_i8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int64Ref));  		break;  	case PE.OpCode.Ldind_i:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.IntNativeRef));  		break;  	case PE.OpCode.Ldind_r4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.SingleRef));  		break;  	case PE.OpCode.Ldind_r8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.DoubleRef));  		break;  	case PE.OpCode.Ldobj:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Stind_i1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int8Ref));  		break;  	case PE.OpCode.Stind_i2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int16Ref));  		break;  	case PE.OpCode.Stind_i4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int32Ref));  		break;  	case PE.OpCode.Stind_i8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int64Ref));  		break;  	case PE.OpCode.Stind_i:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.IntNativeRef));  		break;  	case PE.OpCode.Stind_r4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.SingleRef));  		break;  	case PE.OpCode.Stind_r8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.DoubleRef));  		break;  	case PE.OpCode.Stobj:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Cpobj:  		instructions.Add (new TypeInstruction (offset' TypeOp.Cpobj' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Newarr:  		instructions.Add (new TypeInstruction (offset' TypeOp.Newarr' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Initobj:  		instructions.Add (new TypeInstruction (offset' TypeOp.Initobj' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Castclass:  		instructions.Add (new TypeInstruction (offset' TypeOp.Castclass' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Isinst:  		instructions.Add (new TypeInstruction (offset' TypeOp.Isinst' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Box:  		instructions.Add (new TypeInstruction (offset' TypeOp.Box' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Unbox:  		instructions.Add (new TypeInstruction (offset' TypeOp.Unbox' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Unbox_any:  		instructions.Add (new TypeInstruction (offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Ldelem_i1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int8Ref));  		break;  	case PE.OpCode.Ldelem_u1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt8Ref));  		break;  	case PE.OpCode.Ldelem_i2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int16Ref));  		break;  	case PE.OpCode.Ldelem_u2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt16Ref));  		break;  	case PE.OpCode.Ldelem_i4:  	case PE.OpCode.Ldelem_u4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int32Ref));  		break;  	case PE.OpCode.Ldelem_i:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.IntNativeRef));  		break;  	case PE.OpCode.Ldelem_i8:  		// aka ldelem.u8  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int64Ref));  		break;  	case PE.OpCode.Ldelem_r4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.SingleRef));  		break;  	case PE.OpCode.Ldelem_r8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.DoubleRef));  		break;  	case PE.OpCode.Ldelem:  		// aka ldelem.any  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Stelem_i1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int8Ref));  		break;  	case PE.OpCode.Stelem_i2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int16Ref));  		break;  	case PE.OpCode.Stelem_i4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int32Ref));  		break;  	case PE.OpCode.Stelem_i8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int64Ref));  		break;  	case PE.OpCode.Stelem_i:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.IntNativeRef));  		break;  	case PE.OpCode.Stelem_r4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.SingleRef));  		break;  	case PE.OpCode.Stelem_r8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.DoubleRef));  		break;  	case PE.OpCode.Stelem:  		// aka stelem.any  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Readonly:  		if (i >= ctxt.Instructions.Length)  			throw new InvalidOperationException ("invalid instruction");  		instruction = ctxt.Instructions [i++];  		if (instruction.OpCode != PE.OpCode.Ldelema)  			throw new InvalidOperationException ("invalid instruction");  		instructions.Add (new LdElemAddrInstruction (offset' true' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Ldelema:  		instructions.Add (new LdElemAddrInstruction (offset' false' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Ldc_i4_0:  		instructions.Add (new LdInt32Instruction (offset' 0));  		break;  	case PE.OpCode.Ldc_i4_1:  		instructions.Add (new LdInt32Instruction (offset' 1));  		break;  	case PE.OpCode.Ldc_i4_2:  		instructions.Add (new LdInt32Instruction (offset' 2));  		break;  	case PE.OpCode.Ldc_i4_3:  		instructions.Add (new LdInt32Instruction (offset' 3));  		break;  	case PE.OpCode.Ldc_i4_4:  		instructions.Add (new LdInt32Instruction (offset' 4));  		break;  	case PE.OpCode.Ldc_i4_5:  		instructions.Add (new LdInt32Instruction (offset' 5));  		break;  	case PE.OpCode.Ldc_i4_6:  		instructions.Add (new LdInt32Instruction (offset' 6));  		break;  	case PE.OpCode.Ldc_i4_7:  		instructions.Add (new LdInt32Instruction (offset' 7));  		break;  	case PE.OpCode.Ldc_i4_8:  		instructions.Add (new LdInt32Instruction (offset' 8));  		break;  	case PE.OpCode.Ldc_i4_m1:  		instructions.Add (new LdInt32Instruction (offset' -1));  		break;  	case PE.OpCode.Ldc_i4:  	case PE.OpCode.Ldc_i4_s:  		instructions.Add (new LdInt32Instruction (offset' (int)instruction.Value));  		break;  	case PE.OpCode.Ldc_i8:  		instructions.Add (new LdInt64Instruction (offset' (long)instruction.Value));  		break;  	case PE.OpCode.Ldc_r4:  		instructions.Add (new LdSingleInstruction (offset' (float)instruction.Value));  		break;  	case PE.OpCode.Ldc_r8:  		instructions.Add (new LdDoubleInstruction (offset' (double)instruction.Value));  		break;  	case PE.OpCode.Ldstr:  		instructions.Add (new LdStringInstruction (offset' (string)instruction.Value));  		break;  	case PE.OpCode.Add:  		instructions.Add (new ArithInstruction (offset' ArithOp.Add' false' false));  		break;  	case PE.OpCode.Add_ovf:  		instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' false));  		break;  	case PE.OpCode.Add_ovf_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' true));  		break;  	case PE.OpCode.Sub:  		instructions.Add (new ArithInstruction (offset' ArithOp.Sub' false' false));  		break;  	case PE.OpCode.Sub_ovf:  		instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' false));  		break;  	case PE.OpCode.Sub_ovf_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' true));  		break;  	case PE.OpCode.Mul:  		instructions.Add (new ArithInstruction (offset' ArithOp.Mul' false' false));  		break;  	case PE.OpCode.Mul_ovf:  		instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' false));  		break;  	case PE.OpCode.Mul_ovf_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' true));  		break;  	case PE.OpCode.Div:  		instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' false));  		break;  	case PE.OpCode.Div_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' true));  		break;  	case PE.OpCode.Rem:  		instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' false));  		break;  	case PE.OpCode.Rem_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' true));  		break;  	case PE.OpCode.Neg:  		instructions.Add (new ArithInstruction (offset' ArithOp.Neg' false' false));  		break;  	case PE.OpCode.And:  		instructions.Add (new ArithInstruction (offset' ArithOp.BitAnd' false' false));  		break;  	case PE.OpCode.Or:  		instructions.Add (new ArithInstruction (offset' ArithOp.BitOr' false' false));  		break;  	case PE.OpCode.Xor:  		instructions.Add (new ArithInstruction (offset' ArithOp.BitXor' false' false));  		break;  	case PE.OpCode.Not:  		instructions.Add (new ArithInstruction (offset' ArithOp.BitNot' false' false));  		break;  	case PE.OpCode.Shl:  		instructions.Add (new ArithInstruction (offset' ArithOp.Shl' false' false));  		break;  	case PE.OpCode.Shr:  		instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' false));  		break;  	case PE.OpCode.Shr_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' true));  		break;  	case PE.OpCode.Conv_i1:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' false' false));  		break;  	case PE.OpCode.Conv_u1:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' false' false));  		break;  	case PE.OpCode.Conv_i2:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' false' false));  		break;  	case PE.OpCode.Conv_u2:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' false' false));  		break;  	case PE.OpCode.Conv_i4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' false' false));  		break;  	case PE.OpCode.Conv_u4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' false' false));  		break;  	case PE.OpCode.Conv_i8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' false' false));  		break;  	case PE.OpCode.Conv_u8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' false' false));  		break;  	case PE.OpCode.Conv_i:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' false' false));  		break;  	case PE.OpCode.Conv_u:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' false' false));  		break;  	case PE.OpCode.Conv_r4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Single' false' false));  		break;  	case PE.OpCode.Conv_r8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' false));  		break;  	case PE.OpCode.Conv_r_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' true));  		break;  	case PE.OpCode.Conv_ovf_i1:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' false));  		break;  	case PE.OpCode.Conv_ovf_u1:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' false));  		break;  	case PE.OpCode.Conv_ovf_i2:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' false));  		break;  	case PE.OpCode.Conv_ovf_u2:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' false));  		break;  	case PE.OpCode.Conv_ovf_i4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' false));  		break;  	case PE.OpCode.Conv_ovf_u4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' false));  		break;  	case PE.OpCode.Conv_ovf_i8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' false));  		break;  	case PE.OpCode.Conv_ovf_u8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' false));  		break;  	case PE.OpCode.Conv_ovf_i:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' false));  		break;  	case PE.OpCode.Conv_ovf_u:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' false));  		break;  	case PE.OpCode.Conv_ovf_i1_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' true));  		break;  	case PE.OpCode.Conv_ovf_u1_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' true));  		break;  	case PE.OpCode.Conv_ovf_i2_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' true));  		break;  	case PE.OpCode.Conv_ovf_u2_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' true));  		break;  	case PE.OpCode.Conv_ovf_i4_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' true));  		break;  	case PE.OpCode.Conv_ovf_u4_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' true));  		break;  	case PE.OpCode.Conv_ovf_i8_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' true));  		break;  	case PE.OpCode.Conv_ovf_u8_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' true));  		break;  	case PE.OpCode.Conv_ovf_i_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' true));  		break;  	case PE.OpCode.Conv_ovf_u_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' true));  		break;  	default:  		throw new InvalidOperationException ("invalid instruction");  	}  }  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: if (ehcs != null) {  	// A try instruction begins here with given handlers  	var offset = ctxt.Instructions [i].Offset;  	var tryCtxt = new TryTranslationContext (ctxt' i' ehcs);  	var tryBlock = InstructionsFromContext (tryCtxt);  	var handlers = new Seq<TryInstructionHandler> ();  	foreach (var ehc in ehcs) {  		var handlerCtxt = new HandlerTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.HandlerOffset]' ehc);  		var handlerBlock = InstructionsFromContext (handlerCtxt);  		switch (ehc.Flags) {  		case PE.CorILExceptionClause.Exception:  			handlers.Add (new CatchTryInstructionHandler ((TypeRef)ehc.Class' handlerBlock));  			break;  		case PE.CorILExceptionClause.Filter: {  			var filterCtxt = new FilterTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.FilterOffset]' ehc);  			var filterBlock = InstructionsFromContext (filterCtxt);  			handlers.Add (new FilterTryInstructionHandler (filterBlock' handlerBlock));  			break;  		}  		case PE.CorILExceptionClause.Finally:  			handlers.Add (new FinallyTryInstructionHandler (handlerBlock));  			break;  		case PE.CorILExceptionClause.Fault:  			handlers.Add (new FaultTryInstructionHandler (handlerBlock));  			break;  		default:  			throw new ArgumentOutOfRangeException ();  		}  	}  	instructions.Add (new TryInstruction (offset' tryBlock' handlers));  	// Jump over try block  	var nextOffset = ehcs [0].TryOffset + ehcs [0].TryLength;  	if (!ctxt.OffsetToIndex.TryGetValue (nextOffset' out i))  		i = ctxt.Instructions.Length;  }  else {  	var instruction = ctxt.Instructions [i++];  	var offset = instruction.Offset;  	while (instruction.OpCode == PE.OpCode.Unaligned || instruction.OpCode == PE.OpCode.Volatile || instruction.OpCode == PE.OpCode.Tailcall) {  		// Skip over any ignored prefixes' but remember instruction begins at original offset  		// NOTE: What ever happened to the "no." prefix mentioned in the spec?  		if (i >= ctxt.Instructions.Length)  			throw new InvalidOperationException ("invalid instructions");  		instruction = ctxt.Instructions [i++];  	}  	switch (instruction.OpCode) {  	case PE.OpCode.Cpblk:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Cpblk));  		break;  	case PE.OpCode.Initblk:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Initblk));  		break;  	case PE.OpCode.Arglist:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Arglist));  		break;  	case PE.OpCode.Localloc:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Localloc));  		break;  	case PE.OpCode.Jmp:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Jmp));  		break;  	case PE.OpCode.Calli:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Calli));  		break;  	case PE.OpCode.Sizeof:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Sizeof));  		break;  	case PE.OpCode.Mkrefany:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Mkrefany));  		break;  	case PE.OpCode.Refanytype:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanytype));  		break;  	case PE.OpCode.Refanyval:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanyval));  		break;  	case PE.OpCode.Nop:  		instructions.Add (new MiscInstruction (offset' MiscOp.Nop));  		break;  	case PE.OpCode.Break:  		instructions.Add (new MiscInstruction (offset' MiscOp.Break));  		break;  	case PE.OpCode.Dup:  		instructions.Add (new MiscInstruction (offset' MiscOp.Dup));  		break;  	case PE.OpCode.Pop:  		instructions.Add (new MiscInstruction (offset' MiscOp.Pop));  		break;  	case PE.OpCode.Ldnull:  		instructions.Add (new MiscInstruction (offset' MiscOp.Ldnull));  		break;  	case PE.OpCode.Ckfinite:  		instructions.Add (new MiscInstruction (offset' MiscOp.Ckfinite));  		break;  	case PE.OpCode.Throw:  		instructions.Add (new MiscInstruction (offset' MiscOp.Throw));  		break;  	case PE.OpCode.Rethrow:  		instructions.Add (new MiscInstruction (offset' MiscOp.Rethrow));  		break;  	case PE.OpCode.Ldind_ref:  		instructions.Add (new MiscInstruction (offset' MiscOp.LdindRef));  		break;  	case PE.OpCode.Stind_ref:  		instructions.Add (new MiscInstruction (offset' MiscOp.StindRef));  		break;  	case PE.OpCode.Ldelem_ref:  		instructions.Add (new MiscInstruction (offset' MiscOp.LdelemRef));  		break;  	case PE.OpCode.Stelem_ref:  		instructions.Add (new MiscInstruction (offset' MiscOp.StelemRef));  		break;  	case PE.OpCode.Ldlen:  		instructions.Add (new MiscInstruction (offset' MiscOp.Ldlen));  		break;  	case PE.OpCode.Ret:  		if (ctxt.ResultType == null)  			instructions.Add (new MiscInstruction (offset' MiscOp.Ret));  		else  			instructions.Add (new MiscInstruction (offset' MiscOp.RetVal));  		break;  	case PE.OpCode.Endfilter:  		instructions.Add (new MiscInstruction (offset' MiscOp.Endfilter));  		break;  	case PE.OpCode.Endfinally:  		// aka EndFault  		instructions.Add (new MiscInstruction (offset' MiscOp.Endfinally));  		break;  	case PE.OpCode.Br_s:  	case PE.OpCode.Br:  		instructions.Add (new BranchInstruction (offset' BranchOp.Br' false' (int)instruction.Value));  		break;  	case PE.OpCode.Brtrue_s:  	// aka brinst.s  	case PE.OpCode.Brtrue:  		// aka brinst  		instructions.Add (new BranchInstruction (offset' BranchOp.Brtrue' false' (int)instruction.Value));  		break;  	case PE.OpCode.Brfalse_s:  	// aka brzero.s' brnull.s  	case PE.OpCode.Brfalse:  		// aka brzero' brnull  		instructions.Add (new BranchInstruction (offset' BranchOp.Brfalse' false' (int)instruction.Value));  		break;  	case PE.OpCode.Beq:  	case PE.OpCode.Beq_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.Breq' false' (int)instruction.Value));  		break;  	case PE.OpCode.Bne_un:  	case PE.OpCode.Bne_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.Brne' false' (int)instruction.Value));  		break;  	case PE.OpCode.Leave:  	case PE.OpCode.Leave_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.Leave' false' (int)instruction.Value));  		break;  	case PE.OpCode.Blt:  	case PE.OpCode.Blt_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' false' (int)instruction.Value));  		break;  	case PE.OpCode.Blt_un:  	case PE.OpCode.Blt_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' true' (int)instruction.Value));  		break;  	case PE.OpCode.Ble:  	case PE.OpCode.Ble_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' false' (int)instruction.Value));  		break;  	case PE.OpCode.Ble_un:  	case PE.OpCode.Ble_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' true' (int)instruction.Value));  		break;  	case PE.OpCode.Bgt:  	case PE.OpCode.Bgt_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' false' (int)instruction.Value));  		break;  	case PE.OpCode.Bgt_un:  	case PE.OpCode.Bgt_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' true' (int)instruction.Value));  		break;  	case PE.OpCode.Bge:  	case PE.OpCode.Bge_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' false' (int)instruction.Value));  		break;  	case PE.OpCode.Bge_un:  	case PE.OpCode.Bge_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' true' (int)instruction.Value));  		break;  	case PE.OpCode.Switch:  		instructions.Add (new SwitchInstruction (offset' (Seq<int>)instruction.Value));  		break;  	case PE.OpCode.Ceq:  		instructions.Add (new CompareInstruction (offset' CompareOp.Ceq' false));  		break;  	case PE.OpCode.Clt:  		instructions.Add (new CompareInstruction (offset' CompareOp.Clt' false));  		break;  	case PE.OpCode.Clt_un:  		instructions.Add (new CompareInstruction (offset' CompareOp.Clt' true));  		break;  	case PE.OpCode.Cgt:  		instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' false));  		break;  	case PE.OpCode.Cgt_un:  		instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' true));  		break;  	case PE.OpCode.Ldarg_0:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));  		break;  	case PE.OpCode.Ldarg_1:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));  		break;  	case PE.OpCode.Ldarg_2:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));  		break;  	case PE.OpCode.Ldarg_3:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));  		break;  	case PE.OpCode.Ldarg:  	case PE.OpCode.Ldarg_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));  		break;  	case PE.OpCode.Ldarga:  	case PE.OpCode.Ldarga_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));  		break;  	case PE.OpCode.Starg:  	case PE.OpCode.Starg_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));  		break;  	case PE.OpCode.Ldloc_0:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 0));  		break;  	case PE.OpCode.Ldloc_1:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 1));  		break;  	case PE.OpCode.Ldloc_2:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 2));  		break;  	case PE.OpCode.Ldloc_3:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 3));  		break;  	case PE.OpCode.Ldloc:  	case PE.OpCode.Ldloc_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));  		break;  	case PE.OpCode.Ldloca:  	case PE.OpCode.Ldloca_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));  		break;  	case PE.OpCode.Stloc_0:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 0));  		break;  	case PE.OpCode.Stloc_1:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 1));  		break;  	case PE.OpCode.Stloc_2:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 2));  		break;  	case PE.OpCode.Stloc_3:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 3));  		break;  	case PE.OpCode.Stloc:  	case PE.OpCode.Stloc_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));  		break;  	case PE.OpCode.Ldfld:  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));  		break;  	case PE.OpCode.Ldsfld:  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));  		break;  	case PE.OpCode.Ldflda:  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));  		break;  	case PE.OpCode.Ldsflda:  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));  		break;  	case PE.OpCode.Stfld:  		instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));  		break;  	case PE.OpCode.Stsfld:  		instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));  		break;  	case PE.OpCode.Ldtoken: {  		if (instruction.Value is FieldRef)  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));  		else if (instruction.Value is MethodRef)  			instructions.Add (new MethodInstruction (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));  		else if (instruction.Value is TypeRef)  			// NOTE: May be a higher-kinded type  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));  		else  			throw new InvalidOperationException ("unexpected ldtoken instruction value");  		break;  	}  	case PE.OpCode.Constrained: {  		var constrained = (TypeRef)instruction.Value;  		if (i >= ctxt.Instructions.Length)  			throw new InvalidOperationException ("invalid instructions");  		instruction = ctxt.Instructions [i++];  		if (instruction.OpCode != PE.OpCode.Callvirt)  			throw new InvalidOperationException ("invalid instruction");  		instructions.Add (new MethodInstruction (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));  		break;  	}  	case PE.OpCode.Call:  		instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Callvirt:  		instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Ldftn:  		instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Ldvirtftn:  		instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Newobj:  		instructions.Add (new MethodInstruction (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Ldind_i1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int8Ref));  		break;  	case PE.OpCode.Ldind_u1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt8Ref));  		break;  	case PE.OpCode.Ldind_i2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int16Ref));  		break;  	case PE.OpCode.Ldind_u2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt16Ref));  		break;  	case PE.OpCode.Ldind_i4:  	case PE.OpCode.Ldind_u4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int32Ref));  		break;  	case PE.OpCode.Ldind_i8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int64Ref));  		break;  	case PE.OpCode.Ldind_i:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.IntNativeRef));  		break;  	case PE.OpCode.Ldind_r4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.SingleRef));  		break;  	case PE.OpCode.Ldind_r8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.DoubleRef));  		break;  	case PE.OpCode.Ldobj:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Stind_i1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int8Ref));  		break;  	case PE.OpCode.Stind_i2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int16Ref));  		break;  	case PE.OpCode.Stind_i4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int32Ref));  		break;  	case PE.OpCode.Stind_i8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int64Ref));  		break;  	case PE.OpCode.Stind_i:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.IntNativeRef));  		break;  	case PE.OpCode.Stind_r4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.SingleRef));  		break;  	case PE.OpCode.Stind_r8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.DoubleRef));  		break;  	case PE.OpCode.Stobj:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Cpobj:  		instructions.Add (new TypeInstruction (offset' TypeOp.Cpobj' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Newarr:  		instructions.Add (new TypeInstruction (offset' TypeOp.Newarr' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Initobj:  		instructions.Add (new TypeInstruction (offset' TypeOp.Initobj' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Castclass:  		instructions.Add (new TypeInstruction (offset' TypeOp.Castclass' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Isinst:  		instructions.Add (new TypeInstruction (offset' TypeOp.Isinst' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Box:  		instructions.Add (new TypeInstruction (offset' TypeOp.Box' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Unbox:  		instructions.Add (new TypeInstruction (offset' TypeOp.Unbox' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Unbox_any:  		instructions.Add (new TypeInstruction (offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Ldelem_i1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int8Ref));  		break;  	case PE.OpCode.Ldelem_u1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt8Ref));  		break;  	case PE.OpCode.Ldelem_i2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int16Ref));  		break;  	case PE.OpCode.Ldelem_u2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt16Ref));  		break;  	case PE.OpCode.Ldelem_i4:  	case PE.OpCode.Ldelem_u4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int32Ref));  		break;  	case PE.OpCode.Ldelem_i:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.IntNativeRef));  		break;  	case PE.OpCode.Ldelem_i8:  		// aka ldelem.u8  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int64Ref));  		break;  	case PE.OpCode.Ldelem_r4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.SingleRef));  		break;  	case PE.OpCode.Ldelem_r8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.DoubleRef));  		break;  	case PE.OpCode.Ldelem:  		// aka ldelem.any  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Stelem_i1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int8Ref));  		break;  	case PE.OpCode.Stelem_i2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int16Ref));  		break;  	case PE.OpCode.Stelem_i4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int32Ref));  		break;  	case PE.OpCode.Stelem_i8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int64Ref));  		break;  	case PE.OpCode.Stelem_i:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.IntNativeRef));  		break;  	case PE.OpCode.Stelem_r4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.SingleRef));  		break;  	case PE.OpCode.Stelem_r8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.DoubleRef));  		break;  	case PE.OpCode.Stelem:  		// aka stelem.any  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Readonly:  		if (i >= ctxt.Instructions.Length)  			throw new InvalidOperationException ("invalid instruction");  		instruction = ctxt.Instructions [i++];  		if (instruction.OpCode != PE.OpCode.Ldelema)  			throw new InvalidOperationException ("invalid instruction");  		instructions.Add (new LdElemAddrInstruction (offset' true' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Ldelema:  		instructions.Add (new LdElemAddrInstruction (offset' false' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Ldc_i4_0:  		instructions.Add (new LdInt32Instruction (offset' 0));  		break;  	case PE.OpCode.Ldc_i4_1:  		instructions.Add (new LdInt32Instruction (offset' 1));  		break;  	case PE.OpCode.Ldc_i4_2:  		instructions.Add (new LdInt32Instruction (offset' 2));  		break;  	case PE.OpCode.Ldc_i4_3:  		instructions.Add (new LdInt32Instruction (offset' 3));  		break;  	case PE.OpCode.Ldc_i4_4:  		instructions.Add (new LdInt32Instruction (offset' 4));  		break;  	case PE.OpCode.Ldc_i4_5:  		instructions.Add (new LdInt32Instruction (offset' 5));  		break;  	case PE.OpCode.Ldc_i4_6:  		instructions.Add (new LdInt32Instruction (offset' 6));  		break;  	case PE.OpCode.Ldc_i4_7:  		instructions.Add (new LdInt32Instruction (offset' 7));  		break;  	case PE.OpCode.Ldc_i4_8:  		instructions.Add (new LdInt32Instruction (offset' 8));  		break;  	case PE.OpCode.Ldc_i4_m1:  		instructions.Add (new LdInt32Instruction (offset' -1));  		break;  	case PE.OpCode.Ldc_i4:  	case PE.OpCode.Ldc_i4_s:  		instructions.Add (new LdInt32Instruction (offset' (int)instruction.Value));  		break;  	case PE.OpCode.Ldc_i8:  		instructions.Add (new LdInt64Instruction (offset' (long)instruction.Value));  		break;  	case PE.OpCode.Ldc_r4:  		instructions.Add (new LdSingleInstruction (offset' (float)instruction.Value));  		break;  	case PE.OpCode.Ldc_r8:  		instructions.Add (new LdDoubleInstruction (offset' (double)instruction.Value));  		break;  	case PE.OpCode.Ldstr:  		instructions.Add (new LdStringInstruction (offset' (string)instruction.Value));  		break;  	case PE.OpCode.Add:  		instructions.Add (new ArithInstruction (offset' ArithOp.Add' false' false));  		break;  	case PE.OpCode.Add_ovf:  		instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' false));  		break;  	case PE.OpCode.Add_ovf_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' true));  		break;  	case PE.OpCode.Sub:  		instructions.Add (new ArithInstruction (offset' ArithOp.Sub' false' false));  		break;  	case PE.OpCode.Sub_ovf:  		instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' false));  		break;  	case PE.OpCode.Sub_ovf_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' true));  		break;  	case PE.OpCode.Mul:  		instructions.Add (new ArithInstruction (offset' ArithOp.Mul' false' false));  		break;  	case PE.OpCode.Mul_ovf:  		instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' false));  		break;  	case PE.OpCode.Mul_ovf_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' true));  		break;  	case PE.OpCode.Div:  		instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' false));  		break;  	case PE.OpCode.Div_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' true));  		break;  	case PE.OpCode.Rem:  		instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' false));  		break;  	case PE.OpCode.Rem_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' true));  		break;  	case PE.OpCode.Neg:  		instructions.Add (new ArithInstruction (offset' ArithOp.Neg' false' false));  		break;  	case PE.OpCode.And:  		instructions.Add (new ArithInstruction (offset' ArithOp.BitAnd' false' false));  		break;  	case PE.OpCode.Or:  		instructions.Add (new ArithInstruction (offset' ArithOp.BitOr' false' false));  		break;  	case PE.OpCode.Xor:  		instructions.Add (new ArithInstruction (offset' ArithOp.BitXor' false' false));  		break;  	case PE.OpCode.Not:  		instructions.Add (new ArithInstruction (offset' ArithOp.BitNot' false' false));  		break;  	case PE.OpCode.Shl:  		instructions.Add (new ArithInstruction (offset' ArithOp.Shl' false' false));  		break;  	case PE.OpCode.Shr:  		instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' false));  		break;  	case PE.OpCode.Shr_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' true));  		break;  	case PE.OpCode.Conv_i1:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' false' false));  		break;  	case PE.OpCode.Conv_u1:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' false' false));  		break;  	case PE.OpCode.Conv_i2:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' false' false));  		break;  	case PE.OpCode.Conv_u2:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' false' false));  		break;  	case PE.OpCode.Conv_i4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' false' false));  		break;  	case PE.OpCode.Conv_u4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' false' false));  		break;  	case PE.OpCode.Conv_i8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' false' false));  		break;  	case PE.OpCode.Conv_u8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' false' false));  		break;  	case PE.OpCode.Conv_i:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' false' false));  		break;  	case PE.OpCode.Conv_u:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' false' false));  		break;  	case PE.OpCode.Conv_r4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Single' false' false));  		break;  	case PE.OpCode.Conv_r8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' false));  		break;  	case PE.OpCode.Conv_r_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' true));  		break;  	case PE.OpCode.Conv_ovf_i1:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' false));  		break;  	case PE.OpCode.Conv_ovf_u1:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' false));  		break;  	case PE.OpCode.Conv_ovf_i2:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' false));  		break;  	case PE.OpCode.Conv_ovf_u2:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' false));  		break;  	case PE.OpCode.Conv_ovf_i4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' false));  		break;  	case PE.OpCode.Conv_ovf_u4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' false));  		break;  	case PE.OpCode.Conv_ovf_i8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' false));  		break;  	case PE.OpCode.Conv_ovf_u8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' false));  		break;  	case PE.OpCode.Conv_ovf_i:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' false));  		break;  	case PE.OpCode.Conv_ovf_u:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' false));  		break;  	case PE.OpCode.Conv_ovf_i1_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' true));  		break;  	case PE.OpCode.Conv_ovf_u1_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' true));  		break;  	case PE.OpCode.Conv_ovf_i2_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' true));  		break;  	case PE.OpCode.Conv_ovf_u2_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' true));  		break;  	case PE.OpCode.Conv_ovf_i4_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' true));  		break;  	case PE.OpCode.Conv_ovf_u4_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' true));  		break;  	case PE.OpCode.Conv_ovf_i8_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' true));  		break;  	case PE.OpCode.Conv_ovf_u8_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' true));  		break;  	case PE.OpCode.Conv_ovf_i_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' true));  		break;  	case PE.OpCode.Conv_ovf_u_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' true));  		break;  	default:  		throw new InvalidOperationException ("invalid instruction");  	}  }  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: if (ehcs != null) {  	// A try instruction begins here with given handlers  	var offset = ctxt.Instructions [i].Offset;  	var tryCtxt = new TryTranslationContext (ctxt' i' ehcs);  	var tryBlock = InstructionsFromContext (tryCtxt);  	var handlers = new Seq<TryInstructionHandler> ();  	foreach (var ehc in ehcs) {  		var handlerCtxt = new HandlerTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.HandlerOffset]' ehc);  		var handlerBlock = InstructionsFromContext (handlerCtxt);  		switch (ehc.Flags) {  		case PE.CorILExceptionClause.Exception:  			handlers.Add (new CatchTryInstructionHandler ((TypeRef)ehc.Class' handlerBlock));  			break;  		case PE.CorILExceptionClause.Filter: {  			var filterCtxt = new FilterTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.FilterOffset]' ehc);  			var filterBlock = InstructionsFromContext (filterCtxt);  			handlers.Add (new FilterTryInstructionHandler (filterBlock' handlerBlock));  			break;  		}  		case PE.CorILExceptionClause.Finally:  			handlers.Add (new FinallyTryInstructionHandler (handlerBlock));  			break;  		case PE.CorILExceptionClause.Fault:  			handlers.Add (new FaultTryInstructionHandler (handlerBlock));  			break;  		default:  			throw new ArgumentOutOfRangeException ();  		}  	}  	instructions.Add (new TryInstruction (offset' tryBlock' handlers));  	// Jump over try block  	var nextOffset = ehcs [0].TryOffset + ehcs [0].TryLength;  	if (!ctxt.OffsetToIndex.TryGetValue (nextOffset' out i))  		i = ctxt.Instructions.Length;  }  else {  	var instruction = ctxt.Instructions [i++];  	var offset = instruction.Offset;  	while (instruction.OpCode == PE.OpCode.Unaligned || instruction.OpCode == PE.OpCode.Volatile || instruction.OpCode == PE.OpCode.Tailcall) {  		// Skip over any ignored prefixes' but remember instruction begins at original offset  		// NOTE: What ever happened to the "no." prefix mentioned in the spec?  		if (i >= ctxt.Instructions.Length)  			throw new InvalidOperationException ("invalid instructions");  		instruction = ctxt.Instructions [i++];  	}  	switch (instruction.OpCode) {  	case PE.OpCode.Cpblk:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Cpblk));  		break;  	case PE.OpCode.Initblk:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Initblk));  		break;  	case PE.OpCode.Arglist:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Arglist));  		break;  	case PE.OpCode.Localloc:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Localloc));  		break;  	case PE.OpCode.Jmp:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Jmp));  		break;  	case PE.OpCode.Calli:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Calli));  		break;  	case PE.OpCode.Sizeof:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Sizeof));  		break;  	case PE.OpCode.Mkrefany:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Mkrefany));  		break;  	case PE.OpCode.Refanytype:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanytype));  		break;  	case PE.OpCode.Refanyval:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanyval));  		break;  	case PE.OpCode.Nop:  		instructions.Add (new MiscInstruction (offset' MiscOp.Nop));  		break;  	case PE.OpCode.Break:  		instructions.Add (new MiscInstruction (offset' MiscOp.Break));  		break;  	case PE.OpCode.Dup:  		instructions.Add (new MiscInstruction (offset' MiscOp.Dup));  		break;  	case PE.OpCode.Pop:  		instructions.Add (new MiscInstruction (offset' MiscOp.Pop));  		break;  	case PE.OpCode.Ldnull:  		instructions.Add (new MiscInstruction (offset' MiscOp.Ldnull));  		break;  	case PE.OpCode.Ckfinite:  		instructions.Add (new MiscInstruction (offset' MiscOp.Ckfinite));  		break;  	case PE.OpCode.Throw:  		instructions.Add (new MiscInstruction (offset' MiscOp.Throw));  		break;  	case PE.OpCode.Rethrow:  		instructions.Add (new MiscInstruction (offset' MiscOp.Rethrow));  		break;  	case PE.OpCode.Ldind_ref:  		instructions.Add (new MiscInstruction (offset' MiscOp.LdindRef));  		break;  	case PE.OpCode.Stind_ref:  		instructions.Add (new MiscInstruction (offset' MiscOp.StindRef));  		break;  	case PE.OpCode.Ldelem_ref:  		instructions.Add (new MiscInstruction (offset' MiscOp.LdelemRef));  		break;  	case PE.OpCode.Stelem_ref:  		instructions.Add (new MiscInstruction (offset' MiscOp.StelemRef));  		break;  	case PE.OpCode.Ldlen:  		instructions.Add (new MiscInstruction (offset' MiscOp.Ldlen));  		break;  	case PE.OpCode.Ret:  		if (ctxt.ResultType == null)  			instructions.Add (new MiscInstruction (offset' MiscOp.Ret));  		else  			instructions.Add (new MiscInstruction (offset' MiscOp.RetVal));  		break;  	case PE.OpCode.Endfilter:  		instructions.Add (new MiscInstruction (offset' MiscOp.Endfilter));  		break;  	case PE.OpCode.Endfinally:  		// aka EndFault  		instructions.Add (new MiscInstruction (offset' MiscOp.Endfinally));  		break;  	case PE.OpCode.Br_s:  	case PE.OpCode.Br:  		instructions.Add (new BranchInstruction (offset' BranchOp.Br' false' (int)instruction.Value));  		break;  	case PE.OpCode.Brtrue_s:  	// aka brinst.s  	case PE.OpCode.Brtrue:  		// aka brinst  		instructions.Add (new BranchInstruction (offset' BranchOp.Brtrue' false' (int)instruction.Value));  		break;  	case PE.OpCode.Brfalse_s:  	// aka brzero.s' brnull.s  	case PE.OpCode.Brfalse:  		// aka brzero' brnull  		instructions.Add (new BranchInstruction (offset' BranchOp.Brfalse' false' (int)instruction.Value));  		break;  	case PE.OpCode.Beq:  	case PE.OpCode.Beq_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.Breq' false' (int)instruction.Value));  		break;  	case PE.OpCode.Bne_un:  	case PE.OpCode.Bne_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.Brne' false' (int)instruction.Value));  		break;  	case PE.OpCode.Leave:  	case PE.OpCode.Leave_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.Leave' false' (int)instruction.Value));  		break;  	case PE.OpCode.Blt:  	case PE.OpCode.Blt_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' false' (int)instruction.Value));  		break;  	case PE.OpCode.Blt_un:  	case PE.OpCode.Blt_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' true' (int)instruction.Value));  		break;  	case PE.OpCode.Ble:  	case PE.OpCode.Ble_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' false' (int)instruction.Value));  		break;  	case PE.OpCode.Ble_un:  	case PE.OpCode.Ble_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' true' (int)instruction.Value));  		break;  	case PE.OpCode.Bgt:  	case PE.OpCode.Bgt_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' false' (int)instruction.Value));  		break;  	case PE.OpCode.Bgt_un:  	case PE.OpCode.Bgt_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' true' (int)instruction.Value));  		break;  	case PE.OpCode.Bge:  	case PE.OpCode.Bge_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' false' (int)instruction.Value));  		break;  	case PE.OpCode.Bge_un:  	case PE.OpCode.Bge_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' true' (int)instruction.Value));  		break;  	case PE.OpCode.Switch:  		instructions.Add (new SwitchInstruction (offset' (Seq<int>)instruction.Value));  		break;  	case PE.OpCode.Ceq:  		instructions.Add (new CompareInstruction (offset' CompareOp.Ceq' false));  		break;  	case PE.OpCode.Clt:  		instructions.Add (new CompareInstruction (offset' CompareOp.Clt' false));  		break;  	case PE.OpCode.Clt_un:  		instructions.Add (new CompareInstruction (offset' CompareOp.Clt' true));  		break;  	case PE.OpCode.Cgt:  		instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' false));  		break;  	case PE.OpCode.Cgt_un:  		instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' true));  		break;  	case PE.OpCode.Ldarg_0:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));  		break;  	case PE.OpCode.Ldarg_1:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));  		break;  	case PE.OpCode.Ldarg_2:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));  		break;  	case PE.OpCode.Ldarg_3:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));  		break;  	case PE.OpCode.Ldarg:  	case PE.OpCode.Ldarg_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));  		break;  	case PE.OpCode.Ldarga:  	case PE.OpCode.Ldarga_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));  		break;  	case PE.OpCode.Starg:  	case PE.OpCode.Starg_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));  		break;  	case PE.OpCode.Ldloc_0:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 0));  		break;  	case PE.OpCode.Ldloc_1:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 1));  		break;  	case PE.OpCode.Ldloc_2:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 2));  		break;  	case PE.OpCode.Ldloc_3:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 3));  		break;  	case PE.OpCode.Ldloc:  	case PE.OpCode.Ldloc_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));  		break;  	case PE.OpCode.Ldloca:  	case PE.OpCode.Ldloca_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));  		break;  	case PE.OpCode.Stloc_0:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 0));  		break;  	case PE.OpCode.Stloc_1:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 1));  		break;  	case PE.OpCode.Stloc_2:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 2));  		break;  	case PE.OpCode.Stloc_3:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 3));  		break;  	case PE.OpCode.Stloc:  	case PE.OpCode.Stloc_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));  		break;  	case PE.OpCode.Ldfld:  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));  		break;  	case PE.OpCode.Ldsfld:  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));  		break;  	case PE.OpCode.Ldflda:  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));  		break;  	case PE.OpCode.Ldsflda:  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));  		break;  	case PE.OpCode.Stfld:  		instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));  		break;  	case PE.OpCode.Stsfld:  		instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));  		break;  	case PE.OpCode.Ldtoken: {  		if (instruction.Value is FieldRef)  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));  		else if (instruction.Value is MethodRef)  			instructions.Add (new MethodInstruction (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));  		else if (instruction.Value is TypeRef)  			// NOTE: May be a higher-kinded type  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));  		else  			throw new InvalidOperationException ("unexpected ldtoken instruction value");  		break;  	}  	case PE.OpCode.Constrained: {  		var constrained = (TypeRef)instruction.Value;  		if (i >= ctxt.Instructions.Length)  			throw new InvalidOperationException ("invalid instructions");  		instruction = ctxt.Instructions [i++];  		if (instruction.OpCode != PE.OpCode.Callvirt)  			throw new InvalidOperationException ("invalid instruction");  		instructions.Add (new MethodInstruction (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));  		break;  	}  	case PE.OpCode.Call:  		instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Callvirt:  		instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Ldftn:  		instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Ldvirtftn:  		instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Newobj:  		instructions.Add (new MethodInstruction (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Ldind_i1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int8Ref));  		break;  	case PE.OpCode.Ldind_u1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt8Ref));  		break;  	case PE.OpCode.Ldind_i2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int16Ref));  		break;  	case PE.OpCode.Ldind_u2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt16Ref));  		break;  	case PE.OpCode.Ldind_i4:  	case PE.OpCode.Ldind_u4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int32Ref));  		break;  	case PE.OpCode.Ldind_i8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int64Ref));  		break;  	case PE.OpCode.Ldind_i:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.IntNativeRef));  		break;  	case PE.OpCode.Ldind_r4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.SingleRef));  		break;  	case PE.OpCode.Ldind_r8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.DoubleRef));  		break;  	case PE.OpCode.Ldobj:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Stind_i1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int8Ref));  		break;  	case PE.OpCode.Stind_i2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int16Ref));  		break;  	case PE.OpCode.Stind_i4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int32Ref));  		break;  	case PE.OpCode.Stind_i8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int64Ref));  		break;  	case PE.OpCode.Stind_i:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.IntNativeRef));  		break;  	case PE.OpCode.Stind_r4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.SingleRef));  		break;  	case PE.OpCode.Stind_r8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.DoubleRef));  		break;  	case PE.OpCode.Stobj:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Cpobj:  		instructions.Add (new TypeInstruction (offset' TypeOp.Cpobj' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Newarr:  		instructions.Add (new TypeInstruction (offset' TypeOp.Newarr' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Initobj:  		instructions.Add (new TypeInstruction (offset' TypeOp.Initobj' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Castclass:  		instructions.Add (new TypeInstruction (offset' TypeOp.Castclass' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Isinst:  		instructions.Add (new TypeInstruction (offset' TypeOp.Isinst' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Box:  		instructions.Add (new TypeInstruction (offset' TypeOp.Box' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Unbox:  		instructions.Add (new TypeInstruction (offset' TypeOp.Unbox' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Unbox_any:  		instructions.Add (new TypeInstruction (offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Ldelem_i1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int8Ref));  		break;  	case PE.OpCode.Ldelem_u1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt8Ref));  		break;  	case PE.OpCode.Ldelem_i2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int16Ref));  		break;  	case PE.OpCode.Ldelem_u2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt16Ref));  		break;  	case PE.OpCode.Ldelem_i4:  	case PE.OpCode.Ldelem_u4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int32Ref));  		break;  	case PE.OpCode.Ldelem_i:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.IntNativeRef));  		break;  	case PE.OpCode.Ldelem_i8:  		// aka ldelem.u8  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int64Ref));  		break;  	case PE.OpCode.Ldelem_r4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.SingleRef));  		break;  	case PE.OpCode.Ldelem_r8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.DoubleRef));  		break;  	case PE.OpCode.Ldelem:  		// aka ldelem.any  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Stelem_i1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int8Ref));  		break;  	case PE.OpCode.Stelem_i2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int16Ref));  		break;  	case PE.OpCode.Stelem_i4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int32Ref));  		break;  	case PE.OpCode.Stelem_i8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int64Ref));  		break;  	case PE.OpCode.Stelem_i:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.IntNativeRef));  		break;  	case PE.OpCode.Stelem_r4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.SingleRef));  		break;  	case PE.OpCode.Stelem_r8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.DoubleRef));  		break;  	case PE.OpCode.Stelem:  		// aka stelem.any  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Readonly:  		if (i >= ctxt.Instructions.Length)  			throw new InvalidOperationException ("invalid instruction");  		instruction = ctxt.Instructions [i++];  		if (instruction.OpCode != PE.OpCode.Ldelema)  			throw new InvalidOperationException ("invalid instruction");  		instructions.Add (new LdElemAddrInstruction (offset' true' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Ldelema:  		instructions.Add (new LdElemAddrInstruction (offset' false' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Ldc_i4_0:  		instructions.Add (new LdInt32Instruction (offset' 0));  		break;  	case PE.OpCode.Ldc_i4_1:  		instructions.Add (new LdInt32Instruction (offset' 1));  		break;  	case PE.OpCode.Ldc_i4_2:  		instructions.Add (new LdInt32Instruction (offset' 2));  		break;  	case PE.OpCode.Ldc_i4_3:  		instructions.Add (new LdInt32Instruction (offset' 3));  		break;  	case PE.OpCode.Ldc_i4_4:  		instructions.Add (new LdInt32Instruction (offset' 4));  		break;  	case PE.OpCode.Ldc_i4_5:  		instructions.Add (new LdInt32Instruction (offset' 5));  		break;  	case PE.OpCode.Ldc_i4_6:  		instructions.Add (new LdInt32Instruction (offset' 6));  		break;  	case PE.OpCode.Ldc_i4_7:  		instructions.Add (new LdInt32Instruction (offset' 7));  		break;  	case PE.OpCode.Ldc_i4_8:  		instructions.Add (new LdInt32Instruction (offset' 8));  		break;  	case PE.OpCode.Ldc_i4_m1:  		instructions.Add (new LdInt32Instruction (offset' -1));  		break;  	case PE.OpCode.Ldc_i4:  	case PE.OpCode.Ldc_i4_s:  		instructions.Add (new LdInt32Instruction (offset' (int)instruction.Value));  		break;  	case PE.OpCode.Ldc_i8:  		instructions.Add (new LdInt64Instruction (offset' (long)instruction.Value));  		break;  	case PE.OpCode.Ldc_r4:  		instructions.Add (new LdSingleInstruction (offset' (float)instruction.Value));  		break;  	case PE.OpCode.Ldc_r8:  		instructions.Add (new LdDoubleInstruction (offset' (double)instruction.Value));  		break;  	case PE.OpCode.Ldstr:  		instructions.Add (new LdStringInstruction (offset' (string)instruction.Value));  		break;  	case PE.OpCode.Add:  		instructions.Add (new ArithInstruction (offset' ArithOp.Add' false' false));  		break;  	case PE.OpCode.Add_ovf:  		instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' false));  		break;  	case PE.OpCode.Add_ovf_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' true));  		break;  	case PE.OpCode.Sub:  		instructions.Add (new ArithInstruction (offset' ArithOp.Sub' false' false));  		break;  	case PE.OpCode.Sub_ovf:  		instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' false));  		break;  	case PE.OpCode.Sub_ovf_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' true));  		break;  	case PE.OpCode.Mul:  		instructions.Add (new ArithInstruction (offset' ArithOp.Mul' false' false));  		break;  	case PE.OpCode.Mul_ovf:  		instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' false));  		break;  	case PE.OpCode.Mul_ovf_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' true));  		break;  	case PE.OpCode.Div:  		instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' false));  		break;  	case PE.OpCode.Div_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' true));  		break;  	case PE.OpCode.Rem:  		instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' false));  		break;  	case PE.OpCode.Rem_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' true));  		break;  	case PE.OpCode.Neg:  		instructions.Add (new ArithInstruction (offset' ArithOp.Neg' false' false));  		break;  	case PE.OpCode.And:  		instructions.Add (new ArithInstruction (offset' ArithOp.BitAnd' false' false));  		break;  	case PE.OpCode.Or:  		instructions.Add (new ArithInstruction (offset' ArithOp.BitOr' false' false));  		break;  	case PE.OpCode.Xor:  		instructions.Add (new ArithInstruction (offset' ArithOp.BitXor' false' false));  		break;  	case PE.OpCode.Not:  		instructions.Add (new ArithInstruction (offset' ArithOp.BitNot' false' false));  		break;  	case PE.OpCode.Shl:  		instructions.Add (new ArithInstruction (offset' ArithOp.Shl' false' false));  		break;  	case PE.OpCode.Shr:  		instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' false));  		break;  	case PE.OpCode.Shr_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' true));  		break;  	case PE.OpCode.Conv_i1:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' false' false));  		break;  	case PE.OpCode.Conv_u1:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' false' false));  		break;  	case PE.OpCode.Conv_i2:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' false' false));  		break;  	case PE.OpCode.Conv_u2:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' false' false));  		break;  	case PE.OpCode.Conv_i4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' false' false));  		break;  	case PE.OpCode.Conv_u4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' false' false));  		break;  	case PE.OpCode.Conv_i8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' false' false));  		break;  	case PE.OpCode.Conv_u8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' false' false));  		break;  	case PE.OpCode.Conv_i:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' false' false));  		break;  	case PE.OpCode.Conv_u:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' false' false));  		break;  	case PE.OpCode.Conv_r4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Single' false' false));  		break;  	case PE.OpCode.Conv_r8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' false));  		break;  	case PE.OpCode.Conv_r_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' true));  		break;  	case PE.OpCode.Conv_ovf_i1:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' false));  		break;  	case PE.OpCode.Conv_ovf_u1:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' false));  		break;  	case PE.OpCode.Conv_ovf_i2:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' false));  		break;  	case PE.OpCode.Conv_ovf_u2:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' false));  		break;  	case PE.OpCode.Conv_ovf_i4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' false));  		break;  	case PE.OpCode.Conv_ovf_u4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' false));  		break;  	case PE.OpCode.Conv_ovf_i8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' false));  		break;  	case PE.OpCode.Conv_ovf_u8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' false));  		break;  	case PE.OpCode.Conv_ovf_i:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' false));  		break;  	case PE.OpCode.Conv_ovf_u:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' false));  		break;  	case PE.OpCode.Conv_ovf_i1_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' true));  		break;  	case PE.OpCode.Conv_ovf_u1_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' true));  		break;  	case PE.OpCode.Conv_ovf_i2_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' true));  		break;  	case PE.OpCode.Conv_ovf_u2_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' true));  		break;  	case PE.OpCode.Conv_ovf_i4_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' true));  		break;  	case PE.OpCode.Conv_ovf_u4_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' true));  		break;  	case PE.OpCode.Conv_ovf_i8_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' true));  		break;  	case PE.OpCode.Conv_ovf_u8_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' true));  		break;  	case PE.OpCode.Conv_ovf_i_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' true));  		break;  	case PE.OpCode.Conv_ovf_u_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' true));  		break;  	default:  		throw new InvalidOperationException ("invalid instruction");  	}  }  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: if (ehcs != null) {  	// A try instruction begins here with given handlers  	var offset = ctxt.Instructions [i].Offset;  	var tryCtxt = new TryTranslationContext (ctxt' i' ehcs);  	var tryBlock = InstructionsFromContext (tryCtxt);  	var handlers = new Seq<TryInstructionHandler> ();  	foreach (var ehc in ehcs) {  		var handlerCtxt = new HandlerTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.HandlerOffset]' ehc);  		var handlerBlock = InstructionsFromContext (handlerCtxt);  		switch (ehc.Flags) {  		case PE.CorILExceptionClause.Exception:  			handlers.Add (new CatchTryInstructionHandler ((TypeRef)ehc.Class' handlerBlock));  			break;  		case PE.CorILExceptionClause.Filter: {  			var filterCtxt = new FilterTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.FilterOffset]' ehc);  			var filterBlock = InstructionsFromContext (filterCtxt);  			handlers.Add (new FilterTryInstructionHandler (filterBlock' handlerBlock));  			break;  		}  		case PE.CorILExceptionClause.Finally:  			handlers.Add (new FinallyTryInstructionHandler (handlerBlock));  			break;  		case PE.CorILExceptionClause.Fault:  			handlers.Add (new FaultTryInstructionHandler (handlerBlock));  			break;  		default:  			throw new ArgumentOutOfRangeException ();  		}  	}  	instructions.Add (new TryInstruction (offset' tryBlock' handlers));  	// Jump over try block  	var nextOffset = ehcs [0].TryOffset + ehcs [0].TryLength;  	if (!ctxt.OffsetToIndex.TryGetValue (nextOffset' out i))  		i = ctxt.Instructions.Length;  }  else {  	var instruction = ctxt.Instructions [i++];  	var offset = instruction.Offset;  	while (instruction.OpCode == PE.OpCode.Unaligned || instruction.OpCode == PE.OpCode.Volatile || instruction.OpCode == PE.OpCode.Tailcall) {  		// Skip over any ignored prefixes' but remember instruction begins at original offset  		// NOTE: What ever happened to the "no." prefix mentioned in the spec?  		if (i >= ctxt.Instructions.Length)  			throw new InvalidOperationException ("invalid instructions");  		instruction = ctxt.Instructions [i++];  	}  	switch (instruction.OpCode) {  	case PE.OpCode.Cpblk:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Cpblk));  		break;  	case PE.OpCode.Initblk:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Initblk));  		break;  	case PE.OpCode.Arglist:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Arglist));  		break;  	case PE.OpCode.Localloc:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Localloc));  		break;  	case PE.OpCode.Jmp:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Jmp));  		break;  	case PE.OpCode.Calli:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Calli));  		break;  	case PE.OpCode.Sizeof:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Sizeof));  		break;  	case PE.OpCode.Mkrefany:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Mkrefany));  		break;  	case PE.OpCode.Refanytype:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanytype));  		break;  	case PE.OpCode.Refanyval:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanyval));  		break;  	case PE.OpCode.Nop:  		instructions.Add (new MiscInstruction (offset' MiscOp.Nop));  		break;  	case PE.OpCode.Break:  		instructions.Add (new MiscInstruction (offset' MiscOp.Break));  		break;  	case PE.OpCode.Dup:  		instructions.Add (new MiscInstruction (offset' MiscOp.Dup));  		break;  	case PE.OpCode.Pop:  		instructions.Add (new MiscInstruction (offset' MiscOp.Pop));  		break;  	case PE.OpCode.Ldnull:  		instructions.Add (new MiscInstruction (offset' MiscOp.Ldnull));  		break;  	case PE.OpCode.Ckfinite:  		instructions.Add (new MiscInstruction (offset' MiscOp.Ckfinite));  		break;  	case PE.OpCode.Throw:  		instructions.Add (new MiscInstruction (offset' MiscOp.Throw));  		break;  	case PE.OpCode.Rethrow:  		instructions.Add (new MiscInstruction (offset' MiscOp.Rethrow));  		break;  	case PE.OpCode.Ldind_ref:  		instructions.Add (new MiscInstruction (offset' MiscOp.LdindRef));  		break;  	case PE.OpCode.Stind_ref:  		instructions.Add (new MiscInstruction (offset' MiscOp.StindRef));  		break;  	case PE.OpCode.Ldelem_ref:  		instructions.Add (new MiscInstruction (offset' MiscOp.LdelemRef));  		break;  	case PE.OpCode.Stelem_ref:  		instructions.Add (new MiscInstruction (offset' MiscOp.StelemRef));  		break;  	case PE.OpCode.Ldlen:  		instructions.Add (new MiscInstruction (offset' MiscOp.Ldlen));  		break;  	case PE.OpCode.Ret:  		if (ctxt.ResultType == null)  			instructions.Add (new MiscInstruction (offset' MiscOp.Ret));  		else  			instructions.Add (new MiscInstruction (offset' MiscOp.RetVal));  		break;  	case PE.OpCode.Endfilter:  		instructions.Add (new MiscInstruction (offset' MiscOp.Endfilter));  		break;  	case PE.OpCode.Endfinally:  		// aka EndFault  		instructions.Add (new MiscInstruction (offset' MiscOp.Endfinally));  		break;  	case PE.OpCode.Br_s:  	case PE.OpCode.Br:  		instructions.Add (new BranchInstruction (offset' BranchOp.Br' false' (int)instruction.Value));  		break;  	case PE.OpCode.Brtrue_s:  	// aka brinst.s  	case PE.OpCode.Brtrue:  		// aka brinst  		instructions.Add (new BranchInstruction (offset' BranchOp.Brtrue' false' (int)instruction.Value));  		break;  	case PE.OpCode.Brfalse_s:  	// aka brzero.s' brnull.s  	case PE.OpCode.Brfalse:  		// aka brzero' brnull  		instructions.Add (new BranchInstruction (offset' BranchOp.Brfalse' false' (int)instruction.Value));  		break;  	case PE.OpCode.Beq:  	case PE.OpCode.Beq_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.Breq' false' (int)instruction.Value));  		break;  	case PE.OpCode.Bne_un:  	case PE.OpCode.Bne_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.Brne' false' (int)instruction.Value));  		break;  	case PE.OpCode.Leave:  	case PE.OpCode.Leave_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.Leave' false' (int)instruction.Value));  		break;  	case PE.OpCode.Blt:  	case PE.OpCode.Blt_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' false' (int)instruction.Value));  		break;  	case PE.OpCode.Blt_un:  	case PE.OpCode.Blt_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' true' (int)instruction.Value));  		break;  	case PE.OpCode.Ble:  	case PE.OpCode.Ble_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' false' (int)instruction.Value));  		break;  	case PE.OpCode.Ble_un:  	case PE.OpCode.Ble_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' true' (int)instruction.Value));  		break;  	case PE.OpCode.Bgt:  	case PE.OpCode.Bgt_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' false' (int)instruction.Value));  		break;  	case PE.OpCode.Bgt_un:  	case PE.OpCode.Bgt_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' true' (int)instruction.Value));  		break;  	case PE.OpCode.Bge:  	case PE.OpCode.Bge_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' false' (int)instruction.Value));  		break;  	case PE.OpCode.Bge_un:  	case PE.OpCode.Bge_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' true' (int)instruction.Value));  		break;  	case PE.OpCode.Switch:  		instructions.Add (new SwitchInstruction (offset' (Seq<int>)instruction.Value));  		break;  	case PE.OpCode.Ceq:  		instructions.Add (new CompareInstruction (offset' CompareOp.Ceq' false));  		break;  	case PE.OpCode.Clt:  		instructions.Add (new CompareInstruction (offset' CompareOp.Clt' false));  		break;  	case PE.OpCode.Clt_un:  		instructions.Add (new CompareInstruction (offset' CompareOp.Clt' true));  		break;  	case PE.OpCode.Cgt:  		instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' false));  		break;  	case PE.OpCode.Cgt_un:  		instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' true));  		break;  	case PE.OpCode.Ldarg_0:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));  		break;  	case PE.OpCode.Ldarg_1:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));  		break;  	case PE.OpCode.Ldarg_2:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));  		break;  	case PE.OpCode.Ldarg_3:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));  		break;  	case PE.OpCode.Ldarg:  	case PE.OpCode.Ldarg_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));  		break;  	case PE.OpCode.Ldarga:  	case PE.OpCode.Ldarga_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));  		break;  	case PE.OpCode.Starg:  	case PE.OpCode.Starg_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));  		break;  	case PE.OpCode.Ldloc_0:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 0));  		break;  	case PE.OpCode.Ldloc_1:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 1));  		break;  	case PE.OpCode.Ldloc_2:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 2));  		break;  	case PE.OpCode.Ldloc_3:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 3));  		break;  	case PE.OpCode.Ldloc:  	case PE.OpCode.Ldloc_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));  		break;  	case PE.OpCode.Ldloca:  	case PE.OpCode.Ldloca_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));  		break;  	case PE.OpCode.Stloc_0:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 0));  		break;  	case PE.OpCode.Stloc_1:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 1));  		break;  	case PE.OpCode.Stloc_2:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 2));  		break;  	case PE.OpCode.Stloc_3:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 3));  		break;  	case PE.OpCode.Stloc:  	case PE.OpCode.Stloc_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));  		break;  	case PE.OpCode.Ldfld:  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));  		break;  	case PE.OpCode.Ldsfld:  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));  		break;  	case PE.OpCode.Ldflda:  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));  		break;  	case PE.OpCode.Ldsflda:  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));  		break;  	case PE.OpCode.Stfld:  		instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));  		break;  	case PE.OpCode.Stsfld:  		instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));  		break;  	case PE.OpCode.Ldtoken: {  		if (instruction.Value is FieldRef)  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));  		else if (instruction.Value is MethodRef)  			instructions.Add (new MethodInstruction (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));  		else if (instruction.Value is TypeRef)  			// NOTE: May be a higher-kinded type  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));  		else  			throw new InvalidOperationException ("unexpected ldtoken instruction value");  		break;  	}  	case PE.OpCode.Constrained: {  		var constrained = (TypeRef)instruction.Value;  		if (i >= ctxt.Instructions.Length)  			throw new InvalidOperationException ("invalid instructions");  		instruction = ctxt.Instructions [i++];  		if (instruction.OpCode != PE.OpCode.Callvirt)  			throw new InvalidOperationException ("invalid instruction");  		instructions.Add (new MethodInstruction (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));  		break;  	}  	case PE.OpCode.Call:  		instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Callvirt:  		instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Ldftn:  		instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Ldvirtftn:  		instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Newobj:  		instructions.Add (new MethodInstruction (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Ldind_i1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int8Ref));  		break;  	case PE.OpCode.Ldind_u1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt8Ref));  		break;  	case PE.OpCode.Ldind_i2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int16Ref));  		break;  	case PE.OpCode.Ldind_u2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt16Ref));  		break;  	case PE.OpCode.Ldind_i4:  	case PE.OpCode.Ldind_u4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int32Ref));  		break;  	case PE.OpCode.Ldind_i8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int64Ref));  		break;  	case PE.OpCode.Ldind_i:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.IntNativeRef));  		break;  	case PE.OpCode.Ldind_r4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.SingleRef));  		break;  	case PE.OpCode.Ldind_r8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.DoubleRef));  		break;  	case PE.OpCode.Ldobj:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Stind_i1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int8Ref));  		break;  	case PE.OpCode.Stind_i2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int16Ref));  		break;  	case PE.OpCode.Stind_i4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int32Ref));  		break;  	case PE.OpCode.Stind_i8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int64Ref));  		break;  	case PE.OpCode.Stind_i:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.IntNativeRef));  		break;  	case PE.OpCode.Stind_r4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.SingleRef));  		break;  	case PE.OpCode.Stind_r8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.DoubleRef));  		break;  	case PE.OpCode.Stobj:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Cpobj:  		instructions.Add (new TypeInstruction (offset' TypeOp.Cpobj' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Newarr:  		instructions.Add (new TypeInstruction (offset' TypeOp.Newarr' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Initobj:  		instructions.Add (new TypeInstruction (offset' TypeOp.Initobj' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Castclass:  		instructions.Add (new TypeInstruction (offset' TypeOp.Castclass' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Isinst:  		instructions.Add (new TypeInstruction (offset' TypeOp.Isinst' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Box:  		instructions.Add (new TypeInstruction (offset' TypeOp.Box' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Unbox:  		instructions.Add (new TypeInstruction (offset' TypeOp.Unbox' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Unbox_any:  		instructions.Add (new TypeInstruction (offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Ldelem_i1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int8Ref));  		break;  	case PE.OpCode.Ldelem_u1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt8Ref));  		break;  	case PE.OpCode.Ldelem_i2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int16Ref));  		break;  	case PE.OpCode.Ldelem_u2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt16Ref));  		break;  	case PE.OpCode.Ldelem_i4:  	case PE.OpCode.Ldelem_u4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int32Ref));  		break;  	case PE.OpCode.Ldelem_i:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.IntNativeRef));  		break;  	case PE.OpCode.Ldelem_i8:  		// aka ldelem.u8  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int64Ref));  		break;  	case PE.OpCode.Ldelem_r4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.SingleRef));  		break;  	case PE.OpCode.Ldelem_r8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.DoubleRef));  		break;  	case PE.OpCode.Ldelem:  		// aka ldelem.any  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Stelem_i1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int8Ref));  		break;  	case PE.OpCode.Stelem_i2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int16Ref));  		break;  	case PE.OpCode.Stelem_i4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int32Ref));  		break;  	case PE.OpCode.Stelem_i8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int64Ref));  		break;  	case PE.OpCode.Stelem_i:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.IntNativeRef));  		break;  	case PE.OpCode.Stelem_r4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.SingleRef));  		break;  	case PE.OpCode.Stelem_r8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.DoubleRef));  		break;  	case PE.OpCode.Stelem:  		// aka stelem.any  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Readonly:  		if (i >= ctxt.Instructions.Length)  			throw new InvalidOperationException ("invalid instruction");  		instruction = ctxt.Instructions [i++];  		if (instruction.OpCode != PE.OpCode.Ldelema)  			throw new InvalidOperationException ("invalid instruction");  		instructions.Add (new LdElemAddrInstruction (offset' true' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Ldelema:  		instructions.Add (new LdElemAddrInstruction (offset' false' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Ldc_i4_0:  		instructions.Add (new LdInt32Instruction (offset' 0));  		break;  	case PE.OpCode.Ldc_i4_1:  		instructions.Add (new LdInt32Instruction (offset' 1));  		break;  	case PE.OpCode.Ldc_i4_2:  		instructions.Add (new LdInt32Instruction (offset' 2));  		break;  	case PE.OpCode.Ldc_i4_3:  		instructions.Add (new LdInt32Instruction (offset' 3));  		break;  	case PE.OpCode.Ldc_i4_4:  		instructions.Add (new LdInt32Instruction (offset' 4));  		break;  	case PE.OpCode.Ldc_i4_5:  		instructions.Add (new LdInt32Instruction (offset' 5));  		break;  	case PE.OpCode.Ldc_i4_6:  		instructions.Add (new LdInt32Instruction (offset' 6));  		break;  	case PE.OpCode.Ldc_i4_7:  		instructions.Add (new LdInt32Instruction (offset' 7));  		break;  	case PE.OpCode.Ldc_i4_8:  		instructions.Add (new LdInt32Instruction (offset' 8));  		break;  	case PE.OpCode.Ldc_i4_m1:  		instructions.Add (new LdInt32Instruction (offset' -1));  		break;  	case PE.OpCode.Ldc_i4:  	case PE.OpCode.Ldc_i4_s:  		instructions.Add (new LdInt32Instruction (offset' (int)instruction.Value));  		break;  	case PE.OpCode.Ldc_i8:  		instructions.Add (new LdInt64Instruction (offset' (long)instruction.Value));  		break;  	case PE.OpCode.Ldc_r4:  		instructions.Add (new LdSingleInstruction (offset' (float)instruction.Value));  		break;  	case PE.OpCode.Ldc_r8:  		instructions.Add (new LdDoubleInstruction (offset' (double)instruction.Value));  		break;  	case PE.OpCode.Ldstr:  		instructions.Add (new LdStringInstruction (offset' (string)instruction.Value));  		break;  	case PE.OpCode.Add:  		instructions.Add (new ArithInstruction (offset' ArithOp.Add' false' false));  		break;  	case PE.OpCode.Add_ovf:  		instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' false));  		break;  	case PE.OpCode.Add_ovf_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' true));  		break;  	case PE.OpCode.Sub:  		instructions.Add (new ArithInstruction (offset' ArithOp.Sub' false' false));  		break;  	case PE.OpCode.Sub_ovf:  		instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' false));  		break;  	case PE.OpCode.Sub_ovf_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' true));  		break;  	case PE.OpCode.Mul:  		instructions.Add (new ArithInstruction (offset' ArithOp.Mul' false' false));  		break;  	case PE.OpCode.Mul_ovf:  		instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' false));  		break;  	case PE.OpCode.Mul_ovf_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' true));  		break;  	case PE.OpCode.Div:  		instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' false));  		break;  	case PE.OpCode.Div_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' true));  		break;  	case PE.OpCode.Rem:  		instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' false));  		break;  	case PE.OpCode.Rem_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' true));  		break;  	case PE.OpCode.Neg:  		instructions.Add (new ArithInstruction (offset' ArithOp.Neg' false' false));  		break;  	case PE.OpCode.And:  		instructions.Add (new ArithInstruction (offset' ArithOp.BitAnd' false' false));  		break;  	case PE.OpCode.Or:  		instructions.Add (new ArithInstruction (offset' ArithOp.BitOr' false' false));  		break;  	case PE.OpCode.Xor:  		instructions.Add (new ArithInstruction (offset' ArithOp.BitXor' false' false));  		break;  	case PE.OpCode.Not:  		instructions.Add (new ArithInstruction (offset' ArithOp.BitNot' false' false));  		break;  	case PE.OpCode.Shl:  		instructions.Add (new ArithInstruction (offset' ArithOp.Shl' false' false));  		break;  	case PE.OpCode.Shr:  		instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' false));  		break;  	case PE.OpCode.Shr_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' true));  		break;  	case PE.OpCode.Conv_i1:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' false' false));  		break;  	case PE.OpCode.Conv_u1:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' false' false));  		break;  	case PE.OpCode.Conv_i2:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' false' false));  		break;  	case PE.OpCode.Conv_u2:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' false' false));  		break;  	case PE.OpCode.Conv_i4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' false' false));  		break;  	case PE.OpCode.Conv_u4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' false' false));  		break;  	case PE.OpCode.Conv_i8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' false' false));  		break;  	case PE.OpCode.Conv_u8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' false' false));  		break;  	case PE.OpCode.Conv_i:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' false' false));  		break;  	case PE.OpCode.Conv_u:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' false' false));  		break;  	case PE.OpCode.Conv_r4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Single' false' false));  		break;  	case PE.OpCode.Conv_r8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' false));  		break;  	case PE.OpCode.Conv_r_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' true));  		break;  	case PE.OpCode.Conv_ovf_i1:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' false));  		break;  	case PE.OpCode.Conv_ovf_u1:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' false));  		break;  	case PE.OpCode.Conv_ovf_i2:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' false));  		break;  	case PE.OpCode.Conv_ovf_u2:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' false));  		break;  	case PE.OpCode.Conv_ovf_i4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' false));  		break;  	case PE.OpCode.Conv_ovf_u4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' false));  		break;  	case PE.OpCode.Conv_ovf_i8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' false));  		break;  	case PE.OpCode.Conv_ovf_u8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' false));  		break;  	case PE.OpCode.Conv_ovf_i:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' false));  		break;  	case PE.OpCode.Conv_ovf_u:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' false));  		break;  	case PE.OpCode.Conv_ovf_i1_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' true));  		break;  	case PE.OpCode.Conv_ovf_u1_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' true));  		break;  	case PE.OpCode.Conv_ovf_i2_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' true));  		break;  	case PE.OpCode.Conv_ovf_u2_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' true));  		break;  	case PE.OpCode.Conv_ovf_i4_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' true));  		break;  	case PE.OpCode.Conv_ovf_u4_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' true));  		break;  	case PE.OpCode.Conv_ovf_i8_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' true));  		break;  	case PE.OpCode.Conv_ovf_u8_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' true));  		break;  	case PE.OpCode.Conv_ovf_i_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' true));  		break;  	case PE.OpCode.Conv_ovf_u_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' true));  		break;  	default:  		throw new InvalidOperationException ("invalid instruction");  	}  }  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: if (ehcs != null) {  	// A try instruction begins here with given handlers  	var offset = ctxt.Instructions [i].Offset;  	var tryCtxt = new TryTranslationContext (ctxt' i' ehcs);  	var tryBlock = InstructionsFromContext (tryCtxt);  	var handlers = new Seq<TryInstructionHandler> ();  	foreach (var ehc in ehcs) {  		var handlerCtxt = new HandlerTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.HandlerOffset]' ehc);  		var handlerBlock = InstructionsFromContext (handlerCtxt);  		switch (ehc.Flags) {  		case PE.CorILExceptionClause.Exception:  			handlers.Add (new CatchTryInstructionHandler ((TypeRef)ehc.Class' handlerBlock));  			break;  		case PE.CorILExceptionClause.Filter: {  			var filterCtxt = new FilterTranslationContext (tryCtxt' ctxt.OffsetToIndex [ehc.FilterOffset]' ehc);  			var filterBlock = InstructionsFromContext (filterCtxt);  			handlers.Add (new FilterTryInstructionHandler (filterBlock' handlerBlock));  			break;  		}  		case PE.CorILExceptionClause.Finally:  			handlers.Add (new FinallyTryInstructionHandler (handlerBlock));  			break;  		case PE.CorILExceptionClause.Fault:  			handlers.Add (new FaultTryInstructionHandler (handlerBlock));  			break;  		default:  			throw new ArgumentOutOfRangeException ();  		}  	}  	instructions.Add (new TryInstruction (offset' tryBlock' handlers));  	// Jump over try block  	var nextOffset = ehcs [0].TryOffset + ehcs [0].TryLength;  	if (!ctxt.OffsetToIndex.TryGetValue (nextOffset' out i))  		i = ctxt.Instructions.Length;  }  else {  	var instruction = ctxt.Instructions [i++];  	var offset = instruction.Offset;  	while (instruction.OpCode == PE.OpCode.Unaligned || instruction.OpCode == PE.OpCode.Volatile || instruction.OpCode == PE.OpCode.Tailcall) {  		// Skip over any ignored prefixes' but remember instruction begins at original offset  		// NOTE: What ever happened to the "no." prefix mentioned in the spec?  		if (i >= ctxt.Instructions.Length)  			throw new InvalidOperationException ("invalid instructions");  		instruction = ctxt.Instructions [i++];  	}  	switch (instruction.OpCode) {  	case PE.OpCode.Cpblk:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Cpblk));  		break;  	case PE.OpCode.Initblk:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Initblk));  		break;  	case PE.OpCode.Arglist:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Arglist));  		break;  	case PE.OpCode.Localloc:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Localloc));  		break;  	case PE.OpCode.Jmp:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Jmp));  		break;  	case PE.OpCode.Calli:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Calli));  		break;  	case PE.OpCode.Sizeof:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Sizeof));  		break;  	case PE.OpCode.Mkrefany:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Mkrefany));  		break;  	case PE.OpCode.Refanytype:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanytype));  		break;  	case PE.OpCode.Refanyval:  		instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanyval));  		break;  	case PE.OpCode.Nop:  		instructions.Add (new MiscInstruction (offset' MiscOp.Nop));  		break;  	case PE.OpCode.Break:  		instructions.Add (new MiscInstruction (offset' MiscOp.Break));  		break;  	case PE.OpCode.Dup:  		instructions.Add (new MiscInstruction (offset' MiscOp.Dup));  		break;  	case PE.OpCode.Pop:  		instructions.Add (new MiscInstruction (offset' MiscOp.Pop));  		break;  	case PE.OpCode.Ldnull:  		instructions.Add (new MiscInstruction (offset' MiscOp.Ldnull));  		break;  	case PE.OpCode.Ckfinite:  		instructions.Add (new MiscInstruction (offset' MiscOp.Ckfinite));  		break;  	case PE.OpCode.Throw:  		instructions.Add (new MiscInstruction (offset' MiscOp.Throw));  		break;  	case PE.OpCode.Rethrow:  		instructions.Add (new MiscInstruction (offset' MiscOp.Rethrow));  		break;  	case PE.OpCode.Ldind_ref:  		instructions.Add (new MiscInstruction (offset' MiscOp.LdindRef));  		break;  	case PE.OpCode.Stind_ref:  		instructions.Add (new MiscInstruction (offset' MiscOp.StindRef));  		break;  	case PE.OpCode.Ldelem_ref:  		instructions.Add (new MiscInstruction (offset' MiscOp.LdelemRef));  		break;  	case PE.OpCode.Stelem_ref:  		instructions.Add (new MiscInstruction (offset' MiscOp.StelemRef));  		break;  	case PE.OpCode.Ldlen:  		instructions.Add (new MiscInstruction (offset' MiscOp.Ldlen));  		break;  	case PE.OpCode.Ret:  		if (ctxt.ResultType == null)  			instructions.Add (new MiscInstruction (offset' MiscOp.Ret));  		else  			instructions.Add (new MiscInstruction (offset' MiscOp.RetVal));  		break;  	case PE.OpCode.Endfilter:  		instructions.Add (new MiscInstruction (offset' MiscOp.Endfilter));  		break;  	case PE.OpCode.Endfinally:  		// aka EndFault  		instructions.Add (new MiscInstruction (offset' MiscOp.Endfinally));  		break;  	case PE.OpCode.Br_s:  	case PE.OpCode.Br:  		instructions.Add (new BranchInstruction (offset' BranchOp.Br' false' (int)instruction.Value));  		break;  	case PE.OpCode.Brtrue_s:  	// aka brinst.s  	case PE.OpCode.Brtrue:  		// aka brinst  		instructions.Add (new BranchInstruction (offset' BranchOp.Brtrue' false' (int)instruction.Value));  		break;  	case PE.OpCode.Brfalse_s:  	// aka brzero.s' brnull.s  	case PE.OpCode.Brfalse:  		// aka brzero' brnull  		instructions.Add (new BranchInstruction (offset' BranchOp.Brfalse' false' (int)instruction.Value));  		break;  	case PE.OpCode.Beq:  	case PE.OpCode.Beq_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.Breq' false' (int)instruction.Value));  		break;  	case PE.OpCode.Bne_un:  	case PE.OpCode.Bne_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.Brne' false' (int)instruction.Value));  		break;  	case PE.OpCode.Leave:  	case PE.OpCode.Leave_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.Leave' false' (int)instruction.Value));  		break;  	case PE.OpCode.Blt:  	case PE.OpCode.Blt_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' false' (int)instruction.Value));  		break;  	case PE.OpCode.Blt_un:  	case PE.OpCode.Blt_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' true' (int)instruction.Value));  		break;  	case PE.OpCode.Ble:  	case PE.OpCode.Ble_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' false' (int)instruction.Value));  		break;  	case PE.OpCode.Ble_un:  	case PE.OpCode.Ble_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' true' (int)instruction.Value));  		break;  	case PE.OpCode.Bgt:  	case PE.OpCode.Bgt_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' false' (int)instruction.Value));  		break;  	case PE.OpCode.Bgt_un:  	case PE.OpCode.Bgt_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' true' (int)instruction.Value));  		break;  	case PE.OpCode.Bge:  	case PE.OpCode.Bge_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' false' (int)instruction.Value));  		break;  	case PE.OpCode.Bge_un:  	case PE.OpCode.Bge_un_s:  		instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' true' (int)instruction.Value));  		break;  	case PE.OpCode.Switch:  		instructions.Add (new SwitchInstruction (offset' (Seq<int>)instruction.Value));  		break;  	case PE.OpCode.Ceq:  		instructions.Add (new CompareInstruction (offset' CompareOp.Ceq' false));  		break;  	case PE.OpCode.Clt:  		instructions.Add (new CompareInstruction (offset' CompareOp.Clt' false));  		break;  	case PE.OpCode.Clt_un:  		instructions.Add (new CompareInstruction (offset' CompareOp.Clt' true));  		break;  	case PE.OpCode.Cgt:  		instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' false));  		break;  	case PE.OpCode.Cgt_un:  		instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' true));  		break;  	case PE.OpCode.Ldarg_0:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));  		break;  	case PE.OpCode.Ldarg_1:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));  		break;  	case PE.OpCode.Ldarg_2:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));  		break;  	case PE.OpCode.Ldarg_3:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));  		break;  	case PE.OpCode.Ldarg:  	case PE.OpCode.Ldarg_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));  		break;  	case PE.OpCode.Ldarga:  	case PE.OpCode.Ldarga_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));  		break;  	case PE.OpCode.Starg:  	case PE.OpCode.Starg_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));  		break;  	case PE.OpCode.Ldloc_0:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 0));  		break;  	case PE.OpCode.Ldloc_1:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 1));  		break;  	case PE.OpCode.Ldloc_2:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 2));  		break;  	case PE.OpCode.Ldloc_3:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 3));  		break;  	case PE.OpCode.Ldloc:  	case PE.OpCode.Ldloc_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));  		break;  	case PE.OpCode.Ldloca:  	case PE.OpCode.Ldloca_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));  		break;  	case PE.OpCode.Stloc_0:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 0));  		break;  	case PE.OpCode.Stloc_1:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 1));  		break;  	case PE.OpCode.Stloc_2:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 2));  		break;  	case PE.OpCode.Stloc_3:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 3));  		break;  	case PE.OpCode.Stloc:  	case PE.OpCode.Stloc_s:  		instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));  		break;  	case PE.OpCode.Ldfld:  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));  		break;  	case PE.OpCode.Ldsfld:  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));  		break;  	case PE.OpCode.Ldflda:  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));  		break;  	case PE.OpCode.Ldsflda:  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));  		break;  	case PE.OpCode.Stfld:  		instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));  		break;  	case PE.OpCode.Stsfld:  		instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));  		break;  	case PE.OpCode.Ldtoken: {  		if (instruction.Value is FieldRef)  			instructions.Add (new FieldInstruction (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));  		else if (instruction.Value is MethodRef)  			instructions.Add (new MethodInstruction (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));  		else if (instruction.Value is TypeRef)  			// NOTE: May be a higher-kinded type  			instructions.Add (new TypeInstruction (offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));  		else  			throw new InvalidOperationException ("unexpected ldtoken instruction value");  		break;  	}  	case PE.OpCode.Constrained: {  		var constrained = (TypeRef)instruction.Value;  		if (i >= ctxt.Instructions.Length)  			throw new InvalidOperationException ("invalid instructions");  		instruction = ctxt.Instructions [i++];  		if (instruction.OpCode != PE.OpCode.Callvirt)  			throw new InvalidOperationException ("invalid instruction");  		instructions.Add (new MethodInstruction (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));  		break;  	}  	case PE.OpCode.Call:  		instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Callvirt:  		instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Ldftn:  		instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Ldvirtftn:  		instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Newobj:  		instructions.Add (new MethodInstruction (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));  		break;  	case PE.OpCode.Ldind_i1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int8Ref));  		break;  	case PE.OpCode.Ldind_u1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt8Ref));  		break;  	case PE.OpCode.Ldind_i2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int16Ref));  		break;  	case PE.OpCode.Ldind_u2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt16Ref));  		break;  	case PE.OpCode.Ldind_i4:  	case PE.OpCode.Ldind_u4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int32Ref));  		break;  	case PE.OpCode.Ldind_i8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int64Ref));  		break;  	case PE.OpCode.Ldind_i:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.IntNativeRef));  		break;  	case PE.OpCode.Ldind_r4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.SingleRef));  		break;  	case PE.OpCode.Ldind_r8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.DoubleRef));  		break;  	case PE.OpCode.Ldobj:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Stind_i1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int8Ref));  		break;  	case PE.OpCode.Stind_i2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int16Ref));  		break;  	case PE.OpCode.Stind_i4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int32Ref));  		break;  	case PE.OpCode.Stind_i8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int64Ref));  		break;  	case PE.OpCode.Stind_i:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.IntNativeRef));  		break;  	case PE.OpCode.Stind_r4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.SingleRef));  		break;  	case PE.OpCode.Stind_r8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.DoubleRef));  		break;  	case PE.OpCode.Stobj:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Cpobj:  		instructions.Add (new TypeInstruction (offset' TypeOp.Cpobj' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Newarr:  		instructions.Add (new TypeInstruction (offset' TypeOp.Newarr' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Initobj:  		instructions.Add (new TypeInstruction (offset' TypeOp.Initobj' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Castclass:  		instructions.Add (new TypeInstruction (offset' TypeOp.Castclass' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Isinst:  		instructions.Add (new TypeInstruction (offset' TypeOp.Isinst' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Box:  		instructions.Add (new TypeInstruction (offset' TypeOp.Box' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Unbox:  		instructions.Add (new TypeInstruction (offset' TypeOp.Unbox' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Unbox_any:  		instructions.Add (new TypeInstruction (offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Ldelem_i1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int8Ref));  		break;  	case PE.OpCode.Ldelem_u1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt8Ref));  		break;  	case PE.OpCode.Ldelem_i2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int16Ref));  		break;  	case PE.OpCode.Ldelem_u2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt16Ref));  		break;  	case PE.OpCode.Ldelem_i4:  	case PE.OpCode.Ldelem_u4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int32Ref));  		break;  	case PE.OpCode.Ldelem_i:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.IntNativeRef));  		break;  	case PE.OpCode.Ldelem_i8:  		// aka ldelem.u8  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int64Ref));  		break;  	case PE.OpCode.Ldelem_r4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.SingleRef));  		break;  	case PE.OpCode.Ldelem_r8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.DoubleRef));  		break;  	case PE.OpCode.Ldelem:  		// aka ldelem.any  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Stelem_i1:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int8Ref));  		break;  	case PE.OpCode.Stelem_i2:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int16Ref));  		break;  	case PE.OpCode.Stelem_i4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int32Ref));  		break;  	case PE.OpCode.Stelem_i8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int64Ref));  		break;  	case PE.OpCode.Stelem_i:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.IntNativeRef));  		break;  	case PE.OpCode.Stelem_r4:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.SingleRef));  		break;  	case PE.OpCode.Stelem_r8:  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.DoubleRef));  		break;  	case PE.OpCode.Stelem:  		// aka stelem.any  		instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Readonly:  		if (i >= ctxt.Instructions.Length)  			throw new InvalidOperationException ("invalid instruction");  		instruction = ctxt.Instructions [i++];  		if (instruction.OpCode != PE.OpCode.Ldelema)  			throw new InvalidOperationException ("invalid instruction");  		instructions.Add (new LdElemAddrInstruction (offset' true' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Ldelema:  		instructions.Add (new LdElemAddrInstruction (offset' false' (TypeRef)instruction.Value));  		break;  	case PE.OpCode.Ldc_i4_0:  		instructions.Add (new LdInt32Instruction (offset' 0));  		break;  	case PE.OpCode.Ldc_i4_1:  		instructions.Add (new LdInt32Instruction (offset' 1));  		break;  	case PE.OpCode.Ldc_i4_2:  		instructions.Add (new LdInt32Instruction (offset' 2));  		break;  	case PE.OpCode.Ldc_i4_3:  		instructions.Add (new LdInt32Instruction (offset' 3));  		break;  	case PE.OpCode.Ldc_i4_4:  		instructions.Add (new LdInt32Instruction (offset' 4));  		break;  	case PE.OpCode.Ldc_i4_5:  		instructions.Add (new LdInt32Instruction (offset' 5));  		break;  	case PE.OpCode.Ldc_i4_6:  		instructions.Add (new LdInt32Instruction (offset' 6));  		break;  	case PE.OpCode.Ldc_i4_7:  		instructions.Add (new LdInt32Instruction (offset' 7));  		break;  	case PE.OpCode.Ldc_i4_8:  		instructions.Add (new LdInt32Instruction (offset' 8));  		break;  	case PE.OpCode.Ldc_i4_m1:  		instructions.Add (new LdInt32Instruction (offset' -1));  		break;  	case PE.OpCode.Ldc_i4:  	case PE.OpCode.Ldc_i4_s:  		instructions.Add (new LdInt32Instruction (offset' (int)instruction.Value));  		break;  	case PE.OpCode.Ldc_i8:  		instructions.Add (new LdInt64Instruction (offset' (long)instruction.Value));  		break;  	case PE.OpCode.Ldc_r4:  		instructions.Add (new LdSingleInstruction (offset' (float)instruction.Value));  		break;  	case PE.OpCode.Ldc_r8:  		instructions.Add (new LdDoubleInstruction (offset' (double)instruction.Value));  		break;  	case PE.OpCode.Ldstr:  		instructions.Add (new LdStringInstruction (offset' (string)instruction.Value));  		break;  	case PE.OpCode.Add:  		instructions.Add (new ArithInstruction (offset' ArithOp.Add' false' false));  		break;  	case PE.OpCode.Add_ovf:  		instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' false));  		break;  	case PE.OpCode.Add_ovf_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' true));  		break;  	case PE.OpCode.Sub:  		instructions.Add (new ArithInstruction (offset' ArithOp.Sub' false' false));  		break;  	case PE.OpCode.Sub_ovf:  		instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' false));  		break;  	case PE.OpCode.Sub_ovf_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' true));  		break;  	case PE.OpCode.Mul:  		instructions.Add (new ArithInstruction (offset' ArithOp.Mul' false' false));  		break;  	case PE.OpCode.Mul_ovf:  		instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' false));  		break;  	case PE.OpCode.Mul_ovf_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' true));  		break;  	case PE.OpCode.Div:  		instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' false));  		break;  	case PE.OpCode.Div_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' true));  		break;  	case PE.OpCode.Rem:  		instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' false));  		break;  	case PE.OpCode.Rem_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' true));  		break;  	case PE.OpCode.Neg:  		instructions.Add (new ArithInstruction (offset' ArithOp.Neg' false' false));  		break;  	case PE.OpCode.And:  		instructions.Add (new ArithInstruction (offset' ArithOp.BitAnd' false' false));  		break;  	case PE.OpCode.Or:  		instructions.Add (new ArithInstruction (offset' ArithOp.BitOr' false' false));  		break;  	case PE.OpCode.Xor:  		instructions.Add (new ArithInstruction (offset' ArithOp.BitXor' false' false));  		break;  	case PE.OpCode.Not:  		instructions.Add (new ArithInstruction (offset' ArithOp.BitNot' false' false));  		break;  	case PE.OpCode.Shl:  		instructions.Add (new ArithInstruction (offset' ArithOp.Shl' false' false));  		break;  	case PE.OpCode.Shr:  		instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' false));  		break;  	case PE.OpCode.Shr_un:  		instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' true));  		break;  	case PE.OpCode.Conv_i1:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' false' false));  		break;  	case PE.OpCode.Conv_u1:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' false' false));  		break;  	case PE.OpCode.Conv_i2:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' false' false));  		break;  	case PE.OpCode.Conv_u2:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' false' false));  		break;  	case PE.OpCode.Conv_i4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' false' false));  		break;  	case PE.OpCode.Conv_u4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' false' false));  		break;  	case PE.OpCode.Conv_i8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' false' false));  		break;  	case PE.OpCode.Conv_u8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' false' false));  		break;  	case PE.OpCode.Conv_i:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' false' false));  		break;  	case PE.OpCode.Conv_u:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' false' false));  		break;  	case PE.OpCode.Conv_r4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Single' false' false));  		break;  	case PE.OpCode.Conv_r8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' false));  		break;  	case PE.OpCode.Conv_r_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' true));  		break;  	case PE.OpCode.Conv_ovf_i1:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' false));  		break;  	case PE.OpCode.Conv_ovf_u1:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' false));  		break;  	case PE.OpCode.Conv_ovf_i2:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' false));  		break;  	case PE.OpCode.Conv_ovf_u2:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' false));  		break;  	case PE.OpCode.Conv_ovf_i4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' false));  		break;  	case PE.OpCode.Conv_ovf_u4:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' false));  		break;  	case PE.OpCode.Conv_ovf_i8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' false));  		break;  	case PE.OpCode.Conv_ovf_u8:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' false));  		break;  	case PE.OpCode.Conv_ovf_i:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' false));  		break;  	case PE.OpCode.Conv_ovf_u:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' false));  		break;  	case PE.OpCode.Conv_ovf_i1_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' true));  		break;  	case PE.OpCode.Conv_ovf_u1_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' true));  		break;  	case PE.OpCode.Conv_ovf_i2_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' true));  		break;  	case PE.OpCode.Conv_ovf_u2_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' true));  		break;  	case PE.OpCode.Conv_ovf_i4_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' true));  		break;  	case PE.OpCode.Conv_ovf_u4_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' true));  		break;  	case PE.OpCode.Conv_ovf_i8_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' true));  		break;  	case PE.OpCode.Conv_ovf_u8_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' true));  		break;  	case PE.OpCode.Conv_ovf_i_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' true));  		break;  	case PE.OpCode.Conv_ovf_u_un:  		instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' true));  		break;  	default:  		throw new InvalidOperationException ("invalid instruction");  	}  }  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: switch (instruction.OpCode) {  case PE.OpCode.Cpblk:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Cpblk));  	break;  case PE.OpCode.Initblk:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Initblk));  	break;  case PE.OpCode.Arglist:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Arglist));  	break;  case PE.OpCode.Localloc:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Localloc));  	break;  case PE.OpCode.Jmp:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Jmp));  	break;  case PE.OpCode.Calli:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Calli));  	break;  case PE.OpCode.Sizeof:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Sizeof));  	break;  case PE.OpCode.Mkrefany:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Mkrefany));  	break;  case PE.OpCode.Refanytype:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanytype));  	break;  case PE.OpCode.Refanyval:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanyval));  	break;  case PE.OpCode.Nop:  	instructions.Add (new MiscInstruction (offset' MiscOp.Nop));  	break;  case PE.OpCode.Break:  	instructions.Add (new MiscInstruction (offset' MiscOp.Break));  	break;  case PE.OpCode.Dup:  	instructions.Add (new MiscInstruction (offset' MiscOp.Dup));  	break;  case PE.OpCode.Pop:  	instructions.Add (new MiscInstruction (offset' MiscOp.Pop));  	break;  case PE.OpCode.Ldnull:  	instructions.Add (new MiscInstruction (offset' MiscOp.Ldnull));  	break;  case PE.OpCode.Ckfinite:  	instructions.Add (new MiscInstruction (offset' MiscOp.Ckfinite));  	break;  case PE.OpCode.Throw:  	instructions.Add (new MiscInstruction (offset' MiscOp.Throw));  	break;  case PE.OpCode.Rethrow:  	instructions.Add (new MiscInstruction (offset' MiscOp.Rethrow));  	break;  case PE.OpCode.Ldind_ref:  	instructions.Add (new MiscInstruction (offset' MiscOp.LdindRef));  	break;  case PE.OpCode.Stind_ref:  	instructions.Add (new MiscInstruction (offset' MiscOp.StindRef));  	break;  case PE.OpCode.Ldelem_ref:  	instructions.Add (new MiscInstruction (offset' MiscOp.LdelemRef));  	break;  case PE.OpCode.Stelem_ref:  	instructions.Add (new MiscInstruction (offset' MiscOp.StelemRef));  	break;  case PE.OpCode.Ldlen:  	instructions.Add (new MiscInstruction (offset' MiscOp.Ldlen));  	break;  case PE.OpCode.Ret:  	if (ctxt.ResultType == null)  		instructions.Add (new MiscInstruction (offset' MiscOp.Ret));  	else  		instructions.Add (new MiscInstruction (offset' MiscOp.RetVal));  	break;  case PE.OpCode.Endfilter:  	instructions.Add (new MiscInstruction (offset' MiscOp.Endfilter));  	break;  case PE.OpCode.Endfinally:  	// aka EndFault  	instructions.Add (new MiscInstruction (offset' MiscOp.Endfinally));  	break;  case PE.OpCode.Br_s:  case PE.OpCode.Br:  	instructions.Add (new BranchInstruction (offset' BranchOp.Br' false' (int)instruction.Value));  	break;  case PE.OpCode.Brtrue_s:  // aka brinst.s  case PE.OpCode.Brtrue:  	// aka brinst  	instructions.Add (new BranchInstruction (offset' BranchOp.Brtrue' false' (int)instruction.Value));  	break;  case PE.OpCode.Brfalse_s:  // aka brzero.s' brnull.s  case PE.OpCode.Brfalse:  	// aka brzero' brnull  	instructions.Add (new BranchInstruction (offset' BranchOp.Brfalse' false' (int)instruction.Value));  	break;  case PE.OpCode.Beq:  case PE.OpCode.Beq_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.Breq' false' (int)instruction.Value));  	break;  case PE.OpCode.Bne_un:  case PE.OpCode.Bne_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.Brne' false' (int)instruction.Value));  	break;  case PE.OpCode.Leave:  case PE.OpCode.Leave_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.Leave' false' (int)instruction.Value));  	break;  case PE.OpCode.Blt:  case PE.OpCode.Blt_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' false' (int)instruction.Value));  	break;  case PE.OpCode.Blt_un:  case PE.OpCode.Blt_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' true' (int)instruction.Value));  	break;  case PE.OpCode.Ble:  case PE.OpCode.Ble_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' false' (int)instruction.Value));  	break;  case PE.OpCode.Ble_un:  case PE.OpCode.Ble_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' true' (int)instruction.Value));  	break;  case PE.OpCode.Bgt:  case PE.OpCode.Bgt_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' false' (int)instruction.Value));  	break;  case PE.OpCode.Bgt_un:  case PE.OpCode.Bgt_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' true' (int)instruction.Value));  	break;  case PE.OpCode.Bge:  case PE.OpCode.Bge_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' false' (int)instruction.Value));  	break;  case PE.OpCode.Bge_un:  case PE.OpCode.Bge_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' true' (int)instruction.Value));  	break;  case PE.OpCode.Switch:  	instructions.Add (new SwitchInstruction (offset' (Seq<int>)instruction.Value));  	break;  case PE.OpCode.Ceq:  	instructions.Add (new CompareInstruction (offset' CompareOp.Ceq' false));  	break;  case PE.OpCode.Clt:  	instructions.Add (new CompareInstruction (offset' CompareOp.Clt' false));  	break;  case PE.OpCode.Clt_un:  	instructions.Add (new CompareInstruction (offset' CompareOp.Clt' true));  	break;  case PE.OpCode.Cgt:  	instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' false));  	break;  case PE.OpCode.Cgt_un:  	instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' true));  	break;  case PE.OpCode.Ldarg_0:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));  	break;  case PE.OpCode.Ldarg_1:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));  	break;  case PE.OpCode.Ldarg_2:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));  	break;  case PE.OpCode.Ldarg_3:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));  	break;  case PE.OpCode.Ldarg:  case PE.OpCode.Ldarg_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));  	break;  case PE.OpCode.Ldarga:  case PE.OpCode.Ldarga_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));  	break;  case PE.OpCode.Starg:  case PE.OpCode.Starg_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));  	break;  case PE.OpCode.Ldloc_0:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 0));  	break;  case PE.OpCode.Ldloc_1:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 1));  	break;  case PE.OpCode.Ldloc_2:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 2));  	break;  case PE.OpCode.Ldloc_3:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 3));  	break;  case PE.OpCode.Ldloc:  case PE.OpCode.Ldloc_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));  	break;  case PE.OpCode.Ldloca:  case PE.OpCode.Ldloca_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));  	break;  case PE.OpCode.Stloc_0:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 0));  	break;  case PE.OpCode.Stloc_1:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 1));  	break;  case PE.OpCode.Stloc_2:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 2));  	break;  case PE.OpCode.Stloc_3:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 3));  	break;  case PE.OpCode.Stloc:  case PE.OpCode.Stloc_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));  	break;  case PE.OpCode.Ldfld:  	instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));  	break;  case PE.OpCode.Ldsfld:  	instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));  	break;  case PE.OpCode.Ldflda:  	instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));  	break;  case PE.OpCode.Ldsflda:  	instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));  	break;  case PE.OpCode.Stfld:  	instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));  	break;  case PE.OpCode.Stsfld:  	instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));  	break;  case PE.OpCode.Ldtoken: {  	if (instruction.Value is FieldRef)  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));  	else if (instruction.Value is MethodRef)  		instructions.Add (new MethodInstruction (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));  	else if (instruction.Value is TypeRef)  		// NOTE: May be a higher-kinded type  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));  	else  		throw new InvalidOperationException ("unexpected ldtoken instruction value");  	break;  }  case PE.OpCode.Constrained: {  	var constrained = (TypeRef)instruction.Value;  	if (i >= ctxt.Instructions.Length)  		throw new InvalidOperationException ("invalid instructions");  	instruction = ctxt.Instructions [i++];  	if (instruction.OpCode != PE.OpCode.Callvirt)  		throw new InvalidOperationException ("invalid instruction");  	instructions.Add (new MethodInstruction (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));  	break;  }  case PE.OpCode.Call:  	instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Callvirt:  	instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Ldftn:  	instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Ldvirtftn:  	instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Newobj:  	instructions.Add (new MethodInstruction (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Ldind_i1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int8Ref));  	break;  case PE.OpCode.Ldind_u1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt8Ref));  	break;  case PE.OpCode.Ldind_i2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int16Ref));  	break;  case PE.OpCode.Ldind_u2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt16Ref));  	break;  case PE.OpCode.Ldind_i4:  case PE.OpCode.Ldind_u4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int32Ref));  	break;  case PE.OpCode.Ldind_i8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int64Ref));  	break;  case PE.OpCode.Ldind_i:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.IntNativeRef));  	break;  case PE.OpCode.Ldind_r4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.SingleRef));  	break;  case PE.OpCode.Ldind_r8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.DoubleRef));  	break;  case PE.OpCode.Ldobj:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Stind_i1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int8Ref));  	break;  case PE.OpCode.Stind_i2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int16Ref));  	break;  case PE.OpCode.Stind_i4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int32Ref));  	break;  case PE.OpCode.Stind_i8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int64Ref));  	break;  case PE.OpCode.Stind_i:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.IntNativeRef));  	break;  case PE.OpCode.Stind_r4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.SingleRef));  	break;  case PE.OpCode.Stind_r8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.DoubleRef));  	break;  case PE.OpCode.Stobj:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Cpobj:  	instructions.Add (new TypeInstruction (offset' TypeOp.Cpobj' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Newarr:  	instructions.Add (new TypeInstruction (offset' TypeOp.Newarr' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Initobj:  	instructions.Add (new TypeInstruction (offset' TypeOp.Initobj' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Castclass:  	instructions.Add (new TypeInstruction (offset' TypeOp.Castclass' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Isinst:  	instructions.Add (new TypeInstruction (offset' TypeOp.Isinst' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Box:  	instructions.Add (new TypeInstruction (offset' TypeOp.Box' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Unbox:  	instructions.Add (new TypeInstruction (offset' TypeOp.Unbox' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Unbox_any:  	instructions.Add (new TypeInstruction (offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Ldelem_i1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int8Ref));  	break;  case PE.OpCode.Ldelem_u1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt8Ref));  	break;  case PE.OpCode.Ldelem_i2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int16Ref));  	break;  case PE.OpCode.Ldelem_u2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt16Ref));  	break;  case PE.OpCode.Ldelem_i4:  case PE.OpCode.Ldelem_u4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int32Ref));  	break;  case PE.OpCode.Ldelem_i:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.IntNativeRef));  	break;  case PE.OpCode.Ldelem_i8:  	// aka ldelem.u8  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int64Ref));  	break;  case PE.OpCode.Ldelem_r4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.SingleRef));  	break;  case PE.OpCode.Ldelem_r8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.DoubleRef));  	break;  case PE.OpCode.Ldelem:  	// aka ldelem.any  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Stelem_i1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int8Ref));  	break;  case PE.OpCode.Stelem_i2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int16Ref));  	break;  case PE.OpCode.Stelem_i4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int32Ref));  	break;  case PE.OpCode.Stelem_i8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int64Ref));  	break;  case PE.OpCode.Stelem_i:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.IntNativeRef));  	break;  case PE.OpCode.Stelem_r4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.SingleRef));  	break;  case PE.OpCode.Stelem_r8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.DoubleRef));  	break;  case PE.OpCode.Stelem:  	// aka stelem.any  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Readonly:  	if (i >= ctxt.Instructions.Length)  		throw new InvalidOperationException ("invalid instruction");  	instruction = ctxt.Instructions [i++];  	if (instruction.OpCode != PE.OpCode.Ldelema)  		throw new InvalidOperationException ("invalid instruction");  	instructions.Add (new LdElemAddrInstruction (offset' true' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Ldelema:  	instructions.Add (new LdElemAddrInstruction (offset' false' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Ldc_i4_0:  	instructions.Add (new LdInt32Instruction (offset' 0));  	break;  case PE.OpCode.Ldc_i4_1:  	instructions.Add (new LdInt32Instruction (offset' 1));  	break;  case PE.OpCode.Ldc_i4_2:  	instructions.Add (new LdInt32Instruction (offset' 2));  	break;  case PE.OpCode.Ldc_i4_3:  	instructions.Add (new LdInt32Instruction (offset' 3));  	break;  case PE.OpCode.Ldc_i4_4:  	instructions.Add (new LdInt32Instruction (offset' 4));  	break;  case PE.OpCode.Ldc_i4_5:  	instructions.Add (new LdInt32Instruction (offset' 5));  	break;  case PE.OpCode.Ldc_i4_6:  	instructions.Add (new LdInt32Instruction (offset' 6));  	break;  case PE.OpCode.Ldc_i4_7:  	instructions.Add (new LdInt32Instruction (offset' 7));  	break;  case PE.OpCode.Ldc_i4_8:  	instructions.Add (new LdInt32Instruction (offset' 8));  	break;  case PE.OpCode.Ldc_i4_m1:  	instructions.Add (new LdInt32Instruction (offset' -1));  	break;  case PE.OpCode.Ldc_i4:  case PE.OpCode.Ldc_i4_s:  	instructions.Add (new LdInt32Instruction (offset' (int)instruction.Value));  	break;  case PE.OpCode.Ldc_i8:  	instructions.Add (new LdInt64Instruction (offset' (long)instruction.Value));  	break;  case PE.OpCode.Ldc_r4:  	instructions.Add (new LdSingleInstruction (offset' (float)instruction.Value));  	break;  case PE.OpCode.Ldc_r8:  	instructions.Add (new LdDoubleInstruction (offset' (double)instruction.Value));  	break;  case PE.OpCode.Ldstr:  	instructions.Add (new LdStringInstruction (offset' (string)instruction.Value));  	break;  case PE.OpCode.Add:  	instructions.Add (new ArithInstruction (offset' ArithOp.Add' false' false));  	break;  case PE.OpCode.Add_ovf:  	instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' false));  	break;  case PE.OpCode.Add_ovf_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' true));  	break;  case PE.OpCode.Sub:  	instructions.Add (new ArithInstruction (offset' ArithOp.Sub' false' false));  	break;  case PE.OpCode.Sub_ovf:  	instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' false));  	break;  case PE.OpCode.Sub_ovf_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' true));  	break;  case PE.OpCode.Mul:  	instructions.Add (new ArithInstruction (offset' ArithOp.Mul' false' false));  	break;  case PE.OpCode.Mul_ovf:  	instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' false));  	break;  case PE.OpCode.Mul_ovf_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' true));  	break;  case PE.OpCode.Div:  	instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' false));  	break;  case PE.OpCode.Div_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' true));  	break;  case PE.OpCode.Rem:  	instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' false));  	break;  case PE.OpCode.Rem_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' true));  	break;  case PE.OpCode.Neg:  	instructions.Add (new ArithInstruction (offset' ArithOp.Neg' false' false));  	break;  case PE.OpCode.And:  	instructions.Add (new ArithInstruction (offset' ArithOp.BitAnd' false' false));  	break;  case PE.OpCode.Or:  	instructions.Add (new ArithInstruction (offset' ArithOp.BitOr' false' false));  	break;  case PE.OpCode.Xor:  	instructions.Add (new ArithInstruction (offset' ArithOp.BitXor' false' false));  	break;  case PE.OpCode.Not:  	instructions.Add (new ArithInstruction (offset' ArithOp.BitNot' false' false));  	break;  case PE.OpCode.Shl:  	instructions.Add (new ArithInstruction (offset' ArithOp.Shl' false' false));  	break;  case PE.OpCode.Shr:  	instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' false));  	break;  case PE.OpCode.Shr_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' true));  	break;  case PE.OpCode.Conv_i1:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' false' false));  	break;  case PE.OpCode.Conv_u1:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' false' false));  	break;  case PE.OpCode.Conv_i2:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' false' false));  	break;  case PE.OpCode.Conv_u2:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' false' false));  	break;  case PE.OpCode.Conv_i4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' false' false));  	break;  case PE.OpCode.Conv_u4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' false' false));  	break;  case PE.OpCode.Conv_i8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' false' false));  	break;  case PE.OpCode.Conv_u8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' false' false));  	break;  case PE.OpCode.Conv_i:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' false' false));  	break;  case PE.OpCode.Conv_u:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' false' false));  	break;  case PE.OpCode.Conv_r4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Single' false' false));  	break;  case PE.OpCode.Conv_r8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' false));  	break;  case PE.OpCode.Conv_r_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' true));  	break;  case PE.OpCode.Conv_ovf_i1:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' false));  	break;  case PE.OpCode.Conv_ovf_u1:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' false));  	break;  case PE.OpCode.Conv_ovf_i2:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' false));  	break;  case PE.OpCode.Conv_ovf_u2:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' false));  	break;  case PE.OpCode.Conv_ovf_i4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' false));  	break;  case PE.OpCode.Conv_ovf_u4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' false));  	break;  case PE.OpCode.Conv_ovf_i8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' false));  	break;  case PE.OpCode.Conv_ovf_u8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' false));  	break;  case PE.OpCode.Conv_ovf_i:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' false));  	break;  case PE.OpCode.Conv_ovf_u:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' false));  	break;  case PE.OpCode.Conv_ovf_i1_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' true));  	break;  case PE.OpCode.Conv_ovf_u1_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' true));  	break;  case PE.OpCode.Conv_ovf_i2_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' true));  	break;  case PE.OpCode.Conv_ovf_u2_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' true));  	break;  case PE.OpCode.Conv_ovf_i4_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' true));  	break;  case PE.OpCode.Conv_ovf_u4_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' true));  	break;  case PE.OpCode.Conv_ovf_i8_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' true));  	break;  case PE.OpCode.Conv_ovf_u8_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' true));  	break;  case PE.OpCode.Conv_ovf_i_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' true));  	break;  case PE.OpCode.Conv_ovf_u_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' true));  	break;  default:  	throw new InvalidOperationException ("invalid instruction");  }  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: switch (instruction.OpCode) {  case PE.OpCode.Cpblk:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Cpblk));  	break;  case PE.OpCode.Initblk:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Initblk));  	break;  case PE.OpCode.Arglist:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Arglist));  	break;  case PE.OpCode.Localloc:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Localloc));  	break;  case PE.OpCode.Jmp:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Jmp));  	break;  case PE.OpCode.Calli:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Calli));  	break;  case PE.OpCode.Sizeof:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Sizeof));  	break;  case PE.OpCode.Mkrefany:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Mkrefany));  	break;  case PE.OpCode.Refanytype:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanytype));  	break;  case PE.OpCode.Refanyval:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanyval));  	break;  case PE.OpCode.Nop:  	instructions.Add (new MiscInstruction (offset' MiscOp.Nop));  	break;  case PE.OpCode.Break:  	instructions.Add (new MiscInstruction (offset' MiscOp.Break));  	break;  case PE.OpCode.Dup:  	instructions.Add (new MiscInstruction (offset' MiscOp.Dup));  	break;  case PE.OpCode.Pop:  	instructions.Add (new MiscInstruction (offset' MiscOp.Pop));  	break;  case PE.OpCode.Ldnull:  	instructions.Add (new MiscInstruction (offset' MiscOp.Ldnull));  	break;  case PE.OpCode.Ckfinite:  	instructions.Add (new MiscInstruction (offset' MiscOp.Ckfinite));  	break;  case PE.OpCode.Throw:  	instructions.Add (new MiscInstruction (offset' MiscOp.Throw));  	break;  case PE.OpCode.Rethrow:  	instructions.Add (new MiscInstruction (offset' MiscOp.Rethrow));  	break;  case PE.OpCode.Ldind_ref:  	instructions.Add (new MiscInstruction (offset' MiscOp.LdindRef));  	break;  case PE.OpCode.Stind_ref:  	instructions.Add (new MiscInstruction (offset' MiscOp.StindRef));  	break;  case PE.OpCode.Ldelem_ref:  	instructions.Add (new MiscInstruction (offset' MiscOp.LdelemRef));  	break;  case PE.OpCode.Stelem_ref:  	instructions.Add (new MiscInstruction (offset' MiscOp.StelemRef));  	break;  case PE.OpCode.Ldlen:  	instructions.Add (new MiscInstruction (offset' MiscOp.Ldlen));  	break;  case PE.OpCode.Ret:  	if (ctxt.ResultType == null)  		instructions.Add (new MiscInstruction (offset' MiscOp.Ret));  	else  		instructions.Add (new MiscInstruction (offset' MiscOp.RetVal));  	break;  case PE.OpCode.Endfilter:  	instructions.Add (new MiscInstruction (offset' MiscOp.Endfilter));  	break;  case PE.OpCode.Endfinally:  	// aka EndFault  	instructions.Add (new MiscInstruction (offset' MiscOp.Endfinally));  	break;  case PE.OpCode.Br_s:  case PE.OpCode.Br:  	instructions.Add (new BranchInstruction (offset' BranchOp.Br' false' (int)instruction.Value));  	break;  case PE.OpCode.Brtrue_s:  // aka brinst.s  case PE.OpCode.Brtrue:  	// aka brinst  	instructions.Add (new BranchInstruction (offset' BranchOp.Brtrue' false' (int)instruction.Value));  	break;  case PE.OpCode.Brfalse_s:  // aka brzero.s' brnull.s  case PE.OpCode.Brfalse:  	// aka brzero' brnull  	instructions.Add (new BranchInstruction (offset' BranchOp.Brfalse' false' (int)instruction.Value));  	break;  case PE.OpCode.Beq:  case PE.OpCode.Beq_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.Breq' false' (int)instruction.Value));  	break;  case PE.OpCode.Bne_un:  case PE.OpCode.Bne_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.Brne' false' (int)instruction.Value));  	break;  case PE.OpCode.Leave:  case PE.OpCode.Leave_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.Leave' false' (int)instruction.Value));  	break;  case PE.OpCode.Blt:  case PE.OpCode.Blt_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' false' (int)instruction.Value));  	break;  case PE.OpCode.Blt_un:  case PE.OpCode.Blt_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' true' (int)instruction.Value));  	break;  case PE.OpCode.Ble:  case PE.OpCode.Ble_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' false' (int)instruction.Value));  	break;  case PE.OpCode.Ble_un:  case PE.OpCode.Ble_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' true' (int)instruction.Value));  	break;  case PE.OpCode.Bgt:  case PE.OpCode.Bgt_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' false' (int)instruction.Value));  	break;  case PE.OpCode.Bgt_un:  case PE.OpCode.Bgt_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' true' (int)instruction.Value));  	break;  case PE.OpCode.Bge:  case PE.OpCode.Bge_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' false' (int)instruction.Value));  	break;  case PE.OpCode.Bge_un:  case PE.OpCode.Bge_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' true' (int)instruction.Value));  	break;  case PE.OpCode.Switch:  	instructions.Add (new SwitchInstruction (offset' (Seq<int>)instruction.Value));  	break;  case PE.OpCode.Ceq:  	instructions.Add (new CompareInstruction (offset' CompareOp.Ceq' false));  	break;  case PE.OpCode.Clt:  	instructions.Add (new CompareInstruction (offset' CompareOp.Clt' false));  	break;  case PE.OpCode.Clt_un:  	instructions.Add (new CompareInstruction (offset' CompareOp.Clt' true));  	break;  case PE.OpCode.Cgt:  	instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' false));  	break;  case PE.OpCode.Cgt_un:  	instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' true));  	break;  case PE.OpCode.Ldarg_0:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));  	break;  case PE.OpCode.Ldarg_1:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));  	break;  case PE.OpCode.Ldarg_2:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));  	break;  case PE.OpCode.Ldarg_3:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));  	break;  case PE.OpCode.Ldarg:  case PE.OpCode.Ldarg_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));  	break;  case PE.OpCode.Ldarga:  case PE.OpCode.Ldarga_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));  	break;  case PE.OpCode.Starg:  case PE.OpCode.Starg_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));  	break;  case PE.OpCode.Ldloc_0:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 0));  	break;  case PE.OpCode.Ldloc_1:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 1));  	break;  case PE.OpCode.Ldloc_2:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 2));  	break;  case PE.OpCode.Ldloc_3:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 3));  	break;  case PE.OpCode.Ldloc:  case PE.OpCode.Ldloc_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));  	break;  case PE.OpCode.Ldloca:  case PE.OpCode.Ldloca_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));  	break;  case PE.OpCode.Stloc_0:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 0));  	break;  case PE.OpCode.Stloc_1:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 1));  	break;  case PE.OpCode.Stloc_2:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 2));  	break;  case PE.OpCode.Stloc_3:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 3));  	break;  case PE.OpCode.Stloc:  case PE.OpCode.Stloc_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));  	break;  case PE.OpCode.Ldfld:  	instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));  	break;  case PE.OpCode.Ldsfld:  	instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));  	break;  case PE.OpCode.Ldflda:  	instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));  	break;  case PE.OpCode.Ldsflda:  	instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));  	break;  case PE.OpCode.Stfld:  	instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));  	break;  case PE.OpCode.Stsfld:  	instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));  	break;  case PE.OpCode.Ldtoken: {  	if (instruction.Value is FieldRef)  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));  	else if (instruction.Value is MethodRef)  		instructions.Add (new MethodInstruction (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));  	else if (instruction.Value is TypeRef)  		// NOTE: May be a higher-kinded type  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));  	else  		throw new InvalidOperationException ("unexpected ldtoken instruction value");  	break;  }  case PE.OpCode.Constrained: {  	var constrained = (TypeRef)instruction.Value;  	if (i >= ctxt.Instructions.Length)  		throw new InvalidOperationException ("invalid instructions");  	instruction = ctxt.Instructions [i++];  	if (instruction.OpCode != PE.OpCode.Callvirt)  		throw new InvalidOperationException ("invalid instruction");  	instructions.Add (new MethodInstruction (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));  	break;  }  case PE.OpCode.Call:  	instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Callvirt:  	instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Ldftn:  	instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Ldvirtftn:  	instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Newobj:  	instructions.Add (new MethodInstruction (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Ldind_i1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int8Ref));  	break;  case PE.OpCode.Ldind_u1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt8Ref));  	break;  case PE.OpCode.Ldind_i2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int16Ref));  	break;  case PE.OpCode.Ldind_u2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt16Ref));  	break;  case PE.OpCode.Ldind_i4:  case PE.OpCode.Ldind_u4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int32Ref));  	break;  case PE.OpCode.Ldind_i8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int64Ref));  	break;  case PE.OpCode.Ldind_i:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.IntNativeRef));  	break;  case PE.OpCode.Ldind_r4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.SingleRef));  	break;  case PE.OpCode.Ldind_r8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.DoubleRef));  	break;  case PE.OpCode.Ldobj:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Stind_i1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int8Ref));  	break;  case PE.OpCode.Stind_i2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int16Ref));  	break;  case PE.OpCode.Stind_i4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int32Ref));  	break;  case PE.OpCode.Stind_i8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int64Ref));  	break;  case PE.OpCode.Stind_i:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.IntNativeRef));  	break;  case PE.OpCode.Stind_r4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.SingleRef));  	break;  case PE.OpCode.Stind_r8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.DoubleRef));  	break;  case PE.OpCode.Stobj:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Cpobj:  	instructions.Add (new TypeInstruction (offset' TypeOp.Cpobj' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Newarr:  	instructions.Add (new TypeInstruction (offset' TypeOp.Newarr' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Initobj:  	instructions.Add (new TypeInstruction (offset' TypeOp.Initobj' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Castclass:  	instructions.Add (new TypeInstruction (offset' TypeOp.Castclass' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Isinst:  	instructions.Add (new TypeInstruction (offset' TypeOp.Isinst' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Box:  	instructions.Add (new TypeInstruction (offset' TypeOp.Box' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Unbox:  	instructions.Add (new TypeInstruction (offset' TypeOp.Unbox' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Unbox_any:  	instructions.Add (new TypeInstruction (offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Ldelem_i1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int8Ref));  	break;  case PE.OpCode.Ldelem_u1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt8Ref));  	break;  case PE.OpCode.Ldelem_i2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int16Ref));  	break;  case PE.OpCode.Ldelem_u2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt16Ref));  	break;  case PE.OpCode.Ldelem_i4:  case PE.OpCode.Ldelem_u4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int32Ref));  	break;  case PE.OpCode.Ldelem_i:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.IntNativeRef));  	break;  case PE.OpCode.Ldelem_i8:  	// aka ldelem.u8  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int64Ref));  	break;  case PE.OpCode.Ldelem_r4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.SingleRef));  	break;  case PE.OpCode.Ldelem_r8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.DoubleRef));  	break;  case PE.OpCode.Ldelem:  	// aka ldelem.any  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Stelem_i1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int8Ref));  	break;  case PE.OpCode.Stelem_i2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int16Ref));  	break;  case PE.OpCode.Stelem_i4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int32Ref));  	break;  case PE.OpCode.Stelem_i8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int64Ref));  	break;  case PE.OpCode.Stelem_i:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.IntNativeRef));  	break;  case PE.OpCode.Stelem_r4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.SingleRef));  	break;  case PE.OpCode.Stelem_r8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.DoubleRef));  	break;  case PE.OpCode.Stelem:  	// aka stelem.any  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Readonly:  	if (i >= ctxt.Instructions.Length)  		throw new InvalidOperationException ("invalid instruction");  	instruction = ctxt.Instructions [i++];  	if (instruction.OpCode != PE.OpCode.Ldelema)  		throw new InvalidOperationException ("invalid instruction");  	instructions.Add (new LdElemAddrInstruction (offset' true' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Ldelema:  	instructions.Add (new LdElemAddrInstruction (offset' false' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Ldc_i4_0:  	instructions.Add (new LdInt32Instruction (offset' 0));  	break;  case PE.OpCode.Ldc_i4_1:  	instructions.Add (new LdInt32Instruction (offset' 1));  	break;  case PE.OpCode.Ldc_i4_2:  	instructions.Add (new LdInt32Instruction (offset' 2));  	break;  case PE.OpCode.Ldc_i4_3:  	instructions.Add (new LdInt32Instruction (offset' 3));  	break;  case PE.OpCode.Ldc_i4_4:  	instructions.Add (new LdInt32Instruction (offset' 4));  	break;  case PE.OpCode.Ldc_i4_5:  	instructions.Add (new LdInt32Instruction (offset' 5));  	break;  case PE.OpCode.Ldc_i4_6:  	instructions.Add (new LdInt32Instruction (offset' 6));  	break;  case PE.OpCode.Ldc_i4_7:  	instructions.Add (new LdInt32Instruction (offset' 7));  	break;  case PE.OpCode.Ldc_i4_8:  	instructions.Add (new LdInt32Instruction (offset' 8));  	break;  case PE.OpCode.Ldc_i4_m1:  	instructions.Add (new LdInt32Instruction (offset' -1));  	break;  case PE.OpCode.Ldc_i4:  case PE.OpCode.Ldc_i4_s:  	instructions.Add (new LdInt32Instruction (offset' (int)instruction.Value));  	break;  case PE.OpCode.Ldc_i8:  	instructions.Add (new LdInt64Instruction (offset' (long)instruction.Value));  	break;  case PE.OpCode.Ldc_r4:  	instructions.Add (new LdSingleInstruction (offset' (float)instruction.Value));  	break;  case PE.OpCode.Ldc_r8:  	instructions.Add (new LdDoubleInstruction (offset' (double)instruction.Value));  	break;  case PE.OpCode.Ldstr:  	instructions.Add (new LdStringInstruction (offset' (string)instruction.Value));  	break;  case PE.OpCode.Add:  	instructions.Add (new ArithInstruction (offset' ArithOp.Add' false' false));  	break;  case PE.OpCode.Add_ovf:  	instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' false));  	break;  case PE.OpCode.Add_ovf_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' true));  	break;  case PE.OpCode.Sub:  	instructions.Add (new ArithInstruction (offset' ArithOp.Sub' false' false));  	break;  case PE.OpCode.Sub_ovf:  	instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' false));  	break;  case PE.OpCode.Sub_ovf_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' true));  	break;  case PE.OpCode.Mul:  	instructions.Add (new ArithInstruction (offset' ArithOp.Mul' false' false));  	break;  case PE.OpCode.Mul_ovf:  	instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' false));  	break;  case PE.OpCode.Mul_ovf_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' true));  	break;  case PE.OpCode.Div:  	instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' false));  	break;  case PE.OpCode.Div_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' true));  	break;  case PE.OpCode.Rem:  	instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' false));  	break;  case PE.OpCode.Rem_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' true));  	break;  case PE.OpCode.Neg:  	instructions.Add (new ArithInstruction (offset' ArithOp.Neg' false' false));  	break;  case PE.OpCode.And:  	instructions.Add (new ArithInstruction (offset' ArithOp.BitAnd' false' false));  	break;  case PE.OpCode.Or:  	instructions.Add (new ArithInstruction (offset' ArithOp.BitOr' false' false));  	break;  case PE.OpCode.Xor:  	instructions.Add (new ArithInstruction (offset' ArithOp.BitXor' false' false));  	break;  case PE.OpCode.Not:  	instructions.Add (new ArithInstruction (offset' ArithOp.BitNot' false' false));  	break;  case PE.OpCode.Shl:  	instructions.Add (new ArithInstruction (offset' ArithOp.Shl' false' false));  	break;  case PE.OpCode.Shr:  	instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' false));  	break;  case PE.OpCode.Shr_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' true));  	break;  case PE.OpCode.Conv_i1:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' false' false));  	break;  case PE.OpCode.Conv_u1:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' false' false));  	break;  case PE.OpCode.Conv_i2:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' false' false));  	break;  case PE.OpCode.Conv_u2:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' false' false));  	break;  case PE.OpCode.Conv_i4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' false' false));  	break;  case PE.OpCode.Conv_u4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' false' false));  	break;  case PE.OpCode.Conv_i8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' false' false));  	break;  case PE.OpCode.Conv_u8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' false' false));  	break;  case PE.OpCode.Conv_i:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' false' false));  	break;  case PE.OpCode.Conv_u:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' false' false));  	break;  case PE.OpCode.Conv_r4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Single' false' false));  	break;  case PE.OpCode.Conv_r8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' false));  	break;  case PE.OpCode.Conv_r_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' true));  	break;  case PE.OpCode.Conv_ovf_i1:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' false));  	break;  case PE.OpCode.Conv_ovf_u1:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' false));  	break;  case PE.OpCode.Conv_ovf_i2:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' false));  	break;  case PE.OpCode.Conv_ovf_u2:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' false));  	break;  case PE.OpCode.Conv_ovf_i4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' false));  	break;  case PE.OpCode.Conv_ovf_u4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' false));  	break;  case PE.OpCode.Conv_ovf_i8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' false));  	break;  case PE.OpCode.Conv_ovf_u8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' false));  	break;  case PE.OpCode.Conv_ovf_i:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' false));  	break;  case PE.OpCode.Conv_ovf_u:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' false));  	break;  case PE.OpCode.Conv_ovf_i1_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' true));  	break;  case PE.OpCode.Conv_ovf_u1_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' true));  	break;  case PE.OpCode.Conv_ovf_i2_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' true));  	break;  case PE.OpCode.Conv_ovf_u2_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' true));  	break;  case PE.OpCode.Conv_ovf_i4_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' true));  	break;  case PE.OpCode.Conv_ovf_u4_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' true));  	break;  case PE.OpCode.Conv_ovf_i8_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' true));  	break;  case PE.OpCode.Conv_ovf_u8_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' true));  	break;  case PE.OpCode.Conv_ovf_i_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' true));  	break;  case PE.OpCode.Conv_ovf_u_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' true));  	break;  default:  	throw new InvalidOperationException ("invalid instruction");  }  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: switch (instruction.OpCode) {  case PE.OpCode.Cpblk:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Cpblk));  	break;  case PE.OpCode.Initblk:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Initblk));  	break;  case PE.OpCode.Arglist:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Arglist));  	break;  case PE.OpCode.Localloc:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Localloc));  	break;  case PE.OpCode.Jmp:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Jmp));  	break;  case PE.OpCode.Calli:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Calli));  	break;  case PE.OpCode.Sizeof:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Sizeof));  	break;  case PE.OpCode.Mkrefany:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Mkrefany));  	break;  case PE.OpCode.Refanytype:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanytype));  	break;  case PE.OpCode.Refanyval:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanyval));  	break;  case PE.OpCode.Nop:  	instructions.Add (new MiscInstruction (offset' MiscOp.Nop));  	break;  case PE.OpCode.Break:  	instructions.Add (new MiscInstruction (offset' MiscOp.Break));  	break;  case PE.OpCode.Dup:  	instructions.Add (new MiscInstruction (offset' MiscOp.Dup));  	break;  case PE.OpCode.Pop:  	instructions.Add (new MiscInstruction (offset' MiscOp.Pop));  	break;  case PE.OpCode.Ldnull:  	instructions.Add (new MiscInstruction (offset' MiscOp.Ldnull));  	break;  case PE.OpCode.Ckfinite:  	instructions.Add (new MiscInstruction (offset' MiscOp.Ckfinite));  	break;  case PE.OpCode.Throw:  	instructions.Add (new MiscInstruction (offset' MiscOp.Throw));  	break;  case PE.OpCode.Rethrow:  	instructions.Add (new MiscInstruction (offset' MiscOp.Rethrow));  	break;  case PE.OpCode.Ldind_ref:  	instructions.Add (new MiscInstruction (offset' MiscOp.LdindRef));  	break;  case PE.OpCode.Stind_ref:  	instructions.Add (new MiscInstruction (offset' MiscOp.StindRef));  	break;  case PE.OpCode.Ldelem_ref:  	instructions.Add (new MiscInstruction (offset' MiscOp.LdelemRef));  	break;  case PE.OpCode.Stelem_ref:  	instructions.Add (new MiscInstruction (offset' MiscOp.StelemRef));  	break;  case PE.OpCode.Ldlen:  	instructions.Add (new MiscInstruction (offset' MiscOp.Ldlen));  	break;  case PE.OpCode.Ret:  	if (ctxt.ResultType == null)  		instructions.Add (new MiscInstruction (offset' MiscOp.Ret));  	else  		instructions.Add (new MiscInstruction (offset' MiscOp.RetVal));  	break;  case PE.OpCode.Endfilter:  	instructions.Add (new MiscInstruction (offset' MiscOp.Endfilter));  	break;  case PE.OpCode.Endfinally:  	// aka EndFault  	instructions.Add (new MiscInstruction (offset' MiscOp.Endfinally));  	break;  case PE.OpCode.Br_s:  case PE.OpCode.Br:  	instructions.Add (new BranchInstruction (offset' BranchOp.Br' false' (int)instruction.Value));  	break;  case PE.OpCode.Brtrue_s:  // aka brinst.s  case PE.OpCode.Brtrue:  	// aka brinst  	instructions.Add (new BranchInstruction (offset' BranchOp.Brtrue' false' (int)instruction.Value));  	break;  case PE.OpCode.Brfalse_s:  // aka brzero.s' brnull.s  case PE.OpCode.Brfalse:  	// aka brzero' brnull  	instructions.Add (new BranchInstruction (offset' BranchOp.Brfalse' false' (int)instruction.Value));  	break;  case PE.OpCode.Beq:  case PE.OpCode.Beq_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.Breq' false' (int)instruction.Value));  	break;  case PE.OpCode.Bne_un:  case PE.OpCode.Bne_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.Brne' false' (int)instruction.Value));  	break;  case PE.OpCode.Leave:  case PE.OpCode.Leave_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.Leave' false' (int)instruction.Value));  	break;  case PE.OpCode.Blt:  case PE.OpCode.Blt_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' false' (int)instruction.Value));  	break;  case PE.OpCode.Blt_un:  case PE.OpCode.Blt_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' true' (int)instruction.Value));  	break;  case PE.OpCode.Ble:  case PE.OpCode.Ble_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' false' (int)instruction.Value));  	break;  case PE.OpCode.Ble_un:  case PE.OpCode.Ble_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' true' (int)instruction.Value));  	break;  case PE.OpCode.Bgt:  case PE.OpCode.Bgt_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' false' (int)instruction.Value));  	break;  case PE.OpCode.Bgt_un:  case PE.OpCode.Bgt_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' true' (int)instruction.Value));  	break;  case PE.OpCode.Bge:  case PE.OpCode.Bge_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' false' (int)instruction.Value));  	break;  case PE.OpCode.Bge_un:  case PE.OpCode.Bge_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' true' (int)instruction.Value));  	break;  case PE.OpCode.Switch:  	instructions.Add (new SwitchInstruction (offset' (Seq<int>)instruction.Value));  	break;  case PE.OpCode.Ceq:  	instructions.Add (new CompareInstruction (offset' CompareOp.Ceq' false));  	break;  case PE.OpCode.Clt:  	instructions.Add (new CompareInstruction (offset' CompareOp.Clt' false));  	break;  case PE.OpCode.Clt_un:  	instructions.Add (new CompareInstruction (offset' CompareOp.Clt' true));  	break;  case PE.OpCode.Cgt:  	instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' false));  	break;  case PE.OpCode.Cgt_un:  	instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' true));  	break;  case PE.OpCode.Ldarg_0:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));  	break;  case PE.OpCode.Ldarg_1:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));  	break;  case PE.OpCode.Ldarg_2:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));  	break;  case PE.OpCode.Ldarg_3:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));  	break;  case PE.OpCode.Ldarg:  case PE.OpCode.Ldarg_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));  	break;  case PE.OpCode.Ldarga:  case PE.OpCode.Ldarga_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));  	break;  case PE.OpCode.Starg:  case PE.OpCode.Starg_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));  	break;  case PE.OpCode.Ldloc_0:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 0));  	break;  case PE.OpCode.Ldloc_1:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 1));  	break;  case PE.OpCode.Ldloc_2:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 2));  	break;  case PE.OpCode.Ldloc_3:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 3));  	break;  case PE.OpCode.Ldloc:  case PE.OpCode.Ldloc_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));  	break;  case PE.OpCode.Ldloca:  case PE.OpCode.Ldloca_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));  	break;  case PE.OpCode.Stloc_0:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 0));  	break;  case PE.OpCode.Stloc_1:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 1));  	break;  case PE.OpCode.Stloc_2:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 2));  	break;  case PE.OpCode.Stloc_3:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 3));  	break;  case PE.OpCode.Stloc:  case PE.OpCode.Stloc_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));  	break;  case PE.OpCode.Ldfld:  	instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));  	break;  case PE.OpCode.Ldsfld:  	instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));  	break;  case PE.OpCode.Ldflda:  	instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));  	break;  case PE.OpCode.Ldsflda:  	instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));  	break;  case PE.OpCode.Stfld:  	instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));  	break;  case PE.OpCode.Stsfld:  	instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));  	break;  case PE.OpCode.Ldtoken: {  	if (instruction.Value is FieldRef)  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));  	else if (instruction.Value is MethodRef)  		instructions.Add (new MethodInstruction (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));  	else if (instruction.Value is TypeRef)  		// NOTE: May be a higher-kinded type  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));  	else  		throw new InvalidOperationException ("unexpected ldtoken instruction value");  	break;  }  case PE.OpCode.Constrained: {  	var constrained = (TypeRef)instruction.Value;  	if (i >= ctxt.Instructions.Length)  		throw new InvalidOperationException ("invalid instructions");  	instruction = ctxt.Instructions [i++];  	if (instruction.OpCode != PE.OpCode.Callvirt)  		throw new InvalidOperationException ("invalid instruction");  	instructions.Add (new MethodInstruction (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));  	break;  }  case PE.OpCode.Call:  	instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Callvirt:  	instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Ldftn:  	instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Ldvirtftn:  	instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Newobj:  	instructions.Add (new MethodInstruction (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Ldind_i1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int8Ref));  	break;  case PE.OpCode.Ldind_u1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt8Ref));  	break;  case PE.OpCode.Ldind_i2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int16Ref));  	break;  case PE.OpCode.Ldind_u2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt16Ref));  	break;  case PE.OpCode.Ldind_i4:  case PE.OpCode.Ldind_u4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int32Ref));  	break;  case PE.OpCode.Ldind_i8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int64Ref));  	break;  case PE.OpCode.Ldind_i:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.IntNativeRef));  	break;  case PE.OpCode.Ldind_r4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.SingleRef));  	break;  case PE.OpCode.Ldind_r8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.DoubleRef));  	break;  case PE.OpCode.Ldobj:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Stind_i1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int8Ref));  	break;  case PE.OpCode.Stind_i2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int16Ref));  	break;  case PE.OpCode.Stind_i4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int32Ref));  	break;  case PE.OpCode.Stind_i8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int64Ref));  	break;  case PE.OpCode.Stind_i:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.IntNativeRef));  	break;  case PE.OpCode.Stind_r4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.SingleRef));  	break;  case PE.OpCode.Stind_r8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.DoubleRef));  	break;  case PE.OpCode.Stobj:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Cpobj:  	instructions.Add (new TypeInstruction (offset' TypeOp.Cpobj' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Newarr:  	instructions.Add (new TypeInstruction (offset' TypeOp.Newarr' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Initobj:  	instructions.Add (new TypeInstruction (offset' TypeOp.Initobj' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Castclass:  	instructions.Add (new TypeInstruction (offset' TypeOp.Castclass' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Isinst:  	instructions.Add (new TypeInstruction (offset' TypeOp.Isinst' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Box:  	instructions.Add (new TypeInstruction (offset' TypeOp.Box' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Unbox:  	instructions.Add (new TypeInstruction (offset' TypeOp.Unbox' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Unbox_any:  	instructions.Add (new TypeInstruction (offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Ldelem_i1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int8Ref));  	break;  case PE.OpCode.Ldelem_u1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt8Ref));  	break;  case PE.OpCode.Ldelem_i2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int16Ref));  	break;  case PE.OpCode.Ldelem_u2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt16Ref));  	break;  case PE.OpCode.Ldelem_i4:  case PE.OpCode.Ldelem_u4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int32Ref));  	break;  case PE.OpCode.Ldelem_i:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.IntNativeRef));  	break;  case PE.OpCode.Ldelem_i8:  	// aka ldelem.u8  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int64Ref));  	break;  case PE.OpCode.Ldelem_r4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.SingleRef));  	break;  case PE.OpCode.Ldelem_r8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.DoubleRef));  	break;  case PE.OpCode.Ldelem:  	// aka ldelem.any  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Stelem_i1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int8Ref));  	break;  case PE.OpCode.Stelem_i2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int16Ref));  	break;  case PE.OpCode.Stelem_i4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int32Ref));  	break;  case PE.OpCode.Stelem_i8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int64Ref));  	break;  case PE.OpCode.Stelem_i:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.IntNativeRef));  	break;  case PE.OpCode.Stelem_r4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.SingleRef));  	break;  case PE.OpCode.Stelem_r8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.DoubleRef));  	break;  case PE.OpCode.Stelem:  	// aka stelem.any  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Readonly:  	if (i >= ctxt.Instructions.Length)  		throw new InvalidOperationException ("invalid instruction");  	instruction = ctxt.Instructions [i++];  	if (instruction.OpCode != PE.OpCode.Ldelema)  		throw new InvalidOperationException ("invalid instruction");  	instructions.Add (new LdElemAddrInstruction (offset' true' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Ldelema:  	instructions.Add (new LdElemAddrInstruction (offset' false' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Ldc_i4_0:  	instructions.Add (new LdInt32Instruction (offset' 0));  	break;  case PE.OpCode.Ldc_i4_1:  	instructions.Add (new LdInt32Instruction (offset' 1));  	break;  case PE.OpCode.Ldc_i4_2:  	instructions.Add (new LdInt32Instruction (offset' 2));  	break;  case PE.OpCode.Ldc_i4_3:  	instructions.Add (new LdInt32Instruction (offset' 3));  	break;  case PE.OpCode.Ldc_i4_4:  	instructions.Add (new LdInt32Instruction (offset' 4));  	break;  case PE.OpCode.Ldc_i4_5:  	instructions.Add (new LdInt32Instruction (offset' 5));  	break;  case PE.OpCode.Ldc_i4_6:  	instructions.Add (new LdInt32Instruction (offset' 6));  	break;  case PE.OpCode.Ldc_i4_7:  	instructions.Add (new LdInt32Instruction (offset' 7));  	break;  case PE.OpCode.Ldc_i4_8:  	instructions.Add (new LdInt32Instruction (offset' 8));  	break;  case PE.OpCode.Ldc_i4_m1:  	instructions.Add (new LdInt32Instruction (offset' -1));  	break;  case PE.OpCode.Ldc_i4:  case PE.OpCode.Ldc_i4_s:  	instructions.Add (new LdInt32Instruction (offset' (int)instruction.Value));  	break;  case PE.OpCode.Ldc_i8:  	instructions.Add (new LdInt64Instruction (offset' (long)instruction.Value));  	break;  case PE.OpCode.Ldc_r4:  	instructions.Add (new LdSingleInstruction (offset' (float)instruction.Value));  	break;  case PE.OpCode.Ldc_r8:  	instructions.Add (new LdDoubleInstruction (offset' (double)instruction.Value));  	break;  case PE.OpCode.Ldstr:  	instructions.Add (new LdStringInstruction (offset' (string)instruction.Value));  	break;  case PE.OpCode.Add:  	instructions.Add (new ArithInstruction (offset' ArithOp.Add' false' false));  	break;  case PE.OpCode.Add_ovf:  	instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' false));  	break;  case PE.OpCode.Add_ovf_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' true));  	break;  case PE.OpCode.Sub:  	instructions.Add (new ArithInstruction (offset' ArithOp.Sub' false' false));  	break;  case PE.OpCode.Sub_ovf:  	instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' false));  	break;  case PE.OpCode.Sub_ovf_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' true));  	break;  case PE.OpCode.Mul:  	instructions.Add (new ArithInstruction (offset' ArithOp.Mul' false' false));  	break;  case PE.OpCode.Mul_ovf:  	instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' false));  	break;  case PE.OpCode.Mul_ovf_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' true));  	break;  case PE.OpCode.Div:  	instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' false));  	break;  case PE.OpCode.Div_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' true));  	break;  case PE.OpCode.Rem:  	instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' false));  	break;  case PE.OpCode.Rem_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' true));  	break;  case PE.OpCode.Neg:  	instructions.Add (new ArithInstruction (offset' ArithOp.Neg' false' false));  	break;  case PE.OpCode.And:  	instructions.Add (new ArithInstruction (offset' ArithOp.BitAnd' false' false));  	break;  case PE.OpCode.Or:  	instructions.Add (new ArithInstruction (offset' ArithOp.BitOr' false' false));  	break;  case PE.OpCode.Xor:  	instructions.Add (new ArithInstruction (offset' ArithOp.BitXor' false' false));  	break;  case PE.OpCode.Not:  	instructions.Add (new ArithInstruction (offset' ArithOp.BitNot' false' false));  	break;  case PE.OpCode.Shl:  	instructions.Add (new ArithInstruction (offset' ArithOp.Shl' false' false));  	break;  case PE.OpCode.Shr:  	instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' false));  	break;  case PE.OpCode.Shr_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' true));  	break;  case PE.OpCode.Conv_i1:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' false' false));  	break;  case PE.OpCode.Conv_u1:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' false' false));  	break;  case PE.OpCode.Conv_i2:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' false' false));  	break;  case PE.OpCode.Conv_u2:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' false' false));  	break;  case PE.OpCode.Conv_i4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' false' false));  	break;  case PE.OpCode.Conv_u4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' false' false));  	break;  case PE.OpCode.Conv_i8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' false' false));  	break;  case PE.OpCode.Conv_u8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' false' false));  	break;  case PE.OpCode.Conv_i:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' false' false));  	break;  case PE.OpCode.Conv_u:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' false' false));  	break;  case PE.OpCode.Conv_r4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Single' false' false));  	break;  case PE.OpCode.Conv_r8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' false));  	break;  case PE.OpCode.Conv_r_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' true));  	break;  case PE.OpCode.Conv_ovf_i1:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' false));  	break;  case PE.OpCode.Conv_ovf_u1:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' false));  	break;  case PE.OpCode.Conv_ovf_i2:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' false));  	break;  case PE.OpCode.Conv_ovf_u2:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' false));  	break;  case PE.OpCode.Conv_ovf_i4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' false));  	break;  case PE.OpCode.Conv_ovf_u4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' false));  	break;  case PE.OpCode.Conv_ovf_i8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' false));  	break;  case PE.OpCode.Conv_ovf_u8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' false));  	break;  case PE.OpCode.Conv_ovf_i:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' false));  	break;  case PE.OpCode.Conv_ovf_u:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' false));  	break;  case PE.OpCode.Conv_ovf_i1_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' true));  	break;  case PE.OpCode.Conv_ovf_u1_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' true));  	break;  case PE.OpCode.Conv_ovf_i2_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' true));  	break;  case PE.OpCode.Conv_ovf_u2_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' true));  	break;  case PE.OpCode.Conv_ovf_i4_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' true));  	break;  case PE.OpCode.Conv_ovf_u4_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' true));  	break;  case PE.OpCode.Conv_ovf_i8_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' true));  	break;  case PE.OpCode.Conv_ovf_u8_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' true));  	break;  case PE.OpCode.Conv_ovf_i_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' true));  	break;  case PE.OpCode.Conv_ovf_u_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' true));  	break;  default:  	throw new InvalidOperationException ("invalid instruction");  }  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: switch (instruction.OpCode) {  case PE.OpCode.Cpblk:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Cpblk));  	break;  case PE.OpCode.Initblk:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Initblk));  	break;  case PE.OpCode.Arglist:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Arglist));  	break;  case PE.OpCode.Localloc:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Localloc));  	break;  case PE.OpCode.Jmp:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Jmp));  	break;  case PE.OpCode.Calli:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Calli));  	break;  case PE.OpCode.Sizeof:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Sizeof));  	break;  case PE.OpCode.Mkrefany:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Mkrefany));  	break;  case PE.OpCode.Refanytype:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanytype));  	break;  case PE.OpCode.Refanyval:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanyval));  	break;  case PE.OpCode.Nop:  	instructions.Add (new MiscInstruction (offset' MiscOp.Nop));  	break;  case PE.OpCode.Break:  	instructions.Add (new MiscInstruction (offset' MiscOp.Break));  	break;  case PE.OpCode.Dup:  	instructions.Add (new MiscInstruction (offset' MiscOp.Dup));  	break;  case PE.OpCode.Pop:  	instructions.Add (new MiscInstruction (offset' MiscOp.Pop));  	break;  case PE.OpCode.Ldnull:  	instructions.Add (new MiscInstruction (offset' MiscOp.Ldnull));  	break;  case PE.OpCode.Ckfinite:  	instructions.Add (new MiscInstruction (offset' MiscOp.Ckfinite));  	break;  case PE.OpCode.Throw:  	instructions.Add (new MiscInstruction (offset' MiscOp.Throw));  	break;  case PE.OpCode.Rethrow:  	instructions.Add (new MiscInstruction (offset' MiscOp.Rethrow));  	break;  case PE.OpCode.Ldind_ref:  	instructions.Add (new MiscInstruction (offset' MiscOp.LdindRef));  	break;  case PE.OpCode.Stind_ref:  	instructions.Add (new MiscInstruction (offset' MiscOp.StindRef));  	break;  case PE.OpCode.Ldelem_ref:  	instructions.Add (new MiscInstruction (offset' MiscOp.LdelemRef));  	break;  case PE.OpCode.Stelem_ref:  	instructions.Add (new MiscInstruction (offset' MiscOp.StelemRef));  	break;  case PE.OpCode.Ldlen:  	instructions.Add (new MiscInstruction (offset' MiscOp.Ldlen));  	break;  case PE.OpCode.Ret:  	if (ctxt.ResultType == null)  		instructions.Add (new MiscInstruction (offset' MiscOp.Ret));  	else  		instructions.Add (new MiscInstruction (offset' MiscOp.RetVal));  	break;  case PE.OpCode.Endfilter:  	instructions.Add (new MiscInstruction (offset' MiscOp.Endfilter));  	break;  case PE.OpCode.Endfinally:  	// aka EndFault  	instructions.Add (new MiscInstruction (offset' MiscOp.Endfinally));  	break;  case PE.OpCode.Br_s:  case PE.OpCode.Br:  	instructions.Add (new BranchInstruction (offset' BranchOp.Br' false' (int)instruction.Value));  	break;  case PE.OpCode.Brtrue_s:  // aka brinst.s  case PE.OpCode.Brtrue:  	// aka brinst  	instructions.Add (new BranchInstruction (offset' BranchOp.Brtrue' false' (int)instruction.Value));  	break;  case PE.OpCode.Brfalse_s:  // aka brzero.s' brnull.s  case PE.OpCode.Brfalse:  	// aka brzero' brnull  	instructions.Add (new BranchInstruction (offset' BranchOp.Brfalse' false' (int)instruction.Value));  	break;  case PE.OpCode.Beq:  case PE.OpCode.Beq_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.Breq' false' (int)instruction.Value));  	break;  case PE.OpCode.Bne_un:  case PE.OpCode.Bne_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.Brne' false' (int)instruction.Value));  	break;  case PE.OpCode.Leave:  case PE.OpCode.Leave_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.Leave' false' (int)instruction.Value));  	break;  case PE.OpCode.Blt:  case PE.OpCode.Blt_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' false' (int)instruction.Value));  	break;  case PE.OpCode.Blt_un:  case PE.OpCode.Blt_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' true' (int)instruction.Value));  	break;  case PE.OpCode.Ble:  case PE.OpCode.Ble_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' false' (int)instruction.Value));  	break;  case PE.OpCode.Ble_un:  case PE.OpCode.Ble_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' true' (int)instruction.Value));  	break;  case PE.OpCode.Bgt:  case PE.OpCode.Bgt_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' false' (int)instruction.Value));  	break;  case PE.OpCode.Bgt_un:  case PE.OpCode.Bgt_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' true' (int)instruction.Value));  	break;  case PE.OpCode.Bge:  case PE.OpCode.Bge_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' false' (int)instruction.Value));  	break;  case PE.OpCode.Bge_un:  case PE.OpCode.Bge_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' true' (int)instruction.Value));  	break;  case PE.OpCode.Switch:  	instructions.Add (new SwitchInstruction (offset' (Seq<int>)instruction.Value));  	break;  case PE.OpCode.Ceq:  	instructions.Add (new CompareInstruction (offset' CompareOp.Ceq' false));  	break;  case PE.OpCode.Clt:  	instructions.Add (new CompareInstruction (offset' CompareOp.Clt' false));  	break;  case PE.OpCode.Clt_un:  	instructions.Add (new CompareInstruction (offset' CompareOp.Clt' true));  	break;  case PE.OpCode.Cgt:  	instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' false));  	break;  case PE.OpCode.Cgt_un:  	instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' true));  	break;  case PE.OpCode.Ldarg_0:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));  	break;  case PE.OpCode.Ldarg_1:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));  	break;  case PE.OpCode.Ldarg_2:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));  	break;  case PE.OpCode.Ldarg_3:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));  	break;  case PE.OpCode.Ldarg:  case PE.OpCode.Ldarg_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));  	break;  case PE.OpCode.Ldarga:  case PE.OpCode.Ldarga_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));  	break;  case PE.OpCode.Starg:  case PE.OpCode.Starg_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));  	break;  case PE.OpCode.Ldloc_0:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 0));  	break;  case PE.OpCode.Ldloc_1:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 1));  	break;  case PE.OpCode.Ldloc_2:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 2));  	break;  case PE.OpCode.Ldloc_3:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 3));  	break;  case PE.OpCode.Ldloc:  case PE.OpCode.Ldloc_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));  	break;  case PE.OpCode.Ldloca:  case PE.OpCode.Ldloca_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));  	break;  case PE.OpCode.Stloc_0:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 0));  	break;  case PE.OpCode.Stloc_1:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 1));  	break;  case PE.OpCode.Stloc_2:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 2));  	break;  case PE.OpCode.Stloc_3:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 3));  	break;  case PE.OpCode.Stloc:  case PE.OpCode.Stloc_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));  	break;  case PE.OpCode.Ldfld:  	instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));  	break;  case PE.OpCode.Ldsfld:  	instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));  	break;  case PE.OpCode.Ldflda:  	instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));  	break;  case PE.OpCode.Ldsflda:  	instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));  	break;  case PE.OpCode.Stfld:  	instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));  	break;  case PE.OpCode.Stsfld:  	instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));  	break;  case PE.OpCode.Ldtoken: {  	if (instruction.Value is FieldRef)  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));  	else if (instruction.Value is MethodRef)  		instructions.Add (new MethodInstruction (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));  	else if (instruction.Value is TypeRef)  		// NOTE: May be a higher-kinded type  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));  	else  		throw new InvalidOperationException ("unexpected ldtoken instruction value");  	break;  }  case PE.OpCode.Constrained: {  	var constrained = (TypeRef)instruction.Value;  	if (i >= ctxt.Instructions.Length)  		throw new InvalidOperationException ("invalid instructions");  	instruction = ctxt.Instructions [i++];  	if (instruction.OpCode != PE.OpCode.Callvirt)  		throw new InvalidOperationException ("invalid instruction");  	instructions.Add (new MethodInstruction (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));  	break;  }  case PE.OpCode.Call:  	instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Callvirt:  	instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Ldftn:  	instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Ldvirtftn:  	instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Newobj:  	instructions.Add (new MethodInstruction (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Ldind_i1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int8Ref));  	break;  case PE.OpCode.Ldind_u1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt8Ref));  	break;  case PE.OpCode.Ldind_i2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int16Ref));  	break;  case PE.OpCode.Ldind_u2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt16Ref));  	break;  case PE.OpCode.Ldind_i4:  case PE.OpCode.Ldind_u4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int32Ref));  	break;  case PE.OpCode.Ldind_i8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int64Ref));  	break;  case PE.OpCode.Ldind_i:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.IntNativeRef));  	break;  case PE.OpCode.Ldind_r4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.SingleRef));  	break;  case PE.OpCode.Ldind_r8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.DoubleRef));  	break;  case PE.OpCode.Ldobj:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Stind_i1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int8Ref));  	break;  case PE.OpCode.Stind_i2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int16Ref));  	break;  case PE.OpCode.Stind_i4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int32Ref));  	break;  case PE.OpCode.Stind_i8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int64Ref));  	break;  case PE.OpCode.Stind_i:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.IntNativeRef));  	break;  case PE.OpCode.Stind_r4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.SingleRef));  	break;  case PE.OpCode.Stind_r8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.DoubleRef));  	break;  case PE.OpCode.Stobj:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Cpobj:  	instructions.Add (new TypeInstruction (offset' TypeOp.Cpobj' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Newarr:  	instructions.Add (new TypeInstruction (offset' TypeOp.Newarr' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Initobj:  	instructions.Add (new TypeInstruction (offset' TypeOp.Initobj' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Castclass:  	instructions.Add (new TypeInstruction (offset' TypeOp.Castclass' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Isinst:  	instructions.Add (new TypeInstruction (offset' TypeOp.Isinst' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Box:  	instructions.Add (new TypeInstruction (offset' TypeOp.Box' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Unbox:  	instructions.Add (new TypeInstruction (offset' TypeOp.Unbox' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Unbox_any:  	instructions.Add (new TypeInstruction (offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Ldelem_i1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int8Ref));  	break;  case PE.OpCode.Ldelem_u1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt8Ref));  	break;  case PE.OpCode.Ldelem_i2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int16Ref));  	break;  case PE.OpCode.Ldelem_u2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt16Ref));  	break;  case PE.OpCode.Ldelem_i4:  case PE.OpCode.Ldelem_u4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int32Ref));  	break;  case PE.OpCode.Ldelem_i:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.IntNativeRef));  	break;  case PE.OpCode.Ldelem_i8:  	// aka ldelem.u8  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int64Ref));  	break;  case PE.OpCode.Ldelem_r4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.SingleRef));  	break;  case PE.OpCode.Ldelem_r8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.DoubleRef));  	break;  case PE.OpCode.Ldelem:  	// aka ldelem.any  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Stelem_i1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int8Ref));  	break;  case PE.OpCode.Stelem_i2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int16Ref));  	break;  case PE.OpCode.Stelem_i4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int32Ref));  	break;  case PE.OpCode.Stelem_i8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int64Ref));  	break;  case PE.OpCode.Stelem_i:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.IntNativeRef));  	break;  case PE.OpCode.Stelem_r4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.SingleRef));  	break;  case PE.OpCode.Stelem_r8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.DoubleRef));  	break;  case PE.OpCode.Stelem:  	// aka stelem.any  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Readonly:  	if (i >= ctxt.Instructions.Length)  		throw new InvalidOperationException ("invalid instruction");  	instruction = ctxt.Instructions [i++];  	if (instruction.OpCode != PE.OpCode.Ldelema)  		throw new InvalidOperationException ("invalid instruction");  	instructions.Add (new LdElemAddrInstruction (offset' true' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Ldelema:  	instructions.Add (new LdElemAddrInstruction (offset' false' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Ldc_i4_0:  	instructions.Add (new LdInt32Instruction (offset' 0));  	break;  case PE.OpCode.Ldc_i4_1:  	instructions.Add (new LdInt32Instruction (offset' 1));  	break;  case PE.OpCode.Ldc_i4_2:  	instructions.Add (new LdInt32Instruction (offset' 2));  	break;  case PE.OpCode.Ldc_i4_3:  	instructions.Add (new LdInt32Instruction (offset' 3));  	break;  case PE.OpCode.Ldc_i4_4:  	instructions.Add (new LdInt32Instruction (offset' 4));  	break;  case PE.OpCode.Ldc_i4_5:  	instructions.Add (new LdInt32Instruction (offset' 5));  	break;  case PE.OpCode.Ldc_i4_6:  	instructions.Add (new LdInt32Instruction (offset' 6));  	break;  case PE.OpCode.Ldc_i4_7:  	instructions.Add (new LdInt32Instruction (offset' 7));  	break;  case PE.OpCode.Ldc_i4_8:  	instructions.Add (new LdInt32Instruction (offset' 8));  	break;  case PE.OpCode.Ldc_i4_m1:  	instructions.Add (new LdInt32Instruction (offset' -1));  	break;  case PE.OpCode.Ldc_i4:  case PE.OpCode.Ldc_i4_s:  	instructions.Add (new LdInt32Instruction (offset' (int)instruction.Value));  	break;  case PE.OpCode.Ldc_i8:  	instructions.Add (new LdInt64Instruction (offset' (long)instruction.Value));  	break;  case PE.OpCode.Ldc_r4:  	instructions.Add (new LdSingleInstruction (offset' (float)instruction.Value));  	break;  case PE.OpCode.Ldc_r8:  	instructions.Add (new LdDoubleInstruction (offset' (double)instruction.Value));  	break;  case PE.OpCode.Ldstr:  	instructions.Add (new LdStringInstruction (offset' (string)instruction.Value));  	break;  case PE.OpCode.Add:  	instructions.Add (new ArithInstruction (offset' ArithOp.Add' false' false));  	break;  case PE.OpCode.Add_ovf:  	instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' false));  	break;  case PE.OpCode.Add_ovf_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' true));  	break;  case PE.OpCode.Sub:  	instructions.Add (new ArithInstruction (offset' ArithOp.Sub' false' false));  	break;  case PE.OpCode.Sub_ovf:  	instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' false));  	break;  case PE.OpCode.Sub_ovf_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' true));  	break;  case PE.OpCode.Mul:  	instructions.Add (new ArithInstruction (offset' ArithOp.Mul' false' false));  	break;  case PE.OpCode.Mul_ovf:  	instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' false));  	break;  case PE.OpCode.Mul_ovf_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' true));  	break;  case PE.OpCode.Div:  	instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' false));  	break;  case PE.OpCode.Div_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' true));  	break;  case PE.OpCode.Rem:  	instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' false));  	break;  case PE.OpCode.Rem_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' true));  	break;  case PE.OpCode.Neg:  	instructions.Add (new ArithInstruction (offset' ArithOp.Neg' false' false));  	break;  case PE.OpCode.And:  	instructions.Add (new ArithInstruction (offset' ArithOp.BitAnd' false' false));  	break;  case PE.OpCode.Or:  	instructions.Add (new ArithInstruction (offset' ArithOp.BitOr' false' false));  	break;  case PE.OpCode.Xor:  	instructions.Add (new ArithInstruction (offset' ArithOp.BitXor' false' false));  	break;  case PE.OpCode.Not:  	instructions.Add (new ArithInstruction (offset' ArithOp.BitNot' false' false));  	break;  case PE.OpCode.Shl:  	instructions.Add (new ArithInstruction (offset' ArithOp.Shl' false' false));  	break;  case PE.OpCode.Shr:  	instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' false));  	break;  case PE.OpCode.Shr_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' true));  	break;  case PE.OpCode.Conv_i1:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' false' false));  	break;  case PE.OpCode.Conv_u1:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' false' false));  	break;  case PE.OpCode.Conv_i2:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' false' false));  	break;  case PE.OpCode.Conv_u2:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' false' false));  	break;  case PE.OpCode.Conv_i4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' false' false));  	break;  case PE.OpCode.Conv_u4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' false' false));  	break;  case PE.OpCode.Conv_i8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' false' false));  	break;  case PE.OpCode.Conv_u8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' false' false));  	break;  case PE.OpCode.Conv_i:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' false' false));  	break;  case PE.OpCode.Conv_u:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' false' false));  	break;  case PE.OpCode.Conv_r4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Single' false' false));  	break;  case PE.OpCode.Conv_r8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' false));  	break;  case PE.OpCode.Conv_r_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' true));  	break;  case PE.OpCode.Conv_ovf_i1:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' false));  	break;  case PE.OpCode.Conv_ovf_u1:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' false));  	break;  case PE.OpCode.Conv_ovf_i2:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' false));  	break;  case PE.OpCode.Conv_ovf_u2:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' false));  	break;  case PE.OpCode.Conv_ovf_i4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' false));  	break;  case PE.OpCode.Conv_ovf_u4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' false));  	break;  case PE.OpCode.Conv_ovf_i8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' false));  	break;  case PE.OpCode.Conv_ovf_u8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' false));  	break;  case PE.OpCode.Conv_ovf_i:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' false));  	break;  case PE.OpCode.Conv_ovf_u:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' false));  	break;  case PE.OpCode.Conv_ovf_i1_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' true));  	break;  case PE.OpCode.Conv_ovf_u1_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' true));  	break;  case PE.OpCode.Conv_ovf_i2_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' true));  	break;  case PE.OpCode.Conv_ovf_u2_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' true));  	break;  case PE.OpCode.Conv_ovf_i4_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' true));  	break;  case PE.OpCode.Conv_ovf_u4_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' true));  	break;  case PE.OpCode.Conv_ovf_i8_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' true));  	break;  case PE.OpCode.Conv_ovf_u8_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' true));  	break;  case PE.OpCode.Conv_ovf_i_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' true));  	break;  case PE.OpCode.Conv_ovf_u_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' true));  	break;  default:  	throw new InvalidOperationException ("invalid instruction");  }  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: switch (instruction.OpCode) {  case PE.OpCode.Cpblk:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Cpblk));  	break;  case PE.OpCode.Initblk:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Initblk));  	break;  case PE.OpCode.Arglist:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Arglist));  	break;  case PE.OpCode.Localloc:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Localloc));  	break;  case PE.OpCode.Jmp:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Jmp));  	break;  case PE.OpCode.Calli:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Calli));  	break;  case PE.OpCode.Sizeof:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Sizeof));  	break;  case PE.OpCode.Mkrefany:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Mkrefany));  	break;  case PE.OpCode.Refanytype:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanytype));  	break;  case PE.OpCode.Refanyval:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanyval));  	break;  case PE.OpCode.Nop:  	instructions.Add (new MiscInstruction (offset' MiscOp.Nop));  	break;  case PE.OpCode.Break:  	instructions.Add (new MiscInstruction (offset' MiscOp.Break));  	break;  case PE.OpCode.Dup:  	instructions.Add (new MiscInstruction (offset' MiscOp.Dup));  	break;  case PE.OpCode.Pop:  	instructions.Add (new MiscInstruction (offset' MiscOp.Pop));  	break;  case PE.OpCode.Ldnull:  	instructions.Add (new MiscInstruction (offset' MiscOp.Ldnull));  	break;  case PE.OpCode.Ckfinite:  	instructions.Add (new MiscInstruction (offset' MiscOp.Ckfinite));  	break;  case PE.OpCode.Throw:  	instructions.Add (new MiscInstruction (offset' MiscOp.Throw));  	break;  case PE.OpCode.Rethrow:  	instructions.Add (new MiscInstruction (offset' MiscOp.Rethrow));  	break;  case PE.OpCode.Ldind_ref:  	instructions.Add (new MiscInstruction (offset' MiscOp.LdindRef));  	break;  case PE.OpCode.Stind_ref:  	instructions.Add (new MiscInstruction (offset' MiscOp.StindRef));  	break;  case PE.OpCode.Ldelem_ref:  	instructions.Add (new MiscInstruction (offset' MiscOp.LdelemRef));  	break;  case PE.OpCode.Stelem_ref:  	instructions.Add (new MiscInstruction (offset' MiscOp.StelemRef));  	break;  case PE.OpCode.Ldlen:  	instructions.Add (new MiscInstruction (offset' MiscOp.Ldlen));  	break;  case PE.OpCode.Ret:  	if (ctxt.ResultType == null)  		instructions.Add (new MiscInstruction (offset' MiscOp.Ret));  	else  		instructions.Add (new MiscInstruction (offset' MiscOp.RetVal));  	break;  case PE.OpCode.Endfilter:  	instructions.Add (new MiscInstruction (offset' MiscOp.Endfilter));  	break;  case PE.OpCode.Endfinally:  	// aka EndFault  	instructions.Add (new MiscInstruction (offset' MiscOp.Endfinally));  	break;  case PE.OpCode.Br_s:  case PE.OpCode.Br:  	instructions.Add (new BranchInstruction (offset' BranchOp.Br' false' (int)instruction.Value));  	break;  case PE.OpCode.Brtrue_s:  // aka brinst.s  case PE.OpCode.Brtrue:  	// aka brinst  	instructions.Add (new BranchInstruction (offset' BranchOp.Brtrue' false' (int)instruction.Value));  	break;  case PE.OpCode.Brfalse_s:  // aka brzero.s' brnull.s  case PE.OpCode.Brfalse:  	// aka brzero' brnull  	instructions.Add (new BranchInstruction (offset' BranchOp.Brfalse' false' (int)instruction.Value));  	break;  case PE.OpCode.Beq:  case PE.OpCode.Beq_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.Breq' false' (int)instruction.Value));  	break;  case PE.OpCode.Bne_un:  case PE.OpCode.Bne_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.Brne' false' (int)instruction.Value));  	break;  case PE.OpCode.Leave:  case PE.OpCode.Leave_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.Leave' false' (int)instruction.Value));  	break;  case PE.OpCode.Blt:  case PE.OpCode.Blt_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' false' (int)instruction.Value));  	break;  case PE.OpCode.Blt_un:  case PE.OpCode.Blt_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' true' (int)instruction.Value));  	break;  case PE.OpCode.Ble:  case PE.OpCode.Ble_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' false' (int)instruction.Value));  	break;  case PE.OpCode.Ble_un:  case PE.OpCode.Ble_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' true' (int)instruction.Value));  	break;  case PE.OpCode.Bgt:  case PE.OpCode.Bgt_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' false' (int)instruction.Value));  	break;  case PE.OpCode.Bgt_un:  case PE.OpCode.Bgt_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' true' (int)instruction.Value));  	break;  case PE.OpCode.Bge:  case PE.OpCode.Bge_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' false' (int)instruction.Value));  	break;  case PE.OpCode.Bge_un:  case PE.OpCode.Bge_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' true' (int)instruction.Value));  	break;  case PE.OpCode.Switch:  	instructions.Add (new SwitchInstruction (offset' (Seq<int>)instruction.Value));  	break;  case PE.OpCode.Ceq:  	instructions.Add (new CompareInstruction (offset' CompareOp.Ceq' false));  	break;  case PE.OpCode.Clt:  	instructions.Add (new CompareInstruction (offset' CompareOp.Clt' false));  	break;  case PE.OpCode.Clt_un:  	instructions.Add (new CompareInstruction (offset' CompareOp.Clt' true));  	break;  case PE.OpCode.Cgt:  	instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' false));  	break;  case PE.OpCode.Cgt_un:  	instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' true));  	break;  case PE.OpCode.Ldarg_0:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));  	break;  case PE.OpCode.Ldarg_1:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));  	break;  case PE.OpCode.Ldarg_2:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));  	break;  case PE.OpCode.Ldarg_3:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));  	break;  case PE.OpCode.Ldarg:  case PE.OpCode.Ldarg_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));  	break;  case PE.OpCode.Ldarga:  case PE.OpCode.Ldarga_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));  	break;  case PE.OpCode.Starg:  case PE.OpCode.Starg_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));  	break;  case PE.OpCode.Ldloc_0:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 0));  	break;  case PE.OpCode.Ldloc_1:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 1));  	break;  case PE.OpCode.Ldloc_2:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 2));  	break;  case PE.OpCode.Ldloc_3:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 3));  	break;  case PE.OpCode.Ldloc:  case PE.OpCode.Ldloc_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));  	break;  case PE.OpCode.Ldloca:  case PE.OpCode.Ldloca_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));  	break;  case PE.OpCode.Stloc_0:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 0));  	break;  case PE.OpCode.Stloc_1:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 1));  	break;  case PE.OpCode.Stloc_2:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 2));  	break;  case PE.OpCode.Stloc_3:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 3));  	break;  case PE.OpCode.Stloc:  case PE.OpCode.Stloc_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));  	break;  case PE.OpCode.Ldfld:  	instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));  	break;  case PE.OpCode.Ldsfld:  	instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));  	break;  case PE.OpCode.Ldflda:  	instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));  	break;  case PE.OpCode.Ldsflda:  	instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));  	break;  case PE.OpCode.Stfld:  	instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));  	break;  case PE.OpCode.Stsfld:  	instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));  	break;  case PE.OpCode.Ldtoken: {  	if (instruction.Value is FieldRef)  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));  	else if (instruction.Value is MethodRef)  		instructions.Add (new MethodInstruction (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));  	else if (instruction.Value is TypeRef)  		// NOTE: May be a higher-kinded type  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));  	else  		throw new InvalidOperationException ("unexpected ldtoken instruction value");  	break;  }  case PE.OpCode.Constrained: {  	var constrained = (TypeRef)instruction.Value;  	if (i >= ctxt.Instructions.Length)  		throw new InvalidOperationException ("invalid instructions");  	instruction = ctxt.Instructions [i++];  	if (instruction.OpCode != PE.OpCode.Callvirt)  		throw new InvalidOperationException ("invalid instruction");  	instructions.Add (new MethodInstruction (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));  	break;  }  case PE.OpCode.Call:  	instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Callvirt:  	instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Ldftn:  	instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Ldvirtftn:  	instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Newobj:  	instructions.Add (new MethodInstruction (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Ldind_i1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int8Ref));  	break;  case PE.OpCode.Ldind_u1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt8Ref));  	break;  case PE.OpCode.Ldind_i2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int16Ref));  	break;  case PE.OpCode.Ldind_u2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt16Ref));  	break;  case PE.OpCode.Ldind_i4:  case PE.OpCode.Ldind_u4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int32Ref));  	break;  case PE.OpCode.Ldind_i8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int64Ref));  	break;  case PE.OpCode.Ldind_i:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.IntNativeRef));  	break;  case PE.OpCode.Ldind_r4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.SingleRef));  	break;  case PE.OpCode.Ldind_r8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.DoubleRef));  	break;  case PE.OpCode.Ldobj:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Stind_i1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int8Ref));  	break;  case PE.OpCode.Stind_i2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int16Ref));  	break;  case PE.OpCode.Stind_i4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int32Ref));  	break;  case PE.OpCode.Stind_i8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int64Ref));  	break;  case PE.OpCode.Stind_i:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.IntNativeRef));  	break;  case PE.OpCode.Stind_r4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.SingleRef));  	break;  case PE.OpCode.Stind_r8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.DoubleRef));  	break;  case PE.OpCode.Stobj:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Cpobj:  	instructions.Add (new TypeInstruction (offset' TypeOp.Cpobj' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Newarr:  	instructions.Add (new TypeInstruction (offset' TypeOp.Newarr' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Initobj:  	instructions.Add (new TypeInstruction (offset' TypeOp.Initobj' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Castclass:  	instructions.Add (new TypeInstruction (offset' TypeOp.Castclass' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Isinst:  	instructions.Add (new TypeInstruction (offset' TypeOp.Isinst' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Box:  	instructions.Add (new TypeInstruction (offset' TypeOp.Box' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Unbox:  	instructions.Add (new TypeInstruction (offset' TypeOp.Unbox' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Unbox_any:  	instructions.Add (new TypeInstruction (offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Ldelem_i1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int8Ref));  	break;  case PE.OpCode.Ldelem_u1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt8Ref));  	break;  case PE.OpCode.Ldelem_i2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int16Ref));  	break;  case PE.OpCode.Ldelem_u2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt16Ref));  	break;  case PE.OpCode.Ldelem_i4:  case PE.OpCode.Ldelem_u4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int32Ref));  	break;  case PE.OpCode.Ldelem_i:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.IntNativeRef));  	break;  case PE.OpCode.Ldelem_i8:  	// aka ldelem.u8  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int64Ref));  	break;  case PE.OpCode.Ldelem_r4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.SingleRef));  	break;  case PE.OpCode.Ldelem_r8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.DoubleRef));  	break;  case PE.OpCode.Ldelem:  	// aka ldelem.any  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Stelem_i1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int8Ref));  	break;  case PE.OpCode.Stelem_i2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int16Ref));  	break;  case PE.OpCode.Stelem_i4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int32Ref));  	break;  case PE.OpCode.Stelem_i8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int64Ref));  	break;  case PE.OpCode.Stelem_i:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.IntNativeRef));  	break;  case PE.OpCode.Stelem_r4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.SingleRef));  	break;  case PE.OpCode.Stelem_r8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.DoubleRef));  	break;  case PE.OpCode.Stelem:  	// aka stelem.any  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Readonly:  	if (i >= ctxt.Instructions.Length)  		throw new InvalidOperationException ("invalid instruction");  	instruction = ctxt.Instructions [i++];  	if (instruction.OpCode != PE.OpCode.Ldelema)  		throw new InvalidOperationException ("invalid instruction");  	instructions.Add (new LdElemAddrInstruction (offset' true' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Ldelema:  	instructions.Add (new LdElemAddrInstruction (offset' false' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Ldc_i4_0:  	instructions.Add (new LdInt32Instruction (offset' 0));  	break;  case PE.OpCode.Ldc_i4_1:  	instructions.Add (new LdInt32Instruction (offset' 1));  	break;  case PE.OpCode.Ldc_i4_2:  	instructions.Add (new LdInt32Instruction (offset' 2));  	break;  case PE.OpCode.Ldc_i4_3:  	instructions.Add (new LdInt32Instruction (offset' 3));  	break;  case PE.OpCode.Ldc_i4_4:  	instructions.Add (new LdInt32Instruction (offset' 4));  	break;  case PE.OpCode.Ldc_i4_5:  	instructions.Add (new LdInt32Instruction (offset' 5));  	break;  case PE.OpCode.Ldc_i4_6:  	instructions.Add (new LdInt32Instruction (offset' 6));  	break;  case PE.OpCode.Ldc_i4_7:  	instructions.Add (new LdInt32Instruction (offset' 7));  	break;  case PE.OpCode.Ldc_i4_8:  	instructions.Add (new LdInt32Instruction (offset' 8));  	break;  case PE.OpCode.Ldc_i4_m1:  	instructions.Add (new LdInt32Instruction (offset' -1));  	break;  case PE.OpCode.Ldc_i4:  case PE.OpCode.Ldc_i4_s:  	instructions.Add (new LdInt32Instruction (offset' (int)instruction.Value));  	break;  case PE.OpCode.Ldc_i8:  	instructions.Add (new LdInt64Instruction (offset' (long)instruction.Value));  	break;  case PE.OpCode.Ldc_r4:  	instructions.Add (new LdSingleInstruction (offset' (float)instruction.Value));  	break;  case PE.OpCode.Ldc_r8:  	instructions.Add (new LdDoubleInstruction (offset' (double)instruction.Value));  	break;  case PE.OpCode.Ldstr:  	instructions.Add (new LdStringInstruction (offset' (string)instruction.Value));  	break;  case PE.OpCode.Add:  	instructions.Add (new ArithInstruction (offset' ArithOp.Add' false' false));  	break;  case PE.OpCode.Add_ovf:  	instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' false));  	break;  case PE.OpCode.Add_ovf_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' true));  	break;  case PE.OpCode.Sub:  	instructions.Add (new ArithInstruction (offset' ArithOp.Sub' false' false));  	break;  case PE.OpCode.Sub_ovf:  	instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' false));  	break;  case PE.OpCode.Sub_ovf_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' true));  	break;  case PE.OpCode.Mul:  	instructions.Add (new ArithInstruction (offset' ArithOp.Mul' false' false));  	break;  case PE.OpCode.Mul_ovf:  	instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' false));  	break;  case PE.OpCode.Mul_ovf_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' true));  	break;  case PE.OpCode.Div:  	instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' false));  	break;  case PE.OpCode.Div_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' true));  	break;  case PE.OpCode.Rem:  	instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' false));  	break;  case PE.OpCode.Rem_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' true));  	break;  case PE.OpCode.Neg:  	instructions.Add (new ArithInstruction (offset' ArithOp.Neg' false' false));  	break;  case PE.OpCode.And:  	instructions.Add (new ArithInstruction (offset' ArithOp.BitAnd' false' false));  	break;  case PE.OpCode.Or:  	instructions.Add (new ArithInstruction (offset' ArithOp.BitOr' false' false));  	break;  case PE.OpCode.Xor:  	instructions.Add (new ArithInstruction (offset' ArithOp.BitXor' false' false));  	break;  case PE.OpCode.Not:  	instructions.Add (new ArithInstruction (offset' ArithOp.BitNot' false' false));  	break;  case PE.OpCode.Shl:  	instructions.Add (new ArithInstruction (offset' ArithOp.Shl' false' false));  	break;  case PE.OpCode.Shr:  	instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' false));  	break;  case PE.OpCode.Shr_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' true));  	break;  case PE.OpCode.Conv_i1:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' false' false));  	break;  case PE.OpCode.Conv_u1:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' false' false));  	break;  case PE.OpCode.Conv_i2:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' false' false));  	break;  case PE.OpCode.Conv_u2:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' false' false));  	break;  case PE.OpCode.Conv_i4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' false' false));  	break;  case PE.OpCode.Conv_u4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' false' false));  	break;  case PE.OpCode.Conv_i8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' false' false));  	break;  case PE.OpCode.Conv_u8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' false' false));  	break;  case PE.OpCode.Conv_i:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' false' false));  	break;  case PE.OpCode.Conv_u:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' false' false));  	break;  case PE.OpCode.Conv_r4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Single' false' false));  	break;  case PE.OpCode.Conv_r8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' false));  	break;  case PE.OpCode.Conv_r_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' true));  	break;  case PE.OpCode.Conv_ovf_i1:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' false));  	break;  case PE.OpCode.Conv_ovf_u1:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' false));  	break;  case PE.OpCode.Conv_ovf_i2:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' false));  	break;  case PE.OpCode.Conv_ovf_u2:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' false));  	break;  case PE.OpCode.Conv_ovf_i4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' false));  	break;  case PE.OpCode.Conv_ovf_u4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' false));  	break;  case PE.OpCode.Conv_ovf_i8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' false));  	break;  case PE.OpCode.Conv_ovf_u8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' false));  	break;  case PE.OpCode.Conv_ovf_i:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' false));  	break;  case PE.OpCode.Conv_ovf_u:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' false));  	break;  case PE.OpCode.Conv_ovf_i1_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' true));  	break;  case PE.OpCode.Conv_ovf_u1_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' true));  	break;  case PE.OpCode.Conv_ovf_i2_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' true));  	break;  case PE.OpCode.Conv_ovf_u2_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' true));  	break;  case PE.OpCode.Conv_ovf_i4_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' true));  	break;  case PE.OpCode.Conv_ovf_u4_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' true));  	break;  case PE.OpCode.Conv_ovf_i8_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' true));  	break;  case PE.OpCode.Conv_ovf_u8_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' true));  	break;  case PE.OpCode.Conv_ovf_i_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' true));  	break;  case PE.OpCode.Conv_ovf_u_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' true));  	break;  default:  	throw new InvalidOperationException ("invalid instruction");  }  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: switch (instruction.OpCode) {  case PE.OpCode.Cpblk:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Cpblk));  	break;  case PE.OpCode.Initblk:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Initblk));  	break;  case PE.OpCode.Arglist:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Arglist));  	break;  case PE.OpCode.Localloc:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Localloc));  	break;  case PE.OpCode.Jmp:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Jmp));  	break;  case PE.OpCode.Calli:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Calli));  	break;  case PE.OpCode.Sizeof:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Sizeof));  	break;  case PE.OpCode.Mkrefany:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Mkrefany));  	break;  case PE.OpCode.Refanytype:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanytype));  	break;  case PE.OpCode.Refanyval:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanyval));  	break;  case PE.OpCode.Nop:  	instructions.Add (new MiscInstruction (offset' MiscOp.Nop));  	break;  case PE.OpCode.Break:  	instructions.Add (new MiscInstruction (offset' MiscOp.Break));  	break;  case PE.OpCode.Dup:  	instructions.Add (new MiscInstruction (offset' MiscOp.Dup));  	break;  case PE.OpCode.Pop:  	instructions.Add (new MiscInstruction (offset' MiscOp.Pop));  	break;  case PE.OpCode.Ldnull:  	instructions.Add (new MiscInstruction (offset' MiscOp.Ldnull));  	break;  case PE.OpCode.Ckfinite:  	instructions.Add (new MiscInstruction (offset' MiscOp.Ckfinite));  	break;  case PE.OpCode.Throw:  	instructions.Add (new MiscInstruction (offset' MiscOp.Throw));  	break;  case PE.OpCode.Rethrow:  	instructions.Add (new MiscInstruction (offset' MiscOp.Rethrow));  	break;  case PE.OpCode.Ldind_ref:  	instructions.Add (new MiscInstruction (offset' MiscOp.LdindRef));  	break;  case PE.OpCode.Stind_ref:  	instructions.Add (new MiscInstruction (offset' MiscOp.StindRef));  	break;  case PE.OpCode.Ldelem_ref:  	instructions.Add (new MiscInstruction (offset' MiscOp.LdelemRef));  	break;  case PE.OpCode.Stelem_ref:  	instructions.Add (new MiscInstruction (offset' MiscOp.StelemRef));  	break;  case PE.OpCode.Ldlen:  	instructions.Add (new MiscInstruction (offset' MiscOp.Ldlen));  	break;  case PE.OpCode.Ret:  	if (ctxt.ResultType == null)  		instructions.Add (new MiscInstruction (offset' MiscOp.Ret));  	else  		instructions.Add (new MiscInstruction (offset' MiscOp.RetVal));  	break;  case PE.OpCode.Endfilter:  	instructions.Add (new MiscInstruction (offset' MiscOp.Endfilter));  	break;  case PE.OpCode.Endfinally:  	// aka EndFault  	instructions.Add (new MiscInstruction (offset' MiscOp.Endfinally));  	break;  case PE.OpCode.Br_s:  case PE.OpCode.Br:  	instructions.Add (new BranchInstruction (offset' BranchOp.Br' false' (int)instruction.Value));  	break;  case PE.OpCode.Brtrue_s:  // aka brinst.s  case PE.OpCode.Brtrue:  	// aka brinst  	instructions.Add (new BranchInstruction (offset' BranchOp.Brtrue' false' (int)instruction.Value));  	break;  case PE.OpCode.Brfalse_s:  // aka brzero.s' brnull.s  case PE.OpCode.Brfalse:  	// aka brzero' brnull  	instructions.Add (new BranchInstruction (offset' BranchOp.Brfalse' false' (int)instruction.Value));  	break;  case PE.OpCode.Beq:  case PE.OpCode.Beq_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.Breq' false' (int)instruction.Value));  	break;  case PE.OpCode.Bne_un:  case PE.OpCode.Bne_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.Brne' false' (int)instruction.Value));  	break;  case PE.OpCode.Leave:  case PE.OpCode.Leave_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.Leave' false' (int)instruction.Value));  	break;  case PE.OpCode.Blt:  case PE.OpCode.Blt_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' false' (int)instruction.Value));  	break;  case PE.OpCode.Blt_un:  case PE.OpCode.Blt_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' true' (int)instruction.Value));  	break;  case PE.OpCode.Ble:  case PE.OpCode.Ble_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' false' (int)instruction.Value));  	break;  case PE.OpCode.Ble_un:  case PE.OpCode.Ble_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' true' (int)instruction.Value));  	break;  case PE.OpCode.Bgt:  case PE.OpCode.Bgt_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' false' (int)instruction.Value));  	break;  case PE.OpCode.Bgt_un:  case PE.OpCode.Bgt_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' true' (int)instruction.Value));  	break;  case PE.OpCode.Bge:  case PE.OpCode.Bge_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' false' (int)instruction.Value));  	break;  case PE.OpCode.Bge_un:  case PE.OpCode.Bge_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' true' (int)instruction.Value));  	break;  case PE.OpCode.Switch:  	instructions.Add (new SwitchInstruction (offset' (Seq<int>)instruction.Value));  	break;  case PE.OpCode.Ceq:  	instructions.Add (new CompareInstruction (offset' CompareOp.Ceq' false));  	break;  case PE.OpCode.Clt:  	instructions.Add (new CompareInstruction (offset' CompareOp.Clt' false));  	break;  case PE.OpCode.Clt_un:  	instructions.Add (new CompareInstruction (offset' CompareOp.Clt' true));  	break;  case PE.OpCode.Cgt:  	instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' false));  	break;  case PE.OpCode.Cgt_un:  	instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' true));  	break;  case PE.OpCode.Ldarg_0:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));  	break;  case PE.OpCode.Ldarg_1:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));  	break;  case PE.OpCode.Ldarg_2:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));  	break;  case PE.OpCode.Ldarg_3:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));  	break;  case PE.OpCode.Ldarg:  case PE.OpCode.Ldarg_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));  	break;  case PE.OpCode.Ldarga:  case PE.OpCode.Ldarga_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));  	break;  case PE.OpCode.Starg:  case PE.OpCode.Starg_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));  	break;  case PE.OpCode.Ldloc_0:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 0));  	break;  case PE.OpCode.Ldloc_1:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 1));  	break;  case PE.OpCode.Ldloc_2:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 2));  	break;  case PE.OpCode.Ldloc_3:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 3));  	break;  case PE.OpCode.Ldloc:  case PE.OpCode.Ldloc_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));  	break;  case PE.OpCode.Ldloca:  case PE.OpCode.Ldloca_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));  	break;  case PE.OpCode.Stloc_0:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 0));  	break;  case PE.OpCode.Stloc_1:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 1));  	break;  case PE.OpCode.Stloc_2:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 2));  	break;  case PE.OpCode.Stloc_3:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 3));  	break;  case PE.OpCode.Stloc:  case PE.OpCode.Stloc_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));  	break;  case PE.OpCode.Ldfld:  	instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));  	break;  case PE.OpCode.Ldsfld:  	instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));  	break;  case PE.OpCode.Ldflda:  	instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));  	break;  case PE.OpCode.Ldsflda:  	instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));  	break;  case PE.OpCode.Stfld:  	instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));  	break;  case PE.OpCode.Stsfld:  	instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));  	break;  case PE.OpCode.Ldtoken: {  	if (instruction.Value is FieldRef)  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));  	else if (instruction.Value is MethodRef)  		instructions.Add (new MethodInstruction (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));  	else if (instruction.Value is TypeRef)  		// NOTE: May be a higher-kinded type  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));  	else  		throw new InvalidOperationException ("unexpected ldtoken instruction value");  	break;  }  case PE.OpCode.Constrained: {  	var constrained = (TypeRef)instruction.Value;  	if (i >= ctxt.Instructions.Length)  		throw new InvalidOperationException ("invalid instructions");  	instruction = ctxt.Instructions [i++];  	if (instruction.OpCode != PE.OpCode.Callvirt)  		throw new InvalidOperationException ("invalid instruction");  	instructions.Add (new MethodInstruction (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));  	break;  }  case PE.OpCode.Call:  	instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Callvirt:  	instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Ldftn:  	instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Ldvirtftn:  	instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Newobj:  	instructions.Add (new MethodInstruction (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Ldind_i1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int8Ref));  	break;  case PE.OpCode.Ldind_u1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt8Ref));  	break;  case PE.OpCode.Ldind_i2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int16Ref));  	break;  case PE.OpCode.Ldind_u2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt16Ref));  	break;  case PE.OpCode.Ldind_i4:  case PE.OpCode.Ldind_u4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int32Ref));  	break;  case PE.OpCode.Ldind_i8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int64Ref));  	break;  case PE.OpCode.Ldind_i:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.IntNativeRef));  	break;  case PE.OpCode.Ldind_r4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.SingleRef));  	break;  case PE.OpCode.Ldind_r8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.DoubleRef));  	break;  case PE.OpCode.Ldobj:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Stind_i1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int8Ref));  	break;  case PE.OpCode.Stind_i2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int16Ref));  	break;  case PE.OpCode.Stind_i4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int32Ref));  	break;  case PE.OpCode.Stind_i8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int64Ref));  	break;  case PE.OpCode.Stind_i:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.IntNativeRef));  	break;  case PE.OpCode.Stind_r4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.SingleRef));  	break;  case PE.OpCode.Stind_r8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.DoubleRef));  	break;  case PE.OpCode.Stobj:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Cpobj:  	instructions.Add (new TypeInstruction (offset' TypeOp.Cpobj' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Newarr:  	instructions.Add (new TypeInstruction (offset' TypeOp.Newarr' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Initobj:  	instructions.Add (new TypeInstruction (offset' TypeOp.Initobj' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Castclass:  	instructions.Add (new TypeInstruction (offset' TypeOp.Castclass' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Isinst:  	instructions.Add (new TypeInstruction (offset' TypeOp.Isinst' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Box:  	instructions.Add (new TypeInstruction (offset' TypeOp.Box' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Unbox:  	instructions.Add (new TypeInstruction (offset' TypeOp.Unbox' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Unbox_any:  	instructions.Add (new TypeInstruction (offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Ldelem_i1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int8Ref));  	break;  case PE.OpCode.Ldelem_u1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt8Ref));  	break;  case PE.OpCode.Ldelem_i2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int16Ref));  	break;  case PE.OpCode.Ldelem_u2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt16Ref));  	break;  case PE.OpCode.Ldelem_i4:  case PE.OpCode.Ldelem_u4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int32Ref));  	break;  case PE.OpCode.Ldelem_i:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.IntNativeRef));  	break;  case PE.OpCode.Ldelem_i8:  	// aka ldelem.u8  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int64Ref));  	break;  case PE.OpCode.Ldelem_r4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.SingleRef));  	break;  case PE.OpCode.Ldelem_r8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.DoubleRef));  	break;  case PE.OpCode.Ldelem:  	// aka ldelem.any  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Stelem_i1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int8Ref));  	break;  case PE.OpCode.Stelem_i2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int16Ref));  	break;  case PE.OpCode.Stelem_i4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int32Ref));  	break;  case PE.OpCode.Stelem_i8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int64Ref));  	break;  case PE.OpCode.Stelem_i:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.IntNativeRef));  	break;  case PE.OpCode.Stelem_r4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.SingleRef));  	break;  case PE.OpCode.Stelem_r8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.DoubleRef));  	break;  case PE.OpCode.Stelem:  	// aka stelem.any  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Readonly:  	if (i >= ctxt.Instructions.Length)  		throw new InvalidOperationException ("invalid instruction");  	instruction = ctxt.Instructions [i++];  	if (instruction.OpCode != PE.OpCode.Ldelema)  		throw new InvalidOperationException ("invalid instruction");  	instructions.Add (new LdElemAddrInstruction (offset' true' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Ldelema:  	instructions.Add (new LdElemAddrInstruction (offset' false' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Ldc_i4_0:  	instructions.Add (new LdInt32Instruction (offset' 0));  	break;  case PE.OpCode.Ldc_i4_1:  	instructions.Add (new LdInt32Instruction (offset' 1));  	break;  case PE.OpCode.Ldc_i4_2:  	instructions.Add (new LdInt32Instruction (offset' 2));  	break;  case PE.OpCode.Ldc_i4_3:  	instructions.Add (new LdInt32Instruction (offset' 3));  	break;  case PE.OpCode.Ldc_i4_4:  	instructions.Add (new LdInt32Instruction (offset' 4));  	break;  case PE.OpCode.Ldc_i4_5:  	instructions.Add (new LdInt32Instruction (offset' 5));  	break;  case PE.OpCode.Ldc_i4_6:  	instructions.Add (new LdInt32Instruction (offset' 6));  	break;  case PE.OpCode.Ldc_i4_7:  	instructions.Add (new LdInt32Instruction (offset' 7));  	break;  case PE.OpCode.Ldc_i4_8:  	instructions.Add (new LdInt32Instruction (offset' 8));  	break;  case PE.OpCode.Ldc_i4_m1:  	instructions.Add (new LdInt32Instruction (offset' -1));  	break;  case PE.OpCode.Ldc_i4:  case PE.OpCode.Ldc_i4_s:  	instructions.Add (new LdInt32Instruction (offset' (int)instruction.Value));  	break;  case PE.OpCode.Ldc_i8:  	instructions.Add (new LdInt64Instruction (offset' (long)instruction.Value));  	break;  case PE.OpCode.Ldc_r4:  	instructions.Add (new LdSingleInstruction (offset' (float)instruction.Value));  	break;  case PE.OpCode.Ldc_r8:  	instructions.Add (new LdDoubleInstruction (offset' (double)instruction.Value));  	break;  case PE.OpCode.Ldstr:  	instructions.Add (new LdStringInstruction (offset' (string)instruction.Value));  	break;  case PE.OpCode.Add:  	instructions.Add (new ArithInstruction (offset' ArithOp.Add' false' false));  	break;  case PE.OpCode.Add_ovf:  	instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' false));  	break;  case PE.OpCode.Add_ovf_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' true));  	break;  case PE.OpCode.Sub:  	instructions.Add (new ArithInstruction (offset' ArithOp.Sub' false' false));  	break;  case PE.OpCode.Sub_ovf:  	instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' false));  	break;  case PE.OpCode.Sub_ovf_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' true));  	break;  case PE.OpCode.Mul:  	instructions.Add (new ArithInstruction (offset' ArithOp.Mul' false' false));  	break;  case PE.OpCode.Mul_ovf:  	instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' false));  	break;  case PE.OpCode.Mul_ovf_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' true));  	break;  case PE.OpCode.Div:  	instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' false));  	break;  case PE.OpCode.Div_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' true));  	break;  case PE.OpCode.Rem:  	instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' false));  	break;  case PE.OpCode.Rem_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' true));  	break;  case PE.OpCode.Neg:  	instructions.Add (new ArithInstruction (offset' ArithOp.Neg' false' false));  	break;  case PE.OpCode.And:  	instructions.Add (new ArithInstruction (offset' ArithOp.BitAnd' false' false));  	break;  case PE.OpCode.Or:  	instructions.Add (new ArithInstruction (offset' ArithOp.BitOr' false' false));  	break;  case PE.OpCode.Xor:  	instructions.Add (new ArithInstruction (offset' ArithOp.BitXor' false' false));  	break;  case PE.OpCode.Not:  	instructions.Add (new ArithInstruction (offset' ArithOp.BitNot' false' false));  	break;  case PE.OpCode.Shl:  	instructions.Add (new ArithInstruction (offset' ArithOp.Shl' false' false));  	break;  case PE.OpCode.Shr:  	instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' false));  	break;  case PE.OpCode.Shr_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' true));  	break;  case PE.OpCode.Conv_i1:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' false' false));  	break;  case PE.OpCode.Conv_u1:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' false' false));  	break;  case PE.OpCode.Conv_i2:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' false' false));  	break;  case PE.OpCode.Conv_u2:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' false' false));  	break;  case PE.OpCode.Conv_i4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' false' false));  	break;  case PE.OpCode.Conv_u4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' false' false));  	break;  case PE.OpCode.Conv_i8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' false' false));  	break;  case PE.OpCode.Conv_u8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' false' false));  	break;  case PE.OpCode.Conv_i:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' false' false));  	break;  case PE.OpCode.Conv_u:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' false' false));  	break;  case PE.OpCode.Conv_r4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Single' false' false));  	break;  case PE.OpCode.Conv_r8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' false));  	break;  case PE.OpCode.Conv_r_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' true));  	break;  case PE.OpCode.Conv_ovf_i1:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' false));  	break;  case PE.OpCode.Conv_ovf_u1:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' false));  	break;  case PE.OpCode.Conv_ovf_i2:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' false));  	break;  case PE.OpCode.Conv_ovf_u2:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' false));  	break;  case PE.OpCode.Conv_ovf_i4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' false));  	break;  case PE.OpCode.Conv_ovf_u4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' false));  	break;  case PE.OpCode.Conv_ovf_i8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' false));  	break;  case PE.OpCode.Conv_ovf_u8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' false));  	break;  case PE.OpCode.Conv_ovf_i:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' false));  	break;  case PE.OpCode.Conv_ovf_u:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' false));  	break;  case PE.OpCode.Conv_ovf_i1_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' true));  	break;  case PE.OpCode.Conv_ovf_u1_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' true));  	break;  case PE.OpCode.Conv_ovf_i2_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' true));  	break;  case PE.OpCode.Conv_ovf_u2_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' true));  	break;  case PE.OpCode.Conv_ovf_i4_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' true));  	break;  case PE.OpCode.Conv_ovf_u4_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' true));  	break;  case PE.OpCode.Conv_ovf_i8_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' true));  	break;  case PE.OpCode.Conv_ovf_u8_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' true));  	break;  case PE.OpCode.Conv_ovf_i_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' true));  	break;  case PE.OpCode.Conv_ovf_u_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' true));  	break;  default:  	throw new InvalidOperationException ("invalid instruction");  }  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: switch (instruction.OpCode) {  case PE.OpCode.Cpblk:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Cpblk));  	break;  case PE.OpCode.Initblk:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Initblk));  	break;  case PE.OpCode.Arglist:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Arglist));  	break;  case PE.OpCode.Localloc:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Localloc));  	break;  case PE.OpCode.Jmp:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Jmp));  	break;  case PE.OpCode.Calli:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Calli));  	break;  case PE.OpCode.Sizeof:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Sizeof));  	break;  case PE.OpCode.Mkrefany:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Mkrefany));  	break;  case PE.OpCode.Refanytype:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanytype));  	break;  case PE.OpCode.Refanyval:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanyval));  	break;  case PE.OpCode.Nop:  	instructions.Add (new MiscInstruction (offset' MiscOp.Nop));  	break;  case PE.OpCode.Break:  	instructions.Add (new MiscInstruction (offset' MiscOp.Break));  	break;  case PE.OpCode.Dup:  	instructions.Add (new MiscInstruction (offset' MiscOp.Dup));  	break;  case PE.OpCode.Pop:  	instructions.Add (new MiscInstruction (offset' MiscOp.Pop));  	break;  case PE.OpCode.Ldnull:  	instructions.Add (new MiscInstruction (offset' MiscOp.Ldnull));  	break;  case PE.OpCode.Ckfinite:  	instructions.Add (new MiscInstruction (offset' MiscOp.Ckfinite));  	break;  case PE.OpCode.Throw:  	instructions.Add (new MiscInstruction (offset' MiscOp.Throw));  	break;  case PE.OpCode.Rethrow:  	instructions.Add (new MiscInstruction (offset' MiscOp.Rethrow));  	break;  case PE.OpCode.Ldind_ref:  	instructions.Add (new MiscInstruction (offset' MiscOp.LdindRef));  	break;  case PE.OpCode.Stind_ref:  	instructions.Add (new MiscInstruction (offset' MiscOp.StindRef));  	break;  case PE.OpCode.Ldelem_ref:  	instructions.Add (new MiscInstruction (offset' MiscOp.LdelemRef));  	break;  case PE.OpCode.Stelem_ref:  	instructions.Add (new MiscInstruction (offset' MiscOp.StelemRef));  	break;  case PE.OpCode.Ldlen:  	instructions.Add (new MiscInstruction (offset' MiscOp.Ldlen));  	break;  case PE.OpCode.Ret:  	if (ctxt.ResultType == null)  		instructions.Add (new MiscInstruction (offset' MiscOp.Ret));  	else  		instructions.Add (new MiscInstruction (offset' MiscOp.RetVal));  	break;  case PE.OpCode.Endfilter:  	instructions.Add (new MiscInstruction (offset' MiscOp.Endfilter));  	break;  case PE.OpCode.Endfinally:  	// aka EndFault  	instructions.Add (new MiscInstruction (offset' MiscOp.Endfinally));  	break;  case PE.OpCode.Br_s:  case PE.OpCode.Br:  	instructions.Add (new BranchInstruction (offset' BranchOp.Br' false' (int)instruction.Value));  	break;  case PE.OpCode.Brtrue_s:  // aka brinst.s  case PE.OpCode.Brtrue:  	// aka brinst  	instructions.Add (new BranchInstruction (offset' BranchOp.Brtrue' false' (int)instruction.Value));  	break;  case PE.OpCode.Brfalse_s:  // aka brzero.s' brnull.s  case PE.OpCode.Brfalse:  	// aka brzero' brnull  	instructions.Add (new BranchInstruction (offset' BranchOp.Brfalse' false' (int)instruction.Value));  	break;  case PE.OpCode.Beq:  case PE.OpCode.Beq_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.Breq' false' (int)instruction.Value));  	break;  case PE.OpCode.Bne_un:  case PE.OpCode.Bne_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.Brne' false' (int)instruction.Value));  	break;  case PE.OpCode.Leave:  case PE.OpCode.Leave_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.Leave' false' (int)instruction.Value));  	break;  case PE.OpCode.Blt:  case PE.OpCode.Blt_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' false' (int)instruction.Value));  	break;  case PE.OpCode.Blt_un:  case PE.OpCode.Blt_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' true' (int)instruction.Value));  	break;  case PE.OpCode.Ble:  case PE.OpCode.Ble_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' false' (int)instruction.Value));  	break;  case PE.OpCode.Ble_un:  case PE.OpCode.Ble_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' true' (int)instruction.Value));  	break;  case PE.OpCode.Bgt:  case PE.OpCode.Bgt_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' false' (int)instruction.Value));  	break;  case PE.OpCode.Bgt_un:  case PE.OpCode.Bgt_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' true' (int)instruction.Value));  	break;  case PE.OpCode.Bge:  case PE.OpCode.Bge_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' false' (int)instruction.Value));  	break;  case PE.OpCode.Bge_un:  case PE.OpCode.Bge_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' true' (int)instruction.Value));  	break;  case PE.OpCode.Switch:  	instructions.Add (new SwitchInstruction (offset' (Seq<int>)instruction.Value));  	break;  case PE.OpCode.Ceq:  	instructions.Add (new CompareInstruction (offset' CompareOp.Ceq' false));  	break;  case PE.OpCode.Clt:  	instructions.Add (new CompareInstruction (offset' CompareOp.Clt' false));  	break;  case PE.OpCode.Clt_un:  	instructions.Add (new CompareInstruction (offset' CompareOp.Clt' true));  	break;  case PE.OpCode.Cgt:  	instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' false));  	break;  case PE.OpCode.Cgt_un:  	instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' true));  	break;  case PE.OpCode.Ldarg_0:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));  	break;  case PE.OpCode.Ldarg_1:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));  	break;  case PE.OpCode.Ldarg_2:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));  	break;  case PE.OpCode.Ldarg_3:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));  	break;  case PE.OpCode.Ldarg:  case PE.OpCode.Ldarg_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));  	break;  case PE.OpCode.Ldarga:  case PE.OpCode.Ldarga_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));  	break;  case PE.OpCode.Starg:  case PE.OpCode.Starg_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));  	break;  case PE.OpCode.Ldloc_0:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 0));  	break;  case PE.OpCode.Ldloc_1:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 1));  	break;  case PE.OpCode.Ldloc_2:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 2));  	break;  case PE.OpCode.Ldloc_3:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 3));  	break;  case PE.OpCode.Ldloc:  case PE.OpCode.Ldloc_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));  	break;  case PE.OpCode.Ldloca:  case PE.OpCode.Ldloca_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));  	break;  case PE.OpCode.Stloc_0:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 0));  	break;  case PE.OpCode.Stloc_1:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 1));  	break;  case PE.OpCode.Stloc_2:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 2));  	break;  case PE.OpCode.Stloc_3:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 3));  	break;  case PE.OpCode.Stloc:  case PE.OpCode.Stloc_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));  	break;  case PE.OpCode.Ldfld:  	instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));  	break;  case PE.OpCode.Ldsfld:  	instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));  	break;  case PE.OpCode.Ldflda:  	instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));  	break;  case PE.OpCode.Ldsflda:  	instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));  	break;  case PE.OpCode.Stfld:  	instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));  	break;  case PE.OpCode.Stsfld:  	instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));  	break;  case PE.OpCode.Ldtoken: {  	if (instruction.Value is FieldRef)  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));  	else if (instruction.Value is MethodRef)  		instructions.Add (new MethodInstruction (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));  	else if (instruction.Value is TypeRef)  		// NOTE: May be a higher-kinded type  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));  	else  		throw new InvalidOperationException ("unexpected ldtoken instruction value");  	break;  }  case PE.OpCode.Constrained: {  	var constrained = (TypeRef)instruction.Value;  	if (i >= ctxt.Instructions.Length)  		throw new InvalidOperationException ("invalid instructions");  	instruction = ctxt.Instructions [i++];  	if (instruction.OpCode != PE.OpCode.Callvirt)  		throw new InvalidOperationException ("invalid instruction");  	instructions.Add (new MethodInstruction (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));  	break;  }  case PE.OpCode.Call:  	instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Callvirt:  	instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Ldftn:  	instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Ldvirtftn:  	instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Newobj:  	instructions.Add (new MethodInstruction (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Ldind_i1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int8Ref));  	break;  case PE.OpCode.Ldind_u1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt8Ref));  	break;  case PE.OpCode.Ldind_i2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int16Ref));  	break;  case PE.OpCode.Ldind_u2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt16Ref));  	break;  case PE.OpCode.Ldind_i4:  case PE.OpCode.Ldind_u4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int32Ref));  	break;  case PE.OpCode.Ldind_i8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int64Ref));  	break;  case PE.OpCode.Ldind_i:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.IntNativeRef));  	break;  case PE.OpCode.Ldind_r4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.SingleRef));  	break;  case PE.OpCode.Ldind_r8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.DoubleRef));  	break;  case PE.OpCode.Ldobj:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Stind_i1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int8Ref));  	break;  case PE.OpCode.Stind_i2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int16Ref));  	break;  case PE.OpCode.Stind_i4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int32Ref));  	break;  case PE.OpCode.Stind_i8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int64Ref));  	break;  case PE.OpCode.Stind_i:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.IntNativeRef));  	break;  case PE.OpCode.Stind_r4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.SingleRef));  	break;  case PE.OpCode.Stind_r8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.DoubleRef));  	break;  case PE.OpCode.Stobj:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Cpobj:  	instructions.Add (new TypeInstruction (offset' TypeOp.Cpobj' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Newarr:  	instructions.Add (new TypeInstruction (offset' TypeOp.Newarr' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Initobj:  	instructions.Add (new TypeInstruction (offset' TypeOp.Initobj' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Castclass:  	instructions.Add (new TypeInstruction (offset' TypeOp.Castclass' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Isinst:  	instructions.Add (new TypeInstruction (offset' TypeOp.Isinst' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Box:  	instructions.Add (new TypeInstruction (offset' TypeOp.Box' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Unbox:  	instructions.Add (new TypeInstruction (offset' TypeOp.Unbox' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Unbox_any:  	instructions.Add (new TypeInstruction (offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Ldelem_i1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int8Ref));  	break;  case PE.OpCode.Ldelem_u1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt8Ref));  	break;  case PE.OpCode.Ldelem_i2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int16Ref));  	break;  case PE.OpCode.Ldelem_u2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt16Ref));  	break;  case PE.OpCode.Ldelem_i4:  case PE.OpCode.Ldelem_u4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int32Ref));  	break;  case PE.OpCode.Ldelem_i:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.IntNativeRef));  	break;  case PE.OpCode.Ldelem_i8:  	// aka ldelem.u8  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int64Ref));  	break;  case PE.OpCode.Ldelem_r4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.SingleRef));  	break;  case PE.OpCode.Ldelem_r8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.DoubleRef));  	break;  case PE.OpCode.Ldelem:  	// aka ldelem.any  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Stelem_i1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int8Ref));  	break;  case PE.OpCode.Stelem_i2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int16Ref));  	break;  case PE.OpCode.Stelem_i4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int32Ref));  	break;  case PE.OpCode.Stelem_i8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int64Ref));  	break;  case PE.OpCode.Stelem_i:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.IntNativeRef));  	break;  case PE.OpCode.Stelem_r4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.SingleRef));  	break;  case PE.OpCode.Stelem_r8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.DoubleRef));  	break;  case PE.OpCode.Stelem:  	// aka stelem.any  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Readonly:  	if (i >= ctxt.Instructions.Length)  		throw new InvalidOperationException ("invalid instruction");  	instruction = ctxt.Instructions [i++];  	if (instruction.OpCode != PE.OpCode.Ldelema)  		throw new InvalidOperationException ("invalid instruction");  	instructions.Add (new LdElemAddrInstruction (offset' true' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Ldelema:  	instructions.Add (new LdElemAddrInstruction (offset' false' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Ldc_i4_0:  	instructions.Add (new LdInt32Instruction (offset' 0));  	break;  case PE.OpCode.Ldc_i4_1:  	instructions.Add (new LdInt32Instruction (offset' 1));  	break;  case PE.OpCode.Ldc_i4_2:  	instructions.Add (new LdInt32Instruction (offset' 2));  	break;  case PE.OpCode.Ldc_i4_3:  	instructions.Add (new LdInt32Instruction (offset' 3));  	break;  case PE.OpCode.Ldc_i4_4:  	instructions.Add (new LdInt32Instruction (offset' 4));  	break;  case PE.OpCode.Ldc_i4_5:  	instructions.Add (new LdInt32Instruction (offset' 5));  	break;  case PE.OpCode.Ldc_i4_6:  	instructions.Add (new LdInt32Instruction (offset' 6));  	break;  case PE.OpCode.Ldc_i4_7:  	instructions.Add (new LdInt32Instruction (offset' 7));  	break;  case PE.OpCode.Ldc_i4_8:  	instructions.Add (new LdInt32Instruction (offset' 8));  	break;  case PE.OpCode.Ldc_i4_m1:  	instructions.Add (new LdInt32Instruction (offset' -1));  	break;  case PE.OpCode.Ldc_i4:  case PE.OpCode.Ldc_i4_s:  	instructions.Add (new LdInt32Instruction (offset' (int)instruction.Value));  	break;  case PE.OpCode.Ldc_i8:  	instructions.Add (new LdInt64Instruction (offset' (long)instruction.Value));  	break;  case PE.OpCode.Ldc_r4:  	instructions.Add (new LdSingleInstruction (offset' (float)instruction.Value));  	break;  case PE.OpCode.Ldc_r8:  	instructions.Add (new LdDoubleInstruction (offset' (double)instruction.Value));  	break;  case PE.OpCode.Ldstr:  	instructions.Add (new LdStringInstruction (offset' (string)instruction.Value));  	break;  case PE.OpCode.Add:  	instructions.Add (new ArithInstruction (offset' ArithOp.Add' false' false));  	break;  case PE.OpCode.Add_ovf:  	instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' false));  	break;  case PE.OpCode.Add_ovf_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' true));  	break;  case PE.OpCode.Sub:  	instructions.Add (new ArithInstruction (offset' ArithOp.Sub' false' false));  	break;  case PE.OpCode.Sub_ovf:  	instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' false));  	break;  case PE.OpCode.Sub_ovf_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' true));  	break;  case PE.OpCode.Mul:  	instructions.Add (new ArithInstruction (offset' ArithOp.Mul' false' false));  	break;  case PE.OpCode.Mul_ovf:  	instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' false));  	break;  case PE.OpCode.Mul_ovf_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' true));  	break;  case PE.OpCode.Div:  	instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' false));  	break;  case PE.OpCode.Div_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' true));  	break;  case PE.OpCode.Rem:  	instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' false));  	break;  case PE.OpCode.Rem_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' true));  	break;  case PE.OpCode.Neg:  	instructions.Add (new ArithInstruction (offset' ArithOp.Neg' false' false));  	break;  case PE.OpCode.And:  	instructions.Add (new ArithInstruction (offset' ArithOp.BitAnd' false' false));  	break;  case PE.OpCode.Or:  	instructions.Add (new ArithInstruction (offset' ArithOp.BitOr' false' false));  	break;  case PE.OpCode.Xor:  	instructions.Add (new ArithInstruction (offset' ArithOp.BitXor' false' false));  	break;  case PE.OpCode.Not:  	instructions.Add (new ArithInstruction (offset' ArithOp.BitNot' false' false));  	break;  case PE.OpCode.Shl:  	instructions.Add (new ArithInstruction (offset' ArithOp.Shl' false' false));  	break;  case PE.OpCode.Shr:  	instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' false));  	break;  case PE.OpCode.Shr_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' true));  	break;  case PE.OpCode.Conv_i1:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' false' false));  	break;  case PE.OpCode.Conv_u1:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' false' false));  	break;  case PE.OpCode.Conv_i2:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' false' false));  	break;  case PE.OpCode.Conv_u2:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' false' false));  	break;  case PE.OpCode.Conv_i4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' false' false));  	break;  case PE.OpCode.Conv_u4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' false' false));  	break;  case PE.OpCode.Conv_i8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' false' false));  	break;  case PE.OpCode.Conv_u8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' false' false));  	break;  case PE.OpCode.Conv_i:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' false' false));  	break;  case PE.OpCode.Conv_u:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' false' false));  	break;  case PE.OpCode.Conv_r4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Single' false' false));  	break;  case PE.OpCode.Conv_r8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' false));  	break;  case PE.OpCode.Conv_r_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' true));  	break;  case PE.OpCode.Conv_ovf_i1:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' false));  	break;  case PE.OpCode.Conv_ovf_u1:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' false));  	break;  case PE.OpCode.Conv_ovf_i2:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' false));  	break;  case PE.OpCode.Conv_ovf_u2:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' false));  	break;  case PE.OpCode.Conv_ovf_i4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' false));  	break;  case PE.OpCode.Conv_ovf_u4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' false));  	break;  case PE.OpCode.Conv_ovf_i8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' false));  	break;  case PE.OpCode.Conv_ovf_u8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' false));  	break;  case PE.OpCode.Conv_ovf_i:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' false));  	break;  case PE.OpCode.Conv_ovf_u:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' false));  	break;  case PE.OpCode.Conv_ovf_i1_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' true));  	break;  case PE.OpCode.Conv_ovf_u1_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' true));  	break;  case PE.OpCode.Conv_ovf_i2_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' true));  	break;  case PE.OpCode.Conv_ovf_u2_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' true));  	break;  case PE.OpCode.Conv_ovf_i4_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' true));  	break;  case PE.OpCode.Conv_ovf_u4_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' true));  	break;  case PE.OpCode.Conv_ovf_i8_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' true));  	break;  case PE.OpCode.Conv_ovf_u8_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' true));  	break;  case PE.OpCode.Conv_ovf_i_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' true));  	break;  case PE.OpCode.Conv_ovf_u_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' true));  	break;  default:  	throw new InvalidOperationException ("invalid instruction");  }  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: switch (instruction.OpCode) {  case PE.OpCode.Cpblk:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Cpblk));  	break;  case PE.OpCode.Initblk:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Initblk));  	break;  case PE.OpCode.Arglist:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Arglist));  	break;  case PE.OpCode.Localloc:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Localloc));  	break;  case PE.OpCode.Jmp:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Jmp));  	break;  case PE.OpCode.Calli:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Calli));  	break;  case PE.OpCode.Sizeof:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Sizeof));  	break;  case PE.OpCode.Mkrefany:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Mkrefany));  	break;  case PE.OpCode.Refanytype:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanytype));  	break;  case PE.OpCode.Refanyval:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanyval));  	break;  case PE.OpCode.Nop:  	instructions.Add (new MiscInstruction (offset' MiscOp.Nop));  	break;  case PE.OpCode.Break:  	instructions.Add (new MiscInstruction (offset' MiscOp.Break));  	break;  case PE.OpCode.Dup:  	instructions.Add (new MiscInstruction (offset' MiscOp.Dup));  	break;  case PE.OpCode.Pop:  	instructions.Add (new MiscInstruction (offset' MiscOp.Pop));  	break;  case PE.OpCode.Ldnull:  	instructions.Add (new MiscInstruction (offset' MiscOp.Ldnull));  	break;  case PE.OpCode.Ckfinite:  	instructions.Add (new MiscInstruction (offset' MiscOp.Ckfinite));  	break;  case PE.OpCode.Throw:  	instructions.Add (new MiscInstruction (offset' MiscOp.Throw));  	break;  case PE.OpCode.Rethrow:  	instructions.Add (new MiscInstruction (offset' MiscOp.Rethrow));  	break;  case PE.OpCode.Ldind_ref:  	instructions.Add (new MiscInstruction (offset' MiscOp.LdindRef));  	break;  case PE.OpCode.Stind_ref:  	instructions.Add (new MiscInstruction (offset' MiscOp.StindRef));  	break;  case PE.OpCode.Ldelem_ref:  	instructions.Add (new MiscInstruction (offset' MiscOp.LdelemRef));  	break;  case PE.OpCode.Stelem_ref:  	instructions.Add (new MiscInstruction (offset' MiscOp.StelemRef));  	break;  case PE.OpCode.Ldlen:  	instructions.Add (new MiscInstruction (offset' MiscOp.Ldlen));  	break;  case PE.OpCode.Ret:  	if (ctxt.ResultType == null)  		instructions.Add (new MiscInstruction (offset' MiscOp.Ret));  	else  		instructions.Add (new MiscInstruction (offset' MiscOp.RetVal));  	break;  case PE.OpCode.Endfilter:  	instructions.Add (new MiscInstruction (offset' MiscOp.Endfilter));  	break;  case PE.OpCode.Endfinally:  	// aka EndFault  	instructions.Add (new MiscInstruction (offset' MiscOp.Endfinally));  	break;  case PE.OpCode.Br_s:  case PE.OpCode.Br:  	instructions.Add (new BranchInstruction (offset' BranchOp.Br' false' (int)instruction.Value));  	break;  case PE.OpCode.Brtrue_s:  // aka brinst.s  case PE.OpCode.Brtrue:  	// aka brinst  	instructions.Add (new BranchInstruction (offset' BranchOp.Brtrue' false' (int)instruction.Value));  	break;  case PE.OpCode.Brfalse_s:  // aka brzero.s' brnull.s  case PE.OpCode.Brfalse:  	// aka brzero' brnull  	instructions.Add (new BranchInstruction (offset' BranchOp.Brfalse' false' (int)instruction.Value));  	break;  case PE.OpCode.Beq:  case PE.OpCode.Beq_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.Breq' false' (int)instruction.Value));  	break;  case PE.OpCode.Bne_un:  case PE.OpCode.Bne_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.Brne' false' (int)instruction.Value));  	break;  case PE.OpCode.Leave:  case PE.OpCode.Leave_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.Leave' false' (int)instruction.Value));  	break;  case PE.OpCode.Blt:  case PE.OpCode.Blt_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' false' (int)instruction.Value));  	break;  case PE.OpCode.Blt_un:  case PE.OpCode.Blt_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' true' (int)instruction.Value));  	break;  case PE.OpCode.Ble:  case PE.OpCode.Ble_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' false' (int)instruction.Value));  	break;  case PE.OpCode.Ble_un:  case PE.OpCode.Ble_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' true' (int)instruction.Value));  	break;  case PE.OpCode.Bgt:  case PE.OpCode.Bgt_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' false' (int)instruction.Value));  	break;  case PE.OpCode.Bgt_un:  case PE.OpCode.Bgt_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' true' (int)instruction.Value));  	break;  case PE.OpCode.Bge:  case PE.OpCode.Bge_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' false' (int)instruction.Value));  	break;  case PE.OpCode.Bge_un:  case PE.OpCode.Bge_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' true' (int)instruction.Value));  	break;  case PE.OpCode.Switch:  	instructions.Add (new SwitchInstruction (offset' (Seq<int>)instruction.Value));  	break;  case PE.OpCode.Ceq:  	instructions.Add (new CompareInstruction (offset' CompareOp.Ceq' false));  	break;  case PE.OpCode.Clt:  	instructions.Add (new CompareInstruction (offset' CompareOp.Clt' false));  	break;  case PE.OpCode.Clt_un:  	instructions.Add (new CompareInstruction (offset' CompareOp.Clt' true));  	break;  case PE.OpCode.Cgt:  	instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' false));  	break;  case PE.OpCode.Cgt_un:  	instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' true));  	break;  case PE.OpCode.Ldarg_0:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));  	break;  case PE.OpCode.Ldarg_1:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));  	break;  case PE.OpCode.Ldarg_2:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));  	break;  case PE.OpCode.Ldarg_3:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));  	break;  case PE.OpCode.Ldarg:  case PE.OpCode.Ldarg_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));  	break;  case PE.OpCode.Ldarga:  case PE.OpCode.Ldarga_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));  	break;  case PE.OpCode.Starg:  case PE.OpCode.Starg_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));  	break;  case PE.OpCode.Ldloc_0:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 0));  	break;  case PE.OpCode.Ldloc_1:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 1));  	break;  case PE.OpCode.Ldloc_2:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 2));  	break;  case PE.OpCode.Ldloc_3:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 3));  	break;  case PE.OpCode.Ldloc:  case PE.OpCode.Ldloc_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));  	break;  case PE.OpCode.Ldloca:  case PE.OpCode.Ldloca_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));  	break;  case PE.OpCode.Stloc_0:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 0));  	break;  case PE.OpCode.Stloc_1:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 1));  	break;  case PE.OpCode.Stloc_2:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 2));  	break;  case PE.OpCode.Stloc_3:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 3));  	break;  case PE.OpCode.Stloc:  case PE.OpCode.Stloc_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));  	break;  case PE.OpCode.Ldfld:  	instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));  	break;  case PE.OpCode.Ldsfld:  	instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));  	break;  case PE.OpCode.Ldflda:  	instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));  	break;  case PE.OpCode.Ldsflda:  	instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));  	break;  case PE.OpCode.Stfld:  	instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));  	break;  case PE.OpCode.Stsfld:  	instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));  	break;  case PE.OpCode.Ldtoken: {  	if (instruction.Value is FieldRef)  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));  	else if (instruction.Value is MethodRef)  		instructions.Add (new MethodInstruction (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));  	else if (instruction.Value is TypeRef)  		// NOTE: May be a higher-kinded type  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));  	else  		throw new InvalidOperationException ("unexpected ldtoken instruction value");  	break;  }  case PE.OpCode.Constrained: {  	var constrained = (TypeRef)instruction.Value;  	if (i >= ctxt.Instructions.Length)  		throw new InvalidOperationException ("invalid instructions");  	instruction = ctxt.Instructions [i++];  	if (instruction.OpCode != PE.OpCode.Callvirt)  		throw new InvalidOperationException ("invalid instruction");  	instructions.Add (new MethodInstruction (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));  	break;  }  case PE.OpCode.Call:  	instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Callvirt:  	instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Ldftn:  	instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Ldvirtftn:  	instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Newobj:  	instructions.Add (new MethodInstruction (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Ldind_i1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int8Ref));  	break;  case PE.OpCode.Ldind_u1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt8Ref));  	break;  case PE.OpCode.Ldind_i2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int16Ref));  	break;  case PE.OpCode.Ldind_u2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt16Ref));  	break;  case PE.OpCode.Ldind_i4:  case PE.OpCode.Ldind_u4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int32Ref));  	break;  case PE.OpCode.Ldind_i8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int64Ref));  	break;  case PE.OpCode.Ldind_i:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.IntNativeRef));  	break;  case PE.OpCode.Ldind_r4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.SingleRef));  	break;  case PE.OpCode.Ldind_r8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.DoubleRef));  	break;  case PE.OpCode.Ldobj:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Stind_i1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int8Ref));  	break;  case PE.OpCode.Stind_i2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int16Ref));  	break;  case PE.OpCode.Stind_i4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int32Ref));  	break;  case PE.OpCode.Stind_i8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int64Ref));  	break;  case PE.OpCode.Stind_i:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.IntNativeRef));  	break;  case PE.OpCode.Stind_r4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.SingleRef));  	break;  case PE.OpCode.Stind_r8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.DoubleRef));  	break;  case PE.OpCode.Stobj:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Cpobj:  	instructions.Add (new TypeInstruction (offset' TypeOp.Cpobj' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Newarr:  	instructions.Add (new TypeInstruction (offset' TypeOp.Newarr' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Initobj:  	instructions.Add (new TypeInstruction (offset' TypeOp.Initobj' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Castclass:  	instructions.Add (new TypeInstruction (offset' TypeOp.Castclass' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Isinst:  	instructions.Add (new TypeInstruction (offset' TypeOp.Isinst' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Box:  	instructions.Add (new TypeInstruction (offset' TypeOp.Box' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Unbox:  	instructions.Add (new TypeInstruction (offset' TypeOp.Unbox' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Unbox_any:  	instructions.Add (new TypeInstruction (offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Ldelem_i1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int8Ref));  	break;  case PE.OpCode.Ldelem_u1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt8Ref));  	break;  case PE.OpCode.Ldelem_i2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int16Ref));  	break;  case PE.OpCode.Ldelem_u2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt16Ref));  	break;  case PE.OpCode.Ldelem_i4:  case PE.OpCode.Ldelem_u4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int32Ref));  	break;  case PE.OpCode.Ldelem_i:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.IntNativeRef));  	break;  case PE.OpCode.Ldelem_i8:  	// aka ldelem.u8  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int64Ref));  	break;  case PE.OpCode.Ldelem_r4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.SingleRef));  	break;  case PE.OpCode.Ldelem_r8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.DoubleRef));  	break;  case PE.OpCode.Ldelem:  	// aka ldelem.any  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Stelem_i1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int8Ref));  	break;  case PE.OpCode.Stelem_i2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int16Ref));  	break;  case PE.OpCode.Stelem_i4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int32Ref));  	break;  case PE.OpCode.Stelem_i8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int64Ref));  	break;  case PE.OpCode.Stelem_i:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.IntNativeRef));  	break;  case PE.OpCode.Stelem_r4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.SingleRef));  	break;  case PE.OpCode.Stelem_r8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.DoubleRef));  	break;  case PE.OpCode.Stelem:  	// aka stelem.any  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Readonly:  	if (i >= ctxt.Instructions.Length)  		throw new InvalidOperationException ("invalid instruction");  	instruction = ctxt.Instructions [i++];  	if (instruction.OpCode != PE.OpCode.Ldelema)  		throw new InvalidOperationException ("invalid instruction");  	instructions.Add (new LdElemAddrInstruction (offset' true' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Ldelema:  	instructions.Add (new LdElemAddrInstruction (offset' false' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Ldc_i4_0:  	instructions.Add (new LdInt32Instruction (offset' 0));  	break;  case PE.OpCode.Ldc_i4_1:  	instructions.Add (new LdInt32Instruction (offset' 1));  	break;  case PE.OpCode.Ldc_i4_2:  	instructions.Add (new LdInt32Instruction (offset' 2));  	break;  case PE.OpCode.Ldc_i4_3:  	instructions.Add (new LdInt32Instruction (offset' 3));  	break;  case PE.OpCode.Ldc_i4_4:  	instructions.Add (new LdInt32Instruction (offset' 4));  	break;  case PE.OpCode.Ldc_i4_5:  	instructions.Add (new LdInt32Instruction (offset' 5));  	break;  case PE.OpCode.Ldc_i4_6:  	instructions.Add (new LdInt32Instruction (offset' 6));  	break;  case PE.OpCode.Ldc_i4_7:  	instructions.Add (new LdInt32Instruction (offset' 7));  	break;  case PE.OpCode.Ldc_i4_8:  	instructions.Add (new LdInt32Instruction (offset' 8));  	break;  case PE.OpCode.Ldc_i4_m1:  	instructions.Add (new LdInt32Instruction (offset' -1));  	break;  case PE.OpCode.Ldc_i4:  case PE.OpCode.Ldc_i4_s:  	instructions.Add (new LdInt32Instruction (offset' (int)instruction.Value));  	break;  case PE.OpCode.Ldc_i8:  	instructions.Add (new LdInt64Instruction (offset' (long)instruction.Value));  	break;  case PE.OpCode.Ldc_r4:  	instructions.Add (new LdSingleInstruction (offset' (float)instruction.Value));  	break;  case PE.OpCode.Ldc_r8:  	instructions.Add (new LdDoubleInstruction (offset' (double)instruction.Value));  	break;  case PE.OpCode.Ldstr:  	instructions.Add (new LdStringInstruction (offset' (string)instruction.Value));  	break;  case PE.OpCode.Add:  	instructions.Add (new ArithInstruction (offset' ArithOp.Add' false' false));  	break;  case PE.OpCode.Add_ovf:  	instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' false));  	break;  case PE.OpCode.Add_ovf_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' true));  	break;  case PE.OpCode.Sub:  	instructions.Add (new ArithInstruction (offset' ArithOp.Sub' false' false));  	break;  case PE.OpCode.Sub_ovf:  	instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' false));  	break;  case PE.OpCode.Sub_ovf_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' true));  	break;  case PE.OpCode.Mul:  	instructions.Add (new ArithInstruction (offset' ArithOp.Mul' false' false));  	break;  case PE.OpCode.Mul_ovf:  	instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' false));  	break;  case PE.OpCode.Mul_ovf_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' true));  	break;  case PE.OpCode.Div:  	instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' false));  	break;  case PE.OpCode.Div_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' true));  	break;  case PE.OpCode.Rem:  	instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' false));  	break;  case PE.OpCode.Rem_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' true));  	break;  case PE.OpCode.Neg:  	instructions.Add (new ArithInstruction (offset' ArithOp.Neg' false' false));  	break;  case PE.OpCode.And:  	instructions.Add (new ArithInstruction (offset' ArithOp.BitAnd' false' false));  	break;  case PE.OpCode.Or:  	instructions.Add (new ArithInstruction (offset' ArithOp.BitOr' false' false));  	break;  case PE.OpCode.Xor:  	instructions.Add (new ArithInstruction (offset' ArithOp.BitXor' false' false));  	break;  case PE.OpCode.Not:  	instructions.Add (new ArithInstruction (offset' ArithOp.BitNot' false' false));  	break;  case PE.OpCode.Shl:  	instructions.Add (new ArithInstruction (offset' ArithOp.Shl' false' false));  	break;  case PE.OpCode.Shr:  	instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' false));  	break;  case PE.OpCode.Shr_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' true));  	break;  case PE.OpCode.Conv_i1:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' false' false));  	break;  case PE.OpCode.Conv_u1:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' false' false));  	break;  case PE.OpCode.Conv_i2:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' false' false));  	break;  case PE.OpCode.Conv_u2:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' false' false));  	break;  case PE.OpCode.Conv_i4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' false' false));  	break;  case PE.OpCode.Conv_u4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' false' false));  	break;  case PE.OpCode.Conv_i8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' false' false));  	break;  case PE.OpCode.Conv_u8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' false' false));  	break;  case PE.OpCode.Conv_i:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' false' false));  	break;  case PE.OpCode.Conv_u:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' false' false));  	break;  case PE.OpCode.Conv_r4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Single' false' false));  	break;  case PE.OpCode.Conv_r8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' false));  	break;  case PE.OpCode.Conv_r_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' true));  	break;  case PE.OpCode.Conv_ovf_i1:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' false));  	break;  case PE.OpCode.Conv_ovf_u1:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' false));  	break;  case PE.OpCode.Conv_ovf_i2:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' false));  	break;  case PE.OpCode.Conv_ovf_u2:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' false));  	break;  case PE.OpCode.Conv_ovf_i4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' false));  	break;  case PE.OpCode.Conv_ovf_u4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' false));  	break;  case PE.OpCode.Conv_ovf_i8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' false));  	break;  case PE.OpCode.Conv_ovf_u8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' false));  	break;  case PE.OpCode.Conv_ovf_i:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' false));  	break;  case PE.OpCode.Conv_ovf_u:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' false));  	break;  case PE.OpCode.Conv_ovf_i1_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' true));  	break;  case PE.OpCode.Conv_ovf_u1_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' true));  	break;  case PE.OpCode.Conv_ovf_i2_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' true));  	break;  case PE.OpCode.Conv_ovf_u2_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' true));  	break;  case PE.OpCode.Conv_ovf_i4_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' true));  	break;  case PE.OpCode.Conv_ovf_u4_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' true));  	break;  case PE.OpCode.Conv_ovf_i8_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' true));  	break;  case PE.OpCode.Conv_ovf_u8_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' true));  	break;  case PE.OpCode.Conv_ovf_i_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' true));  	break;  case PE.OpCode.Conv_ovf_u_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' true));  	break;  default:  	throw new InvalidOperationException ("invalid instruction");  }  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: switch (instruction.OpCode) {  case PE.OpCode.Cpblk:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Cpblk));  	break;  case PE.OpCode.Initblk:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Initblk));  	break;  case PE.OpCode.Arglist:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Arglist));  	break;  case PE.OpCode.Localloc:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Localloc));  	break;  case PE.OpCode.Jmp:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Jmp));  	break;  case PE.OpCode.Calli:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Calli));  	break;  case PE.OpCode.Sizeof:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Sizeof));  	break;  case PE.OpCode.Mkrefany:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Mkrefany));  	break;  case PE.OpCode.Refanytype:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanytype));  	break;  case PE.OpCode.Refanyval:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanyval));  	break;  case PE.OpCode.Nop:  	instructions.Add (new MiscInstruction (offset' MiscOp.Nop));  	break;  case PE.OpCode.Break:  	instructions.Add (new MiscInstruction (offset' MiscOp.Break));  	break;  case PE.OpCode.Dup:  	instructions.Add (new MiscInstruction (offset' MiscOp.Dup));  	break;  case PE.OpCode.Pop:  	instructions.Add (new MiscInstruction (offset' MiscOp.Pop));  	break;  case PE.OpCode.Ldnull:  	instructions.Add (new MiscInstruction (offset' MiscOp.Ldnull));  	break;  case PE.OpCode.Ckfinite:  	instructions.Add (new MiscInstruction (offset' MiscOp.Ckfinite));  	break;  case PE.OpCode.Throw:  	instructions.Add (new MiscInstruction (offset' MiscOp.Throw));  	break;  case PE.OpCode.Rethrow:  	instructions.Add (new MiscInstruction (offset' MiscOp.Rethrow));  	break;  case PE.OpCode.Ldind_ref:  	instructions.Add (new MiscInstruction (offset' MiscOp.LdindRef));  	break;  case PE.OpCode.Stind_ref:  	instructions.Add (new MiscInstruction (offset' MiscOp.StindRef));  	break;  case PE.OpCode.Ldelem_ref:  	instructions.Add (new MiscInstruction (offset' MiscOp.LdelemRef));  	break;  case PE.OpCode.Stelem_ref:  	instructions.Add (new MiscInstruction (offset' MiscOp.StelemRef));  	break;  case PE.OpCode.Ldlen:  	instructions.Add (new MiscInstruction (offset' MiscOp.Ldlen));  	break;  case PE.OpCode.Ret:  	if (ctxt.ResultType == null)  		instructions.Add (new MiscInstruction (offset' MiscOp.Ret));  	else  		instructions.Add (new MiscInstruction (offset' MiscOp.RetVal));  	break;  case PE.OpCode.Endfilter:  	instructions.Add (new MiscInstruction (offset' MiscOp.Endfilter));  	break;  case PE.OpCode.Endfinally:  	// aka EndFault  	instructions.Add (new MiscInstruction (offset' MiscOp.Endfinally));  	break;  case PE.OpCode.Br_s:  case PE.OpCode.Br:  	instructions.Add (new BranchInstruction (offset' BranchOp.Br' false' (int)instruction.Value));  	break;  case PE.OpCode.Brtrue_s:  // aka brinst.s  case PE.OpCode.Brtrue:  	// aka brinst  	instructions.Add (new BranchInstruction (offset' BranchOp.Brtrue' false' (int)instruction.Value));  	break;  case PE.OpCode.Brfalse_s:  // aka brzero.s' brnull.s  case PE.OpCode.Brfalse:  	// aka brzero' brnull  	instructions.Add (new BranchInstruction (offset' BranchOp.Brfalse' false' (int)instruction.Value));  	break;  case PE.OpCode.Beq:  case PE.OpCode.Beq_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.Breq' false' (int)instruction.Value));  	break;  case PE.OpCode.Bne_un:  case PE.OpCode.Bne_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.Brne' false' (int)instruction.Value));  	break;  case PE.OpCode.Leave:  case PE.OpCode.Leave_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.Leave' false' (int)instruction.Value));  	break;  case PE.OpCode.Blt:  case PE.OpCode.Blt_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' false' (int)instruction.Value));  	break;  case PE.OpCode.Blt_un:  case PE.OpCode.Blt_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' true' (int)instruction.Value));  	break;  case PE.OpCode.Ble:  case PE.OpCode.Ble_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' false' (int)instruction.Value));  	break;  case PE.OpCode.Ble_un:  case PE.OpCode.Ble_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' true' (int)instruction.Value));  	break;  case PE.OpCode.Bgt:  case PE.OpCode.Bgt_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' false' (int)instruction.Value));  	break;  case PE.OpCode.Bgt_un:  case PE.OpCode.Bgt_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' true' (int)instruction.Value));  	break;  case PE.OpCode.Bge:  case PE.OpCode.Bge_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' false' (int)instruction.Value));  	break;  case PE.OpCode.Bge_un:  case PE.OpCode.Bge_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' true' (int)instruction.Value));  	break;  case PE.OpCode.Switch:  	instructions.Add (new SwitchInstruction (offset' (Seq<int>)instruction.Value));  	break;  case PE.OpCode.Ceq:  	instructions.Add (new CompareInstruction (offset' CompareOp.Ceq' false));  	break;  case PE.OpCode.Clt:  	instructions.Add (new CompareInstruction (offset' CompareOp.Clt' false));  	break;  case PE.OpCode.Clt_un:  	instructions.Add (new CompareInstruction (offset' CompareOp.Clt' true));  	break;  case PE.OpCode.Cgt:  	instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' false));  	break;  case PE.OpCode.Cgt_un:  	instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' true));  	break;  case PE.OpCode.Ldarg_0:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));  	break;  case PE.OpCode.Ldarg_1:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));  	break;  case PE.OpCode.Ldarg_2:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));  	break;  case PE.OpCode.Ldarg_3:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));  	break;  case PE.OpCode.Ldarg:  case PE.OpCode.Ldarg_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));  	break;  case PE.OpCode.Ldarga:  case PE.OpCode.Ldarga_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));  	break;  case PE.OpCode.Starg:  case PE.OpCode.Starg_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));  	break;  case PE.OpCode.Ldloc_0:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 0));  	break;  case PE.OpCode.Ldloc_1:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 1));  	break;  case PE.OpCode.Ldloc_2:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 2));  	break;  case PE.OpCode.Ldloc_3:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 3));  	break;  case PE.OpCode.Ldloc:  case PE.OpCode.Ldloc_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));  	break;  case PE.OpCode.Ldloca:  case PE.OpCode.Ldloca_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));  	break;  case PE.OpCode.Stloc_0:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 0));  	break;  case PE.OpCode.Stloc_1:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 1));  	break;  case PE.OpCode.Stloc_2:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 2));  	break;  case PE.OpCode.Stloc_3:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 3));  	break;  case PE.OpCode.Stloc:  case PE.OpCode.Stloc_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));  	break;  case PE.OpCode.Ldfld:  	instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));  	break;  case PE.OpCode.Ldsfld:  	instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));  	break;  case PE.OpCode.Ldflda:  	instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));  	break;  case PE.OpCode.Ldsflda:  	instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));  	break;  case PE.OpCode.Stfld:  	instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));  	break;  case PE.OpCode.Stsfld:  	instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));  	break;  case PE.OpCode.Ldtoken: {  	if (instruction.Value is FieldRef)  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));  	else if (instruction.Value is MethodRef)  		instructions.Add (new MethodInstruction (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));  	else if (instruction.Value is TypeRef)  		// NOTE: May be a higher-kinded type  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));  	else  		throw new InvalidOperationException ("unexpected ldtoken instruction value");  	break;  }  case PE.OpCode.Constrained: {  	var constrained = (TypeRef)instruction.Value;  	if (i >= ctxt.Instructions.Length)  		throw new InvalidOperationException ("invalid instructions");  	instruction = ctxt.Instructions [i++];  	if (instruction.OpCode != PE.OpCode.Callvirt)  		throw new InvalidOperationException ("invalid instruction");  	instructions.Add (new MethodInstruction (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));  	break;  }  case PE.OpCode.Call:  	instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Callvirt:  	instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Ldftn:  	instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Ldvirtftn:  	instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Newobj:  	instructions.Add (new MethodInstruction (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Ldind_i1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int8Ref));  	break;  case PE.OpCode.Ldind_u1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt8Ref));  	break;  case PE.OpCode.Ldind_i2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int16Ref));  	break;  case PE.OpCode.Ldind_u2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt16Ref));  	break;  case PE.OpCode.Ldind_i4:  case PE.OpCode.Ldind_u4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int32Ref));  	break;  case PE.OpCode.Ldind_i8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int64Ref));  	break;  case PE.OpCode.Ldind_i:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.IntNativeRef));  	break;  case PE.OpCode.Ldind_r4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.SingleRef));  	break;  case PE.OpCode.Ldind_r8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.DoubleRef));  	break;  case PE.OpCode.Ldobj:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Stind_i1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int8Ref));  	break;  case PE.OpCode.Stind_i2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int16Ref));  	break;  case PE.OpCode.Stind_i4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int32Ref));  	break;  case PE.OpCode.Stind_i8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int64Ref));  	break;  case PE.OpCode.Stind_i:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.IntNativeRef));  	break;  case PE.OpCode.Stind_r4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.SingleRef));  	break;  case PE.OpCode.Stind_r8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.DoubleRef));  	break;  case PE.OpCode.Stobj:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Cpobj:  	instructions.Add (new TypeInstruction (offset' TypeOp.Cpobj' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Newarr:  	instructions.Add (new TypeInstruction (offset' TypeOp.Newarr' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Initobj:  	instructions.Add (new TypeInstruction (offset' TypeOp.Initobj' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Castclass:  	instructions.Add (new TypeInstruction (offset' TypeOp.Castclass' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Isinst:  	instructions.Add (new TypeInstruction (offset' TypeOp.Isinst' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Box:  	instructions.Add (new TypeInstruction (offset' TypeOp.Box' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Unbox:  	instructions.Add (new TypeInstruction (offset' TypeOp.Unbox' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Unbox_any:  	instructions.Add (new TypeInstruction (offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Ldelem_i1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int8Ref));  	break;  case PE.OpCode.Ldelem_u1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt8Ref));  	break;  case PE.OpCode.Ldelem_i2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int16Ref));  	break;  case PE.OpCode.Ldelem_u2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt16Ref));  	break;  case PE.OpCode.Ldelem_i4:  case PE.OpCode.Ldelem_u4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int32Ref));  	break;  case PE.OpCode.Ldelem_i:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.IntNativeRef));  	break;  case PE.OpCode.Ldelem_i8:  	// aka ldelem.u8  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int64Ref));  	break;  case PE.OpCode.Ldelem_r4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.SingleRef));  	break;  case PE.OpCode.Ldelem_r8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.DoubleRef));  	break;  case PE.OpCode.Ldelem:  	// aka ldelem.any  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Stelem_i1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int8Ref));  	break;  case PE.OpCode.Stelem_i2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int16Ref));  	break;  case PE.OpCode.Stelem_i4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int32Ref));  	break;  case PE.OpCode.Stelem_i8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int64Ref));  	break;  case PE.OpCode.Stelem_i:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.IntNativeRef));  	break;  case PE.OpCode.Stelem_r4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.SingleRef));  	break;  case PE.OpCode.Stelem_r8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.DoubleRef));  	break;  case PE.OpCode.Stelem:  	// aka stelem.any  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Readonly:  	if (i >= ctxt.Instructions.Length)  		throw new InvalidOperationException ("invalid instruction");  	instruction = ctxt.Instructions [i++];  	if (instruction.OpCode != PE.OpCode.Ldelema)  		throw new InvalidOperationException ("invalid instruction");  	instructions.Add (new LdElemAddrInstruction (offset' true' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Ldelema:  	instructions.Add (new LdElemAddrInstruction (offset' false' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Ldc_i4_0:  	instructions.Add (new LdInt32Instruction (offset' 0));  	break;  case PE.OpCode.Ldc_i4_1:  	instructions.Add (new LdInt32Instruction (offset' 1));  	break;  case PE.OpCode.Ldc_i4_2:  	instructions.Add (new LdInt32Instruction (offset' 2));  	break;  case PE.OpCode.Ldc_i4_3:  	instructions.Add (new LdInt32Instruction (offset' 3));  	break;  case PE.OpCode.Ldc_i4_4:  	instructions.Add (new LdInt32Instruction (offset' 4));  	break;  case PE.OpCode.Ldc_i4_5:  	instructions.Add (new LdInt32Instruction (offset' 5));  	break;  case PE.OpCode.Ldc_i4_6:  	instructions.Add (new LdInt32Instruction (offset' 6));  	break;  case PE.OpCode.Ldc_i4_7:  	instructions.Add (new LdInt32Instruction (offset' 7));  	break;  case PE.OpCode.Ldc_i4_8:  	instructions.Add (new LdInt32Instruction (offset' 8));  	break;  case PE.OpCode.Ldc_i4_m1:  	instructions.Add (new LdInt32Instruction (offset' -1));  	break;  case PE.OpCode.Ldc_i4:  case PE.OpCode.Ldc_i4_s:  	instructions.Add (new LdInt32Instruction (offset' (int)instruction.Value));  	break;  case PE.OpCode.Ldc_i8:  	instructions.Add (new LdInt64Instruction (offset' (long)instruction.Value));  	break;  case PE.OpCode.Ldc_r4:  	instructions.Add (new LdSingleInstruction (offset' (float)instruction.Value));  	break;  case PE.OpCode.Ldc_r8:  	instructions.Add (new LdDoubleInstruction (offset' (double)instruction.Value));  	break;  case PE.OpCode.Ldstr:  	instructions.Add (new LdStringInstruction (offset' (string)instruction.Value));  	break;  case PE.OpCode.Add:  	instructions.Add (new ArithInstruction (offset' ArithOp.Add' false' false));  	break;  case PE.OpCode.Add_ovf:  	instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' false));  	break;  case PE.OpCode.Add_ovf_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' true));  	break;  case PE.OpCode.Sub:  	instructions.Add (new ArithInstruction (offset' ArithOp.Sub' false' false));  	break;  case PE.OpCode.Sub_ovf:  	instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' false));  	break;  case PE.OpCode.Sub_ovf_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' true));  	break;  case PE.OpCode.Mul:  	instructions.Add (new ArithInstruction (offset' ArithOp.Mul' false' false));  	break;  case PE.OpCode.Mul_ovf:  	instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' false));  	break;  case PE.OpCode.Mul_ovf_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' true));  	break;  case PE.OpCode.Div:  	instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' false));  	break;  case PE.OpCode.Div_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' true));  	break;  case PE.OpCode.Rem:  	instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' false));  	break;  case PE.OpCode.Rem_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' true));  	break;  case PE.OpCode.Neg:  	instructions.Add (new ArithInstruction (offset' ArithOp.Neg' false' false));  	break;  case PE.OpCode.And:  	instructions.Add (new ArithInstruction (offset' ArithOp.BitAnd' false' false));  	break;  case PE.OpCode.Or:  	instructions.Add (new ArithInstruction (offset' ArithOp.BitOr' false' false));  	break;  case PE.OpCode.Xor:  	instructions.Add (new ArithInstruction (offset' ArithOp.BitXor' false' false));  	break;  case PE.OpCode.Not:  	instructions.Add (new ArithInstruction (offset' ArithOp.BitNot' false' false));  	break;  case PE.OpCode.Shl:  	instructions.Add (new ArithInstruction (offset' ArithOp.Shl' false' false));  	break;  case PE.OpCode.Shr:  	instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' false));  	break;  case PE.OpCode.Shr_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' true));  	break;  case PE.OpCode.Conv_i1:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' false' false));  	break;  case PE.OpCode.Conv_u1:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' false' false));  	break;  case PE.OpCode.Conv_i2:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' false' false));  	break;  case PE.OpCode.Conv_u2:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' false' false));  	break;  case PE.OpCode.Conv_i4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' false' false));  	break;  case PE.OpCode.Conv_u4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' false' false));  	break;  case PE.OpCode.Conv_i8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' false' false));  	break;  case PE.OpCode.Conv_u8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' false' false));  	break;  case PE.OpCode.Conv_i:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' false' false));  	break;  case PE.OpCode.Conv_u:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' false' false));  	break;  case PE.OpCode.Conv_r4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Single' false' false));  	break;  case PE.OpCode.Conv_r8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' false));  	break;  case PE.OpCode.Conv_r_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' true));  	break;  case PE.OpCode.Conv_ovf_i1:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' false));  	break;  case PE.OpCode.Conv_ovf_u1:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' false));  	break;  case PE.OpCode.Conv_ovf_i2:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' false));  	break;  case PE.OpCode.Conv_ovf_u2:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' false));  	break;  case PE.OpCode.Conv_ovf_i4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' false));  	break;  case PE.OpCode.Conv_ovf_u4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' false));  	break;  case PE.OpCode.Conv_ovf_i8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' false));  	break;  case PE.OpCode.Conv_ovf_u8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' false));  	break;  case PE.OpCode.Conv_ovf_i:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' false));  	break;  case PE.OpCode.Conv_ovf_u:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' false));  	break;  case PE.OpCode.Conv_ovf_i1_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' true));  	break;  case PE.OpCode.Conv_ovf_u1_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' true));  	break;  case PE.OpCode.Conv_ovf_i2_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' true));  	break;  case PE.OpCode.Conv_ovf_u2_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' true));  	break;  case PE.OpCode.Conv_ovf_i4_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' true));  	break;  case PE.OpCode.Conv_ovf_u4_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' true));  	break;  case PE.OpCode.Conv_ovf_i8_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' true));  	break;  case PE.OpCode.Conv_ovf_u8_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' true));  	break;  case PE.OpCode.Conv_ovf_i_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' true));  	break;  case PE.OpCode.Conv_ovf_u_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' true));  	break;  default:  	throw new InvalidOperationException ("invalid instruction");  }  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: switch (instruction.OpCode) {  case PE.OpCode.Cpblk:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Cpblk));  	break;  case PE.OpCode.Initblk:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Initblk));  	break;  case PE.OpCode.Arglist:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Arglist));  	break;  case PE.OpCode.Localloc:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Localloc));  	break;  case PE.OpCode.Jmp:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Jmp));  	break;  case PE.OpCode.Calli:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Calli));  	break;  case PE.OpCode.Sizeof:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Sizeof));  	break;  case PE.OpCode.Mkrefany:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Mkrefany));  	break;  case PE.OpCode.Refanytype:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanytype));  	break;  case PE.OpCode.Refanyval:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanyval));  	break;  case PE.OpCode.Nop:  	instructions.Add (new MiscInstruction (offset' MiscOp.Nop));  	break;  case PE.OpCode.Break:  	instructions.Add (new MiscInstruction (offset' MiscOp.Break));  	break;  case PE.OpCode.Dup:  	instructions.Add (new MiscInstruction (offset' MiscOp.Dup));  	break;  case PE.OpCode.Pop:  	instructions.Add (new MiscInstruction (offset' MiscOp.Pop));  	break;  case PE.OpCode.Ldnull:  	instructions.Add (new MiscInstruction (offset' MiscOp.Ldnull));  	break;  case PE.OpCode.Ckfinite:  	instructions.Add (new MiscInstruction (offset' MiscOp.Ckfinite));  	break;  case PE.OpCode.Throw:  	instructions.Add (new MiscInstruction (offset' MiscOp.Throw));  	break;  case PE.OpCode.Rethrow:  	instructions.Add (new MiscInstruction (offset' MiscOp.Rethrow));  	break;  case PE.OpCode.Ldind_ref:  	instructions.Add (new MiscInstruction (offset' MiscOp.LdindRef));  	break;  case PE.OpCode.Stind_ref:  	instructions.Add (new MiscInstruction (offset' MiscOp.StindRef));  	break;  case PE.OpCode.Ldelem_ref:  	instructions.Add (new MiscInstruction (offset' MiscOp.LdelemRef));  	break;  case PE.OpCode.Stelem_ref:  	instructions.Add (new MiscInstruction (offset' MiscOp.StelemRef));  	break;  case PE.OpCode.Ldlen:  	instructions.Add (new MiscInstruction (offset' MiscOp.Ldlen));  	break;  case PE.OpCode.Ret:  	if (ctxt.ResultType == null)  		instructions.Add (new MiscInstruction (offset' MiscOp.Ret));  	else  		instructions.Add (new MiscInstruction (offset' MiscOp.RetVal));  	break;  case PE.OpCode.Endfilter:  	instructions.Add (new MiscInstruction (offset' MiscOp.Endfilter));  	break;  case PE.OpCode.Endfinally:  	// aka EndFault  	instructions.Add (new MiscInstruction (offset' MiscOp.Endfinally));  	break;  case PE.OpCode.Br_s:  case PE.OpCode.Br:  	instructions.Add (new BranchInstruction (offset' BranchOp.Br' false' (int)instruction.Value));  	break;  case PE.OpCode.Brtrue_s:  // aka brinst.s  case PE.OpCode.Brtrue:  	// aka brinst  	instructions.Add (new BranchInstruction (offset' BranchOp.Brtrue' false' (int)instruction.Value));  	break;  case PE.OpCode.Brfalse_s:  // aka brzero.s' brnull.s  case PE.OpCode.Brfalse:  	// aka brzero' brnull  	instructions.Add (new BranchInstruction (offset' BranchOp.Brfalse' false' (int)instruction.Value));  	break;  case PE.OpCode.Beq:  case PE.OpCode.Beq_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.Breq' false' (int)instruction.Value));  	break;  case PE.OpCode.Bne_un:  case PE.OpCode.Bne_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.Brne' false' (int)instruction.Value));  	break;  case PE.OpCode.Leave:  case PE.OpCode.Leave_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.Leave' false' (int)instruction.Value));  	break;  case PE.OpCode.Blt:  case PE.OpCode.Blt_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' false' (int)instruction.Value));  	break;  case PE.OpCode.Blt_un:  case PE.OpCode.Blt_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' true' (int)instruction.Value));  	break;  case PE.OpCode.Ble:  case PE.OpCode.Ble_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' false' (int)instruction.Value));  	break;  case PE.OpCode.Ble_un:  case PE.OpCode.Ble_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' true' (int)instruction.Value));  	break;  case PE.OpCode.Bgt:  case PE.OpCode.Bgt_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' false' (int)instruction.Value));  	break;  case PE.OpCode.Bgt_un:  case PE.OpCode.Bgt_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' true' (int)instruction.Value));  	break;  case PE.OpCode.Bge:  case PE.OpCode.Bge_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' false' (int)instruction.Value));  	break;  case PE.OpCode.Bge_un:  case PE.OpCode.Bge_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' true' (int)instruction.Value));  	break;  case PE.OpCode.Switch:  	instructions.Add (new SwitchInstruction (offset' (Seq<int>)instruction.Value));  	break;  case PE.OpCode.Ceq:  	instructions.Add (new CompareInstruction (offset' CompareOp.Ceq' false));  	break;  case PE.OpCode.Clt:  	instructions.Add (new CompareInstruction (offset' CompareOp.Clt' false));  	break;  case PE.OpCode.Clt_un:  	instructions.Add (new CompareInstruction (offset' CompareOp.Clt' true));  	break;  case PE.OpCode.Cgt:  	instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' false));  	break;  case PE.OpCode.Cgt_un:  	instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' true));  	break;  case PE.OpCode.Ldarg_0:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));  	break;  case PE.OpCode.Ldarg_1:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));  	break;  case PE.OpCode.Ldarg_2:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));  	break;  case PE.OpCode.Ldarg_3:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));  	break;  case PE.OpCode.Ldarg:  case PE.OpCode.Ldarg_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));  	break;  case PE.OpCode.Ldarga:  case PE.OpCode.Ldarga_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));  	break;  case PE.OpCode.Starg:  case PE.OpCode.Starg_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));  	break;  case PE.OpCode.Ldloc_0:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 0));  	break;  case PE.OpCode.Ldloc_1:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 1));  	break;  case PE.OpCode.Ldloc_2:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 2));  	break;  case PE.OpCode.Ldloc_3:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 3));  	break;  case PE.OpCode.Ldloc:  case PE.OpCode.Ldloc_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));  	break;  case PE.OpCode.Ldloca:  case PE.OpCode.Ldloca_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));  	break;  case PE.OpCode.Stloc_0:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 0));  	break;  case PE.OpCode.Stloc_1:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 1));  	break;  case PE.OpCode.Stloc_2:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 2));  	break;  case PE.OpCode.Stloc_3:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 3));  	break;  case PE.OpCode.Stloc:  case PE.OpCode.Stloc_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));  	break;  case PE.OpCode.Ldfld:  	instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));  	break;  case PE.OpCode.Ldsfld:  	instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));  	break;  case PE.OpCode.Ldflda:  	instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));  	break;  case PE.OpCode.Ldsflda:  	instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));  	break;  case PE.OpCode.Stfld:  	instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));  	break;  case PE.OpCode.Stsfld:  	instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));  	break;  case PE.OpCode.Ldtoken: {  	if (instruction.Value is FieldRef)  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));  	else if (instruction.Value is MethodRef)  		instructions.Add (new MethodInstruction (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));  	else if (instruction.Value is TypeRef)  		// NOTE: May be a higher-kinded type  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));  	else  		throw new InvalidOperationException ("unexpected ldtoken instruction value");  	break;  }  case PE.OpCode.Constrained: {  	var constrained = (TypeRef)instruction.Value;  	if (i >= ctxt.Instructions.Length)  		throw new InvalidOperationException ("invalid instructions");  	instruction = ctxt.Instructions [i++];  	if (instruction.OpCode != PE.OpCode.Callvirt)  		throw new InvalidOperationException ("invalid instruction");  	instructions.Add (new MethodInstruction (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));  	break;  }  case PE.OpCode.Call:  	instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Callvirt:  	instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Ldftn:  	instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Ldvirtftn:  	instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Newobj:  	instructions.Add (new MethodInstruction (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Ldind_i1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int8Ref));  	break;  case PE.OpCode.Ldind_u1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt8Ref));  	break;  case PE.OpCode.Ldind_i2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int16Ref));  	break;  case PE.OpCode.Ldind_u2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt16Ref));  	break;  case PE.OpCode.Ldind_i4:  case PE.OpCode.Ldind_u4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int32Ref));  	break;  case PE.OpCode.Ldind_i8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int64Ref));  	break;  case PE.OpCode.Ldind_i:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.IntNativeRef));  	break;  case PE.OpCode.Ldind_r4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.SingleRef));  	break;  case PE.OpCode.Ldind_r8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.DoubleRef));  	break;  case PE.OpCode.Ldobj:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Stind_i1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int8Ref));  	break;  case PE.OpCode.Stind_i2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int16Ref));  	break;  case PE.OpCode.Stind_i4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int32Ref));  	break;  case PE.OpCode.Stind_i8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int64Ref));  	break;  case PE.OpCode.Stind_i:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.IntNativeRef));  	break;  case PE.OpCode.Stind_r4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.SingleRef));  	break;  case PE.OpCode.Stind_r8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.DoubleRef));  	break;  case PE.OpCode.Stobj:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Cpobj:  	instructions.Add (new TypeInstruction (offset' TypeOp.Cpobj' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Newarr:  	instructions.Add (new TypeInstruction (offset' TypeOp.Newarr' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Initobj:  	instructions.Add (new TypeInstruction (offset' TypeOp.Initobj' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Castclass:  	instructions.Add (new TypeInstruction (offset' TypeOp.Castclass' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Isinst:  	instructions.Add (new TypeInstruction (offset' TypeOp.Isinst' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Box:  	instructions.Add (new TypeInstruction (offset' TypeOp.Box' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Unbox:  	instructions.Add (new TypeInstruction (offset' TypeOp.Unbox' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Unbox_any:  	instructions.Add (new TypeInstruction (offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Ldelem_i1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int8Ref));  	break;  case PE.OpCode.Ldelem_u1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt8Ref));  	break;  case PE.OpCode.Ldelem_i2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int16Ref));  	break;  case PE.OpCode.Ldelem_u2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt16Ref));  	break;  case PE.OpCode.Ldelem_i4:  case PE.OpCode.Ldelem_u4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int32Ref));  	break;  case PE.OpCode.Ldelem_i:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.IntNativeRef));  	break;  case PE.OpCode.Ldelem_i8:  	// aka ldelem.u8  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int64Ref));  	break;  case PE.OpCode.Ldelem_r4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.SingleRef));  	break;  case PE.OpCode.Ldelem_r8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.DoubleRef));  	break;  case PE.OpCode.Ldelem:  	// aka ldelem.any  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Stelem_i1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int8Ref));  	break;  case PE.OpCode.Stelem_i2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int16Ref));  	break;  case PE.OpCode.Stelem_i4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int32Ref));  	break;  case PE.OpCode.Stelem_i8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int64Ref));  	break;  case PE.OpCode.Stelem_i:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.IntNativeRef));  	break;  case PE.OpCode.Stelem_r4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.SingleRef));  	break;  case PE.OpCode.Stelem_r8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.DoubleRef));  	break;  case PE.OpCode.Stelem:  	// aka stelem.any  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Readonly:  	if (i >= ctxt.Instructions.Length)  		throw new InvalidOperationException ("invalid instruction");  	instruction = ctxt.Instructions [i++];  	if (instruction.OpCode != PE.OpCode.Ldelema)  		throw new InvalidOperationException ("invalid instruction");  	instructions.Add (new LdElemAddrInstruction (offset' true' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Ldelema:  	instructions.Add (new LdElemAddrInstruction (offset' false' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Ldc_i4_0:  	instructions.Add (new LdInt32Instruction (offset' 0));  	break;  case PE.OpCode.Ldc_i4_1:  	instructions.Add (new LdInt32Instruction (offset' 1));  	break;  case PE.OpCode.Ldc_i4_2:  	instructions.Add (new LdInt32Instruction (offset' 2));  	break;  case PE.OpCode.Ldc_i4_3:  	instructions.Add (new LdInt32Instruction (offset' 3));  	break;  case PE.OpCode.Ldc_i4_4:  	instructions.Add (new LdInt32Instruction (offset' 4));  	break;  case PE.OpCode.Ldc_i4_5:  	instructions.Add (new LdInt32Instruction (offset' 5));  	break;  case PE.OpCode.Ldc_i4_6:  	instructions.Add (new LdInt32Instruction (offset' 6));  	break;  case PE.OpCode.Ldc_i4_7:  	instructions.Add (new LdInt32Instruction (offset' 7));  	break;  case PE.OpCode.Ldc_i4_8:  	instructions.Add (new LdInt32Instruction (offset' 8));  	break;  case PE.OpCode.Ldc_i4_m1:  	instructions.Add (new LdInt32Instruction (offset' -1));  	break;  case PE.OpCode.Ldc_i4:  case PE.OpCode.Ldc_i4_s:  	instructions.Add (new LdInt32Instruction (offset' (int)instruction.Value));  	break;  case PE.OpCode.Ldc_i8:  	instructions.Add (new LdInt64Instruction (offset' (long)instruction.Value));  	break;  case PE.OpCode.Ldc_r4:  	instructions.Add (new LdSingleInstruction (offset' (float)instruction.Value));  	break;  case PE.OpCode.Ldc_r8:  	instructions.Add (new LdDoubleInstruction (offset' (double)instruction.Value));  	break;  case PE.OpCode.Ldstr:  	instructions.Add (new LdStringInstruction (offset' (string)instruction.Value));  	break;  case PE.OpCode.Add:  	instructions.Add (new ArithInstruction (offset' ArithOp.Add' false' false));  	break;  case PE.OpCode.Add_ovf:  	instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' false));  	break;  case PE.OpCode.Add_ovf_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' true));  	break;  case PE.OpCode.Sub:  	instructions.Add (new ArithInstruction (offset' ArithOp.Sub' false' false));  	break;  case PE.OpCode.Sub_ovf:  	instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' false));  	break;  case PE.OpCode.Sub_ovf_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' true));  	break;  case PE.OpCode.Mul:  	instructions.Add (new ArithInstruction (offset' ArithOp.Mul' false' false));  	break;  case PE.OpCode.Mul_ovf:  	instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' false));  	break;  case PE.OpCode.Mul_ovf_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' true));  	break;  case PE.OpCode.Div:  	instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' false));  	break;  case PE.OpCode.Div_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' true));  	break;  case PE.OpCode.Rem:  	instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' false));  	break;  case PE.OpCode.Rem_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' true));  	break;  case PE.OpCode.Neg:  	instructions.Add (new ArithInstruction (offset' ArithOp.Neg' false' false));  	break;  case PE.OpCode.And:  	instructions.Add (new ArithInstruction (offset' ArithOp.BitAnd' false' false));  	break;  case PE.OpCode.Or:  	instructions.Add (new ArithInstruction (offset' ArithOp.BitOr' false' false));  	break;  case PE.OpCode.Xor:  	instructions.Add (new ArithInstruction (offset' ArithOp.BitXor' false' false));  	break;  case PE.OpCode.Not:  	instructions.Add (new ArithInstruction (offset' ArithOp.BitNot' false' false));  	break;  case PE.OpCode.Shl:  	instructions.Add (new ArithInstruction (offset' ArithOp.Shl' false' false));  	break;  case PE.OpCode.Shr:  	instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' false));  	break;  case PE.OpCode.Shr_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' true));  	break;  case PE.OpCode.Conv_i1:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' false' false));  	break;  case PE.OpCode.Conv_u1:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' false' false));  	break;  case PE.OpCode.Conv_i2:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' false' false));  	break;  case PE.OpCode.Conv_u2:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' false' false));  	break;  case PE.OpCode.Conv_i4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' false' false));  	break;  case PE.OpCode.Conv_u4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' false' false));  	break;  case PE.OpCode.Conv_i8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' false' false));  	break;  case PE.OpCode.Conv_u8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' false' false));  	break;  case PE.OpCode.Conv_i:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' false' false));  	break;  case PE.OpCode.Conv_u:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' false' false));  	break;  case PE.OpCode.Conv_r4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Single' false' false));  	break;  case PE.OpCode.Conv_r8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' false));  	break;  case PE.OpCode.Conv_r_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' true));  	break;  case PE.OpCode.Conv_ovf_i1:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' false));  	break;  case PE.OpCode.Conv_ovf_u1:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' false));  	break;  case PE.OpCode.Conv_ovf_i2:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' false));  	break;  case PE.OpCode.Conv_ovf_u2:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' false));  	break;  case PE.OpCode.Conv_ovf_i4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' false));  	break;  case PE.OpCode.Conv_ovf_u4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' false));  	break;  case PE.OpCode.Conv_ovf_i8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' false));  	break;  case PE.OpCode.Conv_ovf_u8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' false));  	break;  case PE.OpCode.Conv_ovf_i:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' false));  	break;  case PE.OpCode.Conv_ovf_u:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' false));  	break;  case PE.OpCode.Conv_ovf_i1_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' true));  	break;  case PE.OpCode.Conv_ovf_u1_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' true));  	break;  case PE.OpCode.Conv_ovf_i2_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' true));  	break;  case PE.OpCode.Conv_ovf_u2_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' true));  	break;  case PE.OpCode.Conv_ovf_i4_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' true));  	break;  case PE.OpCode.Conv_ovf_u4_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' true));  	break;  case PE.OpCode.Conv_ovf_i8_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' true));  	break;  case PE.OpCode.Conv_ovf_u8_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' true));  	break;  case PE.OpCode.Conv_ovf_i_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' true));  	break;  case PE.OpCode.Conv_ovf_u_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' true));  	break;  default:  	throw new InvalidOperationException ("invalid instruction");  }  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: switch (instruction.OpCode) {  case PE.OpCode.Cpblk:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Cpblk));  	break;  case PE.OpCode.Initblk:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Initblk));  	break;  case PE.OpCode.Arglist:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Arglist));  	break;  case PE.OpCode.Localloc:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Localloc));  	break;  case PE.OpCode.Jmp:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Jmp));  	break;  case PE.OpCode.Calli:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Calli));  	break;  case PE.OpCode.Sizeof:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Sizeof));  	break;  case PE.OpCode.Mkrefany:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Mkrefany));  	break;  case PE.OpCode.Refanytype:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanytype));  	break;  case PE.OpCode.Refanyval:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanyval));  	break;  case PE.OpCode.Nop:  	instructions.Add (new MiscInstruction (offset' MiscOp.Nop));  	break;  case PE.OpCode.Break:  	instructions.Add (new MiscInstruction (offset' MiscOp.Break));  	break;  case PE.OpCode.Dup:  	instructions.Add (new MiscInstruction (offset' MiscOp.Dup));  	break;  case PE.OpCode.Pop:  	instructions.Add (new MiscInstruction (offset' MiscOp.Pop));  	break;  case PE.OpCode.Ldnull:  	instructions.Add (new MiscInstruction (offset' MiscOp.Ldnull));  	break;  case PE.OpCode.Ckfinite:  	instructions.Add (new MiscInstruction (offset' MiscOp.Ckfinite));  	break;  case PE.OpCode.Throw:  	instructions.Add (new MiscInstruction (offset' MiscOp.Throw));  	break;  case PE.OpCode.Rethrow:  	instructions.Add (new MiscInstruction (offset' MiscOp.Rethrow));  	break;  case PE.OpCode.Ldind_ref:  	instructions.Add (new MiscInstruction (offset' MiscOp.LdindRef));  	break;  case PE.OpCode.Stind_ref:  	instructions.Add (new MiscInstruction (offset' MiscOp.StindRef));  	break;  case PE.OpCode.Ldelem_ref:  	instructions.Add (new MiscInstruction (offset' MiscOp.LdelemRef));  	break;  case PE.OpCode.Stelem_ref:  	instructions.Add (new MiscInstruction (offset' MiscOp.StelemRef));  	break;  case PE.OpCode.Ldlen:  	instructions.Add (new MiscInstruction (offset' MiscOp.Ldlen));  	break;  case PE.OpCode.Ret:  	if (ctxt.ResultType == null)  		instructions.Add (new MiscInstruction (offset' MiscOp.Ret));  	else  		instructions.Add (new MiscInstruction (offset' MiscOp.RetVal));  	break;  case PE.OpCode.Endfilter:  	instructions.Add (new MiscInstruction (offset' MiscOp.Endfilter));  	break;  case PE.OpCode.Endfinally:  	// aka EndFault  	instructions.Add (new MiscInstruction (offset' MiscOp.Endfinally));  	break;  case PE.OpCode.Br_s:  case PE.OpCode.Br:  	instructions.Add (new BranchInstruction (offset' BranchOp.Br' false' (int)instruction.Value));  	break;  case PE.OpCode.Brtrue_s:  // aka brinst.s  case PE.OpCode.Brtrue:  	// aka brinst  	instructions.Add (new BranchInstruction (offset' BranchOp.Brtrue' false' (int)instruction.Value));  	break;  case PE.OpCode.Brfalse_s:  // aka brzero.s' brnull.s  case PE.OpCode.Brfalse:  	// aka brzero' brnull  	instructions.Add (new BranchInstruction (offset' BranchOp.Brfalse' false' (int)instruction.Value));  	break;  case PE.OpCode.Beq:  case PE.OpCode.Beq_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.Breq' false' (int)instruction.Value));  	break;  case PE.OpCode.Bne_un:  case PE.OpCode.Bne_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.Brne' false' (int)instruction.Value));  	break;  case PE.OpCode.Leave:  case PE.OpCode.Leave_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.Leave' false' (int)instruction.Value));  	break;  case PE.OpCode.Blt:  case PE.OpCode.Blt_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' false' (int)instruction.Value));  	break;  case PE.OpCode.Blt_un:  case PE.OpCode.Blt_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' true' (int)instruction.Value));  	break;  case PE.OpCode.Ble:  case PE.OpCode.Ble_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' false' (int)instruction.Value));  	break;  case PE.OpCode.Ble_un:  case PE.OpCode.Ble_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' true' (int)instruction.Value));  	break;  case PE.OpCode.Bgt:  case PE.OpCode.Bgt_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' false' (int)instruction.Value));  	break;  case PE.OpCode.Bgt_un:  case PE.OpCode.Bgt_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' true' (int)instruction.Value));  	break;  case PE.OpCode.Bge:  case PE.OpCode.Bge_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' false' (int)instruction.Value));  	break;  case PE.OpCode.Bge_un:  case PE.OpCode.Bge_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' true' (int)instruction.Value));  	break;  case PE.OpCode.Switch:  	instructions.Add (new SwitchInstruction (offset' (Seq<int>)instruction.Value));  	break;  case PE.OpCode.Ceq:  	instructions.Add (new CompareInstruction (offset' CompareOp.Ceq' false));  	break;  case PE.OpCode.Clt:  	instructions.Add (new CompareInstruction (offset' CompareOp.Clt' false));  	break;  case PE.OpCode.Clt_un:  	instructions.Add (new CompareInstruction (offset' CompareOp.Clt' true));  	break;  case PE.OpCode.Cgt:  	instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' false));  	break;  case PE.OpCode.Cgt_un:  	instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' true));  	break;  case PE.OpCode.Ldarg_0:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));  	break;  case PE.OpCode.Ldarg_1:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));  	break;  case PE.OpCode.Ldarg_2:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));  	break;  case PE.OpCode.Ldarg_3:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));  	break;  case PE.OpCode.Ldarg:  case PE.OpCode.Ldarg_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));  	break;  case PE.OpCode.Ldarga:  case PE.OpCode.Ldarga_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));  	break;  case PE.OpCode.Starg:  case PE.OpCode.Starg_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));  	break;  case PE.OpCode.Ldloc_0:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 0));  	break;  case PE.OpCode.Ldloc_1:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 1));  	break;  case PE.OpCode.Ldloc_2:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 2));  	break;  case PE.OpCode.Ldloc_3:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 3));  	break;  case PE.OpCode.Ldloc:  case PE.OpCode.Ldloc_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));  	break;  case PE.OpCode.Ldloca:  case PE.OpCode.Ldloca_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));  	break;  case PE.OpCode.Stloc_0:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 0));  	break;  case PE.OpCode.Stloc_1:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 1));  	break;  case PE.OpCode.Stloc_2:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 2));  	break;  case PE.OpCode.Stloc_3:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 3));  	break;  case PE.OpCode.Stloc:  case PE.OpCode.Stloc_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));  	break;  case PE.OpCode.Ldfld:  	instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));  	break;  case PE.OpCode.Ldsfld:  	instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));  	break;  case PE.OpCode.Ldflda:  	instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));  	break;  case PE.OpCode.Ldsflda:  	instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));  	break;  case PE.OpCode.Stfld:  	instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));  	break;  case PE.OpCode.Stsfld:  	instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));  	break;  case PE.OpCode.Ldtoken: {  	if (instruction.Value is FieldRef)  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));  	else if (instruction.Value is MethodRef)  		instructions.Add (new MethodInstruction (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));  	else if (instruction.Value is TypeRef)  		// NOTE: May be a higher-kinded type  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));  	else  		throw new InvalidOperationException ("unexpected ldtoken instruction value");  	break;  }  case PE.OpCode.Constrained: {  	var constrained = (TypeRef)instruction.Value;  	if (i >= ctxt.Instructions.Length)  		throw new InvalidOperationException ("invalid instructions");  	instruction = ctxt.Instructions [i++];  	if (instruction.OpCode != PE.OpCode.Callvirt)  		throw new InvalidOperationException ("invalid instruction");  	instructions.Add (new MethodInstruction (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));  	break;  }  case PE.OpCode.Call:  	instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Callvirt:  	instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Ldftn:  	instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Ldvirtftn:  	instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Newobj:  	instructions.Add (new MethodInstruction (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Ldind_i1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int8Ref));  	break;  case PE.OpCode.Ldind_u1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt8Ref));  	break;  case PE.OpCode.Ldind_i2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int16Ref));  	break;  case PE.OpCode.Ldind_u2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt16Ref));  	break;  case PE.OpCode.Ldind_i4:  case PE.OpCode.Ldind_u4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int32Ref));  	break;  case PE.OpCode.Ldind_i8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int64Ref));  	break;  case PE.OpCode.Ldind_i:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.IntNativeRef));  	break;  case PE.OpCode.Ldind_r4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.SingleRef));  	break;  case PE.OpCode.Ldind_r8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.DoubleRef));  	break;  case PE.OpCode.Ldobj:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Stind_i1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int8Ref));  	break;  case PE.OpCode.Stind_i2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int16Ref));  	break;  case PE.OpCode.Stind_i4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int32Ref));  	break;  case PE.OpCode.Stind_i8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int64Ref));  	break;  case PE.OpCode.Stind_i:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.IntNativeRef));  	break;  case PE.OpCode.Stind_r4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.SingleRef));  	break;  case PE.OpCode.Stind_r8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.DoubleRef));  	break;  case PE.OpCode.Stobj:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Cpobj:  	instructions.Add (new TypeInstruction (offset' TypeOp.Cpobj' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Newarr:  	instructions.Add (new TypeInstruction (offset' TypeOp.Newarr' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Initobj:  	instructions.Add (new TypeInstruction (offset' TypeOp.Initobj' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Castclass:  	instructions.Add (new TypeInstruction (offset' TypeOp.Castclass' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Isinst:  	instructions.Add (new TypeInstruction (offset' TypeOp.Isinst' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Box:  	instructions.Add (new TypeInstruction (offset' TypeOp.Box' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Unbox:  	instructions.Add (new TypeInstruction (offset' TypeOp.Unbox' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Unbox_any:  	instructions.Add (new TypeInstruction (offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Ldelem_i1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int8Ref));  	break;  case PE.OpCode.Ldelem_u1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt8Ref));  	break;  case PE.OpCode.Ldelem_i2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int16Ref));  	break;  case PE.OpCode.Ldelem_u2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt16Ref));  	break;  case PE.OpCode.Ldelem_i4:  case PE.OpCode.Ldelem_u4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int32Ref));  	break;  case PE.OpCode.Ldelem_i:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.IntNativeRef));  	break;  case PE.OpCode.Ldelem_i8:  	// aka ldelem.u8  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int64Ref));  	break;  case PE.OpCode.Ldelem_r4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.SingleRef));  	break;  case PE.OpCode.Ldelem_r8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.DoubleRef));  	break;  case PE.OpCode.Ldelem:  	// aka ldelem.any  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Stelem_i1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int8Ref));  	break;  case PE.OpCode.Stelem_i2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int16Ref));  	break;  case PE.OpCode.Stelem_i4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int32Ref));  	break;  case PE.OpCode.Stelem_i8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int64Ref));  	break;  case PE.OpCode.Stelem_i:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.IntNativeRef));  	break;  case PE.OpCode.Stelem_r4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.SingleRef));  	break;  case PE.OpCode.Stelem_r8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.DoubleRef));  	break;  case PE.OpCode.Stelem:  	// aka stelem.any  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Readonly:  	if (i >= ctxt.Instructions.Length)  		throw new InvalidOperationException ("invalid instruction");  	instruction = ctxt.Instructions [i++];  	if (instruction.OpCode != PE.OpCode.Ldelema)  		throw new InvalidOperationException ("invalid instruction");  	instructions.Add (new LdElemAddrInstruction (offset' true' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Ldelema:  	instructions.Add (new LdElemAddrInstruction (offset' false' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Ldc_i4_0:  	instructions.Add (new LdInt32Instruction (offset' 0));  	break;  case PE.OpCode.Ldc_i4_1:  	instructions.Add (new LdInt32Instruction (offset' 1));  	break;  case PE.OpCode.Ldc_i4_2:  	instructions.Add (new LdInt32Instruction (offset' 2));  	break;  case PE.OpCode.Ldc_i4_3:  	instructions.Add (new LdInt32Instruction (offset' 3));  	break;  case PE.OpCode.Ldc_i4_4:  	instructions.Add (new LdInt32Instruction (offset' 4));  	break;  case PE.OpCode.Ldc_i4_5:  	instructions.Add (new LdInt32Instruction (offset' 5));  	break;  case PE.OpCode.Ldc_i4_6:  	instructions.Add (new LdInt32Instruction (offset' 6));  	break;  case PE.OpCode.Ldc_i4_7:  	instructions.Add (new LdInt32Instruction (offset' 7));  	break;  case PE.OpCode.Ldc_i4_8:  	instructions.Add (new LdInt32Instruction (offset' 8));  	break;  case PE.OpCode.Ldc_i4_m1:  	instructions.Add (new LdInt32Instruction (offset' -1));  	break;  case PE.OpCode.Ldc_i4:  case PE.OpCode.Ldc_i4_s:  	instructions.Add (new LdInt32Instruction (offset' (int)instruction.Value));  	break;  case PE.OpCode.Ldc_i8:  	instructions.Add (new LdInt64Instruction (offset' (long)instruction.Value));  	break;  case PE.OpCode.Ldc_r4:  	instructions.Add (new LdSingleInstruction (offset' (float)instruction.Value));  	break;  case PE.OpCode.Ldc_r8:  	instructions.Add (new LdDoubleInstruction (offset' (double)instruction.Value));  	break;  case PE.OpCode.Ldstr:  	instructions.Add (new LdStringInstruction (offset' (string)instruction.Value));  	break;  case PE.OpCode.Add:  	instructions.Add (new ArithInstruction (offset' ArithOp.Add' false' false));  	break;  case PE.OpCode.Add_ovf:  	instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' false));  	break;  case PE.OpCode.Add_ovf_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' true));  	break;  case PE.OpCode.Sub:  	instructions.Add (new ArithInstruction (offset' ArithOp.Sub' false' false));  	break;  case PE.OpCode.Sub_ovf:  	instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' false));  	break;  case PE.OpCode.Sub_ovf_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' true));  	break;  case PE.OpCode.Mul:  	instructions.Add (new ArithInstruction (offset' ArithOp.Mul' false' false));  	break;  case PE.OpCode.Mul_ovf:  	instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' false));  	break;  case PE.OpCode.Mul_ovf_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' true));  	break;  case PE.OpCode.Div:  	instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' false));  	break;  case PE.OpCode.Div_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' true));  	break;  case PE.OpCode.Rem:  	instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' false));  	break;  case PE.OpCode.Rem_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' true));  	break;  case PE.OpCode.Neg:  	instructions.Add (new ArithInstruction (offset' ArithOp.Neg' false' false));  	break;  case PE.OpCode.And:  	instructions.Add (new ArithInstruction (offset' ArithOp.BitAnd' false' false));  	break;  case PE.OpCode.Or:  	instructions.Add (new ArithInstruction (offset' ArithOp.BitOr' false' false));  	break;  case PE.OpCode.Xor:  	instructions.Add (new ArithInstruction (offset' ArithOp.BitXor' false' false));  	break;  case PE.OpCode.Not:  	instructions.Add (new ArithInstruction (offset' ArithOp.BitNot' false' false));  	break;  case PE.OpCode.Shl:  	instructions.Add (new ArithInstruction (offset' ArithOp.Shl' false' false));  	break;  case PE.OpCode.Shr:  	instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' false));  	break;  case PE.OpCode.Shr_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' true));  	break;  case PE.OpCode.Conv_i1:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' false' false));  	break;  case PE.OpCode.Conv_u1:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' false' false));  	break;  case PE.OpCode.Conv_i2:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' false' false));  	break;  case PE.OpCode.Conv_u2:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' false' false));  	break;  case PE.OpCode.Conv_i4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' false' false));  	break;  case PE.OpCode.Conv_u4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' false' false));  	break;  case PE.OpCode.Conv_i8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' false' false));  	break;  case PE.OpCode.Conv_u8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' false' false));  	break;  case PE.OpCode.Conv_i:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' false' false));  	break;  case PE.OpCode.Conv_u:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' false' false));  	break;  case PE.OpCode.Conv_r4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Single' false' false));  	break;  case PE.OpCode.Conv_r8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' false));  	break;  case PE.OpCode.Conv_r_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' true));  	break;  case PE.OpCode.Conv_ovf_i1:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' false));  	break;  case PE.OpCode.Conv_ovf_u1:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' false));  	break;  case PE.OpCode.Conv_ovf_i2:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' false));  	break;  case PE.OpCode.Conv_ovf_u2:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' false));  	break;  case PE.OpCode.Conv_ovf_i4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' false));  	break;  case PE.OpCode.Conv_ovf_u4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' false));  	break;  case PE.OpCode.Conv_ovf_i8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' false));  	break;  case PE.OpCode.Conv_ovf_u8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' false));  	break;  case PE.OpCode.Conv_ovf_i:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' false));  	break;  case PE.OpCode.Conv_ovf_u:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' false));  	break;  case PE.OpCode.Conv_ovf_i1_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' true));  	break;  case PE.OpCode.Conv_ovf_u1_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' true));  	break;  case PE.OpCode.Conv_ovf_i2_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' true));  	break;  case PE.OpCode.Conv_ovf_u2_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' true));  	break;  case PE.OpCode.Conv_ovf_i4_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' true));  	break;  case PE.OpCode.Conv_ovf_u4_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' true));  	break;  case PE.OpCode.Conv_ovf_i8_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' true));  	break;  case PE.OpCode.Conv_ovf_u8_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' true));  	break;  case PE.OpCode.Conv_ovf_i_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' true));  	break;  case PE.OpCode.Conv_ovf_u_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' true));  	break;  default:  	throw new InvalidOperationException ("invalid instruction");  }  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: switch (instruction.OpCode) {  case PE.OpCode.Cpblk:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Cpblk));  	break;  case PE.OpCode.Initblk:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Initblk));  	break;  case PE.OpCode.Arglist:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Arglist));  	break;  case PE.OpCode.Localloc:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Localloc));  	break;  case PE.OpCode.Jmp:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Jmp));  	break;  case PE.OpCode.Calli:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Calli));  	break;  case PE.OpCode.Sizeof:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Sizeof));  	break;  case PE.OpCode.Mkrefany:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Mkrefany));  	break;  case PE.OpCode.Refanytype:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanytype));  	break;  case PE.OpCode.Refanyval:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanyval));  	break;  case PE.OpCode.Nop:  	instructions.Add (new MiscInstruction (offset' MiscOp.Nop));  	break;  case PE.OpCode.Break:  	instructions.Add (new MiscInstruction (offset' MiscOp.Break));  	break;  case PE.OpCode.Dup:  	instructions.Add (new MiscInstruction (offset' MiscOp.Dup));  	break;  case PE.OpCode.Pop:  	instructions.Add (new MiscInstruction (offset' MiscOp.Pop));  	break;  case PE.OpCode.Ldnull:  	instructions.Add (new MiscInstruction (offset' MiscOp.Ldnull));  	break;  case PE.OpCode.Ckfinite:  	instructions.Add (new MiscInstruction (offset' MiscOp.Ckfinite));  	break;  case PE.OpCode.Throw:  	instructions.Add (new MiscInstruction (offset' MiscOp.Throw));  	break;  case PE.OpCode.Rethrow:  	instructions.Add (new MiscInstruction (offset' MiscOp.Rethrow));  	break;  case PE.OpCode.Ldind_ref:  	instructions.Add (new MiscInstruction (offset' MiscOp.LdindRef));  	break;  case PE.OpCode.Stind_ref:  	instructions.Add (new MiscInstruction (offset' MiscOp.StindRef));  	break;  case PE.OpCode.Ldelem_ref:  	instructions.Add (new MiscInstruction (offset' MiscOp.LdelemRef));  	break;  case PE.OpCode.Stelem_ref:  	instructions.Add (new MiscInstruction (offset' MiscOp.StelemRef));  	break;  case PE.OpCode.Ldlen:  	instructions.Add (new MiscInstruction (offset' MiscOp.Ldlen));  	break;  case PE.OpCode.Ret:  	if (ctxt.ResultType == null)  		instructions.Add (new MiscInstruction (offset' MiscOp.Ret));  	else  		instructions.Add (new MiscInstruction (offset' MiscOp.RetVal));  	break;  case PE.OpCode.Endfilter:  	instructions.Add (new MiscInstruction (offset' MiscOp.Endfilter));  	break;  case PE.OpCode.Endfinally:  	// aka EndFault  	instructions.Add (new MiscInstruction (offset' MiscOp.Endfinally));  	break;  case PE.OpCode.Br_s:  case PE.OpCode.Br:  	instructions.Add (new BranchInstruction (offset' BranchOp.Br' false' (int)instruction.Value));  	break;  case PE.OpCode.Brtrue_s:  // aka brinst.s  case PE.OpCode.Brtrue:  	// aka brinst  	instructions.Add (new BranchInstruction (offset' BranchOp.Brtrue' false' (int)instruction.Value));  	break;  case PE.OpCode.Brfalse_s:  // aka brzero.s' brnull.s  case PE.OpCode.Brfalse:  	// aka brzero' brnull  	instructions.Add (new BranchInstruction (offset' BranchOp.Brfalse' false' (int)instruction.Value));  	break;  case PE.OpCode.Beq:  case PE.OpCode.Beq_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.Breq' false' (int)instruction.Value));  	break;  case PE.OpCode.Bne_un:  case PE.OpCode.Bne_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.Brne' false' (int)instruction.Value));  	break;  case PE.OpCode.Leave:  case PE.OpCode.Leave_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.Leave' false' (int)instruction.Value));  	break;  case PE.OpCode.Blt:  case PE.OpCode.Blt_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' false' (int)instruction.Value));  	break;  case PE.OpCode.Blt_un:  case PE.OpCode.Blt_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' true' (int)instruction.Value));  	break;  case PE.OpCode.Ble:  case PE.OpCode.Ble_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' false' (int)instruction.Value));  	break;  case PE.OpCode.Ble_un:  case PE.OpCode.Ble_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' true' (int)instruction.Value));  	break;  case PE.OpCode.Bgt:  case PE.OpCode.Bgt_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' false' (int)instruction.Value));  	break;  case PE.OpCode.Bgt_un:  case PE.OpCode.Bgt_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' true' (int)instruction.Value));  	break;  case PE.OpCode.Bge:  case PE.OpCode.Bge_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' false' (int)instruction.Value));  	break;  case PE.OpCode.Bge_un:  case PE.OpCode.Bge_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' true' (int)instruction.Value));  	break;  case PE.OpCode.Switch:  	instructions.Add (new SwitchInstruction (offset' (Seq<int>)instruction.Value));  	break;  case PE.OpCode.Ceq:  	instructions.Add (new CompareInstruction (offset' CompareOp.Ceq' false));  	break;  case PE.OpCode.Clt:  	instructions.Add (new CompareInstruction (offset' CompareOp.Clt' false));  	break;  case PE.OpCode.Clt_un:  	instructions.Add (new CompareInstruction (offset' CompareOp.Clt' true));  	break;  case PE.OpCode.Cgt:  	instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' false));  	break;  case PE.OpCode.Cgt_un:  	instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' true));  	break;  case PE.OpCode.Ldarg_0:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));  	break;  case PE.OpCode.Ldarg_1:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));  	break;  case PE.OpCode.Ldarg_2:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));  	break;  case PE.OpCode.Ldarg_3:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));  	break;  case PE.OpCode.Ldarg:  case PE.OpCode.Ldarg_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));  	break;  case PE.OpCode.Ldarga:  case PE.OpCode.Ldarga_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));  	break;  case PE.OpCode.Starg:  case PE.OpCode.Starg_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));  	break;  case PE.OpCode.Ldloc_0:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 0));  	break;  case PE.OpCode.Ldloc_1:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 1));  	break;  case PE.OpCode.Ldloc_2:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 2));  	break;  case PE.OpCode.Ldloc_3:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 3));  	break;  case PE.OpCode.Ldloc:  case PE.OpCode.Ldloc_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));  	break;  case PE.OpCode.Ldloca:  case PE.OpCode.Ldloca_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));  	break;  case PE.OpCode.Stloc_0:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 0));  	break;  case PE.OpCode.Stloc_1:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 1));  	break;  case PE.OpCode.Stloc_2:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 2));  	break;  case PE.OpCode.Stloc_3:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 3));  	break;  case PE.OpCode.Stloc:  case PE.OpCode.Stloc_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));  	break;  case PE.OpCode.Ldfld:  	instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));  	break;  case PE.OpCode.Ldsfld:  	instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));  	break;  case PE.OpCode.Ldflda:  	instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));  	break;  case PE.OpCode.Ldsflda:  	instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));  	break;  case PE.OpCode.Stfld:  	instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));  	break;  case PE.OpCode.Stsfld:  	instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));  	break;  case PE.OpCode.Ldtoken: {  	if (instruction.Value is FieldRef)  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));  	else if (instruction.Value is MethodRef)  		instructions.Add (new MethodInstruction (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));  	else if (instruction.Value is TypeRef)  		// NOTE: May be a higher-kinded type  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));  	else  		throw new InvalidOperationException ("unexpected ldtoken instruction value");  	break;  }  case PE.OpCode.Constrained: {  	var constrained = (TypeRef)instruction.Value;  	if (i >= ctxt.Instructions.Length)  		throw new InvalidOperationException ("invalid instructions");  	instruction = ctxt.Instructions [i++];  	if (instruction.OpCode != PE.OpCode.Callvirt)  		throw new InvalidOperationException ("invalid instruction");  	instructions.Add (new MethodInstruction (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));  	break;  }  case PE.OpCode.Call:  	instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Callvirt:  	instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Ldftn:  	instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Ldvirtftn:  	instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Newobj:  	instructions.Add (new MethodInstruction (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Ldind_i1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int8Ref));  	break;  case PE.OpCode.Ldind_u1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt8Ref));  	break;  case PE.OpCode.Ldind_i2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int16Ref));  	break;  case PE.OpCode.Ldind_u2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt16Ref));  	break;  case PE.OpCode.Ldind_i4:  case PE.OpCode.Ldind_u4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int32Ref));  	break;  case PE.OpCode.Ldind_i8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int64Ref));  	break;  case PE.OpCode.Ldind_i:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.IntNativeRef));  	break;  case PE.OpCode.Ldind_r4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.SingleRef));  	break;  case PE.OpCode.Ldind_r8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.DoubleRef));  	break;  case PE.OpCode.Ldobj:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Stind_i1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int8Ref));  	break;  case PE.OpCode.Stind_i2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int16Ref));  	break;  case PE.OpCode.Stind_i4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int32Ref));  	break;  case PE.OpCode.Stind_i8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int64Ref));  	break;  case PE.OpCode.Stind_i:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.IntNativeRef));  	break;  case PE.OpCode.Stind_r4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.SingleRef));  	break;  case PE.OpCode.Stind_r8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.DoubleRef));  	break;  case PE.OpCode.Stobj:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Cpobj:  	instructions.Add (new TypeInstruction (offset' TypeOp.Cpobj' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Newarr:  	instructions.Add (new TypeInstruction (offset' TypeOp.Newarr' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Initobj:  	instructions.Add (new TypeInstruction (offset' TypeOp.Initobj' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Castclass:  	instructions.Add (new TypeInstruction (offset' TypeOp.Castclass' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Isinst:  	instructions.Add (new TypeInstruction (offset' TypeOp.Isinst' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Box:  	instructions.Add (new TypeInstruction (offset' TypeOp.Box' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Unbox:  	instructions.Add (new TypeInstruction (offset' TypeOp.Unbox' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Unbox_any:  	instructions.Add (new TypeInstruction (offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Ldelem_i1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int8Ref));  	break;  case PE.OpCode.Ldelem_u1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt8Ref));  	break;  case PE.OpCode.Ldelem_i2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int16Ref));  	break;  case PE.OpCode.Ldelem_u2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt16Ref));  	break;  case PE.OpCode.Ldelem_i4:  case PE.OpCode.Ldelem_u4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int32Ref));  	break;  case PE.OpCode.Ldelem_i:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.IntNativeRef));  	break;  case PE.OpCode.Ldelem_i8:  	// aka ldelem.u8  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int64Ref));  	break;  case PE.OpCode.Ldelem_r4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.SingleRef));  	break;  case PE.OpCode.Ldelem_r8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.DoubleRef));  	break;  case PE.OpCode.Ldelem:  	// aka ldelem.any  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Stelem_i1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int8Ref));  	break;  case PE.OpCode.Stelem_i2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int16Ref));  	break;  case PE.OpCode.Stelem_i4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int32Ref));  	break;  case PE.OpCode.Stelem_i8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int64Ref));  	break;  case PE.OpCode.Stelem_i:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.IntNativeRef));  	break;  case PE.OpCode.Stelem_r4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.SingleRef));  	break;  case PE.OpCode.Stelem_r8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.DoubleRef));  	break;  case PE.OpCode.Stelem:  	// aka stelem.any  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Readonly:  	if (i >= ctxt.Instructions.Length)  		throw new InvalidOperationException ("invalid instruction");  	instruction = ctxt.Instructions [i++];  	if (instruction.OpCode != PE.OpCode.Ldelema)  		throw new InvalidOperationException ("invalid instruction");  	instructions.Add (new LdElemAddrInstruction (offset' true' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Ldelema:  	instructions.Add (new LdElemAddrInstruction (offset' false' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Ldc_i4_0:  	instructions.Add (new LdInt32Instruction (offset' 0));  	break;  case PE.OpCode.Ldc_i4_1:  	instructions.Add (new LdInt32Instruction (offset' 1));  	break;  case PE.OpCode.Ldc_i4_2:  	instructions.Add (new LdInt32Instruction (offset' 2));  	break;  case PE.OpCode.Ldc_i4_3:  	instructions.Add (new LdInt32Instruction (offset' 3));  	break;  case PE.OpCode.Ldc_i4_4:  	instructions.Add (new LdInt32Instruction (offset' 4));  	break;  case PE.OpCode.Ldc_i4_5:  	instructions.Add (new LdInt32Instruction (offset' 5));  	break;  case PE.OpCode.Ldc_i4_6:  	instructions.Add (new LdInt32Instruction (offset' 6));  	break;  case PE.OpCode.Ldc_i4_7:  	instructions.Add (new LdInt32Instruction (offset' 7));  	break;  case PE.OpCode.Ldc_i4_8:  	instructions.Add (new LdInt32Instruction (offset' 8));  	break;  case PE.OpCode.Ldc_i4_m1:  	instructions.Add (new LdInt32Instruction (offset' -1));  	break;  case PE.OpCode.Ldc_i4:  case PE.OpCode.Ldc_i4_s:  	instructions.Add (new LdInt32Instruction (offset' (int)instruction.Value));  	break;  case PE.OpCode.Ldc_i8:  	instructions.Add (new LdInt64Instruction (offset' (long)instruction.Value));  	break;  case PE.OpCode.Ldc_r4:  	instructions.Add (new LdSingleInstruction (offset' (float)instruction.Value));  	break;  case PE.OpCode.Ldc_r8:  	instructions.Add (new LdDoubleInstruction (offset' (double)instruction.Value));  	break;  case PE.OpCode.Ldstr:  	instructions.Add (new LdStringInstruction (offset' (string)instruction.Value));  	break;  case PE.OpCode.Add:  	instructions.Add (new ArithInstruction (offset' ArithOp.Add' false' false));  	break;  case PE.OpCode.Add_ovf:  	instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' false));  	break;  case PE.OpCode.Add_ovf_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' true));  	break;  case PE.OpCode.Sub:  	instructions.Add (new ArithInstruction (offset' ArithOp.Sub' false' false));  	break;  case PE.OpCode.Sub_ovf:  	instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' false));  	break;  case PE.OpCode.Sub_ovf_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' true));  	break;  case PE.OpCode.Mul:  	instructions.Add (new ArithInstruction (offset' ArithOp.Mul' false' false));  	break;  case PE.OpCode.Mul_ovf:  	instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' false));  	break;  case PE.OpCode.Mul_ovf_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' true));  	break;  case PE.OpCode.Div:  	instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' false));  	break;  case PE.OpCode.Div_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' true));  	break;  case PE.OpCode.Rem:  	instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' false));  	break;  case PE.OpCode.Rem_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' true));  	break;  case PE.OpCode.Neg:  	instructions.Add (new ArithInstruction (offset' ArithOp.Neg' false' false));  	break;  case PE.OpCode.And:  	instructions.Add (new ArithInstruction (offset' ArithOp.BitAnd' false' false));  	break;  case PE.OpCode.Or:  	instructions.Add (new ArithInstruction (offset' ArithOp.BitOr' false' false));  	break;  case PE.OpCode.Xor:  	instructions.Add (new ArithInstruction (offset' ArithOp.BitXor' false' false));  	break;  case PE.OpCode.Not:  	instructions.Add (new ArithInstruction (offset' ArithOp.BitNot' false' false));  	break;  case PE.OpCode.Shl:  	instructions.Add (new ArithInstruction (offset' ArithOp.Shl' false' false));  	break;  case PE.OpCode.Shr:  	instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' false));  	break;  case PE.OpCode.Shr_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' true));  	break;  case PE.OpCode.Conv_i1:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' false' false));  	break;  case PE.OpCode.Conv_u1:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' false' false));  	break;  case PE.OpCode.Conv_i2:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' false' false));  	break;  case PE.OpCode.Conv_u2:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' false' false));  	break;  case PE.OpCode.Conv_i4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' false' false));  	break;  case PE.OpCode.Conv_u4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' false' false));  	break;  case PE.OpCode.Conv_i8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' false' false));  	break;  case PE.OpCode.Conv_u8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' false' false));  	break;  case PE.OpCode.Conv_i:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' false' false));  	break;  case PE.OpCode.Conv_u:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' false' false));  	break;  case PE.OpCode.Conv_r4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Single' false' false));  	break;  case PE.OpCode.Conv_r8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' false));  	break;  case PE.OpCode.Conv_r_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' true));  	break;  case PE.OpCode.Conv_ovf_i1:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' false));  	break;  case PE.OpCode.Conv_ovf_u1:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' false));  	break;  case PE.OpCode.Conv_ovf_i2:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' false));  	break;  case PE.OpCode.Conv_ovf_u2:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' false));  	break;  case PE.OpCode.Conv_ovf_i4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' false));  	break;  case PE.OpCode.Conv_ovf_u4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' false));  	break;  case PE.OpCode.Conv_ovf_i8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' false));  	break;  case PE.OpCode.Conv_ovf_u8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' false));  	break;  case PE.OpCode.Conv_ovf_i:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' false));  	break;  case PE.OpCode.Conv_ovf_u:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' false));  	break;  case PE.OpCode.Conv_ovf_i1_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' true));  	break;  case PE.OpCode.Conv_ovf_u1_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' true));  	break;  case PE.OpCode.Conv_ovf_i2_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' true));  	break;  case PE.OpCode.Conv_ovf_u2_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' true));  	break;  case PE.OpCode.Conv_ovf_i4_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' true));  	break;  case PE.OpCode.Conv_ovf_u4_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' true));  	break;  case PE.OpCode.Conv_ovf_i8_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' true));  	break;  case PE.OpCode.Conv_ovf_u8_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' true));  	break;  case PE.OpCode.Conv_ovf_i_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' true));  	break;  case PE.OpCode.Conv_ovf_u_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' true));  	break;  default:  	throw new InvalidOperationException ("invalid instruction");  }  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: switch (instruction.OpCode) {  case PE.OpCode.Cpblk:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Cpblk));  	break;  case PE.OpCode.Initblk:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Initblk));  	break;  case PE.OpCode.Arglist:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Arglist));  	break;  case PE.OpCode.Localloc:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Localloc));  	break;  case PE.OpCode.Jmp:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Jmp));  	break;  case PE.OpCode.Calli:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Calli));  	break;  case PE.OpCode.Sizeof:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Sizeof));  	break;  case PE.OpCode.Mkrefany:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Mkrefany));  	break;  case PE.OpCode.Refanytype:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanytype));  	break;  case PE.OpCode.Refanyval:  	instructions.Add (new UnsupportedInstruction (offset' UnsupportedOp.Refanyval));  	break;  case PE.OpCode.Nop:  	instructions.Add (new MiscInstruction (offset' MiscOp.Nop));  	break;  case PE.OpCode.Break:  	instructions.Add (new MiscInstruction (offset' MiscOp.Break));  	break;  case PE.OpCode.Dup:  	instructions.Add (new MiscInstruction (offset' MiscOp.Dup));  	break;  case PE.OpCode.Pop:  	instructions.Add (new MiscInstruction (offset' MiscOp.Pop));  	break;  case PE.OpCode.Ldnull:  	instructions.Add (new MiscInstruction (offset' MiscOp.Ldnull));  	break;  case PE.OpCode.Ckfinite:  	instructions.Add (new MiscInstruction (offset' MiscOp.Ckfinite));  	break;  case PE.OpCode.Throw:  	instructions.Add (new MiscInstruction (offset' MiscOp.Throw));  	break;  case PE.OpCode.Rethrow:  	instructions.Add (new MiscInstruction (offset' MiscOp.Rethrow));  	break;  case PE.OpCode.Ldind_ref:  	instructions.Add (new MiscInstruction (offset' MiscOp.LdindRef));  	break;  case PE.OpCode.Stind_ref:  	instructions.Add (new MiscInstruction (offset' MiscOp.StindRef));  	break;  case PE.OpCode.Ldelem_ref:  	instructions.Add (new MiscInstruction (offset' MiscOp.LdelemRef));  	break;  case PE.OpCode.Stelem_ref:  	instructions.Add (new MiscInstruction (offset' MiscOp.StelemRef));  	break;  case PE.OpCode.Ldlen:  	instructions.Add (new MiscInstruction (offset' MiscOp.Ldlen));  	break;  case PE.OpCode.Ret:  	if (ctxt.ResultType == null)  		instructions.Add (new MiscInstruction (offset' MiscOp.Ret));  	else  		instructions.Add (new MiscInstruction (offset' MiscOp.RetVal));  	break;  case PE.OpCode.Endfilter:  	instructions.Add (new MiscInstruction (offset' MiscOp.Endfilter));  	break;  case PE.OpCode.Endfinally:  	// aka EndFault  	instructions.Add (new MiscInstruction (offset' MiscOp.Endfinally));  	break;  case PE.OpCode.Br_s:  case PE.OpCode.Br:  	instructions.Add (new BranchInstruction (offset' BranchOp.Br' false' (int)instruction.Value));  	break;  case PE.OpCode.Brtrue_s:  // aka brinst.s  case PE.OpCode.Brtrue:  	// aka brinst  	instructions.Add (new BranchInstruction (offset' BranchOp.Brtrue' false' (int)instruction.Value));  	break;  case PE.OpCode.Brfalse_s:  // aka brzero.s' brnull.s  case PE.OpCode.Brfalse:  	// aka brzero' brnull  	instructions.Add (new BranchInstruction (offset' BranchOp.Brfalse' false' (int)instruction.Value));  	break;  case PE.OpCode.Beq:  case PE.OpCode.Beq_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.Breq' false' (int)instruction.Value));  	break;  case PE.OpCode.Bne_un:  case PE.OpCode.Bne_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.Brne' false' (int)instruction.Value));  	break;  case PE.OpCode.Leave:  case PE.OpCode.Leave_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.Leave' false' (int)instruction.Value));  	break;  case PE.OpCode.Blt:  case PE.OpCode.Blt_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' false' (int)instruction.Value));  	break;  case PE.OpCode.Blt_un:  case PE.OpCode.Blt_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrLt' true' (int)instruction.Value));  	break;  case PE.OpCode.Ble:  case PE.OpCode.Ble_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' false' (int)instruction.Value));  	break;  case PE.OpCode.Ble_un:  case PE.OpCode.Ble_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrLe' true' (int)instruction.Value));  	break;  case PE.OpCode.Bgt:  case PE.OpCode.Bgt_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' false' (int)instruction.Value));  	break;  case PE.OpCode.Bgt_un:  case PE.OpCode.Bgt_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrGt' true' (int)instruction.Value));  	break;  case PE.OpCode.Bge:  case PE.OpCode.Bge_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' false' (int)instruction.Value));  	break;  case PE.OpCode.Bge_un:  case PE.OpCode.Bge_un_s:  	instructions.Add (new BranchInstruction (offset' BranchOp.BrGe' true' (int)instruction.Value));  	break;  case PE.OpCode.Switch:  	instructions.Add (new SwitchInstruction (offset' (Seq<int>)instruction.Value));  	break;  case PE.OpCode.Ceq:  	instructions.Add (new CompareInstruction (offset' CompareOp.Ceq' false));  	break;  case PE.OpCode.Clt:  	instructions.Add (new CompareInstruction (offset' CompareOp.Clt' false));  	break;  case PE.OpCode.Clt_un:  	instructions.Add (new CompareInstruction (offset' CompareOp.Clt' true));  	break;  case PE.OpCode.Cgt:  	instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' false));  	break;  case PE.OpCode.Cgt_un:  	instructions.Add (new CompareInstruction (offset' CompareOp.Cgt' true));  	break;  case PE.OpCode.Ldarg_0:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));  	break;  case PE.OpCode.Ldarg_1:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));  	break;  case PE.OpCode.Ldarg_2:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));  	break;  case PE.OpCode.Ldarg_3:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));  	break;  case PE.OpCode.Ldarg:  case PE.OpCode.Ldarg_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));  	break;  case PE.OpCode.Ldarga:  case PE.OpCode.Ldarga_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));  	break;  case PE.OpCode.Starg:  case PE.OpCode.Starg_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));  	break;  case PE.OpCode.Ldloc_0:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 0));  	break;  case PE.OpCode.Ldloc_1:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 1));  	break;  case PE.OpCode.Ldloc_2:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 2));  	break;  case PE.OpCode.Ldloc_3:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 3));  	break;  case PE.OpCode.Ldloc:  case PE.OpCode.Ldloc_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));  	break;  case PE.OpCode.Ldloca:  case PE.OpCode.Ldloca_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));  	break;  case PE.OpCode.Stloc_0:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 0));  	break;  case PE.OpCode.Stloc_1:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 1));  	break;  case PE.OpCode.Stloc_2:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 2));  	break;  case PE.OpCode.Stloc_3:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 3));  	break;  case PE.OpCode.Stloc:  case PE.OpCode.Stloc_s:  	instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));  	break;  case PE.OpCode.Ldfld:  	instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));  	break;  case PE.OpCode.Ldsfld:  	instructions.Add (new FieldInstruction (offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));  	break;  case PE.OpCode.Ldflda:  	instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));  	break;  case PE.OpCode.Ldsflda:  	instructions.Add (new FieldInstruction (offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));  	break;  case PE.OpCode.Stfld:  	instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));  	break;  case PE.OpCode.Stsfld:  	instructions.Add (new FieldInstruction (offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));  	break;  case PE.OpCode.Ldtoken: {  	if (instruction.Value is FieldRef)  		instructions.Add (new FieldInstruction (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));  	else if (instruction.Value is MethodRef)  		instructions.Add (new MethodInstruction (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));  	else if (instruction.Value is TypeRef)  		// NOTE: May be a higher-kinded type  		instructions.Add (new TypeInstruction (offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));  	else  		throw new InvalidOperationException ("unexpected ldtoken instruction value");  	break;  }  case PE.OpCode.Constrained: {  	var constrained = (TypeRef)instruction.Value;  	if (i >= ctxt.Instructions.Length)  		throw new InvalidOperationException ("invalid instructions");  	instruction = ctxt.Instructions [i++];  	if (instruction.OpCode != PE.OpCode.Callvirt)  		throw new InvalidOperationException ("invalid instruction");  	instructions.Add (new MethodInstruction (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));  	break;  }  case PE.OpCode.Call:  	instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Callvirt:  	instructions.Add (new MethodInstruction (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Ldftn:  	instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Ldvirtftn:  	instructions.Add (new MethodInstruction (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Newobj:  	instructions.Add (new MethodInstruction (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));  	break;  case PE.OpCode.Ldind_i1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int8Ref));  	break;  case PE.OpCode.Ldind_u1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt8Ref));  	break;  case PE.OpCode.Ldind_i2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int16Ref));  	break;  case PE.OpCode.Ldind_u2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.UInt16Ref));  	break;  case PE.OpCode.Ldind_i4:  case PE.OpCode.Ldind_u4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int32Ref));  	break;  case PE.OpCode.Ldind_i8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.Int64Ref));  	break;  case PE.OpCode.Ldind_i:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.IntNativeRef));  	break;  case PE.OpCode.Ldind_r4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.SingleRef));  	break;  case PE.OpCode.Ldind_r8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' global.DoubleRef));  	break;  case PE.OpCode.Ldobj:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldobj' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Stind_i1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int8Ref));  	break;  case PE.OpCode.Stind_i2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int16Ref));  	break;  case PE.OpCode.Stind_i4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int32Ref));  	break;  case PE.OpCode.Stind_i8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.Int64Ref));  	break;  case PE.OpCode.Stind_i:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.IntNativeRef));  	break;  case PE.OpCode.Stind_r4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.SingleRef));  	break;  case PE.OpCode.Stind_r8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' global.DoubleRef));  	break;  case PE.OpCode.Stobj:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stobj' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Cpobj:  	instructions.Add (new TypeInstruction (offset' TypeOp.Cpobj' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Newarr:  	instructions.Add (new TypeInstruction (offset' TypeOp.Newarr' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Initobj:  	instructions.Add (new TypeInstruction (offset' TypeOp.Initobj' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Castclass:  	instructions.Add (new TypeInstruction (offset' TypeOp.Castclass' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Isinst:  	instructions.Add (new TypeInstruction (offset' TypeOp.Isinst' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Box:  	instructions.Add (new TypeInstruction (offset' TypeOp.Box' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Unbox:  	instructions.Add (new TypeInstruction (offset' TypeOp.Unbox' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Unbox_any:  	instructions.Add (new TypeInstruction (offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Ldelem_i1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int8Ref));  	break;  case PE.OpCode.Ldelem_u1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt8Ref));  	break;  case PE.OpCode.Ldelem_i2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int16Ref));  	break;  case PE.OpCode.Ldelem_u2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.UInt16Ref));  	break;  case PE.OpCode.Ldelem_i4:  case PE.OpCode.Ldelem_u4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int32Ref));  	break;  case PE.OpCode.Ldelem_i:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.IntNativeRef));  	break;  case PE.OpCode.Ldelem_i8:  	// aka ldelem.u8  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.Int64Ref));  	break;  case PE.OpCode.Ldelem_r4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.SingleRef));  	break;  case PE.OpCode.Ldelem_r8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' global.DoubleRef));  	break;  case PE.OpCode.Ldelem:  	// aka ldelem.any  	instructions.Add (new TypeInstruction (offset' TypeOp.Ldelem' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Stelem_i1:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int8Ref));  	break;  case PE.OpCode.Stelem_i2:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int16Ref));  	break;  case PE.OpCode.Stelem_i4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int32Ref));  	break;  case PE.OpCode.Stelem_i8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.Int64Ref));  	break;  case PE.OpCode.Stelem_i:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.IntNativeRef));  	break;  case PE.OpCode.Stelem_r4:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.SingleRef));  	break;  case PE.OpCode.Stelem_r8:  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' global.DoubleRef));  	break;  case PE.OpCode.Stelem:  	// aka stelem.any  	instructions.Add (new TypeInstruction (offset' TypeOp.Stelem' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Readonly:  	if (i >= ctxt.Instructions.Length)  		throw new InvalidOperationException ("invalid instruction");  	instruction = ctxt.Instructions [i++];  	if (instruction.OpCode != PE.OpCode.Ldelema)  		throw new InvalidOperationException ("invalid instruction");  	instructions.Add (new LdElemAddrInstruction (offset' true' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Ldelema:  	instructions.Add (new LdElemAddrInstruction (offset' false' (TypeRef)instruction.Value));  	break;  case PE.OpCode.Ldc_i4_0:  	instructions.Add (new LdInt32Instruction (offset' 0));  	break;  case PE.OpCode.Ldc_i4_1:  	instructions.Add (new LdInt32Instruction (offset' 1));  	break;  case PE.OpCode.Ldc_i4_2:  	instructions.Add (new LdInt32Instruction (offset' 2));  	break;  case PE.OpCode.Ldc_i4_3:  	instructions.Add (new LdInt32Instruction (offset' 3));  	break;  case PE.OpCode.Ldc_i4_4:  	instructions.Add (new LdInt32Instruction (offset' 4));  	break;  case PE.OpCode.Ldc_i4_5:  	instructions.Add (new LdInt32Instruction (offset' 5));  	break;  case PE.OpCode.Ldc_i4_6:  	instructions.Add (new LdInt32Instruction (offset' 6));  	break;  case PE.OpCode.Ldc_i4_7:  	instructions.Add (new LdInt32Instruction (offset' 7));  	break;  case PE.OpCode.Ldc_i4_8:  	instructions.Add (new LdInt32Instruction (offset' 8));  	break;  case PE.OpCode.Ldc_i4_m1:  	instructions.Add (new LdInt32Instruction (offset' -1));  	break;  case PE.OpCode.Ldc_i4:  case PE.OpCode.Ldc_i4_s:  	instructions.Add (new LdInt32Instruction (offset' (int)instruction.Value));  	break;  case PE.OpCode.Ldc_i8:  	instructions.Add (new LdInt64Instruction (offset' (long)instruction.Value));  	break;  case PE.OpCode.Ldc_r4:  	instructions.Add (new LdSingleInstruction (offset' (float)instruction.Value));  	break;  case PE.OpCode.Ldc_r8:  	instructions.Add (new LdDoubleInstruction (offset' (double)instruction.Value));  	break;  case PE.OpCode.Ldstr:  	instructions.Add (new LdStringInstruction (offset' (string)instruction.Value));  	break;  case PE.OpCode.Add:  	instructions.Add (new ArithInstruction (offset' ArithOp.Add' false' false));  	break;  case PE.OpCode.Add_ovf:  	instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' false));  	break;  case PE.OpCode.Add_ovf_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Add' true' true));  	break;  case PE.OpCode.Sub:  	instructions.Add (new ArithInstruction (offset' ArithOp.Sub' false' false));  	break;  case PE.OpCode.Sub_ovf:  	instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' false));  	break;  case PE.OpCode.Sub_ovf_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Sub' true' true));  	break;  case PE.OpCode.Mul:  	instructions.Add (new ArithInstruction (offset' ArithOp.Mul' false' false));  	break;  case PE.OpCode.Mul_ovf:  	instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' false));  	break;  case PE.OpCode.Mul_ovf_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Mul' true' true));  	break;  case PE.OpCode.Div:  	instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' false));  	break;  case PE.OpCode.Div_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Div' false' true));  	break;  case PE.OpCode.Rem:  	instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' false));  	break;  case PE.OpCode.Rem_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Rem' false' true));  	break;  case PE.OpCode.Neg:  	instructions.Add (new ArithInstruction (offset' ArithOp.Neg' false' false));  	break;  case PE.OpCode.And:  	instructions.Add (new ArithInstruction (offset' ArithOp.BitAnd' false' false));  	break;  case PE.OpCode.Or:  	instructions.Add (new ArithInstruction (offset' ArithOp.BitOr' false' false));  	break;  case PE.OpCode.Xor:  	instructions.Add (new ArithInstruction (offset' ArithOp.BitXor' false' false));  	break;  case PE.OpCode.Not:  	instructions.Add (new ArithInstruction (offset' ArithOp.BitNot' false' false));  	break;  case PE.OpCode.Shl:  	instructions.Add (new ArithInstruction (offset' ArithOp.Shl' false' false));  	break;  case PE.OpCode.Shr:  	instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' false));  	break;  case PE.OpCode.Shr_un:  	instructions.Add (new ArithInstruction (offset' ArithOp.Shr' false' true));  	break;  case PE.OpCode.Conv_i1:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' false' false));  	break;  case PE.OpCode.Conv_u1:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' false' false));  	break;  case PE.OpCode.Conv_i2:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' false' false));  	break;  case PE.OpCode.Conv_u2:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' false' false));  	break;  case PE.OpCode.Conv_i4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' false' false));  	break;  case PE.OpCode.Conv_u4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' false' false));  	break;  case PE.OpCode.Conv_i8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' false' false));  	break;  case PE.OpCode.Conv_u8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' false' false));  	break;  case PE.OpCode.Conv_i:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' false' false));  	break;  case PE.OpCode.Conv_u:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' false' false));  	break;  case PE.OpCode.Conv_r4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Single' false' false));  	break;  case PE.OpCode.Conv_r8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' false));  	break;  case PE.OpCode.Conv_r_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Double' false' true));  	break;  case PE.OpCode.Conv_ovf_i1:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' false));  	break;  case PE.OpCode.Conv_ovf_u1:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' false));  	break;  case PE.OpCode.Conv_ovf_i2:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' false));  	break;  case PE.OpCode.Conv_ovf_u2:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' false));  	break;  case PE.OpCode.Conv_ovf_i4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' false));  	break;  case PE.OpCode.Conv_ovf_u4:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' false));  	break;  case PE.OpCode.Conv_ovf_i8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' false));  	break;  case PE.OpCode.Conv_ovf_u8:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' false));  	break;  case PE.OpCode.Conv_ovf_i:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' false));  	break;  case PE.OpCode.Conv_ovf_u:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' false));  	break;  case PE.OpCode.Conv_ovf_i1_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int8' true' true));  	break;  case PE.OpCode.Conv_ovf_u1_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt8' true' true));  	break;  case PE.OpCode.Conv_ovf_i2_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int16' true' true));  	break;  case PE.OpCode.Conv_ovf_u2_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt16' true' true));  	break;  case PE.OpCode.Conv_ovf_i4_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int32' true' true));  	break;  case PE.OpCode.Conv_ovf_u4_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt32' true' true));  	break;  case PE.OpCode.Conv_ovf_i8_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.Int64' true' true));  	break;  case PE.OpCode.Conv_ovf_u8_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UInt64' true' true));  	break;  case PE.OpCode.Conv_ovf_i_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.IntNative' true' true));  	break;  case PE.OpCode.Conv_ovf_u_un:  	instructions.Add (new ConvInstruction (offset' NumberFlavor.UIntNative' true' true));  	break;  default:  	throw new InvalidOperationException ("invalid instruction");  }  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 2));  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.Ld' ArgLocal.Local' 3));  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 2));  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: instructions.Add (new ArgLocalInstruction (offset' ArgLocalOp.St' ArgLocal.Local' 3));  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: instructions.Add (new LdInt32Instruction (offset' 2));  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: instructions.Add (new LdInt32Instruction (offset' 3));  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: instructions.Add (new LdInt32Instruction (offset' 4));  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: instructions.Add (new LdInt32Instruction (offset' 5));  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: instructions.Add (new LdInt32Instruction (offset' 6));  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: instructions.Add (new LdInt32Instruction (offset' 7));  
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: instructions.Add (new LdInt32Instruction (offset' 8));  
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor) {  case InstructionFlavor.Unsupported:  	throw new InvalidOperationException ("unsupported opcode");  case InstructionFlavor.Misc: {  	var misci = (MiscInstruction)instruction;  	switch (misci.Op) {  	case MiscOp.Nop:  	case MiscOp.Break:  		return state;  	case MiscOp.Dup:  		return state.Push (state.Peek (0));  	case MiscOp.Pop:  		return state.Pop (1);  	case MiscOp.Ldnull:  		return state.PushType (global.NullRef' BottomPT);  	case MiscOp.Ckfinite:  		state.PeekExpectedType (0' global.DoubleRef' changed);  		// Assume the instruction can "peek" at top of stack' thus no need for pop/push.  		return state;  	case MiscOp.Throw:  		state.PeekReferenceType (0);  		return state.DiscardStack ();  	case MiscOp.Rethrow:  		return state.DiscardStack ();  	case MiscOp.LdindRef: {  		var elemType = state.PeekPointerToReferenceType (0);  		return state.PopPushType (1' elemType' BottomPT);  	}  	case MiscOp.StindRef: {  		var expElemType = state.PeekPointerToReferenceType (1);  		state.PeekExpectedType (0' expElemType' changed);  		return state.Pop (2);  	}  	case MiscOp.LdelemRef: {  		state.PeekIndexType (0);  		// WARNING: Type may not be final  		var elemType = state.PeekArrayOfReferenceType (1);  		return state.PopPushType (2' elemType' BottomPT);  	}  	case MiscOp.StelemRef:  		state.PeekReferenceType (0);  		state.PeekIndexType (1);  		state.PeekArrayOfReferenceType (2);  		// Since the value type and array element type may be independently generalized'  		// it is pointless to check that the first is assignable to the second.  		// Instead this check is done at runtime.  		return state.Pop (3);  	case MiscOp.Ldlen:  		state.PeekArrayOfAnyType (0);  		return state.PopPushType (1' global.IntNativeRef' BottomPT);  	case MiscOp.Ret: {  		if (state.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return state;  		// empty  	}  	case MiscOp.RetVal: {  		state.PeekExpectedType (0' method.Result.Type' changed);  		var newState = state.Pop (1);  		if (newState.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return newState;  		// empty  	}  	case MiscOp.Endfilter: {  		state.PeekExpectedType (0' global.Int32Ref' changed);  		var newState = state.Pop (1);  		if (newState.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return newState;  		// empty  	}  	case MiscOp.Endfinally: {  		// Control could transfer to an outer finally/fault block' or to the target  		// of a leave instruction. However these transitions are delt with separately.  		return state.DiscardStack ();  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Branch: {  	var bri = (BranchInstruction)instruction;  	switch (bri.Op) {  	case BranchOp.Br:  		UnifyBeforeState (state' bri.Target' changed);  		return state;  	case BranchOp.Brtrue: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.PeekIntegerOrObjectOrPointerType (0' false);  		var newState = state.Pop (1);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Brfalse: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.PeekIntegerOrObjectOrPointerType (0' true);  		var newState = state.Pop (1);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Breq:  	case BranchOp.Brne: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.Peek2ComparableTypes (0' true);  		var newState = state.Pop (2);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Leave: {  		// Control could transfer via finally blocks instead of directly to the leave target.  		// Propogate only that the stack must be empty at target. Remaining machine state  		// is dealt with separately.  		UnifyBeforeState (new MachineState (methEnv' method.ValueParameters.Count' method.Locals.Count)' bri.Target' changed);  		return state.DiscardStack ();  	}  	case BranchOp.BrLt:  	case BranchOp.BrLe:  	case BranchOp.BrGt:  	case BranchOp.BrGe: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.Peek2ComparableTypes (0' false);  		var newState = state.Pop (2);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Switch: {  	var switchi = (SwitchInstruction)instruction;  	state.PeekExpectedType (0' global.Int32Ref' changed);  	var newState = state.Pop (1);  	for (var i = 0; i < switchi.CaseTargets.Count; i++)  		UnifyBeforeState (newState' switchi.CaseTargets [i]' changed);  	return newState;  }  case InstructionFlavor.Compare: {  	var cmpi = (CompareInstruction)instruction;  	// WARNING: Capured type may not be final  	// NOTE: May capture skolemized types  	switch (cmpi.Op) {  	case CompareOp.Ceq:  	case CompareOp.CnePseudo:  		cmpi.Type = state.Peek2ComparableTypes (0' true);  		return state.PopPushType (2' global.Int32Ref' BottomPT);  	case CompareOp.Clt:  	case CompareOp.Cgt:  	case CompareOp.CgePseudo:  	case CompareOp.ClePseudo:  		cmpi.Type = state.Peek2ComparableTypes (0' false);  		return state.PopPushType (2' global.Int32Ref' BottomPT);  	case CompareOp.CtruePseudo:  	case CompareOp.CfalsePseudo:  		cmpi.Type = state.PeekIntegerOrObjectOrPointerType (0' true);  		return state.PopPushType (1' global.Int32Ref' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.ArgLocal: {  	var argi = (ArgLocalInstruction)instruction;  	var type = method.ArgLocalType (argi.ArgLocal' argi.Index);  	switch (argi.Op) {  	case ArgLocalOp.Ld:  		return state.PushType (type' state.ArgLocalPointsTo (argi.ArgLocal' argi.Index));  	case ArgLocalOp.Lda:  		return state.PushType (methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (type)' ArgLocalPT (argi.ArgLocal' argi.Index));  	case ArgLocalOp.St: {  		state.PeekExpectedType (0' type' changed);  		var pointsTo = state.PeekPointsTo (0);  		if (!pointsTo.IsBottom) {  			if (!(type.Style (methEnv) is ManagedPointerTypeStyle))  				throw new InvalidOperationException ("stack indicates pointer' but parameter or local type does not");  			if (pointsTo.PointsOutsideOfHeap)  				throw new InvalidOperationException ("arguments cannot point outside of the heap");  		}  		return state.PopAddArgLocalPointsTo (1' argi.ArgLocal' argi.Index' pointsTo);  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Field: {  	var fieldi = (FieldInstruction)instruction;  	var fieldEnv = fieldi.Field.Enter (methEnv);  	var fieldType = fieldEnv.SubstituteType (fieldEnv.Field.FieldType);  	switch (fieldi.Op) {  	case FieldOp.Ldfld:  		if (fieldi.IsStatic)  			return state.PushType (fieldType' BottomPT);  		else {  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (0' fieldi.Field.DefiningType' true' changed);  			return state.PopPushType (1' fieldType' BottomPT);  		}  	case FieldOp.Ldflda:  		if (fieldi.IsStatic)  			return state.PushType (methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (fieldType)' HeapPT);  		else {  			// Underlying type cannot be a struct' otherwise would have a pointer into  			// the stack  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (0' fieldi.Field.DefiningType' false' changed);  			return state.PopPushType (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (fieldType)' HeapPT);  		}  	case FieldOp.Stfld:  		if (fieldi.IsStatic) {  			state.PeekExpectedType (0' fieldType' changed);  			return state.Pop (1);  		}  		else {  			state.PeekExpectedType (0' fieldType' changed);  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (1' fieldi.Field.DefiningType' false' changed);  			return state.Pop (2);  		}  	case FieldOp.Ldtoken:  		return state.PushType (global.RuntimeFieldHandleRef' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Method: {  	var methi = (MethodInstruction)instruction;  	var sig = (CST.MethodSignature)methi.Method.ExternalSignature;  	switch (methi.Op) {  	case MethodOp.Call: {  		for (var i = sig.Parameters.Count - 1; i >= 1; i--)  			state.PeekExpectedType (sig.Parameters.Count - 1 - i' sig.Parameters [i]' changed);  		if (methi.Constrained != null) {  			if (!methi.IsVirtual || methi.Method.IsStatic)  				throw new InvalidOperationException ("constrained only valid on virtual calls to instance methods");  			var thisType = sig.Parameters [0];  			var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (methi.Constrained);  			var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo (methi.Constrained);  			var cs = methi.Constrained.Style (methEnv);  			if (cs is ValueTypeStyle) {  				if (thisType.Style (methEnv) is ManagedPointerTypeStyle) {  					// We pass the argument pointer as is  					if (!methi.Constrained.IsAssignableTo (methEnv' thisType.Arguments [0]))  						throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  				}  				else {  					// *Case 1* Morally we deref the argument pointer and box the contents'  					// but since no supertype of a value type may mutate the underlying value'  					// we don't need to take a copy of the value when boxing' so in practice  					// this is a no-op  					if (!constrainedBox.IsAssignableTo (methEnv' thisType))  						throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  				}  			}  			else if (cs is ReferenceTypeStyle) {  				// *Case 2* We dereference the pointer and pass the object reference  				if (!methi.Constrained.IsAssignableTo (methEnv' thisType))  					throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  			}  			else if (cs is ParameterTypeStyle) {  				// Since we are calling an instance method' we know the first argument cannot be  				// a "naked" type parameter' but is either a class or an interface.  				// We must decide between cases 1 and 2 above at runtime' but checking as  				// per case 1 is sufficient now.  				// NOTE: As for box/classcast/isinst below' if the parameter is  				// instantiated to a reference type then the type box type is considered  				// equivalent to the underyling reference type.  				if (!constrainedBox.IsAssignableTo (methEnv' thisType))  					throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  			}  			else  				throw new InvalidOperationException ("constrained must be value' reference or parameter type");  			state.PeekExpectedType (sig.Parameters.Count - 1' constrainedPtr' changed);  		}  		else if (sig.Parameters.Count > 0)  			state.PeekExpectedType (sig.Parameters.Count - 1' sig.Parameters [0]' changed);  		if (sig.Result == null)  			return state.Pop (sig.Parameters.Count);  		else  			return state.PopPushType (sig.Parameters.Count' sig.Result' BottomPT);  	}  	case MethodOp.Ldftn: {  		// NOTE: Verified CLR allows only the two "blessed" sequences:  		//   dup; ldvirtftn; newobj <delegate ctor>  		//   ldftn; newobj <delegate ctor>  		// It is thus possible to check the delegate will capture an instance which  		// implements the loaded method. However' we don't check that here.  		if (methi.IsVirtual) {  			if (methi.Method.IsStatic)  				throw new InvalidOperationException ("cannot ldvirtftn of a static method");  			var objectType = default(TypeRef);  			if (sig.Parameters [0].Style (methEnv) is ManagedPointerTypeStyle)  				// Object should be a box  				objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (sig.Parameters [0].Arguments [0]);  			else  				// Object should match parameter  				objectType = sig.Parameters [0];  			state.PeekExpectedType (0' objectType' changed);  			return state.PopPushType (1' sig.WithoutThis ().ToCodePointer (methEnv.Global)' BottomPT);  		}  		else {  			if (methi.Method.IsStatic)  				return state.PushType (sig.ToCodePointer (methEnv.Global)' BottomPT);  			else  				return state.PushType (sig.WithoutThis ().ToCodePointer (methEnv.Global)' BottomPT);  		}  	}  	case MethodOp.Newobj: {  		if (methi.Method.IsStatic || sig.Result != null)  			throw new InvalidOperationException ("not a constructor");  		for (var i = sig.Parameters.Count - 1; i >= 1; i--)  			state.PeekExpectedType (sig.Parameters.Count - 1 - i' sig.Parameters [i]' changed);  		// First argument to constructor is created by runtime. If definining type is  		// a value type' first argument will be a pointer' but result left on stack  		// will be the value itself.  		return state.PopPushType (sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);  	}  	case MethodOp.Ldtoken:  		return state.PushType (global.RuntimeMethodHandleRef' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Type: {  	var typei = (TypeInstruction)instruction;  	switch (typei.Op) {  	case TypeOp.Ldobj:  		state.PeekReadPointerType (0' typei.Type);  		return state.PopPushType (1' typei.Type' BottomPT);  	case TypeOp.Stobj:  		state.PeekExpectedType (0' typei.Type' changed);  		state.PeekWritePointerType (1' typei.Type);  		return state.Pop (2);  	case TypeOp.Cpobj:  		state.PeekReadPointerType (0' typei.Type);  		state.PeekWritePointerType (1' typei.Type);  		return state.Pop (2);  	case TypeOp.Newarr:  		state.PeekIndexType (0);  		return state.PopPushType (1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo (typei.Type)' BottomPT);  	case TypeOp.Initobj:  		state.PeekWritePointerType (0' typei.Type);  		return state.Pop (1);  	case TypeOp.Castclass:  	case TypeOp.Isinst:  	case TypeOp.Box: {  		var resultType = default(TypeRef);  		var s = typei.Type.Style (methEnv);  		if (s is NullableTypeStyle)  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type.Arguments [0]);  		else if (s is ValueTypeStyle)  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type);  		else if (s is ReferenceTypeStyle)  			resultType = typei.Type;  		else if (s is ParameterTypeStyle)  			// NOTE: As for constrained call above' if type parameter is instantitated to  			// a ref type' then this box type is considered equivalent to the  			// underlying reference type.  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type);  		else  			throw new InvalidOperationException ("can only box/cast to reference' value or parameter type");  		if (typei.Op == TypeOp.Box)  			state.PeekExpectedType (0' typei.Type' changed);  		else  			state.PeekReferenceType (0);  		return state.PopPushType (1' resultType' BottomPT);  	}  	case TypeOp.Unbox:  		if (!(typei.Type.Style (methEnv) is ValueTypeStyle))  			// Parameter types are not allowed  			throw new InvalidOperationException ("type must be a value type");  		state.PeekBoxedType (0' typei.Type' changed);  		return state.PopPushType (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (typei.Type)' HeapPT);  	case TypeOp.UnboxAny: {  		var s = typei.Type.Style (methEnv);  		if (s is ValueTypeStyle)  			state.PeekBoxedType (0' typei.Type' changed);  		else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))  			throw new InvalidOperationException ("type must be value' reference or parameter type");  		return state.PopPushType (1' typei.Type' BottomPT);  	}  	case TypeOp.Ldtoken:  		return state.PushType (global.RuntimeTypeHandleRef' BottomPT);  	case TypeOp.Ldelem:  		state.PeekIndexType (0);  		state.PeekReadArrayType (1' typei.Type' false);  		return state.PopPushType (2' typei.Type' BottomPT);  	case TypeOp.Stelem:  		state.PeekExpectedType (0' typei.Type' changed);  		state.PeekIndexType (1);  		state.PeekWriteArrayType (2' typei.Type);  		return state.Pop (3);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.LdElemAddr: {  	var ldelemai = (LdElemAddrInstruction)instruction;  	state.PeekIndexType (0);  	// WARNING: May prematurely fail for non-readonly loads  	state.PeekReadArrayType (1' ldelemai.Type' !ldelemai.IsReadonly);  	return state.PopPushType (2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (ldelemai.Type)' HeapPT);  }  case InstructionFlavor.LdInt32:  	return state.PushType (global.Int32Ref' BottomPT);  case InstructionFlavor.LdInt64:  	return state.PushType (global.Int64Ref' BottomPT);  case InstructionFlavor.LdSingle:  	return state.PushType (global.DoubleRef' BottomPT);  case InstructionFlavor.LdDouble:  	return state.PushType (global.DoubleRef' BottomPT);  case InstructionFlavor.LdString:  	return state.PushType (global.StringRef' BottomPT);  case InstructionFlavor.Arith: {  	var arithi = (ArithInstruction)instruction;  	switch (arithi.Op) {  	case ArithOp.Add:  	case ArithOp.Sub:  	case ArithOp.Mul:  	case ArithOp.Div:  	case ArithOp.Rem:  		// NOTE: May capture skolemized types  		arithi.Type = state.Peek2NumberTypes (0' true);  		return state.PopPushType (2' arithi.Type' BottomPT);  	case ArithOp.Neg:  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (0' true);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (1' arithi.Type' BottomPT);  	case ArithOp.BitAnd:  	case ArithOp.BitOr:  	case ArithOp.BitXor:  		// NOTE: May capture skolemized types  		arithi.Type = state.Peek2NumberTypes (0' false);  		return state.PopPushType (2' arithi.Type' BottomPT);  	case ArithOp.BitNot:  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (0' false);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (1' arithi.Type' BottomPT);  	case ArithOp.Shl:  	case ArithOp.Shr:  		state.PeekExpectedType (0' global.Int32Ref' changed);  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (1' false);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (2' arithi.Type' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Conv: {  	var convi = (ConvInstruction)instruction;  	var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned && convi.TargetNumberFlavor == NumberFlavor.Double);  	// NOTE: May capture skolemized types  	convi.SourceType = state.PeekNumberType (0' !mustBeInteger);  	return state.PopPushType (1' TypeRef.NumberFrom (methEnv.Global' convi.TargetNumberFlavor)' BottomPT);  }  case InstructionFlavor.Try: {  	var tryi = (TryInstruction)instruction;  	// Isolation:  	//  - There is no way for the current stack shape to influence or be influenced by  	//    inference of the try' since the current stack shape must be empty.  	//  - There is no way for the try to influence the result stack shape' since it must be  	//    empty.  	//  - However pointers in arguments and locals may propogate into and out of try body  	//    via exceptional transitions. The latter are delt with separately.  	if (state.Depth != 0)  		throw new InvalidOperationException ("stack should be empty");  	var newState = ForwardBlock (new TryBodyInstructionContext (context' index' tryi.Body)' state' changed);  	for (var j = 0; j < tryi.Handlers.Count; j++) {  		var h = tryi.Handlers [j];  		var handlerContext = new TryHandlerInstructionContext (context' index' h.Body' j);  		var initHandlerState = new MachineState (methEnv' method.ValueParameters.Count' method.Locals.Count);  		switch (h.Flavor) {  		case HandlerFlavor.Catch: {  			var catchh = (CatchTryInstructionHandler)h;  			ForwardBlock (handlerContext' initHandlerState.PushType (catchh.Type' BottomPT)' changed);  			break;  		}  		case HandlerFlavor.Filter:  			throw new NotSupportedException ("filter handler blocks");  		case HandlerFlavor.Fault:  		case HandlerFlavor.Finally:  			ForwardBlock (handlerContext' initHandlerState' changed);  			break;  		default:  			throw new ArgumentOutOfRangeException ();  		}  	}  	return newState;  }  case InstructionFlavor.IfThenElsePseudo:  case InstructionFlavor.ShortCircuitingPseudo:  case InstructionFlavor.StructuralSwitchPseudo:  case InstructionFlavor.LoopPseudo:  case InstructionFlavor.WhileDoPseudo:  case InstructionFlavor.DoWhilePseudo:  case InstructionFlavor.LoopControlPseudo:  	throw new InvalidOperationException ("no machine state inference for psuedo-instructions");  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor) {  case InstructionFlavor.Unsupported:  	throw new InvalidOperationException ("unsupported opcode");  case InstructionFlavor.Misc: {  	var misci = (MiscInstruction)instruction;  	switch (misci.Op) {  	case MiscOp.Nop:  	case MiscOp.Break:  		return state;  	case MiscOp.Dup:  		return state.Push (state.Peek (0));  	case MiscOp.Pop:  		return state.Pop (1);  	case MiscOp.Ldnull:  		return state.PushType (global.NullRef' BottomPT);  	case MiscOp.Ckfinite:  		state.PeekExpectedType (0' global.DoubleRef' changed);  		// Assume the instruction can "peek" at top of stack' thus no need for pop/push.  		return state;  	case MiscOp.Throw:  		state.PeekReferenceType (0);  		return state.DiscardStack ();  	case MiscOp.Rethrow:  		return state.DiscardStack ();  	case MiscOp.LdindRef: {  		var elemType = state.PeekPointerToReferenceType (0);  		return state.PopPushType (1' elemType' BottomPT);  	}  	case MiscOp.StindRef: {  		var expElemType = state.PeekPointerToReferenceType (1);  		state.PeekExpectedType (0' expElemType' changed);  		return state.Pop (2);  	}  	case MiscOp.LdelemRef: {  		state.PeekIndexType (0);  		// WARNING: Type may not be final  		var elemType = state.PeekArrayOfReferenceType (1);  		return state.PopPushType (2' elemType' BottomPT);  	}  	case MiscOp.StelemRef:  		state.PeekReferenceType (0);  		state.PeekIndexType (1);  		state.PeekArrayOfReferenceType (2);  		// Since the value type and array element type may be independently generalized'  		// it is pointless to check that the first is assignable to the second.  		// Instead this check is done at runtime.  		return state.Pop (3);  	case MiscOp.Ldlen:  		state.PeekArrayOfAnyType (0);  		return state.PopPushType (1' global.IntNativeRef' BottomPT);  	case MiscOp.Ret: {  		if (state.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return state;  		// empty  	}  	case MiscOp.RetVal: {  		state.PeekExpectedType (0' method.Result.Type' changed);  		var newState = state.Pop (1);  		if (newState.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return newState;  		// empty  	}  	case MiscOp.Endfilter: {  		state.PeekExpectedType (0' global.Int32Ref' changed);  		var newState = state.Pop (1);  		if (newState.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return newState;  		// empty  	}  	case MiscOp.Endfinally: {  		// Control could transfer to an outer finally/fault block' or to the target  		// of a leave instruction. However these transitions are delt with separately.  		return state.DiscardStack ();  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Branch: {  	var bri = (BranchInstruction)instruction;  	switch (bri.Op) {  	case BranchOp.Br:  		UnifyBeforeState (state' bri.Target' changed);  		return state;  	case BranchOp.Brtrue: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.PeekIntegerOrObjectOrPointerType (0' false);  		var newState = state.Pop (1);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Brfalse: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.PeekIntegerOrObjectOrPointerType (0' true);  		var newState = state.Pop (1);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Breq:  	case BranchOp.Brne: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.Peek2ComparableTypes (0' true);  		var newState = state.Pop (2);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Leave: {  		// Control could transfer via finally blocks instead of directly to the leave target.  		// Propogate only that the stack must be empty at target. Remaining machine state  		// is dealt with separately.  		UnifyBeforeState (new MachineState (methEnv' method.ValueParameters.Count' method.Locals.Count)' bri.Target' changed);  		return state.DiscardStack ();  	}  	case BranchOp.BrLt:  	case BranchOp.BrLe:  	case BranchOp.BrGt:  	case BranchOp.BrGe: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.Peek2ComparableTypes (0' false);  		var newState = state.Pop (2);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Switch: {  	var switchi = (SwitchInstruction)instruction;  	state.PeekExpectedType (0' global.Int32Ref' changed);  	var newState = state.Pop (1);  	for (var i = 0; i < switchi.CaseTargets.Count; i++)  		UnifyBeforeState (newState' switchi.CaseTargets [i]' changed);  	return newState;  }  case InstructionFlavor.Compare: {  	var cmpi = (CompareInstruction)instruction;  	// WARNING: Capured type may not be final  	// NOTE: May capture skolemized types  	switch (cmpi.Op) {  	case CompareOp.Ceq:  	case CompareOp.CnePseudo:  		cmpi.Type = state.Peek2ComparableTypes (0' true);  		return state.PopPushType (2' global.Int32Ref' BottomPT);  	case CompareOp.Clt:  	case CompareOp.Cgt:  	case CompareOp.CgePseudo:  	case CompareOp.ClePseudo:  		cmpi.Type = state.Peek2ComparableTypes (0' false);  		return state.PopPushType (2' global.Int32Ref' BottomPT);  	case CompareOp.CtruePseudo:  	case CompareOp.CfalsePseudo:  		cmpi.Type = state.PeekIntegerOrObjectOrPointerType (0' true);  		return state.PopPushType (1' global.Int32Ref' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.ArgLocal: {  	var argi = (ArgLocalInstruction)instruction;  	var type = method.ArgLocalType (argi.ArgLocal' argi.Index);  	switch (argi.Op) {  	case ArgLocalOp.Ld:  		return state.PushType (type' state.ArgLocalPointsTo (argi.ArgLocal' argi.Index));  	case ArgLocalOp.Lda:  		return state.PushType (methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (type)' ArgLocalPT (argi.ArgLocal' argi.Index));  	case ArgLocalOp.St: {  		state.PeekExpectedType (0' type' changed);  		var pointsTo = state.PeekPointsTo (0);  		if (!pointsTo.IsBottom) {  			if (!(type.Style (methEnv) is ManagedPointerTypeStyle))  				throw new InvalidOperationException ("stack indicates pointer' but parameter or local type does not");  			if (pointsTo.PointsOutsideOfHeap)  				throw new InvalidOperationException ("arguments cannot point outside of the heap");  		}  		return state.PopAddArgLocalPointsTo (1' argi.ArgLocal' argi.Index' pointsTo);  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Field: {  	var fieldi = (FieldInstruction)instruction;  	var fieldEnv = fieldi.Field.Enter (methEnv);  	var fieldType = fieldEnv.SubstituteType (fieldEnv.Field.FieldType);  	switch (fieldi.Op) {  	case FieldOp.Ldfld:  		if (fieldi.IsStatic)  			return state.PushType (fieldType' BottomPT);  		else {  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (0' fieldi.Field.DefiningType' true' changed);  			return state.PopPushType (1' fieldType' BottomPT);  		}  	case FieldOp.Ldflda:  		if (fieldi.IsStatic)  			return state.PushType (methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (fieldType)' HeapPT);  		else {  			// Underlying type cannot be a struct' otherwise would have a pointer into  			// the stack  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (0' fieldi.Field.DefiningType' false' changed);  			return state.PopPushType (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (fieldType)' HeapPT);  		}  	case FieldOp.Stfld:  		if (fieldi.IsStatic) {  			state.PeekExpectedType (0' fieldType' changed);  			return state.Pop (1);  		}  		else {  			state.PeekExpectedType (0' fieldType' changed);  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (1' fieldi.Field.DefiningType' false' changed);  			return state.Pop (2);  		}  	case FieldOp.Ldtoken:  		return state.PushType (global.RuntimeFieldHandleRef' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Method: {  	var methi = (MethodInstruction)instruction;  	var sig = (CST.MethodSignature)methi.Method.ExternalSignature;  	switch (methi.Op) {  	case MethodOp.Call: {  		for (var i = sig.Parameters.Count - 1; i >= 1; i--)  			state.PeekExpectedType (sig.Parameters.Count - 1 - i' sig.Parameters [i]' changed);  		if (methi.Constrained != null) {  			if (!methi.IsVirtual || methi.Method.IsStatic)  				throw new InvalidOperationException ("constrained only valid on virtual calls to instance methods");  			var thisType = sig.Parameters [0];  			var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (methi.Constrained);  			var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo (methi.Constrained);  			var cs = methi.Constrained.Style (methEnv);  			if (cs is ValueTypeStyle) {  				if (thisType.Style (methEnv) is ManagedPointerTypeStyle) {  					// We pass the argument pointer as is  					if (!methi.Constrained.IsAssignableTo (methEnv' thisType.Arguments [0]))  						throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  				}  				else {  					// *Case 1* Morally we deref the argument pointer and box the contents'  					// but since no supertype of a value type may mutate the underlying value'  					// we don't need to take a copy of the value when boxing' so in practice  					// this is a no-op  					if (!constrainedBox.IsAssignableTo (methEnv' thisType))  						throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  				}  			}  			else if (cs is ReferenceTypeStyle) {  				// *Case 2* We dereference the pointer and pass the object reference  				if (!methi.Constrained.IsAssignableTo (methEnv' thisType))  					throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  			}  			else if (cs is ParameterTypeStyle) {  				// Since we are calling an instance method' we know the first argument cannot be  				// a "naked" type parameter' but is either a class or an interface.  				// We must decide between cases 1 and 2 above at runtime' but checking as  				// per case 1 is sufficient now.  				// NOTE: As for box/classcast/isinst below' if the parameter is  				// instantiated to a reference type then the type box type is considered  				// equivalent to the underyling reference type.  				if (!constrainedBox.IsAssignableTo (methEnv' thisType))  					throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  			}  			else  				throw new InvalidOperationException ("constrained must be value' reference or parameter type");  			state.PeekExpectedType (sig.Parameters.Count - 1' constrainedPtr' changed);  		}  		else if (sig.Parameters.Count > 0)  			state.PeekExpectedType (sig.Parameters.Count - 1' sig.Parameters [0]' changed);  		if (sig.Result == null)  			return state.Pop (sig.Parameters.Count);  		else  			return state.PopPushType (sig.Parameters.Count' sig.Result' BottomPT);  	}  	case MethodOp.Ldftn: {  		// NOTE: Verified CLR allows only the two "blessed" sequences:  		//   dup; ldvirtftn; newobj <delegate ctor>  		//   ldftn; newobj <delegate ctor>  		// It is thus possible to check the delegate will capture an instance which  		// implements the loaded method. However' we don't check that here.  		if (methi.IsVirtual) {  			if (methi.Method.IsStatic)  				throw new InvalidOperationException ("cannot ldvirtftn of a static method");  			var objectType = default(TypeRef);  			if (sig.Parameters [0].Style (methEnv) is ManagedPointerTypeStyle)  				// Object should be a box  				objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (sig.Parameters [0].Arguments [0]);  			else  				// Object should match parameter  				objectType = sig.Parameters [0];  			state.PeekExpectedType (0' objectType' changed);  			return state.PopPushType (1' sig.WithoutThis ().ToCodePointer (methEnv.Global)' BottomPT);  		}  		else {  			if (methi.Method.IsStatic)  				return state.PushType (sig.ToCodePointer (methEnv.Global)' BottomPT);  			else  				return state.PushType (sig.WithoutThis ().ToCodePointer (methEnv.Global)' BottomPT);  		}  	}  	case MethodOp.Newobj: {  		if (methi.Method.IsStatic || sig.Result != null)  			throw new InvalidOperationException ("not a constructor");  		for (var i = sig.Parameters.Count - 1; i >= 1; i--)  			state.PeekExpectedType (sig.Parameters.Count - 1 - i' sig.Parameters [i]' changed);  		// First argument to constructor is created by runtime. If definining type is  		// a value type' first argument will be a pointer' but result left on stack  		// will be the value itself.  		return state.PopPushType (sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);  	}  	case MethodOp.Ldtoken:  		return state.PushType (global.RuntimeMethodHandleRef' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Type: {  	var typei = (TypeInstruction)instruction;  	switch (typei.Op) {  	case TypeOp.Ldobj:  		state.PeekReadPointerType (0' typei.Type);  		return state.PopPushType (1' typei.Type' BottomPT);  	case TypeOp.Stobj:  		state.PeekExpectedType (0' typei.Type' changed);  		state.PeekWritePointerType (1' typei.Type);  		return state.Pop (2);  	case TypeOp.Cpobj:  		state.PeekReadPointerType (0' typei.Type);  		state.PeekWritePointerType (1' typei.Type);  		return state.Pop (2);  	case TypeOp.Newarr:  		state.PeekIndexType (0);  		return state.PopPushType (1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo (typei.Type)' BottomPT);  	case TypeOp.Initobj:  		state.PeekWritePointerType (0' typei.Type);  		return state.Pop (1);  	case TypeOp.Castclass:  	case TypeOp.Isinst:  	case TypeOp.Box: {  		var resultType = default(TypeRef);  		var s = typei.Type.Style (methEnv);  		if (s is NullableTypeStyle)  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type.Arguments [0]);  		else if (s is ValueTypeStyle)  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type);  		else if (s is ReferenceTypeStyle)  			resultType = typei.Type;  		else if (s is ParameterTypeStyle)  			// NOTE: As for constrained call above' if type parameter is instantitated to  			// a ref type' then this box type is considered equivalent to the  			// underlying reference type.  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type);  		else  			throw new InvalidOperationException ("can only box/cast to reference' value or parameter type");  		if (typei.Op == TypeOp.Box)  			state.PeekExpectedType (0' typei.Type' changed);  		else  			state.PeekReferenceType (0);  		return state.PopPushType (1' resultType' BottomPT);  	}  	case TypeOp.Unbox:  		if (!(typei.Type.Style (methEnv) is ValueTypeStyle))  			// Parameter types are not allowed  			throw new InvalidOperationException ("type must be a value type");  		state.PeekBoxedType (0' typei.Type' changed);  		return state.PopPushType (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (typei.Type)' HeapPT);  	case TypeOp.UnboxAny: {  		var s = typei.Type.Style (methEnv);  		if (s is ValueTypeStyle)  			state.PeekBoxedType (0' typei.Type' changed);  		else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))  			throw new InvalidOperationException ("type must be value' reference or parameter type");  		return state.PopPushType (1' typei.Type' BottomPT);  	}  	case TypeOp.Ldtoken:  		return state.PushType (global.RuntimeTypeHandleRef' BottomPT);  	case TypeOp.Ldelem:  		state.PeekIndexType (0);  		state.PeekReadArrayType (1' typei.Type' false);  		return state.PopPushType (2' typei.Type' BottomPT);  	case TypeOp.Stelem:  		state.PeekExpectedType (0' typei.Type' changed);  		state.PeekIndexType (1);  		state.PeekWriteArrayType (2' typei.Type);  		return state.Pop (3);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.LdElemAddr: {  	var ldelemai = (LdElemAddrInstruction)instruction;  	state.PeekIndexType (0);  	// WARNING: May prematurely fail for non-readonly loads  	state.PeekReadArrayType (1' ldelemai.Type' !ldelemai.IsReadonly);  	return state.PopPushType (2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (ldelemai.Type)' HeapPT);  }  case InstructionFlavor.LdInt32:  	return state.PushType (global.Int32Ref' BottomPT);  case InstructionFlavor.LdInt64:  	return state.PushType (global.Int64Ref' BottomPT);  case InstructionFlavor.LdSingle:  	return state.PushType (global.DoubleRef' BottomPT);  case InstructionFlavor.LdDouble:  	return state.PushType (global.DoubleRef' BottomPT);  case InstructionFlavor.LdString:  	return state.PushType (global.StringRef' BottomPT);  case InstructionFlavor.Arith: {  	var arithi = (ArithInstruction)instruction;  	switch (arithi.Op) {  	case ArithOp.Add:  	case ArithOp.Sub:  	case ArithOp.Mul:  	case ArithOp.Div:  	case ArithOp.Rem:  		// NOTE: May capture skolemized types  		arithi.Type = state.Peek2NumberTypes (0' true);  		return state.PopPushType (2' arithi.Type' BottomPT);  	case ArithOp.Neg:  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (0' true);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (1' arithi.Type' BottomPT);  	case ArithOp.BitAnd:  	case ArithOp.BitOr:  	case ArithOp.BitXor:  		// NOTE: May capture skolemized types  		arithi.Type = state.Peek2NumberTypes (0' false);  		return state.PopPushType (2' arithi.Type' BottomPT);  	case ArithOp.BitNot:  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (0' false);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (1' arithi.Type' BottomPT);  	case ArithOp.Shl:  	case ArithOp.Shr:  		state.PeekExpectedType (0' global.Int32Ref' changed);  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (1' false);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (2' arithi.Type' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Conv: {  	var convi = (ConvInstruction)instruction;  	var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned && convi.TargetNumberFlavor == NumberFlavor.Double);  	// NOTE: May capture skolemized types  	convi.SourceType = state.PeekNumberType (0' !mustBeInteger);  	return state.PopPushType (1' TypeRef.NumberFrom (methEnv.Global' convi.TargetNumberFlavor)' BottomPT);  }  case InstructionFlavor.Try: {  	var tryi = (TryInstruction)instruction;  	// Isolation:  	//  - There is no way for the current stack shape to influence or be influenced by  	//    inference of the try' since the current stack shape must be empty.  	//  - There is no way for the try to influence the result stack shape' since it must be  	//    empty.  	//  - However pointers in arguments and locals may propogate into and out of try body  	//    via exceptional transitions. The latter are delt with separately.  	if (state.Depth != 0)  		throw new InvalidOperationException ("stack should be empty");  	var newState = ForwardBlock (new TryBodyInstructionContext (context' index' tryi.Body)' state' changed);  	for (var j = 0; j < tryi.Handlers.Count; j++) {  		var h = tryi.Handlers [j];  		var handlerContext = new TryHandlerInstructionContext (context' index' h.Body' j);  		var initHandlerState = new MachineState (methEnv' method.ValueParameters.Count' method.Locals.Count);  		switch (h.Flavor) {  		case HandlerFlavor.Catch: {  			var catchh = (CatchTryInstructionHandler)h;  			ForwardBlock (handlerContext' initHandlerState.PushType (catchh.Type' BottomPT)' changed);  			break;  		}  		case HandlerFlavor.Filter:  			throw new NotSupportedException ("filter handler blocks");  		case HandlerFlavor.Fault:  		case HandlerFlavor.Finally:  			ForwardBlock (handlerContext' initHandlerState' changed);  			break;  		default:  			throw new ArgumentOutOfRangeException ();  		}  	}  	return newState;  }  case InstructionFlavor.IfThenElsePseudo:  case InstructionFlavor.ShortCircuitingPseudo:  case InstructionFlavor.StructuralSwitchPseudo:  case InstructionFlavor.LoopPseudo:  case InstructionFlavor.WhileDoPseudo:  case InstructionFlavor.DoWhilePseudo:  case InstructionFlavor.LoopControlPseudo:  	throw new InvalidOperationException ("no machine state inference for psuedo-instructions");  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor) {  case InstructionFlavor.Unsupported:  	throw new InvalidOperationException ("unsupported opcode");  case InstructionFlavor.Misc: {  	var misci = (MiscInstruction)instruction;  	switch (misci.Op) {  	case MiscOp.Nop:  	case MiscOp.Break:  		return state;  	case MiscOp.Dup:  		return state.Push (state.Peek (0));  	case MiscOp.Pop:  		return state.Pop (1);  	case MiscOp.Ldnull:  		return state.PushType (global.NullRef' BottomPT);  	case MiscOp.Ckfinite:  		state.PeekExpectedType (0' global.DoubleRef' changed);  		// Assume the instruction can "peek" at top of stack' thus no need for pop/push.  		return state;  	case MiscOp.Throw:  		state.PeekReferenceType (0);  		return state.DiscardStack ();  	case MiscOp.Rethrow:  		return state.DiscardStack ();  	case MiscOp.LdindRef: {  		var elemType = state.PeekPointerToReferenceType (0);  		return state.PopPushType (1' elemType' BottomPT);  	}  	case MiscOp.StindRef: {  		var expElemType = state.PeekPointerToReferenceType (1);  		state.PeekExpectedType (0' expElemType' changed);  		return state.Pop (2);  	}  	case MiscOp.LdelemRef: {  		state.PeekIndexType (0);  		// WARNING: Type may not be final  		var elemType = state.PeekArrayOfReferenceType (1);  		return state.PopPushType (2' elemType' BottomPT);  	}  	case MiscOp.StelemRef:  		state.PeekReferenceType (0);  		state.PeekIndexType (1);  		state.PeekArrayOfReferenceType (2);  		// Since the value type and array element type may be independently generalized'  		// it is pointless to check that the first is assignable to the second.  		// Instead this check is done at runtime.  		return state.Pop (3);  	case MiscOp.Ldlen:  		state.PeekArrayOfAnyType (0);  		return state.PopPushType (1' global.IntNativeRef' BottomPT);  	case MiscOp.Ret: {  		if (state.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return state;  		// empty  	}  	case MiscOp.RetVal: {  		state.PeekExpectedType (0' method.Result.Type' changed);  		var newState = state.Pop (1);  		if (newState.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return newState;  		// empty  	}  	case MiscOp.Endfilter: {  		state.PeekExpectedType (0' global.Int32Ref' changed);  		var newState = state.Pop (1);  		if (newState.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return newState;  		// empty  	}  	case MiscOp.Endfinally: {  		// Control could transfer to an outer finally/fault block' or to the target  		// of a leave instruction. However these transitions are delt with separately.  		return state.DiscardStack ();  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Branch: {  	var bri = (BranchInstruction)instruction;  	switch (bri.Op) {  	case BranchOp.Br:  		UnifyBeforeState (state' bri.Target' changed);  		return state;  	case BranchOp.Brtrue: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.PeekIntegerOrObjectOrPointerType (0' false);  		var newState = state.Pop (1);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Brfalse: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.PeekIntegerOrObjectOrPointerType (0' true);  		var newState = state.Pop (1);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Breq:  	case BranchOp.Brne: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.Peek2ComparableTypes (0' true);  		var newState = state.Pop (2);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Leave: {  		// Control could transfer via finally blocks instead of directly to the leave target.  		// Propogate only that the stack must be empty at target. Remaining machine state  		// is dealt with separately.  		UnifyBeforeState (new MachineState (methEnv' method.ValueParameters.Count' method.Locals.Count)' bri.Target' changed);  		return state.DiscardStack ();  	}  	case BranchOp.BrLt:  	case BranchOp.BrLe:  	case BranchOp.BrGt:  	case BranchOp.BrGe: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.Peek2ComparableTypes (0' false);  		var newState = state.Pop (2);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Switch: {  	var switchi = (SwitchInstruction)instruction;  	state.PeekExpectedType (0' global.Int32Ref' changed);  	var newState = state.Pop (1);  	for (var i = 0; i < switchi.CaseTargets.Count; i++)  		UnifyBeforeState (newState' switchi.CaseTargets [i]' changed);  	return newState;  }  case InstructionFlavor.Compare: {  	var cmpi = (CompareInstruction)instruction;  	// WARNING: Capured type may not be final  	// NOTE: May capture skolemized types  	switch (cmpi.Op) {  	case CompareOp.Ceq:  	case CompareOp.CnePseudo:  		cmpi.Type = state.Peek2ComparableTypes (0' true);  		return state.PopPushType (2' global.Int32Ref' BottomPT);  	case CompareOp.Clt:  	case CompareOp.Cgt:  	case CompareOp.CgePseudo:  	case CompareOp.ClePseudo:  		cmpi.Type = state.Peek2ComparableTypes (0' false);  		return state.PopPushType (2' global.Int32Ref' BottomPT);  	case CompareOp.CtruePseudo:  	case CompareOp.CfalsePseudo:  		cmpi.Type = state.PeekIntegerOrObjectOrPointerType (0' true);  		return state.PopPushType (1' global.Int32Ref' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.ArgLocal: {  	var argi = (ArgLocalInstruction)instruction;  	var type = method.ArgLocalType (argi.ArgLocal' argi.Index);  	switch (argi.Op) {  	case ArgLocalOp.Ld:  		return state.PushType (type' state.ArgLocalPointsTo (argi.ArgLocal' argi.Index));  	case ArgLocalOp.Lda:  		return state.PushType (methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (type)' ArgLocalPT (argi.ArgLocal' argi.Index));  	case ArgLocalOp.St: {  		state.PeekExpectedType (0' type' changed);  		var pointsTo = state.PeekPointsTo (0);  		if (!pointsTo.IsBottom) {  			if (!(type.Style (methEnv) is ManagedPointerTypeStyle))  				throw new InvalidOperationException ("stack indicates pointer' but parameter or local type does not");  			if (pointsTo.PointsOutsideOfHeap)  				throw new InvalidOperationException ("arguments cannot point outside of the heap");  		}  		return state.PopAddArgLocalPointsTo (1' argi.ArgLocal' argi.Index' pointsTo);  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Field: {  	var fieldi = (FieldInstruction)instruction;  	var fieldEnv = fieldi.Field.Enter (methEnv);  	var fieldType = fieldEnv.SubstituteType (fieldEnv.Field.FieldType);  	switch (fieldi.Op) {  	case FieldOp.Ldfld:  		if (fieldi.IsStatic)  			return state.PushType (fieldType' BottomPT);  		else {  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (0' fieldi.Field.DefiningType' true' changed);  			return state.PopPushType (1' fieldType' BottomPT);  		}  	case FieldOp.Ldflda:  		if (fieldi.IsStatic)  			return state.PushType (methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (fieldType)' HeapPT);  		else {  			// Underlying type cannot be a struct' otherwise would have a pointer into  			// the stack  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (0' fieldi.Field.DefiningType' false' changed);  			return state.PopPushType (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (fieldType)' HeapPT);  		}  	case FieldOp.Stfld:  		if (fieldi.IsStatic) {  			state.PeekExpectedType (0' fieldType' changed);  			return state.Pop (1);  		}  		else {  			state.PeekExpectedType (0' fieldType' changed);  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (1' fieldi.Field.DefiningType' false' changed);  			return state.Pop (2);  		}  	case FieldOp.Ldtoken:  		return state.PushType (global.RuntimeFieldHandleRef' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Method: {  	var methi = (MethodInstruction)instruction;  	var sig = (CST.MethodSignature)methi.Method.ExternalSignature;  	switch (methi.Op) {  	case MethodOp.Call: {  		for (var i = sig.Parameters.Count - 1; i >= 1; i--)  			state.PeekExpectedType (sig.Parameters.Count - 1 - i' sig.Parameters [i]' changed);  		if (methi.Constrained != null) {  			if (!methi.IsVirtual || methi.Method.IsStatic)  				throw new InvalidOperationException ("constrained only valid on virtual calls to instance methods");  			var thisType = sig.Parameters [0];  			var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (methi.Constrained);  			var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo (methi.Constrained);  			var cs = methi.Constrained.Style (methEnv);  			if (cs is ValueTypeStyle) {  				if (thisType.Style (methEnv) is ManagedPointerTypeStyle) {  					// We pass the argument pointer as is  					if (!methi.Constrained.IsAssignableTo (methEnv' thisType.Arguments [0]))  						throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  				}  				else {  					// *Case 1* Morally we deref the argument pointer and box the contents'  					// but since no supertype of a value type may mutate the underlying value'  					// we don't need to take a copy of the value when boxing' so in practice  					// this is a no-op  					if (!constrainedBox.IsAssignableTo (methEnv' thisType))  						throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  				}  			}  			else if (cs is ReferenceTypeStyle) {  				// *Case 2* We dereference the pointer and pass the object reference  				if (!methi.Constrained.IsAssignableTo (methEnv' thisType))  					throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  			}  			else if (cs is ParameterTypeStyle) {  				// Since we are calling an instance method' we know the first argument cannot be  				// a "naked" type parameter' but is either a class or an interface.  				// We must decide between cases 1 and 2 above at runtime' but checking as  				// per case 1 is sufficient now.  				// NOTE: As for box/classcast/isinst below' if the parameter is  				// instantiated to a reference type then the type box type is considered  				// equivalent to the underyling reference type.  				if (!constrainedBox.IsAssignableTo (methEnv' thisType))  					throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  			}  			else  				throw new InvalidOperationException ("constrained must be value' reference or parameter type");  			state.PeekExpectedType (sig.Parameters.Count - 1' constrainedPtr' changed);  		}  		else if (sig.Parameters.Count > 0)  			state.PeekExpectedType (sig.Parameters.Count - 1' sig.Parameters [0]' changed);  		if (sig.Result == null)  			return state.Pop (sig.Parameters.Count);  		else  			return state.PopPushType (sig.Parameters.Count' sig.Result' BottomPT);  	}  	case MethodOp.Ldftn: {  		// NOTE: Verified CLR allows only the two "blessed" sequences:  		//   dup; ldvirtftn; newobj <delegate ctor>  		//   ldftn; newobj <delegate ctor>  		// It is thus possible to check the delegate will capture an instance which  		// implements the loaded method. However' we don't check that here.  		if (methi.IsVirtual) {  			if (methi.Method.IsStatic)  				throw new InvalidOperationException ("cannot ldvirtftn of a static method");  			var objectType = default(TypeRef);  			if (sig.Parameters [0].Style (methEnv) is ManagedPointerTypeStyle)  				// Object should be a box  				objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (sig.Parameters [0].Arguments [0]);  			else  				// Object should match parameter  				objectType = sig.Parameters [0];  			state.PeekExpectedType (0' objectType' changed);  			return state.PopPushType (1' sig.WithoutThis ().ToCodePointer (methEnv.Global)' BottomPT);  		}  		else {  			if (methi.Method.IsStatic)  				return state.PushType (sig.ToCodePointer (methEnv.Global)' BottomPT);  			else  				return state.PushType (sig.WithoutThis ().ToCodePointer (methEnv.Global)' BottomPT);  		}  	}  	case MethodOp.Newobj: {  		if (methi.Method.IsStatic || sig.Result != null)  			throw new InvalidOperationException ("not a constructor");  		for (var i = sig.Parameters.Count - 1; i >= 1; i--)  			state.PeekExpectedType (sig.Parameters.Count - 1 - i' sig.Parameters [i]' changed);  		// First argument to constructor is created by runtime. If definining type is  		// a value type' first argument will be a pointer' but result left on stack  		// will be the value itself.  		return state.PopPushType (sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);  	}  	case MethodOp.Ldtoken:  		return state.PushType (global.RuntimeMethodHandleRef' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Type: {  	var typei = (TypeInstruction)instruction;  	switch (typei.Op) {  	case TypeOp.Ldobj:  		state.PeekReadPointerType (0' typei.Type);  		return state.PopPushType (1' typei.Type' BottomPT);  	case TypeOp.Stobj:  		state.PeekExpectedType (0' typei.Type' changed);  		state.PeekWritePointerType (1' typei.Type);  		return state.Pop (2);  	case TypeOp.Cpobj:  		state.PeekReadPointerType (0' typei.Type);  		state.PeekWritePointerType (1' typei.Type);  		return state.Pop (2);  	case TypeOp.Newarr:  		state.PeekIndexType (0);  		return state.PopPushType (1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo (typei.Type)' BottomPT);  	case TypeOp.Initobj:  		state.PeekWritePointerType (0' typei.Type);  		return state.Pop (1);  	case TypeOp.Castclass:  	case TypeOp.Isinst:  	case TypeOp.Box: {  		var resultType = default(TypeRef);  		var s = typei.Type.Style (methEnv);  		if (s is NullableTypeStyle)  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type.Arguments [0]);  		else if (s is ValueTypeStyle)  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type);  		else if (s is ReferenceTypeStyle)  			resultType = typei.Type;  		else if (s is ParameterTypeStyle)  			// NOTE: As for constrained call above' if type parameter is instantitated to  			// a ref type' then this box type is considered equivalent to the  			// underlying reference type.  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type);  		else  			throw new InvalidOperationException ("can only box/cast to reference' value or parameter type");  		if (typei.Op == TypeOp.Box)  			state.PeekExpectedType (0' typei.Type' changed);  		else  			state.PeekReferenceType (0);  		return state.PopPushType (1' resultType' BottomPT);  	}  	case TypeOp.Unbox:  		if (!(typei.Type.Style (methEnv) is ValueTypeStyle))  			// Parameter types are not allowed  			throw new InvalidOperationException ("type must be a value type");  		state.PeekBoxedType (0' typei.Type' changed);  		return state.PopPushType (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (typei.Type)' HeapPT);  	case TypeOp.UnboxAny: {  		var s = typei.Type.Style (methEnv);  		if (s is ValueTypeStyle)  			state.PeekBoxedType (0' typei.Type' changed);  		else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))  			throw new InvalidOperationException ("type must be value' reference or parameter type");  		return state.PopPushType (1' typei.Type' BottomPT);  	}  	case TypeOp.Ldtoken:  		return state.PushType (global.RuntimeTypeHandleRef' BottomPT);  	case TypeOp.Ldelem:  		state.PeekIndexType (0);  		state.PeekReadArrayType (1' typei.Type' false);  		return state.PopPushType (2' typei.Type' BottomPT);  	case TypeOp.Stelem:  		state.PeekExpectedType (0' typei.Type' changed);  		state.PeekIndexType (1);  		state.PeekWriteArrayType (2' typei.Type);  		return state.Pop (3);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.LdElemAddr: {  	var ldelemai = (LdElemAddrInstruction)instruction;  	state.PeekIndexType (0);  	// WARNING: May prematurely fail for non-readonly loads  	state.PeekReadArrayType (1' ldelemai.Type' !ldelemai.IsReadonly);  	return state.PopPushType (2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (ldelemai.Type)' HeapPT);  }  case InstructionFlavor.LdInt32:  	return state.PushType (global.Int32Ref' BottomPT);  case InstructionFlavor.LdInt64:  	return state.PushType (global.Int64Ref' BottomPT);  case InstructionFlavor.LdSingle:  	return state.PushType (global.DoubleRef' BottomPT);  case InstructionFlavor.LdDouble:  	return state.PushType (global.DoubleRef' BottomPT);  case InstructionFlavor.LdString:  	return state.PushType (global.StringRef' BottomPT);  case InstructionFlavor.Arith: {  	var arithi = (ArithInstruction)instruction;  	switch (arithi.Op) {  	case ArithOp.Add:  	case ArithOp.Sub:  	case ArithOp.Mul:  	case ArithOp.Div:  	case ArithOp.Rem:  		// NOTE: May capture skolemized types  		arithi.Type = state.Peek2NumberTypes (0' true);  		return state.PopPushType (2' arithi.Type' BottomPT);  	case ArithOp.Neg:  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (0' true);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (1' arithi.Type' BottomPT);  	case ArithOp.BitAnd:  	case ArithOp.BitOr:  	case ArithOp.BitXor:  		// NOTE: May capture skolemized types  		arithi.Type = state.Peek2NumberTypes (0' false);  		return state.PopPushType (2' arithi.Type' BottomPT);  	case ArithOp.BitNot:  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (0' false);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (1' arithi.Type' BottomPT);  	case ArithOp.Shl:  	case ArithOp.Shr:  		state.PeekExpectedType (0' global.Int32Ref' changed);  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (1' false);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (2' arithi.Type' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Conv: {  	var convi = (ConvInstruction)instruction;  	var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned && convi.TargetNumberFlavor == NumberFlavor.Double);  	// NOTE: May capture skolemized types  	convi.SourceType = state.PeekNumberType (0' !mustBeInteger);  	return state.PopPushType (1' TypeRef.NumberFrom (methEnv.Global' convi.TargetNumberFlavor)' BottomPT);  }  case InstructionFlavor.Try: {  	var tryi = (TryInstruction)instruction;  	// Isolation:  	//  - There is no way for the current stack shape to influence or be influenced by  	//    inference of the try' since the current stack shape must be empty.  	//  - There is no way for the try to influence the result stack shape' since it must be  	//    empty.  	//  - However pointers in arguments and locals may propogate into and out of try body  	//    via exceptional transitions. The latter are delt with separately.  	if (state.Depth != 0)  		throw new InvalidOperationException ("stack should be empty");  	var newState = ForwardBlock (new TryBodyInstructionContext (context' index' tryi.Body)' state' changed);  	for (var j = 0; j < tryi.Handlers.Count; j++) {  		var h = tryi.Handlers [j];  		var handlerContext = new TryHandlerInstructionContext (context' index' h.Body' j);  		var initHandlerState = new MachineState (methEnv' method.ValueParameters.Count' method.Locals.Count);  		switch (h.Flavor) {  		case HandlerFlavor.Catch: {  			var catchh = (CatchTryInstructionHandler)h;  			ForwardBlock (handlerContext' initHandlerState.PushType (catchh.Type' BottomPT)' changed);  			break;  		}  		case HandlerFlavor.Filter:  			throw new NotSupportedException ("filter handler blocks");  		case HandlerFlavor.Fault:  		case HandlerFlavor.Finally:  			ForwardBlock (handlerContext' initHandlerState' changed);  			break;  		default:  			throw new ArgumentOutOfRangeException ();  		}  	}  	return newState;  }  case InstructionFlavor.IfThenElsePseudo:  case InstructionFlavor.ShortCircuitingPseudo:  case InstructionFlavor.StructuralSwitchPseudo:  case InstructionFlavor.LoopPseudo:  case InstructionFlavor.WhileDoPseudo:  case InstructionFlavor.DoWhilePseudo:  case InstructionFlavor.LoopControlPseudo:  	throw new InvalidOperationException ("no machine state inference for psuedo-instructions");  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor) {  case InstructionFlavor.Unsupported:  	throw new InvalidOperationException ("unsupported opcode");  case InstructionFlavor.Misc: {  	var misci = (MiscInstruction)instruction;  	switch (misci.Op) {  	case MiscOp.Nop:  	case MiscOp.Break:  		return state;  	case MiscOp.Dup:  		return state.Push (state.Peek (0));  	case MiscOp.Pop:  		return state.Pop (1);  	case MiscOp.Ldnull:  		return state.PushType (global.NullRef' BottomPT);  	case MiscOp.Ckfinite:  		state.PeekExpectedType (0' global.DoubleRef' changed);  		// Assume the instruction can "peek" at top of stack' thus no need for pop/push.  		return state;  	case MiscOp.Throw:  		state.PeekReferenceType (0);  		return state.DiscardStack ();  	case MiscOp.Rethrow:  		return state.DiscardStack ();  	case MiscOp.LdindRef: {  		var elemType = state.PeekPointerToReferenceType (0);  		return state.PopPushType (1' elemType' BottomPT);  	}  	case MiscOp.StindRef: {  		var expElemType = state.PeekPointerToReferenceType (1);  		state.PeekExpectedType (0' expElemType' changed);  		return state.Pop (2);  	}  	case MiscOp.LdelemRef: {  		state.PeekIndexType (0);  		// WARNING: Type may not be final  		var elemType = state.PeekArrayOfReferenceType (1);  		return state.PopPushType (2' elemType' BottomPT);  	}  	case MiscOp.StelemRef:  		state.PeekReferenceType (0);  		state.PeekIndexType (1);  		state.PeekArrayOfReferenceType (2);  		// Since the value type and array element type may be independently generalized'  		// it is pointless to check that the first is assignable to the second.  		// Instead this check is done at runtime.  		return state.Pop (3);  	case MiscOp.Ldlen:  		state.PeekArrayOfAnyType (0);  		return state.PopPushType (1' global.IntNativeRef' BottomPT);  	case MiscOp.Ret: {  		if (state.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return state;  		// empty  	}  	case MiscOp.RetVal: {  		state.PeekExpectedType (0' method.Result.Type' changed);  		var newState = state.Pop (1);  		if (newState.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return newState;  		// empty  	}  	case MiscOp.Endfilter: {  		state.PeekExpectedType (0' global.Int32Ref' changed);  		var newState = state.Pop (1);  		if (newState.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return newState;  		// empty  	}  	case MiscOp.Endfinally: {  		// Control could transfer to an outer finally/fault block' or to the target  		// of a leave instruction. However these transitions are delt with separately.  		return state.DiscardStack ();  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Branch: {  	var bri = (BranchInstruction)instruction;  	switch (bri.Op) {  	case BranchOp.Br:  		UnifyBeforeState (state' bri.Target' changed);  		return state;  	case BranchOp.Brtrue: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.PeekIntegerOrObjectOrPointerType (0' false);  		var newState = state.Pop (1);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Brfalse: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.PeekIntegerOrObjectOrPointerType (0' true);  		var newState = state.Pop (1);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Breq:  	case BranchOp.Brne: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.Peek2ComparableTypes (0' true);  		var newState = state.Pop (2);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Leave: {  		// Control could transfer via finally blocks instead of directly to the leave target.  		// Propogate only that the stack must be empty at target. Remaining machine state  		// is dealt with separately.  		UnifyBeforeState (new MachineState (methEnv' method.ValueParameters.Count' method.Locals.Count)' bri.Target' changed);  		return state.DiscardStack ();  	}  	case BranchOp.BrLt:  	case BranchOp.BrLe:  	case BranchOp.BrGt:  	case BranchOp.BrGe: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.Peek2ComparableTypes (0' false);  		var newState = state.Pop (2);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Switch: {  	var switchi = (SwitchInstruction)instruction;  	state.PeekExpectedType (0' global.Int32Ref' changed);  	var newState = state.Pop (1);  	for (var i = 0; i < switchi.CaseTargets.Count; i++)  		UnifyBeforeState (newState' switchi.CaseTargets [i]' changed);  	return newState;  }  case InstructionFlavor.Compare: {  	var cmpi = (CompareInstruction)instruction;  	// WARNING: Capured type may not be final  	// NOTE: May capture skolemized types  	switch (cmpi.Op) {  	case CompareOp.Ceq:  	case CompareOp.CnePseudo:  		cmpi.Type = state.Peek2ComparableTypes (0' true);  		return state.PopPushType (2' global.Int32Ref' BottomPT);  	case CompareOp.Clt:  	case CompareOp.Cgt:  	case CompareOp.CgePseudo:  	case CompareOp.ClePseudo:  		cmpi.Type = state.Peek2ComparableTypes (0' false);  		return state.PopPushType (2' global.Int32Ref' BottomPT);  	case CompareOp.CtruePseudo:  	case CompareOp.CfalsePseudo:  		cmpi.Type = state.PeekIntegerOrObjectOrPointerType (0' true);  		return state.PopPushType (1' global.Int32Ref' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.ArgLocal: {  	var argi = (ArgLocalInstruction)instruction;  	var type = method.ArgLocalType (argi.ArgLocal' argi.Index);  	switch (argi.Op) {  	case ArgLocalOp.Ld:  		return state.PushType (type' state.ArgLocalPointsTo (argi.ArgLocal' argi.Index));  	case ArgLocalOp.Lda:  		return state.PushType (methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (type)' ArgLocalPT (argi.ArgLocal' argi.Index));  	case ArgLocalOp.St: {  		state.PeekExpectedType (0' type' changed);  		var pointsTo = state.PeekPointsTo (0);  		if (!pointsTo.IsBottom) {  			if (!(type.Style (methEnv) is ManagedPointerTypeStyle))  				throw new InvalidOperationException ("stack indicates pointer' but parameter or local type does not");  			if (pointsTo.PointsOutsideOfHeap)  				throw new InvalidOperationException ("arguments cannot point outside of the heap");  		}  		return state.PopAddArgLocalPointsTo (1' argi.ArgLocal' argi.Index' pointsTo);  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Field: {  	var fieldi = (FieldInstruction)instruction;  	var fieldEnv = fieldi.Field.Enter (methEnv);  	var fieldType = fieldEnv.SubstituteType (fieldEnv.Field.FieldType);  	switch (fieldi.Op) {  	case FieldOp.Ldfld:  		if (fieldi.IsStatic)  			return state.PushType (fieldType' BottomPT);  		else {  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (0' fieldi.Field.DefiningType' true' changed);  			return state.PopPushType (1' fieldType' BottomPT);  		}  	case FieldOp.Ldflda:  		if (fieldi.IsStatic)  			return state.PushType (methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (fieldType)' HeapPT);  		else {  			// Underlying type cannot be a struct' otherwise would have a pointer into  			// the stack  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (0' fieldi.Field.DefiningType' false' changed);  			return state.PopPushType (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (fieldType)' HeapPT);  		}  	case FieldOp.Stfld:  		if (fieldi.IsStatic) {  			state.PeekExpectedType (0' fieldType' changed);  			return state.Pop (1);  		}  		else {  			state.PeekExpectedType (0' fieldType' changed);  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (1' fieldi.Field.DefiningType' false' changed);  			return state.Pop (2);  		}  	case FieldOp.Ldtoken:  		return state.PushType (global.RuntimeFieldHandleRef' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Method: {  	var methi = (MethodInstruction)instruction;  	var sig = (CST.MethodSignature)methi.Method.ExternalSignature;  	switch (methi.Op) {  	case MethodOp.Call: {  		for (var i = sig.Parameters.Count - 1; i >= 1; i--)  			state.PeekExpectedType (sig.Parameters.Count - 1 - i' sig.Parameters [i]' changed);  		if (methi.Constrained != null) {  			if (!methi.IsVirtual || methi.Method.IsStatic)  				throw new InvalidOperationException ("constrained only valid on virtual calls to instance methods");  			var thisType = sig.Parameters [0];  			var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (methi.Constrained);  			var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo (methi.Constrained);  			var cs = methi.Constrained.Style (methEnv);  			if (cs is ValueTypeStyle) {  				if (thisType.Style (methEnv) is ManagedPointerTypeStyle) {  					// We pass the argument pointer as is  					if (!methi.Constrained.IsAssignableTo (methEnv' thisType.Arguments [0]))  						throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  				}  				else {  					// *Case 1* Morally we deref the argument pointer and box the contents'  					// but since no supertype of a value type may mutate the underlying value'  					// we don't need to take a copy of the value when boxing' so in practice  					// this is a no-op  					if (!constrainedBox.IsAssignableTo (methEnv' thisType))  						throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  				}  			}  			else if (cs is ReferenceTypeStyle) {  				// *Case 2* We dereference the pointer and pass the object reference  				if (!methi.Constrained.IsAssignableTo (methEnv' thisType))  					throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  			}  			else if (cs is ParameterTypeStyle) {  				// Since we are calling an instance method' we know the first argument cannot be  				// a "naked" type parameter' but is either a class or an interface.  				// We must decide between cases 1 and 2 above at runtime' but checking as  				// per case 1 is sufficient now.  				// NOTE: As for box/classcast/isinst below' if the parameter is  				// instantiated to a reference type then the type box type is considered  				// equivalent to the underyling reference type.  				if (!constrainedBox.IsAssignableTo (methEnv' thisType))  					throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  			}  			else  				throw new InvalidOperationException ("constrained must be value' reference or parameter type");  			state.PeekExpectedType (sig.Parameters.Count - 1' constrainedPtr' changed);  		}  		else if (sig.Parameters.Count > 0)  			state.PeekExpectedType (sig.Parameters.Count - 1' sig.Parameters [0]' changed);  		if (sig.Result == null)  			return state.Pop (sig.Parameters.Count);  		else  			return state.PopPushType (sig.Parameters.Count' sig.Result' BottomPT);  	}  	case MethodOp.Ldftn: {  		// NOTE: Verified CLR allows only the two "blessed" sequences:  		//   dup; ldvirtftn; newobj <delegate ctor>  		//   ldftn; newobj <delegate ctor>  		// It is thus possible to check the delegate will capture an instance which  		// implements the loaded method. However' we don't check that here.  		if (methi.IsVirtual) {  			if (methi.Method.IsStatic)  				throw new InvalidOperationException ("cannot ldvirtftn of a static method");  			var objectType = default(TypeRef);  			if (sig.Parameters [0].Style (methEnv) is ManagedPointerTypeStyle)  				// Object should be a box  				objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (sig.Parameters [0].Arguments [0]);  			else  				// Object should match parameter  				objectType = sig.Parameters [0];  			state.PeekExpectedType (0' objectType' changed);  			return state.PopPushType (1' sig.WithoutThis ().ToCodePointer (methEnv.Global)' BottomPT);  		}  		else {  			if (methi.Method.IsStatic)  				return state.PushType (sig.ToCodePointer (methEnv.Global)' BottomPT);  			else  				return state.PushType (sig.WithoutThis ().ToCodePointer (methEnv.Global)' BottomPT);  		}  	}  	case MethodOp.Newobj: {  		if (methi.Method.IsStatic || sig.Result != null)  			throw new InvalidOperationException ("not a constructor");  		for (var i = sig.Parameters.Count - 1; i >= 1; i--)  			state.PeekExpectedType (sig.Parameters.Count - 1 - i' sig.Parameters [i]' changed);  		// First argument to constructor is created by runtime. If definining type is  		// a value type' first argument will be a pointer' but result left on stack  		// will be the value itself.  		return state.PopPushType (sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);  	}  	case MethodOp.Ldtoken:  		return state.PushType (global.RuntimeMethodHandleRef' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Type: {  	var typei = (TypeInstruction)instruction;  	switch (typei.Op) {  	case TypeOp.Ldobj:  		state.PeekReadPointerType (0' typei.Type);  		return state.PopPushType (1' typei.Type' BottomPT);  	case TypeOp.Stobj:  		state.PeekExpectedType (0' typei.Type' changed);  		state.PeekWritePointerType (1' typei.Type);  		return state.Pop (2);  	case TypeOp.Cpobj:  		state.PeekReadPointerType (0' typei.Type);  		state.PeekWritePointerType (1' typei.Type);  		return state.Pop (2);  	case TypeOp.Newarr:  		state.PeekIndexType (0);  		return state.PopPushType (1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo (typei.Type)' BottomPT);  	case TypeOp.Initobj:  		state.PeekWritePointerType (0' typei.Type);  		return state.Pop (1);  	case TypeOp.Castclass:  	case TypeOp.Isinst:  	case TypeOp.Box: {  		var resultType = default(TypeRef);  		var s = typei.Type.Style (methEnv);  		if (s is NullableTypeStyle)  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type.Arguments [0]);  		else if (s is ValueTypeStyle)  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type);  		else if (s is ReferenceTypeStyle)  			resultType = typei.Type;  		else if (s is ParameterTypeStyle)  			// NOTE: As for constrained call above' if type parameter is instantitated to  			// a ref type' then this box type is considered equivalent to the  			// underlying reference type.  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type);  		else  			throw new InvalidOperationException ("can only box/cast to reference' value or parameter type");  		if (typei.Op == TypeOp.Box)  			state.PeekExpectedType (0' typei.Type' changed);  		else  			state.PeekReferenceType (0);  		return state.PopPushType (1' resultType' BottomPT);  	}  	case TypeOp.Unbox:  		if (!(typei.Type.Style (methEnv) is ValueTypeStyle))  			// Parameter types are not allowed  			throw new InvalidOperationException ("type must be a value type");  		state.PeekBoxedType (0' typei.Type' changed);  		return state.PopPushType (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (typei.Type)' HeapPT);  	case TypeOp.UnboxAny: {  		var s = typei.Type.Style (methEnv);  		if (s is ValueTypeStyle)  			state.PeekBoxedType (0' typei.Type' changed);  		else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))  			throw new InvalidOperationException ("type must be value' reference or parameter type");  		return state.PopPushType (1' typei.Type' BottomPT);  	}  	case TypeOp.Ldtoken:  		return state.PushType (global.RuntimeTypeHandleRef' BottomPT);  	case TypeOp.Ldelem:  		state.PeekIndexType (0);  		state.PeekReadArrayType (1' typei.Type' false);  		return state.PopPushType (2' typei.Type' BottomPT);  	case TypeOp.Stelem:  		state.PeekExpectedType (0' typei.Type' changed);  		state.PeekIndexType (1);  		state.PeekWriteArrayType (2' typei.Type);  		return state.Pop (3);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.LdElemAddr: {  	var ldelemai = (LdElemAddrInstruction)instruction;  	state.PeekIndexType (0);  	// WARNING: May prematurely fail for non-readonly loads  	state.PeekReadArrayType (1' ldelemai.Type' !ldelemai.IsReadonly);  	return state.PopPushType (2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (ldelemai.Type)' HeapPT);  }  case InstructionFlavor.LdInt32:  	return state.PushType (global.Int32Ref' BottomPT);  case InstructionFlavor.LdInt64:  	return state.PushType (global.Int64Ref' BottomPT);  case InstructionFlavor.LdSingle:  	return state.PushType (global.DoubleRef' BottomPT);  case InstructionFlavor.LdDouble:  	return state.PushType (global.DoubleRef' BottomPT);  case InstructionFlavor.LdString:  	return state.PushType (global.StringRef' BottomPT);  case InstructionFlavor.Arith: {  	var arithi = (ArithInstruction)instruction;  	switch (arithi.Op) {  	case ArithOp.Add:  	case ArithOp.Sub:  	case ArithOp.Mul:  	case ArithOp.Div:  	case ArithOp.Rem:  		// NOTE: May capture skolemized types  		arithi.Type = state.Peek2NumberTypes (0' true);  		return state.PopPushType (2' arithi.Type' BottomPT);  	case ArithOp.Neg:  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (0' true);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (1' arithi.Type' BottomPT);  	case ArithOp.BitAnd:  	case ArithOp.BitOr:  	case ArithOp.BitXor:  		// NOTE: May capture skolemized types  		arithi.Type = state.Peek2NumberTypes (0' false);  		return state.PopPushType (2' arithi.Type' BottomPT);  	case ArithOp.BitNot:  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (0' false);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (1' arithi.Type' BottomPT);  	case ArithOp.Shl:  	case ArithOp.Shr:  		state.PeekExpectedType (0' global.Int32Ref' changed);  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (1' false);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (2' arithi.Type' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Conv: {  	var convi = (ConvInstruction)instruction;  	var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned && convi.TargetNumberFlavor == NumberFlavor.Double);  	// NOTE: May capture skolemized types  	convi.SourceType = state.PeekNumberType (0' !mustBeInteger);  	return state.PopPushType (1' TypeRef.NumberFrom (methEnv.Global' convi.TargetNumberFlavor)' BottomPT);  }  case InstructionFlavor.Try: {  	var tryi = (TryInstruction)instruction;  	// Isolation:  	//  - There is no way for the current stack shape to influence or be influenced by  	//    inference of the try' since the current stack shape must be empty.  	//  - There is no way for the try to influence the result stack shape' since it must be  	//    empty.  	//  - However pointers in arguments and locals may propogate into and out of try body  	//    via exceptional transitions. The latter are delt with separately.  	if (state.Depth != 0)  		throw new InvalidOperationException ("stack should be empty");  	var newState = ForwardBlock (new TryBodyInstructionContext (context' index' tryi.Body)' state' changed);  	for (var j = 0; j < tryi.Handlers.Count; j++) {  		var h = tryi.Handlers [j];  		var handlerContext = new TryHandlerInstructionContext (context' index' h.Body' j);  		var initHandlerState = new MachineState (methEnv' method.ValueParameters.Count' method.Locals.Count);  		switch (h.Flavor) {  		case HandlerFlavor.Catch: {  			var catchh = (CatchTryInstructionHandler)h;  			ForwardBlock (handlerContext' initHandlerState.PushType (catchh.Type' BottomPT)' changed);  			break;  		}  		case HandlerFlavor.Filter:  			throw new NotSupportedException ("filter handler blocks");  		case HandlerFlavor.Fault:  		case HandlerFlavor.Finally:  			ForwardBlock (handlerContext' initHandlerState' changed);  			break;  		default:  			throw new ArgumentOutOfRangeException ();  		}  	}  	return newState;  }  case InstructionFlavor.IfThenElsePseudo:  case InstructionFlavor.ShortCircuitingPseudo:  case InstructionFlavor.StructuralSwitchPseudo:  case InstructionFlavor.LoopPseudo:  case InstructionFlavor.WhileDoPseudo:  case InstructionFlavor.DoWhilePseudo:  case InstructionFlavor.LoopControlPseudo:  	throw new InvalidOperationException ("no machine state inference for psuedo-instructions");  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor) {  case InstructionFlavor.Unsupported:  	throw new InvalidOperationException ("unsupported opcode");  case InstructionFlavor.Misc: {  	var misci = (MiscInstruction)instruction;  	switch (misci.Op) {  	case MiscOp.Nop:  	case MiscOp.Break:  		return state;  	case MiscOp.Dup:  		return state.Push (state.Peek (0));  	case MiscOp.Pop:  		return state.Pop (1);  	case MiscOp.Ldnull:  		return state.PushType (global.NullRef' BottomPT);  	case MiscOp.Ckfinite:  		state.PeekExpectedType (0' global.DoubleRef' changed);  		// Assume the instruction can "peek" at top of stack' thus no need for pop/push.  		return state;  	case MiscOp.Throw:  		state.PeekReferenceType (0);  		return state.DiscardStack ();  	case MiscOp.Rethrow:  		return state.DiscardStack ();  	case MiscOp.LdindRef: {  		var elemType = state.PeekPointerToReferenceType (0);  		return state.PopPushType (1' elemType' BottomPT);  	}  	case MiscOp.StindRef: {  		var expElemType = state.PeekPointerToReferenceType (1);  		state.PeekExpectedType (0' expElemType' changed);  		return state.Pop (2);  	}  	case MiscOp.LdelemRef: {  		state.PeekIndexType (0);  		// WARNING: Type may not be final  		var elemType = state.PeekArrayOfReferenceType (1);  		return state.PopPushType (2' elemType' BottomPT);  	}  	case MiscOp.StelemRef:  		state.PeekReferenceType (0);  		state.PeekIndexType (1);  		state.PeekArrayOfReferenceType (2);  		// Since the value type and array element type may be independently generalized'  		// it is pointless to check that the first is assignable to the second.  		// Instead this check is done at runtime.  		return state.Pop (3);  	case MiscOp.Ldlen:  		state.PeekArrayOfAnyType (0);  		return state.PopPushType (1' global.IntNativeRef' BottomPT);  	case MiscOp.Ret: {  		if (state.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return state;  		// empty  	}  	case MiscOp.RetVal: {  		state.PeekExpectedType (0' method.Result.Type' changed);  		var newState = state.Pop (1);  		if (newState.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return newState;  		// empty  	}  	case MiscOp.Endfilter: {  		state.PeekExpectedType (0' global.Int32Ref' changed);  		var newState = state.Pop (1);  		if (newState.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return newState;  		// empty  	}  	case MiscOp.Endfinally: {  		// Control could transfer to an outer finally/fault block' or to the target  		// of a leave instruction. However these transitions are delt with separately.  		return state.DiscardStack ();  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Branch: {  	var bri = (BranchInstruction)instruction;  	switch (bri.Op) {  	case BranchOp.Br:  		UnifyBeforeState (state' bri.Target' changed);  		return state;  	case BranchOp.Brtrue: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.PeekIntegerOrObjectOrPointerType (0' false);  		var newState = state.Pop (1);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Brfalse: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.PeekIntegerOrObjectOrPointerType (0' true);  		var newState = state.Pop (1);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Breq:  	case BranchOp.Brne: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.Peek2ComparableTypes (0' true);  		var newState = state.Pop (2);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Leave: {  		// Control could transfer via finally blocks instead of directly to the leave target.  		// Propogate only that the stack must be empty at target. Remaining machine state  		// is dealt with separately.  		UnifyBeforeState (new MachineState (methEnv' method.ValueParameters.Count' method.Locals.Count)' bri.Target' changed);  		return state.DiscardStack ();  	}  	case BranchOp.BrLt:  	case BranchOp.BrLe:  	case BranchOp.BrGt:  	case BranchOp.BrGe: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.Peek2ComparableTypes (0' false);  		var newState = state.Pop (2);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Switch: {  	var switchi = (SwitchInstruction)instruction;  	state.PeekExpectedType (0' global.Int32Ref' changed);  	var newState = state.Pop (1);  	for (var i = 0; i < switchi.CaseTargets.Count; i++)  		UnifyBeforeState (newState' switchi.CaseTargets [i]' changed);  	return newState;  }  case InstructionFlavor.Compare: {  	var cmpi = (CompareInstruction)instruction;  	// WARNING: Capured type may not be final  	// NOTE: May capture skolemized types  	switch (cmpi.Op) {  	case CompareOp.Ceq:  	case CompareOp.CnePseudo:  		cmpi.Type = state.Peek2ComparableTypes (0' true);  		return state.PopPushType (2' global.Int32Ref' BottomPT);  	case CompareOp.Clt:  	case CompareOp.Cgt:  	case CompareOp.CgePseudo:  	case CompareOp.ClePseudo:  		cmpi.Type = state.Peek2ComparableTypes (0' false);  		return state.PopPushType (2' global.Int32Ref' BottomPT);  	case CompareOp.CtruePseudo:  	case CompareOp.CfalsePseudo:  		cmpi.Type = state.PeekIntegerOrObjectOrPointerType (0' true);  		return state.PopPushType (1' global.Int32Ref' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.ArgLocal: {  	var argi = (ArgLocalInstruction)instruction;  	var type = method.ArgLocalType (argi.ArgLocal' argi.Index);  	switch (argi.Op) {  	case ArgLocalOp.Ld:  		return state.PushType (type' state.ArgLocalPointsTo (argi.ArgLocal' argi.Index));  	case ArgLocalOp.Lda:  		return state.PushType (methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (type)' ArgLocalPT (argi.ArgLocal' argi.Index));  	case ArgLocalOp.St: {  		state.PeekExpectedType (0' type' changed);  		var pointsTo = state.PeekPointsTo (0);  		if (!pointsTo.IsBottom) {  			if (!(type.Style (methEnv) is ManagedPointerTypeStyle))  				throw new InvalidOperationException ("stack indicates pointer' but parameter or local type does not");  			if (pointsTo.PointsOutsideOfHeap)  				throw new InvalidOperationException ("arguments cannot point outside of the heap");  		}  		return state.PopAddArgLocalPointsTo (1' argi.ArgLocal' argi.Index' pointsTo);  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Field: {  	var fieldi = (FieldInstruction)instruction;  	var fieldEnv = fieldi.Field.Enter (methEnv);  	var fieldType = fieldEnv.SubstituteType (fieldEnv.Field.FieldType);  	switch (fieldi.Op) {  	case FieldOp.Ldfld:  		if (fieldi.IsStatic)  			return state.PushType (fieldType' BottomPT);  		else {  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (0' fieldi.Field.DefiningType' true' changed);  			return state.PopPushType (1' fieldType' BottomPT);  		}  	case FieldOp.Ldflda:  		if (fieldi.IsStatic)  			return state.PushType (methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (fieldType)' HeapPT);  		else {  			// Underlying type cannot be a struct' otherwise would have a pointer into  			// the stack  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (0' fieldi.Field.DefiningType' false' changed);  			return state.PopPushType (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (fieldType)' HeapPT);  		}  	case FieldOp.Stfld:  		if (fieldi.IsStatic) {  			state.PeekExpectedType (0' fieldType' changed);  			return state.Pop (1);  		}  		else {  			state.PeekExpectedType (0' fieldType' changed);  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (1' fieldi.Field.DefiningType' false' changed);  			return state.Pop (2);  		}  	case FieldOp.Ldtoken:  		return state.PushType (global.RuntimeFieldHandleRef' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Method: {  	var methi = (MethodInstruction)instruction;  	var sig = (CST.MethodSignature)methi.Method.ExternalSignature;  	switch (methi.Op) {  	case MethodOp.Call: {  		for (var i = sig.Parameters.Count - 1; i >= 1; i--)  			state.PeekExpectedType (sig.Parameters.Count - 1 - i' sig.Parameters [i]' changed);  		if (methi.Constrained != null) {  			if (!methi.IsVirtual || methi.Method.IsStatic)  				throw new InvalidOperationException ("constrained only valid on virtual calls to instance methods");  			var thisType = sig.Parameters [0];  			var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (methi.Constrained);  			var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo (methi.Constrained);  			var cs = methi.Constrained.Style (methEnv);  			if (cs is ValueTypeStyle) {  				if (thisType.Style (methEnv) is ManagedPointerTypeStyle) {  					// We pass the argument pointer as is  					if (!methi.Constrained.IsAssignableTo (methEnv' thisType.Arguments [0]))  						throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  				}  				else {  					// *Case 1* Morally we deref the argument pointer and box the contents'  					// but since no supertype of a value type may mutate the underlying value'  					// we don't need to take a copy of the value when boxing' so in practice  					// this is a no-op  					if (!constrainedBox.IsAssignableTo (methEnv' thisType))  						throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  				}  			}  			else if (cs is ReferenceTypeStyle) {  				// *Case 2* We dereference the pointer and pass the object reference  				if (!methi.Constrained.IsAssignableTo (methEnv' thisType))  					throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  			}  			else if (cs is ParameterTypeStyle) {  				// Since we are calling an instance method' we know the first argument cannot be  				// a "naked" type parameter' but is either a class or an interface.  				// We must decide between cases 1 and 2 above at runtime' but checking as  				// per case 1 is sufficient now.  				// NOTE: As for box/classcast/isinst below' if the parameter is  				// instantiated to a reference type then the type box type is considered  				// equivalent to the underyling reference type.  				if (!constrainedBox.IsAssignableTo (methEnv' thisType))  					throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  			}  			else  				throw new InvalidOperationException ("constrained must be value' reference or parameter type");  			state.PeekExpectedType (sig.Parameters.Count - 1' constrainedPtr' changed);  		}  		else if (sig.Parameters.Count > 0)  			state.PeekExpectedType (sig.Parameters.Count - 1' sig.Parameters [0]' changed);  		if (sig.Result == null)  			return state.Pop (sig.Parameters.Count);  		else  			return state.PopPushType (sig.Parameters.Count' sig.Result' BottomPT);  	}  	case MethodOp.Ldftn: {  		// NOTE: Verified CLR allows only the two "blessed" sequences:  		//   dup; ldvirtftn; newobj <delegate ctor>  		//   ldftn; newobj <delegate ctor>  		// It is thus possible to check the delegate will capture an instance which  		// implements the loaded method. However' we don't check that here.  		if (methi.IsVirtual) {  			if (methi.Method.IsStatic)  				throw new InvalidOperationException ("cannot ldvirtftn of a static method");  			var objectType = default(TypeRef);  			if (sig.Parameters [0].Style (methEnv) is ManagedPointerTypeStyle)  				// Object should be a box  				objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (sig.Parameters [0].Arguments [0]);  			else  				// Object should match parameter  				objectType = sig.Parameters [0];  			state.PeekExpectedType (0' objectType' changed);  			return state.PopPushType (1' sig.WithoutThis ().ToCodePointer (methEnv.Global)' BottomPT);  		}  		else {  			if (methi.Method.IsStatic)  				return state.PushType (sig.ToCodePointer (methEnv.Global)' BottomPT);  			else  				return state.PushType (sig.WithoutThis ().ToCodePointer (methEnv.Global)' BottomPT);  		}  	}  	case MethodOp.Newobj: {  		if (methi.Method.IsStatic || sig.Result != null)  			throw new InvalidOperationException ("not a constructor");  		for (var i = sig.Parameters.Count - 1; i >= 1; i--)  			state.PeekExpectedType (sig.Parameters.Count - 1 - i' sig.Parameters [i]' changed);  		// First argument to constructor is created by runtime. If definining type is  		// a value type' first argument will be a pointer' but result left on stack  		// will be the value itself.  		return state.PopPushType (sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);  	}  	case MethodOp.Ldtoken:  		return state.PushType (global.RuntimeMethodHandleRef' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Type: {  	var typei = (TypeInstruction)instruction;  	switch (typei.Op) {  	case TypeOp.Ldobj:  		state.PeekReadPointerType (0' typei.Type);  		return state.PopPushType (1' typei.Type' BottomPT);  	case TypeOp.Stobj:  		state.PeekExpectedType (0' typei.Type' changed);  		state.PeekWritePointerType (1' typei.Type);  		return state.Pop (2);  	case TypeOp.Cpobj:  		state.PeekReadPointerType (0' typei.Type);  		state.PeekWritePointerType (1' typei.Type);  		return state.Pop (2);  	case TypeOp.Newarr:  		state.PeekIndexType (0);  		return state.PopPushType (1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo (typei.Type)' BottomPT);  	case TypeOp.Initobj:  		state.PeekWritePointerType (0' typei.Type);  		return state.Pop (1);  	case TypeOp.Castclass:  	case TypeOp.Isinst:  	case TypeOp.Box: {  		var resultType = default(TypeRef);  		var s = typei.Type.Style (methEnv);  		if (s is NullableTypeStyle)  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type.Arguments [0]);  		else if (s is ValueTypeStyle)  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type);  		else if (s is ReferenceTypeStyle)  			resultType = typei.Type;  		else if (s is ParameterTypeStyle)  			// NOTE: As for constrained call above' if type parameter is instantitated to  			// a ref type' then this box type is considered equivalent to the  			// underlying reference type.  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type);  		else  			throw new InvalidOperationException ("can only box/cast to reference' value or parameter type");  		if (typei.Op == TypeOp.Box)  			state.PeekExpectedType (0' typei.Type' changed);  		else  			state.PeekReferenceType (0);  		return state.PopPushType (1' resultType' BottomPT);  	}  	case TypeOp.Unbox:  		if (!(typei.Type.Style (methEnv) is ValueTypeStyle))  			// Parameter types are not allowed  			throw new InvalidOperationException ("type must be a value type");  		state.PeekBoxedType (0' typei.Type' changed);  		return state.PopPushType (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (typei.Type)' HeapPT);  	case TypeOp.UnboxAny: {  		var s = typei.Type.Style (methEnv);  		if (s is ValueTypeStyle)  			state.PeekBoxedType (0' typei.Type' changed);  		else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))  			throw new InvalidOperationException ("type must be value' reference or parameter type");  		return state.PopPushType (1' typei.Type' BottomPT);  	}  	case TypeOp.Ldtoken:  		return state.PushType (global.RuntimeTypeHandleRef' BottomPT);  	case TypeOp.Ldelem:  		state.PeekIndexType (0);  		state.PeekReadArrayType (1' typei.Type' false);  		return state.PopPushType (2' typei.Type' BottomPT);  	case TypeOp.Stelem:  		state.PeekExpectedType (0' typei.Type' changed);  		state.PeekIndexType (1);  		state.PeekWriteArrayType (2' typei.Type);  		return state.Pop (3);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.LdElemAddr: {  	var ldelemai = (LdElemAddrInstruction)instruction;  	state.PeekIndexType (0);  	// WARNING: May prematurely fail for non-readonly loads  	state.PeekReadArrayType (1' ldelemai.Type' !ldelemai.IsReadonly);  	return state.PopPushType (2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (ldelemai.Type)' HeapPT);  }  case InstructionFlavor.LdInt32:  	return state.PushType (global.Int32Ref' BottomPT);  case InstructionFlavor.LdInt64:  	return state.PushType (global.Int64Ref' BottomPT);  case InstructionFlavor.LdSingle:  	return state.PushType (global.DoubleRef' BottomPT);  case InstructionFlavor.LdDouble:  	return state.PushType (global.DoubleRef' BottomPT);  case InstructionFlavor.LdString:  	return state.PushType (global.StringRef' BottomPT);  case InstructionFlavor.Arith: {  	var arithi = (ArithInstruction)instruction;  	switch (arithi.Op) {  	case ArithOp.Add:  	case ArithOp.Sub:  	case ArithOp.Mul:  	case ArithOp.Div:  	case ArithOp.Rem:  		// NOTE: May capture skolemized types  		arithi.Type = state.Peek2NumberTypes (0' true);  		return state.PopPushType (2' arithi.Type' BottomPT);  	case ArithOp.Neg:  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (0' true);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (1' arithi.Type' BottomPT);  	case ArithOp.BitAnd:  	case ArithOp.BitOr:  	case ArithOp.BitXor:  		// NOTE: May capture skolemized types  		arithi.Type = state.Peek2NumberTypes (0' false);  		return state.PopPushType (2' arithi.Type' BottomPT);  	case ArithOp.BitNot:  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (0' false);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (1' arithi.Type' BottomPT);  	case ArithOp.Shl:  	case ArithOp.Shr:  		state.PeekExpectedType (0' global.Int32Ref' changed);  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (1' false);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (2' arithi.Type' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Conv: {  	var convi = (ConvInstruction)instruction;  	var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned && convi.TargetNumberFlavor == NumberFlavor.Double);  	// NOTE: May capture skolemized types  	convi.SourceType = state.PeekNumberType (0' !mustBeInteger);  	return state.PopPushType (1' TypeRef.NumberFrom (methEnv.Global' convi.TargetNumberFlavor)' BottomPT);  }  case InstructionFlavor.Try: {  	var tryi = (TryInstruction)instruction;  	// Isolation:  	//  - There is no way for the current stack shape to influence or be influenced by  	//    inference of the try' since the current stack shape must be empty.  	//  - There is no way for the try to influence the result stack shape' since it must be  	//    empty.  	//  - However pointers in arguments and locals may propogate into and out of try body  	//    via exceptional transitions. The latter are delt with separately.  	if (state.Depth != 0)  		throw new InvalidOperationException ("stack should be empty");  	var newState = ForwardBlock (new TryBodyInstructionContext (context' index' tryi.Body)' state' changed);  	for (var j = 0; j < tryi.Handlers.Count; j++) {  		var h = tryi.Handlers [j];  		var handlerContext = new TryHandlerInstructionContext (context' index' h.Body' j);  		var initHandlerState = new MachineState (methEnv' method.ValueParameters.Count' method.Locals.Count);  		switch (h.Flavor) {  		case HandlerFlavor.Catch: {  			var catchh = (CatchTryInstructionHandler)h;  			ForwardBlock (handlerContext' initHandlerState.PushType (catchh.Type' BottomPT)' changed);  			break;  		}  		case HandlerFlavor.Filter:  			throw new NotSupportedException ("filter handler blocks");  		case HandlerFlavor.Fault:  		case HandlerFlavor.Finally:  			ForwardBlock (handlerContext' initHandlerState' changed);  			break;  		default:  			throw new ArgumentOutOfRangeException ();  		}  	}  	return newState;  }  case InstructionFlavor.IfThenElsePseudo:  case InstructionFlavor.ShortCircuitingPseudo:  case InstructionFlavor.StructuralSwitchPseudo:  case InstructionFlavor.LoopPseudo:  case InstructionFlavor.WhileDoPseudo:  case InstructionFlavor.DoWhilePseudo:  case InstructionFlavor.LoopControlPseudo:  	throw new InvalidOperationException ("no machine state inference for psuedo-instructions");  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor) {  case InstructionFlavor.Unsupported:  	throw new InvalidOperationException ("unsupported opcode");  case InstructionFlavor.Misc: {  	var misci = (MiscInstruction)instruction;  	switch (misci.Op) {  	case MiscOp.Nop:  	case MiscOp.Break:  		return state;  	case MiscOp.Dup:  		return state.Push (state.Peek (0));  	case MiscOp.Pop:  		return state.Pop (1);  	case MiscOp.Ldnull:  		return state.PushType (global.NullRef' BottomPT);  	case MiscOp.Ckfinite:  		state.PeekExpectedType (0' global.DoubleRef' changed);  		// Assume the instruction can "peek" at top of stack' thus no need for pop/push.  		return state;  	case MiscOp.Throw:  		state.PeekReferenceType (0);  		return state.DiscardStack ();  	case MiscOp.Rethrow:  		return state.DiscardStack ();  	case MiscOp.LdindRef: {  		var elemType = state.PeekPointerToReferenceType (0);  		return state.PopPushType (1' elemType' BottomPT);  	}  	case MiscOp.StindRef: {  		var expElemType = state.PeekPointerToReferenceType (1);  		state.PeekExpectedType (0' expElemType' changed);  		return state.Pop (2);  	}  	case MiscOp.LdelemRef: {  		state.PeekIndexType (0);  		// WARNING: Type may not be final  		var elemType = state.PeekArrayOfReferenceType (1);  		return state.PopPushType (2' elemType' BottomPT);  	}  	case MiscOp.StelemRef:  		state.PeekReferenceType (0);  		state.PeekIndexType (1);  		state.PeekArrayOfReferenceType (2);  		// Since the value type and array element type may be independently generalized'  		// it is pointless to check that the first is assignable to the second.  		// Instead this check is done at runtime.  		return state.Pop (3);  	case MiscOp.Ldlen:  		state.PeekArrayOfAnyType (0);  		return state.PopPushType (1' global.IntNativeRef' BottomPT);  	case MiscOp.Ret: {  		if (state.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return state;  		// empty  	}  	case MiscOp.RetVal: {  		state.PeekExpectedType (0' method.Result.Type' changed);  		var newState = state.Pop (1);  		if (newState.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return newState;  		// empty  	}  	case MiscOp.Endfilter: {  		state.PeekExpectedType (0' global.Int32Ref' changed);  		var newState = state.Pop (1);  		if (newState.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return newState;  		// empty  	}  	case MiscOp.Endfinally: {  		// Control could transfer to an outer finally/fault block' or to the target  		// of a leave instruction. However these transitions are delt with separately.  		return state.DiscardStack ();  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Branch: {  	var bri = (BranchInstruction)instruction;  	switch (bri.Op) {  	case BranchOp.Br:  		UnifyBeforeState (state' bri.Target' changed);  		return state;  	case BranchOp.Brtrue: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.PeekIntegerOrObjectOrPointerType (0' false);  		var newState = state.Pop (1);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Brfalse: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.PeekIntegerOrObjectOrPointerType (0' true);  		var newState = state.Pop (1);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Breq:  	case BranchOp.Brne: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.Peek2ComparableTypes (0' true);  		var newState = state.Pop (2);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Leave: {  		// Control could transfer via finally blocks instead of directly to the leave target.  		// Propogate only that the stack must be empty at target. Remaining machine state  		// is dealt with separately.  		UnifyBeforeState (new MachineState (methEnv' method.ValueParameters.Count' method.Locals.Count)' bri.Target' changed);  		return state.DiscardStack ();  	}  	case BranchOp.BrLt:  	case BranchOp.BrLe:  	case BranchOp.BrGt:  	case BranchOp.BrGe: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.Peek2ComparableTypes (0' false);  		var newState = state.Pop (2);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Switch: {  	var switchi = (SwitchInstruction)instruction;  	state.PeekExpectedType (0' global.Int32Ref' changed);  	var newState = state.Pop (1);  	for (var i = 0; i < switchi.CaseTargets.Count; i++)  		UnifyBeforeState (newState' switchi.CaseTargets [i]' changed);  	return newState;  }  case InstructionFlavor.Compare: {  	var cmpi = (CompareInstruction)instruction;  	// WARNING: Capured type may not be final  	// NOTE: May capture skolemized types  	switch (cmpi.Op) {  	case CompareOp.Ceq:  	case CompareOp.CnePseudo:  		cmpi.Type = state.Peek2ComparableTypes (0' true);  		return state.PopPushType (2' global.Int32Ref' BottomPT);  	case CompareOp.Clt:  	case CompareOp.Cgt:  	case CompareOp.CgePseudo:  	case CompareOp.ClePseudo:  		cmpi.Type = state.Peek2ComparableTypes (0' false);  		return state.PopPushType (2' global.Int32Ref' BottomPT);  	case CompareOp.CtruePseudo:  	case CompareOp.CfalsePseudo:  		cmpi.Type = state.PeekIntegerOrObjectOrPointerType (0' true);  		return state.PopPushType (1' global.Int32Ref' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.ArgLocal: {  	var argi = (ArgLocalInstruction)instruction;  	var type = method.ArgLocalType (argi.ArgLocal' argi.Index);  	switch (argi.Op) {  	case ArgLocalOp.Ld:  		return state.PushType (type' state.ArgLocalPointsTo (argi.ArgLocal' argi.Index));  	case ArgLocalOp.Lda:  		return state.PushType (methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (type)' ArgLocalPT (argi.ArgLocal' argi.Index));  	case ArgLocalOp.St: {  		state.PeekExpectedType (0' type' changed);  		var pointsTo = state.PeekPointsTo (0);  		if (!pointsTo.IsBottom) {  			if (!(type.Style (methEnv) is ManagedPointerTypeStyle))  				throw new InvalidOperationException ("stack indicates pointer' but parameter or local type does not");  			if (pointsTo.PointsOutsideOfHeap)  				throw new InvalidOperationException ("arguments cannot point outside of the heap");  		}  		return state.PopAddArgLocalPointsTo (1' argi.ArgLocal' argi.Index' pointsTo);  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Field: {  	var fieldi = (FieldInstruction)instruction;  	var fieldEnv = fieldi.Field.Enter (methEnv);  	var fieldType = fieldEnv.SubstituteType (fieldEnv.Field.FieldType);  	switch (fieldi.Op) {  	case FieldOp.Ldfld:  		if (fieldi.IsStatic)  			return state.PushType (fieldType' BottomPT);  		else {  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (0' fieldi.Field.DefiningType' true' changed);  			return state.PopPushType (1' fieldType' BottomPT);  		}  	case FieldOp.Ldflda:  		if (fieldi.IsStatic)  			return state.PushType (methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (fieldType)' HeapPT);  		else {  			// Underlying type cannot be a struct' otherwise would have a pointer into  			// the stack  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (0' fieldi.Field.DefiningType' false' changed);  			return state.PopPushType (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (fieldType)' HeapPT);  		}  	case FieldOp.Stfld:  		if (fieldi.IsStatic) {  			state.PeekExpectedType (0' fieldType' changed);  			return state.Pop (1);  		}  		else {  			state.PeekExpectedType (0' fieldType' changed);  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (1' fieldi.Field.DefiningType' false' changed);  			return state.Pop (2);  		}  	case FieldOp.Ldtoken:  		return state.PushType (global.RuntimeFieldHandleRef' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Method: {  	var methi = (MethodInstruction)instruction;  	var sig = (CST.MethodSignature)methi.Method.ExternalSignature;  	switch (methi.Op) {  	case MethodOp.Call: {  		for (var i = sig.Parameters.Count - 1; i >= 1; i--)  			state.PeekExpectedType (sig.Parameters.Count - 1 - i' sig.Parameters [i]' changed);  		if (methi.Constrained != null) {  			if (!methi.IsVirtual || methi.Method.IsStatic)  				throw new InvalidOperationException ("constrained only valid on virtual calls to instance methods");  			var thisType = sig.Parameters [0];  			var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (methi.Constrained);  			var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo (methi.Constrained);  			var cs = methi.Constrained.Style (methEnv);  			if (cs is ValueTypeStyle) {  				if (thisType.Style (methEnv) is ManagedPointerTypeStyle) {  					// We pass the argument pointer as is  					if (!methi.Constrained.IsAssignableTo (methEnv' thisType.Arguments [0]))  						throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  				}  				else {  					// *Case 1* Morally we deref the argument pointer and box the contents'  					// but since no supertype of a value type may mutate the underlying value'  					// we don't need to take a copy of the value when boxing' so in practice  					// this is a no-op  					if (!constrainedBox.IsAssignableTo (methEnv' thisType))  						throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  				}  			}  			else if (cs is ReferenceTypeStyle) {  				// *Case 2* We dereference the pointer and pass the object reference  				if (!methi.Constrained.IsAssignableTo (methEnv' thisType))  					throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  			}  			else if (cs is ParameterTypeStyle) {  				// Since we are calling an instance method' we know the first argument cannot be  				// a "naked" type parameter' but is either a class or an interface.  				// We must decide between cases 1 and 2 above at runtime' but checking as  				// per case 1 is sufficient now.  				// NOTE: As for box/classcast/isinst below' if the parameter is  				// instantiated to a reference type then the type box type is considered  				// equivalent to the underyling reference type.  				if (!constrainedBox.IsAssignableTo (methEnv' thisType))  					throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  			}  			else  				throw new InvalidOperationException ("constrained must be value' reference or parameter type");  			state.PeekExpectedType (sig.Parameters.Count - 1' constrainedPtr' changed);  		}  		else if (sig.Parameters.Count > 0)  			state.PeekExpectedType (sig.Parameters.Count - 1' sig.Parameters [0]' changed);  		if (sig.Result == null)  			return state.Pop (sig.Parameters.Count);  		else  			return state.PopPushType (sig.Parameters.Count' sig.Result' BottomPT);  	}  	case MethodOp.Ldftn: {  		// NOTE: Verified CLR allows only the two "blessed" sequences:  		//   dup; ldvirtftn; newobj <delegate ctor>  		//   ldftn; newobj <delegate ctor>  		// It is thus possible to check the delegate will capture an instance which  		// implements the loaded method. However' we don't check that here.  		if (methi.IsVirtual) {  			if (methi.Method.IsStatic)  				throw new InvalidOperationException ("cannot ldvirtftn of a static method");  			var objectType = default(TypeRef);  			if (sig.Parameters [0].Style (methEnv) is ManagedPointerTypeStyle)  				// Object should be a box  				objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (sig.Parameters [0].Arguments [0]);  			else  				// Object should match parameter  				objectType = sig.Parameters [0];  			state.PeekExpectedType (0' objectType' changed);  			return state.PopPushType (1' sig.WithoutThis ().ToCodePointer (methEnv.Global)' BottomPT);  		}  		else {  			if (methi.Method.IsStatic)  				return state.PushType (sig.ToCodePointer (methEnv.Global)' BottomPT);  			else  				return state.PushType (sig.WithoutThis ().ToCodePointer (methEnv.Global)' BottomPT);  		}  	}  	case MethodOp.Newobj: {  		if (methi.Method.IsStatic || sig.Result != null)  			throw new InvalidOperationException ("not a constructor");  		for (var i = sig.Parameters.Count - 1; i >= 1; i--)  			state.PeekExpectedType (sig.Parameters.Count - 1 - i' sig.Parameters [i]' changed);  		// First argument to constructor is created by runtime. If definining type is  		// a value type' first argument will be a pointer' but result left on stack  		// will be the value itself.  		return state.PopPushType (sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);  	}  	case MethodOp.Ldtoken:  		return state.PushType (global.RuntimeMethodHandleRef' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Type: {  	var typei = (TypeInstruction)instruction;  	switch (typei.Op) {  	case TypeOp.Ldobj:  		state.PeekReadPointerType (0' typei.Type);  		return state.PopPushType (1' typei.Type' BottomPT);  	case TypeOp.Stobj:  		state.PeekExpectedType (0' typei.Type' changed);  		state.PeekWritePointerType (1' typei.Type);  		return state.Pop (2);  	case TypeOp.Cpobj:  		state.PeekReadPointerType (0' typei.Type);  		state.PeekWritePointerType (1' typei.Type);  		return state.Pop (2);  	case TypeOp.Newarr:  		state.PeekIndexType (0);  		return state.PopPushType (1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo (typei.Type)' BottomPT);  	case TypeOp.Initobj:  		state.PeekWritePointerType (0' typei.Type);  		return state.Pop (1);  	case TypeOp.Castclass:  	case TypeOp.Isinst:  	case TypeOp.Box: {  		var resultType = default(TypeRef);  		var s = typei.Type.Style (methEnv);  		if (s is NullableTypeStyle)  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type.Arguments [0]);  		else if (s is ValueTypeStyle)  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type);  		else if (s is ReferenceTypeStyle)  			resultType = typei.Type;  		else if (s is ParameterTypeStyle)  			// NOTE: As for constrained call above' if type parameter is instantitated to  			// a ref type' then this box type is considered equivalent to the  			// underlying reference type.  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type);  		else  			throw new InvalidOperationException ("can only box/cast to reference' value or parameter type");  		if (typei.Op == TypeOp.Box)  			state.PeekExpectedType (0' typei.Type' changed);  		else  			state.PeekReferenceType (0);  		return state.PopPushType (1' resultType' BottomPT);  	}  	case TypeOp.Unbox:  		if (!(typei.Type.Style (methEnv) is ValueTypeStyle))  			// Parameter types are not allowed  			throw new InvalidOperationException ("type must be a value type");  		state.PeekBoxedType (0' typei.Type' changed);  		return state.PopPushType (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (typei.Type)' HeapPT);  	case TypeOp.UnboxAny: {  		var s = typei.Type.Style (methEnv);  		if (s is ValueTypeStyle)  			state.PeekBoxedType (0' typei.Type' changed);  		else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))  			throw new InvalidOperationException ("type must be value' reference or parameter type");  		return state.PopPushType (1' typei.Type' BottomPT);  	}  	case TypeOp.Ldtoken:  		return state.PushType (global.RuntimeTypeHandleRef' BottomPT);  	case TypeOp.Ldelem:  		state.PeekIndexType (0);  		state.PeekReadArrayType (1' typei.Type' false);  		return state.PopPushType (2' typei.Type' BottomPT);  	case TypeOp.Stelem:  		state.PeekExpectedType (0' typei.Type' changed);  		state.PeekIndexType (1);  		state.PeekWriteArrayType (2' typei.Type);  		return state.Pop (3);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.LdElemAddr: {  	var ldelemai = (LdElemAddrInstruction)instruction;  	state.PeekIndexType (0);  	// WARNING: May prematurely fail for non-readonly loads  	state.PeekReadArrayType (1' ldelemai.Type' !ldelemai.IsReadonly);  	return state.PopPushType (2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (ldelemai.Type)' HeapPT);  }  case InstructionFlavor.LdInt32:  	return state.PushType (global.Int32Ref' BottomPT);  case InstructionFlavor.LdInt64:  	return state.PushType (global.Int64Ref' BottomPT);  case InstructionFlavor.LdSingle:  	return state.PushType (global.DoubleRef' BottomPT);  case InstructionFlavor.LdDouble:  	return state.PushType (global.DoubleRef' BottomPT);  case InstructionFlavor.LdString:  	return state.PushType (global.StringRef' BottomPT);  case InstructionFlavor.Arith: {  	var arithi = (ArithInstruction)instruction;  	switch (arithi.Op) {  	case ArithOp.Add:  	case ArithOp.Sub:  	case ArithOp.Mul:  	case ArithOp.Div:  	case ArithOp.Rem:  		// NOTE: May capture skolemized types  		arithi.Type = state.Peek2NumberTypes (0' true);  		return state.PopPushType (2' arithi.Type' BottomPT);  	case ArithOp.Neg:  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (0' true);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (1' arithi.Type' BottomPT);  	case ArithOp.BitAnd:  	case ArithOp.BitOr:  	case ArithOp.BitXor:  		// NOTE: May capture skolemized types  		arithi.Type = state.Peek2NumberTypes (0' false);  		return state.PopPushType (2' arithi.Type' BottomPT);  	case ArithOp.BitNot:  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (0' false);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (1' arithi.Type' BottomPT);  	case ArithOp.Shl:  	case ArithOp.Shr:  		state.PeekExpectedType (0' global.Int32Ref' changed);  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (1' false);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (2' arithi.Type' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Conv: {  	var convi = (ConvInstruction)instruction;  	var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned && convi.TargetNumberFlavor == NumberFlavor.Double);  	// NOTE: May capture skolemized types  	convi.SourceType = state.PeekNumberType (0' !mustBeInteger);  	return state.PopPushType (1' TypeRef.NumberFrom (methEnv.Global' convi.TargetNumberFlavor)' BottomPT);  }  case InstructionFlavor.Try: {  	var tryi = (TryInstruction)instruction;  	// Isolation:  	//  - There is no way for the current stack shape to influence or be influenced by  	//    inference of the try' since the current stack shape must be empty.  	//  - There is no way for the try to influence the result stack shape' since it must be  	//    empty.  	//  - However pointers in arguments and locals may propogate into and out of try body  	//    via exceptional transitions. The latter are delt with separately.  	if (state.Depth != 0)  		throw new InvalidOperationException ("stack should be empty");  	var newState = ForwardBlock (new TryBodyInstructionContext (context' index' tryi.Body)' state' changed);  	for (var j = 0; j < tryi.Handlers.Count; j++) {  		var h = tryi.Handlers [j];  		var handlerContext = new TryHandlerInstructionContext (context' index' h.Body' j);  		var initHandlerState = new MachineState (methEnv' method.ValueParameters.Count' method.Locals.Count);  		switch (h.Flavor) {  		case HandlerFlavor.Catch: {  			var catchh = (CatchTryInstructionHandler)h;  			ForwardBlock (handlerContext' initHandlerState.PushType (catchh.Type' BottomPT)' changed);  			break;  		}  		case HandlerFlavor.Filter:  			throw new NotSupportedException ("filter handler blocks");  		case HandlerFlavor.Fault:  		case HandlerFlavor.Finally:  			ForwardBlock (handlerContext' initHandlerState' changed);  			break;  		default:  			throw new ArgumentOutOfRangeException ();  		}  	}  	return newState;  }  case InstructionFlavor.IfThenElsePseudo:  case InstructionFlavor.ShortCircuitingPseudo:  case InstructionFlavor.StructuralSwitchPseudo:  case InstructionFlavor.LoopPseudo:  case InstructionFlavor.WhileDoPseudo:  case InstructionFlavor.DoWhilePseudo:  case InstructionFlavor.LoopControlPseudo:  	throw new InvalidOperationException ("no machine state inference for psuedo-instructions");  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor) {  case InstructionFlavor.Unsupported:  	throw new InvalidOperationException ("unsupported opcode");  case InstructionFlavor.Misc: {  	var misci = (MiscInstruction)instruction;  	switch (misci.Op) {  	case MiscOp.Nop:  	case MiscOp.Break:  		return state;  	case MiscOp.Dup:  		return state.Push (state.Peek (0));  	case MiscOp.Pop:  		return state.Pop (1);  	case MiscOp.Ldnull:  		return state.PushType (global.NullRef' BottomPT);  	case MiscOp.Ckfinite:  		state.PeekExpectedType (0' global.DoubleRef' changed);  		// Assume the instruction can "peek" at top of stack' thus no need for pop/push.  		return state;  	case MiscOp.Throw:  		state.PeekReferenceType (0);  		return state.DiscardStack ();  	case MiscOp.Rethrow:  		return state.DiscardStack ();  	case MiscOp.LdindRef: {  		var elemType = state.PeekPointerToReferenceType (0);  		return state.PopPushType (1' elemType' BottomPT);  	}  	case MiscOp.StindRef: {  		var expElemType = state.PeekPointerToReferenceType (1);  		state.PeekExpectedType (0' expElemType' changed);  		return state.Pop (2);  	}  	case MiscOp.LdelemRef: {  		state.PeekIndexType (0);  		// WARNING: Type may not be final  		var elemType = state.PeekArrayOfReferenceType (1);  		return state.PopPushType (2' elemType' BottomPT);  	}  	case MiscOp.StelemRef:  		state.PeekReferenceType (0);  		state.PeekIndexType (1);  		state.PeekArrayOfReferenceType (2);  		// Since the value type and array element type may be independently generalized'  		// it is pointless to check that the first is assignable to the second.  		// Instead this check is done at runtime.  		return state.Pop (3);  	case MiscOp.Ldlen:  		state.PeekArrayOfAnyType (0);  		return state.PopPushType (1' global.IntNativeRef' BottomPT);  	case MiscOp.Ret: {  		if (state.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return state;  		// empty  	}  	case MiscOp.RetVal: {  		state.PeekExpectedType (0' method.Result.Type' changed);  		var newState = state.Pop (1);  		if (newState.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return newState;  		// empty  	}  	case MiscOp.Endfilter: {  		state.PeekExpectedType (0' global.Int32Ref' changed);  		var newState = state.Pop (1);  		if (newState.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return newState;  		// empty  	}  	case MiscOp.Endfinally: {  		// Control could transfer to an outer finally/fault block' or to the target  		// of a leave instruction. However these transitions are delt with separately.  		return state.DiscardStack ();  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Branch: {  	var bri = (BranchInstruction)instruction;  	switch (bri.Op) {  	case BranchOp.Br:  		UnifyBeforeState (state' bri.Target' changed);  		return state;  	case BranchOp.Brtrue: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.PeekIntegerOrObjectOrPointerType (0' false);  		var newState = state.Pop (1);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Brfalse: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.PeekIntegerOrObjectOrPointerType (0' true);  		var newState = state.Pop (1);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Breq:  	case BranchOp.Brne: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.Peek2ComparableTypes (0' true);  		var newState = state.Pop (2);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Leave: {  		// Control could transfer via finally blocks instead of directly to the leave target.  		// Propogate only that the stack must be empty at target. Remaining machine state  		// is dealt with separately.  		UnifyBeforeState (new MachineState (methEnv' method.ValueParameters.Count' method.Locals.Count)' bri.Target' changed);  		return state.DiscardStack ();  	}  	case BranchOp.BrLt:  	case BranchOp.BrLe:  	case BranchOp.BrGt:  	case BranchOp.BrGe: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.Peek2ComparableTypes (0' false);  		var newState = state.Pop (2);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Switch: {  	var switchi = (SwitchInstruction)instruction;  	state.PeekExpectedType (0' global.Int32Ref' changed);  	var newState = state.Pop (1);  	for (var i = 0; i < switchi.CaseTargets.Count; i++)  		UnifyBeforeState (newState' switchi.CaseTargets [i]' changed);  	return newState;  }  case InstructionFlavor.Compare: {  	var cmpi = (CompareInstruction)instruction;  	// WARNING: Capured type may not be final  	// NOTE: May capture skolemized types  	switch (cmpi.Op) {  	case CompareOp.Ceq:  	case CompareOp.CnePseudo:  		cmpi.Type = state.Peek2ComparableTypes (0' true);  		return state.PopPushType (2' global.Int32Ref' BottomPT);  	case CompareOp.Clt:  	case CompareOp.Cgt:  	case CompareOp.CgePseudo:  	case CompareOp.ClePseudo:  		cmpi.Type = state.Peek2ComparableTypes (0' false);  		return state.PopPushType (2' global.Int32Ref' BottomPT);  	case CompareOp.CtruePseudo:  	case CompareOp.CfalsePseudo:  		cmpi.Type = state.PeekIntegerOrObjectOrPointerType (0' true);  		return state.PopPushType (1' global.Int32Ref' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.ArgLocal: {  	var argi = (ArgLocalInstruction)instruction;  	var type = method.ArgLocalType (argi.ArgLocal' argi.Index);  	switch (argi.Op) {  	case ArgLocalOp.Ld:  		return state.PushType (type' state.ArgLocalPointsTo (argi.ArgLocal' argi.Index));  	case ArgLocalOp.Lda:  		return state.PushType (methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (type)' ArgLocalPT (argi.ArgLocal' argi.Index));  	case ArgLocalOp.St: {  		state.PeekExpectedType (0' type' changed);  		var pointsTo = state.PeekPointsTo (0);  		if (!pointsTo.IsBottom) {  			if (!(type.Style (methEnv) is ManagedPointerTypeStyle))  				throw new InvalidOperationException ("stack indicates pointer' but parameter or local type does not");  			if (pointsTo.PointsOutsideOfHeap)  				throw new InvalidOperationException ("arguments cannot point outside of the heap");  		}  		return state.PopAddArgLocalPointsTo (1' argi.ArgLocal' argi.Index' pointsTo);  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Field: {  	var fieldi = (FieldInstruction)instruction;  	var fieldEnv = fieldi.Field.Enter (methEnv);  	var fieldType = fieldEnv.SubstituteType (fieldEnv.Field.FieldType);  	switch (fieldi.Op) {  	case FieldOp.Ldfld:  		if (fieldi.IsStatic)  			return state.PushType (fieldType' BottomPT);  		else {  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (0' fieldi.Field.DefiningType' true' changed);  			return state.PopPushType (1' fieldType' BottomPT);  		}  	case FieldOp.Ldflda:  		if (fieldi.IsStatic)  			return state.PushType (methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (fieldType)' HeapPT);  		else {  			// Underlying type cannot be a struct' otherwise would have a pointer into  			// the stack  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (0' fieldi.Field.DefiningType' false' changed);  			return state.PopPushType (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (fieldType)' HeapPT);  		}  	case FieldOp.Stfld:  		if (fieldi.IsStatic) {  			state.PeekExpectedType (0' fieldType' changed);  			return state.Pop (1);  		}  		else {  			state.PeekExpectedType (0' fieldType' changed);  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (1' fieldi.Field.DefiningType' false' changed);  			return state.Pop (2);  		}  	case FieldOp.Ldtoken:  		return state.PushType (global.RuntimeFieldHandleRef' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Method: {  	var methi = (MethodInstruction)instruction;  	var sig = (CST.MethodSignature)methi.Method.ExternalSignature;  	switch (methi.Op) {  	case MethodOp.Call: {  		for (var i = sig.Parameters.Count - 1; i >= 1; i--)  			state.PeekExpectedType (sig.Parameters.Count - 1 - i' sig.Parameters [i]' changed);  		if (methi.Constrained != null) {  			if (!methi.IsVirtual || methi.Method.IsStatic)  				throw new InvalidOperationException ("constrained only valid on virtual calls to instance methods");  			var thisType = sig.Parameters [0];  			var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (methi.Constrained);  			var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo (methi.Constrained);  			var cs = methi.Constrained.Style (methEnv);  			if (cs is ValueTypeStyle) {  				if (thisType.Style (methEnv) is ManagedPointerTypeStyle) {  					// We pass the argument pointer as is  					if (!methi.Constrained.IsAssignableTo (methEnv' thisType.Arguments [0]))  						throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  				}  				else {  					// *Case 1* Morally we deref the argument pointer and box the contents'  					// but since no supertype of a value type may mutate the underlying value'  					// we don't need to take a copy of the value when boxing' so in practice  					// this is a no-op  					if (!constrainedBox.IsAssignableTo (methEnv' thisType))  						throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  				}  			}  			else if (cs is ReferenceTypeStyle) {  				// *Case 2* We dereference the pointer and pass the object reference  				if (!methi.Constrained.IsAssignableTo (methEnv' thisType))  					throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  			}  			else if (cs is ParameterTypeStyle) {  				// Since we are calling an instance method' we know the first argument cannot be  				// a "naked" type parameter' but is either a class or an interface.  				// We must decide between cases 1 and 2 above at runtime' but checking as  				// per case 1 is sufficient now.  				// NOTE: As for box/classcast/isinst below' if the parameter is  				// instantiated to a reference type then the type box type is considered  				// equivalent to the underyling reference type.  				if (!constrainedBox.IsAssignableTo (methEnv' thisType))  					throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  			}  			else  				throw new InvalidOperationException ("constrained must be value' reference or parameter type");  			state.PeekExpectedType (sig.Parameters.Count - 1' constrainedPtr' changed);  		}  		else if (sig.Parameters.Count > 0)  			state.PeekExpectedType (sig.Parameters.Count - 1' sig.Parameters [0]' changed);  		if (sig.Result == null)  			return state.Pop (sig.Parameters.Count);  		else  			return state.PopPushType (sig.Parameters.Count' sig.Result' BottomPT);  	}  	case MethodOp.Ldftn: {  		// NOTE: Verified CLR allows only the two "blessed" sequences:  		//   dup; ldvirtftn; newobj <delegate ctor>  		//   ldftn; newobj <delegate ctor>  		// It is thus possible to check the delegate will capture an instance which  		// implements the loaded method. However' we don't check that here.  		if (methi.IsVirtual) {  			if (methi.Method.IsStatic)  				throw new InvalidOperationException ("cannot ldvirtftn of a static method");  			var objectType = default(TypeRef);  			if (sig.Parameters [0].Style (methEnv) is ManagedPointerTypeStyle)  				// Object should be a box  				objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (sig.Parameters [0].Arguments [0]);  			else  				// Object should match parameter  				objectType = sig.Parameters [0];  			state.PeekExpectedType (0' objectType' changed);  			return state.PopPushType (1' sig.WithoutThis ().ToCodePointer (methEnv.Global)' BottomPT);  		}  		else {  			if (methi.Method.IsStatic)  				return state.PushType (sig.ToCodePointer (methEnv.Global)' BottomPT);  			else  				return state.PushType (sig.WithoutThis ().ToCodePointer (methEnv.Global)' BottomPT);  		}  	}  	case MethodOp.Newobj: {  		if (methi.Method.IsStatic || sig.Result != null)  			throw new InvalidOperationException ("not a constructor");  		for (var i = sig.Parameters.Count - 1; i >= 1; i--)  			state.PeekExpectedType (sig.Parameters.Count - 1 - i' sig.Parameters [i]' changed);  		// First argument to constructor is created by runtime. If definining type is  		// a value type' first argument will be a pointer' but result left on stack  		// will be the value itself.  		return state.PopPushType (sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);  	}  	case MethodOp.Ldtoken:  		return state.PushType (global.RuntimeMethodHandleRef' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Type: {  	var typei = (TypeInstruction)instruction;  	switch (typei.Op) {  	case TypeOp.Ldobj:  		state.PeekReadPointerType (0' typei.Type);  		return state.PopPushType (1' typei.Type' BottomPT);  	case TypeOp.Stobj:  		state.PeekExpectedType (0' typei.Type' changed);  		state.PeekWritePointerType (1' typei.Type);  		return state.Pop (2);  	case TypeOp.Cpobj:  		state.PeekReadPointerType (0' typei.Type);  		state.PeekWritePointerType (1' typei.Type);  		return state.Pop (2);  	case TypeOp.Newarr:  		state.PeekIndexType (0);  		return state.PopPushType (1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo (typei.Type)' BottomPT);  	case TypeOp.Initobj:  		state.PeekWritePointerType (0' typei.Type);  		return state.Pop (1);  	case TypeOp.Castclass:  	case TypeOp.Isinst:  	case TypeOp.Box: {  		var resultType = default(TypeRef);  		var s = typei.Type.Style (methEnv);  		if (s is NullableTypeStyle)  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type.Arguments [0]);  		else if (s is ValueTypeStyle)  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type);  		else if (s is ReferenceTypeStyle)  			resultType = typei.Type;  		else if (s is ParameterTypeStyle)  			// NOTE: As for constrained call above' if type parameter is instantitated to  			// a ref type' then this box type is considered equivalent to the  			// underlying reference type.  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type);  		else  			throw new InvalidOperationException ("can only box/cast to reference' value or parameter type");  		if (typei.Op == TypeOp.Box)  			state.PeekExpectedType (0' typei.Type' changed);  		else  			state.PeekReferenceType (0);  		return state.PopPushType (1' resultType' BottomPT);  	}  	case TypeOp.Unbox:  		if (!(typei.Type.Style (methEnv) is ValueTypeStyle))  			// Parameter types are not allowed  			throw new InvalidOperationException ("type must be a value type");  		state.PeekBoxedType (0' typei.Type' changed);  		return state.PopPushType (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (typei.Type)' HeapPT);  	case TypeOp.UnboxAny: {  		var s = typei.Type.Style (methEnv);  		if (s is ValueTypeStyle)  			state.PeekBoxedType (0' typei.Type' changed);  		else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))  			throw new InvalidOperationException ("type must be value' reference or parameter type");  		return state.PopPushType (1' typei.Type' BottomPT);  	}  	case TypeOp.Ldtoken:  		return state.PushType (global.RuntimeTypeHandleRef' BottomPT);  	case TypeOp.Ldelem:  		state.PeekIndexType (0);  		state.PeekReadArrayType (1' typei.Type' false);  		return state.PopPushType (2' typei.Type' BottomPT);  	case TypeOp.Stelem:  		state.PeekExpectedType (0' typei.Type' changed);  		state.PeekIndexType (1);  		state.PeekWriteArrayType (2' typei.Type);  		return state.Pop (3);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.LdElemAddr: {  	var ldelemai = (LdElemAddrInstruction)instruction;  	state.PeekIndexType (0);  	// WARNING: May prematurely fail for non-readonly loads  	state.PeekReadArrayType (1' ldelemai.Type' !ldelemai.IsReadonly);  	return state.PopPushType (2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (ldelemai.Type)' HeapPT);  }  case InstructionFlavor.LdInt32:  	return state.PushType (global.Int32Ref' BottomPT);  case InstructionFlavor.LdInt64:  	return state.PushType (global.Int64Ref' BottomPT);  case InstructionFlavor.LdSingle:  	return state.PushType (global.DoubleRef' BottomPT);  case InstructionFlavor.LdDouble:  	return state.PushType (global.DoubleRef' BottomPT);  case InstructionFlavor.LdString:  	return state.PushType (global.StringRef' BottomPT);  case InstructionFlavor.Arith: {  	var arithi = (ArithInstruction)instruction;  	switch (arithi.Op) {  	case ArithOp.Add:  	case ArithOp.Sub:  	case ArithOp.Mul:  	case ArithOp.Div:  	case ArithOp.Rem:  		// NOTE: May capture skolemized types  		arithi.Type = state.Peek2NumberTypes (0' true);  		return state.PopPushType (2' arithi.Type' BottomPT);  	case ArithOp.Neg:  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (0' true);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (1' arithi.Type' BottomPT);  	case ArithOp.BitAnd:  	case ArithOp.BitOr:  	case ArithOp.BitXor:  		// NOTE: May capture skolemized types  		arithi.Type = state.Peek2NumberTypes (0' false);  		return state.PopPushType (2' arithi.Type' BottomPT);  	case ArithOp.BitNot:  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (0' false);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (1' arithi.Type' BottomPT);  	case ArithOp.Shl:  	case ArithOp.Shr:  		state.PeekExpectedType (0' global.Int32Ref' changed);  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (1' false);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (2' arithi.Type' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Conv: {  	var convi = (ConvInstruction)instruction;  	var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned && convi.TargetNumberFlavor == NumberFlavor.Double);  	// NOTE: May capture skolemized types  	convi.SourceType = state.PeekNumberType (0' !mustBeInteger);  	return state.PopPushType (1' TypeRef.NumberFrom (methEnv.Global' convi.TargetNumberFlavor)' BottomPT);  }  case InstructionFlavor.Try: {  	var tryi = (TryInstruction)instruction;  	// Isolation:  	//  - There is no way for the current stack shape to influence or be influenced by  	//    inference of the try' since the current stack shape must be empty.  	//  - There is no way for the try to influence the result stack shape' since it must be  	//    empty.  	//  - However pointers in arguments and locals may propogate into and out of try body  	//    via exceptional transitions. The latter are delt with separately.  	if (state.Depth != 0)  		throw new InvalidOperationException ("stack should be empty");  	var newState = ForwardBlock (new TryBodyInstructionContext (context' index' tryi.Body)' state' changed);  	for (var j = 0; j < tryi.Handlers.Count; j++) {  		var h = tryi.Handlers [j];  		var handlerContext = new TryHandlerInstructionContext (context' index' h.Body' j);  		var initHandlerState = new MachineState (methEnv' method.ValueParameters.Count' method.Locals.Count);  		switch (h.Flavor) {  		case HandlerFlavor.Catch: {  			var catchh = (CatchTryInstructionHandler)h;  			ForwardBlock (handlerContext' initHandlerState.PushType (catchh.Type' BottomPT)' changed);  			break;  		}  		case HandlerFlavor.Filter:  			throw new NotSupportedException ("filter handler blocks");  		case HandlerFlavor.Fault:  		case HandlerFlavor.Finally:  			ForwardBlock (handlerContext' initHandlerState' changed);  			break;  		default:  			throw new ArgumentOutOfRangeException ();  		}  	}  	return newState;  }  case InstructionFlavor.IfThenElsePseudo:  case InstructionFlavor.ShortCircuitingPseudo:  case InstructionFlavor.StructuralSwitchPseudo:  case InstructionFlavor.LoopPseudo:  case InstructionFlavor.WhileDoPseudo:  case InstructionFlavor.DoWhilePseudo:  case InstructionFlavor.LoopControlPseudo:  	throw new InvalidOperationException ("no machine state inference for psuedo-instructions");  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor) {  case InstructionFlavor.Unsupported:  	throw new InvalidOperationException ("unsupported opcode");  case InstructionFlavor.Misc: {  	var misci = (MiscInstruction)instruction;  	switch (misci.Op) {  	case MiscOp.Nop:  	case MiscOp.Break:  		return state;  	case MiscOp.Dup:  		return state.Push (state.Peek (0));  	case MiscOp.Pop:  		return state.Pop (1);  	case MiscOp.Ldnull:  		return state.PushType (global.NullRef' BottomPT);  	case MiscOp.Ckfinite:  		state.PeekExpectedType (0' global.DoubleRef' changed);  		// Assume the instruction can "peek" at top of stack' thus no need for pop/push.  		return state;  	case MiscOp.Throw:  		state.PeekReferenceType (0);  		return state.DiscardStack ();  	case MiscOp.Rethrow:  		return state.DiscardStack ();  	case MiscOp.LdindRef: {  		var elemType = state.PeekPointerToReferenceType (0);  		return state.PopPushType (1' elemType' BottomPT);  	}  	case MiscOp.StindRef: {  		var expElemType = state.PeekPointerToReferenceType (1);  		state.PeekExpectedType (0' expElemType' changed);  		return state.Pop (2);  	}  	case MiscOp.LdelemRef: {  		state.PeekIndexType (0);  		// WARNING: Type may not be final  		var elemType = state.PeekArrayOfReferenceType (1);  		return state.PopPushType (2' elemType' BottomPT);  	}  	case MiscOp.StelemRef:  		state.PeekReferenceType (0);  		state.PeekIndexType (1);  		state.PeekArrayOfReferenceType (2);  		// Since the value type and array element type may be independently generalized'  		// it is pointless to check that the first is assignable to the second.  		// Instead this check is done at runtime.  		return state.Pop (3);  	case MiscOp.Ldlen:  		state.PeekArrayOfAnyType (0);  		return state.PopPushType (1' global.IntNativeRef' BottomPT);  	case MiscOp.Ret: {  		if (state.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return state;  		// empty  	}  	case MiscOp.RetVal: {  		state.PeekExpectedType (0' method.Result.Type' changed);  		var newState = state.Pop (1);  		if (newState.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return newState;  		// empty  	}  	case MiscOp.Endfilter: {  		state.PeekExpectedType (0' global.Int32Ref' changed);  		var newState = state.Pop (1);  		if (newState.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return newState;  		// empty  	}  	case MiscOp.Endfinally: {  		// Control could transfer to an outer finally/fault block' or to the target  		// of a leave instruction. However these transitions are delt with separately.  		return state.DiscardStack ();  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Branch: {  	var bri = (BranchInstruction)instruction;  	switch (bri.Op) {  	case BranchOp.Br:  		UnifyBeforeState (state' bri.Target' changed);  		return state;  	case BranchOp.Brtrue: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.PeekIntegerOrObjectOrPointerType (0' false);  		var newState = state.Pop (1);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Brfalse: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.PeekIntegerOrObjectOrPointerType (0' true);  		var newState = state.Pop (1);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Breq:  	case BranchOp.Brne: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.Peek2ComparableTypes (0' true);  		var newState = state.Pop (2);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Leave: {  		// Control could transfer via finally blocks instead of directly to the leave target.  		// Propogate only that the stack must be empty at target. Remaining machine state  		// is dealt with separately.  		UnifyBeforeState (new MachineState (methEnv' method.ValueParameters.Count' method.Locals.Count)' bri.Target' changed);  		return state.DiscardStack ();  	}  	case BranchOp.BrLt:  	case BranchOp.BrLe:  	case BranchOp.BrGt:  	case BranchOp.BrGe: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.Peek2ComparableTypes (0' false);  		var newState = state.Pop (2);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Switch: {  	var switchi = (SwitchInstruction)instruction;  	state.PeekExpectedType (0' global.Int32Ref' changed);  	var newState = state.Pop (1);  	for (var i = 0; i < switchi.CaseTargets.Count; i++)  		UnifyBeforeState (newState' switchi.CaseTargets [i]' changed);  	return newState;  }  case InstructionFlavor.Compare: {  	var cmpi = (CompareInstruction)instruction;  	// WARNING: Capured type may not be final  	// NOTE: May capture skolemized types  	switch (cmpi.Op) {  	case CompareOp.Ceq:  	case CompareOp.CnePseudo:  		cmpi.Type = state.Peek2ComparableTypes (0' true);  		return state.PopPushType (2' global.Int32Ref' BottomPT);  	case CompareOp.Clt:  	case CompareOp.Cgt:  	case CompareOp.CgePseudo:  	case CompareOp.ClePseudo:  		cmpi.Type = state.Peek2ComparableTypes (0' false);  		return state.PopPushType (2' global.Int32Ref' BottomPT);  	case CompareOp.CtruePseudo:  	case CompareOp.CfalsePseudo:  		cmpi.Type = state.PeekIntegerOrObjectOrPointerType (0' true);  		return state.PopPushType (1' global.Int32Ref' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.ArgLocal: {  	var argi = (ArgLocalInstruction)instruction;  	var type = method.ArgLocalType (argi.ArgLocal' argi.Index);  	switch (argi.Op) {  	case ArgLocalOp.Ld:  		return state.PushType (type' state.ArgLocalPointsTo (argi.ArgLocal' argi.Index));  	case ArgLocalOp.Lda:  		return state.PushType (methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (type)' ArgLocalPT (argi.ArgLocal' argi.Index));  	case ArgLocalOp.St: {  		state.PeekExpectedType (0' type' changed);  		var pointsTo = state.PeekPointsTo (0);  		if (!pointsTo.IsBottom) {  			if (!(type.Style (methEnv) is ManagedPointerTypeStyle))  				throw new InvalidOperationException ("stack indicates pointer' but parameter or local type does not");  			if (pointsTo.PointsOutsideOfHeap)  				throw new InvalidOperationException ("arguments cannot point outside of the heap");  		}  		return state.PopAddArgLocalPointsTo (1' argi.ArgLocal' argi.Index' pointsTo);  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Field: {  	var fieldi = (FieldInstruction)instruction;  	var fieldEnv = fieldi.Field.Enter (methEnv);  	var fieldType = fieldEnv.SubstituteType (fieldEnv.Field.FieldType);  	switch (fieldi.Op) {  	case FieldOp.Ldfld:  		if (fieldi.IsStatic)  			return state.PushType (fieldType' BottomPT);  		else {  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (0' fieldi.Field.DefiningType' true' changed);  			return state.PopPushType (1' fieldType' BottomPT);  		}  	case FieldOp.Ldflda:  		if (fieldi.IsStatic)  			return state.PushType (methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (fieldType)' HeapPT);  		else {  			// Underlying type cannot be a struct' otherwise would have a pointer into  			// the stack  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (0' fieldi.Field.DefiningType' false' changed);  			return state.PopPushType (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (fieldType)' HeapPT);  		}  	case FieldOp.Stfld:  		if (fieldi.IsStatic) {  			state.PeekExpectedType (0' fieldType' changed);  			return state.Pop (1);  		}  		else {  			state.PeekExpectedType (0' fieldType' changed);  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (1' fieldi.Field.DefiningType' false' changed);  			return state.Pop (2);  		}  	case FieldOp.Ldtoken:  		return state.PushType (global.RuntimeFieldHandleRef' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Method: {  	var methi = (MethodInstruction)instruction;  	var sig = (CST.MethodSignature)methi.Method.ExternalSignature;  	switch (methi.Op) {  	case MethodOp.Call: {  		for (var i = sig.Parameters.Count - 1; i >= 1; i--)  			state.PeekExpectedType (sig.Parameters.Count - 1 - i' sig.Parameters [i]' changed);  		if (methi.Constrained != null) {  			if (!methi.IsVirtual || methi.Method.IsStatic)  				throw new InvalidOperationException ("constrained only valid on virtual calls to instance methods");  			var thisType = sig.Parameters [0];  			var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (methi.Constrained);  			var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo (methi.Constrained);  			var cs = methi.Constrained.Style (methEnv);  			if (cs is ValueTypeStyle) {  				if (thisType.Style (methEnv) is ManagedPointerTypeStyle) {  					// We pass the argument pointer as is  					if (!methi.Constrained.IsAssignableTo (methEnv' thisType.Arguments [0]))  						throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  				}  				else {  					// *Case 1* Morally we deref the argument pointer and box the contents'  					// but since no supertype of a value type may mutate the underlying value'  					// we don't need to take a copy of the value when boxing' so in practice  					// this is a no-op  					if (!constrainedBox.IsAssignableTo (methEnv' thisType))  						throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  				}  			}  			else if (cs is ReferenceTypeStyle) {  				// *Case 2* We dereference the pointer and pass the object reference  				if (!methi.Constrained.IsAssignableTo (methEnv' thisType))  					throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  			}  			else if (cs is ParameterTypeStyle) {  				// Since we are calling an instance method' we know the first argument cannot be  				// a "naked" type parameter' but is either a class or an interface.  				// We must decide between cases 1 and 2 above at runtime' but checking as  				// per case 1 is sufficient now.  				// NOTE: As for box/classcast/isinst below' if the parameter is  				// instantiated to a reference type then the type box type is considered  				// equivalent to the underyling reference type.  				if (!constrainedBox.IsAssignableTo (methEnv' thisType))  					throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  			}  			else  				throw new InvalidOperationException ("constrained must be value' reference or parameter type");  			state.PeekExpectedType (sig.Parameters.Count - 1' constrainedPtr' changed);  		}  		else if (sig.Parameters.Count > 0)  			state.PeekExpectedType (sig.Parameters.Count - 1' sig.Parameters [0]' changed);  		if (sig.Result == null)  			return state.Pop (sig.Parameters.Count);  		else  			return state.PopPushType (sig.Parameters.Count' sig.Result' BottomPT);  	}  	case MethodOp.Ldftn: {  		// NOTE: Verified CLR allows only the two "blessed" sequences:  		//   dup; ldvirtftn; newobj <delegate ctor>  		//   ldftn; newobj <delegate ctor>  		// It is thus possible to check the delegate will capture an instance which  		// implements the loaded method. However' we don't check that here.  		if (methi.IsVirtual) {  			if (methi.Method.IsStatic)  				throw new InvalidOperationException ("cannot ldvirtftn of a static method");  			var objectType = default(TypeRef);  			if (sig.Parameters [0].Style (methEnv) is ManagedPointerTypeStyle)  				// Object should be a box  				objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (sig.Parameters [0].Arguments [0]);  			else  				// Object should match parameter  				objectType = sig.Parameters [0];  			state.PeekExpectedType (0' objectType' changed);  			return state.PopPushType (1' sig.WithoutThis ().ToCodePointer (methEnv.Global)' BottomPT);  		}  		else {  			if (methi.Method.IsStatic)  				return state.PushType (sig.ToCodePointer (methEnv.Global)' BottomPT);  			else  				return state.PushType (sig.WithoutThis ().ToCodePointer (methEnv.Global)' BottomPT);  		}  	}  	case MethodOp.Newobj: {  		if (methi.Method.IsStatic || sig.Result != null)  			throw new InvalidOperationException ("not a constructor");  		for (var i = sig.Parameters.Count - 1; i >= 1; i--)  			state.PeekExpectedType (sig.Parameters.Count - 1 - i' sig.Parameters [i]' changed);  		// First argument to constructor is created by runtime. If definining type is  		// a value type' first argument will be a pointer' but result left on stack  		// will be the value itself.  		return state.PopPushType (sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);  	}  	case MethodOp.Ldtoken:  		return state.PushType (global.RuntimeMethodHandleRef' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Type: {  	var typei = (TypeInstruction)instruction;  	switch (typei.Op) {  	case TypeOp.Ldobj:  		state.PeekReadPointerType (0' typei.Type);  		return state.PopPushType (1' typei.Type' BottomPT);  	case TypeOp.Stobj:  		state.PeekExpectedType (0' typei.Type' changed);  		state.PeekWritePointerType (1' typei.Type);  		return state.Pop (2);  	case TypeOp.Cpobj:  		state.PeekReadPointerType (0' typei.Type);  		state.PeekWritePointerType (1' typei.Type);  		return state.Pop (2);  	case TypeOp.Newarr:  		state.PeekIndexType (0);  		return state.PopPushType (1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo (typei.Type)' BottomPT);  	case TypeOp.Initobj:  		state.PeekWritePointerType (0' typei.Type);  		return state.Pop (1);  	case TypeOp.Castclass:  	case TypeOp.Isinst:  	case TypeOp.Box: {  		var resultType = default(TypeRef);  		var s = typei.Type.Style (methEnv);  		if (s is NullableTypeStyle)  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type.Arguments [0]);  		else if (s is ValueTypeStyle)  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type);  		else if (s is ReferenceTypeStyle)  			resultType = typei.Type;  		else if (s is ParameterTypeStyle)  			// NOTE: As for constrained call above' if type parameter is instantitated to  			// a ref type' then this box type is considered equivalent to the  			// underlying reference type.  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type);  		else  			throw new InvalidOperationException ("can only box/cast to reference' value or parameter type");  		if (typei.Op == TypeOp.Box)  			state.PeekExpectedType (0' typei.Type' changed);  		else  			state.PeekReferenceType (0);  		return state.PopPushType (1' resultType' BottomPT);  	}  	case TypeOp.Unbox:  		if (!(typei.Type.Style (methEnv) is ValueTypeStyle))  			// Parameter types are not allowed  			throw new InvalidOperationException ("type must be a value type");  		state.PeekBoxedType (0' typei.Type' changed);  		return state.PopPushType (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (typei.Type)' HeapPT);  	case TypeOp.UnboxAny: {  		var s = typei.Type.Style (methEnv);  		if (s is ValueTypeStyle)  			state.PeekBoxedType (0' typei.Type' changed);  		else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))  			throw new InvalidOperationException ("type must be value' reference or parameter type");  		return state.PopPushType (1' typei.Type' BottomPT);  	}  	case TypeOp.Ldtoken:  		return state.PushType (global.RuntimeTypeHandleRef' BottomPT);  	case TypeOp.Ldelem:  		state.PeekIndexType (0);  		state.PeekReadArrayType (1' typei.Type' false);  		return state.PopPushType (2' typei.Type' BottomPT);  	case TypeOp.Stelem:  		state.PeekExpectedType (0' typei.Type' changed);  		state.PeekIndexType (1);  		state.PeekWriteArrayType (2' typei.Type);  		return state.Pop (3);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.LdElemAddr: {  	var ldelemai = (LdElemAddrInstruction)instruction;  	state.PeekIndexType (0);  	// WARNING: May prematurely fail for non-readonly loads  	state.PeekReadArrayType (1' ldelemai.Type' !ldelemai.IsReadonly);  	return state.PopPushType (2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (ldelemai.Type)' HeapPT);  }  case InstructionFlavor.LdInt32:  	return state.PushType (global.Int32Ref' BottomPT);  case InstructionFlavor.LdInt64:  	return state.PushType (global.Int64Ref' BottomPT);  case InstructionFlavor.LdSingle:  	return state.PushType (global.DoubleRef' BottomPT);  case InstructionFlavor.LdDouble:  	return state.PushType (global.DoubleRef' BottomPT);  case InstructionFlavor.LdString:  	return state.PushType (global.StringRef' BottomPT);  case InstructionFlavor.Arith: {  	var arithi = (ArithInstruction)instruction;  	switch (arithi.Op) {  	case ArithOp.Add:  	case ArithOp.Sub:  	case ArithOp.Mul:  	case ArithOp.Div:  	case ArithOp.Rem:  		// NOTE: May capture skolemized types  		arithi.Type = state.Peek2NumberTypes (0' true);  		return state.PopPushType (2' arithi.Type' BottomPT);  	case ArithOp.Neg:  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (0' true);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (1' arithi.Type' BottomPT);  	case ArithOp.BitAnd:  	case ArithOp.BitOr:  	case ArithOp.BitXor:  		// NOTE: May capture skolemized types  		arithi.Type = state.Peek2NumberTypes (0' false);  		return state.PopPushType (2' arithi.Type' BottomPT);  	case ArithOp.BitNot:  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (0' false);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (1' arithi.Type' BottomPT);  	case ArithOp.Shl:  	case ArithOp.Shr:  		state.PeekExpectedType (0' global.Int32Ref' changed);  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (1' false);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (2' arithi.Type' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Conv: {  	var convi = (ConvInstruction)instruction;  	var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned && convi.TargetNumberFlavor == NumberFlavor.Double);  	// NOTE: May capture skolemized types  	convi.SourceType = state.PeekNumberType (0' !mustBeInteger);  	return state.PopPushType (1' TypeRef.NumberFrom (methEnv.Global' convi.TargetNumberFlavor)' BottomPT);  }  case InstructionFlavor.Try: {  	var tryi = (TryInstruction)instruction;  	// Isolation:  	//  - There is no way for the current stack shape to influence or be influenced by  	//    inference of the try' since the current stack shape must be empty.  	//  - There is no way for the try to influence the result stack shape' since it must be  	//    empty.  	//  - However pointers in arguments and locals may propogate into and out of try body  	//    via exceptional transitions. The latter are delt with separately.  	if (state.Depth != 0)  		throw new InvalidOperationException ("stack should be empty");  	var newState = ForwardBlock (new TryBodyInstructionContext (context' index' tryi.Body)' state' changed);  	for (var j = 0; j < tryi.Handlers.Count; j++) {  		var h = tryi.Handlers [j];  		var handlerContext = new TryHandlerInstructionContext (context' index' h.Body' j);  		var initHandlerState = new MachineState (methEnv' method.ValueParameters.Count' method.Locals.Count);  		switch (h.Flavor) {  		case HandlerFlavor.Catch: {  			var catchh = (CatchTryInstructionHandler)h;  			ForwardBlock (handlerContext' initHandlerState.PushType (catchh.Type' BottomPT)' changed);  			break;  		}  		case HandlerFlavor.Filter:  			throw new NotSupportedException ("filter handler blocks");  		case HandlerFlavor.Fault:  		case HandlerFlavor.Finally:  			ForwardBlock (handlerContext' initHandlerState' changed);  			break;  		default:  			throw new ArgumentOutOfRangeException ();  		}  	}  	return newState;  }  case InstructionFlavor.IfThenElsePseudo:  case InstructionFlavor.ShortCircuitingPseudo:  case InstructionFlavor.StructuralSwitchPseudo:  case InstructionFlavor.LoopPseudo:  case InstructionFlavor.WhileDoPseudo:  case InstructionFlavor.DoWhilePseudo:  case InstructionFlavor.LoopControlPseudo:  	throw new InvalidOperationException ("no machine state inference for psuedo-instructions");  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor) {  case InstructionFlavor.Unsupported:  	throw new InvalidOperationException ("unsupported opcode");  case InstructionFlavor.Misc: {  	var misci = (MiscInstruction)instruction;  	switch (misci.Op) {  	case MiscOp.Nop:  	case MiscOp.Break:  		return state;  	case MiscOp.Dup:  		return state.Push (state.Peek (0));  	case MiscOp.Pop:  		return state.Pop (1);  	case MiscOp.Ldnull:  		return state.PushType (global.NullRef' BottomPT);  	case MiscOp.Ckfinite:  		state.PeekExpectedType (0' global.DoubleRef' changed);  		// Assume the instruction can "peek" at top of stack' thus no need for pop/push.  		return state;  	case MiscOp.Throw:  		state.PeekReferenceType (0);  		return state.DiscardStack ();  	case MiscOp.Rethrow:  		return state.DiscardStack ();  	case MiscOp.LdindRef: {  		var elemType = state.PeekPointerToReferenceType (0);  		return state.PopPushType (1' elemType' BottomPT);  	}  	case MiscOp.StindRef: {  		var expElemType = state.PeekPointerToReferenceType (1);  		state.PeekExpectedType (0' expElemType' changed);  		return state.Pop (2);  	}  	case MiscOp.LdelemRef: {  		state.PeekIndexType (0);  		// WARNING: Type may not be final  		var elemType = state.PeekArrayOfReferenceType (1);  		return state.PopPushType (2' elemType' BottomPT);  	}  	case MiscOp.StelemRef:  		state.PeekReferenceType (0);  		state.PeekIndexType (1);  		state.PeekArrayOfReferenceType (2);  		// Since the value type and array element type may be independently generalized'  		// it is pointless to check that the first is assignable to the second.  		// Instead this check is done at runtime.  		return state.Pop (3);  	case MiscOp.Ldlen:  		state.PeekArrayOfAnyType (0);  		return state.PopPushType (1' global.IntNativeRef' BottomPT);  	case MiscOp.Ret: {  		if (state.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return state;  		// empty  	}  	case MiscOp.RetVal: {  		state.PeekExpectedType (0' method.Result.Type' changed);  		var newState = state.Pop (1);  		if (newState.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return newState;  		// empty  	}  	case MiscOp.Endfilter: {  		state.PeekExpectedType (0' global.Int32Ref' changed);  		var newState = state.Pop (1);  		if (newState.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return newState;  		// empty  	}  	case MiscOp.Endfinally: {  		// Control could transfer to an outer finally/fault block' or to the target  		// of a leave instruction. However these transitions are delt with separately.  		return state.DiscardStack ();  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Branch: {  	var bri = (BranchInstruction)instruction;  	switch (bri.Op) {  	case BranchOp.Br:  		UnifyBeforeState (state' bri.Target' changed);  		return state;  	case BranchOp.Brtrue: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.PeekIntegerOrObjectOrPointerType (0' false);  		var newState = state.Pop (1);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Brfalse: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.PeekIntegerOrObjectOrPointerType (0' true);  		var newState = state.Pop (1);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Breq:  	case BranchOp.Brne: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.Peek2ComparableTypes (0' true);  		var newState = state.Pop (2);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Leave: {  		// Control could transfer via finally blocks instead of directly to the leave target.  		// Propogate only that the stack must be empty at target. Remaining machine state  		// is dealt with separately.  		UnifyBeforeState (new MachineState (methEnv' method.ValueParameters.Count' method.Locals.Count)' bri.Target' changed);  		return state.DiscardStack ();  	}  	case BranchOp.BrLt:  	case BranchOp.BrLe:  	case BranchOp.BrGt:  	case BranchOp.BrGe: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.Peek2ComparableTypes (0' false);  		var newState = state.Pop (2);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Switch: {  	var switchi = (SwitchInstruction)instruction;  	state.PeekExpectedType (0' global.Int32Ref' changed);  	var newState = state.Pop (1);  	for (var i = 0; i < switchi.CaseTargets.Count; i++)  		UnifyBeforeState (newState' switchi.CaseTargets [i]' changed);  	return newState;  }  case InstructionFlavor.Compare: {  	var cmpi = (CompareInstruction)instruction;  	// WARNING: Capured type may not be final  	// NOTE: May capture skolemized types  	switch (cmpi.Op) {  	case CompareOp.Ceq:  	case CompareOp.CnePseudo:  		cmpi.Type = state.Peek2ComparableTypes (0' true);  		return state.PopPushType (2' global.Int32Ref' BottomPT);  	case CompareOp.Clt:  	case CompareOp.Cgt:  	case CompareOp.CgePseudo:  	case CompareOp.ClePseudo:  		cmpi.Type = state.Peek2ComparableTypes (0' false);  		return state.PopPushType (2' global.Int32Ref' BottomPT);  	case CompareOp.CtruePseudo:  	case CompareOp.CfalsePseudo:  		cmpi.Type = state.PeekIntegerOrObjectOrPointerType (0' true);  		return state.PopPushType (1' global.Int32Ref' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.ArgLocal: {  	var argi = (ArgLocalInstruction)instruction;  	var type = method.ArgLocalType (argi.ArgLocal' argi.Index);  	switch (argi.Op) {  	case ArgLocalOp.Ld:  		return state.PushType (type' state.ArgLocalPointsTo (argi.ArgLocal' argi.Index));  	case ArgLocalOp.Lda:  		return state.PushType (methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (type)' ArgLocalPT (argi.ArgLocal' argi.Index));  	case ArgLocalOp.St: {  		state.PeekExpectedType (0' type' changed);  		var pointsTo = state.PeekPointsTo (0);  		if (!pointsTo.IsBottom) {  			if (!(type.Style (methEnv) is ManagedPointerTypeStyle))  				throw new InvalidOperationException ("stack indicates pointer' but parameter or local type does not");  			if (pointsTo.PointsOutsideOfHeap)  				throw new InvalidOperationException ("arguments cannot point outside of the heap");  		}  		return state.PopAddArgLocalPointsTo (1' argi.ArgLocal' argi.Index' pointsTo);  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Field: {  	var fieldi = (FieldInstruction)instruction;  	var fieldEnv = fieldi.Field.Enter (methEnv);  	var fieldType = fieldEnv.SubstituteType (fieldEnv.Field.FieldType);  	switch (fieldi.Op) {  	case FieldOp.Ldfld:  		if (fieldi.IsStatic)  			return state.PushType (fieldType' BottomPT);  		else {  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (0' fieldi.Field.DefiningType' true' changed);  			return state.PopPushType (1' fieldType' BottomPT);  		}  	case FieldOp.Ldflda:  		if (fieldi.IsStatic)  			return state.PushType (methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (fieldType)' HeapPT);  		else {  			// Underlying type cannot be a struct' otherwise would have a pointer into  			// the stack  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (0' fieldi.Field.DefiningType' false' changed);  			return state.PopPushType (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (fieldType)' HeapPT);  		}  	case FieldOp.Stfld:  		if (fieldi.IsStatic) {  			state.PeekExpectedType (0' fieldType' changed);  			return state.Pop (1);  		}  		else {  			state.PeekExpectedType (0' fieldType' changed);  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (1' fieldi.Field.DefiningType' false' changed);  			return state.Pop (2);  		}  	case FieldOp.Ldtoken:  		return state.PushType (global.RuntimeFieldHandleRef' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Method: {  	var methi = (MethodInstruction)instruction;  	var sig = (CST.MethodSignature)methi.Method.ExternalSignature;  	switch (methi.Op) {  	case MethodOp.Call: {  		for (var i = sig.Parameters.Count - 1; i >= 1; i--)  			state.PeekExpectedType (sig.Parameters.Count - 1 - i' sig.Parameters [i]' changed);  		if (methi.Constrained != null) {  			if (!methi.IsVirtual || methi.Method.IsStatic)  				throw new InvalidOperationException ("constrained only valid on virtual calls to instance methods");  			var thisType = sig.Parameters [0];  			var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (methi.Constrained);  			var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo (methi.Constrained);  			var cs = methi.Constrained.Style (methEnv);  			if (cs is ValueTypeStyle) {  				if (thisType.Style (methEnv) is ManagedPointerTypeStyle) {  					// We pass the argument pointer as is  					if (!methi.Constrained.IsAssignableTo (methEnv' thisType.Arguments [0]))  						throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  				}  				else {  					// *Case 1* Morally we deref the argument pointer and box the contents'  					// but since no supertype of a value type may mutate the underlying value'  					// we don't need to take a copy of the value when boxing' so in practice  					// this is a no-op  					if (!constrainedBox.IsAssignableTo (methEnv' thisType))  						throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  				}  			}  			else if (cs is ReferenceTypeStyle) {  				// *Case 2* We dereference the pointer and pass the object reference  				if (!methi.Constrained.IsAssignableTo (methEnv' thisType))  					throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  			}  			else if (cs is ParameterTypeStyle) {  				// Since we are calling an instance method' we know the first argument cannot be  				// a "naked" type parameter' but is either a class or an interface.  				// We must decide between cases 1 and 2 above at runtime' but checking as  				// per case 1 is sufficient now.  				// NOTE: As for box/classcast/isinst below' if the parameter is  				// instantiated to a reference type then the type box type is considered  				// equivalent to the underyling reference type.  				if (!constrainedBox.IsAssignableTo (methEnv' thisType))  					throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  			}  			else  				throw new InvalidOperationException ("constrained must be value' reference or parameter type");  			state.PeekExpectedType (sig.Parameters.Count - 1' constrainedPtr' changed);  		}  		else if (sig.Parameters.Count > 0)  			state.PeekExpectedType (sig.Parameters.Count - 1' sig.Parameters [0]' changed);  		if (sig.Result == null)  			return state.Pop (sig.Parameters.Count);  		else  			return state.PopPushType (sig.Parameters.Count' sig.Result' BottomPT);  	}  	case MethodOp.Ldftn: {  		// NOTE: Verified CLR allows only the two "blessed" sequences:  		//   dup; ldvirtftn; newobj <delegate ctor>  		//   ldftn; newobj <delegate ctor>  		// It is thus possible to check the delegate will capture an instance which  		// implements the loaded method. However' we don't check that here.  		if (methi.IsVirtual) {  			if (methi.Method.IsStatic)  				throw new InvalidOperationException ("cannot ldvirtftn of a static method");  			var objectType = default(TypeRef);  			if (sig.Parameters [0].Style (methEnv) is ManagedPointerTypeStyle)  				// Object should be a box  				objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (sig.Parameters [0].Arguments [0]);  			else  				// Object should match parameter  				objectType = sig.Parameters [0];  			state.PeekExpectedType (0' objectType' changed);  			return state.PopPushType (1' sig.WithoutThis ().ToCodePointer (methEnv.Global)' BottomPT);  		}  		else {  			if (methi.Method.IsStatic)  				return state.PushType (sig.ToCodePointer (methEnv.Global)' BottomPT);  			else  				return state.PushType (sig.WithoutThis ().ToCodePointer (methEnv.Global)' BottomPT);  		}  	}  	case MethodOp.Newobj: {  		if (methi.Method.IsStatic || sig.Result != null)  			throw new InvalidOperationException ("not a constructor");  		for (var i = sig.Parameters.Count - 1; i >= 1; i--)  			state.PeekExpectedType (sig.Parameters.Count - 1 - i' sig.Parameters [i]' changed);  		// First argument to constructor is created by runtime. If definining type is  		// a value type' first argument will be a pointer' but result left on stack  		// will be the value itself.  		return state.PopPushType (sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);  	}  	case MethodOp.Ldtoken:  		return state.PushType (global.RuntimeMethodHandleRef' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Type: {  	var typei = (TypeInstruction)instruction;  	switch (typei.Op) {  	case TypeOp.Ldobj:  		state.PeekReadPointerType (0' typei.Type);  		return state.PopPushType (1' typei.Type' BottomPT);  	case TypeOp.Stobj:  		state.PeekExpectedType (0' typei.Type' changed);  		state.PeekWritePointerType (1' typei.Type);  		return state.Pop (2);  	case TypeOp.Cpobj:  		state.PeekReadPointerType (0' typei.Type);  		state.PeekWritePointerType (1' typei.Type);  		return state.Pop (2);  	case TypeOp.Newarr:  		state.PeekIndexType (0);  		return state.PopPushType (1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo (typei.Type)' BottomPT);  	case TypeOp.Initobj:  		state.PeekWritePointerType (0' typei.Type);  		return state.Pop (1);  	case TypeOp.Castclass:  	case TypeOp.Isinst:  	case TypeOp.Box: {  		var resultType = default(TypeRef);  		var s = typei.Type.Style (methEnv);  		if (s is NullableTypeStyle)  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type.Arguments [0]);  		else if (s is ValueTypeStyle)  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type);  		else if (s is ReferenceTypeStyle)  			resultType = typei.Type;  		else if (s is ParameterTypeStyle)  			// NOTE: As for constrained call above' if type parameter is instantitated to  			// a ref type' then this box type is considered equivalent to the  			// underlying reference type.  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type);  		else  			throw new InvalidOperationException ("can only box/cast to reference' value or parameter type");  		if (typei.Op == TypeOp.Box)  			state.PeekExpectedType (0' typei.Type' changed);  		else  			state.PeekReferenceType (0);  		return state.PopPushType (1' resultType' BottomPT);  	}  	case TypeOp.Unbox:  		if (!(typei.Type.Style (methEnv) is ValueTypeStyle))  			// Parameter types are not allowed  			throw new InvalidOperationException ("type must be a value type");  		state.PeekBoxedType (0' typei.Type' changed);  		return state.PopPushType (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (typei.Type)' HeapPT);  	case TypeOp.UnboxAny: {  		var s = typei.Type.Style (methEnv);  		if (s is ValueTypeStyle)  			state.PeekBoxedType (0' typei.Type' changed);  		else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))  			throw new InvalidOperationException ("type must be value' reference or parameter type");  		return state.PopPushType (1' typei.Type' BottomPT);  	}  	case TypeOp.Ldtoken:  		return state.PushType (global.RuntimeTypeHandleRef' BottomPT);  	case TypeOp.Ldelem:  		state.PeekIndexType (0);  		state.PeekReadArrayType (1' typei.Type' false);  		return state.PopPushType (2' typei.Type' BottomPT);  	case TypeOp.Stelem:  		state.PeekExpectedType (0' typei.Type' changed);  		state.PeekIndexType (1);  		state.PeekWriteArrayType (2' typei.Type);  		return state.Pop (3);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.LdElemAddr: {  	var ldelemai = (LdElemAddrInstruction)instruction;  	state.PeekIndexType (0);  	// WARNING: May prematurely fail for non-readonly loads  	state.PeekReadArrayType (1' ldelemai.Type' !ldelemai.IsReadonly);  	return state.PopPushType (2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (ldelemai.Type)' HeapPT);  }  case InstructionFlavor.LdInt32:  	return state.PushType (global.Int32Ref' BottomPT);  case InstructionFlavor.LdInt64:  	return state.PushType (global.Int64Ref' BottomPT);  case InstructionFlavor.LdSingle:  	return state.PushType (global.DoubleRef' BottomPT);  case InstructionFlavor.LdDouble:  	return state.PushType (global.DoubleRef' BottomPT);  case InstructionFlavor.LdString:  	return state.PushType (global.StringRef' BottomPT);  case InstructionFlavor.Arith: {  	var arithi = (ArithInstruction)instruction;  	switch (arithi.Op) {  	case ArithOp.Add:  	case ArithOp.Sub:  	case ArithOp.Mul:  	case ArithOp.Div:  	case ArithOp.Rem:  		// NOTE: May capture skolemized types  		arithi.Type = state.Peek2NumberTypes (0' true);  		return state.PopPushType (2' arithi.Type' BottomPT);  	case ArithOp.Neg:  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (0' true);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (1' arithi.Type' BottomPT);  	case ArithOp.BitAnd:  	case ArithOp.BitOr:  	case ArithOp.BitXor:  		// NOTE: May capture skolemized types  		arithi.Type = state.Peek2NumberTypes (0' false);  		return state.PopPushType (2' arithi.Type' BottomPT);  	case ArithOp.BitNot:  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (0' false);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (1' arithi.Type' BottomPT);  	case ArithOp.Shl:  	case ArithOp.Shr:  		state.PeekExpectedType (0' global.Int32Ref' changed);  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (1' false);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (2' arithi.Type' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Conv: {  	var convi = (ConvInstruction)instruction;  	var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned && convi.TargetNumberFlavor == NumberFlavor.Double);  	// NOTE: May capture skolemized types  	convi.SourceType = state.PeekNumberType (0' !mustBeInteger);  	return state.PopPushType (1' TypeRef.NumberFrom (methEnv.Global' convi.TargetNumberFlavor)' BottomPT);  }  case InstructionFlavor.Try: {  	var tryi = (TryInstruction)instruction;  	// Isolation:  	//  - There is no way for the current stack shape to influence or be influenced by  	//    inference of the try' since the current stack shape must be empty.  	//  - There is no way for the try to influence the result stack shape' since it must be  	//    empty.  	//  - However pointers in arguments and locals may propogate into and out of try body  	//    via exceptional transitions. The latter are delt with separately.  	if (state.Depth != 0)  		throw new InvalidOperationException ("stack should be empty");  	var newState = ForwardBlock (new TryBodyInstructionContext (context' index' tryi.Body)' state' changed);  	for (var j = 0; j < tryi.Handlers.Count; j++) {  		var h = tryi.Handlers [j];  		var handlerContext = new TryHandlerInstructionContext (context' index' h.Body' j);  		var initHandlerState = new MachineState (methEnv' method.ValueParameters.Count' method.Locals.Count);  		switch (h.Flavor) {  		case HandlerFlavor.Catch: {  			var catchh = (CatchTryInstructionHandler)h;  			ForwardBlock (handlerContext' initHandlerState.PushType (catchh.Type' BottomPT)' changed);  			break;  		}  		case HandlerFlavor.Filter:  			throw new NotSupportedException ("filter handler blocks");  		case HandlerFlavor.Fault:  		case HandlerFlavor.Finally:  			ForwardBlock (handlerContext' initHandlerState' changed);  			break;  		default:  			throw new ArgumentOutOfRangeException ();  		}  	}  	return newState;  }  case InstructionFlavor.IfThenElsePseudo:  case InstructionFlavor.ShortCircuitingPseudo:  case InstructionFlavor.StructuralSwitchPseudo:  case InstructionFlavor.LoopPseudo:  case InstructionFlavor.WhileDoPseudo:  case InstructionFlavor.DoWhilePseudo:  case InstructionFlavor.LoopControlPseudo:  	throw new InvalidOperationException ("no machine state inference for psuedo-instructions");  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor) {  case InstructionFlavor.Unsupported:  	throw new InvalidOperationException ("unsupported opcode");  case InstructionFlavor.Misc: {  	var misci = (MiscInstruction)instruction;  	switch (misci.Op) {  	case MiscOp.Nop:  	case MiscOp.Break:  		return state;  	case MiscOp.Dup:  		return state.Push (state.Peek (0));  	case MiscOp.Pop:  		return state.Pop (1);  	case MiscOp.Ldnull:  		return state.PushType (global.NullRef' BottomPT);  	case MiscOp.Ckfinite:  		state.PeekExpectedType (0' global.DoubleRef' changed);  		// Assume the instruction can "peek" at top of stack' thus no need for pop/push.  		return state;  	case MiscOp.Throw:  		state.PeekReferenceType (0);  		return state.DiscardStack ();  	case MiscOp.Rethrow:  		return state.DiscardStack ();  	case MiscOp.LdindRef: {  		var elemType = state.PeekPointerToReferenceType (0);  		return state.PopPushType (1' elemType' BottomPT);  	}  	case MiscOp.StindRef: {  		var expElemType = state.PeekPointerToReferenceType (1);  		state.PeekExpectedType (0' expElemType' changed);  		return state.Pop (2);  	}  	case MiscOp.LdelemRef: {  		state.PeekIndexType (0);  		// WARNING: Type may not be final  		var elemType = state.PeekArrayOfReferenceType (1);  		return state.PopPushType (2' elemType' BottomPT);  	}  	case MiscOp.StelemRef:  		state.PeekReferenceType (0);  		state.PeekIndexType (1);  		state.PeekArrayOfReferenceType (2);  		// Since the value type and array element type may be independently generalized'  		// it is pointless to check that the first is assignable to the second.  		// Instead this check is done at runtime.  		return state.Pop (3);  	case MiscOp.Ldlen:  		state.PeekArrayOfAnyType (0);  		return state.PopPushType (1' global.IntNativeRef' BottomPT);  	case MiscOp.Ret: {  		if (state.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return state;  		// empty  	}  	case MiscOp.RetVal: {  		state.PeekExpectedType (0' method.Result.Type' changed);  		var newState = state.Pop (1);  		if (newState.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return newState;  		// empty  	}  	case MiscOp.Endfilter: {  		state.PeekExpectedType (0' global.Int32Ref' changed);  		var newState = state.Pop (1);  		if (newState.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return newState;  		// empty  	}  	case MiscOp.Endfinally: {  		// Control could transfer to an outer finally/fault block' or to the target  		// of a leave instruction. However these transitions are delt with separately.  		return state.DiscardStack ();  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Branch: {  	var bri = (BranchInstruction)instruction;  	switch (bri.Op) {  	case BranchOp.Br:  		UnifyBeforeState (state' bri.Target' changed);  		return state;  	case BranchOp.Brtrue: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.PeekIntegerOrObjectOrPointerType (0' false);  		var newState = state.Pop (1);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Brfalse: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.PeekIntegerOrObjectOrPointerType (0' true);  		var newState = state.Pop (1);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Breq:  	case BranchOp.Brne: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.Peek2ComparableTypes (0' true);  		var newState = state.Pop (2);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Leave: {  		// Control could transfer via finally blocks instead of directly to the leave target.  		// Propogate only that the stack must be empty at target. Remaining machine state  		// is dealt with separately.  		UnifyBeforeState (new MachineState (methEnv' method.ValueParameters.Count' method.Locals.Count)' bri.Target' changed);  		return state.DiscardStack ();  	}  	case BranchOp.BrLt:  	case BranchOp.BrLe:  	case BranchOp.BrGt:  	case BranchOp.BrGe: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.Peek2ComparableTypes (0' false);  		var newState = state.Pop (2);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Switch: {  	var switchi = (SwitchInstruction)instruction;  	state.PeekExpectedType (0' global.Int32Ref' changed);  	var newState = state.Pop (1);  	for (var i = 0; i < switchi.CaseTargets.Count; i++)  		UnifyBeforeState (newState' switchi.CaseTargets [i]' changed);  	return newState;  }  case InstructionFlavor.Compare: {  	var cmpi = (CompareInstruction)instruction;  	// WARNING: Capured type may not be final  	// NOTE: May capture skolemized types  	switch (cmpi.Op) {  	case CompareOp.Ceq:  	case CompareOp.CnePseudo:  		cmpi.Type = state.Peek2ComparableTypes (0' true);  		return state.PopPushType (2' global.Int32Ref' BottomPT);  	case CompareOp.Clt:  	case CompareOp.Cgt:  	case CompareOp.CgePseudo:  	case CompareOp.ClePseudo:  		cmpi.Type = state.Peek2ComparableTypes (0' false);  		return state.PopPushType (2' global.Int32Ref' BottomPT);  	case CompareOp.CtruePseudo:  	case CompareOp.CfalsePseudo:  		cmpi.Type = state.PeekIntegerOrObjectOrPointerType (0' true);  		return state.PopPushType (1' global.Int32Ref' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.ArgLocal: {  	var argi = (ArgLocalInstruction)instruction;  	var type = method.ArgLocalType (argi.ArgLocal' argi.Index);  	switch (argi.Op) {  	case ArgLocalOp.Ld:  		return state.PushType (type' state.ArgLocalPointsTo (argi.ArgLocal' argi.Index));  	case ArgLocalOp.Lda:  		return state.PushType (methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (type)' ArgLocalPT (argi.ArgLocal' argi.Index));  	case ArgLocalOp.St: {  		state.PeekExpectedType (0' type' changed);  		var pointsTo = state.PeekPointsTo (0);  		if (!pointsTo.IsBottom) {  			if (!(type.Style (methEnv) is ManagedPointerTypeStyle))  				throw new InvalidOperationException ("stack indicates pointer' but parameter or local type does not");  			if (pointsTo.PointsOutsideOfHeap)  				throw new InvalidOperationException ("arguments cannot point outside of the heap");  		}  		return state.PopAddArgLocalPointsTo (1' argi.ArgLocal' argi.Index' pointsTo);  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Field: {  	var fieldi = (FieldInstruction)instruction;  	var fieldEnv = fieldi.Field.Enter (methEnv);  	var fieldType = fieldEnv.SubstituteType (fieldEnv.Field.FieldType);  	switch (fieldi.Op) {  	case FieldOp.Ldfld:  		if (fieldi.IsStatic)  			return state.PushType (fieldType' BottomPT);  		else {  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (0' fieldi.Field.DefiningType' true' changed);  			return state.PopPushType (1' fieldType' BottomPT);  		}  	case FieldOp.Ldflda:  		if (fieldi.IsStatic)  			return state.PushType (methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (fieldType)' HeapPT);  		else {  			// Underlying type cannot be a struct' otherwise would have a pointer into  			// the stack  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (0' fieldi.Field.DefiningType' false' changed);  			return state.PopPushType (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (fieldType)' HeapPT);  		}  	case FieldOp.Stfld:  		if (fieldi.IsStatic) {  			state.PeekExpectedType (0' fieldType' changed);  			return state.Pop (1);  		}  		else {  			state.PeekExpectedType (0' fieldType' changed);  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (1' fieldi.Field.DefiningType' false' changed);  			return state.Pop (2);  		}  	case FieldOp.Ldtoken:  		return state.PushType (global.RuntimeFieldHandleRef' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Method: {  	var methi = (MethodInstruction)instruction;  	var sig = (CST.MethodSignature)methi.Method.ExternalSignature;  	switch (methi.Op) {  	case MethodOp.Call: {  		for (var i = sig.Parameters.Count - 1; i >= 1; i--)  			state.PeekExpectedType (sig.Parameters.Count - 1 - i' sig.Parameters [i]' changed);  		if (methi.Constrained != null) {  			if (!methi.IsVirtual || methi.Method.IsStatic)  				throw new InvalidOperationException ("constrained only valid on virtual calls to instance methods");  			var thisType = sig.Parameters [0];  			var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (methi.Constrained);  			var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo (methi.Constrained);  			var cs = methi.Constrained.Style (methEnv);  			if (cs is ValueTypeStyle) {  				if (thisType.Style (methEnv) is ManagedPointerTypeStyle) {  					// We pass the argument pointer as is  					if (!methi.Constrained.IsAssignableTo (methEnv' thisType.Arguments [0]))  						throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  				}  				else {  					// *Case 1* Morally we deref the argument pointer and box the contents'  					// but since no supertype of a value type may mutate the underlying value'  					// we don't need to take a copy of the value when boxing' so in practice  					// this is a no-op  					if (!constrainedBox.IsAssignableTo (methEnv' thisType))  						throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  				}  			}  			else if (cs is ReferenceTypeStyle) {  				// *Case 2* We dereference the pointer and pass the object reference  				if (!methi.Constrained.IsAssignableTo (methEnv' thisType))  					throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  			}  			else if (cs is ParameterTypeStyle) {  				// Since we are calling an instance method' we know the first argument cannot be  				// a "naked" type parameter' but is either a class or an interface.  				// We must decide between cases 1 and 2 above at runtime' but checking as  				// per case 1 is sufficient now.  				// NOTE: As for box/classcast/isinst below' if the parameter is  				// instantiated to a reference type then the type box type is considered  				// equivalent to the underyling reference type.  				if (!constrainedBox.IsAssignableTo (methEnv' thisType))  					throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  			}  			else  				throw new InvalidOperationException ("constrained must be value' reference or parameter type");  			state.PeekExpectedType (sig.Parameters.Count - 1' constrainedPtr' changed);  		}  		else if (sig.Parameters.Count > 0)  			state.PeekExpectedType (sig.Parameters.Count - 1' sig.Parameters [0]' changed);  		if (sig.Result == null)  			return state.Pop (sig.Parameters.Count);  		else  			return state.PopPushType (sig.Parameters.Count' sig.Result' BottomPT);  	}  	case MethodOp.Ldftn: {  		// NOTE: Verified CLR allows only the two "blessed" sequences:  		//   dup; ldvirtftn; newobj <delegate ctor>  		//   ldftn; newobj <delegate ctor>  		// It is thus possible to check the delegate will capture an instance which  		// implements the loaded method. However' we don't check that here.  		if (methi.IsVirtual) {  			if (methi.Method.IsStatic)  				throw new InvalidOperationException ("cannot ldvirtftn of a static method");  			var objectType = default(TypeRef);  			if (sig.Parameters [0].Style (methEnv) is ManagedPointerTypeStyle)  				// Object should be a box  				objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (sig.Parameters [0].Arguments [0]);  			else  				// Object should match parameter  				objectType = sig.Parameters [0];  			state.PeekExpectedType (0' objectType' changed);  			return state.PopPushType (1' sig.WithoutThis ().ToCodePointer (methEnv.Global)' BottomPT);  		}  		else {  			if (methi.Method.IsStatic)  				return state.PushType (sig.ToCodePointer (methEnv.Global)' BottomPT);  			else  				return state.PushType (sig.WithoutThis ().ToCodePointer (methEnv.Global)' BottomPT);  		}  	}  	case MethodOp.Newobj: {  		if (methi.Method.IsStatic || sig.Result != null)  			throw new InvalidOperationException ("not a constructor");  		for (var i = sig.Parameters.Count - 1; i >= 1; i--)  			state.PeekExpectedType (sig.Parameters.Count - 1 - i' sig.Parameters [i]' changed);  		// First argument to constructor is created by runtime. If definining type is  		// a value type' first argument will be a pointer' but result left on stack  		// will be the value itself.  		return state.PopPushType (sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);  	}  	case MethodOp.Ldtoken:  		return state.PushType (global.RuntimeMethodHandleRef' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Type: {  	var typei = (TypeInstruction)instruction;  	switch (typei.Op) {  	case TypeOp.Ldobj:  		state.PeekReadPointerType (0' typei.Type);  		return state.PopPushType (1' typei.Type' BottomPT);  	case TypeOp.Stobj:  		state.PeekExpectedType (0' typei.Type' changed);  		state.PeekWritePointerType (1' typei.Type);  		return state.Pop (2);  	case TypeOp.Cpobj:  		state.PeekReadPointerType (0' typei.Type);  		state.PeekWritePointerType (1' typei.Type);  		return state.Pop (2);  	case TypeOp.Newarr:  		state.PeekIndexType (0);  		return state.PopPushType (1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo (typei.Type)' BottomPT);  	case TypeOp.Initobj:  		state.PeekWritePointerType (0' typei.Type);  		return state.Pop (1);  	case TypeOp.Castclass:  	case TypeOp.Isinst:  	case TypeOp.Box: {  		var resultType = default(TypeRef);  		var s = typei.Type.Style (methEnv);  		if (s is NullableTypeStyle)  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type.Arguments [0]);  		else if (s is ValueTypeStyle)  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type);  		else if (s is ReferenceTypeStyle)  			resultType = typei.Type;  		else if (s is ParameterTypeStyle)  			// NOTE: As for constrained call above' if type parameter is instantitated to  			// a ref type' then this box type is considered equivalent to the  			// underlying reference type.  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type);  		else  			throw new InvalidOperationException ("can only box/cast to reference' value or parameter type");  		if (typei.Op == TypeOp.Box)  			state.PeekExpectedType (0' typei.Type' changed);  		else  			state.PeekReferenceType (0);  		return state.PopPushType (1' resultType' BottomPT);  	}  	case TypeOp.Unbox:  		if (!(typei.Type.Style (methEnv) is ValueTypeStyle))  			// Parameter types are not allowed  			throw new InvalidOperationException ("type must be a value type");  		state.PeekBoxedType (0' typei.Type' changed);  		return state.PopPushType (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (typei.Type)' HeapPT);  	case TypeOp.UnboxAny: {  		var s = typei.Type.Style (methEnv);  		if (s is ValueTypeStyle)  			state.PeekBoxedType (0' typei.Type' changed);  		else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))  			throw new InvalidOperationException ("type must be value' reference or parameter type");  		return state.PopPushType (1' typei.Type' BottomPT);  	}  	case TypeOp.Ldtoken:  		return state.PushType (global.RuntimeTypeHandleRef' BottomPT);  	case TypeOp.Ldelem:  		state.PeekIndexType (0);  		state.PeekReadArrayType (1' typei.Type' false);  		return state.PopPushType (2' typei.Type' BottomPT);  	case TypeOp.Stelem:  		state.PeekExpectedType (0' typei.Type' changed);  		state.PeekIndexType (1);  		state.PeekWriteArrayType (2' typei.Type);  		return state.Pop (3);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.LdElemAddr: {  	var ldelemai = (LdElemAddrInstruction)instruction;  	state.PeekIndexType (0);  	// WARNING: May prematurely fail for non-readonly loads  	state.PeekReadArrayType (1' ldelemai.Type' !ldelemai.IsReadonly);  	return state.PopPushType (2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (ldelemai.Type)' HeapPT);  }  case InstructionFlavor.LdInt32:  	return state.PushType (global.Int32Ref' BottomPT);  case InstructionFlavor.LdInt64:  	return state.PushType (global.Int64Ref' BottomPT);  case InstructionFlavor.LdSingle:  	return state.PushType (global.DoubleRef' BottomPT);  case InstructionFlavor.LdDouble:  	return state.PushType (global.DoubleRef' BottomPT);  case InstructionFlavor.LdString:  	return state.PushType (global.StringRef' BottomPT);  case InstructionFlavor.Arith: {  	var arithi = (ArithInstruction)instruction;  	switch (arithi.Op) {  	case ArithOp.Add:  	case ArithOp.Sub:  	case ArithOp.Mul:  	case ArithOp.Div:  	case ArithOp.Rem:  		// NOTE: May capture skolemized types  		arithi.Type = state.Peek2NumberTypes (0' true);  		return state.PopPushType (2' arithi.Type' BottomPT);  	case ArithOp.Neg:  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (0' true);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (1' arithi.Type' BottomPT);  	case ArithOp.BitAnd:  	case ArithOp.BitOr:  	case ArithOp.BitXor:  		// NOTE: May capture skolemized types  		arithi.Type = state.Peek2NumberTypes (0' false);  		return state.PopPushType (2' arithi.Type' BottomPT);  	case ArithOp.BitNot:  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (0' false);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (1' arithi.Type' BottomPT);  	case ArithOp.Shl:  	case ArithOp.Shr:  		state.PeekExpectedType (0' global.Int32Ref' changed);  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (1' false);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (2' arithi.Type' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Conv: {  	var convi = (ConvInstruction)instruction;  	var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned && convi.TargetNumberFlavor == NumberFlavor.Double);  	// NOTE: May capture skolemized types  	convi.SourceType = state.PeekNumberType (0' !mustBeInteger);  	return state.PopPushType (1' TypeRef.NumberFrom (methEnv.Global' convi.TargetNumberFlavor)' BottomPT);  }  case InstructionFlavor.Try: {  	var tryi = (TryInstruction)instruction;  	// Isolation:  	//  - There is no way for the current stack shape to influence or be influenced by  	//    inference of the try' since the current stack shape must be empty.  	//  - There is no way for the try to influence the result stack shape' since it must be  	//    empty.  	//  - However pointers in arguments and locals may propogate into and out of try body  	//    via exceptional transitions. The latter are delt with separately.  	if (state.Depth != 0)  		throw new InvalidOperationException ("stack should be empty");  	var newState = ForwardBlock (new TryBodyInstructionContext (context' index' tryi.Body)' state' changed);  	for (var j = 0; j < tryi.Handlers.Count; j++) {  		var h = tryi.Handlers [j];  		var handlerContext = new TryHandlerInstructionContext (context' index' h.Body' j);  		var initHandlerState = new MachineState (methEnv' method.ValueParameters.Count' method.Locals.Count);  		switch (h.Flavor) {  		case HandlerFlavor.Catch: {  			var catchh = (CatchTryInstructionHandler)h;  			ForwardBlock (handlerContext' initHandlerState.PushType (catchh.Type' BottomPT)' changed);  			break;  		}  		case HandlerFlavor.Filter:  			throw new NotSupportedException ("filter handler blocks");  		case HandlerFlavor.Fault:  		case HandlerFlavor.Finally:  			ForwardBlock (handlerContext' initHandlerState' changed);  			break;  		default:  			throw new ArgumentOutOfRangeException ();  		}  	}  	return newState;  }  case InstructionFlavor.IfThenElsePseudo:  case InstructionFlavor.ShortCircuitingPseudo:  case InstructionFlavor.StructuralSwitchPseudo:  case InstructionFlavor.LoopPseudo:  case InstructionFlavor.WhileDoPseudo:  case InstructionFlavor.DoWhilePseudo:  case InstructionFlavor.LoopControlPseudo:  	throw new InvalidOperationException ("no machine state inference for psuedo-instructions");  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor) {  case InstructionFlavor.Unsupported:  	throw new InvalidOperationException ("unsupported opcode");  case InstructionFlavor.Misc: {  	var misci = (MiscInstruction)instruction;  	switch (misci.Op) {  	case MiscOp.Nop:  	case MiscOp.Break:  		return state;  	case MiscOp.Dup:  		return state.Push (state.Peek (0));  	case MiscOp.Pop:  		return state.Pop (1);  	case MiscOp.Ldnull:  		return state.PushType (global.NullRef' BottomPT);  	case MiscOp.Ckfinite:  		state.PeekExpectedType (0' global.DoubleRef' changed);  		// Assume the instruction can "peek" at top of stack' thus no need for pop/push.  		return state;  	case MiscOp.Throw:  		state.PeekReferenceType (0);  		return state.DiscardStack ();  	case MiscOp.Rethrow:  		return state.DiscardStack ();  	case MiscOp.LdindRef: {  		var elemType = state.PeekPointerToReferenceType (0);  		return state.PopPushType (1' elemType' BottomPT);  	}  	case MiscOp.StindRef: {  		var expElemType = state.PeekPointerToReferenceType (1);  		state.PeekExpectedType (0' expElemType' changed);  		return state.Pop (2);  	}  	case MiscOp.LdelemRef: {  		state.PeekIndexType (0);  		// WARNING: Type may not be final  		var elemType = state.PeekArrayOfReferenceType (1);  		return state.PopPushType (2' elemType' BottomPT);  	}  	case MiscOp.StelemRef:  		state.PeekReferenceType (0);  		state.PeekIndexType (1);  		state.PeekArrayOfReferenceType (2);  		// Since the value type and array element type may be independently generalized'  		// it is pointless to check that the first is assignable to the second.  		// Instead this check is done at runtime.  		return state.Pop (3);  	case MiscOp.Ldlen:  		state.PeekArrayOfAnyType (0);  		return state.PopPushType (1' global.IntNativeRef' BottomPT);  	case MiscOp.Ret: {  		if (state.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return state;  		// empty  	}  	case MiscOp.RetVal: {  		state.PeekExpectedType (0' method.Result.Type' changed);  		var newState = state.Pop (1);  		if (newState.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return newState;  		// empty  	}  	case MiscOp.Endfilter: {  		state.PeekExpectedType (0' global.Int32Ref' changed);  		var newState = state.Pop (1);  		if (newState.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return newState;  		// empty  	}  	case MiscOp.Endfinally: {  		// Control could transfer to an outer finally/fault block' or to the target  		// of a leave instruction. However these transitions are delt with separately.  		return state.DiscardStack ();  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Branch: {  	var bri = (BranchInstruction)instruction;  	switch (bri.Op) {  	case BranchOp.Br:  		UnifyBeforeState (state' bri.Target' changed);  		return state;  	case BranchOp.Brtrue: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.PeekIntegerOrObjectOrPointerType (0' false);  		var newState = state.Pop (1);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Brfalse: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.PeekIntegerOrObjectOrPointerType (0' true);  		var newState = state.Pop (1);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Breq:  	case BranchOp.Brne: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.Peek2ComparableTypes (0' true);  		var newState = state.Pop (2);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Leave: {  		// Control could transfer via finally blocks instead of directly to the leave target.  		// Propogate only that the stack must be empty at target. Remaining machine state  		// is dealt with separately.  		UnifyBeforeState (new MachineState (methEnv' method.ValueParameters.Count' method.Locals.Count)' bri.Target' changed);  		return state.DiscardStack ();  	}  	case BranchOp.BrLt:  	case BranchOp.BrLe:  	case BranchOp.BrGt:  	case BranchOp.BrGe: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.Peek2ComparableTypes (0' false);  		var newState = state.Pop (2);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Switch: {  	var switchi = (SwitchInstruction)instruction;  	state.PeekExpectedType (0' global.Int32Ref' changed);  	var newState = state.Pop (1);  	for (var i = 0; i < switchi.CaseTargets.Count; i++)  		UnifyBeforeState (newState' switchi.CaseTargets [i]' changed);  	return newState;  }  case InstructionFlavor.Compare: {  	var cmpi = (CompareInstruction)instruction;  	// WARNING: Capured type may not be final  	// NOTE: May capture skolemized types  	switch (cmpi.Op) {  	case CompareOp.Ceq:  	case CompareOp.CnePseudo:  		cmpi.Type = state.Peek2ComparableTypes (0' true);  		return state.PopPushType (2' global.Int32Ref' BottomPT);  	case CompareOp.Clt:  	case CompareOp.Cgt:  	case CompareOp.CgePseudo:  	case CompareOp.ClePseudo:  		cmpi.Type = state.Peek2ComparableTypes (0' false);  		return state.PopPushType (2' global.Int32Ref' BottomPT);  	case CompareOp.CtruePseudo:  	case CompareOp.CfalsePseudo:  		cmpi.Type = state.PeekIntegerOrObjectOrPointerType (0' true);  		return state.PopPushType (1' global.Int32Ref' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.ArgLocal: {  	var argi = (ArgLocalInstruction)instruction;  	var type = method.ArgLocalType (argi.ArgLocal' argi.Index);  	switch (argi.Op) {  	case ArgLocalOp.Ld:  		return state.PushType (type' state.ArgLocalPointsTo (argi.ArgLocal' argi.Index));  	case ArgLocalOp.Lda:  		return state.PushType (methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (type)' ArgLocalPT (argi.ArgLocal' argi.Index));  	case ArgLocalOp.St: {  		state.PeekExpectedType (0' type' changed);  		var pointsTo = state.PeekPointsTo (0);  		if (!pointsTo.IsBottom) {  			if (!(type.Style (methEnv) is ManagedPointerTypeStyle))  				throw new InvalidOperationException ("stack indicates pointer' but parameter or local type does not");  			if (pointsTo.PointsOutsideOfHeap)  				throw new InvalidOperationException ("arguments cannot point outside of the heap");  		}  		return state.PopAddArgLocalPointsTo (1' argi.ArgLocal' argi.Index' pointsTo);  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Field: {  	var fieldi = (FieldInstruction)instruction;  	var fieldEnv = fieldi.Field.Enter (methEnv);  	var fieldType = fieldEnv.SubstituteType (fieldEnv.Field.FieldType);  	switch (fieldi.Op) {  	case FieldOp.Ldfld:  		if (fieldi.IsStatic)  			return state.PushType (fieldType' BottomPT);  		else {  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (0' fieldi.Field.DefiningType' true' changed);  			return state.PopPushType (1' fieldType' BottomPT);  		}  	case FieldOp.Ldflda:  		if (fieldi.IsStatic)  			return state.PushType (methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (fieldType)' HeapPT);  		else {  			// Underlying type cannot be a struct' otherwise would have a pointer into  			// the stack  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (0' fieldi.Field.DefiningType' false' changed);  			return state.PopPushType (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (fieldType)' HeapPT);  		}  	case FieldOp.Stfld:  		if (fieldi.IsStatic) {  			state.PeekExpectedType (0' fieldType' changed);  			return state.Pop (1);  		}  		else {  			state.PeekExpectedType (0' fieldType' changed);  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (1' fieldi.Field.DefiningType' false' changed);  			return state.Pop (2);  		}  	case FieldOp.Ldtoken:  		return state.PushType (global.RuntimeFieldHandleRef' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Method: {  	var methi = (MethodInstruction)instruction;  	var sig = (CST.MethodSignature)methi.Method.ExternalSignature;  	switch (methi.Op) {  	case MethodOp.Call: {  		for (var i = sig.Parameters.Count - 1; i >= 1; i--)  			state.PeekExpectedType (sig.Parameters.Count - 1 - i' sig.Parameters [i]' changed);  		if (methi.Constrained != null) {  			if (!methi.IsVirtual || methi.Method.IsStatic)  				throw new InvalidOperationException ("constrained only valid on virtual calls to instance methods");  			var thisType = sig.Parameters [0];  			var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (methi.Constrained);  			var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo (methi.Constrained);  			var cs = methi.Constrained.Style (methEnv);  			if (cs is ValueTypeStyle) {  				if (thisType.Style (methEnv) is ManagedPointerTypeStyle) {  					// We pass the argument pointer as is  					if (!methi.Constrained.IsAssignableTo (methEnv' thisType.Arguments [0]))  						throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  				}  				else {  					// *Case 1* Morally we deref the argument pointer and box the contents'  					// but since no supertype of a value type may mutate the underlying value'  					// we don't need to take a copy of the value when boxing' so in practice  					// this is a no-op  					if (!constrainedBox.IsAssignableTo (methEnv' thisType))  						throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  				}  			}  			else if (cs is ReferenceTypeStyle) {  				// *Case 2* We dereference the pointer and pass the object reference  				if (!methi.Constrained.IsAssignableTo (methEnv' thisType))  					throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  			}  			else if (cs is ParameterTypeStyle) {  				// Since we are calling an instance method' we know the first argument cannot be  				// a "naked" type parameter' but is either a class or an interface.  				// We must decide between cases 1 and 2 above at runtime' but checking as  				// per case 1 is sufficient now.  				// NOTE: As for box/classcast/isinst below' if the parameter is  				// instantiated to a reference type then the type box type is considered  				// equivalent to the underyling reference type.  				if (!constrainedBox.IsAssignableTo (methEnv' thisType))  					throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  			}  			else  				throw new InvalidOperationException ("constrained must be value' reference or parameter type");  			state.PeekExpectedType (sig.Parameters.Count - 1' constrainedPtr' changed);  		}  		else if (sig.Parameters.Count > 0)  			state.PeekExpectedType (sig.Parameters.Count - 1' sig.Parameters [0]' changed);  		if (sig.Result == null)  			return state.Pop (sig.Parameters.Count);  		else  			return state.PopPushType (sig.Parameters.Count' sig.Result' BottomPT);  	}  	case MethodOp.Ldftn: {  		// NOTE: Verified CLR allows only the two "blessed" sequences:  		//   dup; ldvirtftn; newobj <delegate ctor>  		//   ldftn; newobj <delegate ctor>  		// It is thus possible to check the delegate will capture an instance which  		// implements the loaded method. However' we don't check that here.  		if (methi.IsVirtual) {  			if (methi.Method.IsStatic)  				throw new InvalidOperationException ("cannot ldvirtftn of a static method");  			var objectType = default(TypeRef);  			if (sig.Parameters [0].Style (methEnv) is ManagedPointerTypeStyle)  				// Object should be a box  				objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (sig.Parameters [0].Arguments [0]);  			else  				// Object should match parameter  				objectType = sig.Parameters [0];  			state.PeekExpectedType (0' objectType' changed);  			return state.PopPushType (1' sig.WithoutThis ().ToCodePointer (methEnv.Global)' BottomPT);  		}  		else {  			if (methi.Method.IsStatic)  				return state.PushType (sig.ToCodePointer (methEnv.Global)' BottomPT);  			else  				return state.PushType (sig.WithoutThis ().ToCodePointer (methEnv.Global)' BottomPT);  		}  	}  	case MethodOp.Newobj: {  		if (methi.Method.IsStatic || sig.Result != null)  			throw new InvalidOperationException ("not a constructor");  		for (var i = sig.Parameters.Count - 1; i >= 1; i--)  			state.PeekExpectedType (sig.Parameters.Count - 1 - i' sig.Parameters [i]' changed);  		// First argument to constructor is created by runtime. If definining type is  		// a value type' first argument will be a pointer' but result left on stack  		// will be the value itself.  		return state.PopPushType (sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);  	}  	case MethodOp.Ldtoken:  		return state.PushType (global.RuntimeMethodHandleRef' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Type: {  	var typei = (TypeInstruction)instruction;  	switch (typei.Op) {  	case TypeOp.Ldobj:  		state.PeekReadPointerType (0' typei.Type);  		return state.PopPushType (1' typei.Type' BottomPT);  	case TypeOp.Stobj:  		state.PeekExpectedType (0' typei.Type' changed);  		state.PeekWritePointerType (1' typei.Type);  		return state.Pop (2);  	case TypeOp.Cpobj:  		state.PeekReadPointerType (0' typei.Type);  		state.PeekWritePointerType (1' typei.Type);  		return state.Pop (2);  	case TypeOp.Newarr:  		state.PeekIndexType (0);  		return state.PopPushType (1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo (typei.Type)' BottomPT);  	case TypeOp.Initobj:  		state.PeekWritePointerType (0' typei.Type);  		return state.Pop (1);  	case TypeOp.Castclass:  	case TypeOp.Isinst:  	case TypeOp.Box: {  		var resultType = default(TypeRef);  		var s = typei.Type.Style (methEnv);  		if (s is NullableTypeStyle)  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type.Arguments [0]);  		else if (s is ValueTypeStyle)  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type);  		else if (s is ReferenceTypeStyle)  			resultType = typei.Type;  		else if (s is ParameterTypeStyle)  			// NOTE: As for constrained call above' if type parameter is instantitated to  			// a ref type' then this box type is considered equivalent to the  			// underlying reference type.  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type);  		else  			throw new InvalidOperationException ("can only box/cast to reference' value or parameter type");  		if (typei.Op == TypeOp.Box)  			state.PeekExpectedType (0' typei.Type' changed);  		else  			state.PeekReferenceType (0);  		return state.PopPushType (1' resultType' BottomPT);  	}  	case TypeOp.Unbox:  		if (!(typei.Type.Style (methEnv) is ValueTypeStyle))  			// Parameter types are not allowed  			throw new InvalidOperationException ("type must be a value type");  		state.PeekBoxedType (0' typei.Type' changed);  		return state.PopPushType (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (typei.Type)' HeapPT);  	case TypeOp.UnboxAny: {  		var s = typei.Type.Style (methEnv);  		if (s is ValueTypeStyle)  			state.PeekBoxedType (0' typei.Type' changed);  		else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))  			throw new InvalidOperationException ("type must be value' reference or parameter type");  		return state.PopPushType (1' typei.Type' BottomPT);  	}  	case TypeOp.Ldtoken:  		return state.PushType (global.RuntimeTypeHandleRef' BottomPT);  	case TypeOp.Ldelem:  		state.PeekIndexType (0);  		state.PeekReadArrayType (1' typei.Type' false);  		return state.PopPushType (2' typei.Type' BottomPT);  	case TypeOp.Stelem:  		state.PeekExpectedType (0' typei.Type' changed);  		state.PeekIndexType (1);  		state.PeekWriteArrayType (2' typei.Type);  		return state.Pop (3);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.LdElemAddr: {  	var ldelemai = (LdElemAddrInstruction)instruction;  	state.PeekIndexType (0);  	// WARNING: May prematurely fail for non-readonly loads  	state.PeekReadArrayType (1' ldelemai.Type' !ldelemai.IsReadonly);  	return state.PopPushType (2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (ldelemai.Type)' HeapPT);  }  case InstructionFlavor.LdInt32:  	return state.PushType (global.Int32Ref' BottomPT);  case InstructionFlavor.LdInt64:  	return state.PushType (global.Int64Ref' BottomPT);  case InstructionFlavor.LdSingle:  	return state.PushType (global.DoubleRef' BottomPT);  case InstructionFlavor.LdDouble:  	return state.PushType (global.DoubleRef' BottomPT);  case InstructionFlavor.LdString:  	return state.PushType (global.StringRef' BottomPT);  case InstructionFlavor.Arith: {  	var arithi = (ArithInstruction)instruction;  	switch (arithi.Op) {  	case ArithOp.Add:  	case ArithOp.Sub:  	case ArithOp.Mul:  	case ArithOp.Div:  	case ArithOp.Rem:  		// NOTE: May capture skolemized types  		arithi.Type = state.Peek2NumberTypes (0' true);  		return state.PopPushType (2' arithi.Type' BottomPT);  	case ArithOp.Neg:  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (0' true);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (1' arithi.Type' BottomPT);  	case ArithOp.BitAnd:  	case ArithOp.BitOr:  	case ArithOp.BitXor:  		// NOTE: May capture skolemized types  		arithi.Type = state.Peek2NumberTypes (0' false);  		return state.PopPushType (2' arithi.Type' BottomPT);  	case ArithOp.BitNot:  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (0' false);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (1' arithi.Type' BottomPT);  	case ArithOp.Shl:  	case ArithOp.Shr:  		state.PeekExpectedType (0' global.Int32Ref' changed);  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (1' false);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (2' arithi.Type' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Conv: {  	var convi = (ConvInstruction)instruction;  	var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned && convi.TargetNumberFlavor == NumberFlavor.Double);  	// NOTE: May capture skolemized types  	convi.SourceType = state.PeekNumberType (0' !mustBeInteger);  	return state.PopPushType (1' TypeRef.NumberFrom (methEnv.Global' convi.TargetNumberFlavor)' BottomPT);  }  case InstructionFlavor.Try: {  	var tryi = (TryInstruction)instruction;  	// Isolation:  	//  - There is no way for the current stack shape to influence or be influenced by  	//    inference of the try' since the current stack shape must be empty.  	//  - There is no way for the try to influence the result stack shape' since it must be  	//    empty.  	//  - However pointers in arguments and locals may propogate into and out of try body  	//    via exceptional transitions. The latter are delt with separately.  	if (state.Depth != 0)  		throw new InvalidOperationException ("stack should be empty");  	var newState = ForwardBlock (new TryBodyInstructionContext (context' index' tryi.Body)' state' changed);  	for (var j = 0; j < tryi.Handlers.Count; j++) {  		var h = tryi.Handlers [j];  		var handlerContext = new TryHandlerInstructionContext (context' index' h.Body' j);  		var initHandlerState = new MachineState (methEnv' method.ValueParameters.Count' method.Locals.Count);  		switch (h.Flavor) {  		case HandlerFlavor.Catch: {  			var catchh = (CatchTryInstructionHandler)h;  			ForwardBlock (handlerContext' initHandlerState.PushType (catchh.Type' BottomPT)' changed);  			break;  		}  		case HandlerFlavor.Filter:  			throw new NotSupportedException ("filter handler blocks");  		case HandlerFlavor.Fault:  		case HandlerFlavor.Finally:  			ForwardBlock (handlerContext' initHandlerState' changed);  			break;  		default:  			throw new ArgumentOutOfRangeException ();  		}  	}  	return newState;  }  case InstructionFlavor.IfThenElsePseudo:  case InstructionFlavor.ShortCircuitingPseudo:  case InstructionFlavor.StructuralSwitchPseudo:  case InstructionFlavor.LoopPseudo:  case InstructionFlavor.WhileDoPseudo:  case InstructionFlavor.DoWhilePseudo:  case InstructionFlavor.LoopControlPseudo:  	throw new InvalidOperationException ("no machine state inference for psuedo-instructions");  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor) {  case InstructionFlavor.Unsupported:  	throw new InvalidOperationException ("unsupported opcode");  case InstructionFlavor.Misc: {  	var misci = (MiscInstruction)instruction;  	switch (misci.Op) {  	case MiscOp.Nop:  	case MiscOp.Break:  		return state;  	case MiscOp.Dup:  		return state.Push (state.Peek (0));  	case MiscOp.Pop:  		return state.Pop (1);  	case MiscOp.Ldnull:  		return state.PushType (global.NullRef' BottomPT);  	case MiscOp.Ckfinite:  		state.PeekExpectedType (0' global.DoubleRef' changed);  		// Assume the instruction can "peek" at top of stack' thus no need for pop/push.  		return state;  	case MiscOp.Throw:  		state.PeekReferenceType (0);  		return state.DiscardStack ();  	case MiscOp.Rethrow:  		return state.DiscardStack ();  	case MiscOp.LdindRef: {  		var elemType = state.PeekPointerToReferenceType (0);  		return state.PopPushType (1' elemType' BottomPT);  	}  	case MiscOp.StindRef: {  		var expElemType = state.PeekPointerToReferenceType (1);  		state.PeekExpectedType (0' expElemType' changed);  		return state.Pop (2);  	}  	case MiscOp.LdelemRef: {  		state.PeekIndexType (0);  		// WARNING: Type may not be final  		var elemType = state.PeekArrayOfReferenceType (1);  		return state.PopPushType (2' elemType' BottomPT);  	}  	case MiscOp.StelemRef:  		state.PeekReferenceType (0);  		state.PeekIndexType (1);  		state.PeekArrayOfReferenceType (2);  		// Since the value type and array element type may be independently generalized'  		// it is pointless to check that the first is assignable to the second.  		// Instead this check is done at runtime.  		return state.Pop (3);  	case MiscOp.Ldlen:  		state.PeekArrayOfAnyType (0);  		return state.PopPushType (1' global.IntNativeRef' BottomPT);  	case MiscOp.Ret: {  		if (state.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return state;  		// empty  	}  	case MiscOp.RetVal: {  		state.PeekExpectedType (0' method.Result.Type' changed);  		var newState = state.Pop (1);  		if (newState.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return newState;  		// empty  	}  	case MiscOp.Endfilter: {  		state.PeekExpectedType (0' global.Int32Ref' changed);  		var newState = state.Pop (1);  		if (newState.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return newState;  		// empty  	}  	case MiscOp.Endfinally: {  		// Control could transfer to an outer finally/fault block' or to the target  		// of a leave instruction. However these transitions are delt with separately.  		return state.DiscardStack ();  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Branch: {  	var bri = (BranchInstruction)instruction;  	switch (bri.Op) {  	case BranchOp.Br:  		UnifyBeforeState (state' bri.Target' changed);  		return state;  	case BranchOp.Brtrue: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.PeekIntegerOrObjectOrPointerType (0' false);  		var newState = state.Pop (1);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Brfalse: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.PeekIntegerOrObjectOrPointerType (0' true);  		var newState = state.Pop (1);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Breq:  	case BranchOp.Brne: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.Peek2ComparableTypes (0' true);  		var newState = state.Pop (2);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Leave: {  		// Control could transfer via finally blocks instead of directly to the leave target.  		// Propogate only that the stack must be empty at target. Remaining machine state  		// is dealt with separately.  		UnifyBeforeState (new MachineState (methEnv' method.ValueParameters.Count' method.Locals.Count)' bri.Target' changed);  		return state.DiscardStack ();  	}  	case BranchOp.BrLt:  	case BranchOp.BrLe:  	case BranchOp.BrGt:  	case BranchOp.BrGe: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.Peek2ComparableTypes (0' false);  		var newState = state.Pop (2);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Switch: {  	var switchi = (SwitchInstruction)instruction;  	state.PeekExpectedType (0' global.Int32Ref' changed);  	var newState = state.Pop (1);  	for (var i = 0; i < switchi.CaseTargets.Count; i++)  		UnifyBeforeState (newState' switchi.CaseTargets [i]' changed);  	return newState;  }  case InstructionFlavor.Compare: {  	var cmpi = (CompareInstruction)instruction;  	// WARNING: Capured type may not be final  	// NOTE: May capture skolemized types  	switch (cmpi.Op) {  	case CompareOp.Ceq:  	case CompareOp.CnePseudo:  		cmpi.Type = state.Peek2ComparableTypes (0' true);  		return state.PopPushType (2' global.Int32Ref' BottomPT);  	case CompareOp.Clt:  	case CompareOp.Cgt:  	case CompareOp.CgePseudo:  	case CompareOp.ClePseudo:  		cmpi.Type = state.Peek2ComparableTypes (0' false);  		return state.PopPushType (2' global.Int32Ref' BottomPT);  	case CompareOp.CtruePseudo:  	case CompareOp.CfalsePseudo:  		cmpi.Type = state.PeekIntegerOrObjectOrPointerType (0' true);  		return state.PopPushType (1' global.Int32Ref' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.ArgLocal: {  	var argi = (ArgLocalInstruction)instruction;  	var type = method.ArgLocalType (argi.ArgLocal' argi.Index);  	switch (argi.Op) {  	case ArgLocalOp.Ld:  		return state.PushType (type' state.ArgLocalPointsTo (argi.ArgLocal' argi.Index));  	case ArgLocalOp.Lda:  		return state.PushType (methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (type)' ArgLocalPT (argi.ArgLocal' argi.Index));  	case ArgLocalOp.St: {  		state.PeekExpectedType (0' type' changed);  		var pointsTo = state.PeekPointsTo (0);  		if (!pointsTo.IsBottom) {  			if (!(type.Style (methEnv) is ManagedPointerTypeStyle))  				throw new InvalidOperationException ("stack indicates pointer' but parameter or local type does not");  			if (pointsTo.PointsOutsideOfHeap)  				throw new InvalidOperationException ("arguments cannot point outside of the heap");  		}  		return state.PopAddArgLocalPointsTo (1' argi.ArgLocal' argi.Index' pointsTo);  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Field: {  	var fieldi = (FieldInstruction)instruction;  	var fieldEnv = fieldi.Field.Enter (methEnv);  	var fieldType = fieldEnv.SubstituteType (fieldEnv.Field.FieldType);  	switch (fieldi.Op) {  	case FieldOp.Ldfld:  		if (fieldi.IsStatic)  			return state.PushType (fieldType' BottomPT);  		else {  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (0' fieldi.Field.DefiningType' true' changed);  			return state.PopPushType (1' fieldType' BottomPT);  		}  	case FieldOp.Ldflda:  		if (fieldi.IsStatic)  			return state.PushType (methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (fieldType)' HeapPT);  		else {  			// Underlying type cannot be a struct' otherwise would have a pointer into  			// the stack  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (0' fieldi.Field.DefiningType' false' changed);  			return state.PopPushType (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (fieldType)' HeapPT);  		}  	case FieldOp.Stfld:  		if (fieldi.IsStatic) {  			state.PeekExpectedType (0' fieldType' changed);  			return state.Pop (1);  		}  		else {  			state.PeekExpectedType (0' fieldType' changed);  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (1' fieldi.Field.DefiningType' false' changed);  			return state.Pop (2);  		}  	case FieldOp.Ldtoken:  		return state.PushType (global.RuntimeFieldHandleRef' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Method: {  	var methi = (MethodInstruction)instruction;  	var sig = (CST.MethodSignature)methi.Method.ExternalSignature;  	switch (methi.Op) {  	case MethodOp.Call: {  		for (var i = sig.Parameters.Count - 1; i >= 1; i--)  			state.PeekExpectedType (sig.Parameters.Count - 1 - i' sig.Parameters [i]' changed);  		if (methi.Constrained != null) {  			if (!methi.IsVirtual || methi.Method.IsStatic)  				throw new InvalidOperationException ("constrained only valid on virtual calls to instance methods");  			var thisType = sig.Parameters [0];  			var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (methi.Constrained);  			var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo (methi.Constrained);  			var cs = methi.Constrained.Style (methEnv);  			if (cs is ValueTypeStyle) {  				if (thisType.Style (methEnv) is ManagedPointerTypeStyle) {  					// We pass the argument pointer as is  					if (!methi.Constrained.IsAssignableTo (methEnv' thisType.Arguments [0]))  						throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  				}  				else {  					// *Case 1* Morally we deref the argument pointer and box the contents'  					// but since no supertype of a value type may mutate the underlying value'  					// we don't need to take a copy of the value when boxing' so in practice  					// this is a no-op  					if (!constrainedBox.IsAssignableTo (methEnv' thisType))  						throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  				}  			}  			else if (cs is ReferenceTypeStyle) {  				// *Case 2* We dereference the pointer and pass the object reference  				if (!methi.Constrained.IsAssignableTo (methEnv' thisType))  					throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  			}  			else if (cs is ParameterTypeStyle) {  				// Since we are calling an instance method' we know the first argument cannot be  				// a "naked" type parameter' but is either a class or an interface.  				// We must decide between cases 1 and 2 above at runtime' but checking as  				// per case 1 is sufficient now.  				// NOTE: As for box/classcast/isinst below' if the parameter is  				// instantiated to a reference type then the type box type is considered  				// equivalent to the underyling reference type.  				if (!constrainedBox.IsAssignableTo (methEnv' thisType))  					throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  			}  			else  				throw new InvalidOperationException ("constrained must be value' reference or parameter type");  			state.PeekExpectedType (sig.Parameters.Count - 1' constrainedPtr' changed);  		}  		else if (sig.Parameters.Count > 0)  			state.PeekExpectedType (sig.Parameters.Count - 1' sig.Parameters [0]' changed);  		if (sig.Result == null)  			return state.Pop (sig.Parameters.Count);  		else  			return state.PopPushType (sig.Parameters.Count' sig.Result' BottomPT);  	}  	case MethodOp.Ldftn: {  		// NOTE: Verified CLR allows only the two "blessed" sequences:  		//   dup; ldvirtftn; newobj <delegate ctor>  		//   ldftn; newobj <delegate ctor>  		// It is thus possible to check the delegate will capture an instance which  		// implements the loaded method. However' we don't check that here.  		if (methi.IsVirtual) {  			if (methi.Method.IsStatic)  				throw new InvalidOperationException ("cannot ldvirtftn of a static method");  			var objectType = default(TypeRef);  			if (sig.Parameters [0].Style (methEnv) is ManagedPointerTypeStyle)  				// Object should be a box  				objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (sig.Parameters [0].Arguments [0]);  			else  				// Object should match parameter  				objectType = sig.Parameters [0];  			state.PeekExpectedType (0' objectType' changed);  			return state.PopPushType (1' sig.WithoutThis ().ToCodePointer (methEnv.Global)' BottomPT);  		}  		else {  			if (methi.Method.IsStatic)  				return state.PushType (sig.ToCodePointer (methEnv.Global)' BottomPT);  			else  				return state.PushType (sig.WithoutThis ().ToCodePointer (methEnv.Global)' BottomPT);  		}  	}  	case MethodOp.Newobj: {  		if (methi.Method.IsStatic || sig.Result != null)  			throw new InvalidOperationException ("not a constructor");  		for (var i = sig.Parameters.Count - 1; i >= 1; i--)  			state.PeekExpectedType (sig.Parameters.Count - 1 - i' sig.Parameters [i]' changed);  		// First argument to constructor is created by runtime. If definining type is  		// a value type' first argument will be a pointer' but result left on stack  		// will be the value itself.  		return state.PopPushType (sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);  	}  	case MethodOp.Ldtoken:  		return state.PushType (global.RuntimeMethodHandleRef' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Type: {  	var typei = (TypeInstruction)instruction;  	switch (typei.Op) {  	case TypeOp.Ldobj:  		state.PeekReadPointerType (0' typei.Type);  		return state.PopPushType (1' typei.Type' BottomPT);  	case TypeOp.Stobj:  		state.PeekExpectedType (0' typei.Type' changed);  		state.PeekWritePointerType (1' typei.Type);  		return state.Pop (2);  	case TypeOp.Cpobj:  		state.PeekReadPointerType (0' typei.Type);  		state.PeekWritePointerType (1' typei.Type);  		return state.Pop (2);  	case TypeOp.Newarr:  		state.PeekIndexType (0);  		return state.PopPushType (1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo (typei.Type)' BottomPT);  	case TypeOp.Initobj:  		state.PeekWritePointerType (0' typei.Type);  		return state.Pop (1);  	case TypeOp.Castclass:  	case TypeOp.Isinst:  	case TypeOp.Box: {  		var resultType = default(TypeRef);  		var s = typei.Type.Style (methEnv);  		if (s is NullableTypeStyle)  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type.Arguments [0]);  		else if (s is ValueTypeStyle)  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type);  		else if (s is ReferenceTypeStyle)  			resultType = typei.Type;  		else if (s is ParameterTypeStyle)  			// NOTE: As for constrained call above' if type parameter is instantitated to  			// a ref type' then this box type is considered equivalent to the  			// underlying reference type.  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type);  		else  			throw new InvalidOperationException ("can only box/cast to reference' value or parameter type");  		if (typei.Op == TypeOp.Box)  			state.PeekExpectedType (0' typei.Type' changed);  		else  			state.PeekReferenceType (0);  		return state.PopPushType (1' resultType' BottomPT);  	}  	case TypeOp.Unbox:  		if (!(typei.Type.Style (methEnv) is ValueTypeStyle))  			// Parameter types are not allowed  			throw new InvalidOperationException ("type must be a value type");  		state.PeekBoxedType (0' typei.Type' changed);  		return state.PopPushType (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (typei.Type)' HeapPT);  	case TypeOp.UnboxAny: {  		var s = typei.Type.Style (methEnv);  		if (s is ValueTypeStyle)  			state.PeekBoxedType (0' typei.Type' changed);  		else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))  			throw new InvalidOperationException ("type must be value' reference or parameter type");  		return state.PopPushType (1' typei.Type' BottomPT);  	}  	case TypeOp.Ldtoken:  		return state.PushType (global.RuntimeTypeHandleRef' BottomPT);  	case TypeOp.Ldelem:  		state.PeekIndexType (0);  		state.PeekReadArrayType (1' typei.Type' false);  		return state.PopPushType (2' typei.Type' BottomPT);  	case TypeOp.Stelem:  		state.PeekExpectedType (0' typei.Type' changed);  		state.PeekIndexType (1);  		state.PeekWriteArrayType (2' typei.Type);  		return state.Pop (3);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.LdElemAddr: {  	var ldelemai = (LdElemAddrInstruction)instruction;  	state.PeekIndexType (0);  	// WARNING: May prematurely fail for non-readonly loads  	state.PeekReadArrayType (1' ldelemai.Type' !ldelemai.IsReadonly);  	return state.PopPushType (2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (ldelemai.Type)' HeapPT);  }  case InstructionFlavor.LdInt32:  	return state.PushType (global.Int32Ref' BottomPT);  case InstructionFlavor.LdInt64:  	return state.PushType (global.Int64Ref' BottomPT);  case InstructionFlavor.LdSingle:  	return state.PushType (global.DoubleRef' BottomPT);  case InstructionFlavor.LdDouble:  	return state.PushType (global.DoubleRef' BottomPT);  case InstructionFlavor.LdString:  	return state.PushType (global.StringRef' BottomPT);  case InstructionFlavor.Arith: {  	var arithi = (ArithInstruction)instruction;  	switch (arithi.Op) {  	case ArithOp.Add:  	case ArithOp.Sub:  	case ArithOp.Mul:  	case ArithOp.Div:  	case ArithOp.Rem:  		// NOTE: May capture skolemized types  		arithi.Type = state.Peek2NumberTypes (0' true);  		return state.PopPushType (2' arithi.Type' BottomPT);  	case ArithOp.Neg:  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (0' true);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (1' arithi.Type' BottomPT);  	case ArithOp.BitAnd:  	case ArithOp.BitOr:  	case ArithOp.BitXor:  		// NOTE: May capture skolemized types  		arithi.Type = state.Peek2NumberTypes (0' false);  		return state.PopPushType (2' arithi.Type' BottomPT);  	case ArithOp.BitNot:  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (0' false);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (1' arithi.Type' BottomPT);  	case ArithOp.Shl:  	case ArithOp.Shr:  		state.PeekExpectedType (0' global.Int32Ref' changed);  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (1' false);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (2' arithi.Type' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Conv: {  	var convi = (ConvInstruction)instruction;  	var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned && convi.TargetNumberFlavor == NumberFlavor.Double);  	// NOTE: May capture skolemized types  	convi.SourceType = state.PeekNumberType (0' !mustBeInteger);  	return state.PopPushType (1' TypeRef.NumberFrom (methEnv.Global' convi.TargetNumberFlavor)' BottomPT);  }  case InstructionFlavor.Try: {  	var tryi = (TryInstruction)instruction;  	// Isolation:  	//  - There is no way for the current stack shape to influence or be influenced by  	//    inference of the try' since the current stack shape must be empty.  	//  - There is no way for the try to influence the result stack shape' since it must be  	//    empty.  	//  - However pointers in arguments and locals may propogate into and out of try body  	//    via exceptional transitions. The latter are delt with separately.  	if (state.Depth != 0)  		throw new InvalidOperationException ("stack should be empty");  	var newState = ForwardBlock (new TryBodyInstructionContext (context' index' tryi.Body)' state' changed);  	for (var j = 0; j < tryi.Handlers.Count; j++) {  		var h = tryi.Handlers [j];  		var handlerContext = new TryHandlerInstructionContext (context' index' h.Body' j);  		var initHandlerState = new MachineState (methEnv' method.ValueParameters.Count' method.Locals.Count);  		switch (h.Flavor) {  		case HandlerFlavor.Catch: {  			var catchh = (CatchTryInstructionHandler)h;  			ForwardBlock (handlerContext' initHandlerState.PushType (catchh.Type' BottomPT)' changed);  			break;  		}  		case HandlerFlavor.Filter:  			throw new NotSupportedException ("filter handler blocks");  		case HandlerFlavor.Fault:  		case HandlerFlavor.Finally:  			ForwardBlock (handlerContext' initHandlerState' changed);  			break;  		default:  			throw new ArgumentOutOfRangeException ();  		}  	}  	return newState;  }  case InstructionFlavor.IfThenElsePseudo:  case InstructionFlavor.ShortCircuitingPseudo:  case InstructionFlavor.StructuralSwitchPseudo:  case InstructionFlavor.LoopPseudo:  case InstructionFlavor.WhileDoPseudo:  case InstructionFlavor.DoWhilePseudo:  case InstructionFlavor.LoopControlPseudo:  	throw new InvalidOperationException ("no machine state inference for psuedo-instructions");  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor) {  case InstructionFlavor.Unsupported:  	throw new InvalidOperationException ("unsupported opcode");  case InstructionFlavor.Misc: {  	var misci = (MiscInstruction)instruction;  	switch (misci.Op) {  	case MiscOp.Nop:  	case MiscOp.Break:  		return state;  	case MiscOp.Dup:  		return state.Push (state.Peek (0));  	case MiscOp.Pop:  		return state.Pop (1);  	case MiscOp.Ldnull:  		return state.PushType (global.NullRef' BottomPT);  	case MiscOp.Ckfinite:  		state.PeekExpectedType (0' global.DoubleRef' changed);  		// Assume the instruction can "peek" at top of stack' thus no need for pop/push.  		return state;  	case MiscOp.Throw:  		state.PeekReferenceType (0);  		return state.DiscardStack ();  	case MiscOp.Rethrow:  		return state.DiscardStack ();  	case MiscOp.LdindRef: {  		var elemType = state.PeekPointerToReferenceType (0);  		return state.PopPushType (1' elemType' BottomPT);  	}  	case MiscOp.StindRef: {  		var expElemType = state.PeekPointerToReferenceType (1);  		state.PeekExpectedType (0' expElemType' changed);  		return state.Pop (2);  	}  	case MiscOp.LdelemRef: {  		state.PeekIndexType (0);  		// WARNING: Type may not be final  		var elemType = state.PeekArrayOfReferenceType (1);  		return state.PopPushType (2' elemType' BottomPT);  	}  	case MiscOp.StelemRef:  		state.PeekReferenceType (0);  		state.PeekIndexType (1);  		state.PeekArrayOfReferenceType (2);  		// Since the value type and array element type may be independently generalized'  		// it is pointless to check that the first is assignable to the second.  		// Instead this check is done at runtime.  		return state.Pop (3);  	case MiscOp.Ldlen:  		state.PeekArrayOfAnyType (0);  		return state.PopPushType (1' global.IntNativeRef' BottomPT);  	case MiscOp.Ret: {  		if (state.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return state;  		// empty  	}  	case MiscOp.RetVal: {  		state.PeekExpectedType (0' method.Result.Type' changed);  		var newState = state.Pop (1);  		if (newState.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return newState;  		// empty  	}  	case MiscOp.Endfilter: {  		state.PeekExpectedType (0' global.Int32Ref' changed);  		var newState = state.Pop (1);  		if (newState.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return newState;  		// empty  	}  	case MiscOp.Endfinally: {  		// Control could transfer to an outer finally/fault block' or to the target  		// of a leave instruction. However these transitions are delt with separately.  		return state.DiscardStack ();  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Branch: {  	var bri = (BranchInstruction)instruction;  	switch (bri.Op) {  	case BranchOp.Br:  		UnifyBeforeState (state' bri.Target' changed);  		return state;  	case BranchOp.Brtrue: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.PeekIntegerOrObjectOrPointerType (0' false);  		var newState = state.Pop (1);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Brfalse: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.PeekIntegerOrObjectOrPointerType (0' true);  		var newState = state.Pop (1);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Breq:  	case BranchOp.Brne: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.Peek2ComparableTypes (0' true);  		var newState = state.Pop (2);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Leave: {  		// Control could transfer via finally blocks instead of directly to the leave target.  		// Propogate only that the stack must be empty at target. Remaining machine state  		// is dealt with separately.  		UnifyBeforeState (new MachineState (methEnv' method.ValueParameters.Count' method.Locals.Count)' bri.Target' changed);  		return state.DiscardStack ();  	}  	case BranchOp.BrLt:  	case BranchOp.BrLe:  	case BranchOp.BrGt:  	case BranchOp.BrGe: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.Peek2ComparableTypes (0' false);  		var newState = state.Pop (2);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Switch: {  	var switchi = (SwitchInstruction)instruction;  	state.PeekExpectedType (0' global.Int32Ref' changed);  	var newState = state.Pop (1);  	for (var i = 0; i < switchi.CaseTargets.Count; i++)  		UnifyBeforeState (newState' switchi.CaseTargets [i]' changed);  	return newState;  }  case InstructionFlavor.Compare: {  	var cmpi = (CompareInstruction)instruction;  	// WARNING: Capured type may not be final  	// NOTE: May capture skolemized types  	switch (cmpi.Op) {  	case CompareOp.Ceq:  	case CompareOp.CnePseudo:  		cmpi.Type = state.Peek2ComparableTypes (0' true);  		return state.PopPushType (2' global.Int32Ref' BottomPT);  	case CompareOp.Clt:  	case CompareOp.Cgt:  	case CompareOp.CgePseudo:  	case CompareOp.ClePseudo:  		cmpi.Type = state.Peek2ComparableTypes (0' false);  		return state.PopPushType (2' global.Int32Ref' BottomPT);  	case CompareOp.CtruePseudo:  	case CompareOp.CfalsePseudo:  		cmpi.Type = state.PeekIntegerOrObjectOrPointerType (0' true);  		return state.PopPushType (1' global.Int32Ref' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.ArgLocal: {  	var argi = (ArgLocalInstruction)instruction;  	var type = method.ArgLocalType (argi.ArgLocal' argi.Index);  	switch (argi.Op) {  	case ArgLocalOp.Ld:  		return state.PushType (type' state.ArgLocalPointsTo (argi.ArgLocal' argi.Index));  	case ArgLocalOp.Lda:  		return state.PushType (methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (type)' ArgLocalPT (argi.ArgLocal' argi.Index));  	case ArgLocalOp.St: {  		state.PeekExpectedType (0' type' changed);  		var pointsTo = state.PeekPointsTo (0);  		if (!pointsTo.IsBottom) {  			if (!(type.Style (methEnv) is ManagedPointerTypeStyle))  				throw new InvalidOperationException ("stack indicates pointer' but parameter or local type does not");  			if (pointsTo.PointsOutsideOfHeap)  				throw new InvalidOperationException ("arguments cannot point outside of the heap");  		}  		return state.PopAddArgLocalPointsTo (1' argi.ArgLocal' argi.Index' pointsTo);  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Field: {  	var fieldi = (FieldInstruction)instruction;  	var fieldEnv = fieldi.Field.Enter (methEnv);  	var fieldType = fieldEnv.SubstituteType (fieldEnv.Field.FieldType);  	switch (fieldi.Op) {  	case FieldOp.Ldfld:  		if (fieldi.IsStatic)  			return state.PushType (fieldType' BottomPT);  		else {  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (0' fieldi.Field.DefiningType' true' changed);  			return state.PopPushType (1' fieldType' BottomPT);  		}  	case FieldOp.Ldflda:  		if (fieldi.IsStatic)  			return state.PushType (methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (fieldType)' HeapPT);  		else {  			// Underlying type cannot be a struct' otherwise would have a pointer into  			// the stack  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (0' fieldi.Field.DefiningType' false' changed);  			return state.PopPushType (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (fieldType)' HeapPT);  		}  	case FieldOp.Stfld:  		if (fieldi.IsStatic) {  			state.PeekExpectedType (0' fieldType' changed);  			return state.Pop (1);  		}  		else {  			state.PeekExpectedType (0' fieldType' changed);  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (1' fieldi.Field.DefiningType' false' changed);  			return state.Pop (2);  		}  	case FieldOp.Ldtoken:  		return state.PushType (global.RuntimeFieldHandleRef' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Method: {  	var methi = (MethodInstruction)instruction;  	var sig = (CST.MethodSignature)methi.Method.ExternalSignature;  	switch (methi.Op) {  	case MethodOp.Call: {  		for (var i = sig.Parameters.Count - 1; i >= 1; i--)  			state.PeekExpectedType (sig.Parameters.Count - 1 - i' sig.Parameters [i]' changed);  		if (methi.Constrained != null) {  			if (!methi.IsVirtual || methi.Method.IsStatic)  				throw new InvalidOperationException ("constrained only valid on virtual calls to instance methods");  			var thisType = sig.Parameters [0];  			var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (methi.Constrained);  			var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo (methi.Constrained);  			var cs = methi.Constrained.Style (methEnv);  			if (cs is ValueTypeStyle) {  				if (thisType.Style (methEnv) is ManagedPointerTypeStyle) {  					// We pass the argument pointer as is  					if (!methi.Constrained.IsAssignableTo (methEnv' thisType.Arguments [0]))  						throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  				}  				else {  					// *Case 1* Morally we deref the argument pointer and box the contents'  					// but since no supertype of a value type may mutate the underlying value'  					// we don't need to take a copy of the value when boxing' so in practice  					// this is a no-op  					if (!constrainedBox.IsAssignableTo (methEnv' thisType))  						throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  				}  			}  			else if (cs is ReferenceTypeStyle) {  				// *Case 2* We dereference the pointer and pass the object reference  				if (!methi.Constrained.IsAssignableTo (methEnv' thisType))  					throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  			}  			else if (cs is ParameterTypeStyle) {  				// Since we are calling an instance method' we know the first argument cannot be  				// a "naked" type parameter' but is either a class or an interface.  				// We must decide between cases 1 and 2 above at runtime' but checking as  				// per case 1 is sufficient now.  				// NOTE: As for box/classcast/isinst below' if the parameter is  				// instantiated to a reference type then the type box type is considered  				// equivalent to the underyling reference type.  				if (!constrainedBox.IsAssignableTo (methEnv' thisType))  					throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  			}  			else  				throw new InvalidOperationException ("constrained must be value' reference or parameter type");  			state.PeekExpectedType (sig.Parameters.Count - 1' constrainedPtr' changed);  		}  		else if (sig.Parameters.Count > 0)  			state.PeekExpectedType (sig.Parameters.Count - 1' sig.Parameters [0]' changed);  		if (sig.Result == null)  			return state.Pop (sig.Parameters.Count);  		else  			return state.PopPushType (sig.Parameters.Count' sig.Result' BottomPT);  	}  	case MethodOp.Ldftn: {  		// NOTE: Verified CLR allows only the two "blessed" sequences:  		//   dup; ldvirtftn; newobj <delegate ctor>  		//   ldftn; newobj <delegate ctor>  		// It is thus possible to check the delegate will capture an instance which  		// implements the loaded method. However' we don't check that here.  		if (methi.IsVirtual) {  			if (methi.Method.IsStatic)  				throw new InvalidOperationException ("cannot ldvirtftn of a static method");  			var objectType = default(TypeRef);  			if (sig.Parameters [0].Style (methEnv) is ManagedPointerTypeStyle)  				// Object should be a box  				objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (sig.Parameters [0].Arguments [0]);  			else  				// Object should match parameter  				objectType = sig.Parameters [0];  			state.PeekExpectedType (0' objectType' changed);  			return state.PopPushType (1' sig.WithoutThis ().ToCodePointer (methEnv.Global)' BottomPT);  		}  		else {  			if (methi.Method.IsStatic)  				return state.PushType (sig.ToCodePointer (methEnv.Global)' BottomPT);  			else  				return state.PushType (sig.WithoutThis ().ToCodePointer (methEnv.Global)' BottomPT);  		}  	}  	case MethodOp.Newobj: {  		if (methi.Method.IsStatic || sig.Result != null)  			throw new InvalidOperationException ("not a constructor");  		for (var i = sig.Parameters.Count - 1; i >= 1; i--)  			state.PeekExpectedType (sig.Parameters.Count - 1 - i' sig.Parameters [i]' changed);  		// First argument to constructor is created by runtime. If definining type is  		// a value type' first argument will be a pointer' but result left on stack  		// will be the value itself.  		return state.PopPushType (sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);  	}  	case MethodOp.Ldtoken:  		return state.PushType (global.RuntimeMethodHandleRef' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Type: {  	var typei = (TypeInstruction)instruction;  	switch (typei.Op) {  	case TypeOp.Ldobj:  		state.PeekReadPointerType (0' typei.Type);  		return state.PopPushType (1' typei.Type' BottomPT);  	case TypeOp.Stobj:  		state.PeekExpectedType (0' typei.Type' changed);  		state.PeekWritePointerType (1' typei.Type);  		return state.Pop (2);  	case TypeOp.Cpobj:  		state.PeekReadPointerType (0' typei.Type);  		state.PeekWritePointerType (1' typei.Type);  		return state.Pop (2);  	case TypeOp.Newarr:  		state.PeekIndexType (0);  		return state.PopPushType (1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo (typei.Type)' BottomPT);  	case TypeOp.Initobj:  		state.PeekWritePointerType (0' typei.Type);  		return state.Pop (1);  	case TypeOp.Castclass:  	case TypeOp.Isinst:  	case TypeOp.Box: {  		var resultType = default(TypeRef);  		var s = typei.Type.Style (methEnv);  		if (s is NullableTypeStyle)  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type.Arguments [0]);  		else if (s is ValueTypeStyle)  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type);  		else if (s is ReferenceTypeStyle)  			resultType = typei.Type;  		else if (s is ParameterTypeStyle)  			// NOTE: As for constrained call above' if type parameter is instantitated to  			// a ref type' then this box type is considered equivalent to the  			// underlying reference type.  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type);  		else  			throw new InvalidOperationException ("can only box/cast to reference' value or parameter type");  		if (typei.Op == TypeOp.Box)  			state.PeekExpectedType (0' typei.Type' changed);  		else  			state.PeekReferenceType (0);  		return state.PopPushType (1' resultType' BottomPT);  	}  	case TypeOp.Unbox:  		if (!(typei.Type.Style (methEnv) is ValueTypeStyle))  			// Parameter types are not allowed  			throw new InvalidOperationException ("type must be a value type");  		state.PeekBoxedType (0' typei.Type' changed);  		return state.PopPushType (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (typei.Type)' HeapPT);  	case TypeOp.UnboxAny: {  		var s = typei.Type.Style (methEnv);  		if (s is ValueTypeStyle)  			state.PeekBoxedType (0' typei.Type' changed);  		else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))  			throw new InvalidOperationException ("type must be value' reference or parameter type");  		return state.PopPushType (1' typei.Type' BottomPT);  	}  	case TypeOp.Ldtoken:  		return state.PushType (global.RuntimeTypeHandleRef' BottomPT);  	case TypeOp.Ldelem:  		state.PeekIndexType (0);  		state.PeekReadArrayType (1' typei.Type' false);  		return state.PopPushType (2' typei.Type' BottomPT);  	case TypeOp.Stelem:  		state.PeekExpectedType (0' typei.Type' changed);  		state.PeekIndexType (1);  		state.PeekWriteArrayType (2' typei.Type);  		return state.Pop (3);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.LdElemAddr: {  	var ldelemai = (LdElemAddrInstruction)instruction;  	state.PeekIndexType (0);  	// WARNING: May prematurely fail for non-readonly loads  	state.PeekReadArrayType (1' ldelemai.Type' !ldelemai.IsReadonly);  	return state.PopPushType (2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (ldelemai.Type)' HeapPT);  }  case InstructionFlavor.LdInt32:  	return state.PushType (global.Int32Ref' BottomPT);  case InstructionFlavor.LdInt64:  	return state.PushType (global.Int64Ref' BottomPT);  case InstructionFlavor.LdSingle:  	return state.PushType (global.DoubleRef' BottomPT);  case InstructionFlavor.LdDouble:  	return state.PushType (global.DoubleRef' BottomPT);  case InstructionFlavor.LdString:  	return state.PushType (global.StringRef' BottomPT);  case InstructionFlavor.Arith: {  	var arithi = (ArithInstruction)instruction;  	switch (arithi.Op) {  	case ArithOp.Add:  	case ArithOp.Sub:  	case ArithOp.Mul:  	case ArithOp.Div:  	case ArithOp.Rem:  		// NOTE: May capture skolemized types  		arithi.Type = state.Peek2NumberTypes (0' true);  		return state.PopPushType (2' arithi.Type' BottomPT);  	case ArithOp.Neg:  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (0' true);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (1' arithi.Type' BottomPT);  	case ArithOp.BitAnd:  	case ArithOp.BitOr:  	case ArithOp.BitXor:  		// NOTE: May capture skolemized types  		arithi.Type = state.Peek2NumberTypes (0' false);  		return state.PopPushType (2' arithi.Type' BottomPT);  	case ArithOp.BitNot:  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (0' false);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (1' arithi.Type' BottomPT);  	case ArithOp.Shl:  	case ArithOp.Shr:  		state.PeekExpectedType (0' global.Int32Ref' changed);  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (1' false);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (2' arithi.Type' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Conv: {  	var convi = (ConvInstruction)instruction;  	var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned && convi.TargetNumberFlavor == NumberFlavor.Double);  	// NOTE: May capture skolemized types  	convi.SourceType = state.PeekNumberType (0' !mustBeInteger);  	return state.PopPushType (1' TypeRef.NumberFrom (methEnv.Global' convi.TargetNumberFlavor)' BottomPT);  }  case InstructionFlavor.Try: {  	var tryi = (TryInstruction)instruction;  	// Isolation:  	//  - There is no way for the current stack shape to influence or be influenced by  	//    inference of the try' since the current stack shape must be empty.  	//  - There is no way for the try to influence the result stack shape' since it must be  	//    empty.  	//  - However pointers in arguments and locals may propogate into and out of try body  	//    via exceptional transitions. The latter are delt with separately.  	if (state.Depth != 0)  		throw new InvalidOperationException ("stack should be empty");  	var newState = ForwardBlock (new TryBodyInstructionContext (context' index' tryi.Body)' state' changed);  	for (var j = 0; j < tryi.Handlers.Count; j++) {  		var h = tryi.Handlers [j];  		var handlerContext = new TryHandlerInstructionContext (context' index' h.Body' j);  		var initHandlerState = new MachineState (methEnv' method.ValueParameters.Count' method.Locals.Count);  		switch (h.Flavor) {  		case HandlerFlavor.Catch: {  			var catchh = (CatchTryInstructionHandler)h;  			ForwardBlock (handlerContext' initHandlerState.PushType (catchh.Type' BottomPT)' changed);  			break;  		}  		case HandlerFlavor.Filter:  			throw new NotSupportedException ("filter handler blocks");  		case HandlerFlavor.Fault:  		case HandlerFlavor.Finally:  			ForwardBlock (handlerContext' initHandlerState' changed);  			break;  		default:  			throw new ArgumentOutOfRangeException ();  		}  	}  	return newState;  }  case InstructionFlavor.IfThenElsePseudo:  case InstructionFlavor.ShortCircuitingPseudo:  case InstructionFlavor.StructuralSwitchPseudo:  case InstructionFlavor.LoopPseudo:  case InstructionFlavor.WhileDoPseudo:  case InstructionFlavor.DoWhilePseudo:  case InstructionFlavor.LoopControlPseudo:  	throw new InvalidOperationException ("no machine state inference for psuedo-instructions");  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor) {  case InstructionFlavor.Unsupported:  	throw new InvalidOperationException ("unsupported opcode");  case InstructionFlavor.Misc: {  	var misci = (MiscInstruction)instruction;  	switch (misci.Op) {  	case MiscOp.Nop:  	case MiscOp.Break:  		return state;  	case MiscOp.Dup:  		return state.Push (state.Peek (0));  	case MiscOp.Pop:  		return state.Pop (1);  	case MiscOp.Ldnull:  		return state.PushType (global.NullRef' BottomPT);  	case MiscOp.Ckfinite:  		state.PeekExpectedType (0' global.DoubleRef' changed);  		// Assume the instruction can "peek" at top of stack' thus no need for pop/push.  		return state;  	case MiscOp.Throw:  		state.PeekReferenceType (0);  		return state.DiscardStack ();  	case MiscOp.Rethrow:  		return state.DiscardStack ();  	case MiscOp.LdindRef: {  		var elemType = state.PeekPointerToReferenceType (0);  		return state.PopPushType (1' elemType' BottomPT);  	}  	case MiscOp.StindRef: {  		var expElemType = state.PeekPointerToReferenceType (1);  		state.PeekExpectedType (0' expElemType' changed);  		return state.Pop (2);  	}  	case MiscOp.LdelemRef: {  		state.PeekIndexType (0);  		// WARNING: Type may not be final  		var elemType = state.PeekArrayOfReferenceType (1);  		return state.PopPushType (2' elemType' BottomPT);  	}  	case MiscOp.StelemRef:  		state.PeekReferenceType (0);  		state.PeekIndexType (1);  		state.PeekArrayOfReferenceType (2);  		// Since the value type and array element type may be independently generalized'  		// it is pointless to check that the first is assignable to the second.  		// Instead this check is done at runtime.  		return state.Pop (3);  	case MiscOp.Ldlen:  		state.PeekArrayOfAnyType (0);  		return state.PopPushType (1' global.IntNativeRef' BottomPT);  	case MiscOp.Ret: {  		if (state.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return state;  		// empty  	}  	case MiscOp.RetVal: {  		state.PeekExpectedType (0' method.Result.Type' changed);  		var newState = state.Pop (1);  		if (newState.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return newState;  		// empty  	}  	case MiscOp.Endfilter: {  		state.PeekExpectedType (0' global.Int32Ref' changed);  		var newState = state.Pop (1);  		if (newState.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return newState;  		// empty  	}  	case MiscOp.Endfinally: {  		// Control could transfer to an outer finally/fault block' or to the target  		// of a leave instruction. However these transitions are delt with separately.  		return state.DiscardStack ();  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Branch: {  	var bri = (BranchInstruction)instruction;  	switch (bri.Op) {  	case BranchOp.Br:  		UnifyBeforeState (state' bri.Target' changed);  		return state;  	case BranchOp.Brtrue: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.PeekIntegerOrObjectOrPointerType (0' false);  		var newState = state.Pop (1);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Brfalse: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.PeekIntegerOrObjectOrPointerType (0' true);  		var newState = state.Pop (1);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Breq:  	case BranchOp.Brne: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.Peek2ComparableTypes (0' true);  		var newState = state.Pop (2);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Leave: {  		// Control could transfer via finally blocks instead of directly to the leave target.  		// Propogate only that the stack must be empty at target. Remaining machine state  		// is dealt with separately.  		UnifyBeforeState (new MachineState (methEnv' method.ValueParameters.Count' method.Locals.Count)' bri.Target' changed);  		return state.DiscardStack ();  	}  	case BranchOp.BrLt:  	case BranchOp.BrLe:  	case BranchOp.BrGt:  	case BranchOp.BrGe: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.Peek2ComparableTypes (0' false);  		var newState = state.Pop (2);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Switch: {  	var switchi = (SwitchInstruction)instruction;  	state.PeekExpectedType (0' global.Int32Ref' changed);  	var newState = state.Pop (1);  	for (var i = 0; i < switchi.CaseTargets.Count; i++)  		UnifyBeforeState (newState' switchi.CaseTargets [i]' changed);  	return newState;  }  case InstructionFlavor.Compare: {  	var cmpi = (CompareInstruction)instruction;  	// WARNING: Capured type may not be final  	// NOTE: May capture skolemized types  	switch (cmpi.Op) {  	case CompareOp.Ceq:  	case CompareOp.CnePseudo:  		cmpi.Type = state.Peek2ComparableTypes (0' true);  		return state.PopPushType (2' global.Int32Ref' BottomPT);  	case CompareOp.Clt:  	case CompareOp.Cgt:  	case CompareOp.CgePseudo:  	case CompareOp.ClePseudo:  		cmpi.Type = state.Peek2ComparableTypes (0' false);  		return state.PopPushType (2' global.Int32Ref' BottomPT);  	case CompareOp.CtruePseudo:  	case CompareOp.CfalsePseudo:  		cmpi.Type = state.PeekIntegerOrObjectOrPointerType (0' true);  		return state.PopPushType (1' global.Int32Ref' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.ArgLocal: {  	var argi = (ArgLocalInstruction)instruction;  	var type = method.ArgLocalType (argi.ArgLocal' argi.Index);  	switch (argi.Op) {  	case ArgLocalOp.Ld:  		return state.PushType (type' state.ArgLocalPointsTo (argi.ArgLocal' argi.Index));  	case ArgLocalOp.Lda:  		return state.PushType (methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (type)' ArgLocalPT (argi.ArgLocal' argi.Index));  	case ArgLocalOp.St: {  		state.PeekExpectedType (0' type' changed);  		var pointsTo = state.PeekPointsTo (0);  		if (!pointsTo.IsBottom) {  			if (!(type.Style (methEnv) is ManagedPointerTypeStyle))  				throw new InvalidOperationException ("stack indicates pointer' but parameter or local type does not");  			if (pointsTo.PointsOutsideOfHeap)  				throw new InvalidOperationException ("arguments cannot point outside of the heap");  		}  		return state.PopAddArgLocalPointsTo (1' argi.ArgLocal' argi.Index' pointsTo);  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Field: {  	var fieldi = (FieldInstruction)instruction;  	var fieldEnv = fieldi.Field.Enter (methEnv);  	var fieldType = fieldEnv.SubstituteType (fieldEnv.Field.FieldType);  	switch (fieldi.Op) {  	case FieldOp.Ldfld:  		if (fieldi.IsStatic)  			return state.PushType (fieldType' BottomPT);  		else {  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (0' fieldi.Field.DefiningType' true' changed);  			return state.PopPushType (1' fieldType' BottomPT);  		}  	case FieldOp.Ldflda:  		if (fieldi.IsStatic)  			return state.PushType (methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (fieldType)' HeapPT);  		else {  			// Underlying type cannot be a struct' otherwise would have a pointer into  			// the stack  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (0' fieldi.Field.DefiningType' false' changed);  			return state.PopPushType (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (fieldType)' HeapPT);  		}  	case FieldOp.Stfld:  		if (fieldi.IsStatic) {  			state.PeekExpectedType (0' fieldType' changed);  			return state.Pop (1);  		}  		else {  			state.PeekExpectedType (0' fieldType' changed);  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (1' fieldi.Field.DefiningType' false' changed);  			return state.Pop (2);  		}  	case FieldOp.Ldtoken:  		return state.PushType (global.RuntimeFieldHandleRef' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Method: {  	var methi = (MethodInstruction)instruction;  	var sig = (CST.MethodSignature)methi.Method.ExternalSignature;  	switch (methi.Op) {  	case MethodOp.Call: {  		for (var i = sig.Parameters.Count - 1; i >= 1; i--)  			state.PeekExpectedType (sig.Parameters.Count - 1 - i' sig.Parameters [i]' changed);  		if (methi.Constrained != null) {  			if (!methi.IsVirtual || methi.Method.IsStatic)  				throw new InvalidOperationException ("constrained only valid on virtual calls to instance methods");  			var thisType = sig.Parameters [0];  			var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (methi.Constrained);  			var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo (methi.Constrained);  			var cs = methi.Constrained.Style (methEnv);  			if (cs is ValueTypeStyle) {  				if (thisType.Style (methEnv) is ManagedPointerTypeStyle) {  					// We pass the argument pointer as is  					if (!methi.Constrained.IsAssignableTo (methEnv' thisType.Arguments [0]))  						throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  				}  				else {  					// *Case 1* Morally we deref the argument pointer and box the contents'  					// but since no supertype of a value type may mutate the underlying value'  					// we don't need to take a copy of the value when boxing' so in practice  					// this is a no-op  					if (!constrainedBox.IsAssignableTo (methEnv' thisType))  						throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  				}  			}  			else if (cs is ReferenceTypeStyle) {  				// *Case 2* We dereference the pointer and pass the object reference  				if (!methi.Constrained.IsAssignableTo (methEnv' thisType))  					throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  			}  			else if (cs is ParameterTypeStyle) {  				// Since we are calling an instance method' we know the first argument cannot be  				// a "naked" type parameter' but is either a class or an interface.  				// We must decide between cases 1 and 2 above at runtime' but checking as  				// per case 1 is sufficient now.  				// NOTE: As for box/classcast/isinst below' if the parameter is  				// instantiated to a reference type then the type box type is considered  				// equivalent to the underyling reference type.  				if (!constrainedBox.IsAssignableTo (methEnv' thisType))  					throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  			}  			else  				throw new InvalidOperationException ("constrained must be value' reference or parameter type");  			state.PeekExpectedType (sig.Parameters.Count - 1' constrainedPtr' changed);  		}  		else if (sig.Parameters.Count > 0)  			state.PeekExpectedType (sig.Parameters.Count - 1' sig.Parameters [0]' changed);  		if (sig.Result == null)  			return state.Pop (sig.Parameters.Count);  		else  			return state.PopPushType (sig.Parameters.Count' sig.Result' BottomPT);  	}  	case MethodOp.Ldftn: {  		// NOTE: Verified CLR allows only the two "blessed" sequences:  		//   dup; ldvirtftn; newobj <delegate ctor>  		//   ldftn; newobj <delegate ctor>  		// It is thus possible to check the delegate will capture an instance which  		// implements the loaded method. However' we don't check that here.  		if (methi.IsVirtual) {  			if (methi.Method.IsStatic)  				throw new InvalidOperationException ("cannot ldvirtftn of a static method");  			var objectType = default(TypeRef);  			if (sig.Parameters [0].Style (methEnv) is ManagedPointerTypeStyle)  				// Object should be a box  				objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (sig.Parameters [0].Arguments [0]);  			else  				// Object should match parameter  				objectType = sig.Parameters [0];  			state.PeekExpectedType (0' objectType' changed);  			return state.PopPushType (1' sig.WithoutThis ().ToCodePointer (methEnv.Global)' BottomPT);  		}  		else {  			if (methi.Method.IsStatic)  				return state.PushType (sig.ToCodePointer (methEnv.Global)' BottomPT);  			else  				return state.PushType (sig.WithoutThis ().ToCodePointer (methEnv.Global)' BottomPT);  		}  	}  	case MethodOp.Newobj: {  		if (methi.Method.IsStatic || sig.Result != null)  			throw new InvalidOperationException ("not a constructor");  		for (var i = sig.Parameters.Count - 1; i >= 1; i--)  			state.PeekExpectedType (sig.Parameters.Count - 1 - i' sig.Parameters [i]' changed);  		// First argument to constructor is created by runtime. If definining type is  		// a value type' first argument will be a pointer' but result left on stack  		// will be the value itself.  		return state.PopPushType (sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);  	}  	case MethodOp.Ldtoken:  		return state.PushType (global.RuntimeMethodHandleRef' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Type: {  	var typei = (TypeInstruction)instruction;  	switch (typei.Op) {  	case TypeOp.Ldobj:  		state.PeekReadPointerType (0' typei.Type);  		return state.PopPushType (1' typei.Type' BottomPT);  	case TypeOp.Stobj:  		state.PeekExpectedType (0' typei.Type' changed);  		state.PeekWritePointerType (1' typei.Type);  		return state.Pop (2);  	case TypeOp.Cpobj:  		state.PeekReadPointerType (0' typei.Type);  		state.PeekWritePointerType (1' typei.Type);  		return state.Pop (2);  	case TypeOp.Newarr:  		state.PeekIndexType (0);  		return state.PopPushType (1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo (typei.Type)' BottomPT);  	case TypeOp.Initobj:  		state.PeekWritePointerType (0' typei.Type);  		return state.Pop (1);  	case TypeOp.Castclass:  	case TypeOp.Isinst:  	case TypeOp.Box: {  		var resultType = default(TypeRef);  		var s = typei.Type.Style (methEnv);  		if (s is NullableTypeStyle)  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type.Arguments [0]);  		else if (s is ValueTypeStyle)  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type);  		else if (s is ReferenceTypeStyle)  			resultType = typei.Type;  		else if (s is ParameterTypeStyle)  			// NOTE: As for constrained call above' if type parameter is instantitated to  			// a ref type' then this box type is considered equivalent to the  			// underlying reference type.  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type);  		else  			throw new InvalidOperationException ("can only box/cast to reference' value or parameter type");  		if (typei.Op == TypeOp.Box)  			state.PeekExpectedType (0' typei.Type' changed);  		else  			state.PeekReferenceType (0);  		return state.PopPushType (1' resultType' BottomPT);  	}  	case TypeOp.Unbox:  		if (!(typei.Type.Style (methEnv) is ValueTypeStyle))  			// Parameter types are not allowed  			throw new InvalidOperationException ("type must be a value type");  		state.PeekBoxedType (0' typei.Type' changed);  		return state.PopPushType (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (typei.Type)' HeapPT);  	case TypeOp.UnboxAny: {  		var s = typei.Type.Style (methEnv);  		if (s is ValueTypeStyle)  			state.PeekBoxedType (0' typei.Type' changed);  		else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))  			throw new InvalidOperationException ("type must be value' reference or parameter type");  		return state.PopPushType (1' typei.Type' BottomPT);  	}  	case TypeOp.Ldtoken:  		return state.PushType (global.RuntimeTypeHandleRef' BottomPT);  	case TypeOp.Ldelem:  		state.PeekIndexType (0);  		state.PeekReadArrayType (1' typei.Type' false);  		return state.PopPushType (2' typei.Type' BottomPT);  	case TypeOp.Stelem:  		state.PeekExpectedType (0' typei.Type' changed);  		state.PeekIndexType (1);  		state.PeekWriteArrayType (2' typei.Type);  		return state.Pop (3);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.LdElemAddr: {  	var ldelemai = (LdElemAddrInstruction)instruction;  	state.PeekIndexType (0);  	// WARNING: May prematurely fail for non-readonly loads  	state.PeekReadArrayType (1' ldelemai.Type' !ldelemai.IsReadonly);  	return state.PopPushType (2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (ldelemai.Type)' HeapPT);  }  case InstructionFlavor.LdInt32:  	return state.PushType (global.Int32Ref' BottomPT);  case InstructionFlavor.LdInt64:  	return state.PushType (global.Int64Ref' BottomPT);  case InstructionFlavor.LdSingle:  	return state.PushType (global.DoubleRef' BottomPT);  case InstructionFlavor.LdDouble:  	return state.PushType (global.DoubleRef' BottomPT);  case InstructionFlavor.LdString:  	return state.PushType (global.StringRef' BottomPT);  case InstructionFlavor.Arith: {  	var arithi = (ArithInstruction)instruction;  	switch (arithi.Op) {  	case ArithOp.Add:  	case ArithOp.Sub:  	case ArithOp.Mul:  	case ArithOp.Div:  	case ArithOp.Rem:  		// NOTE: May capture skolemized types  		arithi.Type = state.Peek2NumberTypes (0' true);  		return state.PopPushType (2' arithi.Type' BottomPT);  	case ArithOp.Neg:  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (0' true);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (1' arithi.Type' BottomPT);  	case ArithOp.BitAnd:  	case ArithOp.BitOr:  	case ArithOp.BitXor:  		// NOTE: May capture skolemized types  		arithi.Type = state.Peek2NumberTypes (0' false);  		return state.PopPushType (2' arithi.Type' BottomPT);  	case ArithOp.BitNot:  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (0' false);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (1' arithi.Type' BottomPT);  	case ArithOp.Shl:  	case ArithOp.Shr:  		state.PeekExpectedType (0' global.Int32Ref' changed);  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (1' false);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (2' arithi.Type' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Conv: {  	var convi = (ConvInstruction)instruction;  	var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned && convi.TargetNumberFlavor == NumberFlavor.Double);  	// NOTE: May capture skolemized types  	convi.SourceType = state.PeekNumberType (0' !mustBeInteger);  	return state.PopPushType (1' TypeRef.NumberFrom (methEnv.Global' convi.TargetNumberFlavor)' BottomPT);  }  case InstructionFlavor.Try: {  	var tryi = (TryInstruction)instruction;  	// Isolation:  	//  - There is no way for the current stack shape to influence or be influenced by  	//    inference of the try' since the current stack shape must be empty.  	//  - There is no way for the try to influence the result stack shape' since it must be  	//    empty.  	//  - However pointers in arguments and locals may propogate into and out of try body  	//    via exceptional transitions. The latter are delt with separately.  	if (state.Depth != 0)  		throw new InvalidOperationException ("stack should be empty");  	var newState = ForwardBlock (new TryBodyInstructionContext (context' index' tryi.Body)' state' changed);  	for (var j = 0; j < tryi.Handlers.Count; j++) {  		var h = tryi.Handlers [j];  		var handlerContext = new TryHandlerInstructionContext (context' index' h.Body' j);  		var initHandlerState = new MachineState (methEnv' method.ValueParameters.Count' method.Locals.Count);  		switch (h.Flavor) {  		case HandlerFlavor.Catch: {  			var catchh = (CatchTryInstructionHandler)h;  			ForwardBlock (handlerContext' initHandlerState.PushType (catchh.Type' BottomPT)' changed);  			break;  		}  		case HandlerFlavor.Filter:  			throw new NotSupportedException ("filter handler blocks");  		case HandlerFlavor.Fault:  		case HandlerFlavor.Finally:  			ForwardBlock (handlerContext' initHandlerState' changed);  			break;  		default:  			throw new ArgumentOutOfRangeException ();  		}  	}  	return newState;  }  case InstructionFlavor.IfThenElsePseudo:  case InstructionFlavor.ShortCircuitingPseudo:  case InstructionFlavor.StructuralSwitchPseudo:  case InstructionFlavor.LoopPseudo:  case InstructionFlavor.WhileDoPseudo:  case InstructionFlavor.DoWhilePseudo:  case InstructionFlavor.LoopControlPseudo:  	throw new InvalidOperationException ("no machine state inference for psuedo-instructions");  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor) {  case InstructionFlavor.Unsupported:  	throw new InvalidOperationException ("unsupported opcode");  case InstructionFlavor.Misc: {  	var misci = (MiscInstruction)instruction;  	switch (misci.Op) {  	case MiscOp.Nop:  	case MiscOp.Break:  		return state;  	case MiscOp.Dup:  		return state.Push (state.Peek (0));  	case MiscOp.Pop:  		return state.Pop (1);  	case MiscOp.Ldnull:  		return state.PushType (global.NullRef' BottomPT);  	case MiscOp.Ckfinite:  		state.PeekExpectedType (0' global.DoubleRef' changed);  		// Assume the instruction can "peek" at top of stack' thus no need for pop/push.  		return state;  	case MiscOp.Throw:  		state.PeekReferenceType (0);  		return state.DiscardStack ();  	case MiscOp.Rethrow:  		return state.DiscardStack ();  	case MiscOp.LdindRef: {  		var elemType = state.PeekPointerToReferenceType (0);  		return state.PopPushType (1' elemType' BottomPT);  	}  	case MiscOp.StindRef: {  		var expElemType = state.PeekPointerToReferenceType (1);  		state.PeekExpectedType (0' expElemType' changed);  		return state.Pop (2);  	}  	case MiscOp.LdelemRef: {  		state.PeekIndexType (0);  		// WARNING: Type may not be final  		var elemType = state.PeekArrayOfReferenceType (1);  		return state.PopPushType (2' elemType' BottomPT);  	}  	case MiscOp.StelemRef:  		state.PeekReferenceType (0);  		state.PeekIndexType (1);  		state.PeekArrayOfReferenceType (2);  		// Since the value type and array element type may be independently generalized'  		// it is pointless to check that the first is assignable to the second.  		// Instead this check is done at runtime.  		return state.Pop (3);  	case MiscOp.Ldlen:  		state.PeekArrayOfAnyType (0);  		return state.PopPushType (1' global.IntNativeRef' BottomPT);  	case MiscOp.Ret: {  		if (state.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return state;  		// empty  	}  	case MiscOp.RetVal: {  		state.PeekExpectedType (0' method.Result.Type' changed);  		var newState = state.Pop (1);  		if (newState.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return newState;  		// empty  	}  	case MiscOp.Endfilter: {  		state.PeekExpectedType (0' global.Int32Ref' changed);  		var newState = state.Pop (1);  		if (newState.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return newState;  		// empty  	}  	case MiscOp.Endfinally: {  		// Control could transfer to an outer finally/fault block' or to the target  		// of a leave instruction. However these transitions are delt with separately.  		return state.DiscardStack ();  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Branch: {  	var bri = (BranchInstruction)instruction;  	switch (bri.Op) {  	case BranchOp.Br:  		UnifyBeforeState (state' bri.Target' changed);  		return state;  	case BranchOp.Brtrue: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.PeekIntegerOrObjectOrPointerType (0' false);  		var newState = state.Pop (1);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Brfalse: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.PeekIntegerOrObjectOrPointerType (0' true);  		var newState = state.Pop (1);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Breq:  	case BranchOp.Brne: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.Peek2ComparableTypes (0' true);  		var newState = state.Pop (2);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Leave: {  		// Control could transfer via finally blocks instead of directly to the leave target.  		// Propogate only that the stack must be empty at target. Remaining machine state  		// is dealt with separately.  		UnifyBeforeState (new MachineState (methEnv' method.ValueParameters.Count' method.Locals.Count)' bri.Target' changed);  		return state.DiscardStack ();  	}  	case BranchOp.BrLt:  	case BranchOp.BrLe:  	case BranchOp.BrGt:  	case BranchOp.BrGe: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.Peek2ComparableTypes (0' false);  		var newState = state.Pop (2);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Switch: {  	var switchi = (SwitchInstruction)instruction;  	state.PeekExpectedType (0' global.Int32Ref' changed);  	var newState = state.Pop (1);  	for (var i = 0; i < switchi.CaseTargets.Count; i++)  		UnifyBeforeState (newState' switchi.CaseTargets [i]' changed);  	return newState;  }  case InstructionFlavor.Compare: {  	var cmpi = (CompareInstruction)instruction;  	// WARNING: Capured type may not be final  	// NOTE: May capture skolemized types  	switch (cmpi.Op) {  	case CompareOp.Ceq:  	case CompareOp.CnePseudo:  		cmpi.Type = state.Peek2ComparableTypes (0' true);  		return state.PopPushType (2' global.Int32Ref' BottomPT);  	case CompareOp.Clt:  	case CompareOp.Cgt:  	case CompareOp.CgePseudo:  	case CompareOp.ClePseudo:  		cmpi.Type = state.Peek2ComparableTypes (0' false);  		return state.PopPushType (2' global.Int32Ref' BottomPT);  	case CompareOp.CtruePseudo:  	case CompareOp.CfalsePseudo:  		cmpi.Type = state.PeekIntegerOrObjectOrPointerType (0' true);  		return state.PopPushType (1' global.Int32Ref' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.ArgLocal: {  	var argi = (ArgLocalInstruction)instruction;  	var type = method.ArgLocalType (argi.ArgLocal' argi.Index);  	switch (argi.Op) {  	case ArgLocalOp.Ld:  		return state.PushType (type' state.ArgLocalPointsTo (argi.ArgLocal' argi.Index));  	case ArgLocalOp.Lda:  		return state.PushType (methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (type)' ArgLocalPT (argi.ArgLocal' argi.Index));  	case ArgLocalOp.St: {  		state.PeekExpectedType (0' type' changed);  		var pointsTo = state.PeekPointsTo (0);  		if (!pointsTo.IsBottom) {  			if (!(type.Style (methEnv) is ManagedPointerTypeStyle))  				throw new InvalidOperationException ("stack indicates pointer' but parameter or local type does not");  			if (pointsTo.PointsOutsideOfHeap)  				throw new InvalidOperationException ("arguments cannot point outside of the heap");  		}  		return state.PopAddArgLocalPointsTo (1' argi.ArgLocal' argi.Index' pointsTo);  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Field: {  	var fieldi = (FieldInstruction)instruction;  	var fieldEnv = fieldi.Field.Enter (methEnv);  	var fieldType = fieldEnv.SubstituteType (fieldEnv.Field.FieldType);  	switch (fieldi.Op) {  	case FieldOp.Ldfld:  		if (fieldi.IsStatic)  			return state.PushType (fieldType' BottomPT);  		else {  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (0' fieldi.Field.DefiningType' true' changed);  			return state.PopPushType (1' fieldType' BottomPT);  		}  	case FieldOp.Ldflda:  		if (fieldi.IsStatic)  			return state.PushType (methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (fieldType)' HeapPT);  		else {  			// Underlying type cannot be a struct' otherwise would have a pointer into  			// the stack  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (0' fieldi.Field.DefiningType' false' changed);  			return state.PopPushType (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (fieldType)' HeapPT);  		}  	case FieldOp.Stfld:  		if (fieldi.IsStatic) {  			state.PeekExpectedType (0' fieldType' changed);  			return state.Pop (1);  		}  		else {  			state.PeekExpectedType (0' fieldType' changed);  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (1' fieldi.Field.DefiningType' false' changed);  			return state.Pop (2);  		}  	case FieldOp.Ldtoken:  		return state.PushType (global.RuntimeFieldHandleRef' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Method: {  	var methi = (MethodInstruction)instruction;  	var sig = (CST.MethodSignature)methi.Method.ExternalSignature;  	switch (methi.Op) {  	case MethodOp.Call: {  		for (var i = sig.Parameters.Count - 1; i >= 1; i--)  			state.PeekExpectedType (sig.Parameters.Count - 1 - i' sig.Parameters [i]' changed);  		if (methi.Constrained != null) {  			if (!methi.IsVirtual || methi.Method.IsStatic)  				throw new InvalidOperationException ("constrained only valid on virtual calls to instance methods");  			var thisType = sig.Parameters [0];  			var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (methi.Constrained);  			var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo (methi.Constrained);  			var cs = methi.Constrained.Style (methEnv);  			if (cs is ValueTypeStyle) {  				if (thisType.Style (methEnv) is ManagedPointerTypeStyle) {  					// We pass the argument pointer as is  					if (!methi.Constrained.IsAssignableTo (methEnv' thisType.Arguments [0]))  						throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  				}  				else {  					// *Case 1* Morally we deref the argument pointer and box the contents'  					// but since no supertype of a value type may mutate the underlying value'  					// we don't need to take a copy of the value when boxing' so in practice  					// this is a no-op  					if (!constrainedBox.IsAssignableTo (methEnv' thisType))  						throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  				}  			}  			else if (cs is ReferenceTypeStyle) {  				// *Case 2* We dereference the pointer and pass the object reference  				if (!methi.Constrained.IsAssignableTo (methEnv' thisType))  					throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  			}  			else if (cs is ParameterTypeStyle) {  				// Since we are calling an instance method' we know the first argument cannot be  				// a "naked" type parameter' but is either a class or an interface.  				// We must decide between cases 1 and 2 above at runtime' but checking as  				// per case 1 is sufficient now.  				// NOTE: As for box/classcast/isinst below' if the parameter is  				// instantiated to a reference type then the type box type is considered  				// equivalent to the underyling reference type.  				if (!constrainedBox.IsAssignableTo (methEnv' thisType))  					throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  			}  			else  				throw new InvalidOperationException ("constrained must be value' reference or parameter type");  			state.PeekExpectedType (sig.Parameters.Count - 1' constrainedPtr' changed);  		}  		else if (sig.Parameters.Count > 0)  			state.PeekExpectedType (sig.Parameters.Count - 1' sig.Parameters [0]' changed);  		if (sig.Result == null)  			return state.Pop (sig.Parameters.Count);  		else  			return state.PopPushType (sig.Parameters.Count' sig.Result' BottomPT);  	}  	case MethodOp.Ldftn: {  		// NOTE: Verified CLR allows only the two "blessed" sequences:  		//   dup; ldvirtftn; newobj <delegate ctor>  		//   ldftn; newobj <delegate ctor>  		// It is thus possible to check the delegate will capture an instance which  		// implements the loaded method. However' we don't check that here.  		if (methi.IsVirtual) {  			if (methi.Method.IsStatic)  				throw new InvalidOperationException ("cannot ldvirtftn of a static method");  			var objectType = default(TypeRef);  			if (sig.Parameters [0].Style (methEnv) is ManagedPointerTypeStyle)  				// Object should be a box  				objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (sig.Parameters [0].Arguments [0]);  			else  				// Object should match parameter  				objectType = sig.Parameters [0];  			state.PeekExpectedType (0' objectType' changed);  			return state.PopPushType (1' sig.WithoutThis ().ToCodePointer (methEnv.Global)' BottomPT);  		}  		else {  			if (methi.Method.IsStatic)  				return state.PushType (sig.ToCodePointer (methEnv.Global)' BottomPT);  			else  				return state.PushType (sig.WithoutThis ().ToCodePointer (methEnv.Global)' BottomPT);  		}  	}  	case MethodOp.Newobj: {  		if (methi.Method.IsStatic || sig.Result != null)  			throw new InvalidOperationException ("not a constructor");  		for (var i = sig.Parameters.Count - 1; i >= 1; i--)  			state.PeekExpectedType (sig.Parameters.Count - 1 - i' sig.Parameters [i]' changed);  		// First argument to constructor is created by runtime. If definining type is  		// a value type' first argument will be a pointer' but result left on stack  		// will be the value itself.  		return state.PopPushType (sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);  	}  	case MethodOp.Ldtoken:  		return state.PushType (global.RuntimeMethodHandleRef' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Type: {  	var typei = (TypeInstruction)instruction;  	switch (typei.Op) {  	case TypeOp.Ldobj:  		state.PeekReadPointerType (0' typei.Type);  		return state.PopPushType (1' typei.Type' BottomPT);  	case TypeOp.Stobj:  		state.PeekExpectedType (0' typei.Type' changed);  		state.PeekWritePointerType (1' typei.Type);  		return state.Pop (2);  	case TypeOp.Cpobj:  		state.PeekReadPointerType (0' typei.Type);  		state.PeekWritePointerType (1' typei.Type);  		return state.Pop (2);  	case TypeOp.Newarr:  		state.PeekIndexType (0);  		return state.PopPushType (1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo (typei.Type)' BottomPT);  	case TypeOp.Initobj:  		state.PeekWritePointerType (0' typei.Type);  		return state.Pop (1);  	case TypeOp.Castclass:  	case TypeOp.Isinst:  	case TypeOp.Box: {  		var resultType = default(TypeRef);  		var s = typei.Type.Style (methEnv);  		if (s is NullableTypeStyle)  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type.Arguments [0]);  		else if (s is ValueTypeStyle)  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type);  		else if (s is ReferenceTypeStyle)  			resultType = typei.Type;  		else if (s is ParameterTypeStyle)  			// NOTE: As for constrained call above' if type parameter is instantitated to  			// a ref type' then this box type is considered equivalent to the  			// underlying reference type.  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type);  		else  			throw new InvalidOperationException ("can only box/cast to reference' value or parameter type");  		if (typei.Op == TypeOp.Box)  			state.PeekExpectedType (0' typei.Type' changed);  		else  			state.PeekReferenceType (0);  		return state.PopPushType (1' resultType' BottomPT);  	}  	case TypeOp.Unbox:  		if (!(typei.Type.Style (methEnv) is ValueTypeStyle))  			// Parameter types are not allowed  			throw new InvalidOperationException ("type must be a value type");  		state.PeekBoxedType (0' typei.Type' changed);  		return state.PopPushType (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (typei.Type)' HeapPT);  	case TypeOp.UnboxAny: {  		var s = typei.Type.Style (methEnv);  		if (s is ValueTypeStyle)  			state.PeekBoxedType (0' typei.Type' changed);  		else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))  			throw new InvalidOperationException ("type must be value' reference or parameter type");  		return state.PopPushType (1' typei.Type' BottomPT);  	}  	case TypeOp.Ldtoken:  		return state.PushType (global.RuntimeTypeHandleRef' BottomPT);  	case TypeOp.Ldelem:  		state.PeekIndexType (0);  		state.PeekReadArrayType (1' typei.Type' false);  		return state.PopPushType (2' typei.Type' BottomPT);  	case TypeOp.Stelem:  		state.PeekExpectedType (0' typei.Type' changed);  		state.PeekIndexType (1);  		state.PeekWriteArrayType (2' typei.Type);  		return state.Pop (3);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.LdElemAddr: {  	var ldelemai = (LdElemAddrInstruction)instruction;  	state.PeekIndexType (0);  	// WARNING: May prematurely fail for non-readonly loads  	state.PeekReadArrayType (1' ldelemai.Type' !ldelemai.IsReadonly);  	return state.PopPushType (2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (ldelemai.Type)' HeapPT);  }  case InstructionFlavor.LdInt32:  	return state.PushType (global.Int32Ref' BottomPT);  case InstructionFlavor.LdInt64:  	return state.PushType (global.Int64Ref' BottomPT);  case InstructionFlavor.LdSingle:  	return state.PushType (global.DoubleRef' BottomPT);  case InstructionFlavor.LdDouble:  	return state.PushType (global.DoubleRef' BottomPT);  case InstructionFlavor.LdString:  	return state.PushType (global.StringRef' BottomPT);  case InstructionFlavor.Arith: {  	var arithi = (ArithInstruction)instruction;  	switch (arithi.Op) {  	case ArithOp.Add:  	case ArithOp.Sub:  	case ArithOp.Mul:  	case ArithOp.Div:  	case ArithOp.Rem:  		// NOTE: May capture skolemized types  		arithi.Type = state.Peek2NumberTypes (0' true);  		return state.PopPushType (2' arithi.Type' BottomPT);  	case ArithOp.Neg:  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (0' true);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (1' arithi.Type' BottomPT);  	case ArithOp.BitAnd:  	case ArithOp.BitOr:  	case ArithOp.BitXor:  		// NOTE: May capture skolemized types  		arithi.Type = state.Peek2NumberTypes (0' false);  		return state.PopPushType (2' arithi.Type' BottomPT);  	case ArithOp.BitNot:  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (0' false);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (1' arithi.Type' BottomPT);  	case ArithOp.Shl:  	case ArithOp.Shr:  		state.PeekExpectedType (0' global.Int32Ref' changed);  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (1' false);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (2' arithi.Type' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Conv: {  	var convi = (ConvInstruction)instruction;  	var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned && convi.TargetNumberFlavor == NumberFlavor.Double);  	// NOTE: May capture skolemized types  	convi.SourceType = state.PeekNumberType (0' !mustBeInteger);  	return state.PopPushType (1' TypeRef.NumberFrom (methEnv.Global' convi.TargetNumberFlavor)' BottomPT);  }  case InstructionFlavor.Try: {  	var tryi = (TryInstruction)instruction;  	// Isolation:  	//  - There is no way for the current stack shape to influence or be influenced by  	//    inference of the try' since the current stack shape must be empty.  	//  - There is no way for the try to influence the result stack shape' since it must be  	//    empty.  	//  - However pointers in arguments and locals may propogate into and out of try body  	//    via exceptional transitions. The latter are delt with separately.  	if (state.Depth != 0)  		throw new InvalidOperationException ("stack should be empty");  	var newState = ForwardBlock (new TryBodyInstructionContext (context' index' tryi.Body)' state' changed);  	for (var j = 0; j < tryi.Handlers.Count; j++) {  		var h = tryi.Handlers [j];  		var handlerContext = new TryHandlerInstructionContext (context' index' h.Body' j);  		var initHandlerState = new MachineState (methEnv' method.ValueParameters.Count' method.Locals.Count);  		switch (h.Flavor) {  		case HandlerFlavor.Catch: {  			var catchh = (CatchTryInstructionHandler)h;  			ForwardBlock (handlerContext' initHandlerState.PushType (catchh.Type' BottomPT)' changed);  			break;  		}  		case HandlerFlavor.Filter:  			throw new NotSupportedException ("filter handler blocks");  		case HandlerFlavor.Fault:  		case HandlerFlavor.Finally:  			ForwardBlock (handlerContext' initHandlerState' changed);  			break;  		default:  			throw new ArgumentOutOfRangeException ();  		}  	}  	return newState;  }  case InstructionFlavor.IfThenElsePseudo:  case InstructionFlavor.ShortCircuitingPseudo:  case InstructionFlavor.StructuralSwitchPseudo:  case InstructionFlavor.LoopPseudo:  case InstructionFlavor.WhileDoPseudo:  case InstructionFlavor.DoWhilePseudo:  case InstructionFlavor.LoopControlPseudo:  	throw new InvalidOperationException ("no machine state inference for psuedo-instructions");  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor) {  case InstructionFlavor.Unsupported:  	throw new InvalidOperationException ("unsupported opcode");  case InstructionFlavor.Misc: {  	var misci = (MiscInstruction)instruction;  	switch (misci.Op) {  	case MiscOp.Nop:  	case MiscOp.Break:  		return state;  	case MiscOp.Dup:  		return state.Push (state.Peek (0));  	case MiscOp.Pop:  		return state.Pop (1);  	case MiscOp.Ldnull:  		return state.PushType (global.NullRef' BottomPT);  	case MiscOp.Ckfinite:  		state.PeekExpectedType (0' global.DoubleRef' changed);  		// Assume the instruction can "peek" at top of stack' thus no need for pop/push.  		return state;  	case MiscOp.Throw:  		state.PeekReferenceType (0);  		return state.DiscardStack ();  	case MiscOp.Rethrow:  		return state.DiscardStack ();  	case MiscOp.LdindRef: {  		var elemType = state.PeekPointerToReferenceType (0);  		return state.PopPushType (1' elemType' BottomPT);  	}  	case MiscOp.StindRef: {  		var expElemType = state.PeekPointerToReferenceType (1);  		state.PeekExpectedType (0' expElemType' changed);  		return state.Pop (2);  	}  	case MiscOp.LdelemRef: {  		state.PeekIndexType (0);  		// WARNING: Type may not be final  		var elemType = state.PeekArrayOfReferenceType (1);  		return state.PopPushType (2' elemType' BottomPT);  	}  	case MiscOp.StelemRef:  		state.PeekReferenceType (0);  		state.PeekIndexType (1);  		state.PeekArrayOfReferenceType (2);  		// Since the value type and array element type may be independently generalized'  		// it is pointless to check that the first is assignable to the second.  		// Instead this check is done at runtime.  		return state.Pop (3);  	case MiscOp.Ldlen:  		state.PeekArrayOfAnyType (0);  		return state.PopPushType (1' global.IntNativeRef' BottomPT);  	case MiscOp.Ret: {  		if (state.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return state;  		// empty  	}  	case MiscOp.RetVal: {  		state.PeekExpectedType (0' method.Result.Type' changed);  		var newState = state.Pop (1);  		if (newState.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return newState;  		// empty  	}  	case MiscOp.Endfilter: {  		state.PeekExpectedType (0' global.Int32Ref' changed);  		var newState = state.Pop (1);  		if (newState.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return newState;  		// empty  	}  	case MiscOp.Endfinally: {  		// Control could transfer to an outer finally/fault block' or to the target  		// of a leave instruction. However these transitions are delt with separately.  		return state.DiscardStack ();  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Branch: {  	var bri = (BranchInstruction)instruction;  	switch (bri.Op) {  	case BranchOp.Br:  		UnifyBeforeState (state' bri.Target' changed);  		return state;  	case BranchOp.Brtrue: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.PeekIntegerOrObjectOrPointerType (0' false);  		var newState = state.Pop (1);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Brfalse: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.PeekIntegerOrObjectOrPointerType (0' true);  		var newState = state.Pop (1);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Breq:  	case BranchOp.Brne: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.Peek2ComparableTypes (0' true);  		var newState = state.Pop (2);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Leave: {  		// Control could transfer via finally blocks instead of directly to the leave target.  		// Propogate only that the stack must be empty at target. Remaining machine state  		// is dealt with separately.  		UnifyBeforeState (new MachineState (methEnv' method.ValueParameters.Count' method.Locals.Count)' bri.Target' changed);  		return state.DiscardStack ();  	}  	case BranchOp.BrLt:  	case BranchOp.BrLe:  	case BranchOp.BrGt:  	case BranchOp.BrGe: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.Peek2ComparableTypes (0' false);  		var newState = state.Pop (2);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Switch: {  	var switchi = (SwitchInstruction)instruction;  	state.PeekExpectedType (0' global.Int32Ref' changed);  	var newState = state.Pop (1);  	for (var i = 0; i < switchi.CaseTargets.Count; i++)  		UnifyBeforeState (newState' switchi.CaseTargets [i]' changed);  	return newState;  }  case InstructionFlavor.Compare: {  	var cmpi = (CompareInstruction)instruction;  	// WARNING: Capured type may not be final  	// NOTE: May capture skolemized types  	switch (cmpi.Op) {  	case CompareOp.Ceq:  	case CompareOp.CnePseudo:  		cmpi.Type = state.Peek2ComparableTypes (0' true);  		return state.PopPushType (2' global.Int32Ref' BottomPT);  	case CompareOp.Clt:  	case CompareOp.Cgt:  	case CompareOp.CgePseudo:  	case CompareOp.ClePseudo:  		cmpi.Type = state.Peek2ComparableTypes (0' false);  		return state.PopPushType (2' global.Int32Ref' BottomPT);  	case CompareOp.CtruePseudo:  	case CompareOp.CfalsePseudo:  		cmpi.Type = state.PeekIntegerOrObjectOrPointerType (0' true);  		return state.PopPushType (1' global.Int32Ref' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.ArgLocal: {  	var argi = (ArgLocalInstruction)instruction;  	var type = method.ArgLocalType (argi.ArgLocal' argi.Index);  	switch (argi.Op) {  	case ArgLocalOp.Ld:  		return state.PushType (type' state.ArgLocalPointsTo (argi.ArgLocal' argi.Index));  	case ArgLocalOp.Lda:  		return state.PushType (methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (type)' ArgLocalPT (argi.ArgLocal' argi.Index));  	case ArgLocalOp.St: {  		state.PeekExpectedType (0' type' changed);  		var pointsTo = state.PeekPointsTo (0);  		if (!pointsTo.IsBottom) {  			if (!(type.Style (methEnv) is ManagedPointerTypeStyle))  				throw new InvalidOperationException ("stack indicates pointer' but parameter or local type does not");  			if (pointsTo.PointsOutsideOfHeap)  				throw new InvalidOperationException ("arguments cannot point outside of the heap");  		}  		return state.PopAddArgLocalPointsTo (1' argi.ArgLocal' argi.Index' pointsTo);  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Field: {  	var fieldi = (FieldInstruction)instruction;  	var fieldEnv = fieldi.Field.Enter (methEnv);  	var fieldType = fieldEnv.SubstituteType (fieldEnv.Field.FieldType);  	switch (fieldi.Op) {  	case FieldOp.Ldfld:  		if (fieldi.IsStatic)  			return state.PushType (fieldType' BottomPT);  		else {  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (0' fieldi.Field.DefiningType' true' changed);  			return state.PopPushType (1' fieldType' BottomPT);  		}  	case FieldOp.Ldflda:  		if (fieldi.IsStatic)  			return state.PushType (methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (fieldType)' HeapPT);  		else {  			// Underlying type cannot be a struct' otherwise would have a pointer into  			// the stack  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (0' fieldi.Field.DefiningType' false' changed);  			return state.PopPushType (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (fieldType)' HeapPT);  		}  	case FieldOp.Stfld:  		if (fieldi.IsStatic) {  			state.PeekExpectedType (0' fieldType' changed);  			return state.Pop (1);  		}  		else {  			state.PeekExpectedType (0' fieldType' changed);  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (1' fieldi.Field.DefiningType' false' changed);  			return state.Pop (2);  		}  	case FieldOp.Ldtoken:  		return state.PushType (global.RuntimeFieldHandleRef' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Method: {  	var methi = (MethodInstruction)instruction;  	var sig = (CST.MethodSignature)methi.Method.ExternalSignature;  	switch (methi.Op) {  	case MethodOp.Call: {  		for (var i = sig.Parameters.Count - 1; i >= 1; i--)  			state.PeekExpectedType (sig.Parameters.Count - 1 - i' sig.Parameters [i]' changed);  		if (methi.Constrained != null) {  			if (!methi.IsVirtual || methi.Method.IsStatic)  				throw new InvalidOperationException ("constrained only valid on virtual calls to instance methods");  			var thisType = sig.Parameters [0];  			var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (methi.Constrained);  			var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo (methi.Constrained);  			var cs = methi.Constrained.Style (methEnv);  			if (cs is ValueTypeStyle) {  				if (thisType.Style (methEnv) is ManagedPointerTypeStyle) {  					// We pass the argument pointer as is  					if (!methi.Constrained.IsAssignableTo (methEnv' thisType.Arguments [0]))  						throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  				}  				else {  					// *Case 1* Morally we deref the argument pointer and box the contents'  					// but since no supertype of a value type may mutate the underlying value'  					// we don't need to take a copy of the value when boxing' so in practice  					// this is a no-op  					if (!constrainedBox.IsAssignableTo (methEnv' thisType))  						throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  				}  			}  			else if (cs is ReferenceTypeStyle) {  				// *Case 2* We dereference the pointer and pass the object reference  				if (!methi.Constrained.IsAssignableTo (methEnv' thisType))  					throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  			}  			else if (cs is ParameterTypeStyle) {  				// Since we are calling an instance method' we know the first argument cannot be  				// a "naked" type parameter' but is either a class or an interface.  				// We must decide between cases 1 and 2 above at runtime' but checking as  				// per case 1 is sufficient now.  				// NOTE: As for box/classcast/isinst below' if the parameter is  				// instantiated to a reference type then the type box type is considered  				// equivalent to the underyling reference type.  				if (!constrainedBox.IsAssignableTo (methEnv' thisType))  					throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  			}  			else  				throw new InvalidOperationException ("constrained must be value' reference or parameter type");  			state.PeekExpectedType (sig.Parameters.Count - 1' constrainedPtr' changed);  		}  		else if (sig.Parameters.Count > 0)  			state.PeekExpectedType (sig.Parameters.Count - 1' sig.Parameters [0]' changed);  		if (sig.Result == null)  			return state.Pop (sig.Parameters.Count);  		else  			return state.PopPushType (sig.Parameters.Count' sig.Result' BottomPT);  	}  	case MethodOp.Ldftn: {  		// NOTE: Verified CLR allows only the two "blessed" sequences:  		//   dup; ldvirtftn; newobj <delegate ctor>  		//   ldftn; newobj <delegate ctor>  		// It is thus possible to check the delegate will capture an instance which  		// implements the loaded method. However' we don't check that here.  		if (methi.IsVirtual) {  			if (methi.Method.IsStatic)  				throw new InvalidOperationException ("cannot ldvirtftn of a static method");  			var objectType = default(TypeRef);  			if (sig.Parameters [0].Style (methEnv) is ManagedPointerTypeStyle)  				// Object should be a box  				objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (sig.Parameters [0].Arguments [0]);  			else  				// Object should match parameter  				objectType = sig.Parameters [0];  			state.PeekExpectedType (0' objectType' changed);  			return state.PopPushType (1' sig.WithoutThis ().ToCodePointer (methEnv.Global)' BottomPT);  		}  		else {  			if (methi.Method.IsStatic)  				return state.PushType (sig.ToCodePointer (methEnv.Global)' BottomPT);  			else  				return state.PushType (sig.WithoutThis ().ToCodePointer (methEnv.Global)' BottomPT);  		}  	}  	case MethodOp.Newobj: {  		if (methi.Method.IsStatic || sig.Result != null)  			throw new InvalidOperationException ("not a constructor");  		for (var i = sig.Parameters.Count - 1; i >= 1; i--)  			state.PeekExpectedType (sig.Parameters.Count - 1 - i' sig.Parameters [i]' changed);  		// First argument to constructor is created by runtime. If definining type is  		// a value type' first argument will be a pointer' but result left on stack  		// will be the value itself.  		return state.PopPushType (sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);  	}  	case MethodOp.Ldtoken:  		return state.PushType (global.RuntimeMethodHandleRef' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Type: {  	var typei = (TypeInstruction)instruction;  	switch (typei.Op) {  	case TypeOp.Ldobj:  		state.PeekReadPointerType (0' typei.Type);  		return state.PopPushType (1' typei.Type' BottomPT);  	case TypeOp.Stobj:  		state.PeekExpectedType (0' typei.Type' changed);  		state.PeekWritePointerType (1' typei.Type);  		return state.Pop (2);  	case TypeOp.Cpobj:  		state.PeekReadPointerType (0' typei.Type);  		state.PeekWritePointerType (1' typei.Type);  		return state.Pop (2);  	case TypeOp.Newarr:  		state.PeekIndexType (0);  		return state.PopPushType (1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo (typei.Type)' BottomPT);  	case TypeOp.Initobj:  		state.PeekWritePointerType (0' typei.Type);  		return state.Pop (1);  	case TypeOp.Castclass:  	case TypeOp.Isinst:  	case TypeOp.Box: {  		var resultType = default(TypeRef);  		var s = typei.Type.Style (methEnv);  		if (s is NullableTypeStyle)  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type.Arguments [0]);  		else if (s is ValueTypeStyle)  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type);  		else if (s is ReferenceTypeStyle)  			resultType = typei.Type;  		else if (s is ParameterTypeStyle)  			// NOTE: As for constrained call above' if type parameter is instantitated to  			// a ref type' then this box type is considered equivalent to the  			// underlying reference type.  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type);  		else  			throw new InvalidOperationException ("can only box/cast to reference' value or parameter type");  		if (typei.Op == TypeOp.Box)  			state.PeekExpectedType (0' typei.Type' changed);  		else  			state.PeekReferenceType (0);  		return state.PopPushType (1' resultType' BottomPT);  	}  	case TypeOp.Unbox:  		if (!(typei.Type.Style (methEnv) is ValueTypeStyle))  			// Parameter types are not allowed  			throw new InvalidOperationException ("type must be a value type");  		state.PeekBoxedType (0' typei.Type' changed);  		return state.PopPushType (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (typei.Type)' HeapPT);  	case TypeOp.UnboxAny: {  		var s = typei.Type.Style (methEnv);  		if (s is ValueTypeStyle)  			state.PeekBoxedType (0' typei.Type' changed);  		else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))  			throw new InvalidOperationException ("type must be value' reference or parameter type");  		return state.PopPushType (1' typei.Type' BottomPT);  	}  	case TypeOp.Ldtoken:  		return state.PushType (global.RuntimeTypeHandleRef' BottomPT);  	case TypeOp.Ldelem:  		state.PeekIndexType (0);  		state.PeekReadArrayType (1' typei.Type' false);  		return state.PopPushType (2' typei.Type' BottomPT);  	case TypeOp.Stelem:  		state.PeekExpectedType (0' typei.Type' changed);  		state.PeekIndexType (1);  		state.PeekWriteArrayType (2' typei.Type);  		return state.Pop (3);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.LdElemAddr: {  	var ldelemai = (LdElemAddrInstruction)instruction;  	state.PeekIndexType (0);  	// WARNING: May prematurely fail for non-readonly loads  	state.PeekReadArrayType (1' ldelemai.Type' !ldelemai.IsReadonly);  	return state.PopPushType (2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (ldelemai.Type)' HeapPT);  }  case InstructionFlavor.LdInt32:  	return state.PushType (global.Int32Ref' BottomPT);  case InstructionFlavor.LdInt64:  	return state.PushType (global.Int64Ref' BottomPT);  case InstructionFlavor.LdSingle:  	return state.PushType (global.DoubleRef' BottomPT);  case InstructionFlavor.LdDouble:  	return state.PushType (global.DoubleRef' BottomPT);  case InstructionFlavor.LdString:  	return state.PushType (global.StringRef' BottomPT);  case InstructionFlavor.Arith: {  	var arithi = (ArithInstruction)instruction;  	switch (arithi.Op) {  	case ArithOp.Add:  	case ArithOp.Sub:  	case ArithOp.Mul:  	case ArithOp.Div:  	case ArithOp.Rem:  		// NOTE: May capture skolemized types  		arithi.Type = state.Peek2NumberTypes (0' true);  		return state.PopPushType (2' arithi.Type' BottomPT);  	case ArithOp.Neg:  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (0' true);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (1' arithi.Type' BottomPT);  	case ArithOp.BitAnd:  	case ArithOp.BitOr:  	case ArithOp.BitXor:  		// NOTE: May capture skolemized types  		arithi.Type = state.Peek2NumberTypes (0' false);  		return state.PopPushType (2' arithi.Type' BottomPT);  	case ArithOp.BitNot:  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (0' false);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (1' arithi.Type' BottomPT);  	case ArithOp.Shl:  	case ArithOp.Shr:  		state.PeekExpectedType (0' global.Int32Ref' changed);  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (1' false);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (2' arithi.Type' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Conv: {  	var convi = (ConvInstruction)instruction;  	var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned && convi.TargetNumberFlavor == NumberFlavor.Double);  	// NOTE: May capture skolemized types  	convi.SourceType = state.PeekNumberType (0' !mustBeInteger);  	return state.PopPushType (1' TypeRef.NumberFrom (methEnv.Global' convi.TargetNumberFlavor)' BottomPT);  }  case InstructionFlavor.Try: {  	var tryi = (TryInstruction)instruction;  	// Isolation:  	//  - There is no way for the current stack shape to influence or be influenced by  	//    inference of the try' since the current stack shape must be empty.  	//  - There is no way for the try to influence the result stack shape' since it must be  	//    empty.  	//  - However pointers in arguments and locals may propogate into and out of try body  	//    via exceptional transitions. The latter are delt with separately.  	if (state.Depth != 0)  		throw new InvalidOperationException ("stack should be empty");  	var newState = ForwardBlock (new TryBodyInstructionContext (context' index' tryi.Body)' state' changed);  	for (var j = 0; j < tryi.Handlers.Count; j++) {  		var h = tryi.Handlers [j];  		var handlerContext = new TryHandlerInstructionContext (context' index' h.Body' j);  		var initHandlerState = new MachineState (methEnv' method.ValueParameters.Count' method.Locals.Count);  		switch (h.Flavor) {  		case HandlerFlavor.Catch: {  			var catchh = (CatchTryInstructionHandler)h;  			ForwardBlock (handlerContext' initHandlerState.PushType (catchh.Type' BottomPT)' changed);  			break;  		}  		case HandlerFlavor.Filter:  			throw new NotSupportedException ("filter handler blocks");  		case HandlerFlavor.Fault:  		case HandlerFlavor.Finally:  			ForwardBlock (handlerContext' initHandlerState' changed);  			break;  		default:  			throw new ArgumentOutOfRangeException ();  		}  	}  	return newState;  }  case InstructionFlavor.IfThenElsePseudo:  case InstructionFlavor.ShortCircuitingPseudo:  case InstructionFlavor.StructuralSwitchPseudo:  case InstructionFlavor.LoopPseudo:  case InstructionFlavor.WhileDoPseudo:  case InstructionFlavor.DoWhilePseudo:  case InstructionFlavor.LoopControlPseudo:  	throw new InvalidOperationException ("no machine state inference for psuedo-instructions");  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor) {  case InstructionFlavor.Unsupported:  	throw new InvalidOperationException ("unsupported opcode");  case InstructionFlavor.Misc: {  	var misci = (MiscInstruction)instruction;  	switch (misci.Op) {  	case MiscOp.Nop:  	case MiscOp.Break:  		return state;  	case MiscOp.Dup:  		return state.Push (state.Peek (0));  	case MiscOp.Pop:  		return state.Pop (1);  	case MiscOp.Ldnull:  		return state.PushType (global.NullRef' BottomPT);  	case MiscOp.Ckfinite:  		state.PeekExpectedType (0' global.DoubleRef' changed);  		// Assume the instruction can "peek" at top of stack' thus no need for pop/push.  		return state;  	case MiscOp.Throw:  		state.PeekReferenceType (0);  		return state.DiscardStack ();  	case MiscOp.Rethrow:  		return state.DiscardStack ();  	case MiscOp.LdindRef: {  		var elemType = state.PeekPointerToReferenceType (0);  		return state.PopPushType (1' elemType' BottomPT);  	}  	case MiscOp.StindRef: {  		var expElemType = state.PeekPointerToReferenceType (1);  		state.PeekExpectedType (0' expElemType' changed);  		return state.Pop (2);  	}  	case MiscOp.LdelemRef: {  		state.PeekIndexType (0);  		// WARNING: Type may not be final  		var elemType = state.PeekArrayOfReferenceType (1);  		return state.PopPushType (2' elemType' BottomPT);  	}  	case MiscOp.StelemRef:  		state.PeekReferenceType (0);  		state.PeekIndexType (1);  		state.PeekArrayOfReferenceType (2);  		// Since the value type and array element type may be independently generalized'  		// it is pointless to check that the first is assignable to the second.  		// Instead this check is done at runtime.  		return state.Pop (3);  	case MiscOp.Ldlen:  		state.PeekArrayOfAnyType (0);  		return state.PopPushType (1' global.IntNativeRef' BottomPT);  	case MiscOp.Ret: {  		if (state.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return state;  		// empty  	}  	case MiscOp.RetVal: {  		state.PeekExpectedType (0' method.Result.Type' changed);  		var newState = state.Pop (1);  		if (newState.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return newState;  		// empty  	}  	case MiscOp.Endfilter: {  		state.PeekExpectedType (0' global.Int32Ref' changed);  		var newState = state.Pop (1);  		if (newState.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return newState;  		// empty  	}  	case MiscOp.Endfinally: {  		// Control could transfer to an outer finally/fault block' or to the target  		// of a leave instruction. However these transitions are delt with separately.  		return state.DiscardStack ();  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Branch: {  	var bri = (BranchInstruction)instruction;  	switch (bri.Op) {  	case BranchOp.Br:  		UnifyBeforeState (state' bri.Target' changed);  		return state;  	case BranchOp.Brtrue: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.PeekIntegerOrObjectOrPointerType (0' false);  		var newState = state.Pop (1);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Brfalse: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.PeekIntegerOrObjectOrPointerType (0' true);  		var newState = state.Pop (1);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Breq:  	case BranchOp.Brne: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.Peek2ComparableTypes (0' true);  		var newState = state.Pop (2);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Leave: {  		// Control could transfer via finally blocks instead of directly to the leave target.  		// Propogate only that the stack must be empty at target. Remaining machine state  		// is dealt with separately.  		UnifyBeforeState (new MachineState (methEnv' method.ValueParameters.Count' method.Locals.Count)' bri.Target' changed);  		return state.DiscardStack ();  	}  	case BranchOp.BrLt:  	case BranchOp.BrLe:  	case BranchOp.BrGt:  	case BranchOp.BrGe: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.Peek2ComparableTypes (0' false);  		var newState = state.Pop (2);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Switch: {  	var switchi = (SwitchInstruction)instruction;  	state.PeekExpectedType (0' global.Int32Ref' changed);  	var newState = state.Pop (1);  	for (var i = 0; i < switchi.CaseTargets.Count; i++)  		UnifyBeforeState (newState' switchi.CaseTargets [i]' changed);  	return newState;  }  case InstructionFlavor.Compare: {  	var cmpi = (CompareInstruction)instruction;  	// WARNING: Capured type may not be final  	// NOTE: May capture skolemized types  	switch (cmpi.Op) {  	case CompareOp.Ceq:  	case CompareOp.CnePseudo:  		cmpi.Type = state.Peek2ComparableTypes (0' true);  		return state.PopPushType (2' global.Int32Ref' BottomPT);  	case CompareOp.Clt:  	case CompareOp.Cgt:  	case CompareOp.CgePseudo:  	case CompareOp.ClePseudo:  		cmpi.Type = state.Peek2ComparableTypes (0' false);  		return state.PopPushType (2' global.Int32Ref' BottomPT);  	case CompareOp.CtruePseudo:  	case CompareOp.CfalsePseudo:  		cmpi.Type = state.PeekIntegerOrObjectOrPointerType (0' true);  		return state.PopPushType (1' global.Int32Ref' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.ArgLocal: {  	var argi = (ArgLocalInstruction)instruction;  	var type = method.ArgLocalType (argi.ArgLocal' argi.Index);  	switch (argi.Op) {  	case ArgLocalOp.Ld:  		return state.PushType (type' state.ArgLocalPointsTo (argi.ArgLocal' argi.Index));  	case ArgLocalOp.Lda:  		return state.PushType (methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (type)' ArgLocalPT (argi.ArgLocal' argi.Index));  	case ArgLocalOp.St: {  		state.PeekExpectedType (0' type' changed);  		var pointsTo = state.PeekPointsTo (0);  		if (!pointsTo.IsBottom) {  			if (!(type.Style (methEnv) is ManagedPointerTypeStyle))  				throw new InvalidOperationException ("stack indicates pointer' but parameter or local type does not");  			if (pointsTo.PointsOutsideOfHeap)  				throw new InvalidOperationException ("arguments cannot point outside of the heap");  		}  		return state.PopAddArgLocalPointsTo (1' argi.ArgLocal' argi.Index' pointsTo);  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Field: {  	var fieldi = (FieldInstruction)instruction;  	var fieldEnv = fieldi.Field.Enter (methEnv);  	var fieldType = fieldEnv.SubstituteType (fieldEnv.Field.FieldType);  	switch (fieldi.Op) {  	case FieldOp.Ldfld:  		if (fieldi.IsStatic)  			return state.PushType (fieldType' BottomPT);  		else {  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (0' fieldi.Field.DefiningType' true' changed);  			return state.PopPushType (1' fieldType' BottomPT);  		}  	case FieldOp.Ldflda:  		if (fieldi.IsStatic)  			return state.PushType (methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (fieldType)' HeapPT);  		else {  			// Underlying type cannot be a struct' otherwise would have a pointer into  			// the stack  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (0' fieldi.Field.DefiningType' false' changed);  			return state.PopPushType (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (fieldType)' HeapPT);  		}  	case FieldOp.Stfld:  		if (fieldi.IsStatic) {  			state.PeekExpectedType (0' fieldType' changed);  			return state.Pop (1);  		}  		else {  			state.PeekExpectedType (0' fieldType' changed);  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (1' fieldi.Field.DefiningType' false' changed);  			return state.Pop (2);  		}  	case FieldOp.Ldtoken:  		return state.PushType (global.RuntimeFieldHandleRef' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Method: {  	var methi = (MethodInstruction)instruction;  	var sig = (CST.MethodSignature)methi.Method.ExternalSignature;  	switch (methi.Op) {  	case MethodOp.Call: {  		for (var i = sig.Parameters.Count - 1; i >= 1; i--)  			state.PeekExpectedType (sig.Parameters.Count - 1 - i' sig.Parameters [i]' changed);  		if (methi.Constrained != null) {  			if (!methi.IsVirtual || methi.Method.IsStatic)  				throw new InvalidOperationException ("constrained only valid on virtual calls to instance methods");  			var thisType = sig.Parameters [0];  			var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (methi.Constrained);  			var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo (methi.Constrained);  			var cs = methi.Constrained.Style (methEnv);  			if (cs is ValueTypeStyle) {  				if (thisType.Style (methEnv) is ManagedPointerTypeStyle) {  					// We pass the argument pointer as is  					if (!methi.Constrained.IsAssignableTo (methEnv' thisType.Arguments [0]))  						throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  				}  				else {  					// *Case 1* Morally we deref the argument pointer and box the contents'  					// but since no supertype of a value type may mutate the underlying value'  					// we don't need to take a copy of the value when boxing' so in practice  					// this is a no-op  					if (!constrainedBox.IsAssignableTo (methEnv' thisType))  						throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  				}  			}  			else if (cs is ReferenceTypeStyle) {  				// *Case 2* We dereference the pointer and pass the object reference  				if (!methi.Constrained.IsAssignableTo (methEnv' thisType))  					throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  			}  			else if (cs is ParameterTypeStyle) {  				// Since we are calling an instance method' we know the first argument cannot be  				// a "naked" type parameter' but is either a class or an interface.  				// We must decide between cases 1 and 2 above at runtime' but checking as  				// per case 1 is sufficient now.  				// NOTE: As for box/classcast/isinst below' if the parameter is  				// instantiated to a reference type then the type box type is considered  				// equivalent to the underyling reference type.  				if (!constrainedBox.IsAssignableTo (methEnv' thisType))  					throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  			}  			else  				throw new InvalidOperationException ("constrained must be value' reference or parameter type");  			state.PeekExpectedType (sig.Parameters.Count - 1' constrainedPtr' changed);  		}  		else if (sig.Parameters.Count > 0)  			state.PeekExpectedType (sig.Parameters.Count - 1' sig.Parameters [0]' changed);  		if (sig.Result == null)  			return state.Pop (sig.Parameters.Count);  		else  			return state.PopPushType (sig.Parameters.Count' sig.Result' BottomPT);  	}  	case MethodOp.Ldftn: {  		// NOTE: Verified CLR allows only the two "blessed" sequences:  		//   dup; ldvirtftn; newobj <delegate ctor>  		//   ldftn; newobj <delegate ctor>  		// It is thus possible to check the delegate will capture an instance which  		// implements the loaded method. However' we don't check that here.  		if (methi.IsVirtual) {  			if (methi.Method.IsStatic)  				throw new InvalidOperationException ("cannot ldvirtftn of a static method");  			var objectType = default(TypeRef);  			if (sig.Parameters [0].Style (methEnv) is ManagedPointerTypeStyle)  				// Object should be a box  				objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (sig.Parameters [0].Arguments [0]);  			else  				// Object should match parameter  				objectType = sig.Parameters [0];  			state.PeekExpectedType (0' objectType' changed);  			return state.PopPushType (1' sig.WithoutThis ().ToCodePointer (methEnv.Global)' BottomPT);  		}  		else {  			if (methi.Method.IsStatic)  				return state.PushType (sig.ToCodePointer (methEnv.Global)' BottomPT);  			else  				return state.PushType (sig.WithoutThis ().ToCodePointer (methEnv.Global)' BottomPT);  		}  	}  	case MethodOp.Newobj: {  		if (methi.Method.IsStatic || sig.Result != null)  			throw new InvalidOperationException ("not a constructor");  		for (var i = sig.Parameters.Count - 1; i >= 1; i--)  			state.PeekExpectedType (sig.Parameters.Count - 1 - i' sig.Parameters [i]' changed);  		// First argument to constructor is created by runtime. If definining type is  		// a value type' first argument will be a pointer' but result left on stack  		// will be the value itself.  		return state.PopPushType (sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);  	}  	case MethodOp.Ldtoken:  		return state.PushType (global.RuntimeMethodHandleRef' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Type: {  	var typei = (TypeInstruction)instruction;  	switch (typei.Op) {  	case TypeOp.Ldobj:  		state.PeekReadPointerType (0' typei.Type);  		return state.PopPushType (1' typei.Type' BottomPT);  	case TypeOp.Stobj:  		state.PeekExpectedType (0' typei.Type' changed);  		state.PeekWritePointerType (1' typei.Type);  		return state.Pop (2);  	case TypeOp.Cpobj:  		state.PeekReadPointerType (0' typei.Type);  		state.PeekWritePointerType (1' typei.Type);  		return state.Pop (2);  	case TypeOp.Newarr:  		state.PeekIndexType (0);  		return state.PopPushType (1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo (typei.Type)' BottomPT);  	case TypeOp.Initobj:  		state.PeekWritePointerType (0' typei.Type);  		return state.Pop (1);  	case TypeOp.Castclass:  	case TypeOp.Isinst:  	case TypeOp.Box: {  		var resultType = default(TypeRef);  		var s = typei.Type.Style (methEnv);  		if (s is NullableTypeStyle)  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type.Arguments [0]);  		else if (s is ValueTypeStyle)  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type);  		else if (s is ReferenceTypeStyle)  			resultType = typei.Type;  		else if (s is ParameterTypeStyle)  			// NOTE: As for constrained call above' if type parameter is instantitated to  			// a ref type' then this box type is considered equivalent to the  			// underlying reference type.  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type);  		else  			throw new InvalidOperationException ("can only box/cast to reference' value or parameter type");  		if (typei.Op == TypeOp.Box)  			state.PeekExpectedType (0' typei.Type' changed);  		else  			state.PeekReferenceType (0);  		return state.PopPushType (1' resultType' BottomPT);  	}  	case TypeOp.Unbox:  		if (!(typei.Type.Style (methEnv) is ValueTypeStyle))  			// Parameter types are not allowed  			throw new InvalidOperationException ("type must be a value type");  		state.PeekBoxedType (0' typei.Type' changed);  		return state.PopPushType (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (typei.Type)' HeapPT);  	case TypeOp.UnboxAny: {  		var s = typei.Type.Style (methEnv);  		if (s is ValueTypeStyle)  			state.PeekBoxedType (0' typei.Type' changed);  		else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))  			throw new InvalidOperationException ("type must be value' reference or parameter type");  		return state.PopPushType (1' typei.Type' BottomPT);  	}  	case TypeOp.Ldtoken:  		return state.PushType (global.RuntimeTypeHandleRef' BottomPT);  	case TypeOp.Ldelem:  		state.PeekIndexType (0);  		state.PeekReadArrayType (1' typei.Type' false);  		return state.PopPushType (2' typei.Type' BottomPT);  	case TypeOp.Stelem:  		state.PeekExpectedType (0' typei.Type' changed);  		state.PeekIndexType (1);  		state.PeekWriteArrayType (2' typei.Type);  		return state.Pop (3);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.LdElemAddr: {  	var ldelemai = (LdElemAddrInstruction)instruction;  	state.PeekIndexType (0);  	// WARNING: May prematurely fail for non-readonly loads  	state.PeekReadArrayType (1' ldelemai.Type' !ldelemai.IsReadonly);  	return state.PopPushType (2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (ldelemai.Type)' HeapPT);  }  case InstructionFlavor.LdInt32:  	return state.PushType (global.Int32Ref' BottomPT);  case InstructionFlavor.LdInt64:  	return state.PushType (global.Int64Ref' BottomPT);  case InstructionFlavor.LdSingle:  	return state.PushType (global.DoubleRef' BottomPT);  case InstructionFlavor.LdDouble:  	return state.PushType (global.DoubleRef' BottomPT);  case InstructionFlavor.LdString:  	return state.PushType (global.StringRef' BottomPT);  case InstructionFlavor.Arith: {  	var arithi = (ArithInstruction)instruction;  	switch (arithi.Op) {  	case ArithOp.Add:  	case ArithOp.Sub:  	case ArithOp.Mul:  	case ArithOp.Div:  	case ArithOp.Rem:  		// NOTE: May capture skolemized types  		arithi.Type = state.Peek2NumberTypes (0' true);  		return state.PopPushType (2' arithi.Type' BottomPT);  	case ArithOp.Neg:  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (0' true);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (1' arithi.Type' BottomPT);  	case ArithOp.BitAnd:  	case ArithOp.BitOr:  	case ArithOp.BitXor:  		// NOTE: May capture skolemized types  		arithi.Type = state.Peek2NumberTypes (0' false);  		return state.PopPushType (2' arithi.Type' BottomPT);  	case ArithOp.BitNot:  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (0' false);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (1' arithi.Type' BottomPT);  	case ArithOp.Shl:  	case ArithOp.Shr:  		state.PeekExpectedType (0' global.Int32Ref' changed);  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (1' false);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (2' arithi.Type' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Conv: {  	var convi = (ConvInstruction)instruction;  	var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned && convi.TargetNumberFlavor == NumberFlavor.Double);  	// NOTE: May capture skolemized types  	convi.SourceType = state.PeekNumberType (0' !mustBeInteger);  	return state.PopPushType (1' TypeRef.NumberFrom (methEnv.Global' convi.TargetNumberFlavor)' BottomPT);  }  case InstructionFlavor.Try: {  	var tryi = (TryInstruction)instruction;  	// Isolation:  	//  - There is no way for the current stack shape to influence or be influenced by  	//    inference of the try' since the current stack shape must be empty.  	//  - There is no way for the try to influence the result stack shape' since it must be  	//    empty.  	//  - However pointers in arguments and locals may propogate into and out of try body  	//    via exceptional transitions. The latter are delt with separately.  	if (state.Depth != 0)  		throw new InvalidOperationException ("stack should be empty");  	var newState = ForwardBlock (new TryBodyInstructionContext (context' index' tryi.Body)' state' changed);  	for (var j = 0; j < tryi.Handlers.Count; j++) {  		var h = tryi.Handlers [j];  		var handlerContext = new TryHandlerInstructionContext (context' index' h.Body' j);  		var initHandlerState = new MachineState (methEnv' method.ValueParameters.Count' method.Locals.Count);  		switch (h.Flavor) {  		case HandlerFlavor.Catch: {  			var catchh = (CatchTryInstructionHandler)h;  			ForwardBlock (handlerContext' initHandlerState.PushType (catchh.Type' BottomPT)' changed);  			break;  		}  		case HandlerFlavor.Filter:  			throw new NotSupportedException ("filter handler blocks");  		case HandlerFlavor.Fault:  		case HandlerFlavor.Finally:  			ForwardBlock (handlerContext' initHandlerState' changed);  			break;  		default:  			throw new ArgumentOutOfRangeException ();  		}  	}  	return newState;  }  case InstructionFlavor.IfThenElsePseudo:  case InstructionFlavor.ShortCircuitingPseudo:  case InstructionFlavor.StructuralSwitchPseudo:  case InstructionFlavor.LoopPseudo:  case InstructionFlavor.WhileDoPseudo:  case InstructionFlavor.DoWhilePseudo:  case InstructionFlavor.LoopControlPseudo:  	throw new InvalidOperationException ("no machine state inference for psuedo-instructions");  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor) {  case InstructionFlavor.Unsupported:  	throw new InvalidOperationException ("unsupported opcode");  case InstructionFlavor.Misc: {  	var misci = (MiscInstruction)instruction;  	switch (misci.Op) {  	case MiscOp.Nop:  	case MiscOp.Break:  		return state;  	case MiscOp.Dup:  		return state.Push (state.Peek (0));  	case MiscOp.Pop:  		return state.Pop (1);  	case MiscOp.Ldnull:  		return state.PushType (global.NullRef' BottomPT);  	case MiscOp.Ckfinite:  		state.PeekExpectedType (0' global.DoubleRef' changed);  		// Assume the instruction can "peek" at top of stack' thus no need for pop/push.  		return state;  	case MiscOp.Throw:  		state.PeekReferenceType (0);  		return state.DiscardStack ();  	case MiscOp.Rethrow:  		return state.DiscardStack ();  	case MiscOp.LdindRef: {  		var elemType = state.PeekPointerToReferenceType (0);  		return state.PopPushType (1' elemType' BottomPT);  	}  	case MiscOp.StindRef: {  		var expElemType = state.PeekPointerToReferenceType (1);  		state.PeekExpectedType (0' expElemType' changed);  		return state.Pop (2);  	}  	case MiscOp.LdelemRef: {  		state.PeekIndexType (0);  		// WARNING: Type may not be final  		var elemType = state.PeekArrayOfReferenceType (1);  		return state.PopPushType (2' elemType' BottomPT);  	}  	case MiscOp.StelemRef:  		state.PeekReferenceType (0);  		state.PeekIndexType (1);  		state.PeekArrayOfReferenceType (2);  		// Since the value type and array element type may be independently generalized'  		// it is pointless to check that the first is assignable to the second.  		// Instead this check is done at runtime.  		return state.Pop (3);  	case MiscOp.Ldlen:  		state.PeekArrayOfAnyType (0);  		return state.PopPushType (1' global.IntNativeRef' BottomPT);  	case MiscOp.Ret: {  		if (state.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return state;  		// empty  	}  	case MiscOp.RetVal: {  		state.PeekExpectedType (0' method.Result.Type' changed);  		var newState = state.Pop (1);  		if (newState.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return newState;  		// empty  	}  	case MiscOp.Endfilter: {  		state.PeekExpectedType (0' global.Int32Ref' changed);  		var newState = state.Pop (1);  		if (newState.Depth != 0)  			throw new InvalidOperationException ("stack should be empty");  		return newState;  		// empty  	}  	case MiscOp.Endfinally: {  		// Control could transfer to an outer finally/fault block' or to the target  		// of a leave instruction. However these transitions are delt with separately.  		return state.DiscardStack ();  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Branch: {  	var bri = (BranchInstruction)instruction;  	switch (bri.Op) {  	case BranchOp.Br:  		UnifyBeforeState (state' bri.Target' changed);  		return state;  	case BranchOp.Brtrue: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.PeekIntegerOrObjectOrPointerType (0' false);  		var newState = state.Pop (1);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Brfalse: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.PeekIntegerOrObjectOrPointerType (0' true);  		var newState = state.Pop (1);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Breq:  	case BranchOp.Brne: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.Peek2ComparableTypes (0' true);  		var newState = state.Pop (2);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	case BranchOp.Leave: {  		// Control could transfer via finally blocks instead of directly to the leave target.  		// Propogate only that the stack must be empty at target. Remaining machine state  		// is dealt with separately.  		UnifyBeforeState (new MachineState (methEnv' method.ValueParameters.Count' method.Locals.Count)' bri.Target' changed);  		return state.DiscardStack ();  	}  	case BranchOp.BrLt:  	case BranchOp.BrLe:  	case BranchOp.BrGt:  	case BranchOp.BrGe: {  		// WARNING: Type may not be final  		// NOTE: May capture skolemized types  		bri.Type = state.Peek2ComparableTypes (0' false);  		var newState = state.Pop (2);  		UnifyBeforeState (newState' bri.Target' changed);  		return newState;  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Switch: {  	var switchi = (SwitchInstruction)instruction;  	state.PeekExpectedType (0' global.Int32Ref' changed);  	var newState = state.Pop (1);  	for (var i = 0; i < switchi.CaseTargets.Count; i++)  		UnifyBeforeState (newState' switchi.CaseTargets [i]' changed);  	return newState;  }  case InstructionFlavor.Compare: {  	var cmpi = (CompareInstruction)instruction;  	// WARNING: Capured type may not be final  	// NOTE: May capture skolemized types  	switch (cmpi.Op) {  	case CompareOp.Ceq:  	case CompareOp.CnePseudo:  		cmpi.Type = state.Peek2ComparableTypes (0' true);  		return state.PopPushType (2' global.Int32Ref' BottomPT);  	case CompareOp.Clt:  	case CompareOp.Cgt:  	case CompareOp.CgePseudo:  	case CompareOp.ClePseudo:  		cmpi.Type = state.Peek2ComparableTypes (0' false);  		return state.PopPushType (2' global.Int32Ref' BottomPT);  	case CompareOp.CtruePseudo:  	case CompareOp.CfalsePseudo:  		cmpi.Type = state.PeekIntegerOrObjectOrPointerType (0' true);  		return state.PopPushType (1' global.Int32Ref' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.ArgLocal: {  	var argi = (ArgLocalInstruction)instruction;  	var type = method.ArgLocalType (argi.ArgLocal' argi.Index);  	switch (argi.Op) {  	case ArgLocalOp.Ld:  		return state.PushType (type' state.ArgLocalPointsTo (argi.ArgLocal' argi.Index));  	case ArgLocalOp.Lda:  		return state.PushType (methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (type)' ArgLocalPT (argi.ArgLocal' argi.Index));  	case ArgLocalOp.St: {  		state.PeekExpectedType (0' type' changed);  		var pointsTo = state.PeekPointsTo (0);  		if (!pointsTo.IsBottom) {  			if (!(type.Style (methEnv) is ManagedPointerTypeStyle))  				throw new InvalidOperationException ("stack indicates pointer' but parameter or local type does not");  			if (pointsTo.PointsOutsideOfHeap)  				throw new InvalidOperationException ("arguments cannot point outside of the heap");  		}  		return state.PopAddArgLocalPointsTo (1' argi.ArgLocal' argi.Index' pointsTo);  	}  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Field: {  	var fieldi = (FieldInstruction)instruction;  	var fieldEnv = fieldi.Field.Enter (methEnv);  	var fieldType = fieldEnv.SubstituteType (fieldEnv.Field.FieldType);  	switch (fieldi.Op) {  	case FieldOp.Ldfld:  		if (fieldi.IsStatic)  			return state.PushType (fieldType' BottomPT);  		else {  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (0' fieldi.Field.DefiningType' true' changed);  			return state.PopPushType (1' fieldType' BottomPT);  		}  	case FieldOp.Ldflda:  		if (fieldi.IsStatic)  			return state.PushType (methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (fieldType)' HeapPT);  		else {  			// Underlying type cannot be a struct' otherwise would have a pointer into  			// the stack  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (0' fieldi.Field.DefiningType' false' changed);  			return state.PopPushType (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (fieldType)' HeapPT);  		}  	case FieldOp.Stfld:  		if (fieldi.IsStatic) {  			state.PeekExpectedType (0' fieldType' changed);  			return state.Pop (1);  		}  		else {  			state.PeekExpectedType (0' fieldType' changed);  			fieldi.IsViaPointer = state.PeekDereferencableExpectedType (1' fieldi.Field.DefiningType' false' changed);  			return state.Pop (2);  		}  	case FieldOp.Ldtoken:  		return state.PushType (global.RuntimeFieldHandleRef' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Method: {  	var methi = (MethodInstruction)instruction;  	var sig = (CST.MethodSignature)methi.Method.ExternalSignature;  	switch (methi.Op) {  	case MethodOp.Call: {  		for (var i = sig.Parameters.Count - 1; i >= 1; i--)  			state.PeekExpectedType (sig.Parameters.Count - 1 - i' sig.Parameters [i]' changed);  		if (methi.Constrained != null) {  			if (!methi.IsVirtual || methi.Method.IsStatic)  				throw new InvalidOperationException ("constrained only valid on virtual calls to instance methods");  			var thisType = sig.Parameters [0];  			var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (methi.Constrained);  			var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo (methi.Constrained);  			var cs = methi.Constrained.Style (methEnv);  			if (cs is ValueTypeStyle) {  				if (thisType.Style (methEnv) is ManagedPointerTypeStyle) {  					// We pass the argument pointer as is  					if (!methi.Constrained.IsAssignableTo (methEnv' thisType.Arguments [0]))  						throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  				}  				else {  					// *Case 1* Morally we deref the argument pointer and box the contents'  					// but since no supertype of a value type may mutate the underlying value'  					// we don't need to take a copy of the value when boxing' so in practice  					// this is a no-op  					if (!constrainedBox.IsAssignableTo (methEnv' thisType))  						throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  				}  			}  			else if (cs is ReferenceTypeStyle) {  				// *Case 2* We dereference the pointer and pass the object reference  				if (!methi.Constrained.IsAssignableTo (methEnv' thisType))  					throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  			}  			else if (cs is ParameterTypeStyle) {  				// Since we are calling an instance method' we know the first argument cannot be  				// a "naked" type parameter' but is either a class or an interface.  				// We must decide between cases 1 and 2 above at runtime' but checking as  				// per case 1 is sufficient now.  				// NOTE: As for box/classcast/isinst below' if the parameter is  				// instantiated to a reference type then the type box type is considered  				// equivalent to the underyling reference type.  				if (!constrainedBox.IsAssignableTo (methEnv' thisType))  					throw new InvalidOperationException ("constrained type is not assignable to method's first argument type");  			}  			else  				throw new InvalidOperationException ("constrained must be value' reference or parameter type");  			state.PeekExpectedType (sig.Parameters.Count - 1' constrainedPtr' changed);  		}  		else if (sig.Parameters.Count > 0)  			state.PeekExpectedType (sig.Parameters.Count - 1' sig.Parameters [0]' changed);  		if (sig.Result == null)  			return state.Pop (sig.Parameters.Count);  		else  			return state.PopPushType (sig.Parameters.Count' sig.Result' BottomPT);  	}  	case MethodOp.Ldftn: {  		// NOTE: Verified CLR allows only the two "blessed" sequences:  		//   dup; ldvirtftn; newobj <delegate ctor>  		//   ldftn; newobj <delegate ctor>  		// It is thus possible to check the delegate will capture an instance which  		// implements the loaded method. However' we don't check that here.  		if (methi.IsVirtual) {  			if (methi.Method.IsStatic)  				throw new InvalidOperationException ("cannot ldvirtftn of a static method");  			var objectType = default(TypeRef);  			if (sig.Parameters [0].Style (methEnv) is ManagedPointerTypeStyle)  				// Object should be a box  				objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (sig.Parameters [0].Arguments [0]);  			else  				// Object should match parameter  				objectType = sig.Parameters [0];  			state.PeekExpectedType (0' objectType' changed);  			return state.PopPushType (1' sig.WithoutThis ().ToCodePointer (methEnv.Global)' BottomPT);  		}  		else {  			if (methi.Method.IsStatic)  				return state.PushType (sig.ToCodePointer (methEnv.Global)' BottomPT);  			else  				return state.PushType (sig.WithoutThis ().ToCodePointer (methEnv.Global)' BottomPT);  		}  	}  	case MethodOp.Newobj: {  		if (methi.Method.IsStatic || sig.Result != null)  			throw new InvalidOperationException ("not a constructor");  		for (var i = sig.Parameters.Count - 1; i >= 1; i--)  			state.PeekExpectedType (sig.Parameters.Count - 1 - i' sig.Parameters [i]' changed);  		// First argument to constructor is created by runtime. If definining type is  		// a value type' first argument will be a pointer' but result left on stack  		// will be the value itself.  		return state.PopPushType (sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);  	}  	case MethodOp.Ldtoken:  		return state.PushType (global.RuntimeMethodHandleRef' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Type: {  	var typei = (TypeInstruction)instruction;  	switch (typei.Op) {  	case TypeOp.Ldobj:  		state.PeekReadPointerType (0' typei.Type);  		return state.PopPushType (1' typei.Type' BottomPT);  	case TypeOp.Stobj:  		state.PeekExpectedType (0' typei.Type' changed);  		state.PeekWritePointerType (1' typei.Type);  		return state.Pop (2);  	case TypeOp.Cpobj:  		state.PeekReadPointerType (0' typei.Type);  		state.PeekWritePointerType (1' typei.Type);  		return state.Pop (2);  	case TypeOp.Newarr:  		state.PeekIndexType (0);  		return state.PopPushType (1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo (typei.Type)' BottomPT);  	case TypeOp.Initobj:  		state.PeekWritePointerType (0' typei.Type);  		return state.Pop (1);  	case TypeOp.Castclass:  	case TypeOp.Isinst:  	case TypeOp.Box: {  		var resultType = default(TypeRef);  		var s = typei.Type.Style (methEnv);  		if (s is NullableTypeStyle)  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type.Arguments [0]);  		else if (s is ValueTypeStyle)  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type);  		else if (s is ReferenceTypeStyle)  			resultType = typei.Type;  		else if (s is ParameterTypeStyle)  			// NOTE: As for constrained call above' if type parameter is instantitated to  			// a ref type' then this box type is considered equivalent to the  			// underlying reference type.  			resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type);  		else  			throw new InvalidOperationException ("can only box/cast to reference' value or parameter type");  		if (typei.Op == TypeOp.Box)  			state.PeekExpectedType (0' typei.Type' changed);  		else  			state.PeekReferenceType (0);  		return state.PopPushType (1' resultType' BottomPT);  	}  	case TypeOp.Unbox:  		if (!(typei.Type.Style (methEnv) is ValueTypeStyle))  			// Parameter types are not allowed  			throw new InvalidOperationException ("type must be a value type");  		state.PeekBoxedType (0' typei.Type' changed);  		return state.PopPushType (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (typei.Type)' HeapPT);  	case TypeOp.UnboxAny: {  		var s = typei.Type.Style (methEnv);  		if (s is ValueTypeStyle)  			state.PeekBoxedType (0' typei.Type' changed);  		else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))  			throw new InvalidOperationException ("type must be value' reference or parameter type");  		return state.PopPushType (1' typei.Type' BottomPT);  	}  	case TypeOp.Ldtoken:  		return state.PushType (global.RuntimeTypeHandleRef' BottomPT);  	case TypeOp.Ldelem:  		state.PeekIndexType (0);  		state.PeekReadArrayType (1' typei.Type' false);  		return state.PopPushType (2' typei.Type' BottomPT);  	case TypeOp.Stelem:  		state.PeekExpectedType (0' typei.Type' changed);  		state.PeekIndexType (1);  		state.PeekWriteArrayType (2' typei.Type);  		return state.Pop (3);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.LdElemAddr: {  	var ldelemai = (LdElemAddrInstruction)instruction;  	state.PeekIndexType (0);  	// WARNING: May prematurely fail for non-readonly loads  	state.PeekReadArrayType (1' ldelemai.Type' !ldelemai.IsReadonly);  	return state.PopPushType (2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (ldelemai.Type)' HeapPT);  }  case InstructionFlavor.LdInt32:  	return state.PushType (global.Int32Ref' BottomPT);  case InstructionFlavor.LdInt64:  	return state.PushType (global.Int64Ref' BottomPT);  case InstructionFlavor.LdSingle:  	return state.PushType (global.DoubleRef' BottomPT);  case InstructionFlavor.LdDouble:  	return state.PushType (global.DoubleRef' BottomPT);  case InstructionFlavor.LdString:  	return state.PushType (global.StringRef' BottomPT);  case InstructionFlavor.Arith: {  	var arithi = (ArithInstruction)instruction;  	switch (arithi.Op) {  	case ArithOp.Add:  	case ArithOp.Sub:  	case ArithOp.Mul:  	case ArithOp.Div:  	case ArithOp.Rem:  		// NOTE: May capture skolemized types  		arithi.Type = state.Peek2NumberTypes (0' true);  		return state.PopPushType (2' arithi.Type' BottomPT);  	case ArithOp.Neg:  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (0' true);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (1' arithi.Type' BottomPT);  	case ArithOp.BitAnd:  	case ArithOp.BitOr:  	case ArithOp.BitXor:  		// NOTE: May capture skolemized types  		arithi.Type = state.Peek2NumberTypes (0' false);  		return state.PopPushType (2' arithi.Type' BottomPT);  	case ArithOp.BitNot:  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (0' false);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (1' arithi.Type' BottomPT);  	case ArithOp.Shl:  	case ArithOp.Shr:  		state.PeekExpectedType (0' global.Int32Ref' changed);  		// NOTE: May capture skolemized types  		arithi.Type = state.PeekNumberType (1' false);  		// Changing underlying value' so pop/push explicitly  		return state.PopPushType (2' arithi.Type' BottomPT);  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Conv: {  	var convi = (ConvInstruction)instruction;  	var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned && convi.TargetNumberFlavor == NumberFlavor.Double);  	// NOTE: May capture skolemized types  	convi.SourceType = state.PeekNumberType (0' !mustBeInteger);  	return state.PopPushType (1' TypeRef.NumberFrom (methEnv.Global' convi.TargetNumberFlavor)' BottomPT);  }  case InstructionFlavor.Try: {  	var tryi = (TryInstruction)instruction;  	// Isolation:  	//  - There is no way for the current stack shape to influence or be influenced by  	//    inference of the try' since the current stack shape must be empty.  	//  - There is no way for the try to influence the result stack shape' since it must be  	//    empty.  	//  - However pointers in arguments and locals may propogate into and out of try body  	//    via exceptional transitions. The latter are delt with separately.  	if (state.Depth != 0)  		throw new InvalidOperationException ("stack should be empty");  	var newState = ForwardBlock (new TryBodyInstructionContext (context' index' tryi.Body)' state' changed);  	for (var j = 0; j < tryi.Handlers.Count; j++) {  		var h = tryi.Handlers [j];  		var handlerContext = new TryHandlerInstructionContext (context' index' h.Body' j);  		var initHandlerState = new MachineState (methEnv' method.ValueParameters.Count' method.Locals.Count);  		switch (h.Flavor) {  		case HandlerFlavor.Catch: {  			var catchh = (CatchTryInstructionHandler)h;  			ForwardBlock (handlerContext' initHandlerState.PushType (catchh.Type' BottomPT)' changed);  			break;  		}  		case HandlerFlavor.Filter:  			throw new NotSupportedException ("filter handler blocks");  		case HandlerFlavor.Fault:  		case HandlerFlavor.Finally:  			ForwardBlock (handlerContext' initHandlerState' changed);  			break;  		default:  			throw new ArgumentOutOfRangeException ();  		}  	}  	return newState;  }  case InstructionFlavor.IfThenElsePseudo:  case InstructionFlavor.ShortCircuitingPseudo:  case InstructionFlavor.StructuralSwitchPseudo:  case InstructionFlavor.LoopPseudo:  case InstructionFlavor.WhileDoPseudo:  case InstructionFlavor.DoWhilePseudo:  case InstructionFlavor.LoopControlPseudo:  	throw new InvalidOperationException ("no machine state inference for psuedo-instructions");  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (misci.Op) {  case MiscOp.Nop:  case MiscOp.Break:  	return state;  case MiscOp.Dup:  	return state.Push (state.Peek (0));  case MiscOp.Pop:  	return state.Pop (1);  case MiscOp.Ldnull:  	return state.PushType (global.NullRef' BottomPT);  case MiscOp.Ckfinite:  	state.PeekExpectedType (0' global.DoubleRef' changed);  	// Assume the instruction can "peek" at top of stack' thus no need for pop/push.  	return state;  case MiscOp.Throw:  	state.PeekReferenceType (0);  	return state.DiscardStack ();  case MiscOp.Rethrow:  	return state.DiscardStack ();  case MiscOp.LdindRef: {  	var elemType = state.PeekPointerToReferenceType (0);  	return state.PopPushType (1' elemType' BottomPT);  }  case MiscOp.StindRef: {  	var expElemType = state.PeekPointerToReferenceType (1);  	state.PeekExpectedType (0' expElemType' changed);  	return state.Pop (2);  }  case MiscOp.LdelemRef: {  	state.PeekIndexType (0);  	// WARNING: Type may not be final  	var elemType = state.PeekArrayOfReferenceType (1);  	return state.PopPushType (2' elemType' BottomPT);  }  case MiscOp.StelemRef:  	state.PeekReferenceType (0);  	state.PeekIndexType (1);  	state.PeekArrayOfReferenceType (2);  	// Since the value type and array element type may be independently generalized'  	// it is pointless to check that the first is assignable to the second.  	// Instead this check is done at runtime.  	return state.Pop (3);  case MiscOp.Ldlen:  	state.PeekArrayOfAnyType (0);  	return state.PopPushType (1' global.IntNativeRef' BottomPT);  case MiscOp.Ret: {  	if (state.Depth != 0)  		throw new InvalidOperationException ("stack should be empty");  	return state;  	// empty  }  case MiscOp.RetVal: {  	state.PeekExpectedType (0' method.Result.Type' changed);  	var newState = state.Pop (1);  	if (newState.Depth != 0)  		throw new InvalidOperationException ("stack should be empty");  	return newState;  	// empty  }  case MiscOp.Endfilter: {  	state.PeekExpectedType (0' global.Int32Ref' changed);  	var newState = state.Pop (1);  	if (newState.Depth != 0)  		throw new InvalidOperationException ("stack should be empty");  	return newState;  	// empty  }  case MiscOp.Endfinally: {  	// Control could transfer to an outer finally/fault block' or to the target  	// of a leave instruction. However these transitions are delt with separately.  	return state.DiscardStack ();  }  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (misci.Op) {  case MiscOp.Nop:  case MiscOp.Break:  	return state;  case MiscOp.Dup:  	return state.Push (state.Peek (0));  case MiscOp.Pop:  	return state.Pop (1);  case MiscOp.Ldnull:  	return state.PushType (global.NullRef' BottomPT);  case MiscOp.Ckfinite:  	state.PeekExpectedType (0' global.DoubleRef' changed);  	// Assume the instruction can "peek" at top of stack' thus no need for pop/push.  	return state;  case MiscOp.Throw:  	state.PeekReferenceType (0);  	return state.DiscardStack ();  case MiscOp.Rethrow:  	return state.DiscardStack ();  case MiscOp.LdindRef: {  	var elemType = state.PeekPointerToReferenceType (0);  	return state.PopPushType (1' elemType' BottomPT);  }  case MiscOp.StindRef: {  	var expElemType = state.PeekPointerToReferenceType (1);  	state.PeekExpectedType (0' expElemType' changed);  	return state.Pop (2);  }  case MiscOp.LdelemRef: {  	state.PeekIndexType (0);  	// WARNING: Type may not be final  	var elemType = state.PeekArrayOfReferenceType (1);  	return state.PopPushType (2' elemType' BottomPT);  }  case MiscOp.StelemRef:  	state.PeekReferenceType (0);  	state.PeekIndexType (1);  	state.PeekArrayOfReferenceType (2);  	// Since the value type and array element type may be independently generalized'  	// it is pointless to check that the first is assignable to the second.  	// Instead this check is done at runtime.  	return state.Pop (3);  case MiscOp.Ldlen:  	state.PeekArrayOfAnyType (0);  	return state.PopPushType (1' global.IntNativeRef' BottomPT);  case MiscOp.Ret: {  	if (state.Depth != 0)  		throw new InvalidOperationException ("stack should be empty");  	return state;  	// empty  }  case MiscOp.RetVal: {  	state.PeekExpectedType (0' method.Result.Type' changed);  	var newState = state.Pop (1);  	if (newState.Depth != 0)  		throw new InvalidOperationException ("stack should be empty");  	return newState;  	// empty  }  case MiscOp.Endfilter: {  	state.PeekExpectedType (0' global.Int32Ref' changed);  	var newState = state.Pop (1);  	if (newState.Depth != 0)  		throw new InvalidOperationException ("stack should be empty");  	return newState;  	// empty  }  case MiscOp.Endfinally: {  	// Control could transfer to an outer finally/fault block' or to the target  	// of a leave instruction. However these transitions are delt with separately.  	return state.DiscardStack ();  }  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (misci.Op) {  case MiscOp.Nop:  case MiscOp.Break:  	return state;  case MiscOp.Dup:  	return state.Push (state.Peek (0));  case MiscOp.Pop:  	return state.Pop (1);  case MiscOp.Ldnull:  	return state.PushType (global.NullRef' BottomPT);  case MiscOp.Ckfinite:  	state.PeekExpectedType (0' global.DoubleRef' changed);  	// Assume the instruction can "peek" at top of stack' thus no need for pop/push.  	return state;  case MiscOp.Throw:  	state.PeekReferenceType (0);  	return state.DiscardStack ();  case MiscOp.Rethrow:  	return state.DiscardStack ();  case MiscOp.LdindRef: {  	var elemType = state.PeekPointerToReferenceType (0);  	return state.PopPushType (1' elemType' BottomPT);  }  case MiscOp.StindRef: {  	var expElemType = state.PeekPointerToReferenceType (1);  	state.PeekExpectedType (0' expElemType' changed);  	return state.Pop (2);  }  case MiscOp.LdelemRef: {  	state.PeekIndexType (0);  	// WARNING: Type may not be final  	var elemType = state.PeekArrayOfReferenceType (1);  	return state.PopPushType (2' elemType' BottomPT);  }  case MiscOp.StelemRef:  	state.PeekReferenceType (0);  	state.PeekIndexType (1);  	state.PeekArrayOfReferenceType (2);  	// Since the value type and array element type may be independently generalized'  	// it is pointless to check that the first is assignable to the second.  	// Instead this check is done at runtime.  	return state.Pop (3);  case MiscOp.Ldlen:  	state.PeekArrayOfAnyType (0);  	return state.PopPushType (1' global.IntNativeRef' BottomPT);  case MiscOp.Ret: {  	if (state.Depth != 0)  		throw new InvalidOperationException ("stack should be empty");  	return state;  	// empty  }  case MiscOp.RetVal: {  	state.PeekExpectedType (0' method.Result.Type' changed);  	var newState = state.Pop (1);  	if (newState.Depth != 0)  		throw new InvalidOperationException ("stack should be empty");  	return newState;  	// empty  }  case MiscOp.Endfilter: {  	state.PeekExpectedType (0' global.Int32Ref' changed);  	var newState = state.Pop (1);  	if (newState.Depth != 0)  		throw new InvalidOperationException ("stack should be empty");  	return newState;  	// empty  }  case MiscOp.Endfinally: {  	// Control could transfer to an outer finally/fault block' or to the target  	// of a leave instruction. However these transitions are delt with separately.  	return state.DiscardStack ();  }  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (misci.Op) {  case MiscOp.Nop:  case MiscOp.Break:  	return state;  case MiscOp.Dup:  	return state.Push (state.Peek (0));  case MiscOp.Pop:  	return state.Pop (1);  case MiscOp.Ldnull:  	return state.PushType (global.NullRef' BottomPT);  case MiscOp.Ckfinite:  	state.PeekExpectedType (0' global.DoubleRef' changed);  	// Assume the instruction can "peek" at top of stack' thus no need for pop/push.  	return state;  case MiscOp.Throw:  	state.PeekReferenceType (0);  	return state.DiscardStack ();  case MiscOp.Rethrow:  	return state.DiscardStack ();  case MiscOp.LdindRef: {  	var elemType = state.PeekPointerToReferenceType (0);  	return state.PopPushType (1' elemType' BottomPT);  }  case MiscOp.StindRef: {  	var expElemType = state.PeekPointerToReferenceType (1);  	state.PeekExpectedType (0' expElemType' changed);  	return state.Pop (2);  }  case MiscOp.LdelemRef: {  	state.PeekIndexType (0);  	// WARNING: Type may not be final  	var elemType = state.PeekArrayOfReferenceType (1);  	return state.PopPushType (2' elemType' BottomPT);  }  case MiscOp.StelemRef:  	state.PeekReferenceType (0);  	state.PeekIndexType (1);  	state.PeekArrayOfReferenceType (2);  	// Since the value type and array element type may be independently generalized'  	// it is pointless to check that the first is assignable to the second.  	// Instead this check is done at runtime.  	return state.Pop (3);  case MiscOp.Ldlen:  	state.PeekArrayOfAnyType (0);  	return state.PopPushType (1' global.IntNativeRef' BottomPT);  case MiscOp.Ret: {  	if (state.Depth != 0)  		throw new InvalidOperationException ("stack should be empty");  	return state;  	// empty  }  case MiscOp.RetVal: {  	state.PeekExpectedType (0' method.Result.Type' changed);  	var newState = state.Pop (1);  	if (newState.Depth != 0)  		throw new InvalidOperationException ("stack should be empty");  	return newState;  	// empty  }  case MiscOp.Endfilter: {  	state.PeekExpectedType (0' global.Int32Ref' changed);  	var newState = state.Pop (1);  	if (newState.Depth != 0)  		throw new InvalidOperationException ("stack should be empty");  	return newState;  	// empty  }  case MiscOp.Endfinally: {  	// Control could transfer to an outer finally/fault block' or to the target  	// of a leave instruction. However these transitions are delt with separately.  	return state.DiscardStack ();  }  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: return state.Pop (2);  
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: return state.PopPushType (2' elemType' BottomPT);  
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: state.PeekArrayOfReferenceType (2);  
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: return state.Pop (3);  
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (bri.Op) {  case BranchOp.Br:  	UnifyBeforeState (state' bri.Target' changed);  	return state;  case BranchOp.Brtrue: {  	// WARNING: Type may not be final  	// NOTE: May capture skolemized types  	bri.Type = state.PeekIntegerOrObjectOrPointerType (0' false);  	var newState = state.Pop (1);  	UnifyBeforeState (newState' bri.Target' changed);  	return newState;  }  case BranchOp.Brfalse: {  	// WARNING: Type may not be final  	// NOTE: May capture skolemized types  	bri.Type = state.PeekIntegerOrObjectOrPointerType (0' true);  	var newState = state.Pop (1);  	UnifyBeforeState (newState' bri.Target' changed);  	return newState;  }  case BranchOp.Breq:  case BranchOp.Brne: {  	// WARNING: Type may not be final  	// NOTE: May capture skolemized types  	bri.Type = state.Peek2ComparableTypes (0' true);  	var newState = state.Pop (2);  	UnifyBeforeState (newState' bri.Target' changed);  	return newState;  }  case BranchOp.Leave: {  	// Control could transfer via finally blocks instead of directly to the leave target.  	// Propogate only that the stack must be empty at target. Remaining machine state  	// is dealt with separately.  	UnifyBeforeState (new MachineState (methEnv' method.ValueParameters.Count' method.Locals.Count)' bri.Target' changed);  	return state.DiscardStack ();  }  case BranchOp.BrLt:  case BranchOp.BrLe:  case BranchOp.BrGt:  case BranchOp.BrGe: {  	// WARNING: Type may not be final  	// NOTE: May capture skolemized types  	bri.Type = state.Peek2ComparableTypes (0' false);  	var newState = state.Pop (2);  	UnifyBeforeState (newState' bri.Target' changed);  	return newState;  }  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (bri.Op) {  case BranchOp.Br:  	UnifyBeforeState (state' bri.Target' changed);  	return state;  case BranchOp.Brtrue: {  	// WARNING: Type may not be final  	// NOTE: May capture skolemized types  	bri.Type = state.PeekIntegerOrObjectOrPointerType (0' false);  	var newState = state.Pop (1);  	UnifyBeforeState (newState' bri.Target' changed);  	return newState;  }  case BranchOp.Brfalse: {  	// WARNING: Type may not be final  	// NOTE: May capture skolemized types  	bri.Type = state.PeekIntegerOrObjectOrPointerType (0' true);  	var newState = state.Pop (1);  	UnifyBeforeState (newState' bri.Target' changed);  	return newState;  }  case BranchOp.Breq:  case BranchOp.Brne: {  	// WARNING: Type may not be final  	// NOTE: May capture skolemized types  	bri.Type = state.Peek2ComparableTypes (0' true);  	var newState = state.Pop (2);  	UnifyBeforeState (newState' bri.Target' changed);  	return newState;  }  case BranchOp.Leave: {  	// Control could transfer via finally blocks instead of directly to the leave target.  	// Propogate only that the stack must be empty at target. Remaining machine state  	// is dealt with separately.  	UnifyBeforeState (new MachineState (methEnv' method.ValueParameters.Count' method.Locals.Count)' bri.Target' changed);  	return state.DiscardStack ();  }  case BranchOp.BrLt:  case BranchOp.BrLe:  case BranchOp.BrGt:  case BranchOp.BrGe: {  	// WARNING: Type may not be final  	// NOTE: May capture skolemized types  	bri.Type = state.Peek2ComparableTypes (0' false);  	var newState = state.Pop (2);  	UnifyBeforeState (newState' bri.Target' changed);  	return newState;  }  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (cmpi.Op) {  case CompareOp.Ceq:  case CompareOp.CnePseudo:  	cmpi.Type = state.Peek2ComparableTypes (0' true);  	return state.PopPushType (2' global.Int32Ref' BottomPT);  case CompareOp.Clt:  case CompareOp.Cgt:  case CompareOp.CgePseudo:  case CompareOp.ClePseudo:  	cmpi.Type = state.Peek2ComparableTypes (0' false);  	return state.PopPushType (2' global.Int32Ref' BottomPT);  case CompareOp.CtruePseudo:  case CompareOp.CfalsePseudo:  	cmpi.Type = state.PeekIntegerOrObjectOrPointerType (0' true);  	return state.PopPushType (1' global.Int32Ref' BottomPT);  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (cmpi.Op) {  case CompareOp.Ceq:  case CompareOp.CnePseudo:  	cmpi.Type = state.Peek2ComparableTypes (0' true);  	return state.PopPushType (2' global.Int32Ref' BottomPT);  case CompareOp.Clt:  case CompareOp.Cgt:  case CompareOp.CgePseudo:  case CompareOp.ClePseudo:  	cmpi.Type = state.Peek2ComparableTypes (0' false);  	return state.PopPushType (2' global.Int32Ref' BottomPT);  case CompareOp.CtruePseudo:  case CompareOp.CfalsePseudo:  	cmpi.Type = state.PeekIntegerOrObjectOrPointerType (0' true);  	return state.PopPushType (1' global.Int32Ref' BottomPT);  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: return state.PopPushType (2' global.Int32Ref' BottomPT);  
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: return state.PopPushType (2' global.Int32Ref' BottomPT);  
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (fieldi.Op) {  case FieldOp.Ldfld:  	if (fieldi.IsStatic)  		return state.PushType (fieldType' BottomPT);  	else {  		fieldi.IsViaPointer = state.PeekDereferencableExpectedType (0' fieldi.Field.DefiningType' true' changed);  		return state.PopPushType (1' fieldType' BottomPT);  	}  case FieldOp.Ldflda:  	if (fieldi.IsStatic)  		return state.PushType (methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (fieldType)' HeapPT);  	else {  		// Underlying type cannot be a struct' otherwise would have a pointer into  		// the stack  		fieldi.IsViaPointer = state.PeekDereferencableExpectedType (0' fieldi.Field.DefiningType' false' changed);  		return state.PopPushType (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (fieldType)' HeapPT);  	}  case FieldOp.Stfld:  	if (fieldi.IsStatic) {  		state.PeekExpectedType (0' fieldType' changed);  		return state.Pop (1);  	}  	else {  		state.PeekExpectedType (0' fieldType' changed);  		fieldi.IsViaPointer = state.PeekDereferencableExpectedType (1' fieldi.Field.DefiningType' false' changed);  		return state.Pop (2);  	}  case FieldOp.Ldtoken:  	return state.PushType (global.RuntimeFieldHandleRef' BottomPT);  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: if (fieldi.IsStatic) {  	state.PeekExpectedType (0' fieldType' changed);  	return state.Pop (1);  }  else {  	state.PeekExpectedType (0' fieldType' changed);  	fieldi.IsViaPointer = state.PeekDereferencableExpectedType (1' fieldi.Field.DefiningType' false' changed);  	return state.Pop (2);  }  
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: return state.Pop (2);  
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (typei.Op) {  case TypeOp.Ldobj:  	state.PeekReadPointerType (0' typei.Type);  	return state.PopPushType (1' typei.Type' BottomPT);  case TypeOp.Stobj:  	state.PeekExpectedType (0' typei.Type' changed);  	state.PeekWritePointerType (1' typei.Type);  	return state.Pop (2);  case TypeOp.Cpobj:  	state.PeekReadPointerType (0' typei.Type);  	state.PeekWritePointerType (1' typei.Type);  	return state.Pop (2);  case TypeOp.Newarr:  	state.PeekIndexType (0);  	return state.PopPushType (1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo (typei.Type)' BottomPT);  case TypeOp.Initobj:  	state.PeekWritePointerType (0' typei.Type);  	return state.Pop (1);  case TypeOp.Castclass:  case TypeOp.Isinst:  case TypeOp.Box: {  	var resultType = default(TypeRef);  	var s = typei.Type.Style (methEnv);  	if (s is NullableTypeStyle)  		resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type.Arguments [0]);  	else if (s is ValueTypeStyle)  		resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type);  	else if (s is ReferenceTypeStyle)  		resultType = typei.Type;  	else if (s is ParameterTypeStyle)  		// NOTE: As for constrained call above' if type parameter is instantitated to  		// a ref type' then this box type is considered equivalent to the  		// underlying reference type.  		resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type);  	else  		throw new InvalidOperationException ("can only box/cast to reference' value or parameter type");  	if (typei.Op == TypeOp.Box)  		state.PeekExpectedType (0' typei.Type' changed);  	else  		state.PeekReferenceType (0);  	return state.PopPushType (1' resultType' BottomPT);  }  case TypeOp.Unbox:  	if (!(typei.Type.Style (methEnv) is ValueTypeStyle))  		// Parameter types are not allowed  		throw new InvalidOperationException ("type must be a value type");  	state.PeekBoxedType (0' typei.Type' changed);  	return state.PopPushType (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (typei.Type)' HeapPT);  case TypeOp.UnboxAny: {  	var s = typei.Type.Style (methEnv);  	if (s is ValueTypeStyle)  		state.PeekBoxedType (0' typei.Type' changed);  	else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))  		throw new InvalidOperationException ("type must be value' reference or parameter type");  	return state.PopPushType (1' typei.Type' BottomPT);  }  case TypeOp.Ldtoken:  	return state.PushType (global.RuntimeTypeHandleRef' BottomPT);  case TypeOp.Ldelem:  	state.PeekIndexType (0);  	state.PeekReadArrayType (1' typei.Type' false);  	return state.PopPushType (2' typei.Type' BottomPT);  case TypeOp.Stelem:  	state.PeekExpectedType (0' typei.Type' changed);  	state.PeekIndexType (1);  	state.PeekWriteArrayType (2' typei.Type);  	return state.Pop (3);  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (typei.Op) {  case TypeOp.Ldobj:  	state.PeekReadPointerType (0' typei.Type);  	return state.PopPushType (1' typei.Type' BottomPT);  case TypeOp.Stobj:  	state.PeekExpectedType (0' typei.Type' changed);  	state.PeekWritePointerType (1' typei.Type);  	return state.Pop (2);  case TypeOp.Cpobj:  	state.PeekReadPointerType (0' typei.Type);  	state.PeekWritePointerType (1' typei.Type);  	return state.Pop (2);  case TypeOp.Newarr:  	state.PeekIndexType (0);  	return state.PopPushType (1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo (typei.Type)' BottomPT);  case TypeOp.Initobj:  	state.PeekWritePointerType (0' typei.Type);  	return state.Pop (1);  case TypeOp.Castclass:  case TypeOp.Isinst:  case TypeOp.Box: {  	var resultType = default(TypeRef);  	var s = typei.Type.Style (methEnv);  	if (s is NullableTypeStyle)  		resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type.Arguments [0]);  	else if (s is ValueTypeStyle)  		resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type);  	else if (s is ReferenceTypeStyle)  		resultType = typei.Type;  	else if (s is ParameterTypeStyle)  		// NOTE: As for constrained call above' if type parameter is instantitated to  		// a ref type' then this box type is considered equivalent to the  		// underlying reference type.  		resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type);  	else  		throw new InvalidOperationException ("can only box/cast to reference' value or parameter type");  	if (typei.Op == TypeOp.Box)  		state.PeekExpectedType (0' typei.Type' changed);  	else  		state.PeekReferenceType (0);  	return state.PopPushType (1' resultType' BottomPT);  }  case TypeOp.Unbox:  	if (!(typei.Type.Style (methEnv) is ValueTypeStyle))  		// Parameter types are not allowed  		throw new InvalidOperationException ("type must be a value type");  	state.PeekBoxedType (0' typei.Type' changed);  	return state.PopPushType (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (typei.Type)' HeapPT);  case TypeOp.UnboxAny: {  	var s = typei.Type.Style (methEnv);  	if (s is ValueTypeStyle)  		state.PeekBoxedType (0' typei.Type' changed);  	else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))  		throw new InvalidOperationException ("type must be value' reference or parameter type");  	return state.PopPushType (1' typei.Type' BottomPT);  }  case TypeOp.Ldtoken:  	return state.PushType (global.RuntimeTypeHandleRef' BottomPT);  case TypeOp.Ldelem:  	state.PeekIndexType (0);  	state.PeekReadArrayType (1' typei.Type' false);  	return state.PopPushType (2' typei.Type' BottomPT);  case TypeOp.Stelem:  	state.PeekExpectedType (0' typei.Type' changed);  	state.PeekIndexType (1);  	state.PeekWriteArrayType (2' typei.Type);  	return state.Pop (3);  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (typei.Op) {  case TypeOp.Ldobj:  	state.PeekReadPointerType (0' typei.Type);  	return state.PopPushType (1' typei.Type' BottomPT);  case TypeOp.Stobj:  	state.PeekExpectedType (0' typei.Type' changed);  	state.PeekWritePointerType (1' typei.Type);  	return state.Pop (2);  case TypeOp.Cpobj:  	state.PeekReadPointerType (0' typei.Type);  	state.PeekWritePointerType (1' typei.Type);  	return state.Pop (2);  case TypeOp.Newarr:  	state.PeekIndexType (0);  	return state.PopPushType (1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo (typei.Type)' BottomPT);  case TypeOp.Initobj:  	state.PeekWritePointerType (0' typei.Type);  	return state.Pop (1);  case TypeOp.Castclass:  case TypeOp.Isinst:  case TypeOp.Box: {  	var resultType = default(TypeRef);  	var s = typei.Type.Style (methEnv);  	if (s is NullableTypeStyle)  		resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type.Arguments [0]);  	else if (s is ValueTypeStyle)  		resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type);  	else if (s is ReferenceTypeStyle)  		resultType = typei.Type;  	else if (s is ParameterTypeStyle)  		// NOTE: As for constrained call above' if type parameter is instantitated to  		// a ref type' then this box type is considered equivalent to the  		// underlying reference type.  		resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type);  	else  		throw new InvalidOperationException ("can only box/cast to reference' value or parameter type");  	if (typei.Op == TypeOp.Box)  		state.PeekExpectedType (0' typei.Type' changed);  	else  		state.PeekReferenceType (0);  	return state.PopPushType (1' resultType' BottomPT);  }  case TypeOp.Unbox:  	if (!(typei.Type.Style (methEnv) is ValueTypeStyle))  		// Parameter types are not allowed  		throw new InvalidOperationException ("type must be a value type");  	state.PeekBoxedType (0' typei.Type' changed);  	return state.PopPushType (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (typei.Type)' HeapPT);  case TypeOp.UnboxAny: {  	var s = typei.Type.Style (methEnv);  	if (s is ValueTypeStyle)  		state.PeekBoxedType (0' typei.Type' changed);  	else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))  		throw new InvalidOperationException ("type must be value' reference or parameter type");  	return state.PopPushType (1' typei.Type' BottomPT);  }  case TypeOp.Ldtoken:  	return state.PushType (global.RuntimeTypeHandleRef' BottomPT);  case TypeOp.Ldelem:  	state.PeekIndexType (0);  	state.PeekReadArrayType (1' typei.Type' false);  	return state.PopPushType (2' typei.Type' BottomPT);  case TypeOp.Stelem:  	state.PeekExpectedType (0' typei.Type' changed);  	state.PeekIndexType (1);  	state.PeekWriteArrayType (2' typei.Type);  	return state.Pop (3);  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (typei.Op) {  case TypeOp.Ldobj:  	state.PeekReadPointerType (0' typei.Type);  	return state.PopPushType (1' typei.Type' BottomPT);  case TypeOp.Stobj:  	state.PeekExpectedType (0' typei.Type' changed);  	state.PeekWritePointerType (1' typei.Type);  	return state.Pop (2);  case TypeOp.Cpobj:  	state.PeekReadPointerType (0' typei.Type);  	state.PeekWritePointerType (1' typei.Type);  	return state.Pop (2);  case TypeOp.Newarr:  	state.PeekIndexType (0);  	return state.PopPushType (1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo (typei.Type)' BottomPT);  case TypeOp.Initobj:  	state.PeekWritePointerType (0' typei.Type);  	return state.Pop (1);  case TypeOp.Castclass:  case TypeOp.Isinst:  case TypeOp.Box: {  	var resultType = default(TypeRef);  	var s = typei.Type.Style (methEnv);  	if (s is NullableTypeStyle)  		resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type.Arguments [0]);  	else if (s is ValueTypeStyle)  		resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type);  	else if (s is ReferenceTypeStyle)  		resultType = typei.Type;  	else if (s is ParameterTypeStyle)  		// NOTE: As for constrained call above' if type parameter is instantitated to  		// a ref type' then this box type is considered equivalent to the  		// underlying reference type.  		resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type);  	else  		throw new InvalidOperationException ("can only box/cast to reference' value or parameter type");  	if (typei.Op == TypeOp.Box)  		state.PeekExpectedType (0' typei.Type' changed);  	else  		state.PeekReferenceType (0);  	return state.PopPushType (1' resultType' BottomPT);  }  case TypeOp.Unbox:  	if (!(typei.Type.Style (methEnv) is ValueTypeStyle))  		// Parameter types are not allowed  		throw new InvalidOperationException ("type must be a value type");  	state.PeekBoxedType (0' typei.Type' changed);  	return state.PopPushType (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (typei.Type)' HeapPT);  case TypeOp.UnboxAny: {  	var s = typei.Type.Style (methEnv);  	if (s is ValueTypeStyle)  		state.PeekBoxedType (0' typei.Type' changed);  	else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))  		throw new InvalidOperationException ("type must be value' reference or parameter type");  	return state.PopPushType (1' typei.Type' BottomPT);  }  case TypeOp.Ldtoken:  	return state.PushType (global.RuntimeTypeHandleRef' BottomPT);  case TypeOp.Ldelem:  	state.PeekIndexType (0);  	state.PeekReadArrayType (1' typei.Type' false);  	return state.PopPushType (2' typei.Type' BottomPT);  case TypeOp.Stelem:  	state.PeekExpectedType (0' typei.Type' changed);  	state.PeekIndexType (1);  	state.PeekWriteArrayType (2' typei.Type);  	return state.Pop (3);  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (typei.Op) {  case TypeOp.Ldobj:  	state.PeekReadPointerType (0' typei.Type);  	return state.PopPushType (1' typei.Type' BottomPT);  case TypeOp.Stobj:  	state.PeekExpectedType (0' typei.Type' changed);  	state.PeekWritePointerType (1' typei.Type);  	return state.Pop (2);  case TypeOp.Cpobj:  	state.PeekReadPointerType (0' typei.Type);  	state.PeekWritePointerType (1' typei.Type);  	return state.Pop (2);  case TypeOp.Newarr:  	state.PeekIndexType (0);  	return state.PopPushType (1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo (typei.Type)' BottomPT);  case TypeOp.Initobj:  	state.PeekWritePointerType (0' typei.Type);  	return state.Pop (1);  case TypeOp.Castclass:  case TypeOp.Isinst:  case TypeOp.Box: {  	var resultType = default(TypeRef);  	var s = typei.Type.Style (methEnv);  	if (s is NullableTypeStyle)  		resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type.Arguments [0]);  	else if (s is ValueTypeStyle)  		resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type);  	else if (s is ReferenceTypeStyle)  		resultType = typei.Type;  	else if (s is ParameterTypeStyle)  		// NOTE: As for constrained call above' if type parameter is instantitated to  		// a ref type' then this box type is considered equivalent to the  		// underlying reference type.  		resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo (typei.Type);  	else  		throw new InvalidOperationException ("can only box/cast to reference' value or parameter type");  	if (typei.Op == TypeOp.Box)  		state.PeekExpectedType (0' typei.Type' changed);  	else  		state.PeekReferenceType (0);  	return state.PopPushType (1' resultType' BottomPT);  }  case TypeOp.Unbox:  	if (!(typei.Type.Style (methEnv) is ValueTypeStyle))  		// Parameter types are not allowed  		throw new InvalidOperationException ("type must be a value type");  	state.PeekBoxedType (0' typei.Type' changed);  	return state.PopPushType (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (typei.Type)' HeapPT);  case TypeOp.UnboxAny: {  	var s = typei.Type.Style (methEnv);  	if (s is ValueTypeStyle)  		state.PeekBoxedType (0' typei.Type' changed);  	else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))  		throw new InvalidOperationException ("type must be value' reference or parameter type");  	return state.PopPushType (1' typei.Type' BottomPT);  }  case TypeOp.Ldtoken:  	return state.PushType (global.RuntimeTypeHandleRef' BottomPT);  case TypeOp.Ldelem:  	state.PeekIndexType (0);  	state.PeekReadArrayType (1' typei.Type' false);  	return state.PopPushType (2' typei.Type' BottomPT);  case TypeOp.Stelem:  	state.PeekExpectedType (0' typei.Type' changed);  	state.PeekIndexType (1);  	state.PeekWriteArrayType (2' typei.Type);  	return state.Pop (3);  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: return state.Pop (2);  
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: return state.Pop (2);  
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: return state.PopPushType (2' typei.Type' BottomPT);  
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: state.PeekWriteArrayType (2' typei.Type);  
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: return state.Pop (3);  
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: return state.PopPushType (2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo (ldelemai.Type)' HeapPT);  
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (arithi.Op) {  case ArithOp.Add:  case ArithOp.Sub:  case ArithOp.Mul:  case ArithOp.Div:  case ArithOp.Rem:  	// NOTE: May capture skolemized types  	arithi.Type = state.Peek2NumberTypes (0' true);  	return state.PopPushType (2' arithi.Type' BottomPT);  case ArithOp.Neg:  	// NOTE: May capture skolemized types  	arithi.Type = state.PeekNumberType (0' true);  	// Changing underlying value' so pop/push explicitly  	return state.PopPushType (1' arithi.Type' BottomPT);  case ArithOp.BitAnd:  case ArithOp.BitOr:  case ArithOp.BitXor:  	// NOTE: May capture skolemized types  	arithi.Type = state.Peek2NumberTypes (0' false);  	return state.PopPushType (2' arithi.Type' BottomPT);  case ArithOp.BitNot:  	// NOTE: May capture skolemized types  	arithi.Type = state.PeekNumberType (0' false);  	// Changing underlying value' so pop/push explicitly  	return state.PopPushType (1' arithi.Type' BottomPT);  case ArithOp.Shl:  case ArithOp.Shr:  	state.PeekExpectedType (0' global.Int32Ref' changed);  	// NOTE: May capture skolemized types  	arithi.Type = state.PeekNumberType (1' false);  	// Changing underlying value' so pop/push explicitly  	return state.PopPushType (2' arithi.Type' BottomPT);  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (arithi.Op) {  case ArithOp.Add:  case ArithOp.Sub:  case ArithOp.Mul:  case ArithOp.Div:  case ArithOp.Rem:  	// NOTE: May capture skolemized types  	arithi.Type = state.Peek2NumberTypes (0' true);  	return state.PopPushType (2' arithi.Type' BottomPT);  case ArithOp.Neg:  	// NOTE: May capture skolemized types  	arithi.Type = state.PeekNumberType (0' true);  	// Changing underlying value' so pop/push explicitly  	return state.PopPushType (1' arithi.Type' BottomPT);  case ArithOp.BitAnd:  case ArithOp.BitOr:  case ArithOp.BitXor:  	// NOTE: May capture skolemized types  	arithi.Type = state.Peek2NumberTypes (0' false);  	return state.PopPushType (2' arithi.Type' BottomPT);  case ArithOp.BitNot:  	// NOTE: May capture skolemized types  	arithi.Type = state.PeekNumberType (0' false);  	// Changing underlying value' so pop/push explicitly  	return state.PopPushType (1' arithi.Type' BottomPT);  case ArithOp.Shl:  case ArithOp.Shr:  	state.PeekExpectedType (0' global.Int32Ref' changed);  	// NOTE: May capture skolemized types  	arithi.Type = state.PeekNumberType (1' false);  	// Changing underlying value' so pop/push explicitly  	return state.PopPushType (2' arithi.Type' BottomPT);  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (arithi.Op) {  case ArithOp.Add:  case ArithOp.Sub:  case ArithOp.Mul:  case ArithOp.Div:  case ArithOp.Rem:  	// NOTE: May capture skolemized types  	arithi.Type = state.Peek2NumberTypes (0' true);  	return state.PopPushType (2' arithi.Type' BottomPT);  case ArithOp.Neg:  	// NOTE: May capture skolemized types  	arithi.Type = state.PeekNumberType (0' true);  	// Changing underlying value' so pop/push explicitly  	return state.PopPushType (1' arithi.Type' BottomPT);  case ArithOp.BitAnd:  case ArithOp.BitOr:  case ArithOp.BitXor:  	// NOTE: May capture skolemized types  	arithi.Type = state.Peek2NumberTypes (0' false);  	return state.PopPushType (2' arithi.Type' BottomPT);  case ArithOp.BitNot:  	// NOTE: May capture skolemized types  	arithi.Type = state.PeekNumberType (0' false);  	// Changing underlying value' so pop/push explicitly  	return state.PopPushType (1' arithi.Type' BottomPT);  case ArithOp.Shl:  case ArithOp.Shr:  	state.PeekExpectedType (0' global.Int32Ref' changed);  	// NOTE: May capture skolemized types  	arithi.Type = state.PeekNumberType (1' false);  	// Changing underlying value' so pop/push explicitly  	return state.PopPushType (2' arithi.Type' BottomPT);  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: return state.PopPushType (2' arithi.Type' BottomPT);  
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: return state.PopPushType (2' arithi.Type' BottomPT);  
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: return state.PopPushType (2' arithi.Type' BottomPT);  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,AssemblyName,The following statement contains a magic number: if (resolution == AssemblyNameResolution.Full) {  	if (publicKeyToken != null && publicKeyToken.Length != 0) {  		if (publicKeyToken.Length > 8) {  			var sha1 = new System.Security.Cryptography.SHA1CryptoServiceProvider ();  			var hash = sha1.ComputeHash (publicKeyToken);  			publicKeyToken = new byte[8];  			for (var i = 0; i < 8; i++)  				publicKeyToken [i] = hash [hash.Length - 1 - i];  		}  		PublicKeyToken = publicKeyToken;  	}  }  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,AssemblyName,The following statement contains a magic number: if (resolution == AssemblyNameResolution.Full) {  	if (publicKeyToken != null && publicKeyToken.Length != 0) {  		if (publicKeyToken.Length > 8) {  			var sha1 = new System.Security.Cryptography.SHA1CryptoServiceProvider ();  			var hash = sha1.ComputeHash (publicKeyToken);  			publicKeyToken = new byte[8];  			for (var i = 0; i < 8; i++)  				publicKeyToken [i] = hash [hash.Length - 1 - i];  		}  		PublicKeyToken = publicKeyToken;  	}  }  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,AssemblyName,The following statement contains a magic number: if (resolution == AssemblyNameResolution.Full) {  	if (publicKeyToken != null && publicKeyToken.Length != 0) {  		if (publicKeyToken.Length > 8) {  			var sha1 = new System.Security.Cryptography.SHA1CryptoServiceProvider ();  			var hash = sha1.ComputeHash (publicKeyToken);  			publicKeyToken = new byte[8];  			for (var i = 0; i < 8; i++)  				publicKeyToken [i] = hash [hash.Length - 1 - i];  		}  		PublicKeyToken = publicKeyToken;  	}  }  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,AssemblyName,The following statement contains a magic number: if (publicKeyToken != null && publicKeyToken.Length != 0) {  	if (publicKeyToken.Length > 8) {  		var sha1 = new System.Security.Cryptography.SHA1CryptoServiceProvider ();  		var hash = sha1.ComputeHash (publicKeyToken);  		publicKeyToken = new byte[8];  		for (var i = 0; i < 8; i++)  			publicKeyToken [i] = hash [hash.Length - 1 - i];  	}  	PublicKeyToken = publicKeyToken;  }  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,AssemblyName,The following statement contains a magic number: if (publicKeyToken != null && publicKeyToken.Length != 0) {  	if (publicKeyToken.Length > 8) {  		var sha1 = new System.Security.Cryptography.SHA1CryptoServiceProvider ();  		var hash = sha1.ComputeHash (publicKeyToken);  		publicKeyToken = new byte[8];  		for (var i = 0; i < 8; i++)  			publicKeyToken [i] = hash [hash.Length - 1 - i];  	}  	PublicKeyToken = publicKeyToken;  }  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,AssemblyName,The following statement contains a magic number: if (publicKeyToken != null && publicKeyToken.Length != 0) {  	if (publicKeyToken.Length > 8) {  		var sha1 = new System.Security.Cryptography.SHA1CryptoServiceProvider ();  		var hash = sha1.ComputeHash (publicKeyToken);  		publicKeyToken = new byte[8];  		for (var i = 0; i < 8; i++)  			publicKeyToken [i] = hash [hash.Length - 1 - i];  	}  	PublicKeyToken = publicKeyToken;  }  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,AssemblyName,The following statement contains a magic number: if (publicKeyToken.Length > 8) {  	var sha1 = new System.Security.Cryptography.SHA1CryptoServiceProvider ();  	var hash = sha1.ComputeHash (publicKeyToken);  	publicKeyToken = new byte[8];  	for (var i = 0; i < 8; i++)  		publicKeyToken [i] = hash [hash.Length - 1 - i];  }  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,AssemblyName,The following statement contains a magic number: if (publicKeyToken.Length > 8) {  	var sha1 = new System.Security.Cryptography.SHA1CryptoServiceProvider ();  	var hash = sha1.ComputeHash (publicKeyToken);  	publicKeyToken = new byte[8];  	for (var i = 0; i < 8; i++)  		publicKeyToken [i] = hash [hash.Length - 1 - i];  }  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,AssemblyName,The following statement contains a magic number: if (publicKeyToken.Length > 8) {  	var sha1 = new System.Security.Cryptography.SHA1CryptoServiceProvider ();  	var hash = sha1.ComputeHash (publicKeyToken);  	publicKeyToken = new byte[8];  	for (var i = 0; i < 8; i++)  		publicKeyToken [i] = hash [hash.Length - 1 - i];  }  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,AssemblyName,The following statement contains a magic number: publicKeyToken = new byte[8];  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,AssemblyName,The following statement contains a magic number: for (var i = 0; i < 8; i++)  	publicKeyToken [i] = hash [hash.Length - 1 - i];  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,Append,The following statement contains a magic number: if (w.Global.AssemblyNameResolution == AssemblyNameResolution.Full) {  	w.Append ("' PublicKeyToken=");  	if (PublicKeyToken == null)  		w.Append (defaultPublicKeyToken);  	else {  		for (var i = 0; i < PublicKeyToken.Length; i++) {  			var v = PublicKeyToken [i];  			for (var j = 0; j < 2; j++) {  				var d = v >> 4;  				w.Append (d < 10 ? '0' + d : 'a' + (d - 10));  				v <<= 4;  			}  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,Append,The following statement contains a magic number: if (w.Global.AssemblyNameResolution == AssemblyNameResolution.Full) {  	w.Append ("' PublicKeyToken=");  	if (PublicKeyToken == null)  		w.Append (defaultPublicKeyToken);  	else {  		for (var i = 0; i < PublicKeyToken.Length; i++) {  			var v = PublicKeyToken [i];  			for (var j = 0; j < 2; j++) {  				var d = v >> 4;  				w.Append (d < 10 ? '0' + d : 'a' + (d - 10));  				v <<= 4;  			}  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,Append,The following statement contains a magic number: if (w.Global.AssemblyNameResolution == AssemblyNameResolution.Full) {  	w.Append ("' PublicKeyToken=");  	if (PublicKeyToken == null)  		w.Append (defaultPublicKeyToken);  	else {  		for (var i = 0; i < PublicKeyToken.Length; i++) {  			var v = PublicKeyToken [i];  			for (var j = 0; j < 2; j++) {  				var d = v >> 4;  				w.Append (d < 10 ? '0' + d : 'a' + (d - 10));  				v <<= 4;  			}  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,Append,The following statement contains a magic number: if (w.Global.AssemblyNameResolution == AssemblyNameResolution.Full) {  	w.Append ("' PublicKeyToken=");  	if (PublicKeyToken == null)  		w.Append (defaultPublicKeyToken);  	else {  		for (var i = 0; i < PublicKeyToken.Length; i++) {  			var v = PublicKeyToken [i];  			for (var j = 0; j < 2; j++) {  				var d = v >> 4;  				w.Append (d < 10 ? '0' + d : 'a' + (d - 10));  				v <<= 4;  			}  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,Append,The following statement contains a magic number: if (w.Global.AssemblyNameResolution == AssemblyNameResolution.Full) {  	w.Append ("' PublicKeyToken=");  	if (PublicKeyToken == null)  		w.Append (defaultPublicKeyToken);  	else {  		for (var i = 0; i < PublicKeyToken.Length; i++) {  			var v = PublicKeyToken [i];  			for (var j = 0; j < 2; j++) {  				var d = v >> 4;  				w.Append (d < 10 ? '0' + d : 'a' + (d - 10));  				v <<= 4;  			}  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,Append,The following statement contains a magic number: if (PublicKeyToken == null)  	w.Append (defaultPublicKeyToken);  else {  	for (var i = 0; i < PublicKeyToken.Length; i++) {  		var v = PublicKeyToken [i];  		for (var j = 0; j < 2; j++) {  			var d = v >> 4;  			w.Append (d < 10 ? '0' + d : 'a' + (d - 10));  			v <<= 4;  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,Append,The following statement contains a magic number: if (PublicKeyToken == null)  	w.Append (defaultPublicKeyToken);  else {  	for (var i = 0; i < PublicKeyToken.Length; i++) {  		var v = PublicKeyToken [i];  		for (var j = 0; j < 2; j++) {  			var d = v >> 4;  			w.Append (d < 10 ? '0' + d : 'a' + (d - 10));  			v <<= 4;  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,Append,The following statement contains a magic number: if (PublicKeyToken == null)  	w.Append (defaultPublicKeyToken);  else {  	for (var i = 0; i < PublicKeyToken.Length; i++) {  		var v = PublicKeyToken [i];  		for (var j = 0; j < 2; j++) {  			var d = v >> 4;  			w.Append (d < 10 ? '0' + d : 'a' + (d - 10));  			v <<= 4;  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,Append,The following statement contains a magic number: if (PublicKeyToken == null)  	w.Append (defaultPublicKeyToken);  else {  	for (var i = 0; i < PublicKeyToken.Length; i++) {  		var v = PublicKeyToken [i];  		for (var j = 0; j < 2; j++) {  			var d = v >> 4;  			w.Append (d < 10 ? '0' + d : 'a' + (d - 10));  			v <<= 4;  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,Append,The following statement contains a magic number: if (PublicKeyToken == null)  	w.Append (defaultPublicKeyToken);  else {  	for (var i = 0; i < PublicKeyToken.Length; i++) {  		var v = PublicKeyToken [i];  		for (var j = 0; j < 2; j++) {  			var d = v >> 4;  			w.Append (d < 10 ? '0' + d : 'a' + (d - 10));  			v <<= 4;  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,Append,The following statement contains a magic number: for (var i = 0; i < PublicKeyToken.Length; i++) {  	var v = PublicKeyToken [i];  	for (var j = 0; j < 2; j++) {  		var d = v >> 4;  		w.Append (d < 10 ? '0' + d : 'a' + (d - 10));  		v <<= 4;  	}  }  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,Append,The following statement contains a magic number: for (var i = 0; i < PublicKeyToken.Length; i++) {  	var v = PublicKeyToken [i];  	for (var j = 0; j < 2; j++) {  		var d = v >> 4;  		w.Append (d < 10 ? '0' + d : 'a' + (d - 10));  		v <<= 4;  	}  }  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,Append,The following statement contains a magic number: for (var i = 0; i < PublicKeyToken.Length; i++) {  	var v = PublicKeyToken [i];  	for (var j = 0; j < 2; j++) {  		var d = v >> 4;  		w.Append (d < 10 ? '0' + d : 'a' + (d - 10));  		v <<= 4;  	}  }  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,Append,The following statement contains a magic number: for (var i = 0; i < PublicKeyToken.Length; i++) {  	var v = PublicKeyToken [i];  	for (var j = 0; j < 2; j++) {  		var d = v >> 4;  		w.Append (d < 10 ? '0' + d : 'a' + (d - 10));  		v <<= 4;  	}  }  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,Append,The following statement contains a magic number: for (var i = 0; i < PublicKeyToken.Length; i++) {  	var v = PublicKeyToken [i];  	for (var j = 0; j < 2; j++) {  		var d = v >> 4;  		w.Append (d < 10 ? '0' + d : 'a' + (d - 10));  		v <<= 4;  	}  }  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,Append,The following statement contains a magic number: for (var j = 0; j < 2; j++) {  	var d = v >> 4;  	w.Append (d < 10 ? '0' + d : 'a' + (d - 10));  	v <<= 4;  }  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,Append,The following statement contains a magic number: for (var j = 0; j < 2; j++) {  	var d = v >> 4;  	w.Append (d < 10 ? '0' + d : 'a' + (d - 10));  	v <<= 4;  }  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,Append,The following statement contains a magic number: for (var j = 0; j < 2; j++) {  	var d = v >> 4;  	w.Append (d < 10 ? '0' + d : 'a' + (d - 10));  	v <<= 4;  }  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,Append,The following statement contains a magic number: for (var j = 0; j < 2; j++) {  	var d = v >> 4;  	w.Append (d < 10 ? '0' + d : 'a' + (d - 10));  	v <<= 4;  }  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,Append,The following statement contains a magic number: for (var j = 0; j < 2; j++) {  	var d = v >> 4;  	w.Append (d < 10 ? '0' + d : 'a' + (d - 10));  	v <<= 4;  }  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,Append,The following statement contains a magic number: w.Append (d < 10 ? '0' + d : 'a' + (d - 10));  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,Append,The following statement contains a magic number: w.Append (d < 10 ? '0' + d : 'a' + (d - 10));  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,Append,The following statement contains a magic number: v <<= 4;  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,GetNum,The following statement contains a magic number: while (i < str.Length && str [i] >= '0' && str [i] <= '9') {  	v = v * 10 + (str [i++] - '0');  	any = true;  }  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,GetNum,The following statement contains a magic number: v = v * 10 + (str [i++] - '0');  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,GetByte,The following statement contains a magic number: while (i < str.Length && n < 2) {  	if (str [i] >= '0' && str [i] <= '9')  		v = v * 16 + (str [i] - '0');  	else if (str [i] >= 'a' && str [i] <= 'f')  		v = v * 16 + 10 + (str [i] - 'a');  	else if (str [i] >= 'A' && str [i] <= 'F')  		v = v * 16 + 10 + (str [i] - 'a');  	else  		return -1;  	n++;  	i++;  }  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,GetByte,The following statement contains a magic number: while (i < str.Length && n < 2) {  	if (str [i] >= '0' && str [i] <= '9')  		v = v * 16 + (str [i] - '0');  	else if (str [i] >= 'a' && str [i] <= 'f')  		v = v * 16 + 10 + (str [i] - 'a');  	else if (str [i] >= 'A' && str [i] <= 'F')  		v = v * 16 + 10 + (str [i] - 'a');  	else  		return -1;  	n++;  	i++;  }  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,GetByte,The following statement contains a magic number: while (i < str.Length && n < 2) {  	if (str [i] >= '0' && str [i] <= '9')  		v = v * 16 + (str [i] - '0');  	else if (str [i] >= 'a' && str [i] <= 'f')  		v = v * 16 + 10 + (str [i] - 'a');  	else if (str [i] >= 'A' && str [i] <= 'F')  		v = v * 16 + 10 + (str [i] - 'a');  	else  		return -1;  	n++;  	i++;  }  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,GetByte,The following statement contains a magic number: while (i < str.Length && n < 2) {  	if (str [i] >= '0' && str [i] <= '9')  		v = v * 16 + (str [i] - '0');  	else if (str [i] >= 'a' && str [i] <= 'f')  		v = v * 16 + 10 + (str [i] - 'a');  	else if (str [i] >= 'A' && str [i] <= 'F')  		v = v * 16 + 10 + (str [i] - 'a');  	else  		return -1;  	n++;  	i++;  }  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,GetByte,The following statement contains a magic number: while (i < str.Length && n < 2) {  	if (str [i] >= '0' && str [i] <= '9')  		v = v * 16 + (str [i] - '0');  	else if (str [i] >= 'a' && str [i] <= 'f')  		v = v * 16 + 10 + (str [i] - 'a');  	else if (str [i] >= 'A' && str [i] <= 'F')  		v = v * 16 + 10 + (str [i] - 'a');  	else  		return -1;  	n++;  	i++;  }  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,GetByte,The following statement contains a magic number: while (i < str.Length && n < 2) {  	if (str [i] >= '0' && str [i] <= '9')  		v = v * 16 + (str [i] - '0');  	else if (str [i] >= 'a' && str [i] <= 'f')  		v = v * 16 + 10 + (str [i] - 'a');  	else if (str [i] >= 'A' && str [i] <= 'F')  		v = v * 16 + 10 + (str [i] - 'a');  	else  		return -1;  	n++;  	i++;  }  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,GetByte,The following statement contains a magic number: if (str [i] >= '0' && str [i] <= '9')  	v = v * 16 + (str [i] - '0');  else if (str [i] >= 'a' && str [i] <= 'f')  	v = v * 16 + 10 + (str [i] - 'a');  else if (str [i] >= 'A' && str [i] <= 'F')  	v = v * 16 + 10 + (str [i] - 'a');  else  	return -1;  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,GetByte,The following statement contains a magic number: if (str [i] >= '0' && str [i] <= '9')  	v = v * 16 + (str [i] - '0');  else if (str [i] >= 'a' && str [i] <= 'f')  	v = v * 16 + 10 + (str [i] - 'a');  else if (str [i] >= 'A' && str [i] <= 'F')  	v = v * 16 + 10 + (str [i] - 'a');  else  	return -1;  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,GetByte,The following statement contains a magic number: if (str [i] >= '0' && str [i] <= '9')  	v = v * 16 + (str [i] - '0');  else if (str [i] >= 'a' && str [i] <= 'f')  	v = v * 16 + 10 + (str [i] - 'a');  else if (str [i] >= 'A' && str [i] <= 'F')  	v = v * 16 + 10 + (str [i] - 'a');  else  	return -1;  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,GetByte,The following statement contains a magic number: if (str [i] >= '0' && str [i] <= '9')  	v = v * 16 + (str [i] - '0');  else if (str [i] >= 'a' && str [i] <= 'f')  	v = v * 16 + 10 + (str [i] - 'a');  else if (str [i] >= 'A' && str [i] <= 'F')  	v = v * 16 + 10 + (str [i] - 'a');  else  	return -1;  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,GetByte,The following statement contains a magic number: if (str [i] >= '0' && str [i] <= '9')  	v = v * 16 + (str [i] - '0');  else if (str [i] >= 'a' && str [i] <= 'f')  	v = v * 16 + 10 + (str [i] - 'a');  else if (str [i] >= 'A' && str [i] <= 'F')  	v = v * 16 + 10 + (str [i] - 'a');  else  	return -1;  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,GetByte,The following statement contains a magic number: v = v * 16 + (str [i] - '0');  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,GetByte,The following statement contains a magic number: if (str [i] >= 'a' && str [i] <= 'f')  	v = v * 16 + 10 + (str [i] - 'a');  else if (str [i] >= 'A' && str [i] <= 'F')  	v = v * 16 + 10 + (str [i] - 'a');  else  	return -1;  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,GetByte,The following statement contains a magic number: if (str [i] >= 'a' && str [i] <= 'f')  	v = v * 16 + 10 + (str [i] - 'a');  else if (str [i] >= 'A' && str [i] <= 'F')  	v = v * 16 + 10 + (str [i] - 'a');  else  	return -1;  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,GetByte,The following statement contains a magic number: if (str [i] >= 'a' && str [i] <= 'f')  	v = v * 16 + 10 + (str [i] - 'a');  else if (str [i] >= 'A' && str [i] <= 'F')  	v = v * 16 + 10 + (str [i] - 'a');  else  	return -1;  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,GetByte,The following statement contains a magic number: if (str [i] >= 'a' && str [i] <= 'f')  	v = v * 16 + 10 + (str [i] - 'a');  else if (str [i] >= 'A' && str [i] <= 'F')  	v = v * 16 + 10 + (str [i] - 'a');  else  	return -1;  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,GetByte,The following statement contains a magic number: v = v * 16 + 10 + (str [i] - 'a');  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,GetByte,The following statement contains a magic number: v = v * 16 + 10 + (str [i] - 'a');  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,GetByte,The following statement contains a magic number: if (str [i] >= 'A' && str [i] <= 'F')  	v = v * 16 + 10 + (str [i] - 'a');  else  	return -1;  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,GetByte,The following statement contains a magic number: if (str [i] >= 'A' && str [i] <= 'F')  	v = v * 16 + 10 + (str [i] - 'a');  else  	return -1;  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,GetByte,The following statement contains a magic number: v = v * 16 + 10 + (str [i] - 'a');  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,GetByte,The following statement contains a magic number: v = v * 16 + 10 + (str [i] - 'a');  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,GetByte,The following statement contains a magic number: return n == 2 ? v : -1;  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,FromReflectionName,The following statement contains a magic number: if (i < 0)  	name = strongName;  else {  	name = strongName.Substring (0' i);  	i++;  	SkipWS (strongName' ref i);  	while (i < strongName.Length) {  		var kwd = GetKeyword (strongName' ref i);  		if (string.Equals (kwd' versionKeyword' StringComparison.OrdinalIgnoreCase)) {  			var version = GetValue (strongName' ref i);  			if (version == null)  				return null;  			var j = 0;  			majorVersion = GetNum (version' ref j);  			if (majorVersion < 0)  				return null;  			if (!SkipDot (version' ref j))  				return null;  			minorVersion = GetNum (version' ref j);  			if (minorVersion < 0)  				return null;  			if (!SkipDot (version' ref j))  				return null;  			buildNumber = GetNum (version' ref j);  			if (buildNumber < 0)  				return null;  			if (!SkipDot (version' ref j))  				return null;  			revisionNumber = GetNum (version' ref j);  			if (revisionNumber < 0)  				return null;  		}  		else if (string.Equals (kwd' cultureKeyword' StringComparison.OrdinalIgnoreCase)) {  			culture = GetValue (strongName' ref i);  			if (culture == null)  				return null;  		}  		else if (string.Equals (kwd' publicKeyTokenKeyword' StringComparison.OrdinalIgnoreCase)) {  			var hex = GetValue (strongName' ref i);  			if (hex == null)  				return null;  			if (!hex.Equals (defaultPublicKeyToken' StringComparison.OrdinalIgnoreCase)) {  				if (hex.Length % 2 != 0)  					return null;  				var j = 0;  				publicKeyToken = new byte[hex.Length / 2];  				for (var k = 0; k < publicKeyToken.Length; k++) {  					var v = GetByte (hex' ref j);  					if (v < 0)  						return null;  					publicKeyToken [k] = (byte)v;  				}  			}  		}  		else  			return null;  	}  }  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,FromReflectionName,The following statement contains a magic number: if (i < 0)  	name = strongName;  else {  	name = strongName.Substring (0' i);  	i++;  	SkipWS (strongName' ref i);  	while (i < strongName.Length) {  		var kwd = GetKeyword (strongName' ref i);  		if (string.Equals (kwd' versionKeyword' StringComparison.OrdinalIgnoreCase)) {  			var version = GetValue (strongName' ref i);  			if (version == null)  				return null;  			var j = 0;  			majorVersion = GetNum (version' ref j);  			if (majorVersion < 0)  				return null;  			if (!SkipDot (version' ref j))  				return null;  			minorVersion = GetNum (version' ref j);  			if (minorVersion < 0)  				return null;  			if (!SkipDot (version' ref j))  				return null;  			buildNumber = GetNum (version' ref j);  			if (buildNumber < 0)  				return null;  			if (!SkipDot (version' ref j))  				return null;  			revisionNumber = GetNum (version' ref j);  			if (revisionNumber < 0)  				return null;  		}  		else if (string.Equals (kwd' cultureKeyword' StringComparison.OrdinalIgnoreCase)) {  			culture = GetValue (strongName' ref i);  			if (culture == null)  				return null;  		}  		else if (string.Equals (kwd' publicKeyTokenKeyword' StringComparison.OrdinalIgnoreCase)) {  			var hex = GetValue (strongName' ref i);  			if (hex == null)  				return null;  			if (!hex.Equals (defaultPublicKeyToken' StringComparison.OrdinalIgnoreCase)) {  				if (hex.Length % 2 != 0)  					return null;  				var j = 0;  				publicKeyToken = new byte[hex.Length / 2];  				for (var k = 0; k < publicKeyToken.Length; k++) {  					var v = GetByte (hex' ref j);  					if (v < 0)  						return null;  					publicKeyToken [k] = (byte)v;  				}  			}  		}  		else  			return null;  	}  }  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,FromReflectionName,The following statement contains a magic number: while (i < strongName.Length) {  	var kwd = GetKeyword (strongName' ref i);  	if (string.Equals (kwd' versionKeyword' StringComparison.OrdinalIgnoreCase)) {  		var version = GetValue (strongName' ref i);  		if (version == null)  			return null;  		var j = 0;  		majorVersion = GetNum (version' ref j);  		if (majorVersion < 0)  			return null;  		if (!SkipDot (version' ref j))  			return null;  		minorVersion = GetNum (version' ref j);  		if (minorVersion < 0)  			return null;  		if (!SkipDot (version' ref j))  			return null;  		buildNumber = GetNum (version' ref j);  		if (buildNumber < 0)  			return null;  		if (!SkipDot (version' ref j))  			return null;  		revisionNumber = GetNum (version' ref j);  		if (revisionNumber < 0)  			return null;  	}  	else if (string.Equals (kwd' cultureKeyword' StringComparison.OrdinalIgnoreCase)) {  		culture = GetValue (strongName' ref i);  		if (culture == null)  			return null;  	}  	else if (string.Equals (kwd' publicKeyTokenKeyword' StringComparison.OrdinalIgnoreCase)) {  		var hex = GetValue (strongName' ref i);  		if (hex == null)  			return null;  		if (!hex.Equals (defaultPublicKeyToken' StringComparison.OrdinalIgnoreCase)) {  			if (hex.Length % 2 != 0)  				return null;  			var j = 0;  			publicKeyToken = new byte[hex.Length / 2];  			for (var k = 0; k < publicKeyToken.Length; k++) {  				var v = GetByte (hex' ref j);  				if (v < 0)  					return null;  				publicKeyToken [k] = (byte)v;  			}  		}  	}  	else  		return null;  }  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,FromReflectionName,The following statement contains a magic number: while (i < strongName.Length) {  	var kwd = GetKeyword (strongName' ref i);  	if (string.Equals (kwd' versionKeyword' StringComparison.OrdinalIgnoreCase)) {  		var version = GetValue (strongName' ref i);  		if (version == null)  			return null;  		var j = 0;  		majorVersion = GetNum (version' ref j);  		if (majorVersion < 0)  			return null;  		if (!SkipDot (version' ref j))  			return null;  		minorVersion = GetNum (version' ref j);  		if (minorVersion < 0)  			return null;  		if (!SkipDot (version' ref j))  			return null;  		buildNumber = GetNum (version' ref j);  		if (buildNumber < 0)  			return null;  		if (!SkipDot (version' ref j))  			return null;  		revisionNumber = GetNum (version' ref j);  		if (revisionNumber < 0)  			return null;  	}  	else if (string.Equals (kwd' cultureKeyword' StringComparison.OrdinalIgnoreCase)) {  		culture = GetValue (strongName' ref i);  		if (culture == null)  			return null;  	}  	else if (string.Equals (kwd' publicKeyTokenKeyword' StringComparison.OrdinalIgnoreCase)) {  		var hex = GetValue (strongName' ref i);  		if (hex == null)  			return null;  		if (!hex.Equals (defaultPublicKeyToken' StringComparison.OrdinalIgnoreCase)) {  			if (hex.Length % 2 != 0)  				return null;  			var j = 0;  			publicKeyToken = new byte[hex.Length / 2];  			for (var k = 0; k < publicKeyToken.Length; k++) {  				var v = GetByte (hex' ref j);  				if (v < 0)  					return null;  				publicKeyToken [k] = (byte)v;  			}  		}  	}  	else  		return null;  }  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,FromReflectionName,The following statement contains a magic number: if (string.Equals (kwd' versionKeyword' StringComparison.OrdinalIgnoreCase)) {  	var version = GetValue (strongName' ref i);  	if (version == null)  		return null;  	var j = 0;  	majorVersion = GetNum (version' ref j);  	if (majorVersion < 0)  		return null;  	if (!SkipDot (version' ref j))  		return null;  	minorVersion = GetNum (version' ref j);  	if (minorVersion < 0)  		return null;  	if (!SkipDot (version' ref j))  		return null;  	buildNumber = GetNum (version' ref j);  	if (buildNumber < 0)  		return null;  	if (!SkipDot (version' ref j))  		return null;  	revisionNumber = GetNum (version' ref j);  	if (revisionNumber < 0)  		return null;  }  else if (string.Equals (kwd' cultureKeyword' StringComparison.OrdinalIgnoreCase)) {  	culture = GetValue (strongName' ref i);  	if (culture == null)  		return null;  }  else if (string.Equals (kwd' publicKeyTokenKeyword' StringComparison.OrdinalIgnoreCase)) {  	var hex = GetValue (strongName' ref i);  	if (hex == null)  		return null;  	if (!hex.Equals (defaultPublicKeyToken' StringComparison.OrdinalIgnoreCase)) {  		if (hex.Length % 2 != 0)  			return null;  		var j = 0;  		publicKeyToken = new byte[hex.Length / 2];  		for (var k = 0; k < publicKeyToken.Length; k++) {  			var v = GetByte (hex' ref j);  			if (v < 0)  				return null;  			publicKeyToken [k] = (byte)v;  		}  	}  }  else  	return null;  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,FromReflectionName,The following statement contains a magic number: if (string.Equals (kwd' versionKeyword' StringComparison.OrdinalIgnoreCase)) {  	var version = GetValue (strongName' ref i);  	if (version == null)  		return null;  	var j = 0;  	majorVersion = GetNum (version' ref j);  	if (majorVersion < 0)  		return null;  	if (!SkipDot (version' ref j))  		return null;  	minorVersion = GetNum (version' ref j);  	if (minorVersion < 0)  		return null;  	if (!SkipDot (version' ref j))  		return null;  	buildNumber = GetNum (version' ref j);  	if (buildNumber < 0)  		return null;  	if (!SkipDot (version' ref j))  		return null;  	revisionNumber = GetNum (version' ref j);  	if (revisionNumber < 0)  		return null;  }  else if (string.Equals (kwd' cultureKeyword' StringComparison.OrdinalIgnoreCase)) {  	culture = GetValue (strongName' ref i);  	if (culture == null)  		return null;  }  else if (string.Equals (kwd' publicKeyTokenKeyword' StringComparison.OrdinalIgnoreCase)) {  	var hex = GetValue (strongName' ref i);  	if (hex == null)  		return null;  	if (!hex.Equals (defaultPublicKeyToken' StringComparison.OrdinalIgnoreCase)) {  		if (hex.Length % 2 != 0)  			return null;  		var j = 0;  		publicKeyToken = new byte[hex.Length / 2];  		for (var k = 0; k < publicKeyToken.Length; k++) {  			var v = GetByte (hex' ref j);  			if (v < 0)  				return null;  			publicKeyToken [k] = (byte)v;  		}  	}  }  else  	return null;  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,FromReflectionName,The following statement contains a magic number: if (string.Equals (kwd' cultureKeyword' StringComparison.OrdinalIgnoreCase)) {  	culture = GetValue (strongName' ref i);  	if (culture == null)  		return null;  }  else if (string.Equals (kwd' publicKeyTokenKeyword' StringComparison.OrdinalIgnoreCase)) {  	var hex = GetValue (strongName' ref i);  	if (hex == null)  		return null;  	if (!hex.Equals (defaultPublicKeyToken' StringComparison.OrdinalIgnoreCase)) {  		if (hex.Length % 2 != 0)  			return null;  		var j = 0;  		publicKeyToken = new byte[hex.Length / 2];  		for (var k = 0; k < publicKeyToken.Length; k++) {  			var v = GetByte (hex' ref j);  			if (v < 0)  				return null;  			publicKeyToken [k] = (byte)v;  		}  	}  }  else  	return null;  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,FromReflectionName,The following statement contains a magic number: if (string.Equals (kwd' cultureKeyword' StringComparison.OrdinalIgnoreCase)) {  	culture = GetValue (strongName' ref i);  	if (culture == null)  		return null;  }  else if (string.Equals (kwd' publicKeyTokenKeyword' StringComparison.OrdinalIgnoreCase)) {  	var hex = GetValue (strongName' ref i);  	if (hex == null)  		return null;  	if (!hex.Equals (defaultPublicKeyToken' StringComparison.OrdinalIgnoreCase)) {  		if (hex.Length % 2 != 0)  			return null;  		var j = 0;  		publicKeyToken = new byte[hex.Length / 2];  		for (var k = 0; k < publicKeyToken.Length; k++) {  			var v = GetByte (hex' ref j);  			if (v < 0)  				return null;  			publicKeyToken [k] = (byte)v;  		}  	}  }  else  	return null;  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,FromReflectionName,The following statement contains a magic number: if (string.Equals (kwd' publicKeyTokenKeyword' StringComparison.OrdinalIgnoreCase)) {  	var hex = GetValue (strongName' ref i);  	if (hex == null)  		return null;  	if (!hex.Equals (defaultPublicKeyToken' StringComparison.OrdinalIgnoreCase)) {  		if (hex.Length % 2 != 0)  			return null;  		var j = 0;  		publicKeyToken = new byte[hex.Length / 2];  		for (var k = 0; k < publicKeyToken.Length; k++) {  			var v = GetByte (hex' ref j);  			if (v < 0)  				return null;  			publicKeyToken [k] = (byte)v;  		}  	}  }  else  	return null;  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,FromReflectionName,The following statement contains a magic number: if (string.Equals (kwd' publicKeyTokenKeyword' StringComparison.OrdinalIgnoreCase)) {  	var hex = GetValue (strongName' ref i);  	if (hex == null)  		return null;  	if (!hex.Equals (defaultPublicKeyToken' StringComparison.OrdinalIgnoreCase)) {  		if (hex.Length % 2 != 0)  			return null;  		var j = 0;  		publicKeyToken = new byte[hex.Length / 2];  		for (var k = 0; k < publicKeyToken.Length; k++) {  			var v = GetByte (hex' ref j);  			if (v < 0)  				return null;  			publicKeyToken [k] = (byte)v;  		}  	}  }  else  	return null;  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,FromReflectionName,The following statement contains a magic number: if (!hex.Equals (defaultPublicKeyToken' StringComparison.OrdinalIgnoreCase)) {  	if (hex.Length % 2 != 0)  		return null;  	var j = 0;  	publicKeyToken = new byte[hex.Length / 2];  	for (var k = 0; k < publicKeyToken.Length; k++) {  		var v = GetByte (hex' ref j);  		if (v < 0)  			return null;  		publicKeyToken [k] = (byte)v;  	}  }  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,FromReflectionName,The following statement contains a magic number: if (!hex.Equals (defaultPublicKeyToken' StringComparison.OrdinalIgnoreCase)) {  	if (hex.Length % 2 != 0)  		return null;  	var j = 0;  	publicKeyToken = new byte[hex.Length / 2];  	for (var k = 0; k < publicKeyToken.Length; k++) {  		var v = GetByte (hex' ref j);  		if (v < 0)  			return null;  		publicKeyToken [k] = (byte)v;  	}  }  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,FromReflectionName,The following statement contains a magic number: if (hex.Length % 2 != 0)  	return null;  
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,FromReflectionName,The following statement contains a magic number: publicKeyToken = new byte[hex.Length / 2];  
Magic Number,Microsoft.LiveLabs.CST,Peephole,C:\repos\Reactive-Extensions_IL2JS\CST\Peephole.cs,MoveNext,The following statement contains a magic number: do {  	rewritten = false;  	if (EnsureLookahead (1)) {  		var i = lookahead [0];  		if (i.Flavor == InstructionFlavor.ArgLocal) {  			var argloci = (ArgLocalInstruction)i;  			if (argloci.Op == ArgLocalOp.St) {  				if (!argloci.AfterState.ArgLocalIsAlive (argloci.ArgLocal' argloci.Index)) {  					// starg.n (where arg n is dead) ==> pop  					// stloc.n (where local n is dead) ==> pop  					lookahead [0] = new MiscInstruction (argloci.Offset' MiscOp.Pop) {  						BeforeState = argloci.BeforeState'  						AfterState = argloci.AfterState  					};  					Trace (1' argloci);  					rewritten = true;  				}  				else if (EnsureLookahead (2)) {  					var j = lookahead [1];  					if (j.Flavor == InstructionFlavor.ArgLocal) {  						var arglocj = (ArgLocalInstruction)j;  						if (arglocj.Op == ArgLocalOp.Ld && argloci.ArgLocal == arglocj.ArgLocal && argloci.Index == arglocj.Index) {  							if (!arglocj.AfterState.ArgLocalIsAlive (arglocj.ArgLocal' arglocj.Index)) {  								// stloc.n; ldloc.n (where local n is dead) ==> <empty>  								// starg.n; ldarg.n (where arg n is dead) ==> <empty>   								lookahead.RemoveAt (0);  								lookahead.RemoveAt (0);  								Trace (0' argloci' arglocj);  								rewritten = true;  							}  						}  					}  				}  			}  		}  		else if (i.Flavor == InstructionFlavor.LdInt32) {  			var ldinti = (LdInt32Instruction)i;  			if (ldinti.Value == 0) {  				if (EnsureLookahead (2)) {  					var j = lookahead [1];  					if (j.Flavor == InstructionFlavor.Compare) {  						var compj = (CompareInstruction)j;  						if (compj.Op == CompareOp.Cgt && compj.IsUnsigned) {  							// ldc.i4 0; cgt.u => ctrue  							lookahead.RemoveAt (0);  							lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CtruePseudo' false) {  								Type = compj.Type'  								BeforeState = ldinti.BeforeState'  								AfterState = compj.AfterState  							};  							Trace (1' ldinti' compj);  							rewritten = true;  						}  						else if (compj.Op == CompareOp.Ceq) {  							// ldc.i4 0; ceq => cfalse  							lookahead.RemoveAt (0);  							lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CfalsePseudo' false) {  								Type = compj.Type'  								BeforeState = ldinti.BeforeState'  								AfterState = compj.AfterState  							};  							Trace (1' ldinti' compj);  							rewritten = true;  						}  					}  				}  			}  		}  		else if (i.Flavor == InstructionFlavor.Misc) {  			var misci = (MiscInstruction)i;  			if (misci.Op == MiscOp.Nop) {  				// nop ==> <empty>  				lookahead.RemoveAt (0);  				Trace (0' misci);  				rewritten = true;  			}  			else if (misci.Op == MiscOp.Ldnull) {  				if (EnsureLookahead (2)) {  					var j = lookahead [1];  					if (j.Flavor == InstructionFlavor.Compare) {  						var compj = (CompareInstruction)j;  						if (compj.Op == CompareOp.Cgt) {  							// ldnull; cgt => ctrue  							lookahead.RemoveAt (0);  							lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CtruePseudo' false) {  								Type = compj.Type'  								BeforeState = misci.BeforeState'  								AfterState = compj.AfterState  							};  							Trace (1' misci' compj);  							rewritten = true;  						}  						else if (compj.Op == CompareOp.Ceq) {  							// ldnull; ceq => cfalse  							lookahead.RemoveAt (0);  							lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CfalsePseudo' false) {  								Type = compj.Type'  								BeforeState = misci.BeforeState'  								AfterState = compj.AfterState  							};  							Trace (1' misci' compj);  							rewritten = true;  						}  					}  				}  			}  			else if (misci.Op == MiscOp.Dup) {  				if (EnsureLookahead (2)) {  					var j = lookahead [1];  					if (j.Flavor == InstructionFlavor.Misc) {  						var miscj = (MiscInstruction)j;  						if (miscj.Op == MiscOp.Pop) {  							// dup; pop ==> <empty>  							lookahead.RemoveAt (0);  							lookahead.RemoveAt (0);  							Trace (0' misci' miscj);  							rewritten = true;  						}  					}  				}  			}  		}  	}  }  while (rewritten);  
Magic Number,Microsoft.LiveLabs.CST,Peephole,C:\repos\Reactive-Extensions_IL2JS\CST\Peephole.cs,MoveNext,The following statement contains a magic number: do {  	rewritten = false;  	if (EnsureLookahead (1)) {  		var i = lookahead [0];  		if (i.Flavor == InstructionFlavor.ArgLocal) {  			var argloci = (ArgLocalInstruction)i;  			if (argloci.Op == ArgLocalOp.St) {  				if (!argloci.AfterState.ArgLocalIsAlive (argloci.ArgLocal' argloci.Index)) {  					// starg.n (where arg n is dead) ==> pop  					// stloc.n (where local n is dead) ==> pop  					lookahead [0] = new MiscInstruction (argloci.Offset' MiscOp.Pop) {  						BeforeState = argloci.BeforeState'  						AfterState = argloci.AfterState  					};  					Trace (1' argloci);  					rewritten = true;  				}  				else if (EnsureLookahead (2)) {  					var j = lookahead [1];  					if (j.Flavor == InstructionFlavor.ArgLocal) {  						var arglocj = (ArgLocalInstruction)j;  						if (arglocj.Op == ArgLocalOp.Ld && argloci.ArgLocal == arglocj.ArgLocal && argloci.Index == arglocj.Index) {  							if (!arglocj.AfterState.ArgLocalIsAlive (arglocj.ArgLocal' arglocj.Index)) {  								// stloc.n; ldloc.n (where local n is dead) ==> <empty>  								// starg.n; ldarg.n (where arg n is dead) ==> <empty>   								lookahead.RemoveAt (0);  								lookahead.RemoveAt (0);  								Trace (0' argloci' arglocj);  								rewritten = true;  							}  						}  					}  				}  			}  		}  		else if (i.Flavor == InstructionFlavor.LdInt32) {  			var ldinti = (LdInt32Instruction)i;  			if (ldinti.Value == 0) {  				if (EnsureLookahead (2)) {  					var j = lookahead [1];  					if (j.Flavor == InstructionFlavor.Compare) {  						var compj = (CompareInstruction)j;  						if (compj.Op == CompareOp.Cgt && compj.IsUnsigned) {  							// ldc.i4 0; cgt.u => ctrue  							lookahead.RemoveAt (0);  							lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CtruePseudo' false) {  								Type = compj.Type'  								BeforeState = ldinti.BeforeState'  								AfterState = compj.AfterState  							};  							Trace (1' ldinti' compj);  							rewritten = true;  						}  						else if (compj.Op == CompareOp.Ceq) {  							// ldc.i4 0; ceq => cfalse  							lookahead.RemoveAt (0);  							lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CfalsePseudo' false) {  								Type = compj.Type'  								BeforeState = ldinti.BeforeState'  								AfterState = compj.AfterState  							};  							Trace (1' ldinti' compj);  							rewritten = true;  						}  					}  				}  			}  		}  		else if (i.Flavor == InstructionFlavor.Misc) {  			var misci = (MiscInstruction)i;  			if (misci.Op == MiscOp.Nop) {  				// nop ==> <empty>  				lookahead.RemoveAt (0);  				Trace (0' misci);  				rewritten = true;  			}  			else if (misci.Op == MiscOp.Ldnull) {  				if (EnsureLookahead (2)) {  					var j = lookahead [1];  					if (j.Flavor == InstructionFlavor.Compare) {  						var compj = (CompareInstruction)j;  						if (compj.Op == CompareOp.Cgt) {  							// ldnull; cgt => ctrue  							lookahead.RemoveAt (0);  							lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CtruePseudo' false) {  								Type = compj.Type'  								BeforeState = misci.BeforeState'  								AfterState = compj.AfterState  							};  							Trace (1' misci' compj);  							rewritten = true;  						}  						else if (compj.Op == CompareOp.Ceq) {  							// ldnull; ceq => cfalse  							lookahead.RemoveAt (0);  							lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CfalsePseudo' false) {  								Type = compj.Type'  								BeforeState = misci.BeforeState'  								AfterState = compj.AfterState  							};  							Trace (1' misci' compj);  							rewritten = true;  						}  					}  				}  			}  			else if (misci.Op == MiscOp.Dup) {  				if (EnsureLookahead (2)) {  					var j = lookahead [1];  					if (j.Flavor == InstructionFlavor.Misc) {  						var miscj = (MiscInstruction)j;  						if (miscj.Op == MiscOp.Pop) {  							// dup; pop ==> <empty>  							lookahead.RemoveAt (0);  							lookahead.RemoveAt (0);  							Trace (0' misci' miscj);  							rewritten = true;  						}  					}  				}  			}  		}  	}  }  while (rewritten);  
Magic Number,Microsoft.LiveLabs.CST,Peephole,C:\repos\Reactive-Extensions_IL2JS\CST\Peephole.cs,MoveNext,The following statement contains a magic number: do {  	rewritten = false;  	if (EnsureLookahead (1)) {  		var i = lookahead [0];  		if (i.Flavor == InstructionFlavor.ArgLocal) {  			var argloci = (ArgLocalInstruction)i;  			if (argloci.Op == ArgLocalOp.St) {  				if (!argloci.AfterState.ArgLocalIsAlive (argloci.ArgLocal' argloci.Index)) {  					// starg.n (where arg n is dead) ==> pop  					// stloc.n (where local n is dead) ==> pop  					lookahead [0] = new MiscInstruction (argloci.Offset' MiscOp.Pop) {  						BeforeState = argloci.BeforeState'  						AfterState = argloci.AfterState  					};  					Trace (1' argloci);  					rewritten = true;  				}  				else if (EnsureLookahead (2)) {  					var j = lookahead [1];  					if (j.Flavor == InstructionFlavor.ArgLocal) {  						var arglocj = (ArgLocalInstruction)j;  						if (arglocj.Op == ArgLocalOp.Ld && argloci.ArgLocal == arglocj.ArgLocal && argloci.Index == arglocj.Index) {  							if (!arglocj.AfterState.ArgLocalIsAlive (arglocj.ArgLocal' arglocj.Index)) {  								// stloc.n; ldloc.n (where local n is dead) ==> <empty>  								// starg.n; ldarg.n (where arg n is dead) ==> <empty>   								lookahead.RemoveAt (0);  								lookahead.RemoveAt (0);  								Trace (0' argloci' arglocj);  								rewritten = true;  							}  						}  					}  				}  			}  		}  		else if (i.Flavor == InstructionFlavor.LdInt32) {  			var ldinti = (LdInt32Instruction)i;  			if (ldinti.Value == 0) {  				if (EnsureLookahead (2)) {  					var j = lookahead [1];  					if (j.Flavor == InstructionFlavor.Compare) {  						var compj = (CompareInstruction)j;  						if (compj.Op == CompareOp.Cgt && compj.IsUnsigned) {  							// ldc.i4 0; cgt.u => ctrue  							lookahead.RemoveAt (0);  							lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CtruePseudo' false) {  								Type = compj.Type'  								BeforeState = ldinti.BeforeState'  								AfterState = compj.AfterState  							};  							Trace (1' ldinti' compj);  							rewritten = true;  						}  						else if (compj.Op == CompareOp.Ceq) {  							// ldc.i4 0; ceq => cfalse  							lookahead.RemoveAt (0);  							lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CfalsePseudo' false) {  								Type = compj.Type'  								BeforeState = ldinti.BeforeState'  								AfterState = compj.AfterState  							};  							Trace (1' ldinti' compj);  							rewritten = true;  						}  					}  				}  			}  		}  		else if (i.Flavor == InstructionFlavor.Misc) {  			var misci = (MiscInstruction)i;  			if (misci.Op == MiscOp.Nop) {  				// nop ==> <empty>  				lookahead.RemoveAt (0);  				Trace (0' misci);  				rewritten = true;  			}  			else if (misci.Op == MiscOp.Ldnull) {  				if (EnsureLookahead (2)) {  					var j = lookahead [1];  					if (j.Flavor == InstructionFlavor.Compare) {  						var compj = (CompareInstruction)j;  						if (compj.Op == CompareOp.Cgt) {  							// ldnull; cgt => ctrue  							lookahead.RemoveAt (0);  							lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CtruePseudo' false) {  								Type = compj.Type'  								BeforeState = misci.BeforeState'  								AfterState = compj.AfterState  							};  							Trace (1' misci' compj);  							rewritten = true;  						}  						else if (compj.Op == CompareOp.Ceq) {  							// ldnull; ceq => cfalse  							lookahead.RemoveAt (0);  							lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CfalsePseudo' false) {  								Type = compj.Type'  								BeforeState = misci.BeforeState'  								AfterState = compj.AfterState  							};  							Trace (1' misci' compj);  							rewritten = true;  						}  					}  				}  			}  			else if (misci.Op == MiscOp.Dup) {  				if (EnsureLookahead (2)) {  					var j = lookahead [1];  					if (j.Flavor == InstructionFlavor.Misc) {  						var miscj = (MiscInstruction)j;  						if (miscj.Op == MiscOp.Pop) {  							// dup; pop ==> <empty>  							lookahead.RemoveAt (0);  							lookahead.RemoveAt (0);  							Trace (0' misci' miscj);  							rewritten = true;  						}  					}  				}  			}  		}  	}  }  while (rewritten);  
Magic Number,Microsoft.LiveLabs.CST,Peephole,C:\repos\Reactive-Extensions_IL2JS\CST\Peephole.cs,MoveNext,The following statement contains a magic number: do {  	rewritten = false;  	if (EnsureLookahead (1)) {  		var i = lookahead [0];  		if (i.Flavor == InstructionFlavor.ArgLocal) {  			var argloci = (ArgLocalInstruction)i;  			if (argloci.Op == ArgLocalOp.St) {  				if (!argloci.AfterState.ArgLocalIsAlive (argloci.ArgLocal' argloci.Index)) {  					// starg.n (where arg n is dead) ==> pop  					// stloc.n (where local n is dead) ==> pop  					lookahead [0] = new MiscInstruction (argloci.Offset' MiscOp.Pop) {  						BeforeState = argloci.BeforeState'  						AfterState = argloci.AfterState  					};  					Trace (1' argloci);  					rewritten = true;  				}  				else if (EnsureLookahead (2)) {  					var j = lookahead [1];  					if (j.Flavor == InstructionFlavor.ArgLocal) {  						var arglocj = (ArgLocalInstruction)j;  						if (arglocj.Op == ArgLocalOp.Ld && argloci.ArgLocal == arglocj.ArgLocal && argloci.Index == arglocj.Index) {  							if (!arglocj.AfterState.ArgLocalIsAlive (arglocj.ArgLocal' arglocj.Index)) {  								// stloc.n; ldloc.n (where local n is dead) ==> <empty>  								// starg.n; ldarg.n (where arg n is dead) ==> <empty>   								lookahead.RemoveAt (0);  								lookahead.RemoveAt (0);  								Trace (0' argloci' arglocj);  								rewritten = true;  							}  						}  					}  				}  			}  		}  		else if (i.Flavor == InstructionFlavor.LdInt32) {  			var ldinti = (LdInt32Instruction)i;  			if (ldinti.Value == 0) {  				if (EnsureLookahead (2)) {  					var j = lookahead [1];  					if (j.Flavor == InstructionFlavor.Compare) {  						var compj = (CompareInstruction)j;  						if (compj.Op == CompareOp.Cgt && compj.IsUnsigned) {  							// ldc.i4 0; cgt.u => ctrue  							lookahead.RemoveAt (0);  							lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CtruePseudo' false) {  								Type = compj.Type'  								BeforeState = ldinti.BeforeState'  								AfterState = compj.AfterState  							};  							Trace (1' ldinti' compj);  							rewritten = true;  						}  						else if (compj.Op == CompareOp.Ceq) {  							// ldc.i4 0; ceq => cfalse  							lookahead.RemoveAt (0);  							lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CfalsePseudo' false) {  								Type = compj.Type'  								BeforeState = ldinti.BeforeState'  								AfterState = compj.AfterState  							};  							Trace (1' ldinti' compj);  							rewritten = true;  						}  					}  				}  			}  		}  		else if (i.Flavor == InstructionFlavor.Misc) {  			var misci = (MiscInstruction)i;  			if (misci.Op == MiscOp.Nop) {  				// nop ==> <empty>  				lookahead.RemoveAt (0);  				Trace (0' misci);  				rewritten = true;  			}  			else if (misci.Op == MiscOp.Ldnull) {  				if (EnsureLookahead (2)) {  					var j = lookahead [1];  					if (j.Flavor == InstructionFlavor.Compare) {  						var compj = (CompareInstruction)j;  						if (compj.Op == CompareOp.Cgt) {  							// ldnull; cgt => ctrue  							lookahead.RemoveAt (0);  							lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CtruePseudo' false) {  								Type = compj.Type'  								BeforeState = misci.BeforeState'  								AfterState = compj.AfterState  							};  							Trace (1' misci' compj);  							rewritten = true;  						}  						else if (compj.Op == CompareOp.Ceq) {  							// ldnull; ceq => cfalse  							lookahead.RemoveAt (0);  							lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CfalsePseudo' false) {  								Type = compj.Type'  								BeforeState = misci.BeforeState'  								AfterState = compj.AfterState  							};  							Trace (1' misci' compj);  							rewritten = true;  						}  					}  				}  			}  			else if (misci.Op == MiscOp.Dup) {  				if (EnsureLookahead (2)) {  					var j = lookahead [1];  					if (j.Flavor == InstructionFlavor.Misc) {  						var miscj = (MiscInstruction)j;  						if (miscj.Op == MiscOp.Pop) {  							// dup; pop ==> <empty>  							lookahead.RemoveAt (0);  							lookahead.RemoveAt (0);  							Trace (0' misci' miscj);  							rewritten = true;  						}  					}  				}  			}  		}  	}  }  while (rewritten);  
Magic Number,Microsoft.LiveLabs.CST,Peephole,C:\repos\Reactive-Extensions_IL2JS\CST\Peephole.cs,MoveNext,The following statement contains a magic number: if (EnsureLookahead (1)) {  	var i = lookahead [0];  	if (i.Flavor == InstructionFlavor.ArgLocal) {  		var argloci = (ArgLocalInstruction)i;  		if (argloci.Op == ArgLocalOp.St) {  			if (!argloci.AfterState.ArgLocalIsAlive (argloci.ArgLocal' argloci.Index)) {  				// starg.n (where arg n is dead) ==> pop  				// stloc.n (where local n is dead) ==> pop  				lookahead [0] = new MiscInstruction (argloci.Offset' MiscOp.Pop) {  					BeforeState = argloci.BeforeState'  					AfterState = argloci.AfterState  				};  				Trace (1' argloci);  				rewritten = true;  			}  			else if (EnsureLookahead (2)) {  				var j = lookahead [1];  				if (j.Flavor == InstructionFlavor.ArgLocal) {  					var arglocj = (ArgLocalInstruction)j;  					if (arglocj.Op == ArgLocalOp.Ld && argloci.ArgLocal == arglocj.ArgLocal && argloci.Index == arglocj.Index) {  						if (!arglocj.AfterState.ArgLocalIsAlive (arglocj.ArgLocal' arglocj.Index)) {  							// stloc.n; ldloc.n (where local n is dead) ==> <empty>  							// starg.n; ldarg.n (where arg n is dead) ==> <empty>   							lookahead.RemoveAt (0);  							lookahead.RemoveAt (0);  							Trace (0' argloci' arglocj);  							rewritten = true;  						}  					}  				}  			}  		}  	}  	else if (i.Flavor == InstructionFlavor.LdInt32) {  		var ldinti = (LdInt32Instruction)i;  		if (ldinti.Value == 0) {  			if (EnsureLookahead (2)) {  				var j = lookahead [1];  				if (j.Flavor == InstructionFlavor.Compare) {  					var compj = (CompareInstruction)j;  					if (compj.Op == CompareOp.Cgt && compj.IsUnsigned) {  						// ldc.i4 0; cgt.u => ctrue  						lookahead.RemoveAt (0);  						lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CtruePseudo' false) {  							Type = compj.Type'  							BeforeState = ldinti.BeforeState'  							AfterState = compj.AfterState  						};  						Trace (1' ldinti' compj);  						rewritten = true;  					}  					else if (compj.Op == CompareOp.Ceq) {  						// ldc.i4 0; ceq => cfalse  						lookahead.RemoveAt (0);  						lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CfalsePseudo' false) {  							Type = compj.Type'  							BeforeState = ldinti.BeforeState'  							AfterState = compj.AfterState  						};  						Trace (1' ldinti' compj);  						rewritten = true;  					}  				}  			}  		}  	}  	else if (i.Flavor == InstructionFlavor.Misc) {  		var misci = (MiscInstruction)i;  		if (misci.Op == MiscOp.Nop) {  			// nop ==> <empty>  			lookahead.RemoveAt (0);  			Trace (0' misci);  			rewritten = true;  		}  		else if (misci.Op == MiscOp.Ldnull) {  			if (EnsureLookahead (2)) {  				var j = lookahead [1];  				if (j.Flavor == InstructionFlavor.Compare) {  					var compj = (CompareInstruction)j;  					if (compj.Op == CompareOp.Cgt) {  						// ldnull; cgt => ctrue  						lookahead.RemoveAt (0);  						lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CtruePseudo' false) {  							Type = compj.Type'  							BeforeState = misci.BeforeState'  							AfterState = compj.AfterState  						};  						Trace (1' misci' compj);  						rewritten = true;  					}  					else if (compj.Op == CompareOp.Ceq) {  						// ldnull; ceq => cfalse  						lookahead.RemoveAt (0);  						lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CfalsePseudo' false) {  							Type = compj.Type'  							BeforeState = misci.BeforeState'  							AfterState = compj.AfterState  						};  						Trace (1' misci' compj);  						rewritten = true;  					}  				}  			}  		}  		else if (misci.Op == MiscOp.Dup) {  			if (EnsureLookahead (2)) {  				var j = lookahead [1];  				if (j.Flavor == InstructionFlavor.Misc) {  					var miscj = (MiscInstruction)j;  					if (miscj.Op == MiscOp.Pop) {  						// dup; pop ==> <empty>  						lookahead.RemoveAt (0);  						lookahead.RemoveAt (0);  						Trace (0' misci' miscj);  						rewritten = true;  					}  				}  			}  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,Peephole,C:\repos\Reactive-Extensions_IL2JS\CST\Peephole.cs,MoveNext,The following statement contains a magic number: if (EnsureLookahead (1)) {  	var i = lookahead [0];  	if (i.Flavor == InstructionFlavor.ArgLocal) {  		var argloci = (ArgLocalInstruction)i;  		if (argloci.Op == ArgLocalOp.St) {  			if (!argloci.AfterState.ArgLocalIsAlive (argloci.ArgLocal' argloci.Index)) {  				// starg.n (where arg n is dead) ==> pop  				// stloc.n (where local n is dead) ==> pop  				lookahead [0] = new MiscInstruction (argloci.Offset' MiscOp.Pop) {  					BeforeState = argloci.BeforeState'  					AfterState = argloci.AfterState  				};  				Trace (1' argloci);  				rewritten = true;  			}  			else if (EnsureLookahead (2)) {  				var j = lookahead [1];  				if (j.Flavor == InstructionFlavor.ArgLocal) {  					var arglocj = (ArgLocalInstruction)j;  					if (arglocj.Op == ArgLocalOp.Ld && argloci.ArgLocal == arglocj.ArgLocal && argloci.Index == arglocj.Index) {  						if (!arglocj.AfterState.ArgLocalIsAlive (arglocj.ArgLocal' arglocj.Index)) {  							// stloc.n; ldloc.n (where local n is dead) ==> <empty>  							// starg.n; ldarg.n (where arg n is dead) ==> <empty>   							lookahead.RemoveAt (0);  							lookahead.RemoveAt (0);  							Trace (0' argloci' arglocj);  							rewritten = true;  						}  					}  				}  			}  		}  	}  	else if (i.Flavor == InstructionFlavor.LdInt32) {  		var ldinti = (LdInt32Instruction)i;  		if (ldinti.Value == 0) {  			if (EnsureLookahead (2)) {  				var j = lookahead [1];  				if (j.Flavor == InstructionFlavor.Compare) {  					var compj = (CompareInstruction)j;  					if (compj.Op == CompareOp.Cgt && compj.IsUnsigned) {  						// ldc.i4 0; cgt.u => ctrue  						lookahead.RemoveAt (0);  						lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CtruePseudo' false) {  							Type = compj.Type'  							BeforeState = ldinti.BeforeState'  							AfterState = compj.AfterState  						};  						Trace (1' ldinti' compj);  						rewritten = true;  					}  					else if (compj.Op == CompareOp.Ceq) {  						// ldc.i4 0; ceq => cfalse  						lookahead.RemoveAt (0);  						lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CfalsePseudo' false) {  							Type = compj.Type'  							BeforeState = ldinti.BeforeState'  							AfterState = compj.AfterState  						};  						Trace (1' ldinti' compj);  						rewritten = true;  					}  				}  			}  		}  	}  	else if (i.Flavor == InstructionFlavor.Misc) {  		var misci = (MiscInstruction)i;  		if (misci.Op == MiscOp.Nop) {  			// nop ==> <empty>  			lookahead.RemoveAt (0);  			Trace (0' misci);  			rewritten = true;  		}  		else if (misci.Op == MiscOp.Ldnull) {  			if (EnsureLookahead (2)) {  				var j = lookahead [1];  				if (j.Flavor == InstructionFlavor.Compare) {  					var compj = (CompareInstruction)j;  					if (compj.Op == CompareOp.Cgt) {  						// ldnull; cgt => ctrue  						lookahead.RemoveAt (0);  						lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CtruePseudo' false) {  							Type = compj.Type'  							BeforeState = misci.BeforeState'  							AfterState = compj.AfterState  						};  						Trace (1' misci' compj);  						rewritten = true;  					}  					else if (compj.Op == CompareOp.Ceq) {  						// ldnull; ceq => cfalse  						lookahead.RemoveAt (0);  						lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CfalsePseudo' false) {  							Type = compj.Type'  							BeforeState = misci.BeforeState'  							AfterState = compj.AfterState  						};  						Trace (1' misci' compj);  						rewritten = true;  					}  				}  			}  		}  		else if (misci.Op == MiscOp.Dup) {  			if (EnsureLookahead (2)) {  				var j = lookahead [1];  				if (j.Flavor == InstructionFlavor.Misc) {  					var miscj = (MiscInstruction)j;  					if (miscj.Op == MiscOp.Pop) {  						// dup; pop ==> <empty>  						lookahead.RemoveAt (0);  						lookahead.RemoveAt (0);  						Trace (0' misci' miscj);  						rewritten = true;  					}  				}  			}  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,Peephole,C:\repos\Reactive-Extensions_IL2JS\CST\Peephole.cs,MoveNext,The following statement contains a magic number: if (EnsureLookahead (1)) {  	var i = lookahead [0];  	if (i.Flavor == InstructionFlavor.ArgLocal) {  		var argloci = (ArgLocalInstruction)i;  		if (argloci.Op == ArgLocalOp.St) {  			if (!argloci.AfterState.ArgLocalIsAlive (argloci.ArgLocal' argloci.Index)) {  				// starg.n (where arg n is dead) ==> pop  				// stloc.n (where local n is dead) ==> pop  				lookahead [0] = new MiscInstruction (argloci.Offset' MiscOp.Pop) {  					BeforeState = argloci.BeforeState'  					AfterState = argloci.AfterState  				};  				Trace (1' argloci);  				rewritten = true;  			}  			else if (EnsureLookahead (2)) {  				var j = lookahead [1];  				if (j.Flavor == InstructionFlavor.ArgLocal) {  					var arglocj = (ArgLocalInstruction)j;  					if (arglocj.Op == ArgLocalOp.Ld && argloci.ArgLocal == arglocj.ArgLocal && argloci.Index == arglocj.Index) {  						if (!arglocj.AfterState.ArgLocalIsAlive (arglocj.ArgLocal' arglocj.Index)) {  							// stloc.n; ldloc.n (where local n is dead) ==> <empty>  							// starg.n; ldarg.n (where arg n is dead) ==> <empty>   							lookahead.RemoveAt (0);  							lookahead.RemoveAt (0);  							Trace (0' argloci' arglocj);  							rewritten = true;  						}  					}  				}  			}  		}  	}  	else if (i.Flavor == InstructionFlavor.LdInt32) {  		var ldinti = (LdInt32Instruction)i;  		if (ldinti.Value == 0) {  			if (EnsureLookahead (2)) {  				var j = lookahead [1];  				if (j.Flavor == InstructionFlavor.Compare) {  					var compj = (CompareInstruction)j;  					if (compj.Op == CompareOp.Cgt && compj.IsUnsigned) {  						// ldc.i4 0; cgt.u => ctrue  						lookahead.RemoveAt (0);  						lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CtruePseudo' false) {  							Type = compj.Type'  							BeforeState = ldinti.BeforeState'  							AfterState = compj.AfterState  						};  						Trace (1' ldinti' compj);  						rewritten = true;  					}  					else if (compj.Op == CompareOp.Ceq) {  						// ldc.i4 0; ceq => cfalse  						lookahead.RemoveAt (0);  						lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CfalsePseudo' false) {  							Type = compj.Type'  							BeforeState = ldinti.BeforeState'  							AfterState = compj.AfterState  						};  						Trace (1' ldinti' compj);  						rewritten = true;  					}  				}  			}  		}  	}  	else if (i.Flavor == InstructionFlavor.Misc) {  		var misci = (MiscInstruction)i;  		if (misci.Op == MiscOp.Nop) {  			// nop ==> <empty>  			lookahead.RemoveAt (0);  			Trace (0' misci);  			rewritten = true;  		}  		else if (misci.Op == MiscOp.Ldnull) {  			if (EnsureLookahead (2)) {  				var j = lookahead [1];  				if (j.Flavor == InstructionFlavor.Compare) {  					var compj = (CompareInstruction)j;  					if (compj.Op == CompareOp.Cgt) {  						// ldnull; cgt => ctrue  						lookahead.RemoveAt (0);  						lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CtruePseudo' false) {  							Type = compj.Type'  							BeforeState = misci.BeforeState'  							AfterState = compj.AfterState  						};  						Trace (1' misci' compj);  						rewritten = true;  					}  					else if (compj.Op == CompareOp.Ceq) {  						// ldnull; ceq => cfalse  						lookahead.RemoveAt (0);  						lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CfalsePseudo' false) {  							Type = compj.Type'  							BeforeState = misci.BeforeState'  							AfterState = compj.AfterState  						};  						Trace (1' misci' compj);  						rewritten = true;  					}  				}  			}  		}  		else if (misci.Op == MiscOp.Dup) {  			if (EnsureLookahead (2)) {  				var j = lookahead [1];  				if (j.Flavor == InstructionFlavor.Misc) {  					var miscj = (MiscInstruction)j;  					if (miscj.Op == MiscOp.Pop) {  						// dup; pop ==> <empty>  						lookahead.RemoveAt (0);  						lookahead.RemoveAt (0);  						Trace (0' misci' miscj);  						rewritten = true;  					}  				}  			}  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,Peephole,C:\repos\Reactive-Extensions_IL2JS\CST\Peephole.cs,MoveNext,The following statement contains a magic number: if (EnsureLookahead (1)) {  	var i = lookahead [0];  	if (i.Flavor == InstructionFlavor.ArgLocal) {  		var argloci = (ArgLocalInstruction)i;  		if (argloci.Op == ArgLocalOp.St) {  			if (!argloci.AfterState.ArgLocalIsAlive (argloci.ArgLocal' argloci.Index)) {  				// starg.n (where arg n is dead) ==> pop  				// stloc.n (where local n is dead) ==> pop  				lookahead [0] = new MiscInstruction (argloci.Offset' MiscOp.Pop) {  					BeforeState = argloci.BeforeState'  					AfterState = argloci.AfterState  				};  				Trace (1' argloci);  				rewritten = true;  			}  			else if (EnsureLookahead (2)) {  				var j = lookahead [1];  				if (j.Flavor == InstructionFlavor.ArgLocal) {  					var arglocj = (ArgLocalInstruction)j;  					if (arglocj.Op == ArgLocalOp.Ld && argloci.ArgLocal == arglocj.ArgLocal && argloci.Index == arglocj.Index) {  						if (!arglocj.AfterState.ArgLocalIsAlive (arglocj.ArgLocal' arglocj.Index)) {  							// stloc.n; ldloc.n (where local n is dead) ==> <empty>  							// starg.n; ldarg.n (where arg n is dead) ==> <empty>   							lookahead.RemoveAt (0);  							lookahead.RemoveAt (0);  							Trace (0' argloci' arglocj);  							rewritten = true;  						}  					}  				}  			}  		}  	}  	else if (i.Flavor == InstructionFlavor.LdInt32) {  		var ldinti = (LdInt32Instruction)i;  		if (ldinti.Value == 0) {  			if (EnsureLookahead (2)) {  				var j = lookahead [1];  				if (j.Flavor == InstructionFlavor.Compare) {  					var compj = (CompareInstruction)j;  					if (compj.Op == CompareOp.Cgt && compj.IsUnsigned) {  						// ldc.i4 0; cgt.u => ctrue  						lookahead.RemoveAt (0);  						lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CtruePseudo' false) {  							Type = compj.Type'  							BeforeState = ldinti.BeforeState'  							AfterState = compj.AfterState  						};  						Trace (1' ldinti' compj);  						rewritten = true;  					}  					else if (compj.Op == CompareOp.Ceq) {  						// ldc.i4 0; ceq => cfalse  						lookahead.RemoveAt (0);  						lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CfalsePseudo' false) {  							Type = compj.Type'  							BeforeState = ldinti.BeforeState'  							AfterState = compj.AfterState  						};  						Trace (1' ldinti' compj);  						rewritten = true;  					}  				}  			}  		}  	}  	else if (i.Flavor == InstructionFlavor.Misc) {  		var misci = (MiscInstruction)i;  		if (misci.Op == MiscOp.Nop) {  			// nop ==> <empty>  			lookahead.RemoveAt (0);  			Trace (0' misci);  			rewritten = true;  		}  		else if (misci.Op == MiscOp.Ldnull) {  			if (EnsureLookahead (2)) {  				var j = lookahead [1];  				if (j.Flavor == InstructionFlavor.Compare) {  					var compj = (CompareInstruction)j;  					if (compj.Op == CompareOp.Cgt) {  						// ldnull; cgt => ctrue  						lookahead.RemoveAt (0);  						lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CtruePseudo' false) {  							Type = compj.Type'  							BeforeState = misci.BeforeState'  							AfterState = compj.AfterState  						};  						Trace (1' misci' compj);  						rewritten = true;  					}  					else if (compj.Op == CompareOp.Ceq) {  						// ldnull; ceq => cfalse  						lookahead.RemoveAt (0);  						lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CfalsePseudo' false) {  							Type = compj.Type'  							BeforeState = misci.BeforeState'  							AfterState = compj.AfterState  						};  						Trace (1' misci' compj);  						rewritten = true;  					}  				}  			}  		}  		else if (misci.Op == MiscOp.Dup) {  			if (EnsureLookahead (2)) {  				var j = lookahead [1];  				if (j.Flavor == InstructionFlavor.Misc) {  					var miscj = (MiscInstruction)j;  					if (miscj.Op == MiscOp.Pop) {  						// dup; pop ==> <empty>  						lookahead.RemoveAt (0);  						lookahead.RemoveAt (0);  						Trace (0' misci' miscj);  						rewritten = true;  					}  				}  			}  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,Peephole,C:\repos\Reactive-Extensions_IL2JS\CST\Peephole.cs,MoveNext,The following statement contains a magic number: if (i.Flavor == InstructionFlavor.ArgLocal) {  	var argloci = (ArgLocalInstruction)i;  	if (argloci.Op == ArgLocalOp.St) {  		if (!argloci.AfterState.ArgLocalIsAlive (argloci.ArgLocal' argloci.Index)) {  			// starg.n (where arg n is dead) ==> pop  			// stloc.n (where local n is dead) ==> pop  			lookahead [0] = new MiscInstruction (argloci.Offset' MiscOp.Pop) {  				BeforeState = argloci.BeforeState'  				AfterState = argloci.AfterState  			};  			Trace (1' argloci);  			rewritten = true;  		}  		else if (EnsureLookahead (2)) {  			var j = lookahead [1];  			if (j.Flavor == InstructionFlavor.ArgLocal) {  				var arglocj = (ArgLocalInstruction)j;  				if (arglocj.Op == ArgLocalOp.Ld && argloci.ArgLocal == arglocj.ArgLocal && argloci.Index == arglocj.Index) {  					if (!arglocj.AfterState.ArgLocalIsAlive (arglocj.ArgLocal' arglocj.Index)) {  						// stloc.n; ldloc.n (where local n is dead) ==> <empty>  						// starg.n; ldarg.n (where arg n is dead) ==> <empty>   						lookahead.RemoveAt (0);  						lookahead.RemoveAt (0);  						Trace (0' argloci' arglocj);  						rewritten = true;  					}  				}  			}  		}  	}  }  else if (i.Flavor == InstructionFlavor.LdInt32) {  	var ldinti = (LdInt32Instruction)i;  	if (ldinti.Value == 0) {  		if (EnsureLookahead (2)) {  			var j = lookahead [1];  			if (j.Flavor == InstructionFlavor.Compare) {  				var compj = (CompareInstruction)j;  				if (compj.Op == CompareOp.Cgt && compj.IsUnsigned) {  					// ldc.i4 0; cgt.u => ctrue  					lookahead.RemoveAt (0);  					lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CtruePseudo' false) {  						Type = compj.Type'  						BeforeState = ldinti.BeforeState'  						AfterState = compj.AfterState  					};  					Trace (1' ldinti' compj);  					rewritten = true;  				}  				else if (compj.Op == CompareOp.Ceq) {  					// ldc.i4 0; ceq => cfalse  					lookahead.RemoveAt (0);  					lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CfalsePseudo' false) {  						Type = compj.Type'  						BeforeState = ldinti.BeforeState'  						AfterState = compj.AfterState  					};  					Trace (1' ldinti' compj);  					rewritten = true;  				}  			}  		}  	}  }  else if (i.Flavor == InstructionFlavor.Misc) {  	var misci = (MiscInstruction)i;  	if (misci.Op == MiscOp.Nop) {  		// nop ==> <empty>  		lookahead.RemoveAt (0);  		Trace (0' misci);  		rewritten = true;  	}  	else if (misci.Op == MiscOp.Ldnull) {  		if (EnsureLookahead (2)) {  			var j = lookahead [1];  			if (j.Flavor == InstructionFlavor.Compare) {  				var compj = (CompareInstruction)j;  				if (compj.Op == CompareOp.Cgt) {  					// ldnull; cgt => ctrue  					lookahead.RemoveAt (0);  					lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CtruePseudo' false) {  						Type = compj.Type'  						BeforeState = misci.BeforeState'  						AfterState = compj.AfterState  					};  					Trace (1' misci' compj);  					rewritten = true;  				}  				else if (compj.Op == CompareOp.Ceq) {  					// ldnull; ceq => cfalse  					lookahead.RemoveAt (0);  					lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CfalsePseudo' false) {  						Type = compj.Type'  						BeforeState = misci.BeforeState'  						AfterState = compj.AfterState  					};  					Trace (1' misci' compj);  					rewritten = true;  				}  			}  		}  	}  	else if (misci.Op == MiscOp.Dup) {  		if (EnsureLookahead (2)) {  			var j = lookahead [1];  			if (j.Flavor == InstructionFlavor.Misc) {  				var miscj = (MiscInstruction)j;  				if (miscj.Op == MiscOp.Pop) {  					// dup; pop ==> <empty>  					lookahead.RemoveAt (0);  					lookahead.RemoveAt (0);  					Trace (0' misci' miscj);  					rewritten = true;  				}  			}  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,Peephole,C:\repos\Reactive-Extensions_IL2JS\CST\Peephole.cs,MoveNext,The following statement contains a magic number: if (i.Flavor == InstructionFlavor.ArgLocal) {  	var argloci = (ArgLocalInstruction)i;  	if (argloci.Op == ArgLocalOp.St) {  		if (!argloci.AfterState.ArgLocalIsAlive (argloci.ArgLocal' argloci.Index)) {  			// starg.n (where arg n is dead) ==> pop  			// stloc.n (where local n is dead) ==> pop  			lookahead [0] = new MiscInstruction (argloci.Offset' MiscOp.Pop) {  				BeforeState = argloci.BeforeState'  				AfterState = argloci.AfterState  			};  			Trace (1' argloci);  			rewritten = true;  		}  		else if (EnsureLookahead (2)) {  			var j = lookahead [1];  			if (j.Flavor == InstructionFlavor.ArgLocal) {  				var arglocj = (ArgLocalInstruction)j;  				if (arglocj.Op == ArgLocalOp.Ld && argloci.ArgLocal == arglocj.ArgLocal && argloci.Index == arglocj.Index) {  					if (!arglocj.AfterState.ArgLocalIsAlive (arglocj.ArgLocal' arglocj.Index)) {  						// stloc.n; ldloc.n (where local n is dead) ==> <empty>  						// starg.n; ldarg.n (where arg n is dead) ==> <empty>   						lookahead.RemoveAt (0);  						lookahead.RemoveAt (0);  						Trace (0' argloci' arglocj);  						rewritten = true;  					}  				}  			}  		}  	}  }  else if (i.Flavor == InstructionFlavor.LdInt32) {  	var ldinti = (LdInt32Instruction)i;  	if (ldinti.Value == 0) {  		if (EnsureLookahead (2)) {  			var j = lookahead [1];  			if (j.Flavor == InstructionFlavor.Compare) {  				var compj = (CompareInstruction)j;  				if (compj.Op == CompareOp.Cgt && compj.IsUnsigned) {  					// ldc.i4 0; cgt.u => ctrue  					lookahead.RemoveAt (0);  					lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CtruePseudo' false) {  						Type = compj.Type'  						BeforeState = ldinti.BeforeState'  						AfterState = compj.AfterState  					};  					Trace (1' ldinti' compj);  					rewritten = true;  				}  				else if (compj.Op == CompareOp.Ceq) {  					// ldc.i4 0; ceq => cfalse  					lookahead.RemoveAt (0);  					lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CfalsePseudo' false) {  						Type = compj.Type'  						BeforeState = ldinti.BeforeState'  						AfterState = compj.AfterState  					};  					Trace (1' ldinti' compj);  					rewritten = true;  				}  			}  		}  	}  }  else if (i.Flavor == InstructionFlavor.Misc) {  	var misci = (MiscInstruction)i;  	if (misci.Op == MiscOp.Nop) {  		// nop ==> <empty>  		lookahead.RemoveAt (0);  		Trace (0' misci);  		rewritten = true;  	}  	else if (misci.Op == MiscOp.Ldnull) {  		if (EnsureLookahead (2)) {  			var j = lookahead [1];  			if (j.Flavor == InstructionFlavor.Compare) {  				var compj = (CompareInstruction)j;  				if (compj.Op == CompareOp.Cgt) {  					// ldnull; cgt => ctrue  					lookahead.RemoveAt (0);  					lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CtruePseudo' false) {  						Type = compj.Type'  						BeforeState = misci.BeforeState'  						AfterState = compj.AfterState  					};  					Trace (1' misci' compj);  					rewritten = true;  				}  				else if (compj.Op == CompareOp.Ceq) {  					// ldnull; ceq => cfalse  					lookahead.RemoveAt (0);  					lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CfalsePseudo' false) {  						Type = compj.Type'  						BeforeState = misci.BeforeState'  						AfterState = compj.AfterState  					};  					Trace (1' misci' compj);  					rewritten = true;  				}  			}  		}  	}  	else if (misci.Op == MiscOp.Dup) {  		if (EnsureLookahead (2)) {  			var j = lookahead [1];  			if (j.Flavor == InstructionFlavor.Misc) {  				var miscj = (MiscInstruction)j;  				if (miscj.Op == MiscOp.Pop) {  					// dup; pop ==> <empty>  					lookahead.RemoveAt (0);  					lookahead.RemoveAt (0);  					Trace (0' misci' miscj);  					rewritten = true;  				}  			}  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,Peephole,C:\repos\Reactive-Extensions_IL2JS\CST\Peephole.cs,MoveNext,The following statement contains a magic number: if (i.Flavor == InstructionFlavor.ArgLocal) {  	var argloci = (ArgLocalInstruction)i;  	if (argloci.Op == ArgLocalOp.St) {  		if (!argloci.AfterState.ArgLocalIsAlive (argloci.ArgLocal' argloci.Index)) {  			// starg.n (where arg n is dead) ==> pop  			// stloc.n (where local n is dead) ==> pop  			lookahead [0] = new MiscInstruction (argloci.Offset' MiscOp.Pop) {  				BeforeState = argloci.BeforeState'  				AfterState = argloci.AfterState  			};  			Trace (1' argloci);  			rewritten = true;  		}  		else if (EnsureLookahead (2)) {  			var j = lookahead [1];  			if (j.Flavor == InstructionFlavor.ArgLocal) {  				var arglocj = (ArgLocalInstruction)j;  				if (arglocj.Op == ArgLocalOp.Ld && argloci.ArgLocal == arglocj.ArgLocal && argloci.Index == arglocj.Index) {  					if (!arglocj.AfterState.ArgLocalIsAlive (arglocj.ArgLocal' arglocj.Index)) {  						// stloc.n; ldloc.n (where local n is dead) ==> <empty>  						// starg.n; ldarg.n (where arg n is dead) ==> <empty>   						lookahead.RemoveAt (0);  						lookahead.RemoveAt (0);  						Trace (0' argloci' arglocj);  						rewritten = true;  					}  				}  			}  		}  	}  }  else if (i.Flavor == InstructionFlavor.LdInt32) {  	var ldinti = (LdInt32Instruction)i;  	if (ldinti.Value == 0) {  		if (EnsureLookahead (2)) {  			var j = lookahead [1];  			if (j.Flavor == InstructionFlavor.Compare) {  				var compj = (CompareInstruction)j;  				if (compj.Op == CompareOp.Cgt && compj.IsUnsigned) {  					// ldc.i4 0; cgt.u => ctrue  					lookahead.RemoveAt (0);  					lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CtruePseudo' false) {  						Type = compj.Type'  						BeforeState = ldinti.BeforeState'  						AfterState = compj.AfterState  					};  					Trace (1' ldinti' compj);  					rewritten = true;  				}  				else if (compj.Op == CompareOp.Ceq) {  					// ldc.i4 0; ceq => cfalse  					lookahead.RemoveAt (0);  					lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CfalsePseudo' false) {  						Type = compj.Type'  						BeforeState = ldinti.BeforeState'  						AfterState = compj.AfterState  					};  					Trace (1' ldinti' compj);  					rewritten = true;  				}  			}  		}  	}  }  else if (i.Flavor == InstructionFlavor.Misc) {  	var misci = (MiscInstruction)i;  	if (misci.Op == MiscOp.Nop) {  		// nop ==> <empty>  		lookahead.RemoveAt (0);  		Trace (0' misci);  		rewritten = true;  	}  	else if (misci.Op == MiscOp.Ldnull) {  		if (EnsureLookahead (2)) {  			var j = lookahead [1];  			if (j.Flavor == InstructionFlavor.Compare) {  				var compj = (CompareInstruction)j;  				if (compj.Op == CompareOp.Cgt) {  					// ldnull; cgt => ctrue  					lookahead.RemoveAt (0);  					lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CtruePseudo' false) {  						Type = compj.Type'  						BeforeState = misci.BeforeState'  						AfterState = compj.AfterState  					};  					Trace (1' misci' compj);  					rewritten = true;  				}  				else if (compj.Op == CompareOp.Ceq) {  					// ldnull; ceq => cfalse  					lookahead.RemoveAt (0);  					lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CfalsePseudo' false) {  						Type = compj.Type'  						BeforeState = misci.BeforeState'  						AfterState = compj.AfterState  					};  					Trace (1' misci' compj);  					rewritten = true;  				}  			}  		}  	}  	else if (misci.Op == MiscOp.Dup) {  		if (EnsureLookahead (2)) {  			var j = lookahead [1];  			if (j.Flavor == InstructionFlavor.Misc) {  				var miscj = (MiscInstruction)j;  				if (miscj.Op == MiscOp.Pop) {  					// dup; pop ==> <empty>  					lookahead.RemoveAt (0);  					lookahead.RemoveAt (0);  					Trace (0' misci' miscj);  					rewritten = true;  				}  			}  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,Peephole,C:\repos\Reactive-Extensions_IL2JS\CST\Peephole.cs,MoveNext,The following statement contains a magic number: if (i.Flavor == InstructionFlavor.ArgLocal) {  	var argloci = (ArgLocalInstruction)i;  	if (argloci.Op == ArgLocalOp.St) {  		if (!argloci.AfterState.ArgLocalIsAlive (argloci.ArgLocal' argloci.Index)) {  			// starg.n (where arg n is dead) ==> pop  			// stloc.n (where local n is dead) ==> pop  			lookahead [0] = new MiscInstruction (argloci.Offset' MiscOp.Pop) {  				BeforeState = argloci.BeforeState'  				AfterState = argloci.AfterState  			};  			Trace (1' argloci);  			rewritten = true;  		}  		else if (EnsureLookahead (2)) {  			var j = lookahead [1];  			if (j.Flavor == InstructionFlavor.ArgLocal) {  				var arglocj = (ArgLocalInstruction)j;  				if (arglocj.Op == ArgLocalOp.Ld && argloci.ArgLocal == arglocj.ArgLocal && argloci.Index == arglocj.Index) {  					if (!arglocj.AfterState.ArgLocalIsAlive (arglocj.ArgLocal' arglocj.Index)) {  						// stloc.n; ldloc.n (where local n is dead) ==> <empty>  						// starg.n; ldarg.n (where arg n is dead) ==> <empty>   						lookahead.RemoveAt (0);  						lookahead.RemoveAt (0);  						Trace (0' argloci' arglocj);  						rewritten = true;  					}  				}  			}  		}  	}  }  else if (i.Flavor == InstructionFlavor.LdInt32) {  	var ldinti = (LdInt32Instruction)i;  	if (ldinti.Value == 0) {  		if (EnsureLookahead (2)) {  			var j = lookahead [1];  			if (j.Flavor == InstructionFlavor.Compare) {  				var compj = (CompareInstruction)j;  				if (compj.Op == CompareOp.Cgt && compj.IsUnsigned) {  					// ldc.i4 0; cgt.u => ctrue  					lookahead.RemoveAt (0);  					lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CtruePseudo' false) {  						Type = compj.Type'  						BeforeState = ldinti.BeforeState'  						AfterState = compj.AfterState  					};  					Trace (1' ldinti' compj);  					rewritten = true;  				}  				else if (compj.Op == CompareOp.Ceq) {  					// ldc.i4 0; ceq => cfalse  					lookahead.RemoveAt (0);  					lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CfalsePseudo' false) {  						Type = compj.Type'  						BeforeState = ldinti.BeforeState'  						AfterState = compj.AfterState  					};  					Trace (1' ldinti' compj);  					rewritten = true;  				}  			}  		}  	}  }  else if (i.Flavor == InstructionFlavor.Misc) {  	var misci = (MiscInstruction)i;  	if (misci.Op == MiscOp.Nop) {  		// nop ==> <empty>  		lookahead.RemoveAt (0);  		Trace (0' misci);  		rewritten = true;  	}  	else if (misci.Op == MiscOp.Ldnull) {  		if (EnsureLookahead (2)) {  			var j = lookahead [1];  			if (j.Flavor == InstructionFlavor.Compare) {  				var compj = (CompareInstruction)j;  				if (compj.Op == CompareOp.Cgt) {  					// ldnull; cgt => ctrue  					lookahead.RemoveAt (0);  					lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CtruePseudo' false) {  						Type = compj.Type'  						BeforeState = misci.BeforeState'  						AfterState = compj.AfterState  					};  					Trace (1' misci' compj);  					rewritten = true;  				}  				else if (compj.Op == CompareOp.Ceq) {  					// ldnull; ceq => cfalse  					lookahead.RemoveAt (0);  					lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CfalsePseudo' false) {  						Type = compj.Type'  						BeforeState = misci.BeforeState'  						AfterState = compj.AfterState  					};  					Trace (1' misci' compj);  					rewritten = true;  				}  			}  		}  	}  	else if (misci.Op == MiscOp.Dup) {  		if (EnsureLookahead (2)) {  			var j = lookahead [1];  			if (j.Flavor == InstructionFlavor.Misc) {  				var miscj = (MiscInstruction)j;  				if (miscj.Op == MiscOp.Pop) {  					// dup; pop ==> <empty>  					lookahead.RemoveAt (0);  					lookahead.RemoveAt (0);  					Trace (0' misci' miscj);  					rewritten = true;  				}  			}  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,Peephole,C:\repos\Reactive-Extensions_IL2JS\CST\Peephole.cs,MoveNext,The following statement contains a magic number: if (argloci.Op == ArgLocalOp.St) {  	if (!argloci.AfterState.ArgLocalIsAlive (argloci.ArgLocal' argloci.Index)) {  		// starg.n (where arg n is dead) ==> pop  		// stloc.n (where local n is dead) ==> pop  		lookahead [0] = new MiscInstruction (argloci.Offset' MiscOp.Pop) {  			BeforeState = argloci.BeforeState'  			AfterState = argloci.AfterState  		};  		Trace (1' argloci);  		rewritten = true;  	}  	else if (EnsureLookahead (2)) {  		var j = lookahead [1];  		if (j.Flavor == InstructionFlavor.ArgLocal) {  			var arglocj = (ArgLocalInstruction)j;  			if (arglocj.Op == ArgLocalOp.Ld && argloci.ArgLocal == arglocj.ArgLocal && argloci.Index == arglocj.Index) {  				if (!arglocj.AfterState.ArgLocalIsAlive (arglocj.ArgLocal' arglocj.Index)) {  					// stloc.n; ldloc.n (where local n is dead) ==> <empty>  					// starg.n; ldarg.n (where arg n is dead) ==> <empty>   					lookahead.RemoveAt (0);  					lookahead.RemoveAt (0);  					Trace (0' argloci' arglocj);  					rewritten = true;  				}  			}  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,Peephole,C:\repos\Reactive-Extensions_IL2JS\CST\Peephole.cs,MoveNext,The following statement contains a magic number: if (!argloci.AfterState.ArgLocalIsAlive (argloci.ArgLocal' argloci.Index)) {  	// starg.n (where arg n is dead) ==> pop  	// stloc.n (where local n is dead) ==> pop  	lookahead [0] = new MiscInstruction (argloci.Offset' MiscOp.Pop) {  		BeforeState = argloci.BeforeState'  		AfterState = argloci.AfterState  	};  	Trace (1' argloci);  	rewritten = true;  }  else if (EnsureLookahead (2)) {  	var j = lookahead [1];  	if (j.Flavor == InstructionFlavor.ArgLocal) {  		var arglocj = (ArgLocalInstruction)j;  		if (arglocj.Op == ArgLocalOp.Ld && argloci.ArgLocal == arglocj.ArgLocal && argloci.Index == arglocj.Index) {  			if (!arglocj.AfterState.ArgLocalIsAlive (arglocj.ArgLocal' arglocj.Index)) {  				// stloc.n; ldloc.n (where local n is dead) ==> <empty>  				// starg.n; ldarg.n (where arg n is dead) ==> <empty>   				lookahead.RemoveAt (0);  				lookahead.RemoveAt (0);  				Trace (0' argloci' arglocj);  				rewritten = true;  			}  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,Peephole,C:\repos\Reactive-Extensions_IL2JS\CST\Peephole.cs,MoveNext,The following statement contains a magic number: if (EnsureLookahead (2)) {  	var j = lookahead [1];  	if (j.Flavor == InstructionFlavor.ArgLocal) {  		var arglocj = (ArgLocalInstruction)j;  		if (arglocj.Op == ArgLocalOp.Ld && argloci.ArgLocal == arglocj.ArgLocal && argloci.Index == arglocj.Index) {  			if (!arglocj.AfterState.ArgLocalIsAlive (arglocj.ArgLocal' arglocj.Index)) {  				// stloc.n; ldloc.n (where local n is dead) ==> <empty>  				// starg.n; ldarg.n (where arg n is dead) ==> <empty>   				lookahead.RemoveAt (0);  				lookahead.RemoveAt (0);  				Trace (0' argloci' arglocj);  				rewritten = true;  			}  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,Peephole,C:\repos\Reactive-Extensions_IL2JS\CST\Peephole.cs,MoveNext,The following statement contains a magic number: if (i.Flavor == InstructionFlavor.LdInt32) {  	var ldinti = (LdInt32Instruction)i;  	if (ldinti.Value == 0) {  		if (EnsureLookahead (2)) {  			var j = lookahead [1];  			if (j.Flavor == InstructionFlavor.Compare) {  				var compj = (CompareInstruction)j;  				if (compj.Op == CompareOp.Cgt && compj.IsUnsigned) {  					// ldc.i4 0; cgt.u => ctrue  					lookahead.RemoveAt (0);  					lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CtruePseudo' false) {  						Type = compj.Type'  						BeforeState = ldinti.BeforeState'  						AfterState = compj.AfterState  					};  					Trace (1' ldinti' compj);  					rewritten = true;  				}  				else if (compj.Op == CompareOp.Ceq) {  					// ldc.i4 0; ceq => cfalse  					lookahead.RemoveAt (0);  					lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CfalsePseudo' false) {  						Type = compj.Type'  						BeforeState = ldinti.BeforeState'  						AfterState = compj.AfterState  					};  					Trace (1' ldinti' compj);  					rewritten = true;  				}  			}  		}  	}  }  else if (i.Flavor == InstructionFlavor.Misc) {  	var misci = (MiscInstruction)i;  	if (misci.Op == MiscOp.Nop) {  		// nop ==> <empty>  		lookahead.RemoveAt (0);  		Trace (0' misci);  		rewritten = true;  	}  	else if (misci.Op == MiscOp.Ldnull) {  		if (EnsureLookahead (2)) {  			var j = lookahead [1];  			if (j.Flavor == InstructionFlavor.Compare) {  				var compj = (CompareInstruction)j;  				if (compj.Op == CompareOp.Cgt) {  					// ldnull; cgt => ctrue  					lookahead.RemoveAt (0);  					lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CtruePseudo' false) {  						Type = compj.Type'  						BeforeState = misci.BeforeState'  						AfterState = compj.AfterState  					};  					Trace (1' misci' compj);  					rewritten = true;  				}  				else if (compj.Op == CompareOp.Ceq) {  					// ldnull; ceq => cfalse  					lookahead.RemoveAt (0);  					lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CfalsePseudo' false) {  						Type = compj.Type'  						BeforeState = misci.BeforeState'  						AfterState = compj.AfterState  					};  					Trace (1' misci' compj);  					rewritten = true;  				}  			}  		}  	}  	else if (misci.Op == MiscOp.Dup) {  		if (EnsureLookahead (2)) {  			var j = lookahead [1];  			if (j.Flavor == InstructionFlavor.Misc) {  				var miscj = (MiscInstruction)j;  				if (miscj.Op == MiscOp.Pop) {  					// dup; pop ==> <empty>  					lookahead.RemoveAt (0);  					lookahead.RemoveAt (0);  					Trace (0' misci' miscj);  					rewritten = true;  				}  			}  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,Peephole,C:\repos\Reactive-Extensions_IL2JS\CST\Peephole.cs,MoveNext,The following statement contains a magic number: if (i.Flavor == InstructionFlavor.LdInt32) {  	var ldinti = (LdInt32Instruction)i;  	if (ldinti.Value == 0) {  		if (EnsureLookahead (2)) {  			var j = lookahead [1];  			if (j.Flavor == InstructionFlavor.Compare) {  				var compj = (CompareInstruction)j;  				if (compj.Op == CompareOp.Cgt && compj.IsUnsigned) {  					// ldc.i4 0; cgt.u => ctrue  					lookahead.RemoveAt (0);  					lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CtruePseudo' false) {  						Type = compj.Type'  						BeforeState = ldinti.BeforeState'  						AfterState = compj.AfterState  					};  					Trace (1' ldinti' compj);  					rewritten = true;  				}  				else if (compj.Op == CompareOp.Ceq) {  					// ldc.i4 0; ceq => cfalse  					lookahead.RemoveAt (0);  					lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CfalsePseudo' false) {  						Type = compj.Type'  						BeforeState = ldinti.BeforeState'  						AfterState = compj.AfterState  					};  					Trace (1' ldinti' compj);  					rewritten = true;  				}  			}  		}  	}  }  else if (i.Flavor == InstructionFlavor.Misc) {  	var misci = (MiscInstruction)i;  	if (misci.Op == MiscOp.Nop) {  		// nop ==> <empty>  		lookahead.RemoveAt (0);  		Trace (0' misci);  		rewritten = true;  	}  	else if (misci.Op == MiscOp.Ldnull) {  		if (EnsureLookahead (2)) {  			var j = lookahead [1];  			if (j.Flavor == InstructionFlavor.Compare) {  				var compj = (CompareInstruction)j;  				if (compj.Op == CompareOp.Cgt) {  					// ldnull; cgt => ctrue  					lookahead.RemoveAt (0);  					lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CtruePseudo' false) {  						Type = compj.Type'  						BeforeState = misci.BeforeState'  						AfterState = compj.AfterState  					};  					Trace (1' misci' compj);  					rewritten = true;  				}  				else if (compj.Op == CompareOp.Ceq) {  					// ldnull; ceq => cfalse  					lookahead.RemoveAt (0);  					lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CfalsePseudo' false) {  						Type = compj.Type'  						BeforeState = misci.BeforeState'  						AfterState = compj.AfterState  					};  					Trace (1' misci' compj);  					rewritten = true;  				}  			}  		}  	}  	else if (misci.Op == MiscOp.Dup) {  		if (EnsureLookahead (2)) {  			var j = lookahead [1];  			if (j.Flavor == InstructionFlavor.Misc) {  				var miscj = (MiscInstruction)j;  				if (miscj.Op == MiscOp.Pop) {  					// dup; pop ==> <empty>  					lookahead.RemoveAt (0);  					lookahead.RemoveAt (0);  					Trace (0' misci' miscj);  					rewritten = true;  				}  			}  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,Peephole,C:\repos\Reactive-Extensions_IL2JS\CST\Peephole.cs,MoveNext,The following statement contains a magic number: if (i.Flavor == InstructionFlavor.LdInt32) {  	var ldinti = (LdInt32Instruction)i;  	if (ldinti.Value == 0) {  		if (EnsureLookahead (2)) {  			var j = lookahead [1];  			if (j.Flavor == InstructionFlavor.Compare) {  				var compj = (CompareInstruction)j;  				if (compj.Op == CompareOp.Cgt && compj.IsUnsigned) {  					// ldc.i4 0; cgt.u => ctrue  					lookahead.RemoveAt (0);  					lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CtruePseudo' false) {  						Type = compj.Type'  						BeforeState = ldinti.BeforeState'  						AfterState = compj.AfterState  					};  					Trace (1' ldinti' compj);  					rewritten = true;  				}  				else if (compj.Op == CompareOp.Ceq) {  					// ldc.i4 0; ceq => cfalse  					lookahead.RemoveAt (0);  					lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CfalsePseudo' false) {  						Type = compj.Type'  						BeforeState = ldinti.BeforeState'  						AfterState = compj.AfterState  					};  					Trace (1' ldinti' compj);  					rewritten = true;  				}  			}  		}  	}  }  else if (i.Flavor == InstructionFlavor.Misc) {  	var misci = (MiscInstruction)i;  	if (misci.Op == MiscOp.Nop) {  		// nop ==> <empty>  		lookahead.RemoveAt (0);  		Trace (0' misci);  		rewritten = true;  	}  	else if (misci.Op == MiscOp.Ldnull) {  		if (EnsureLookahead (2)) {  			var j = lookahead [1];  			if (j.Flavor == InstructionFlavor.Compare) {  				var compj = (CompareInstruction)j;  				if (compj.Op == CompareOp.Cgt) {  					// ldnull; cgt => ctrue  					lookahead.RemoveAt (0);  					lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CtruePseudo' false) {  						Type = compj.Type'  						BeforeState = misci.BeforeState'  						AfterState = compj.AfterState  					};  					Trace (1' misci' compj);  					rewritten = true;  				}  				else if (compj.Op == CompareOp.Ceq) {  					// ldnull; ceq => cfalse  					lookahead.RemoveAt (0);  					lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CfalsePseudo' false) {  						Type = compj.Type'  						BeforeState = misci.BeforeState'  						AfterState = compj.AfterState  					};  					Trace (1' misci' compj);  					rewritten = true;  				}  			}  		}  	}  	else if (misci.Op == MiscOp.Dup) {  		if (EnsureLookahead (2)) {  			var j = lookahead [1];  			if (j.Flavor == InstructionFlavor.Misc) {  				var miscj = (MiscInstruction)j;  				if (miscj.Op == MiscOp.Pop) {  					// dup; pop ==> <empty>  					lookahead.RemoveAt (0);  					lookahead.RemoveAt (0);  					Trace (0' misci' miscj);  					rewritten = true;  				}  			}  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,Peephole,C:\repos\Reactive-Extensions_IL2JS\CST\Peephole.cs,MoveNext,The following statement contains a magic number: if (ldinti.Value == 0) {  	if (EnsureLookahead (2)) {  		var j = lookahead [1];  		if (j.Flavor == InstructionFlavor.Compare) {  			var compj = (CompareInstruction)j;  			if (compj.Op == CompareOp.Cgt && compj.IsUnsigned) {  				// ldc.i4 0; cgt.u => ctrue  				lookahead.RemoveAt (0);  				lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CtruePseudo' false) {  					Type = compj.Type'  					BeforeState = ldinti.BeforeState'  					AfterState = compj.AfterState  				};  				Trace (1' ldinti' compj);  				rewritten = true;  			}  			else if (compj.Op == CompareOp.Ceq) {  				// ldc.i4 0; ceq => cfalse  				lookahead.RemoveAt (0);  				lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CfalsePseudo' false) {  					Type = compj.Type'  					BeforeState = ldinti.BeforeState'  					AfterState = compj.AfterState  				};  				Trace (1' ldinti' compj);  				rewritten = true;  			}  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,Peephole,C:\repos\Reactive-Extensions_IL2JS\CST\Peephole.cs,MoveNext,The following statement contains a magic number: if (EnsureLookahead (2)) {  	var j = lookahead [1];  	if (j.Flavor == InstructionFlavor.Compare) {  		var compj = (CompareInstruction)j;  		if (compj.Op == CompareOp.Cgt && compj.IsUnsigned) {  			// ldc.i4 0; cgt.u => ctrue  			lookahead.RemoveAt (0);  			lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CtruePseudo' false) {  				Type = compj.Type'  				BeforeState = ldinti.BeforeState'  				AfterState = compj.AfterState  			};  			Trace (1' ldinti' compj);  			rewritten = true;  		}  		else if (compj.Op == CompareOp.Ceq) {  			// ldc.i4 0; ceq => cfalse  			lookahead.RemoveAt (0);  			lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CfalsePseudo' false) {  				Type = compj.Type'  				BeforeState = ldinti.BeforeState'  				AfterState = compj.AfterState  			};  			Trace (1' ldinti' compj);  			rewritten = true;  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,Peephole,C:\repos\Reactive-Extensions_IL2JS\CST\Peephole.cs,MoveNext,The following statement contains a magic number: if (i.Flavor == InstructionFlavor.Misc) {  	var misci = (MiscInstruction)i;  	if (misci.Op == MiscOp.Nop) {  		// nop ==> <empty>  		lookahead.RemoveAt (0);  		Trace (0' misci);  		rewritten = true;  	}  	else if (misci.Op == MiscOp.Ldnull) {  		if (EnsureLookahead (2)) {  			var j = lookahead [1];  			if (j.Flavor == InstructionFlavor.Compare) {  				var compj = (CompareInstruction)j;  				if (compj.Op == CompareOp.Cgt) {  					// ldnull; cgt => ctrue  					lookahead.RemoveAt (0);  					lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CtruePseudo' false) {  						Type = compj.Type'  						BeforeState = misci.BeforeState'  						AfterState = compj.AfterState  					};  					Trace (1' misci' compj);  					rewritten = true;  				}  				else if (compj.Op == CompareOp.Ceq) {  					// ldnull; ceq => cfalse  					lookahead.RemoveAt (0);  					lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CfalsePseudo' false) {  						Type = compj.Type'  						BeforeState = misci.BeforeState'  						AfterState = compj.AfterState  					};  					Trace (1' misci' compj);  					rewritten = true;  				}  			}  		}  	}  	else if (misci.Op == MiscOp.Dup) {  		if (EnsureLookahead (2)) {  			var j = lookahead [1];  			if (j.Flavor == InstructionFlavor.Misc) {  				var miscj = (MiscInstruction)j;  				if (miscj.Op == MiscOp.Pop) {  					// dup; pop ==> <empty>  					lookahead.RemoveAt (0);  					lookahead.RemoveAt (0);  					Trace (0' misci' miscj);  					rewritten = true;  				}  			}  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,Peephole,C:\repos\Reactive-Extensions_IL2JS\CST\Peephole.cs,MoveNext,The following statement contains a magic number: if (i.Flavor == InstructionFlavor.Misc) {  	var misci = (MiscInstruction)i;  	if (misci.Op == MiscOp.Nop) {  		// nop ==> <empty>  		lookahead.RemoveAt (0);  		Trace (0' misci);  		rewritten = true;  	}  	else if (misci.Op == MiscOp.Ldnull) {  		if (EnsureLookahead (2)) {  			var j = lookahead [1];  			if (j.Flavor == InstructionFlavor.Compare) {  				var compj = (CompareInstruction)j;  				if (compj.Op == CompareOp.Cgt) {  					// ldnull; cgt => ctrue  					lookahead.RemoveAt (0);  					lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CtruePseudo' false) {  						Type = compj.Type'  						BeforeState = misci.BeforeState'  						AfterState = compj.AfterState  					};  					Trace (1' misci' compj);  					rewritten = true;  				}  				else if (compj.Op == CompareOp.Ceq) {  					// ldnull; ceq => cfalse  					lookahead.RemoveAt (0);  					lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CfalsePseudo' false) {  						Type = compj.Type'  						BeforeState = misci.BeforeState'  						AfterState = compj.AfterState  					};  					Trace (1' misci' compj);  					rewritten = true;  				}  			}  		}  	}  	else if (misci.Op == MiscOp.Dup) {  		if (EnsureLookahead (2)) {  			var j = lookahead [1];  			if (j.Flavor == InstructionFlavor.Misc) {  				var miscj = (MiscInstruction)j;  				if (miscj.Op == MiscOp.Pop) {  					// dup; pop ==> <empty>  					lookahead.RemoveAt (0);  					lookahead.RemoveAt (0);  					Trace (0' misci' miscj);  					rewritten = true;  				}  			}  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,Peephole,C:\repos\Reactive-Extensions_IL2JS\CST\Peephole.cs,MoveNext,The following statement contains a magic number: if (misci.Op == MiscOp.Nop) {  	// nop ==> <empty>  	lookahead.RemoveAt (0);  	Trace (0' misci);  	rewritten = true;  }  else if (misci.Op == MiscOp.Ldnull) {  	if (EnsureLookahead (2)) {  		var j = lookahead [1];  		if (j.Flavor == InstructionFlavor.Compare) {  			var compj = (CompareInstruction)j;  			if (compj.Op == CompareOp.Cgt) {  				// ldnull; cgt => ctrue  				lookahead.RemoveAt (0);  				lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CtruePseudo' false) {  					Type = compj.Type'  					BeforeState = misci.BeforeState'  					AfterState = compj.AfterState  				};  				Trace (1' misci' compj);  				rewritten = true;  			}  			else if (compj.Op == CompareOp.Ceq) {  				// ldnull; ceq => cfalse  				lookahead.RemoveAt (0);  				lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CfalsePseudo' false) {  					Type = compj.Type'  					BeforeState = misci.BeforeState'  					AfterState = compj.AfterState  				};  				Trace (1' misci' compj);  				rewritten = true;  			}  		}  	}  }  else if (misci.Op == MiscOp.Dup) {  	if (EnsureLookahead (2)) {  		var j = lookahead [1];  		if (j.Flavor == InstructionFlavor.Misc) {  			var miscj = (MiscInstruction)j;  			if (miscj.Op == MiscOp.Pop) {  				// dup; pop ==> <empty>  				lookahead.RemoveAt (0);  				lookahead.RemoveAt (0);  				Trace (0' misci' miscj);  				rewritten = true;  			}  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,Peephole,C:\repos\Reactive-Extensions_IL2JS\CST\Peephole.cs,MoveNext,The following statement contains a magic number: if (misci.Op == MiscOp.Nop) {  	// nop ==> <empty>  	lookahead.RemoveAt (0);  	Trace (0' misci);  	rewritten = true;  }  else if (misci.Op == MiscOp.Ldnull) {  	if (EnsureLookahead (2)) {  		var j = lookahead [1];  		if (j.Flavor == InstructionFlavor.Compare) {  			var compj = (CompareInstruction)j;  			if (compj.Op == CompareOp.Cgt) {  				// ldnull; cgt => ctrue  				lookahead.RemoveAt (0);  				lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CtruePseudo' false) {  					Type = compj.Type'  					BeforeState = misci.BeforeState'  					AfterState = compj.AfterState  				};  				Trace (1' misci' compj);  				rewritten = true;  			}  			else if (compj.Op == CompareOp.Ceq) {  				// ldnull; ceq => cfalse  				lookahead.RemoveAt (0);  				lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CfalsePseudo' false) {  					Type = compj.Type'  					BeforeState = misci.BeforeState'  					AfterState = compj.AfterState  				};  				Trace (1' misci' compj);  				rewritten = true;  			}  		}  	}  }  else if (misci.Op == MiscOp.Dup) {  	if (EnsureLookahead (2)) {  		var j = lookahead [1];  		if (j.Flavor == InstructionFlavor.Misc) {  			var miscj = (MiscInstruction)j;  			if (miscj.Op == MiscOp.Pop) {  				// dup; pop ==> <empty>  				lookahead.RemoveAt (0);  				lookahead.RemoveAt (0);  				Trace (0' misci' miscj);  				rewritten = true;  			}  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,Peephole,C:\repos\Reactive-Extensions_IL2JS\CST\Peephole.cs,MoveNext,The following statement contains a magic number: if (misci.Op == MiscOp.Ldnull) {  	if (EnsureLookahead (2)) {  		var j = lookahead [1];  		if (j.Flavor == InstructionFlavor.Compare) {  			var compj = (CompareInstruction)j;  			if (compj.Op == CompareOp.Cgt) {  				// ldnull; cgt => ctrue  				lookahead.RemoveAt (0);  				lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CtruePseudo' false) {  					Type = compj.Type'  					BeforeState = misci.BeforeState'  					AfterState = compj.AfterState  				};  				Trace (1' misci' compj);  				rewritten = true;  			}  			else if (compj.Op == CompareOp.Ceq) {  				// ldnull; ceq => cfalse  				lookahead.RemoveAt (0);  				lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CfalsePseudo' false) {  					Type = compj.Type'  					BeforeState = misci.BeforeState'  					AfterState = compj.AfterState  				};  				Trace (1' misci' compj);  				rewritten = true;  			}  		}  	}  }  else if (misci.Op == MiscOp.Dup) {  	if (EnsureLookahead (2)) {  		var j = lookahead [1];  		if (j.Flavor == InstructionFlavor.Misc) {  			var miscj = (MiscInstruction)j;  			if (miscj.Op == MiscOp.Pop) {  				// dup; pop ==> <empty>  				lookahead.RemoveAt (0);  				lookahead.RemoveAt (0);  				Trace (0' misci' miscj);  				rewritten = true;  			}  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,Peephole,C:\repos\Reactive-Extensions_IL2JS\CST\Peephole.cs,MoveNext,The following statement contains a magic number: if (misci.Op == MiscOp.Ldnull) {  	if (EnsureLookahead (2)) {  		var j = lookahead [1];  		if (j.Flavor == InstructionFlavor.Compare) {  			var compj = (CompareInstruction)j;  			if (compj.Op == CompareOp.Cgt) {  				// ldnull; cgt => ctrue  				lookahead.RemoveAt (0);  				lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CtruePseudo' false) {  					Type = compj.Type'  					BeforeState = misci.BeforeState'  					AfterState = compj.AfterState  				};  				Trace (1' misci' compj);  				rewritten = true;  			}  			else if (compj.Op == CompareOp.Ceq) {  				// ldnull; ceq => cfalse  				lookahead.RemoveAt (0);  				lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CfalsePseudo' false) {  					Type = compj.Type'  					BeforeState = misci.BeforeState'  					AfterState = compj.AfterState  				};  				Trace (1' misci' compj);  				rewritten = true;  			}  		}  	}  }  else if (misci.Op == MiscOp.Dup) {  	if (EnsureLookahead (2)) {  		var j = lookahead [1];  		if (j.Flavor == InstructionFlavor.Misc) {  			var miscj = (MiscInstruction)j;  			if (miscj.Op == MiscOp.Pop) {  				// dup; pop ==> <empty>  				lookahead.RemoveAt (0);  				lookahead.RemoveAt (0);  				Trace (0' misci' miscj);  				rewritten = true;  			}  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,Peephole,C:\repos\Reactive-Extensions_IL2JS\CST\Peephole.cs,MoveNext,The following statement contains a magic number: if (EnsureLookahead (2)) {  	var j = lookahead [1];  	if (j.Flavor == InstructionFlavor.Compare) {  		var compj = (CompareInstruction)j;  		if (compj.Op == CompareOp.Cgt) {  			// ldnull; cgt => ctrue  			lookahead.RemoveAt (0);  			lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CtruePseudo' false) {  				Type = compj.Type'  				BeforeState = misci.BeforeState'  				AfterState = compj.AfterState  			};  			Trace (1' misci' compj);  			rewritten = true;  		}  		else if (compj.Op == CompareOp.Ceq) {  			// ldnull; ceq => cfalse  			lookahead.RemoveAt (0);  			lookahead [0] = new CompareInstruction (compj.Offset' CompareOp.CfalsePseudo' false) {  				Type = compj.Type'  				BeforeState = misci.BeforeState'  				AfterState = compj.AfterState  			};  			Trace (1' misci' compj);  			rewritten = true;  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,Peephole,C:\repos\Reactive-Extensions_IL2JS\CST\Peephole.cs,MoveNext,The following statement contains a magic number: if (misci.Op == MiscOp.Dup) {  	if (EnsureLookahead (2)) {  		var j = lookahead [1];  		if (j.Flavor == InstructionFlavor.Misc) {  			var miscj = (MiscInstruction)j;  			if (miscj.Op == MiscOp.Pop) {  				// dup; pop ==> <empty>  				lookahead.RemoveAt (0);  				lookahead.RemoveAt (0);  				Trace (0' misci' miscj);  				rewritten = true;  			}  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,Peephole,C:\repos\Reactive-Extensions_IL2JS\CST\Peephole.cs,MoveNext,The following statement contains a magic number: if (EnsureLookahead (2)) {  	var j = lookahead [1];  	if (j.Flavor == InstructionFlavor.Misc) {  		var miscj = (MiscInstruction)j;  		if (miscj.Op == MiscOp.Pop) {  			// dup; pop ==> <empty>  			lookahead.RemoveAt (0);  			lookahead.RemoveAt (0);  			Trace (0' misci' miscj);  			rewritten = true;  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,ArgsAndResultFromMethodSig,The following statement contains a magic number: if (definingTypeRef.Arguments.Count == 1 && !isStatic && (name.Equals ("Set"' StringComparison.Ordinal) || name.Equals ("Get"' StringComparison.Ordinal)) && valParams != null) {  	var bounds = global.GetMultiDimArrayTypeConstructorDetails (definingTypeRef.QualifiedTypeName);  	if (bounds != null) {  		if (name.Equals ("Set"' StringComparison.Ordinal) && valParams.Count == 2 + bounds.Rank && valParams [valParams.Count - 1].Equals (definingTypeRef.Arguments [0])) {  			var paramRef = new ParameterTypeRef (ParameterFlavor.Type' 0);  			valParams [valParams.Count - 1] = paramRef;  		}  		else if (name.Equals ("Get"' StringComparison.Ordinal) && valParams.Count == 1 + bounds.Rank && result != null && result.Equals (definingTypeRef.Arguments [0])) {  			result = new ParameterTypeRef (ParameterFlavor.Type' 0);  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,ArgsAndResultFromMethodSig,The following statement contains a magic number: if (bounds != null) {  	if (name.Equals ("Set"' StringComparison.Ordinal) && valParams.Count == 2 + bounds.Rank && valParams [valParams.Count - 1].Equals (definingTypeRef.Arguments [0])) {  		var paramRef = new ParameterTypeRef (ParameterFlavor.Type' 0);  		valParams [valParams.Count - 1] = paramRef;  	}  	else if (name.Equals ("Get"' StringComparison.Ordinal) && valParams.Count == 1 + bounds.Rank && result != null && result.Equals (definingTypeRef.Arguments [0])) {  		result = new ParameterTypeRef (ParameterFlavor.Type' 0);  	}  }  
Magic Number,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,ArgsAndResultFromMethodSig,The following statement contains a magic number: if (name.Equals ("Set"' StringComparison.Ordinal) && valParams.Count == 2 + bounds.Rank && valParams [valParams.Count - 1].Equals (definingTypeRef.Arguments [0])) {  	var paramRef = new ParameterTypeRef (ParameterFlavor.Type' 0);  	valParams [valParams.Count - 1] = paramRef;  }  else if (name.Equals ("Get"' StringComparison.Ordinal) && valParams.Count == 1 + bounds.Rank && result != null && result.Equals (definingTypeRef.Arguments [0])) {  	result = new ParameterTypeRef (ParameterFlavor.Type' 0);  }  
Magic Number,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The following statement contains a magic number: if (isInterface) {  	if (extends != null)  		throw new InvalidOperationException ("invalid interface type definition");  	if (qtn.Equals (global.IEnumerableTypeConstructorRef.QualifiedTypeName))  		res = new GenericIEnumerableTypeDef (annotations' null' implements' parameters' typeName' members);  	else  		res = new InterfaceTypeDef (annotations' null' implements' parameters' typeName' members);  }  else {  	if (global.QualifiedTypeNameToAbbreviation.ContainsKey (qtn)) {  		var numberFlavor = default(NumberFlavor);  		var handleFlavor = default(HandleFlavor);  		if (global.QualifiedTypeNameToNumberFlavor.TryGetValue (qtn' out numberFlavor))  			res = new NumberTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' numberFlavor' explicitInterfaceImplementations' isCallStaticConstructorEarly);  		else if (global.QualifiedTypeNameToHandleFlavor.TryGetValue (qtn' out handleFlavor))  			res = new HandleTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' handleFlavor' explicitInterfaceImplementations' isCallStaticConstructorEarly);  		else if (qtn.Equals (global.VoidRef.QualifiedTypeName))  			res = new VoidTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  		else if (qtn.Equals (global.ObjectRef.QualifiedTypeName))  			res = new ObjectTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  		else if (qtn.Equals (global.StringRef.QualifiedTypeName))  			res = new StringTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  		else  			throw new InvalidOperationException ("unrecognised special type");  	}  	else if (qtn.Equals (global.EnumRef.QualifiedTypeName) || qtn.Equals (global.ValueTypeRef.QualifiedTypeName) || qtn.Equals (global.DelegateRef.QualifiedTypeName) || qtn.Equals (global.MulticastDelegateRef.QualifiedTypeName) || qtn.Equals (global.ObjectRef.QualifiedTypeName))  		res = new ClassTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isSealed' isAbstract' isCallStaticConstructorEarly);  	else if (qtn.Equals (global.NullableTypeConstructorRef.QualifiedTypeName))  		res = new NullableTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	else if (extends != null) {  		// Look at extends type to decide if delegate' value type or ordinary class.  		// (Can get aways with this because delegates and value types are sealed.)  		if (extends.Equals (global.DelegateRef) || extends.Equals (global.MulticastDelegateRef)) {  			// Is a user-defined delegate type.   			// Fixup the constructor to take a properly typed function pointer as third argument  			// instead of just IntPtr.  			var invokeDef = members.OfType<MethodDef> ().Where (m => !m.IsStatic && m.Name.Equals ("Invoke"' StringComparison.Ordinal)).FirstOrDefault ();  			if (invokeDef == null)  				throw new InvalidOperationException ("delegate does not have Invoke method");  			var codePointer = ((MethodSignature)invokeDef.Signature).WithoutThis ().ToCodePointer (global);  			var ctorDef = members.OfType<MethodDef> ().Where (m => !m.IsStatic && m.IsConstructor && m.Arity == 3).FirstOrDefault ();  			if (ctorDef == null)  				throw new InvalidOperationException ("delegate does not have expected constructor");  			var newCtorParams = new Seq<ParameterOrLocalOrResult> {  				ctorDef.ValueParameters [0]'  				ctorDef.ValueParameters [1]'  				new ParameterOrLocalOrResult (ctorDef.ValueParameters [2].Annotations' ctorDef.ValueParameters [2].CustomAttributes' codePointer)  			};  			var newCtorDef = new MethodDef (ctorDef.Annotations' ctorDef.CustomAttributes' ctorDef.Name' ctorDef.IsStatic' ctorDef.TypeParameters' newCtorParams' ctorDef.Result' ctorDef.MethodStyle' ctorDef.HasNewSlot' ctorDef.CodeFlavor' ctorDef.IsSyncronized' ctorDef.NoInlining' ctorDef.IsInitLocals' ctorDef.Locals' ctorDef.MethodBody);  			var newMembers = new Seq<MemberDef> ();  			foreach (var member in members)  				newMembers.Add (member == ctorDef ? newCtorDef : member);  			res = new DelegateTypeDef (annotations' null' extends' implements' parameters' qtn.Type' newMembers' explicitInterfaceImplementations' isCallStaticConstructorEarly);  		}  		else if (extends.Equals (global.EnumRef))  			// Is a user-defined enumeration  			res = new EnumTypeDef (annotations' null' extends' implements' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  		else if (extends.Equals (global.ValueTypeRef))  			// Is a user-defined struct  			res = new StructTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  		else  			res = new ClassTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isSealed' isAbstract' isCallStaticConstructorEarly);  	}  	else  		// Probably the <Module> type  		res = new ClassTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isSealed' isAbstract' isCallStaticConstructorEarly);  }  
Magic Number,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The following statement contains a magic number: if (isInterface) {  	if (extends != null)  		throw new InvalidOperationException ("invalid interface type definition");  	if (qtn.Equals (global.IEnumerableTypeConstructorRef.QualifiedTypeName))  		res = new GenericIEnumerableTypeDef (annotations' null' implements' parameters' typeName' members);  	else  		res = new InterfaceTypeDef (annotations' null' implements' parameters' typeName' members);  }  else {  	if (global.QualifiedTypeNameToAbbreviation.ContainsKey (qtn)) {  		var numberFlavor = default(NumberFlavor);  		var handleFlavor = default(HandleFlavor);  		if (global.QualifiedTypeNameToNumberFlavor.TryGetValue (qtn' out numberFlavor))  			res = new NumberTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' numberFlavor' explicitInterfaceImplementations' isCallStaticConstructorEarly);  		else if (global.QualifiedTypeNameToHandleFlavor.TryGetValue (qtn' out handleFlavor))  			res = new HandleTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' handleFlavor' explicitInterfaceImplementations' isCallStaticConstructorEarly);  		else if (qtn.Equals (global.VoidRef.QualifiedTypeName))  			res = new VoidTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  		else if (qtn.Equals (global.ObjectRef.QualifiedTypeName))  			res = new ObjectTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  		else if (qtn.Equals (global.StringRef.QualifiedTypeName))  			res = new StringTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  		else  			throw new InvalidOperationException ("unrecognised special type");  	}  	else if (qtn.Equals (global.EnumRef.QualifiedTypeName) || qtn.Equals (global.ValueTypeRef.QualifiedTypeName) || qtn.Equals (global.DelegateRef.QualifiedTypeName) || qtn.Equals (global.MulticastDelegateRef.QualifiedTypeName) || qtn.Equals (global.ObjectRef.QualifiedTypeName))  		res = new ClassTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isSealed' isAbstract' isCallStaticConstructorEarly);  	else if (qtn.Equals (global.NullableTypeConstructorRef.QualifiedTypeName))  		res = new NullableTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	else if (extends != null) {  		// Look at extends type to decide if delegate' value type or ordinary class.  		// (Can get aways with this because delegates and value types are sealed.)  		if (extends.Equals (global.DelegateRef) || extends.Equals (global.MulticastDelegateRef)) {  			// Is a user-defined delegate type.   			// Fixup the constructor to take a properly typed function pointer as third argument  			// instead of just IntPtr.  			var invokeDef = members.OfType<MethodDef> ().Where (m => !m.IsStatic && m.Name.Equals ("Invoke"' StringComparison.Ordinal)).FirstOrDefault ();  			if (invokeDef == null)  				throw new InvalidOperationException ("delegate does not have Invoke method");  			var codePointer = ((MethodSignature)invokeDef.Signature).WithoutThis ().ToCodePointer (global);  			var ctorDef = members.OfType<MethodDef> ().Where (m => !m.IsStatic && m.IsConstructor && m.Arity == 3).FirstOrDefault ();  			if (ctorDef == null)  				throw new InvalidOperationException ("delegate does not have expected constructor");  			var newCtorParams = new Seq<ParameterOrLocalOrResult> {  				ctorDef.ValueParameters [0]'  				ctorDef.ValueParameters [1]'  				new ParameterOrLocalOrResult (ctorDef.ValueParameters [2].Annotations' ctorDef.ValueParameters [2].CustomAttributes' codePointer)  			};  			var newCtorDef = new MethodDef (ctorDef.Annotations' ctorDef.CustomAttributes' ctorDef.Name' ctorDef.IsStatic' ctorDef.TypeParameters' newCtorParams' ctorDef.Result' ctorDef.MethodStyle' ctorDef.HasNewSlot' ctorDef.CodeFlavor' ctorDef.IsSyncronized' ctorDef.NoInlining' ctorDef.IsInitLocals' ctorDef.Locals' ctorDef.MethodBody);  			var newMembers = new Seq<MemberDef> ();  			foreach (var member in members)  				newMembers.Add (member == ctorDef ? newCtorDef : member);  			res = new DelegateTypeDef (annotations' null' extends' implements' parameters' qtn.Type' newMembers' explicitInterfaceImplementations' isCallStaticConstructorEarly);  		}  		else if (extends.Equals (global.EnumRef))  			// Is a user-defined enumeration  			res = new EnumTypeDef (annotations' null' extends' implements' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  		else if (extends.Equals (global.ValueTypeRef))  			// Is a user-defined struct  			res = new StructTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  		else  			res = new ClassTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isSealed' isAbstract' isCallStaticConstructorEarly);  	}  	else  		// Probably the <Module> type  		res = new ClassTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isSealed' isAbstract' isCallStaticConstructorEarly);  }  
Magic Number,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The following statement contains a magic number: if (isInterface) {  	if (extends != null)  		throw new InvalidOperationException ("invalid interface type definition");  	if (qtn.Equals (global.IEnumerableTypeConstructorRef.QualifiedTypeName))  		res = new GenericIEnumerableTypeDef (annotations' null' implements' parameters' typeName' members);  	else  		res = new InterfaceTypeDef (annotations' null' implements' parameters' typeName' members);  }  else {  	if (global.QualifiedTypeNameToAbbreviation.ContainsKey (qtn)) {  		var numberFlavor = default(NumberFlavor);  		var handleFlavor = default(HandleFlavor);  		if (global.QualifiedTypeNameToNumberFlavor.TryGetValue (qtn' out numberFlavor))  			res = new NumberTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' numberFlavor' explicitInterfaceImplementations' isCallStaticConstructorEarly);  		else if (global.QualifiedTypeNameToHandleFlavor.TryGetValue (qtn' out handleFlavor))  			res = new HandleTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' handleFlavor' explicitInterfaceImplementations' isCallStaticConstructorEarly);  		else if (qtn.Equals (global.VoidRef.QualifiedTypeName))  			res = new VoidTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  		else if (qtn.Equals (global.ObjectRef.QualifiedTypeName))  			res = new ObjectTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  		else if (qtn.Equals (global.StringRef.QualifiedTypeName))  			res = new StringTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  		else  			throw new InvalidOperationException ("unrecognised special type");  	}  	else if (qtn.Equals (global.EnumRef.QualifiedTypeName) || qtn.Equals (global.ValueTypeRef.QualifiedTypeName) || qtn.Equals (global.DelegateRef.QualifiedTypeName) || qtn.Equals (global.MulticastDelegateRef.QualifiedTypeName) || qtn.Equals (global.ObjectRef.QualifiedTypeName))  		res = new ClassTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isSealed' isAbstract' isCallStaticConstructorEarly);  	else if (qtn.Equals (global.NullableTypeConstructorRef.QualifiedTypeName))  		res = new NullableTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	else if (extends != null) {  		// Look at extends type to decide if delegate' value type or ordinary class.  		// (Can get aways with this because delegates and value types are sealed.)  		if (extends.Equals (global.DelegateRef) || extends.Equals (global.MulticastDelegateRef)) {  			// Is a user-defined delegate type.   			// Fixup the constructor to take a properly typed function pointer as third argument  			// instead of just IntPtr.  			var invokeDef = members.OfType<MethodDef> ().Where (m => !m.IsStatic && m.Name.Equals ("Invoke"' StringComparison.Ordinal)).FirstOrDefault ();  			if (invokeDef == null)  				throw new InvalidOperationException ("delegate does not have Invoke method");  			var codePointer = ((MethodSignature)invokeDef.Signature).WithoutThis ().ToCodePointer (global);  			var ctorDef = members.OfType<MethodDef> ().Where (m => !m.IsStatic && m.IsConstructor && m.Arity == 3).FirstOrDefault ();  			if (ctorDef == null)  				throw new InvalidOperationException ("delegate does not have expected constructor");  			var newCtorParams = new Seq<ParameterOrLocalOrResult> {  				ctorDef.ValueParameters [0]'  				ctorDef.ValueParameters [1]'  				new ParameterOrLocalOrResult (ctorDef.ValueParameters [2].Annotations' ctorDef.ValueParameters [2].CustomAttributes' codePointer)  			};  			var newCtorDef = new MethodDef (ctorDef.Annotations' ctorDef.CustomAttributes' ctorDef.Name' ctorDef.IsStatic' ctorDef.TypeParameters' newCtorParams' ctorDef.Result' ctorDef.MethodStyle' ctorDef.HasNewSlot' ctorDef.CodeFlavor' ctorDef.IsSyncronized' ctorDef.NoInlining' ctorDef.IsInitLocals' ctorDef.Locals' ctorDef.MethodBody);  			var newMembers = new Seq<MemberDef> ();  			foreach (var member in members)  				newMembers.Add (member == ctorDef ? newCtorDef : member);  			res = new DelegateTypeDef (annotations' null' extends' implements' parameters' qtn.Type' newMembers' explicitInterfaceImplementations' isCallStaticConstructorEarly);  		}  		else if (extends.Equals (global.EnumRef))  			// Is a user-defined enumeration  			res = new EnumTypeDef (annotations' null' extends' implements' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  		else if (extends.Equals (global.ValueTypeRef))  			// Is a user-defined struct  			res = new StructTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  		else  			res = new ClassTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isSealed' isAbstract' isCallStaticConstructorEarly);  	}  	else  		// Probably the <Module> type  		res = new ClassTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isSealed' isAbstract' isCallStaticConstructorEarly);  }  
Magic Number,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The following statement contains a magic number: if (global.QualifiedTypeNameToAbbreviation.ContainsKey (qtn)) {  	var numberFlavor = default(NumberFlavor);  	var handleFlavor = default(HandleFlavor);  	if (global.QualifiedTypeNameToNumberFlavor.TryGetValue (qtn' out numberFlavor))  		res = new NumberTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' numberFlavor' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	else if (global.QualifiedTypeNameToHandleFlavor.TryGetValue (qtn' out handleFlavor))  		res = new HandleTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' handleFlavor' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	else if (qtn.Equals (global.VoidRef.QualifiedTypeName))  		res = new VoidTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	else if (qtn.Equals (global.ObjectRef.QualifiedTypeName))  		res = new ObjectTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	else if (qtn.Equals (global.StringRef.QualifiedTypeName))  		res = new StringTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	else  		throw new InvalidOperationException ("unrecognised special type");  }  else if (qtn.Equals (global.EnumRef.QualifiedTypeName) || qtn.Equals (global.ValueTypeRef.QualifiedTypeName) || qtn.Equals (global.DelegateRef.QualifiedTypeName) || qtn.Equals (global.MulticastDelegateRef.QualifiedTypeName) || qtn.Equals (global.ObjectRef.QualifiedTypeName))  	res = new ClassTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isSealed' isAbstract' isCallStaticConstructorEarly);  else if (qtn.Equals (global.NullableTypeConstructorRef.QualifiedTypeName))  	res = new NullableTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  else if (extends != null) {  	// Look at extends type to decide if delegate' value type or ordinary class.  	// (Can get aways with this because delegates and value types are sealed.)  	if (extends.Equals (global.DelegateRef) || extends.Equals (global.MulticastDelegateRef)) {  		// Is a user-defined delegate type.   		// Fixup the constructor to take a properly typed function pointer as third argument  		// instead of just IntPtr.  		var invokeDef = members.OfType<MethodDef> ().Where (m => !m.IsStatic && m.Name.Equals ("Invoke"' StringComparison.Ordinal)).FirstOrDefault ();  		if (invokeDef == null)  			throw new InvalidOperationException ("delegate does not have Invoke method");  		var codePointer = ((MethodSignature)invokeDef.Signature).WithoutThis ().ToCodePointer (global);  		var ctorDef = members.OfType<MethodDef> ().Where (m => !m.IsStatic && m.IsConstructor && m.Arity == 3).FirstOrDefault ();  		if (ctorDef == null)  			throw new InvalidOperationException ("delegate does not have expected constructor");  		var newCtorParams = new Seq<ParameterOrLocalOrResult> {  			ctorDef.ValueParameters [0]'  			ctorDef.ValueParameters [1]'  			new ParameterOrLocalOrResult (ctorDef.ValueParameters [2].Annotations' ctorDef.ValueParameters [2].CustomAttributes' codePointer)  		};  		var newCtorDef = new MethodDef (ctorDef.Annotations' ctorDef.CustomAttributes' ctorDef.Name' ctorDef.IsStatic' ctorDef.TypeParameters' newCtorParams' ctorDef.Result' ctorDef.MethodStyle' ctorDef.HasNewSlot' ctorDef.CodeFlavor' ctorDef.IsSyncronized' ctorDef.NoInlining' ctorDef.IsInitLocals' ctorDef.Locals' ctorDef.MethodBody);  		var newMembers = new Seq<MemberDef> ();  		foreach (var member in members)  			newMembers.Add (member == ctorDef ? newCtorDef : member);  		res = new DelegateTypeDef (annotations' null' extends' implements' parameters' qtn.Type' newMembers' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	}  	else if (extends.Equals (global.EnumRef))  		// Is a user-defined enumeration  		res = new EnumTypeDef (annotations' null' extends' implements' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	else if (extends.Equals (global.ValueTypeRef))  		// Is a user-defined struct  		res = new StructTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	else  		res = new ClassTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isSealed' isAbstract' isCallStaticConstructorEarly);  }  else  	// Probably the <Module> type  	res = new ClassTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isSealed' isAbstract' isCallStaticConstructorEarly);  
Magic Number,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The following statement contains a magic number: if (global.QualifiedTypeNameToAbbreviation.ContainsKey (qtn)) {  	var numberFlavor = default(NumberFlavor);  	var handleFlavor = default(HandleFlavor);  	if (global.QualifiedTypeNameToNumberFlavor.TryGetValue (qtn' out numberFlavor))  		res = new NumberTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' numberFlavor' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	else if (global.QualifiedTypeNameToHandleFlavor.TryGetValue (qtn' out handleFlavor))  		res = new HandleTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' handleFlavor' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	else if (qtn.Equals (global.VoidRef.QualifiedTypeName))  		res = new VoidTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	else if (qtn.Equals (global.ObjectRef.QualifiedTypeName))  		res = new ObjectTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	else if (qtn.Equals (global.StringRef.QualifiedTypeName))  		res = new StringTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	else  		throw new InvalidOperationException ("unrecognised special type");  }  else if (qtn.Equals (global.EnumRef.QualifiedTypeName) || qtn.Equals (global.ValueTypeRef.QualifiedTypeName) || qtn.Equals (global.DelegateRef.QualifiedTypeName) || qtn.Equals (global.MulticastDelegateRef.QualifiedTypeName) || qtn.Equals (global.ObjectRef.QualifiedTypeName))  	res = new ClassTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isSealed' isAbstract' isCallStaticConstructorEarly);  else if (qtn.Equals (global.NullableTypeConstructorRef.QualifiedTypeName))  	res = new NullableTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  else if (extends != null) {  	// Look at extends type to decide if delegate' value type or ordinary class.  	// (Can get aways with this because delegates and value types are sealed.)  	if (extends.Equals (global.DelegateRef) || extends.Equals (global.MulticastDelegateRef)) {  		// Is a user-defined delegate type.   		// Fixup the constructor to take a properly typed function pointer as third argument  		// instead of just IntPtr.  		var invokeDef = members.OfType<MethodDef> ().Where (m => !m.IsStatic && m.Name.Equals ("Invoke"' StringComparison.Ordinal)).FirstOrDefault ();  		if (invokeDef == null)  			throw new InvalidOperationException ("delegate does not have Invoke method");  		var codePointer = ((MethodSignature)invokeDef.Signature).WithoutThis ().ToCodePointer (global);  		var ctorDef = members.OfType<MethodDef> ().Where (m => !m.IsStatic && m.IsConstructor && m.Arity == 3).FirstOrDefault ();  		if (ctorDef == null)  			throw new InvalidOperationException ("delegate does not have expected constructor");  		var newCtorParams = new Seq<ParameterOrLocalOrResult> {  			ctorDef.ValueParameters [0]'  			ctorDef.ValueParameters [1]'  			new ParameterOrLocalOrResult (ctorDef.ValueParameters [2].Annotations' ctorDef.ValueParameters [2].CustomAttributes' codePointer)  		};  		var newCtorDef = new MethodDef (ctorDef.Annotations' ctorDef.CustomAttributes' ctorDef.Name' ctorDef.IsStatic' ctorDef.TypeParameters' newCtorParams' ctorDef.Result' ctorDef.MethodStyle' ctorDef.HasNewSlot' ctorDef.CodeFlavor' ctorDef.IsSyncronized' ctorDef.NoInlining' ctorDef.IsInitLocals' ctorDef.Locals' ctorDef.MethodBody);  		var newMembers = new Seq<MemberDef> ();  		foreach (var member in members)  			newMembers.Add (member == ctorDef ? newCtorDef : member);  		res = new DelegateTypeDef (annotations' null' extends' implements' parameters' qtn.Type' newMembers' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	}  	else if (extends.Equals (global.EnumRef))  		// Is a user-defined enumeration  		res = new EnumTypeDef (annotations' null' extends' implements' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	else if (extends.Equals (global.ValueTypeRef))  		// Is a user-defined struct  		res = new StructTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	else  		res = new ClassTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isSealed' isAbstract' isCallStaticConstructorEarly);  }  else  	// Probably the <Module> type  	res = new ClassTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isSealed' isAbstract' isCallStaticConstructorEarly);  
Magic Number,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The following statement contains a magic number: if (global.QualifiedTypeNameToAbbreviation.ContainsKey (qtn)) {  	var numberFlavor = default(NumberFlavor);  	var handleFlavor = default(HandleFlavor);  	if (global.QualifiedTypeNameToNumberFlavor.TryGetValue (qtn' out numberFlavor))  		res = new NumberTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' numberFlavor' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	else if (global.QualifiedTypeNameToHandleFlavor.TryGetValue (qtn' out handleFlavor))  		res = new HandleTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' handleFlavor' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	else if (qtn.Equals (global.VoidRef.QualifiedTypeName))  		res = new VoidTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	else if (qtn.Equals (global.ObjectRef.QualifiedTypeName))  		res = new ObjectTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	else if (qtn.Equals (global.StringRef.QualifiedTypeName))  		res = new StringTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	else  		throw new InvalidOperationException ("unrecognised special type");  }  else if (qtn.Equals (global.EnumRef.QualifiedTypeName) || qtn.Equals (global.ValueTypeRef.QualifiedTypeName) || qtn.Equals (global.DelegateRef.QualifiedTypeName) || qtn.Equals (global.MulticastDelegateRef.QualifiedTypeName) || qtn.Equals (global.ObjectRef.QualifiedTypeName))  	res = new ClassTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isSealed' isAbstract' isCallStaticConstructorEarly);  else if (qtn.Equals (global.NullableTypeConstructorRef.QualifiedTypeName))  	res = new NullableTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  else if (extends != null) {  	// Look at extends type to decide if delegate' value type or ordinary class.  	// (Can get aways with this because delegates and value types are sealed.)  	if (extends.Equals (global.DelegateRef) || extends.Equals (global.MulticastDelegateRef)) {  		// Is a user-defined delegate type.   		// Fixup the constructor to take a properly typed function pointer as third argument  		// instead of just IntPtr.  		var invokeDef = members.OfType<MethodDef> ().Where (m => !m.IsStatic && m.Name.Equals ("Invoke"' StringComparison.Ordinal)).FirstOrDefault ();  		if (invokeDef == null)  			throw new InvalidOperationException ("delegate does not have Invoke method");  		var codePointer = ((MethodSignature)invokeDef.Signature).WithoutThis ().ToCodePointer (global);  		var ctorDef = members.OfType<MethodDef> ().Where (m => !m.IsStatic && m.IsConstructor && m.Arity == 3).FirstOrDefault ();  		if (ctorDef == null)  			throw new InvalidOperationException ("delegate does not have expected constructor");  		var newCtorParams = new Seq<ParameterOrLocalOrResult> {  			ctorDef.ValueParameters [0]'  			ctorDef.ValueParameters [1]'  			new ParameterOrLocalOrResult (ctorDef.ValueParameters [2].Annotations' ctorDef.ValueParameters [2].CustomAttributes' codePointer)  		};  		var newCtorDef = new MethodDef (ctorDef.Annotations' ctorDef.CustomAttributes' ctorDef.Name' ctorDef.IsStatic' ctorDef.TypeParameters' newCtorParams' ctorDef.Result' ctorDef.MethodStyle' ctorDef.HasNewSlot' ctorDef.CodeFlavor' ctorDef.IsSyncronized' ctorDef.NoInlining' ctorDef.IsInitLocals' ctorDef.Locals' ctorDef.MethodBody);  		var newMembers = new Seq<MemberDef> ();  		foreach (var member in members)  			newMembers.Add (member == ctorDef ? newCtorDef : member);  		res = new DelegateTypeDef (annotations' null' extends' implements' parameters' qtn.Type' newMembers' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	}  	else if (extends.Equals (global.EnumRef))  		// Is a user-defined enumeration  		res = new EnumTypeDef (annotations' null' extends' implements' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	else if (extends.Equals (global.ValueTypeRef))  		// Is a user-defined struct  		res = new StructTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	else  		res = new ClassTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isSealed' isAbstract' isCallStaticConstructorEarly);  }  else  	// Probably the <Module> type  	res = new ClassTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isSealed' isAbstract' isCallStaticConstructorEarly);  
Magic Number,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The following statement contains a magic number: if (qtn.Equals (global.EnumRef.QualifiedTypeName) || qtn.Equals (global.ValueTypeRef.QualifiedTypeName) || qtn.Equals (global.DelegateRef.QualifiedTypeName) || qtn.Equals (global.MulticastDelegateRef.QualifiedTypeName) || qtn.Equals (global.ObjectRef.QualifiedTypeName))  	res = new ClassTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isSealed' isAbstract' isCallStaticConstructorEarly);  else if (qtn.Equals (global.NullableTypeConstructorRef.QualifiedTypeName))  	res = new NullableTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  else if (extends != null) {  	// Look at extends type to decide if delegate' value type or ordinary class.  	// (Can get aways with this because delegates and value types are sealed.)  	if (extends.Equals (global.DelegateRef) || extends.Equals (global.MulticastDelegateRef)) {  		// Is a user-defined delegate type.   		// Fixup the constructor to take a properly typed function pointer as third argument  		// instead of just IntPtr.  		var invokeDef = members.OfType<MethodDef> ().Where (m => !m.IsStatic && m.Name.Equals ("Invoke"' StringComparison.Ordinal)).FirstOrDefault ();  		if (invokeDef == null)  			throw new InvalidOperationException ("delegate does not have Invoke method");  		var codePointer = ((MethodSignature)invokeDef.Signature).WithoutThis ().ToCodePointer (global);  		var ctorDef = members.OfType<MethodDef> ().Where (m => !m.IsStatic && m.IsConstructor && m.Arity == 3).FirstOrDefault ();  		if (ctorDef == null)  			throw new InvalidOperationException ("delegate does not have expected constructor");  		var newCtorParams = new Seq<ParameterOrLocalOrResult> {  			ctorDef.ValueParameters [0]'  			ctorDef.ValueParameters [1]'  			new ParameterOrLocalOrResult (ctorDef.ValueParameters [2].Annotations' ctorDef.ValueParameters [2].CustomAttributes' codePointer)  		};  		var newCtorDef = new MethodDef (ctorDef.Annotations' ctorDef.CustomAttributes' ctorDef.Name' ctorDef.IsStatic' ctorDef.TypeParameters' newCtorParams' ctorDef.Result' ctorDef.MethodStyle' ctorDef.HasNewSlot' ctorDef.CodeFlavor' ctorDef.IsSyncronized' ctorDef.NoInlining' ctorDef.IsInitLocals' ctorDef.Locals' ctorDef.MethodBody);  		var newMembers = new Seq<MemberDef> ();  		foreach (var member in members)  			newMembers.Add (member == ctorDef ? newCtorDef : member);  		res = new DelegateTypeDef (annotations' null' extends' implements' parameters' qtn.Type' newMembers' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	}  	else if (extends.Equals (global.EnumRef))  		// Is a user-defined enumeration  		res = new EnumTypeDef (annotations' null' extends' implements' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	else if (extends.Equals (global.ValueTypeRef))  		// Is a user-defined struct  		res = new StructTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	else  		res = new ClassTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isSealed' isAbstract' isCallStaticConstructorEarly);  }  else  	// Probably the <Module> type  	res = new ClassTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isSealed' isAbstract' isCallStaticConstructorEarly);  
Magic Number,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The following statement contains a magic number: if (qtn.Equals (global.EnumRef.QualifiedTypeName) || qtn.Equals (global.ValueTypeRef.QualifiedTypeName) || qtn.Equals (global.DelegateRef.QualifiedTypeName) || qtn.Equals (global.MulticastDelegateRef.QualifiedTypeName) || qtn.Equals (global.ObjectRef.QualifiedTypeName))  	res = new ClassTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isSealed' isAbstract' isCallStaticConstructorEarly);  else if (qtn.Equals (global.NullableTypeConstructorRef.QualifiedTypeName))  	res = new NullableTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  else if (extends != null) {  	// Look at extends type to decide if delegate' value type or ordinary class.  	// (Can get aways with this because delegates and value types are sealed.)  	if (extends.Equals (global.DelegateRef) || extends.Equals (global.MulticastDelegateRef)) {  		// Is a user-defined delegate type.   		// Fixup the constructor to take a properly typed function pointer as third argument  		// instead of just IntPtr.  		var invokeDef = members.OfType<MethodDef> ().Where (m => !m.IsStatic && m.Name.Equals ("Invoke"' StringComparison.Ordinal)).FirstOrDefault ();  		if (invokeDef == null)  			throw new InvalidOperationException ("delegate does not have Invoke method");  		var codePointer = ((MethodSignature)invokeDef.Signature).WithoutThis ().ToCodePointer (global);  		var ctorDef = members.OfType<MethodDef> ().Where (m => !m.IsStatic && m.IsConstructor && m.Arity == 3).FirstOrDefault ();  		if (ctorDef == null)  			throw new InvalidOperationException ("delegate does not have expected constructor");  		var newCtorParams = new Seq<ParameterOrLocalOrResult> {  			ctorDef.ValueParameters [0]'  			ctorDef.ValueParameters [1]'  			new ParameterOrLocalOrResult (ctorDef.ValueParameters [2].Annotations' ctorDef.ValueParameters [2].CustomAttributes' codePointer)  		};  		var newCtorDef = new MethodDef (ctorDef.Annotations' ctorDef.CustomAttributes' ctorDef.Name' ctorDef.IsStatic' ctorDef.TypeParameters' newCtorParams' ctorDef.Result' ctorDef.MethodStyle' ctorDef.HasNewSlot' ctorDef.CodeFlavor' ctorDef.IsSyncronized' ctorDef.NoInlining' ctorDef.IsInitLocals' ctorDef.Locals' ctorDef.MethodBody);  		var newMembers = new Seq<MemberDef> ();  		foreach (var member in members)  			newMembers.Add (member == ctorDef ? newCtorDef : member);  		res = new DelegateTypeDef (annotations' null' extends' implements' parameters' qtn.Type' newMembers' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	}  	else if (extends.Equals (global.EnumRef))  		// Is a user-defined enumeration  		res = new EnumTypeDef (annotations' null' extends' implements' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	else if (extends.Equals (global.ValueTypeRef))  		// Is a user-defined struct  		res = new StructTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	else  		res = new ClassTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isSealed' isAbstract' isCallStaticConstructorEarly);  }  else  	// Probably the <Module> type  	res = new ClassTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isSealed' isAbstract' isCallStaticConstructorEarly);  
Magic Number,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The following statement contains a magic number: if (qtn.Equals (global.EnumRef.QualifiedTypeName) || qtn.Equals (global.ValueTypeRef.QualifiedTypeName) || qtn.Equals (global.DelegateRef.QualifiedTypeName) || qtn.Equals (global.MulticastDelegateRef.QualifiedTypeName) || qtn.Equals (global.ObjectRef.QualifiedTypeName))  	res = new ClassTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isSealed' isAbstract' isCallStaticConstructorEarly);  else if (qtn.Equals (global.NullableTypeConstructorRef.QualifiedTypeName))  	res = new NullableTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  else if (extends != null) {  	// Look at extends type to decide if delegate' value type or ordinary class.  	// (Can get aways with this because delegates and value types are sealed.)  	if (extends.Equals (global.DelegateRef) || extends.Equals (global.MulticastDelegateRef)) {  		// Is a user-defined delegate type.   		// Fixup the constructor to take a properly typed function pointer as third argument  		// instead of just IntPtr.  		var invokeDef = members.OfType<MethodDef> ().Where (m => !m.IsStatic && m.Name.Equals ("Invoke"' StringComparison.Ordinal)).FirstOrDefault ();  		if (invokeDef == null)  			throw new InvalidOperationException ("delegate does not have Invoke method");  		var codePointer = ((MethodSignature)invokeDef.Signature).WithoutThis ().ToCodePointer (global);  		var ctorDef = members.OfType<MethodDef> ().Where (m => !m.IsStatic && m.IsConstructor && m.Arity == 3).FirstOrDefault ();  		if (ctorDef == null)  			throw new InvalidOperationException ("delegate does not have expected constructor");  		var newCtorParams = new Seq<ParameterOrLocalOrResult> {  			ctorDef.ValueParameters [0]'  			ctorDef.ValueParameters [1]'  			new ParameterOrLocalOrResult (ctorDef.ValueParameters [2].Annotations' ctorDef.ValueParameters [2].CustomAttributes' codePointer)  		};  		var newCtorDef = new MethodDef (ctorDef.Annotations' ctorDef.CustomAttributes' ctorDef.Name' ctorDef.IsStatic' ctorDef.TypeParameters' newCtorParams' ctorDef.Result' ctorDef.MethodStyle' ctorDef.HasNewSlot' ctorDef.CodeFlavor' ctorDef.IsSyncronized' ctorDef.NoInlining' ctorDef.IsInitLocals' ctorDef.Locals' ctorDef.MethodBody);  		var newMembers = new Seq<MemberDef> ();  		foreach (var member in members)  			newMembers.Add (member == ctorDef ? newCtorDef : member);  		res = new DelegateTypeDef (annotations' null' extends' implements' parameters' qtn.Type' newMembers' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	}  	else if (extends.Equals (global.EnumRef))  		// Is a user-defined enumeration  		res = new EnumTypeDef (annotations' null' extends' implements' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	else if (extends.Equals (global.ValueTypeRef))  		// Is a user-defined struct  		res = new StructTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	else  		res = new ClassTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isSealed' isAbstract' isCallStaticConstructorEarly);  }  else  	// Probably the <Module> type  	res = new ClassTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isSealed' isAbstract' isCallStaticConstructorEarly);  
Magic Number,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The following statement contains a magic number: if (qtn.Equals (global.NullableTypeConstructorRef.QualifiedTypeName))  	res = new NullableTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  else if (extends != null) {  	// Look at extends type to decide if delegate' value type or ordinary class.  	// (Can get aways with this because delegates and value types are sealed.)  	if (extends.Equals (global.DelegateRef) || extends.Equals (global.MulticastDelegateRef)) {  		// Is a user-defined delegate type.   		// Fixup the constructor to take a properly typed function pointer as third argument  		// instead of just IntPtr.  		var invokeDef = members.OfType<MethodDef> ().Where (m => !m.IsStatic && m.Name.Equals ("Invoke"' StringComparison.Ordinal)).FirstOrDefault ();  		if (invokeDef == null)  			throw new InvalidOperationException ("delegate does not have Invoke method");  		var codePointer = ((MethodSignature)invokeDef.Signature).WithoutThis ().ToCodePointer (global);  		var ctorDef = members.OfType<MethodDef> ().Where (m => !m.IsStatic && m.IsConstructor && m.Arity == 3).FirstOrDefault ();  		if (ctorDef == null)  			throw new InvalidOperationException ("delegate does not have expected constructor");  		var newCtorParams = new Seq<ParameterOrLocalOrResult> {  			ctorDef.ValueParameters [0]'  			ctorDef.ValueParameters [1]'  			new ParameterOrLocalOrResult (ctorDef.ValueParameters [2].Annotations' ctorDef.ValueParameters [2].CustomAttributes' codePointer)  		};  		var newCtorDef = new MethodDef (ctorDef.Annotations' ctorDef.CustomAttributes' ctorDef.Name' ctorDef.IsStatic' ctorDef.TypeParameters' newCtorParams' ctorDef.Result' ctorDef.MethodStyle' ctorDef.HasNewSlot' ctorDef.CodeFlavor' ctorDef.IsSyncronized' ctorDef.NoInlining' ctorDef.IsInitLocals' ctorDef.Locals' ctorDef.MethodBody);  		var newMembers = new Seq<MemberDef> ();  		foreach (var member in members)  			newMembers.Add (member == ctorDef ? newCtorDef : member);  		res = new DelegateTypeDef (annotations' null' extends' implements' parameters' qtn.Type' newMembers' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	}  	else if (extends.Equals (global.EnumRef))  		// Is a user-defined enumeration  		res = new EnumTypeDef (annotations' null' extends' implements' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	else if (extends.Equals (global.ValueTypeRef))  		// Is a user-defined struct  		res = new StructTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	else  		res = new ClassTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isSealed' isAbstract' isCallStaticConstructorEarly);  }  else  	// Probably the <Module> type  	res = new ClassTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isSealed' isAbstract' isCallStaticConstructorEarly);  
Magic Number,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The following statement contains a magic number: if (qtn.Equals (global.NullableTypeConstructorRef.QualifiedTypeName))  	res = new NullableTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  else if (extends != null) {  	// Look at extends type to decide if delegate' value type or ordinary class.  	// (Can get aways with this because delegates and value types are sealed.)  	if (extends.Equals (global.DelegateRef) || extends.Equals (global.MulticastDelegateRef)) {  		// Is a user-defined delegate type.   		// Fixup the constructor to take a properly typed function pointer as third argument  		// instead of just IntPtr.  		var invokeDef = members.OfType<MethodDef> ().Where (m => !m.IsStatic && m.Name.Equals ("Invoke"' StringComparison.Ordinal)).FirstOrDefault ();  		if (invokeDef == null)  			throw new InvalidOperationException ("delegate does not have Invoke method");  		var codePointer = ((MethodSignature)invokeDef.Signature).WithoutThis ().ToCodePointer (global);  		var ctorDef = members.OfType<MethodDef> ().Where (m => !m.IsStatic && m.IsConstructor && m.Arity == 3).FirstOrDefault ();  		if (ctorDef == null)  			throw new InvalidOperationException ("delegate does not have expected constructor");  		var newCtorParams = new Seq<ParameterOrLocalOrResult> {  			ctorDef.ValueParameters [0]'  			ctorDef.ValueParameters [1]'  			new ParameterOrLocalOrResult (ctorDef.ValueParameters [2].Annotations' ctorDef.ValueParameters [2].CustomAttributes' codePointer)  		};  		var newCtorDef = new MethodDef (ctorDef.Annotations' ctorDef.CustomAttributes' ctorDef.Name' ctorDef.IsStatic' ctorDef.TypeParameters' newCtorParams' ctorDef.Result' ctorDef.MethodStyle' ctorDef.HasNewSlot' ctorDef.CodeFlavor' ctorDef.IsSyncronized' ctorDef.NoInlining' ctorDef.IsInitLocals' ctorDef.Locals' ctorDef.MethodBody);  		var newMembers = new Seq<MemberDef> ();  		foreach (var member in members)  			newMembers.Add (member == ctorDef ? newCtorDef : member);  		res = new DelegateTypeDef (annotations' null' extends' implements' parameters' qtn.Type' newMembers' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	}  	else if (extends.Equals (global.EnumRef))  		// Is a user-defined enumeration  		res = new EnumTypeDef (annotations' null' extends' implements' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	else if (extends.Equals (global.ValueTypeRef))  		// Is a user-defined struct  		res = new StructTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	else  		res = new ClassTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isSealed' isAbstract' isCallStaticConstructorEarly);  }  else  	// Probably the <Module> type  	res = new ClassTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isSealed' isAbstract' isCallStaticConstructorEarly);  
Magic Number,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The following statement contains a magic number: if (qtn.Equals (global.NullableTypeConstructorRef.QualifiedTypeName))  	res = new NullableTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  else if (extends != null) {  	// Look at extends type to decide if delegate' value type or ordinary class.  	// (Can get aways with this because delegates and value types are sealed.)  	if (extends.Equals (global.DelegateRef) || extends.Equals (global.MulticastDelegateRef)) {  		// Is a user-defined delegate type.   		// Fixup the constructor to take a properly typed function pointer as third argument  		// instead of just IntPtr.  		var invokeDef = members.OfType<MethodDef> ().Where (m => !m.IsStatic && m.Name.Equals ("Invoke"' StringComparison.Ordinal)).FirstOrDefault ();  		if (invokeDef == null)  			throw new InvalidOperationException ("delegate does not have Invoke method");  		var codePointer = ((MethodSignature)invokeDef.Signature).WithoutThis ().ToCodePointer (global);  		var ctorDef = members.OfType<MethodDef> ().Where (m => !m.IsStatic && m.IsConstructor && m.Arity == 3).FirstOrDefault ();  		if (ctorDef == null)  			throw new InvalidOperationException ("delegate does not have expected constructor");  		var newCtorParams = new Seq<ParameterOrLocalOrResult> {  			ctorDef.ValueParameters [0]'  			ctorDef.ValueParameters [1]'  			new ParameterOrLocalOrResult (ctorDef.ValueParameters [2].Annotations' ctorDef.ValueParameters [2].CustomAttributes' codePointer)  		};  		var newCtorDef = new MethodDef (ctorDef.Annotations' ctorDef.CustomAttributes' ctorDef.Name' ctorDef.IsStatic' ctorDef.TypeParameters' newCtorParams' ctorDef.Result' ctorDef.MethodStyle' ctorDef.HasNewSlot' ctorDef.CodeFlavor' ctorDef.IsSyncronized' ctorDef.NoInlining' ctorDef.IsInitLocals' ctorDef.Locals' ctorDef.MethodBody);  		var newMembers = new Seq<MemberDef> ();  		foreach (var member in members)  			newMembers.Add (member == ctorDef ? newCtorDef : member);  		res = new DelegateTypeDef (annotations' null' extends' implements' parameters' qtn.Type' newMembers' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	}  	else if (extends.Equals (global.EnumRef))  		// Is a user-defined enumeration  		res = new EnumTypeDef (annotations' null' extends' implements' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	else if (extends.Equals (global.ValueTypeRef))  		// Is a user-defined struct  		res = new StructTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	else  		res = new ClassTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isSealed' isAbstract' isCallStaticConstructorEarly);  }  else  	// Probably the <Module> type  	res = new ClassTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isSealed' isAbstract' isCallStaticConstructorEarly);  
Magic Number,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The following statement contains a magic number: if (extends != null) {  	// Look at extends type to decide if delegate' value type or ordinary class.  	// (Can get aways with this because delegates and value types are sealed.)  	if (extends.Equals (global.DelegateRef) || extends.Equals (global.MulticastDelegateRef)) {  		// Is a user-defined delegate type.   		// Fixup the constructor to take a properly typed function pointer as third argument  		// instead of just IntPtr.  		var invokeDef = members.OfType<MethodDef> ().Where (m => !m.IsStatic && m.Name.Equals ("Invoke"' StringComparison.Ordinal)).FirstOrDefault ();  		if (invokeDef == null)  			throw new InvalidOperationException ("delegate does not have Invoke method");  		var codePointer = ((MethodSignature)invokeDef.Signature).WithoutThis ().ToCodePointer (global);  		var ctorDef = members.OfType<MethodDef> ().Where (m => !m.IsStatic && m.IsConstructor && m.Arity == 3).FirstOrDefault ();  		if (ctorDef == null)  			throw new InvalidOperationException ("delegate does not have expected constructor");  		var newCtorParams = new Seq<ParameterOrLocalOrResult> {  			ctorDef.ValueParameters [0]'  			ctorDef.ValueParameters [1]'  			new ParameterOrLocalOrResult (ctorDef.ValueParameters [2].Annotations' ctorDef.ValueParameters [2].CustomAttributes' codePointer)  		};  		var newCtorDef = new MethodDef (ctorDef.Annotations' ctorDef.CustomAttributes' ctorDef.Name' ctorDef.IsStatic' ctorDef.TypeParameters' newCtorParams' ctorDef.Result' ctorDef.MethodStyle' ctorDef.HasNewSlot' ctorDef.CodeFlavor' ctorDef.IsSyncronized' ctorDef.NoInlining' ctorDef.IsInitLocals' ctorDef.Locals' ctorDef.MethodBody);  		var newMembers = new Seq<MemberDef> ();  		foreach (var member in members)  			newMembers.Add (member == ctorDef ? newCtorDef : member);  		res = new DelegateTypeDef (annotations' null' extends' implements' parameters' qtn.Type' newMembers' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	}  	else if (extends.Equals (global.EnumRef))  		// Is a user-defined enumeration  		res = new EnumTypeDef (annotations' null' extends' implements' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	else if (extends.Equals (global.ValueTypeRef))  		// Is a user-defined struct  		res = new StructTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	else  		res = new ClassTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isSealed' isAbstract' isCallStaticConstructorEarly);  }  else  	// Probably the <Module> type  	res = new ClassTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isSealed' isAbstract' isCallStaticConstructorEarly);  
Magic Number,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The following statement contains a magic number: if (extends != null) {  	// Look at extends type to decide if delegate' value type or ordinary class.  	// (Can get aways with this because delegates and value types are sealed.)  	if (extends.Equals (global.DelegateRef) || extends.Equals (global.MulticastDelegateRef)) {  		// Is a user-defined delegate type.   		// Fixup the constructor to take a properly typed function pointer as third argument  		// instead of just IntPtr.  		var invokeDef = members.OfType<MethodDef> ().Where (m => !m.IsStatic && m.Name.Equals ("Invoke"' StringComparison.Ordinal)).FirstOrDefault ();  		if (invokeDef == null)  			throw new InvalidOperationException ("delegate does not have Invoke method");  		var codePointer = ((MethodSignature)invokeDef.Signature).WithoutThis ().ToCodePointer (global);  		var ctorDef = members.OfType<MethodDef> ().Where (m => !m.IsStatic && m.IsConstructor && m.Arity == 3).FirstOrDefault ();  		if (ctorDef == null)  			throw new InvalidOperationException ("delegate does not have expected constructor");  		var newCtorParams = new Seq<ParameterOrLocalOrResult> {  			ctorDef.ValueParameters [0]'  			ctorDef.ValueParameters [1]'  			new ParameterOrLocalOrResult (ctorDef.ValueParameters [2].Annotations' ctorDef.ValueParameters [2].CustomAttributes' codePointer)  		};  		var newCtorDef = new MethodDef (ctorDef.Annotations' ctorDef.CustomAttributes' ctorDef.Name' ctorDef.IsStatic' ctorDef.TypeParameters' newCtorParams' ctorDef.Result' ctorDef.MethodStyle' ctorDef.HasNewSlot' ctorDef.CodeFlavor' ctorDef.IsSyncronized' ctorDef.NoInlining' ctorDef.IsInitLocals' ctorDef.Locals' ctorDef.MethodBody);  		var newMembers = new Seq<MemberDef> ();  		foreach (var member in members)  			newMembers.Add (member == ctorDef ? newCtorDef : member);  		res = new DelegateTypeDef (annotations' null' extends' implements' parameters' qtn.Type' newMembers' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	}  	else if (extends.Equals (global.EnumRef))  		// Is a user-defined enumeration  		res = new EnumTypeDef (annotations' null' extends' implements' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	else if (extends.Equals (global.ValueTypeRef))  		// Is a user-defined struct  		res = new StructTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	else  		res = new ClassTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isSealed' isAbstract' isCallStaticConstructorEarly);  }  else  	// Probably the <Module> type  	res = new ClassTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isSealed' isAbstract' isCallStaticConstructorEarly);  
Magic Number,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The following statement contains a magic number: if (extends != null) {  	// Look at extends type to decide if delegate' value type or ordinary class.  	// (Can get aways with this because delegates and value types are sealed.)  	if (extends.Equals (global.DelegateRef) || extends.Equals (global.MulticastDelegateRef)) {  		// Is a user-defined delegate type.   		// Fixup the constructor to take a properly typed function pointer as third argument  		// instead of just IntPtr.  		var invokeDef = members.OfType<MethodDef> ().Where (m => !m.IsStatic && m.Name.Equals ("Invoke"' StringComparison.Ordinal)).FirstOrDefault ();  		if (invokeDef == null)  			throw new InvalidOperationException ("delegate does not have Invoke method");  		var codePointer = ((MethodSignature)invokeDef.Signature).WithoutThis ().ToCodePointer (global);  		var ctorDef = members.OfType<MethodDef> ().Where (m => !m.IsStatic && m.IsConstructor && m.Arity == 3).FirstOrDefault ();  		if (ctorDef == null)  			throw new InvalidOperationException ("delegate does not have expected constructor");  		var newCtorParams = new Seq<ParameterOrLocalOrResult> {  			ctorDef.ValueParameters [0]'  			ctorDef.ValueParameters [1]'  			new ParameterOrLocalOrResult (ctorDef.ValueParameters [2].Annotations' ctorDef.ValueParameters [2].CustomAttributes' codePointer)  		};  		var newCtorDef = new MethodDef (ctorDef.Annotations' ctorDef.CustomAttributes' ctorDef.Name' ctorDef.IsStatic' ctorDef.TypeParameters' newCtorParams' ctorDef.Result' ctorDef.MethodStyle' ctorDef.HasNewSlot' ctorDef.CodeFlavor' ctorDef.IsSyncronized' ctorDef.NoInlining' ctorDef.IsInitLocals' ctorDef.Locals' ctorDef.MethodBody);  		var newMembers = new Seq<MemberDef> ();  		foreach (var member in members)  			newMembers.Add (member == ctorDef ? newCtorDef : member);  		res = new DelegateTypeDef (annotations' null' extends' implements' parameters' qtn.Type' newMembers' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	}  	else if (extends.Equals (global.EnumRef))  		// Is a user-defined enumeration  		res = new EnumTypeDef (annotations' null' extends' implements' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	else if (extends.Equals (global.ValueTypeRef))  		// Is a user-defined struct  		res = new StructTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  	else  		res = new ClassTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isSealed' isAbstract' isCallStaticConstructorEarly);  }  else  	// Probably the <Module> type  	res = new ClassTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isSealed' isAbstract' isCallStaticConstructorEarly);  
Magic Number,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The following statement contains a magic number: if (extends.Equals (global.DelegateRef) || extends.Equals (global.MulticastDelegateRef)) {  	// Is a user-defined delegate type.   	// Fixup the constructor to take a properly typed function pointer as third argument  	// instead of just IntPtr.  	var invokeDef = members.OfType<MethodDef> ().Where (m => !m.IsStatic && m.Name.Equals ("Invoke"' StringComparison.Ordinal)).FirstOrDefault ();  	if (invokeDef == null)  		throw new InvalidOperationException ("delegate does not have Invoke method");  	var codePointer = ((MethodSignature)invokeDef.Signature).WithoutThis ().ToCodePointer (global);  	var ctorDef = members.OfType<MethodDef> ().Where (m => !m.IsStatic && m.IsConstructor && m.Arity == 3).FirstOrDefault ();  	if (ctorDef == null)  		throw new InvalidOperationException ("delegate does not have expected constructor");  	var newCtorParams = new Seq<ParameterOrLocalOrResult> {  		ctorDef.ValueParameters [0]'  		ctorDef.ValueParameters [1]'  		new ParameterOrLocalOrResult (ctorDef.ValueParameters [2].Annotations' ctorDef.ValueParameters [2].CustomAttributes' codePointer)  	};  	var newCtorDef = new MethodDef (ctorDef.Annotations' ctorDef.CustomAttributes' ctorDef.Name' ctorDef.IsStatic' ctorDef.TypeParameters' newCtorParams' ctorDef.Result' ctorDef.MethodStyle' ctorDef.HasNewSlot' ctorDef.CodeFlavor' ctorDef.IsSyncronized' ctorDef.NoInlining' ctorDef.IsInitLocals' ctorDef.Locals' ctorDef.MethodBody);  	var newMembers = new Seq<MemberDef> ();  	foreach (var member in members)  		newMembers.Add (member == ctorDef ? newCtorDef : member);  	res = new DelegateTypeDef (annotations' null' extends' implements' parameters' qtn.Type' newMembers' explicitInterfaceImplementations' isCallStaticConstructorEarly);  }  else if (extends.Equals (global.EnumRef))  	// Is a user-defined enumeration  	res = new EnumTypeDef (annotations' null' extends' implements' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  else if (extends.Equals (global.ValueTypeRef))  	// Is a user-defined struct  	res = new StructTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  else  	res = new ClassTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isSealed' isAbstract' isCallStaticConstructorEarly);  
Magic Number,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The following statement contains a magic number: if (extends.Equals (global.DelegateRef) || extends.Equals (global.MulticastDelegateRef)) {  	// Is a user-defined delegate type.   	// Fixup the constructor to take a properly typed function pointer as third argument  	// instead of just IntPtr.  	var invokeDef = members.OfType<MethodDef> ().Where (m => !m.IsStatic && m.Name.Equals ("Invoke"' StringComparison.Ordinal)).FirstOrDefault ();  	if (invokeDef == null)  		throw new InvalidOperationException ("delegate does not have Invoke method");  	var codePointer = ((MethodSignature)invokeDef.Signature).WithoutThis ().ToCodePointer (global);  	var ctorDef = members.OfType<MethodDef> ().Where (m => !m.IsStatic && m.IsConstructor && m.Arity == 3).FirstOrDefault ();  	if (ctorDef == null)  		throw new InvalidOperationException ("delegate does not have expected constructor");  	var newCtorParams = new Seq<ParameterOrLocalOrResult> {  		ctorDef.ValueParameters [0]'  		ctorDef.ValueParameters [1]'  		new ParameterOrLocalOrResult (ctorDef.ValueParameters [2].Annotations' ctorDef.ValueParameters [2].CustomAttributes' codePointer)  	};  	var newCtorDef = new MethodDef (ctorDef.Annotations' ctorDef.CustomAttributes' ctorDef.Name' ctorDef.IsStatic' ctorDef.TypeParameters' newCtorParams' ctorDef.Result' ctorDef.MethodStyle' ctorDef.HasNewSlot' ctorDef.CodeFlavor' ctorDef.IsSyncronized' ctorDef.NoInlining' ctorDef.IsInitLocals' ctorDef.Locals' ctorDef.MethodBody);  	var newMembers = new Seq<MemberDef> ();  	foreach (var member in members)  		newMembers.Add (member == ctorDef ? newCtorDef : member);  	res = new DelegateTypeDef (annotations' null' extends' implements' parameters' qtn.Type' newMembers' explicitInterfaceImplementations' isCallStaticConstructorEarly);  }  else if (extends.Equals (global.EnumRef))  	// Is a user-defined enumeration  	res = new EnumTypeDef (annotations' null' extends' implements' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  else if (extends.Equals (global.ValueTypeRef))  	// Is a user-defined struct  	res = new StructTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  else  	res = new ClassTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isSealed' isAbstract' isCallStaticConstructorEarly);  
Magic Number,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The following statement contains a magic number: if (extends.Equals (global.DelegateRef) || extends.Equals (global.MulticastDelegateRef)) {  	// Is a user-defined delegate type.   	// Fixup the constructor to take a properly typed function pointer as third argument  	// instead of just IntPtr.  	var invokeDef = members.OfType<MethodDef> ().Where (m => !m.IsStatic && m.Name.Equals ("Invoke"' StringComparison.Ordinal)).FirstOrDefault ();  	if (invokeDef == null)  		throw new InvalidOperationException ("delegate does not have Invoke method");  	var codePointer = ((MethodSignature)invokeDef.Signature).WithoutThis ().ToCodePointer (global);  	var ctorDef = members.OfType<MethodDef> ().Where (m => !m.IsStatic && m.IsConstructor && m.Arity == 3).FirstOrDefault ();  	if (ctorDef == null)  		throw new InvalidOperationException ("delegate does not have expected constructor");  	var newCtorParams = new Seq<ParameterOrLocalOrResult> {  		ctorDef.ValueParameters [0]'  		ctorDef.ValueParameters [1]'  		new ParameterOrLocalOrResult (ctorDef.ValueParameters [2].Annotations' ctorDef.ValueParameters [2].CustomAttributes' codePointer)  	};  	var newCtorDef = new MethodDef (ctorDef.Annotations' ctorDef.CustomAttributes' ctorDef.Name' ctorDef.IsStatic' ctorDef.TypeParameters' newCtorParams' ctorDef.Result' ctorDef.MethodStyle' ctorDef.HasNewSlot' ctorDef.CodeFlavor' ctorDef.IsSyncronized' ctorDef.NoInlining' ctorDef.IsInitLocals' ctorDef.Locals' ctorDef.MethodBody);  	var newMembers = new Seq<MemberDef> ();  	foreach (var member in members)  		newMembers.Add (member == ctorDef ? newCtorDef : member);  	res = new DelegateTypeDef (annotations' null' extends' implements' parameters' qtn.Type' newMembers' explicitInterfaceImplementations' isCallStaticConstructorEarly);  }  else if (extends.Equals (global.EnumRef))  	// Is a user-defined enumeration  	res = new EnumTypeDef (annotations' null' extends' implements' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  else if (extends.Equals (global.ValueTypeRef))  	// Is a user-defined struct  	res = new StructTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isCallStaticConstructorEarly);  else  	res = new ClassTypeDef (annotations' null' extends' implements' parameters' qtn.Type' members' explicitInterfaceImplementations' isSealed' isAbstract' isCallStaticConstructorEarly);  
Magic Number,Microsoft.LiveLabs.CST,MethodSignature,C:\repos\Reactive-Extensions_IL2JS\CST\Signature.cs,Fixup,The following statement contains a magic number: if (Parameters.Count > 0 && !IsStatic) {  	var paramAssemblyDef = default(AssemblyDef);  	var paramTypeDef = default(TypeDef);  	if (Parameters [0].PrimTryResolve (global' out paramAssemblyDef' out paramTypeDef)) {  		var s = paramTypeDef.Style;  		if (s is ValueTypeStyle) {  			var newValueParameters = new Seq<TypeRef> (Parameters.Count);  			newValueParameters.Add (global.ManagedPointerTypeConstructorRef.ApplyTo (Parameters [0]));  			for (var i = 1; i < Parameters.Count; i++)  				newValueParameters.Add (Parameters [i]);  			Parameters = newValueParameters;  		}  		else if (Parameters.Count == 3 && Name.Equals (".ctor"' StringComparison.Ordinal) && s is DelegateTypeStyle) {  			var delTypeDef = (DelegateTypeDef)paramTypeDef;  			var newValueParameters = new Seq<TypeRef> (Parameters.Count);  			for (var i = 0; i < 2; i++)  				newValueParameters.Add (Parameters [i]);  			newValueParameters.Add (TypeRef.CodePointerFrom (global' delTypeDef.ValueParameters.Select (p => p.Type).ToSeq ()' delTypeDef.Result == null ? null : delTypeDef.Result.Type));  			Parameters = newValueParameters;  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,MethodSignature,C:\repos\Reactive-Extensions_IL2JS\CST\Signature.cs,Fixup,The following statement contains a magic number: if (Parameters.Count > 0 && !IsStatic) {  	var paramAssemblyDef = default(AssemblyDef);  	var paramTypeDef = default(TypeDef);  	if (Parameters [0].PrimTryResolve (global' out paramAssemblyDef' out paramTypeDef)) {  		var s = paramTypeDef.Style;  		if (s is ValueTypeStyle) {  			var newValueParameters = new Seq<TypeRef> (Parameters.Count);  			newValueParameters.Add (global.ManagedPointerTypeConstructorRef.ApplyTo (Parameters [0]));  			for (var i = 1; i < Parameters.Count; i++)  				newValueParameters.Add (Parameters [i]);  			Parameters = newValueParameters;  		}  		else if (Parameters.Count == 3 && Name.Equals (".ctor"' StringComparison.Ordinal) && s is DelegateTypeStyle) {  			var delTypeDef = (DelegateTypeDef)paramTypeDef;  			var newValueParameters = new Seq<TypeRef> (Parameters.Count);  			for (var i = 0; i < 2; i++)  				newValueParameters.Add (Parameters [i]);  			newValueParameters.Add (TypeRef.CodePointerFrom (global' delTypeDef.ValueParameters.Select (p => p.Type).ToSeq ()' delTypeDef.Result == null ? null : delTypeDef.Result.Type));  			Parameters = newValueParameters;  		}  	}  }  
Magic Number,Microsoft.LiveLabs.CST,MethodSignature,C:\repos\Reactive-Extensions_IL2JS\CST\Signature.cs,Fixup,The following statement contains a magic number: if (Parameters [0].PrimTryResolve (global' out paramAssemblyDef' out paramTypeDef)) {  	var s = paramTypeDef.Style;  	if (s is ValueTypeStyle) {  		var newValueParameters = new Seq<TypeRef> (Parameters.Count);  		newValueParameters.Add (global.ManagedPointerTypeConstructorRef.ApplyTo (Parameters [0]));  		for (var i = 1; i < Parameters.Count; i++)  			newValueParameters.Add (Parameters [i]);  		Parameters = newValueParameters;  	}  	else if (Parameters.Count == 3 && Name.Equals (".ctor"' StringComparison.Ordinal) && s is DelegateTypeStyle) {  		var delTypeDef = (DelegateTypeDef)paramTypeDef;  		var newValueParameters = new Seq<TypeRef> (Parameters.Count);  		for (var i = 0; i < 2; i++)  			newValueParameters.Add (Parameters [i]);  		newValueParameters.Add (TypeRef.CodePointerFrom (global' delTypeDef.ValueParameters.Select (p => p.Type).ToSeq ()' delTypeDef.Result == null ? null : delTypeDef.Result.Type));  		Parameters = newValueParameters;  	}  }  
Magic Number,Microsoft.LiveLabs.CST,MethodSignature,C:\repos\Reactive-Extensions_IL2JS\CST\Signature.cs,Fixup,The following statement contains a magic number: if (Parameters [0].PrimTryResolve (global' out paramAssemblyDef' out paramTypeDef)) {  	var s = paramTypeDef.Style;  	if (s is ValueTypeStyle) {  		var newValueParameters = new Seq<TypeRef> (Parameters.Count);  		newValueParameters.Add (global.ManagedPointerTypeConstructorRef.ApplyTo (Parameters [0]));  		for (var i = 1; i < Parameters.Count; i++)  			newValueParameters.Add (Parameters [i]);  		Parameters = newValueParameters;  	}  	else if (Parameters.Count == 3 && Name.Equals (".ctor"' StringComparison.Ordinal) && s is DelegateTypeStyle) {  		var delTypeDef = (DelegateTypeDef)paramTypeDef;  		var newValueParameters = new Seq<TypeRef> (Parameters.Count);  		for (var i = 0; i < 2; i++)  			newValueParameters.Add (Parameters [i]);  		newValueParameters.Add (TypeRef.CodePointerFrom (global' delTypeDef.ValueParameters.Select (p => p.Type).ToSeq ()' delTypeDef.Result == null ? null : delTypeDef.Result.Type));  		Parameters = newValueParameters;  	}  }  
Magic Number,Microsoft.LiveLabs.CST,MethodSignature,C:\repos\Reactive-Extensions_IL2JS\CST\Signature.cs,Fixup,The following statement contains a magic number: if (s is ValueTypeStyle) {  	var newValueParameters = new Seq<TypeRef> (Parameters.Count);  	newValueParameters.Add (global.ManagedPointerTypeConstructorRef.ApplyTo (Parameters [0]));  	for (var i = 1; i < Parameters.Count; i++)  		newValueParameters.Add (Parameters [i]);  	Parameters = newValueParameters;  }  else if (Parameters.Count == 3 && Name.Equals (".ctor"' StringComparison.Ordinal) && s is DelegateTypeStyle) {  	var delTypeDef = (DelegateTypeDef)paramTypeDef;  	var newValueParameters = new Seq<TypeRef> (Parameters.Count);  	for (var i = 0; i < 2; i++)  		newValueParameters.Add (Parameters [i]);  	newValueParameters.Add (TypeRef.CodePointerFrom (global' delTypeDef.ValueParameters.Select (p => p.Type).ToSeq ()' delTypeDef.Result == null ? null : delTypeDef.Result.Type));  	Parameters = newValueParameters;  }  
Magic Number,Microsoft.LiveLabs.CST,MethodSignature,C:\repos\Reactive-Extensions_IL2JS\CST\Signature.cs,Fixup,The following statement contains a magic number: if (s is ValueTypeStyle) {  	var newValueParameters = new Seq<TypeRef> (Parameters.Count);  	newValueParameters.Add (global.ManagedPointerTypeConstructorRef.ApplyTo (Parameters [0]));  	for (var i = 1; i < Parameters.Count; i++)  		newValueParameters.Add (Parameters [i]);  	Parameters = newValueParameters;  }  else if (Parameters.Count == 3 && Name.Equals (".ctor"' StringComparison.Ordinal) && s is DelegateTypeStyle) {  	var delTypeDef = (DelegateTypeDef)paramTypeDef;  	var newValueParameters = new Seq<TypeRef> (Parameters.Count);  	for (var i = 0; i < 2; i++)  		newValueParameters.Add (Parameters [i]);  	newValueParameters.Add (TypeRef.CodePointerFrom (global' delTypeDef.ValueParameters.Select (p => p.Type).ToSeq ()' delTypeDef.Result == null ? null : delTypeDef.Result.Type));  	Parameters = newValueParameters;  }  
Magic Number,Microsoft.LiveLabs.CST,MethodSignature,C:\repos\Reactive-Extensions_IL2JS\CST\Signature.cs,Fixup,The following statement contains a magic number: if (Parameters.Count == 3 && Name.Equals (".ctor"' StringComparison.Ordinal) && s is DelegateTypeStyle) {  	var delTypeDef = (DelegateTypeDef)paramTypeDef;  	var newValueParameters = new Seq<TypeRef> (Parameters.Count);  	for (var i = 0; i < 2; i++)  		newValueParameters.Add (Parameters [i]);  	newValueParameters.Add (TypeRef.CodePointerFrom (global' delTypeDef.ValueParameters.Select (p => p.Type).ToSeq ()' delTypeDef.Result == null ? null : delTypeDef.Result.Type));  	Parameters = newValueParameters;  }  
Magic Number,Microsoft.LiveLabs.CST,MethodSignature,C:\repos\Reactive-Extensions_IL2JS\CST\Signature.cs,Fixup,The following statement contains a magic number: if (Parameters.Count == 3 && Name.Equals (".ctor"' StringComparison.Ordinal) && s is DelegateTypeStyle) {  	var delTypeDef = (DelegateTypeDef)paramTypeDef;  	var newValueParameters = new Seq<TypeRef> (Parameters.Count);  	for (var i = 0; i < 2; i++)  		newValueParameters.Add (Parameters [i]);  	newValueParameters.Add (TypeRef.CodePointerFrom (global' delTypeDef.ValueParameters.Select (p => p.Type).ToSeq ()' delTypeDef.Result == null ? null : delTypeDef.Result.Type));  	Parameters = newValueParameters;  }  
Magic Number,Microsoft.LiveLabs.CST,MethodSignature,C:\repos\Reactive-Extensions_IL2JS\CST\Signature.cs,Fixup,The following statement contains a magic number: for (var i = 0; i < 2; i++)  	newValueParameters.Add (Parameters [i]);  
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (instruction.Flavor) {  case InstructionFlavor.Unsupported:  	throw new InvalidOperationException ("unsupported opcode");  case InstructionFlavor.Misc: {  	var misci = (MiscInstruction)instruction;  	switch (misci.Op) {  	case MiscOp.Nop:  	case MiscOp.Break:  		return true;  	case MiscOp.Dup:  		return stack.Dup (statements);  	case MiscOp.Pop:  		return stack.PopAndDiscard (statements);  	case MiscOp.Ldnull:  		stack.Push (new ExpressionStackEntry (new NullConstantExpression ()' BottomE));  		return true;  	case MiscOp.Ckfinite:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' UnaryOp.CheckFinite' false' false)' e.Lub (ThrowsE)));  	case MiscOp.Throw:  		if (!stack.DiscardAll (statements' 1))  			return false;  		if (!stack.PopEvalSE (statements' 1' true' ThrowsE' (s' a) => s.Add (new ThrowStatement (a [0]))))  			return false;  		return true;  	case MiscOp.Rethrow:  		if (!stack.DiscardAll (statements' 0))  			return false;  		if (statements == null)  			return Failed (false' "rethrow");  		if (exid == null)  			throw new InvalidOperationException ("rethrow outside of catch");  		statements.Add (new RethrowStatement (new VariableCell (exid).Read ()));  		return true;  	case MiscOp.LdindRef:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ReadExpression (a [0]).CloneIfStruct (compEnv)' e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ())));  	case MiscOp.LdelemRef:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' true).Read ().CloneIfStruct (compEnv)' e.Lub (ReadHeapOrThrowE)));  	case MiscOp.Ldlen:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' UnaryOp.Length' false' false)' e.Lub (ReadHeapOrThrowE)));  	case MiscOp.StindRef:  		return stack.PopEvalSE (statements' 2' true' instruction.BeforeState.PeekPointsTo (1).WriteEffect ()' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' a [1]))));  	case MiscOp.StelemRef:  		return stack.PopEvalSE (statements' 3' true' WriteHeapOrThrowE' (s' a) => s.Add (new ExpressionStatement (new ElementCell (a [0]' a [1]' false).Write (a [2]))));  	case MiscOp.Ret:  		if (statements == null)  			return Failed (false' "return");  		statements.Add (new ReturnStatement (null));  		return true;  	case MiscOp.RetVal:  		return stack.PopEvalSE (statements' 1' true' BottomE' (s' a) => s.Add (new ReturnStatement (a [0])));  	case MiscOp.Endfilter:  	case MiscOp.Endfinally:  		throw new InvalidOperationException ("endfilter/endfinally instructions should have been removed");  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Branch:  case InstructionFlavor.Switch:  	throw new InvalidOperationException ("branch/switch instructions should have been removed");  case InstructionFlavor.Compare: {  	var cmpi = (CompareInstruction)instruction;  	if (cmpi.Op == CompareOp.CtruePseudo || cmpi.Op == CompareOp.CfalsePseudo) {  		var s = cmpi.Type.Style (compEnv);  		var unop = default(UnaryOp);  		if (s is NumberTypeStyle)  			unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonZero : UnaryOp.IsZero;  		else  			unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonNull : UnaryOp.IsNull;  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' unop' false' cmpi.IsUnsigned)' e));  	}  	else {  		var binop = default(BinaryOp);  		switch (cmpi.Op) {  		case CompareOp.Ceq:  			binop = BinaryOp.Eq;  			break;  		case CompareOp.Clt:  			binop = BinaryOp.Lt;  			break;  		case CompareOp.Cgt:  			binop = BinaryOp.Gt;  			break;  		case CompareOp.CgePseudo:  			binop = BinaryOp.Ge;  			break;  		case CompareOp.ClePseudo:  			binop = BinaryOp.Le;  			break;  		case CompareOp.CnePseudo:  			binop = BinaryOp.Ne;  			break;  		case CompareOp.CtruePseudo:  		case CompareOp.CfalsePseudo:  			// handled above  			throw new InvalidOperationException ();  		default:  			throw new ArgumentOutOfRangeException ();  		}  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new BinaryExpression (a [0]' binop' a [1]' false' cmpi.IsUnsigned)' e));  	}  }  case InstructionFlavor.ArgLocal: {  	var sli = (ArgLocalInstruction)instruction;  	var id = default(JST.Identifier);  	switch (sli.ArgLocal) {  	case ArgLocal.Arg:  		id = compEnv.ValueParameterIds [sli.Index];  		break;  	case ArgLocal.Local:  		id = compEnv.LocalIds [sli.Index];  		break;  	default:  		throw new ArgumentOutOfRangeException ();  	}  	var cell = new VariableCell (id);  	switch (sli.Op) {  	case ArgLocalOp.Ld:  		stack.Push (new ExpressionStackEntry (cell.Read ().CloneIfStruct (compEnv)' ReadArgLocalE (sli.ArgLocal' sli.Index)));  		return true;  	case ArgLocalOp.Lda:  		// Effect will be accounted for on reads/writes  		stack.Push (new ExpressionStackEntry (cell.AddressOf ()' BottomE));  		return true;  	case ArgLocalOp.St:  		return stack.PopEvalSE (statements' 1' true' WriteArgLocalE (sli.ArgLocal' sli.Index)' (s' a) => s.Add (new ExpressionStatement (cell.Write (a [0]))));  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Field: {  	var fieldi = (FieldInstruction)instruction;  	switch (fieldi.Op) {  	case FieldOp.Ldfld:  		if (fieldi.IsStatic) {  			stack.Push (new ExpressionStackEntry (new FieldCell (null' compEnv.SubstituteMember (fieldi.Field)).Read ().CloneIfStruct (compEnv)' ReadHeapE));  			return true;  		}  		else  			return stack.PopEvalPush (statements' 1' true' (a' e) =>  {  				var readEffect = default(Effects);  				var obj = default(Expression);  				if (fieldi.IsViaPointer.Value) {  					readEffect = e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ());  					obj = new ReadExpression (a [0]);  					// no need for clone  				}  				else if (fieldi.Field.DefiningType.Style (compEnv) is ValueTypeStyle) {  					readEffect = e;  					obj = a [0];  				}  				else {  					// Object could be null  					readEffect = e.Lub (ReadHeapOrThrowE);  					obj = a [0];  				}  				return new ExpressionStackEntry (new FieldCell (obj' compEnv.SubstituteMember (fieldi.Field)).Read ().CloneIfStruct (compEnv)' readEffect);  			});  	case FieldOp.Ldflda:  		if (fieldi.IsStatic) {  			// Effect will be accounted for on reads/writes  			stack.Push (new ExpressionStackEntry (new FieldCell (null' compEnv.SubstituteMember (fieldi.Field)).AddressOf ()' BottomE));  			return true;  		}  		else  			return stack.PopEvalPush (statements' 1' true' (a' e) =>  {  				if (fieldi.IsViaPointer.Value)  					// We're just adding an offset to a pointer' so effect will  					// be accounted for when the final pointer is read/written  					return new ExpressionStackEntry (new FieldCell (new ReadExpression (a [0])' compEnv.SubstituteMember (fieldi.Field)).AddressOf ()' e);  				else  					// Must be a reference type' and ref could be null  					return new ExpressionStackEntry (new FieldCell (a [0]' compEnv.SubstituteMember (fieldi.Field)).AddressOf ()' e.Lub (ThrowsE));  			});  	case FieldOp.Stfld:  		if (fieldi.IsStatic)  			return stack.PopEvalSE (statements' 1' true' WriteHeapE' (s' a) => s.Add (new ExpressionStatement (new FieldCell (null' compEnv.SubstituteMember (fieldi.Field)).Write (a [0]))));  		else {  			var writeEffect = fieldi.IsViaPointer.Value ? instruction.BeforeState.PeekPointsTo (1).WriteEffect () : WriteHeapOrThrowE;  			return stack.PopEvalSE (statements' 2' true' writeEffect' (s' a) =>  {  				var obj = fieldi.IsViaPointer.Value ? new ReadExpression (a [0]) : a [0];  				s.Add (new ExpressionStatement (new FieldCell (obj' compEnv.SubstituteMember (fieldi.Field)).Write (a [1])));  			});  		}  	case FieldOp.Ldtoken:  		stack.Push (new ExpressionStackEntry (new FieldHandleConstantExpression (compEnv.SubstituteMember (fieldi.Field))' BottomE));  		return true;  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Method: {  	var methodi = (MethodInstruction)instruction;  	var arity = methodi.Method.ValueParameters.Count;  	switch (methodi.Op) {  	case MethodOp.Ldftn:  		if (methodi.IsVirtual)  			// Object could be null  			return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new CodePointerExpression (a [0]' compEnv.SubstituteMember (methodi.Method))' e.Lub (ReadHeapOrThrowE)));  		else {  			stack.Push (new ExpressionStackEntry (new CodePointerExpression (null' compEnv.SubstituteMember (methodi.Method))' BottomE));  			return true;  		}  	case MethodOp.Call:  		if (methodi.Method.Result == null)  			return stack.PopEvalSE (statements' arity' true' CalleeEffects (methodi.BeforeState' arity)' (s' a) => s.Add (new ExpressionStatement (new CallExpression (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal' compEnv.SubstituteMember (methodi.Method)' CallerArguments (methodi.Constrained' methodi.Method' a)))));  		else  			return stack.PopEvalPush (statements' arity' true' (a' e) => new ExpressionStackEntry (new CallExpression (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal' compEnv.SubstituteMember (methodi.Method)' CallerArguments (methodi.Constrained' methodi.Method' a))' e.Lub (CalleeEffects (methodi.BeforeState' arity))));  	case MethodOp.Newobj:  		arity--;  		return stack.PopEvalPush (statements' arity' true' (a' e) => new ExpressionStackEntry (new NewObjectExpression (compEnv.SubstituteMember (methodi.Method)' CallerArguments (null' methodi.Method' a))' e.Lub (CalleeEffects (methodi.BeforeState' arity))));  	case MethodOp.Ldtoken:  		stack.Push (new ExpressionStackEntry (new MethodHandleConstantExpression (compEnv.SubstituteMember (methodi.Method))' BottomE));  		return true;  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Type: {  	var typei = (TypeInstruction)instruction;  	switch (typei.Op) {  	case TypeOp.Ldobj:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ReadExpression (a [0]).CloneIfStruct (compEnv)' e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ())));  	case TypeOp.Stobj:  		return stack.PopEvalSE (statements' 2' true' instruction.BeforeState.PeekPointsTo (1).WriteEffect ()' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' a [1]))));  	case TypeOp.Cpobj: {  		var copyEffect = instruction.BeforeState.PeekPointsTo (0).ReadEffect ().Lub (instruction.BeforeState.PeekPointsTo (1).WriteEffect ());  		return stack.PopEvalSE (statements' 2' true' copyEffect' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' new ReadExpression (a [1]).CloneIfStruct (compEnv)))));  	}  	case TypeOp.Newarr:  		// Growing the heap is not considered an observable change. But will throw if  		// length < 0  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new NewArrayExpression (a [0]' compEnv.SubstituteType (typei.Type))' e.Lub (ThrowsE)));  	case TypeOp.Initobj:  		return stack.PopEvalSE (statements' 1' true' WriteHeapE' (s' a) => s.Add (new InitializeObjectStatement (a [0])));  	case TypeOp.Castclass:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new CastExpression (a [0]' compEnv.SubstituteType (typei.Type))' e.Lub (ThrowsE)));  	case TypeOp.Isinst:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new IsInstExpression (a [0]' compEnv.SubstituteType (typei.Type))' e));  	case TypeOp.Box:  		// Growing the heap is not considered an observable change  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new NewBoxExpression (a [0]' compEnv.SubstituteType (typei.Type))' e));  	case TypeOp.Unbox:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new BoxCell (a [0]' compEnv.SubstituteType (typei.Type)).AddressOf ()' e.Lub (ThrowsE)));  	case TypeOp.UnboxAny:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new BoxCell (a [0]' compEnv.SubstituteType (typei.Type)).Read ().CloneIfStruct (compEnv)' e.Lub (ThrowsE)));  	case TypeOp.Ldtoken:  		stack.Push (new ExpressionStackEntry (new TypeHandleConstantExpression (compEnv.SubstituteType (typei.Type))' BottomE));  		return true;  	case TypeOp.Ldelem:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' true).Read ().CloneIfStruct (compEnv)' e.Lub (ReadHeapOrThrowE)));  	case TypeOp.Stelem:  		return stack.PopEvalSE (statements' 3' true' WriteHeapOrThrowE' (s' a) => s.Add (new ExpressionStatement (new ElementCell (a [0]' a [1]' false).Write (a [2]))));  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.LdElemAddr:  	// Calculating the pointer may throw if index is out of range.  	// Remaining effect will be accounted for when pointer is read/written.  	return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' false).AddressOf ()' e.Lub (ThrowsE)));  case InstructionFlavor.LdInt32: {  	var int32i = (LdInt32Instruction)instruction;  	stack.Push (new ExpressionStackEntry (new Int32ConstantExpression (int32i.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdInt64: {  	var int64i = (LdInt64Instruction)instruction;  	stack.Push (new ExpressionStackEntry (new Int64ConstantExpression (int64i.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdSingle: {  	var singlei = (LdSingleInstruction)instruction;  	stack.Push (new ExpressionStackEntry (new SingleConstantExpression (singlei.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdDouble: {  	var doublei = (LdDoubleInstruction)instruction;  	stack.Push (new ExpressionStackEntry (new DoubleConstantExpression (doublei.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdString: {  	var stringi = (LdStringInstruction)instruction;  	stack.Push (new ExpressionStackEntry (new StringConstantExpression (stringi.Value)' BottomE));  	return true;  }  case InstructionFlavor.Arith: {  	var arithi = (ArithInstruction)instruction;  	switch (arithi.Op) {  	case ArithOp.Div:  	case ArithOp.Rem:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new BinaryExpression (a [0]' ArithOpToBinaryOp (arithi.Op)' a [1]' arithi.WithOverflow' arithi.IsUnsigned)' e.Lub (ThrowsE)));  	case ArithOp.Add:  	case ArithOp.Sub:  	case ArithOp.Mul:  	case ArithOp.BitAnd:  	case ArithOp.BitOr:  	case ArithOp.BitXor:  	case ArithOp.Shl:  	case ArithOp.Shr:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new BinaryExpression (a [0]' ArithOpToBinaryOp (arithi.Op)' a [1]' arithi.WithOverflow' arithi.IsUnsigned)' e.Lub (arithi.WithOverflow ? ThrowsE : BottomE)));  	case ArithOp.Neg:  	case ArithOp.BitNot:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' ArithOpToUnaryOp (arithi.Op)' arithi.WithOverflow' arithi.IsUnsigned)' e));  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Conv: {  	var convi = (ConvInstruction)instruction;  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ConvertExpression (a [0]' new NamedTypeRef (compEnv.Global.NumberFlavorToQualifiedTypeName [convi.TargetNumberFlavor])' convi.WithOverflow' convi.IsSourceUnsigned)' e.Lub (convi.WithOverflow ? ThrowsE : BottomE)));  }  case InstructionFlavor.Try: {  	if (stack.Depth > 0)  		throw new InvalidOperationException ("stack must be empty on entry to try block");  	var tryi = (TryInstruction)instruction;  	var tryStatements = BlockToTryFaultFinallyStatements (tryi.Body);  	if (tryStatements == null)  		return false;  	var handlers = TranslateHandlers (tryi.Handlers);  	if (handlers == null)  		return false;  	if (statements == null)  		return Failed (false' "try");  	statements.Add (new TryStatement (tryStatements' handlers));  	return true;  }  case InstructionFlavor.IfThenElsePseudo: {  	var itei = (IfThenElseInstruction)instruction;  	var isExpr = default(bool);  	// If outer context is re-translating as statements instead of expression' jump directly  	// to appropriate translation for this instruction  	var couldBeExpression = !instructionTranslationStyleCache.TryGetValue (itei.Offset' out isExpr) || isExpr;  	if (!TranslateBlock (statements' itei.Condition' stack' exid))  		return false;  	if (couldBeExpression && itei.Else != null) {  		// Pass 1: Try to tranlate to an if-then-else expression. Will only work if Then and Else don't  		//         reach into current stack' push exactly one value' and don't need to emit any  		//         statements along the way.  		var thenEntry = BlockToExpression (itei.Then' exid);  		if (thenEntry != null) {  			var elseEntry = BlockToExpression (itei.Else' exid);  			if (elseEntry != null) {  				if (!instructionTranslationStyleCache.ContainsKey (itei.Offset))  					instructionTranslationStyleCache.Add (itei.Offset' true);  				return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new IfThenElseExpression (a [0]' thenEntry.Expression' elseEntry.Expression)' e.Lub (thenEntry.Effects.Lub (elseEntry.Effects))));  			}  			// else: fallthrough  		}  		// else: fallthrough  	}  	// else: fallthrough  	// Pass 2: Translate to a statement  	var noStackChange = itei.Then.NoStackChange && (itei.Else == null || itei.Else.NoStackChange);  	var condEntry = noStackChange ? stack.Pop () : stack.FlushAndPopPostState (statements' itei.Then.BeforeState);  	if (condEntry == null)  		return false;  	var thenStmnts = noStackChange ? BlockToStatementsEmptyStack (itei.Then' exid) : BlockToStatements (itei.Then' exid);  	if (thenStmnts == null)  		return false;  	var elseStmnts = default(Seq<Statement>);  	if (itei.Else != null) {  		elseStmnts = noStackChange ? BlockToStatementsEmptyStack (itei.Else' exid) : BlockToStatements (itei.Else' exid);  		if (elseStmnts == null)  			return false;  	}  	if (statements == null)  		return Failed (false' "if-then-else");  	statements.Add (new IfThenElseStatement (condEntry.Expression' new Statements (thenStmnts)' elseStmnts == null ? null : new Statements (elseStmnts)));  	if (!noStackChange && !stack.Restore (itei.AfterState' 0))  		return false;  	if (!instructionTranslationStyleCache.ContainsKey (itei.Offset))  		instructionTranslationStyleCache.Add (itei.Offset' false);  	return true;  }  case InstructionFlavor.ShortCircuitingPseudo: {  	var sci = (ShortCircuitingInstruction)instruction;  	var isExpr = default(bool);  	// If outer context is re-translating as statements instead of expression' jump directly  	// to appropriate translation for this instruction  	var couldBeExpression = !instructionTranslationStyleCache.TryGetValue (sci.Offset' out isExpr) || isExpr;  	if (couldBeExpression) {  		// Pass 1: Try to translate to an expression.  		var leftEntry = BlockToExpression (sci.Left' exid);  		if (leftEntry != null) {  			var rightEntry = BlockToExpression (sci.Right' exid);  			if (rightEntry != null) {  				stack.Push (new ExpressionStackEntry (new BinaryExpression (leftEntry.Expression' ShortCircuitingOpToBinaryOp (sci.Op)' rightEntry.Expression' false' false)' leftEntry.Effects.Lub (rightEntry.Effects)));  				if (!instructionTranslationStyleCache.ContainsKey (sci.Offset))  					instructionTranslationStyleCache.Add (sci.Offset' true);  				return true;  			}  			// else: fallthrough  		}  		// else: fallthrough  	}  	// else: fallthrough  	// Pass 2: Translate to a statement  	if (!TranslateBlock (statements' sci.Left' stack' exid))  		return false;  	var leftEntry2 = stack.FlushAndPopPostState (statements' sci.Right.BeforeState);  	if (leftEntry2 == null)  		return false;  	var rightStatements = BlockToStatements (sci.Right' exid);  	if (rightStatements == null)  		return false;  	var id = sci.Right.AfterState.PeekId (0' nameSupply.GenSym);  	var cell = new VariableCell (id);  	compEnv.AddVariable (id' ArgLocal.Local' false' true' compEnv.SubstituteType (sci.Right.AfterState.PeekType (0)));  	if (statements == null)  		return Failed (false' "short-circuit");  	switch (sci.Op) {  	case ShortCircuitingOp.And:  		statements.Add (new IfThenElseStatement (leftEntry2.Expression' new Statements (rightStatements)' new Statements (new ExpressionStatement (cell.Write (new Int32ConstantExpression (0))))));  		break;  	case ShortCircuitingOp.Or:  		statements.Add (new IfThenElseStatement (leftEntry2.Expression' new Statements (new ExpressionStatement (cell.Write (new Int32ConstantExpression (1))))' new Statements (rightStatements)));  		break;  	default:  		throw new ArgumentOutOfRangeException ();  	}  	if (!stack.Restore (sci.AfterState' 1))  		return false;  	stack.Push (new ExpressionStackEntry (cell.Read ()' BottomE));  	if (!instructionTranslationStyleCache.ContainsKey (sci.Offset))  		instructionTranslationStyleCache.Add (sci.Offset' false);  	return true;  }  case InstructionFlavor.StructuralSwitchPseudo: {  	var ssi = (StructuralSwitchInstruction)instruction;  	if (!TranslateBlock (statements' ssi.Body' stack' exid))  		return false;  	var valueEntry = stack.FlushAndPopPreState (statements' ssi.Body.AfterState);  	if (valueEntry == null)  		return false;  	var cases = new Seq<SwitchStatementCase> ();  	foreach (var c in ssi.Cases) {  		var caseStatements = BlockToStatements (c.Body' exid);  		if (caseStatements == null)  			return false;  		cases.Add (new SwitchStatementCase (c.Values' new Statements (caseStatements)));  	}  	if (statements == null)  		return Failed (false' "structural switch");  	statements.Add (new SwitchStatement (valueEntry.Expression' cases));  	if (!stack.Restore (ssi.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.LoopPseudo: {  	var li = (LoopInstruction)instruction;  	if (!stack.Flush (statements' li.Body.BeforeState))  		return false;  	if (statements == null)  		return Failed (false' "loop");  	var whileStatements = BlockToStatements (li.Body' exid);  	statements.Add (new WhileDoStatement (new Int32ConstantExpression (1)' new Statements (whileStatements)));  	if (!stack.Restore (li.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.WhileDoPseudo: {  	var wdi = (WhileDoInstruction)instruction;  	if (!stack.Flush (statements' wdi.Condition.BeforeState))  		return false;  	var condEntry = BlockToExpression (wdi.Condition' exid);  	if (condEntry == null) {  		var stack1 = new ExpressionStack (compEnv' BottomE' nameSupply.GenSym' wdi.Condition.BeforeState' trace);  		var preCondStatements = new Seq<Statement> ();  		if (!TranslateBlock (preCondStatements' wdi.Condition' stack1' exid))  			return false;  		condEntry = stack1.FlushAndPopPostState (preCondStatements' wdi.Body.BeforeState);  		if (condEntry == null)  			return false;  		var stack2 = new ExpressionStack (compEnv' BottomE' nameSupply.GenSym' wdi.Body.BeforeState' trace);  		var postCondStatements = new Seq<Statement> ();  		if (!TranslateBlock (postCondStatements' wdi.Body' stack2' exid))  			return false;  		if (!stack2.Flush (postCondStatements' wdi.Body.AfterState))  			return false;  		preCondStatements.Add (new IfThenElseStatement (condEntry.Expression' new Statements (postCondStatements)' new Statements (new BreakStatement ())));  		statements.Add (new WhileDoStatement (new Int32ConstantExpression (1)' new Statements (preCondStatements)));  	}  	else {  		var loopStatements = BlockToStatements (wdi.Body' exid);  		if (loopStatements == null)  			return false;  		if (statements == null)  			return Failed (false' "while-do");  		statements.Add (new WhileDoStatement (condEntry.Expression' new Statements (loopStatements)));  	}  	if (!stack.Restore (wdi.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.DoWhilePseudo: {  	var dwi = (DoWhileInstruction)instruction;  	if (!stack.Flush (statements' dwi.Body.BeforeState))  		return false;  	var combined = new Seq<Instruction> ();  	foreach (var i in dwi.Body.Body)  		combined.Add (i);  	foreach (var i in dwi.Condition.Body)  		combined.Add (i);  	var condEntry = default(ExpressionStackEntry);  	var loopStatements = BlockToConditionStatements (new Instructions (null' combined)' dwi.Body.BeforeState' exid' out condEntry);  	if (loopStatements == null)  		return false;  	if (statements == null)  		return Failed (false' "do-while");  	statements.Add (new DoWhileStatement (new Statements (loopStatements)' condEntry.Expression));  	if (!stack.Restore (dwi.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.LoopControlPseudo: {  	var lci = (BreakContinueInstruction)instruction;  	if (!stack.Flush (statements' lci.BeforeState))  		return false;  	if (statements == null)  		return Failed (false' "loop-control");  	var targetState = default(int);  	switch (lci.Op) {  	case BreakContinueOp.Break:  		if (labelToLoopCandidateBreakState != null && labelToLoopCandidateBreakState.TryGetValue (lci.Label' out targetState))  			statements.Add (new GotoPseudoStatement (stateId' targetState));  		else  			statements.Add (new BreakStatement (lci.Label));  		break;  	case BreakContinueOp.Continue:  		if (labelToLoopCandidateContinueState != null && labelToLoopCandidateContinueState.TryGetValue (lci.Label' out targetState))  			statements.Add (new GotoPseudoStatement (stateId' targetState));  		else  			statements.Add (new ContinueStatement (lci.Label));  		break;  	default:  		throw new ArgumentOutOfRangeException ();  	}  	return true;  }  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (instruction.Flavor) {  case InstructionFlavor.Unsupported:  	throw new InvalidOperationException ("unsupported opcode");  case InstructionFlavor.Misc: {  	var misci = (MiscInstruction)instruction;  	switch (misci.Op) {  	case MiscOp.Nop:  	case MiscOp.Break:  		return true;  	case MiscOp.Dup:  		return stack.Dup (statements);  	case MiscOp.Pop:  		return stack.PopAndDiscard (statements);  	case MiscOp.Ldnull:  		stack.Push (new ExpressionStackEntry (new NullConstantExpression ()' BottomE));  		return true;  	case MiscOp.Ckfinite:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' UnaryOp.CheckFinite' false' false)' e.Lub (ThrowsE)));  	case MiscOp.Throw:  		if (!stack.DiscardAll (statements' 1))  			return false;  		if (!stack.PopEvalSE (statements' 1' true' ThrowsE' (s' a) => s.Add (new ThrowStatement (a [0]))))  			return false;  		return true;  	case MiscOp.Rethrow:  		if (!stack.DiscardAll (statements' 0))  			return false;  		if (statements == null)  			return Failed (false' "rethrow");  		if (exid == null)  			throw new InvalidOperationException ("rethrow outside of catch");  		statements.Add (new RethrowStatement (new VariableCell (exid).Read ()));  		return true;  	case MiscOp.LdindRef:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ReadExpression (a [0]).CloneIfStruct (compEnv)' e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ())));  	case MiscOp.LdelemRef:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' true).Read ().CloneIfStruct (compEnv)' e.Lub (ReadHeapOrThrowE)));  	case MiscOp.Ldlen:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' UnaryOp.Length' false' false)' e.Lub (ReadHeapOrThrowE)));  	case MiscOp.StindRef:  		return stack.PopEvalSE (statements' 2' true' instruction.BeforeState.PeekPointsTo (1).WriteEffect ()' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' a [1]))));  	case MiscOp.StelemRef:  		return stack.PopEvalSE (statements' 3' true' WriteHeapOrThrowE' (s' a) => s.Add (new ExpressionStatement (new ElementCell (a [0]' a [1]' false).Write (a [2]))));  	case MiscOp.Ret:  		if (statements == null)  			return Failed (false' "return");  		statements.Add (new ReturnStatement (null));  		return true;  	case MiscOp.RetVal:  		return stack.PopEvalSE (statements' 1' true' BottomE' (s' a) => s.Add (new ReturnStatement (a [0])));  	case MiscOp.Endfilter:  	case MiscOp.Endfinally:  		throw new InvalidOperationException ("endfilter/endfinally instructions should have been removed");  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Branch:  case InstructionFlavor.Switch:  	throw new InvalidOperationException ("branch/switch instructions should have been removed");  case InstructionFlavor.Compare: {  	var cmpi = (CompareInstruction)instruction;  	if (cmpi.Op == CompareOp.CtruePseudo || cmpi.Op == CompareOp.CfalsePseudo) {  		var s = cmpi.Type.Style (compEnv);  		var unop = default(UnaryOp);  		if (s is NumberTypeStyle)  			unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonZero : UnaryOp.IsZero;  		else  			unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonNull : UnaryOp.IsNull;  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' unop' false' cmpi.IsUnsigned)' e));  	}  	else {  		var binop = default(BinaryOp);  		switch (cmpi.Op) {  		case CompareOp.Ceq:  			binop = BinaryOp.Eq;  			break;  		case CompareOp.Clt:  			binop = BinaryOp.Lt;  			break;  		case CompareOp.Cgt:  			binop = BinaryOp.Gt;  			break;  		case CompareOp.CgePseudo:  			binop = BinaryOp.Ge;  			break;  		case CompareOp.ClePseudo:  			binop = BinaryOp.Le;  			break;  		case CompareOp.CnePseudo:  			binop = BinaryOp.Ne;  			break;  		case CompareOp.CtruePseudo:  		case CompareOp.CfalsePseudo:  			// handled above  			throw new InvalidOperationException ();  		default:  			throw new ArgumentOutOfRangeException ();  		}  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new BinaryExpression (a [0]' binop' a [1]' false' cmpi.IsUnsigned)' e));  	}  }  case InstructionFlavor.ArgLocal: {  	var sli = (ArgLocalInstruction)instruction;  	var id = default(JST.Identifier);  	switch (sli.ArgLocal) {  	case ArgLocal.Arg:  		id = compEnv.ValueParameterIds [sli.Index];  		break;  	case ArgLocal.Local:  		id = compEnv.LocalIds [sli.Index];  		break;  	default:  		throw new ArgumentOutOfRangeException ();  	}  	var cell = new VariableCell (id);  	switch (sli.Op) {  	case ArgLocalOp.Ld:  		stack.Push (new ExpressionStackEntry (cell.Read ().CloneIfStruct (compEnv)' ReadArgLocalE (sli.ArgLocal' sli.Index)));  		return true;  	case ArgLocalOp.Lda:  		// Effect will be accounted for on reads/writes  		stack.Push (new ExpressionStackEntry (cell.AddressOf ()' BottomE));  		return true;  	case ArgLocalOp.St:  		return stack.PopEvalSE (statements' 1' true' WriteArgLocalE (sli.ArgLocal' sli.Index)' (s' a) => s.Add (new ExpressionStatement (cell.Write (a [0]))));  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Field: {  	var fieldi = (FieldInstruction)instruction;  	switch (fieldi.Op) {  	case FieldOp.Ldfld:  		if (fieldi.IsStatic) {  			stack.Push (new ExpressionStackEntry (new FieldCell (null' compEnv.SubstituteMember (fieldi.Field)).Read ().CloneIfStruct (compEnv)' ReadHeapE));  			return true;  		}  		else  			return stack.PopEvalPush (statements' 1' true' (a' e) =>  {  				var readEffect = default(Effects);  				var obj = default(Expression);  				if (fieldi.IsViaPointer.Value) {  					readEffect = e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ());  					obj = new ReadExpression (a [0]);  					// no need for clone  				}  				else if (fieldi.Field.DefiningType.Style (compEnv) is ValueTypeStyle) {  					readEffect = e;  					obj = a [0];  				}  				else {  					// Object could be null  					readEffect = e.Lub (ReadHeapOrThrowE);  					obj = a [0];  				}  				return new ExpressionStackEntry (new FieldCell (obj' compEnv.SubstituteMember (fieldi.Field)).Read ().CloneIfStruct (compEnv)' readEffect);  			});  	case FieldOp.Ldflda:  		if (fieldi.IsStatic) {  			// Effect will be accounted for on reads/writes  			stack.Push (new ExpressionStackEntry (new FieldCell (null' compEnv.SubstituteMember (fieldi.Field)).AddressOf ()' BottomE));  			return true;  		}  		else  			return stack.PopEvalPush (statements' 1' true' (a' e) =>  {  				if (fieldi.IsViaPointer.Value)  					// We're just adding an offset to a pointer' so effect will  					// be accounted for when the final pointer is read/written  					return new ExpressionStackEntry (new FieldCell (new ReadExpression (a [0])' compEnv.SubstituteMember (fieldi.Field)).AddressOf ()' e);  				else  					// Must be a reference type' and ref could be null  					return new ExpressionStackEntry (new FieldCell (a [0]' compEnv.SubstituteMember (fieldi.Field)).AddressOf ()' e.Lub (ThrowsE));  			});  	case FieldOp.Stfld:  		if (fieldi.IsStatic)  			return stack.PopEvalSE (statements' 1' true' WriteHeapE' (s' a) => s.Add (new ExpressionStatement (new FieldCell (null' compEnv.SubstituteMember (fieldi.Field)).Write (a [0]))));  		else {  			var writeEffect = fieldi.IsViaPointer.Value ? instruction.BeforeState.PeekPointsTo (1).WriteEffect () : WriteHeapOrThrowE;  			return stack.PopEvalSE (statements' 2' true' writeEffect' (s' a) =>  {  				var obj = fieldi.IsViaPointer.Value ? new ReadExpression (a [0]) : a [0];  				s.Add (new ExpressionStatement (new FieldCell (obj' compEnv.SubstituteMember (fieldi.Field)).Write (a [1])));  			});  		}  	case FieldOp.Ldtoken:  		stack.Push (new ExpressionStackEntry (new FieldHandleConstantExpression (compEnv.SubstituteMember (fieldi.Field))' BottomE));  		return true;  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Method: {  	var methodi = (MethodInstruction)instruction;  	var arity = methodi.Method.ValueParameters.Count;  	switch (methodi.Op) {  	case MethodOp.Ldftn:  		if (methodi.IsVirtual)  			// Object could be null  			return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new CodePointerExpression (a [0]' compEnv.SubstituteMember (methodi.Method))' e.Lub (ReadHeapOrThrowE)));  		else {  			stack.Push (new ExpressionStackEntry (new CodePointerExpression (null' compEnv.SubstituteMember (methodi.Method))' BottomE));  			return true;  		}  	case MethodOp.Call:  		if (methodi.Method.Result == null)  			return stack.PopEvalSE (statements' arity' true' CalleeEffects (methodi.BeforeState' arity)' (s' a) => s.Add (new ExpressionStatement (new CallExpression (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal' compEnv.SubstituteMember (methodi.Method)' CallerArguments (methodi.Constrained' methodi.Method' a)))));  		else  			return stack.PopEvalPush (statements' arity' true' (a' e) => new ExpressionStackEntry (new CallExpression (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal' compEnv.SubstituteMember (methodi.Method)' CallerArguments (methodi.Constrained' methodi.Method' a))' e.Lub (CalleeEffects (methodi.BeforeState' arity))));  	case MethodOp.Newobj:  		arity--;  		return stack.PopEvalPush (statements' arity' true' (a' e) => new ExpressionStackEntry (new NewObjectExpression (compEnv.SubstituteMember (methodi.Method)' CallerArguments (null' methodi.Method' a))' e.Lub (CalleeEffects (methodi.BeforeState' arity))));  	case MethodOp.Ldtoken:  		stack.Push (new ExpressionStackEntry (new MethodHandleConstantExpression (compEnv.SubstituteMember (methodi.Method))' BottomE));  		return true;  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Type: {  	var typei = (TypeInstruction)instruction;  	switch (typei.Op) {  	case TypeOp.Ldobj:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ReadExpression (a [0]).CloneIfStruct (compEnv)' e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ())));  	case TypeOp.Stobj:  		return stack.PopEvalSE (statements' 2' true' instruction.BeforeState.PeekPointsTo (1).WriteEffect ()' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' a [1]))));  	case TypeOp.Cpobj: {  		var copyEffect = instruction.BeforeState.PeekPointsTo (0).ReadEffect ().Lub (instruction.BeforeState.PeekPointsTo (1).WriteEffect ());  		return stack.PopEvalSE (statements' 2' true' copyEffect' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' new ReadExpression (a [1]).CloneIfStruct (compEnv)))));  	}  	case TypeOp.Newarr:  		// Growing the heap is not considered an observable change. But will throw if  		// length < 0  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new NewArrayExpression (a [0]' compEnv.SubstituteType (typei.Type))' e.Lub (ThrowsE)));  	case TypeOp.Initobj:  		return stack.PopEvalSE (statements' 1' true' WriteHeapE' (s' a) => s.Add (new InitializeObjectStatement (a [0])));  	case TypeOp.Castclass:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new CastExpression (a [0]' compEnv.SubstituteType (typei.Type))' e.Lub (ThrowsE)));  	case TypeOp.Isinst:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new IsInstExpression (a [0]' compEnv.SubstituteType (typei.Type))' e));  	case TypeOp.Box:  		// Growing the heap is not considered an observable change  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new NewBoxExpression (a [0]' compEnv.SubstituteType (typei.Type))' e));  	case TypeOp.Unbox:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new BoxCell (a [0]' compEnv.SubstituteType (typei.Type)).AddressOf ()' e.Lub (ThrowsE)));  	case TypeOp.UnboxAny:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new BoxCell (a [0]' compEnv.SubstituteType (typei.Type)).Read ().CloneIfStruct (compEnv)' e.Lub (ThrowsE)));  	case TypeOp.Ldtoken:  		stack.Push (new ExpressionStackEntry (new TypeHandleConstantExpression (compEnv.SubstituteType (typei.Type))' BottomE));  		return true;  	case TypeOp.Ldelem:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' true).Read ().CloneIfStruct (compEnv)' e.Lub (ReadHeapOrThrowE)));  	case TypeOp.Stelem:  		return stack.PopEvalSE (statements' 3' true' WriteHeapOrThrowE' (s' a) => s.Add (new ExpressionStatement (new ElementCell (a [0]' a [1]' false).Write (a [2]))));  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.LdElemAddr:  	// Calculating the pointer may throw if index is out of range.  	// Remaining effect will be accounted for when pointer is read/written.  	return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' false).AddressOf ()' e.Lub (ThrowsE)));  case InstructionFlavor.LdInt32: {  	var int32i = (LdInt32Instruction)instruction;  	stack.Push (new ExpressionStackEntry (new Int32ConstantExpression (int32i.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdInt64: {  	var int64i = (LdInt64Instruction)instruction;  	stack.Push (new ExpressionStackEntry (new Int64ConstantExpression (int64i.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdSingle: {  	var singlei = (LdSingleInstruction)instruction;  	stack.Push (new ExpressionStackEntry (new SingleConstantExpression (singlei.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdDouble: {  	var doublei = (LdDoubleInstruction)instruction;  	stack.Push (new ExpressionStackEntry (new DoubleConstantExpression (doublei.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdString: {  	var stringi = (LdStringInstruction)instruction;  	stack.Push (new ExpressionStackEntry (new StringConstantExpression (stringi.Value)' BottomE));  	return true;  }  case InstructionFlavor.Arith: {  	var arithi = (ArithInstruction)instruction;  	switch (arithi.Op) {  	case ArithOp.Div:  	case ArithOp.Rem:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new BinaryExpression (a [0]' ArithOpToBinaryOp (arithi.Op)' a [1]' arithi.WithOverflow' arithi.IsUnsigned)' e.Lub (ThrowsE)));  	case ArithOp.Add:  	case ArithOp.Sub:  	case ArithOp.Mul:  	case ArithOp.BitAnd:  	case ArithOp.BitOr:  	case ArithOp.BitXor:  	case ArithOp.Shl:  	case ArithOp.Shr:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new BinaryExpression (a [0]' ArithOpToBinaryOp (arithi.Op)' a [1]' arithi.WithOverflow' arithi.IsUnsigned)' e.Lub (arithi.WithOverflow ? ThrowsE : BottomE)));  	case ArithOp.Neg:  	case ArithOp.BitNot:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' ArithOpToUnaryOp (arithi.Op)' arithi.WithOverflow' arithi.IsUnsigned)' e));  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Conv: {  	var convi = (ConvInstruction)instruction;  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ConvertExpression (a [0]' new NamedTypeRef (compEnv.Global.NumberFlavorToQualifiedTypeName [convi.TargetNumberFlavor])' convi.WithOverflow' convi.IsSourceUnsigned)' e.Lub (convi.WithOverflow ? ThrowsE : BottomE)));  }  case InstructionFlavor.Try: {  	if (stack.Depth > 0)  		throw new InvalidOperationException ("stack must be empty on entry to try block");  	var tryi = (TryInstruction)instruction;  	var tryStatements = BlockToTryFaultFinallyStatements (tryi.Body);  	if (tryStatements == null)  		return false;  	var handlers = TranslateHandlers (tryi.Handlers);  	if (handlers == null)  		return false;  	if (statements == null)  		return Failed (false' "try");  	statements.Add (new TryStatement (tryStatements' handlers));  	return true;  }  case InstructionFlavor.IfThenElsePseudo: {  	var itei = (IfThenElseInstruction)instruction;  	var isExpr = default(bool);  	// If outer context is re-translating as statements instead of expression' jump directly  	// to appropriate translation for this instruction  	var couldBeExpression = !instructionTranslationStyleCache.TryGetValue (itei.Offset' out isExpr) || isExpr;  	if (!TranslateBlock (statements' itei.Condition' stack' exid))  		return false;  	if (couldBeExpression && itei.Else != null) {  		// Pass 1: Try to tranlate to an if-then-else expression. Will only work if Then and Else don't  		//         reach into current stack' push exactly one value' and don't need to emit any  		//         statements along the way.  		var thenEntry = BlockToExpression (itei.Then' exid);  		if (thenEntry != null) {  			var elseEntry = BlockToExpression (itei.Else' exid);  			if (elseEntry != null) {  				if (!instructionTranslationStyleCache.ContainsKey (itei.Offset))  					instructionTranslationStyleCache.Add (itei.Offset' true);  				return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new IfThenElseExpression (a [0]' thenEntry.Expression' elseEntry.Expression)' e.Lub (thenEntry.Effects.Lub (elseEntry.Effects))));  			}  			// else: fallthrough  		}  		// else: fallthrough  	}  	// else: fallthrough  	// Pass 2: Translate to a statement  	var noStackChange = itei.Then.NoStackChange && (itei.Else == null || itei.Else.NoStackChange);  	var condEntry = noStackChange ? stack.Pop () : stack.FlushAndPopPostState (statements' itei.Then.BeforeState);  	if (condEntry == null)  		return false;  	var thenStmnts = noStackChange ? BlockToStatementsEmptyStack (itei.Then' exid) : BlockToStatements (itei.Then' exid);  	if (thenStmnts == null)  		return false;  	var elseStmnts = default(Seq<Statement>);  	if (itei.Else != null) {  		elseStmnts = noStackChange ? BlockToStatementsEmptyStack (itei.Else' exid) : BlockToStatements (itei.Else' exid);  		if (elseStmnts == null)  			return false;  	}  	if (statements == null)  		return Failed (false' "if-then-else");  	statements.Add (new IfThenElseStatement (condEntry.Expression' new Statements (thenStmnts)' elseStmnts == null ? null : new Statements (elseStmnts)));  	if (!noStackChange && !stack.Restore (itei.AfterState' 0))  		return false;  	if (!instructionTranslationStyleCache.ContainsKey (itei.Offset))  		instructionTranslationStyleCache.Add (itei.Offset' false);  	return true;  }  case InstructionFlavor.ShortCircuitingPseudo: {  	var sci = (ShortCircuitingInstruction)instruction;  	var isExpr = default(bool);  	// If outer context is re-translating as statements instead of expression' jump directly  	// to appropriate translation for this instruction  	var couldBeExpression = !instructionTranslationStyleCache.TryGetValue (sci.Offset' out isExpr) || isExpr;  	if (couldBeExpression) {  		// Pass 1: Try to translate to an expression.  		var leftEntry = BlockToExpression (sci.Left' exid);  		if (leftEntry != null) {  			var rightEntry = BlockToExpression (sci.Right' exid);  			if (rightEntry != null) {  				stack.Push (new ExpressionStackEntry (new BinaryExpression (leftEntry.Expression' ShortCircuitingOpToBinaryOp (sci.Op)' rightEntry.Expression' false' false)' leftEntry.Effects.Lub (rightEntry.Effects)));  				if (!instructionTranslationStyleCache.ContainsKey (sci.Offset))  					instructionTranslationStyleCache.Add (sci.Offset' true);  				return true;  			}  			// else: fallthrough  		}  		// else: fallthrough  	}  	// else: fallthrough  	// Pass 2: Translate to a statement  	if (!TranslateBlock (statements' sci.Left' stack' exid))  		return false;  	var leftEntry2 = stack.FlushAndPopPostState (statements' sci.Right.BeforeState);  	if (leftEntry2 == null)  		return false;  	var rightStatements = BlockToStatements (sci.Right' exid);  	if (rightStatements == null)  		return false;  	var id = sci.Right.AfterState.PeekId (0' nameSupply.GenSym);  	var cell = new VariableCell (id);  	compEnv.AddVariable (id' ArgLocal.Local' false' true' compEnv.SubstituteType (sci.Right.AfterState.PeekType (0)));  	if (statements == null)  		return Failed (false' "short-circuit");  	switch (sci.Op) {  	case ShortCircuitingOp.And:  		statements.Add (new IfThenElseStatement (leftEntry2.Expression' new Statements (rightStatements)' new Statements (new ExpressionStatement (cell.Write (new Int32ConstantExpression (0))))));  		break;  	case ShortCircuitingOp.Or:  		statements.Add (new IfThenElseStatement (leftEntry2.Expression' new Statements (new ExpressionStatement (cell.Write (new Int32ConstantExpression (1))))' new Statements (rightStatements)));  		break;  	default:  		throw new ArgumentOutOfRangeException ();  	}  	if (!stack.Restore (sci.AfterState' 1))  		return false;  	stack.Push (new ExpressionStackEntry (cell.Read ()' BottomE));  	if (!instructionTranslationStyleCache.ContainsKey (sci.Offset))  		instructionTranslationStyleCache.Add (sci.Offset' false);  	return true;  }  case InstructionFlavor.StructuralSwitchPseudo: {  	var ssi = (StructuralSwitchInstruction)instruction;  	if (!TranslateBlock (statements' ssi.Body' stack' exid))  		return false;  	var valueEntry = stack.FlushAndPopPreState (statements' ssi.Body.AfterState);  	if (valueEntry == null)  		return false;  	var cases = new Seq<SwitchStatementCase> ();  	foreach (var c in ssi.Cases) {  		var caseStatements = BlockToStatements (c.Body' exid);  		if (caseStatements == null)  			return false;  		cases.Add (new SwitchStatementCase (c.Values' new Statements (caseStatements)));  	}  	if (statements == null)  		return Failed (false' "structural switch");  	statements.Add (new SwitchStatement (valueEntry.Expression' cases));  	if (!stack.Restore (ssi.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.LoopPseudo: {  	var li = (LoopInstruction)instruction;  	if (!stack.Flush (statements' li.Body.BeforeState))  		return false;  	if (statements == null)  		return Failed (false' "loop");  	var whileStatements = BlockToStatements (li.Body' exid);  	statements.Add (new WhileDoStatement (new Int32ConstantExpression (1)' new Statements (whileStatements)));  	if (!stack.Restore (li.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.WhileDoPseudo: {  	var wdi = (WhileDoInstruction)instruction;  	if (!stack.Flush (statements' wdi.Condition.BeforeState))  		return false;  	var condEntry = BlockToExpression (wdi.Condition' exid);  	if (condEntry == null) {  		var stack1 = new ExpressionStack (compEnv' BottomE' nameSupply.GenSym' wdi.Condition.BeforeState' trace);  		var preCondStatements = new Seq<Statement> ();  		if (!TranslateBlock (preCondStatements' wdi.Condition' stack1' exid))  			return false;  		condEntry = stack1.FlushAndPopPostState (preCondStatements' wdi.Body.BeforeState);  		if (condEntry == null)  			return false;  		var stack2 = new ExpressionStack (compEnv' BottomE' nameSupply.GenSym' wdi.Body.BeforeState' trace);  		var postCondStatements = new Seq<Statement> ();  		if (!TranslateBlock (postCondStatements' wdi.Body' stack2' exid))  			return false;  		if (!stack2.Flush (postCondStatements' wdi.Body.AfterState))  			return false;  		preCondStatements.Add (new IfThenElseStatement (condEntry.Expression' new Statements (postCondStatements)' new Statements (new BreakStatement ())));  		statements.Add (new WhileDoStatement (new Int32ConstantExpression (1)' new Statements (preCondStatements)));  	}  	else {  		var loopStatements = BlockToStatements (wdi.Body' exid);  		if (loopStatements == null)  			return false;  		if (statements == null)  			return Failed (false' "while-do");  		statements.Add (new WhileDoStatement (condEntry.Expression' new Statements (loopStatements)));  	}  	if (!stack.Restore (wdi.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.DoWhilePseudo: {  	var dwi = (DoWhileInstruction)instruction;  	if (!stack.Flush (statements' dwi.Body.BeforeState))  		return false;  	var combined = new Seq<Instruction> ();  	foreach (var i in dwi.Body.Body)  		combined.Add (i);  	foreach (var i in dwi.Condition.Body)  		combined.Add (i);  	var condEntry = default(ExpressionStackEntry);  	var loopStatements = BlockToConditionStatements (new Instructions (null' combined)' dwi.Body.BeforeState' exid' out condEntry);  	if (loopStatements == null)  		return false;  	if (statements == null)  		return Failed (false' "do-while");  	statements.Add (new DoWhileStatement (new Statements (loopStatements)' condEntry.Expression));  	if (!stack.Restore (dwi.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.LoopControlPseudo: {  	var lci = (BreakContinueInstruction)instruction;  	if (!stack.Flush (statements' lci.BeforeState))  		return false;  	if (statements == null)  		return Failed (false' "loop-control");  	var targetState = default(int);  	switch (lci.Op) {  	case BreakContinueOp.Break:  		if (labelToLoopCandidateBreakState != null && labelToLoopCandidateBreakState.TryGetValue (lci.Label' out targetState))  			statements.Add (new GotoPseudoStatement (stateId' targetState));  		else  			statements.Add (new BreakStatement (lci.Label));  		break;  	case BreakContinueOp.Continue:  		if (labelToLoopCandidateContinueState != null && labelToLoopCandidateContinueState.TryGetValue (lci.Label' out targetState))  			statements.Add (new GotoPseudoStatement (stateId' targetState));  		else  			statements.Add (new ContinueStatement (lci.Label));  		break;  	default:  		throw new ArgumentOutOfRangeException ();  	}  	return true;  }  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (instruction.Flavor) {  case InstructionFlavor.Unsupported:  	throw new InvalidOperationException ("unsupported opcode");  case InstructionFlavor.Misc: {  	var misci = (MiscInstruction)instruction;  	switch (misci.Op) {  	case MiscOp.Nop:  	case MiscOp.Break:  		return true;  	case MiscOp.Dup:  		return stack.Dup (statements);  	case MiscOp.Pop:  		return stack.PopAndDiscard (statements);  	case MiscOp.Ldnull:  		stack.Push (new ExpressionStackEntry (new NullConstantExpression ()' BottomE));  		return true;  	case MiscOp.Ckfinite:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' UnaryOp.CheckFinite' false' false)' e.Lub (ThrowsE)));  	case MiscOp.Throw:  		if (!stack.DiscardAll (statements' 1))  			return false;  		if (!stack.PopEvalSE (statements' 1' true' ThrowsE' (s' a) => s.Add (new ThrowStatement (a [0]))))  			return false;  		return true;  	case MiscOp.Rethrow:  		if (!stack.DiscardAll (statements' 0))  			return false;  		if (statements == null)  			return Failed (false' "rethrow");  		if (exid == null)  			throw new InvalidOperationException ("rethrow outside of catch");  		statements.Add (new RethrowStatement (new VariableCell (exid).Read ()));  		return true;  	case MiscOp.LdindRef:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ReadExpression (a [0]).CloneIfStruct (compEnv)' e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ())));  	case MiscOp.LdelemRef:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' true).Read ().CloneIfStruct (compEnv)' e.Lub (ReadHeapOrThrowE)));  	case MiscOp.Ldlen:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' UnaryOp.Length' false' false)' e.Lub (ReadHeapOrThrowE)));  	case MiscOp.StindRef:  		return stack.PopEvalSE (statements' 2' true' instruction.BeforeState.PeekPointsTo (1).WriteEffect ()' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' a [1]))));  	case MiscOp.StelemRef:  		return stack.PopEvalSE (statements' 3' true' WriteHeapOrThrowE' (s' a) => s.Add (new ExpressionStatement (new ElementCell (a [0]' a [1]' false).Write (a [2]))));  	case MiscOp.Ret:  		if (statements == null)  			return Failed (false' "return");  		statements.Add (new ReturnStatement (null));  		return true;  	case MiscOp.RetVal:  		return stack.PopEvalSE (statements' 1' true' BottomE' (s' a) => s.Add (new ReturnStatement (a [0])));  	case MiscOp.Endfilter:  	case MiscOp.Endfinally:  		throw new InvalidOperationException ("endfilter/endfinally instructions should have been removed");  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Branch:  case InstructionFlavor.Switch:  	throw new InvalidOperationException ("branch/switch instructions should have been removed");  case InstructionFlavor.Compare: {  	var cmpi = (CompareInstruction)instruction;  	if (cmpi.Op == CompareOp.CtruePseudo || cmpi.Op == CompareOp.CfalsePseudo) {  		var s = cmpi.Type.Style (compEnv);  		var unop = default(UnaryOp);  		if (s is NumberTypeStyle)  			unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonZero : UnaryOp.IsZero;  		else  			unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonNull : UnaryOp.IsNull;  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' unop' false' cmpi.IsUnsigned)' e));  	}  	else {  		var binop = default(BinaryOp);  		switch (cmpi.Op) {  		case CompareOp.Ceq:  			binop = BinaryOp.Eq;  			break;  		case CompareOp.Clt:  			binop = BinaryOp.Lt;  			break;  		case CompareOp.Cgt:  			binop = BinaryOp.Gt;  			break;  		case CompareOp.CgePseudo:  			binop = BinaryOp.Ge;  			break;  		case CompareOp.ClePseudo:  			binop = BinaryOp.Le;  			break;  		case CompareOp.CnePseudo:  			binop = BinaryOp.Ne;  			break;  		case CompareOp.CtruePseudo:  		case CompareOp.CfalsePseudo:  			// handled above  			throw new InvalidOperationException ();  		default:  			throw new ArgumentOutOfRangeException ();  		}  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new BinaryExpression (a [0]' binop' a [1]' false' cmpi.IsUnsigned)' e));  	}  }  case InstructionFlavor.ArgLocal: {  	var sli = (ArgLocalInstruction)instruction;  	var id = default(JST.Identifier);  	switch (sli.ArgLocal) {  	case ArgLocal.Arg:  		id = compEnv.ValueParameterIds [sli.Index];  		break;  	case ArgLocal.Local:  		id = compEnv.LocalIds [sli.Index];  		break;  	default:  		throw new ArgumentOutOfRangeException ();  	}  	var cell = new VariableCell (id);  	switch (sli.Op) {  	case ArgLocalOp.Ld:  		stack.Push (new ExpressionStackEntry (cell.Read ().CloneIfStruct (compEnv)' ReadArgLocalE (sli.ArgLocal' sli.Index)));  		return true;  	case ArgLocalOp.Lda:  		// Effect will be accounted for on reads/writes  		stack.Push (new ExpressionStackEntry (cell.AddressOf ()' BottomE));  		return true;  	case ArgLocalOp.St:  		return stack.PopEvalSE (statements' 1' true' WriteArgLocalE (sli.ArgLocal' sli.Index)' (s' a) => s.Add (new ExpressionStatement (cell.Write (a [0]))));  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Field: {  	var fieldi = (FieldInstruction)instruction;  	switch (fieldi.Op) {  	case FieldOp.Ldfld:  		if (fieldi.IsStatic) {  			stack.Push (new ExpressionStackEntry (new FieldCell (null' compEnv.SubstituteMember (fieldi.Field)).Read ().CloneIfStruct (compEnv)' ReadHeapE));  			return true;  		}  		else  			return stack.PopEvalPush (statements' 1' true' (a' e) =>  {  				var readEffect = default(Effects);  				var obj = default(Expression);  				if (fieldi.IsViaPointer.Value) {  					readEffect = e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ());  					obj = new ReadExpression (a [0]);  					// no need for clone  				}  				else if (fieldi.Field.DefiningType.Style (compEnv) is ValueTypeStyle) {  					readEffect = e;  					obj = a [0];  				}  				else {  					// Object could be null  					readEffect = e.Lub (ReadHeapOrThrowE);  					obj = a [0];  				}  				return new ExpressionStackEntry (new FieldCell (obj' compEnv.SubstituteMember (fieldi.Field)).Read ().CloneIfStruct (compEnv)' readEffect);  			});  	case FieldOp.Ldflda:  		if (fieldi.IsStatic) {  			// Effect will be accounted for on reads/writes  			stack.Push (new ExpressionStackEntry (new FieldCell (null' compEnv.SubstituteMember (fieldi.Field)).AddressOf ()' BottomE));  			return true;  		}  		else  			return stack.PopEvalPush (statements' 1' true' (a' e) =>  {  				if (fieldi.IsViaPointer.Value)  					// We're just adding an offset to a pointer' so effect will  					// be accounted for when the final pointer is read/written  					return new ExpressionStackEntry (new FieldCell (new ReadExpression (a [0])' compEnv.SubstituteMember (fieldi.Field)).AddressOf ()' e);  				else  					// Must be a reference type' and ref could be null  					return new ExpressionStackEntry (new FieldCell (a [0]' compEnv.SubstituteMember (fieldi.Field)).AddressOf ()' e.Lub (ThrowsE));  			});  	case FieldOp.Stfld:  		if (fieldi.IsStatic)  			return stack.PopEvalSE (statements' 1' true' WriteHeapE' (s' a) => s.Add (new ExpressionStatement (new FieldCell (null' compEnv.SubstituteMember (fieldi.Field)).Write (a [0]))));  		else {  			var writeEffect = fieldi.IsViaPointer.Value ? instruction.BeforeState.PeekPointsTo (1).WriteEffect () : WriteHeapOrThrowE;  			return stack.PopEvalSE (statements' 2' true' writeEffect' (s' a) =>  {  				var obj = fieldi.IsViaPointer.Value ? new ReadExpression (a [0]) : a [0];  				s.Add (new ExpressionStatement (new FieldCell (obj' compEnv.SubstituteMember (fieldi.Field)).Write (a [1])));  			});  		}  	case FieldOp.Ldtoken:  		stack.Push (new ExpressionStackEntry (new FieldHandleConstantExpression (compEnv.SubstituteMember (fieldi.Field))' BottomE));  		return true;  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Method: {  	var methodi = (MethodInstruction)instruction;  	var arity = methodi.Method.ValueParameters.Count;  	switch (methodi.Op) {  	case MethodOp.Ldftn:  		if (methodi.IsVirtual)  			// Object could be null  			return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new CodePointerExpression (a [0]' compEnv.SubstituteMember (methodi.Method))' e.Lub (ReadHeapOrThrowE)));  		else {  			stack.Push (new ExpressionStackEntry (new CodePointerExpression (null' compEnv.SubstituteMember (methodi.Method))' BottomE));  			return true;  		}  	case MethodOp.Call:  		if (methodi.Method.Result == null)  			return stack.PopEvalSE (statements' arity' true' CalleeEffects (methodi.BeforeState' arity)' (s' a) => s.Add (new ExpressionStatement (new CallExpression (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal' compEnv.SubstituteMember (methodi.Method)' CallerArguments (methodi.Constrained' methodi.Method' a)))));  		else  			return stack.PopEvalPush (statements' arity' true' (a' e) => new ExpressionStackEntry (new CallExpression (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal' compEnv.SubstituteMember (methodi.Method)' CallerArguments (methodi.Constrained' methodi.Method' a))' e.Lub (CalleeEffects (methodi.BeforeState' arity))));  	case MethodOp.Newobj:  		arity--;  		return stack.PopEvalPush (statements' arity' true' (a' e) => new ExpressionStackEntry (new NewObjectExpression (compEnv.SubstituteMember (methodi.Method)' CallerArguments (null' methodi.Method' a))' e.Lub (CalleeEffects (methodi.BeforeState' arity))));  	case MethodOp.Ldtoken:  		stack.Push (new ExpressionStackEntry (new MethodHandleConstantExpression (compEnv.SubstituteMember (methodi.Method))' BottomE));  		return true;  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Type: {  	var typei = (TypeInstruction)instruction;  	switch (typei.Op) {  	case TypeOp.Ldobj:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ReadExpression (a [0]).CloneIfStruct (compEnv)' e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ())));  	case TypeOp.Stobj:  		return stack.PopEvalSE (statements' 2' true' instruction.BeforeState.PeekPointsTo (1).WriteEffect ()' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' a [1]))));  	case TypeOp.Cpobj: {  		var copyEffect = instruction.BeforeState.PeekPointsTo (0).ReadEffect ().Lub (instruction.BeforeState.PeekPointsTo (1).WriteEffect ());  		return stack.PopEvalSE (statements' 2' true' copyEffect' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' new ReadExpression (a [1]).CloneIfStruct (compEnv)))));  	}  	case TypeOp.Newarr:  		// Growing the heap is not considered an observable change. But will throw if  		// length < 0  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new NewArrayExpression (a [0]' compEnv.SubstituteType (typei.Type))' e.Lub (ThrowsE)));  	case TypeOp.Initobj:  		return stack.PopEvalSE (statements' 1' true' WriteHeapE' (s' a) => s.Add (new InitializeObjectStatement (a [0])));  	case TypeOp.Castclass:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new CastExpression (a [0]' compEnv.SubstituteType (typei.Type))' e.Lub (ThrowsE)));  	case TypeOp.Isinst:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new IsInstExpression (a [0]' compEnv.SubstituteType (typei.Type))' e));  	case TypeOp.Box:  		// Growing the heap is not considered an observable change  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new NewBoxExpression (a [0]' compEnv.SubstituteType (typei.Type))' e));  	case TypeOp.Unbox:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new BoxCell (a [0]' compEnv.SubstituteType (typei.Type)).AddressOf ()' e.Lub (ThrowsE)));  	case TypeOp.UnboxAny:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new BoxCell (a [0]' compEnv.SubstituteType (typei.Type)).Read ().CloneIfStruct (compEnv)' e.Lub (ThrowsE)));  	case TypeOp.Ldtoken:  		stack.Push (new ExpressionStackEntry (new TypeHandleConstantExpression (compEnv.SubstituteType (typei.Type))' BottomE));  		return true;  	case TypeOp.Ldelem:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' true).Read ().CloneIfStruct (compEnv)' e.Lub (ReadHeapOrThrowE)));  	case TypeOp.Stelem:  		return stack.PopEvalSE (statements' 3' true' WriteHeapOrThrowE' (s' a) => s.Add (new ExpressionStatement (new ElementCell (a [0]' a [1]' false).Write (a [2]))));  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.LdElemAddr:  	// Calculating the pointer may throw if index is out of range.  	// Remaining effect will be accounted for when pointer is read/written.  	return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' false).AddressOf ()' e.Lub (ThrowsE)));  case InstructionFlavor.LdInt32: {  	var int32i = (LdInt32Instruction)instruction;  	stack.Push (new ExpressionStackEntry (new Int32ConstantExpression (int32i.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdInt64: {  	var int64i = (LdInt64Instruction)instruction;  	stack.Push (new ExpressionStackEntry (new Int64ConstantExpression (int64i.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdSingle: {  	var singlei = (LdSingleInstruction)instruction;  	stack.Push (new ExpressionStackEntry (new SingleConstantExpression (singlei.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdDouble: {  	var doublei = (LdDoubleInstruction)instruction;  	stack.Push (new ExpressionStackEntry (new DoubleConstantExpression (doublei.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdString: {  	var stringi = (LdStringInstruction)instruction;  	stack.Push (new ExpressionStackEntry (new StringConstantExpression (stringi.Value)' BottomE));  	return true;  }  case InstructionFlavor.Arith: {  	var arithi = (ArithInstruction)instruction;  	switch (arithi.Op) {  	case ArithOp.Div:  	case ArithOp.Rem:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new BinaryExpression (a [0]' ArithOpToBinaryOp (arithi.Op)' a [1]' arithi.WithOverflow' arithi.IsUnsigned)' e.Lub (ThrowsE)));  	case ArithOp.Add:  	case ArithOp.Sub:  	case ArithOp.Mul:  	case ArithOp.BitAnd:  	case ArithOp.BitOr:  	case ArithOp.BitXor:  	case ArithOp.Shl:  	case ArithOp.Shr:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new BinaryExpression (a [0]' ArithOpToBinaryOp (arithi.Op)' a [1]' arithi.WithOverflow' arithi.IsUnsigned)' e.Lub (arithi.WithOverflow ? ThrowsE : BottomE)));  	case ArithOp.Neg:  	case ArithOp.BitNot:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' ArithOpToUnaryOp (arithi.Op)' arithi.WithOverflow' arithi.IsUnsigned)' e));  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Conv: {  	var convi = (ConvInstruction)instruction;  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ConvertExpression (a [0]' new NamedTypeRef (compEnv.Global.NumberFlavorToQualifiedTypeName [convi.TargetNumberFlavor])' convi.WithOverflow' convi.IsSourceUnsigned)' e.Lub (convi.WithOverflow ? ThrowsE : BottomE)));  }  case InstructionFlavor.Try: {  	if (stack.Depth > 0)  		throw new InvalidOperationException ("stack must be empty on entry to try block");  	var tryi = (TryInstruction)instruction;  	var tryStatements = BlockToTryFaultFinallyStatements (tryi.Body);  	if (tryStatements == null)  		return false;  	var handlers = TranslateHandlers (tryi.Handlers);  	if (handlers == null)  		return false;  	if (statements == null)  		return Failed (false' "try");  	statements.Add (new TryStatement (tryStatements' handlers));  	return true;  }  case InstructionFlavor.IfThenElsePseudo: {  	var itei = (IfThenElseInstruction)instruction;  	var isExpr = default(bool);  	// If outer context is re-translating as statements instead of expression' jump directly  	// to appropriate translation for this instruction  	var couldBeExpression = !instructionTranslationStyleCache.TryGetValue (itei.Offset' out isExpr) || isExpr;  	if (!TranslateBlock (statements' itei.Condition' stack' exid))  		return false;  	if (couldBeExpression && itei.Else != null) {  		// Pass 1: Try to tranlate to an if-then-else expression. Will only work if Then and Else don't  		//         reach into current stack' push exactly one value' and don't need to emit any  		//         statements along the way.  		var thenEntry = BlockToExpression (itei.Then' exid);  		if (thenEntry != null) {  			var elseEntry = BlockToExpression (itei.Else' exid);  			if (elseEntry != null) {  				if (!instructionTranslationStyleCache.ContainsKey (itei.Offset))  					instructionTranslationStyleCache.Add (itei.Offset' true);  				return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new IfThenElseExpression (a [0]' thenEntry.Expression' elseEntry.Expression)' e.Lub (thenEntry.Effects.Lub (elseEntry.Effects))));  			}  			// else: fallthrough  		}  		// else: fallthrough  	}  	// else: fallthrough  	// Pass 2: Translate to a statement  	var noStackChange = itei.Then.NoStackChange && (itei.Else == null || itei.Else.NoStackChange);  	var condEntry = noStackChange ? stack.Pop () : stack.FlushAndPopPostState (statements' itei.Then.BeforeState);  	if (condEntry == null)  		return false;  	var thenStmnts = noStackChange ? BlockToStatementsEmptyStack (itei.Then' exid) : BlockToStatements (itei.Then' exid);  	if (thenStmnts == null)  		return false;  	var elseStmnts = default(Seq<Statement>);  	if (itei.Else != null) {  		elseStmnts = noStackChange ? BlockToStatementsEmptyStack (itei.Else' exid) : BlockToStatements (itei.Else' exid);  		if (elseStmnts == null)  			return false;  	}  	if (statements == null)  		return Failed (false' "if-then-else");  	statements.Add (new IfThenElseStatement (condEntry.Expression' new Statements (thenStmnts)' elseStmnts == null ? null : new Statements (elseStmnts)));  	if (!noStackChange && !stack.Restore (itei.AfterState' 0))  		return false;  	if (!instructionTranslationStyleCache.ContainsKey (itei.Offset))  		instructionTranslationStyleCache.Add (itei.Offset' false);  	return true;  }  case InstructionFlavor.ShortCircuitingPseudo: {  	var sci = (ShortCircuitingInstruction)instruction;  	var isExpr = default(bool);  	// If outer context is re-translating as statements instead of expression' jump directly  	// to appropriate translation for this instruction  	var couldBeExpression = !instructionTranslationStyleCache.TryGetValue (sci.Offset' out isExpr) || isExpr;  	if (couldBeExpression) {  		// Pass 1: Try to translate to an expression.  		var leftEntry = BlockToExpression (sci.Left' exid);  		if (leftEntry != null) {  			var rightEntry = BlockToExpression (sci.Right' exid);  			if (rightEntry != null) {  				stack.Push (new ExpressionStackEntry (new BinaryExpression (leftEntry.Expression' ShortCircuitingOpToBinaryOp (sci.Op)' rightEntry.Expression' false' false)' leftEntry.Effects.Lub (rightEntry.Effects)));  				if (!instructionTranslationStyleCache.ContainsKey (sci.Offset))  					instructionTranslationStyleCache.Add (sci.Offset' true);  				return true;  			}  			// else: fallthrough  		}  		// else: fallthrough  	}  	// else: fallthrough  	// Pass 2: Translate to a statement  	if (!TranslateBlock (statements' sci.Left' stack' exid))  		return false;  	var leftEntry2 = stack.FlushAndPopPostState (statements' sci.Right.BeforeState);  	if (leftEntry2 == null)  		return false;  	var rightStatements = BlockToStatements (sci.Right' exid);  	if (rightStatements == null)  		return false;  	var id = sci.Right.AfterState.PeekId (0' nameSupply.GenSym);  	var cell = new VariableCell (id);  	compEnv.AddVariable (id' ArgLocal.Local' false' true' compEnv.SubstituteType (sci.Right.AfterState.PeekType (0)));  	if (statements == null)  		return Failed (false' "short-circuit");  	switch (sci.Op) {  	case ShortCircuitingOp.And:  		statements.Add (new IfThenElseStatement (leftEntry2.Expression' new Statements (rightStatements)' new Statements (new ExpressionStatement (cell.Write (new Int32ConstantExpression (0))))));  		break;  	case ShortCircuitingOp.Or:  		statements.Add (new IfThenElseStatement (leftEntry2.Expression' new Statements (new ExpressionStatement (cell.Write (new Int32ConstantExpression (1))))' new Statements (rightStatements)));  		break;  	default:  		throw new ArgumentOutOfRangeException ();  	}  	if (!stack.Restore (sci.AfterState' 1))  		return false;  	stack.Push (new ExpressionStackEntry (cell.Read ()' BottomE));  	if (!instructionTranslationStyleCache.ContainsKey (sci.Offset))  		instructionTranslationStyleCache.Add (sci.Offset' false);  	return true;  }  case InstructionFlavor.StructuralSwitchPseudo: {  	var ssi = (StructuralSwitchInstruction)instruction;  	if (!TranslateBlock (statements' ssi.Body' stack' exid))  		return false;  	var valueEntry = stack.FlushAndPopPreState (statements' ssi.Body.AfterState);  	if (valueEntry == null)  		return false;  	var cases = new Seq<SwitchStatementCase> ();  	foreach (var c in ssi.Cases) {  		var caseStatements = BlockToStatements (c.Body' exid);  		if (caseStatements == null)  			return false;  		cases.Add (new SwitchStatementCase (c.Values' new Statements (caseStatements)));  	}  	if (statements == null)  		return Failed (false' "structural switch");  	statements.Add (new SwitchStatement (valueEntry.Expression' cases));  	if (!stack.Restore (ssi.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.LoopPseudo: {  	var li = (LoopInstruction)instruction;  	if (!stack.Flush (statements' li.Body.BeforeState))  		return false;  	if (statements == null)  		return Failed (false' "loop");  	var whileStatements = BlockToStatements (li.Body' exid);  	statements.Add (new WhileDoStatement (new Int32ConstantExpression (1)' new Statements (whileStatements)));  	if (!stack.Restore (li.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.WhileDoPseudo: {  	var wdi = (WhileDoInstruction)instruction;  	if (!stack.Flush (statements' wdi.Condition.BeforeState))  		return false;  	var condEntry = BlockToExpression (wdi.Condition' exid);  	if (condEntry == null) {  		var stack1 = new ExpressionStack (compEnv' BottomE' nameSupply.GenSym' wdi.Condition.BeforeState' trace);  		var preCondStatements = new Seq<Statement> ();  		if (!TranslateBlock (preCondStatements' wdi.Condition' stack1' exid))  			return false;  		condEntry = stack1.FlushAndPopPostState (preCondStatements' wdi.Body.BeforeState);  		if (condEntry == null)  			return false;  		var stack2 = new ExpressionStack (compEnv' BottomE' nameSupply.GenSym' wdi.Body.BeforeState' trace);  		var postCondStatements = new Seq<Statement> ();  		if (!TranslateBlock (postCondStatements' wdi.Body' stack2' exid))  			return false;  		if (!stack2.Flush (postCondStatements' wdi.Body.AfterState))  			return false;  		preCondStatements.Add (new IfThenElseStatement (condEntry.Expression' new Statements (postCondStatements)' new Statements (new BreakStatement ())));  		statements.Add (new WhileDoStatement (new Int32ConstantExpression (1)' new Statements (preCondStatements)));  	}  	else {  		var loopStatements = BlockToStatements (wdi.Body' exid);  		if (loopStatements == null)  			return false;  		if (statements == null)  			return Failed (false' "while-do");  		statements.Add (new WhileDoStatement (condEntry.Expression' new Statements (loopStatements)));  	}  	if (!stack.Restore (wdi.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.DoWhilePseudo: {  	var dwi = (DoWhileInstruction)instruction;  	if (!stack.Flush (statements' dwi.Body.BeforeState))  		return false;  	var combined = new Seq<Instruction> ();  	foreach (var i in dwi.Body.Body)  		combined.Add (i);  	foreach (var i in dwi.Condition.Body)  		combined.Add (i);  	var condEntry = default(ExpressionStackEntry);  	var loopStatements = BlockToConditionStatements (new Instructions (null' combined)' dwi.Body.BeforeState' exid' out condEntry);  	if (loopStatements == null)  		return false;  	if (statements == null)  		return Failed (false' "do-while");  	statements.Add (new DoWhileStatement (new Statements (loopStatements)' condEntry.Expression));  	if (!stack.Restore (dwi.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.LoopControlPseudo: {  	var lci = (BreakContinueInstruction)instruction;  	if (!stack.Flush (statements' lci.BeforeState))  		return false;  	if (statements == null)  		return Failed (false' "loop-control");  	var targetState = default(int);  	switch (lci.Op) {  	case BreakContinueOp.Break:  		if (labelToLoopCandidateBreakState != null && labelToLoopCandidateBreakState.TryGetValue (lci.Label' out targetState))  			statements.Add (new GotoPseudoStatement (stateId' targetState));  		else  			statements.Add (new BreakStatement (lci.Label));  		break;  	case BreakContinueOp.Continue:  		if (labelToLoopCandidateContinueState != null && labelToLoopCandidateContinueState.TryGetValue (lci.Label' out targetState))  			statements.Add (new GotoPseudoStatement (stateId' targetState));  		else  			statements.Add (new ContinueStatement (lci.Label));  		break;  	default:  		throw new ArgumentOutOfRangeException ();  	}  	return true;  }  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (instruction.Flavor) {  case InstructionFlavor.Unsupported:  	throw new InvalidOperationException ("unsupported opcode");  case InstructionFlavor.Misc: {  	var misci = (MiscInstruction)instruction;  	switch (misci.Op) {  	case MiscOp.Nop:  	case MiscOp.Break:  		return true;  	case MiscOp.Dup:  		return stack.Dup (statements);  	case MiscOp.Pop:  		return stack.PopAndDiscard (statements);  	case MiscOp.Ldnull:  		stack.Push (new ExpressionStackEntry (new NullConstantExpression ()' BottomE));  		return true;  	case MiscOp.Ckfinite:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' UnaryOp.CheckFinite' false' false)' e.Lub (ThrowsE)));  	case MiscOp.Throw:  		if (!stack.DiscardAll (statements' 1))  			return false;  		if (!stack.PopEvalSE (statements' 1' true' ThrowsE' (s' a) => s.Add (new ThrowStatement (a [0]))))  			return false;  		return true;  	case MiscOp.Rethrow:  		if (!stack.DiscardAll (statements' 0))  			return false;  		if (statements == null)  			return Failed (false' "rethrow");  		if (exid == null)  			throw new InvalidOperationException ("rethrow outside of catch");  		statements.Add (new RethrowStatement (new VariableCell (exid).Read ()));  		return true;  	case MiscOp.LdindRef:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ReadExpression (a [0]).CloneIfStruct (compEnv)' e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ())));  	case MiscOp.LdelemRef:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' true).Read ().CloneIfStruct (compEnv)' e.Lub (ReadHeapOrThrowE)));  	case MiscOp.Ldlen:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' UnaryOp.Length' false' false)' e.Lub (ReadHeapOrThrowE)));  	case MiscOp.StindRef:  		return stack.PopEvalSE (statements' 2' true' instruction.BeforeState.PeekPointsTo (1).WriteEffect ()' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' a [1]))));  	case MiscOp.StelemRef:  		return stack.PopEvalSE (statements' 3' true' WriteHeapOrThrowE' (s' a) => s.Add (new ExpressionStatement (new ElementCell (a [0]' a [1]' false).Write (a [2]))));  	case MiscOp.Ret:  		if (statements == null)  			return Failed (false' "return");  		statements.Add (new ReturnStatement (null));  		return true;  	case MiscOp.RetVal:  		return stack.PopEvalSE (statements' 1' true' BottomE' (s' a) => s.Add (new ReturnStatement (a [0])));  	case MiscOp.Endfilter:  	case MiscOp.Endfinally:  		throw new InvalidOperationException ("endfilter/endfinally instructions should have been removed");  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Branch:  case InstructionFlavor.Switch:  	throw new InvalidOperationException ("branch/switch instructions should have been removed");  case InstructionFlavor.Compare: {  	var cmpi = (CompareInstruction)instruction;  	if (cmpi.Op == CompareOp.CtruePseudo || cmpi.Op == CompareOp.CfalsePseudo) {  		var s = cmpi.Type.Style (compEnv);  		var unop = default(UnaryOp);  		if (s is NumberTypeStyle)  			unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonZero : UnaryOp.IsZero;  		else  			unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonNull : UnaryOp.IsNull;  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' unop' false' cmpi.IsUnsigned)' e));  	}  	else {  		var binop = default(BinaryOp);  		switch (cmpi.Op) {  		case CompareOp.Ceq:  			binop = BinaryOp.Eq;  			break;  		case CompareOp.Clt:  			binop = BinaryOp.Lt;  			break;  		case CompareOp.Cgt:  			binop = BinaryOp.Gt;  			break;  		case CompareOp.CgePseudo:  			binop = BinaryOp.Ge;  			break;  		case CompareOp.ClePseudo:  			binop = BinaryOp.Le;  			break;  		case CompareOp.CnePseudo:  			binop = BinaryOp.Ne;  			break;  		case CompareOp.CtruePseudo:  		case CompareOp.CfalsePseudo:  			// handled above  			throw new InvalidOperationException ();  		default:  			throw new ArgumentOutOfRangeException ();  		}  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new BinaryExpression (a [0]' binop' a [1]' false' cmpi.IsUnsigned)' e));  	}  }  case InstructionFlavor.ArgLocal: {  	var sli = (ArgLocalInstruction)instruction;  	var id = default(JST.Identifier);  	switch (sli.ArgLocal) {  	case ArgLocal.Arg:  		id = compEnv.ValueParameterIds [sli.Index];  		break;  	case ArgLocal.Local:  		id = compEnv.LocalIds [sli.Index];  		break;  	default:  		throw new ArgumentOutOfRangeException ();  	}  	var cell = new VariableCell (id);  	switch (sli.Op) {  	case ArgLocalOp.Ld:  		stack.Push (new ExpressionStackEntry (cell.Read ().CloneIfStruct (compEnv)' ReadArgLocalE (sli.ArgLocal' sli.Index)));  		return true;  	case ArgLocalOp.Lda:  		// Effect will be accounted for on reads/writes  		stack.Push (new ExpressionStackEntry (cell.AddressOf ()' BottomE));  		return true;  	case ArgLocalOp.St:  		return stack.PopEvalSE (statements' 1' true' WriteArgLocalE (sli.ArgLocal' sli.Index)' (s' a) => s.Add (new ExpressionStatement (cell.Write (a [0]))));  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Field: {  	var fieldi = (FieldInstruction)instruction;  	switch (fieldi.Op) {  	case FieldOp.Ldfld:  		if (fieldi.IsStatic) {  			stack.Push (new ExpressionStackEntry (new FieldCell (null' compEnv.SubstituteMember (fieldi.Field)).Read ().CloneIfStruct (compEnv)' ReadHeapE));  			return true;  		}  		else  			return stack.PopEvalPush (statements' 1' true' (a' e) =>  {  				var readEffect = default(Effects);  				var obj = default(Expression);  				if (fieldi.IsViaPointer.Value) {  					readEffect = e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ());  					obj = new ReadExpression (a [0]);  					// no need for clone  				}  				else if (fieldi.Field.DefiningType.Style (compEnv) is ValueTypeStyle) {  					readEffect = e;  					obj = a [0];  				}  				else {  					// Object could be null  					readEffect = e.Lub (ReadHeapOrThrowE);  					obj = a [0];  				}  				return new ExpressionStackEntry (new FieldCell (obj' compEnv.SubstituteMember (fieldi.Field)).Read ().CloneIfStruct (compEnv)' readEffect);  			});  	case FieldOp.Ldflda:  		if (fieldi.IsStatic) {  			// Effect will be accounted for on reads/writes  			stack.Push (new ExpressionStackEntry (new FieldCell (null' compEnv.SubstituteMember (fieldi.Field)).AddressOf ()' BottomE));  			return true;  		}  		else  			return stack.PopEvalPush (statements' 1' true' (a' e) =>  {  				if (fieldi.IsViaPointer.Value)  					// We're just adding an offset to a pointer' so effect will  					// be accounted for when the final pointer is read/written  					return new ExpressionStackEntry (new FieldCell (new ReadExpression (a [0])' compEnv.SubstituteMember (fieldi.Field)).AddressOf ()' e);  				else  					// Must be a reference type' and ref could be null  					return new ExpressionStackEntry (new FieldCell (a [0]' compEnv.SubstituteMember (fieldi.Field)).AddressOf ()' e.Lub (ThrowsE));  			});  	case FieldOp.Stfld:  		if (fieldi.IsStatic)  			return stack.PopEvalSE (statements' 1' true' WriteHeapE' (s' a) => s.Add (new ExpressionStatement (new FieldCell (null' compEnv.SubstituteMember (fieldi.Field)).Write (a [0]))));  		else {  			var writeEffect = fieldi.IsViaPointer.Value ? instruction.BeforeState.PeekPointsTo (1).WriteEffect () : WriteHeapOrThrowE;  			return stack.PopEvalSE (statements' 2' true' writeEffect' (s' a) =>  {  				var obj = fieldi.IsViaPointer.Value ? new ReadExpression (a [0]) : a [0];  				s.Add (new ExpressionStatement (new FieldCell (obj' compEnv.SubstituteMember (fieldi.Field)).Write (a [1])));  			});  		}  	case FieldOp.Ldtoken:  		stack.Push (new ExpressionStackEntry (new FieldHandleConstantExpression (compEnv.SubstituteMember (fieldi.Field))' BottomE));  		return true;  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Method: {  	var methodi = (MethodInstruction)instruction;  	var arity = methodi.Method.ValueParameters.Count;  	switch (methodi.Op) {  	case MethodOp.Ldftn:  		if (methodi.IsVirtual)  			// Object could be null  			return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new CodePointerExpression (a [0]' compEnv.SubstituteMember (methodi.Method))' e.Lub (ReadHeapOrThrowE)));  		else {  			stack.Push (new ExpressionStackEntry (new CodePointerExpression (null' compEnv.SubstituteMember (methodi.Method))' BottomE));  			return true;  		}  	case MethodOp.Call:  		if (methodi.Method.Result == null)  			return stack.PopEvalSE (statements' arity' true' CalleeEffects (methodi.BeforeState' arity)' (s' a) => s.Add (new ExpressionStatement (new CallExpression (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal' compEnv.SubstituteMember (methodi.Method)' CallerArguments (methodi.Constrained' methodi.Method' a)))));  		else  			return stack.PopEvalPush (statements' arity' true' (a' e) => new ExpressionStackEntry (new CallExpression (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal' compEnv.SubstituteMember (methodi.Method)' CallerArguments (methodi.Constrained' methodi.Method' a))' e.Lub (CalleeEffects (methodi.BeforeState' arity))));  	case MethodOp.Newobj:  		arity--;  		return stack.PopEvalPush (statements' arity' true' (a' e) => new ExpressionStackEntry (new NewObjectExpression (compEnv.SubstituteMember (methodi.Method)' CallerArguments (null' methodi.Method' a))' e.Lub (CalleeEffects (methodi.BeforeState' arity))));  	case MethodOp.Ldtoken:  		stack.Push (new ExpressionStackEntry (new MethodHandleConstantExpression (compEnv.SubstituteMember (methodi.Method))' BottomE));  		return true;  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Type: {  	var typei = (TypeInstruction)instruction;  	switch (typei.Op) {  	case TypeOp.Ldobj:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ReadExpression (a [0]).CloneIfStruct (compEnv)' e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ())));  	case TypeOp.Stobj:  		return stack.PopEvalSE (statements' 2' true' instruction.BeforeState.PeekPointsTo (1).WriteEffect ()' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' a [1]))));  	case TypeOp.Cpobj: {  		var copyEffect = instruction.BeforeState.PeekPointsTo (0).ReadEffect ().Lub (instruction.BeforeState.PeekPointsTo (1).WriteEffect ());  		return stack.PopEvalSE (statements' 2' true' copyEffect' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' new ReadExpression (a [1]).CloneIfStruct (compEnv)))));  	}  	case TypeOp.Newarr:  		// Growing the heap is not considered an observable change. But will throw if  		// length < 0  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new NewArrayExpression (a [0]' compEnv.SubstituteType (typei.Type))' e.Lub (ThrowsE)));  	case TypeOp.Initobj:  		return stack.PopEvalSE (statements' 1' true' WriteHeapE' (s' a) => s.Add (new InitializeObjectStatement (a [0])));  	case TypeOp.Castclass:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new CastExpression (a [0]' compEnv.SubstituteType (typei.Type))' e.Lub (ThrowsE)));  	case TypeOp.Isinst:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new IsInstExpression (a [0]' compEnv.SubstituteType (typei.Type))' e));  	case TypeOp.Box:  		// Growing the heap is not considered an observable change  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new NewBoxExpression (a [0]' compEnv.SubstituteType (typei.Type))' e));  	case TypeOp.Unbox:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new BoxCell (a [0]' compEnv.SubstituteType (typei.Type)).AddressOf ()' e.Lub (ThrowsE)));  	case TypeOp.UnboxAny:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new BoxCell (a [0]' compEnv.SubstituteType (typei.Type)).Read ().CloneIfStruct (compEnv)' e.Lub (ThrowsE)));  	case TypeOp.Ldtoken:  		stack.Push (new ExpressionStackEntry (new TypeHandleConstantExpression (compEnv.SubstituteType (typei.Type))' BottomE));  		return true;  	case TypeOp.Ldelem:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' true).Read ().CloneIfStruct (compEnv)' e.Lub (ReadHeapOrThrowE)));  	case TypeOp.Stelem:  		return stack.PopEvalSE (statements' 3' true' WriteHeapOrThrowE' (s' a) => s.Add (new ExpressionStatement (new ElementCell (a [0]' a [1]' false).Write (a [2]))));  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.LdElemAddr:  	// Calculating the pointer may throw if index is out of range.  	// Remaining effect will be accounted for when pointer is read/written.  	return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' false).AddressOf ()' e.Lub (ThrowsE)));  case InstructionFlavor.LdInt32: {  	var int32i = (LdInt32Instruction)instruction;  	stack.Push (new ExpressionStackEntry (new Int32ConstantExpression (int32i.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdInt64: {  	var int64i = (LdInt64Instruction)instruction;  	stack.Push (new ExpressionStackEntry (new Int64ConstantExpression (int64i.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdSingle: {  	var singlei = (LdSingleInstruction)instruction;  	stack.Push (new ExpressionStackEntry (new SingleConstantExpression (singlei.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdDouble: {  	var doublei = (LdDoubleInstruction)instruction;  	stack.Push (new ExpressionStackEntry (new DoubleConstantExpression (doublei.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdString: {  	var stringi = (LdStringInstruction)instruction;  	stack.Push (new ExpressionStackEntry (new StringConstantExpression (stringi.Value)' BottomE));  	return true;  }  case InstructionFlavor.Arith: {  	var arithi = (ArithInstruction)instruction;  	switch (arithi.Op) {  	case ArithOp.Div:  	case ArithOp.Rem:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new BinaryExpression (a [0]' ArithOpToBinaryOp (arithi.Op)' a [1]' arithi.WithOverflow' arithi.IsUnsigned)' e.Lub (ThrowsE)));  	case ArithOp.Add:  	case ArithOp.Sub:  	case ArithOp.Mul:  	case ArithOp.BitAnd:  	case ArithOp.BitOr:  	case ArithOp.BitXor:  	case ArithOp.Shl:  	case ArithOp.Shr:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new BinaryExpression (a [0]' ArithOpToBinaryOp (arithi.Op)' a [1]' arithi.WithOverflow' arithi.IsUnsigned)' e.Lub (arithi.WithOverflow ? ThrowsE : BottomE)));  	case ArithOp.Neg:  	case ArithOp.BitNot:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' ArithOpToUnaryOp (arithi.Op)' arithi.WithOverflow' arithi.IsUnsigned)' e));  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Conv: {  	var convi = (ConvInstruction)instruction;  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ConvertExpression (a [0]' new NamedTypeRef (compEnv.Global.NumberFlavorToQualifiedTypeName [convi.TargetNumberFlavor])' convi.WithOverflow' convi.IsSourceUnsigned)' e.Lub (convi.WithOverflow ? ThrowsE : BottomE)));  }  case InstructionFlavor.Try: {  	if (stack.Depth > 0)  		throw new InvalidOperationException ("stack must be empty on entry to try block");  	var tryi = (TryInstruction)instruction;  	var tryStatements = BlockToTryFaultFinallyStatements (tryi.Body);  	if (tryStatements == null)  		return false;  	var handlers = TranslateHandlers (tryi.Handlers);  	if (handlers == null)  		return false;  	if (statements == null)  		return Failed (false' "try");  	statements.Add (new TryStatement (tryStatements' handlers));  	return true;  }  case InstructionFlavor.IfThenElsePseudo: {  	var itei = (IfThenElseInstruction)instruction;  	var isExpr = default(bool);  	// If outer context is re-translating as statements instead of expression' jump directly  	// to appropriate translation for this instruction  	var couldBeExpression = !instructionTranslationStyleCache.TryGetValue (itei.Offset' out isExpr) || isExpr;  	if (!TranslateBlock (statements' itei.Condition' stack' exid))  		return false;  	if (couldBeExpression && itei.Else != null) {  		// Pass 1: Try to tranlate to an if-then-else expression. Will only work if Then and Else don't  		//         reach into current stack' push exactly one value' and don't need to emit any  		//         statements along the way.  		var thenEntry = BlockToExpression (itei.Then' exid);  		if (thenEntry != null) {  			var elseEntry = BlockToExpression (itei.Else' exid);  			if (elseEntry != null) {  				if (!instructionTranslationStyleCache.ContainsKey (itei.Offset))  					instructionTranslationStyleCache.Add (itei.Offset' true);  				return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new IfThenElseExpression (a [0]' thenEntry.Expression' elseEntry.Expression)' e.Lub (thenEntry.Effects.Lub (elseEntry.Effects))));  			}  			// else: fallthrough  		}  		// else: fallthrough  	}  	// else: fallthrough  	// Pass 2: Translate to a statement  	var noStackChange = itei.Then.NoStackChange && (itei.Else == null || itei.Else.NoStackChange);  	var condEntry = noStackChange ? stack.Pop () : stack.FlushAndPopPostState (statements' itei.Then.BeforeState);  	if (condEntry == null)  		return false;  	var thenStmnts = noStackChange ? BlockToStatementsEmptyStack (itei.Then' exid) : BlockToStatements (itei.Then' exid);  	if (thenStmnts == null)  		return false;  	var elseStmnts = default(Seq<Statement>);  	if (itei.Else != null) {  		elseStmnts = noStackChange ? BlockToStatementsEmptyStack (itei.Else' exid) : BlockToStatements (itei.Else' exid);  		if (elseStmnts == null)  			return false;  	}  	if (statements == null)  		return Failed (false' "if-then-else");  	statements.Add (new IfThenElseStatement (condEntry.Expression' new Statements (thenStmnts)' elseStmnts == null ? null : new Statements (elseStmnts)));  	if (!noStackChange && !stack.Restore (itei.AfterState' 0))  		return false;  	if (!instructionTranslationStyleCache.ContainsKey (itei.Offset))  		instructionTranslationStyleCache.Add (itei.Offset' false);  	return true;  }  case InstructionFlavor.ShortCircuitingPseudo: {  	var sci = (ShortCircuitingInstruction)instruction;  	var isExpr = default(bool);  	// If outer context is re-translating as statements instead of expression' jump directly  	// to appropriate translation for this instruction  	var couldBeExpression = !instructionTranslationStyleCache.TryGetValue (sci.Offset' out isExpr) || isExpr;  	if (couldBeExpression) {  		// Pass 1: Try to translate to an expression.  		var leftEntry = BlockToExpression (sci.Left' exid);  		if (leftEntry != null) {  			var rightEntry = BlockToExpression (sci.Right' exid);  			if (rightEntry != null) {  				stack.Push (new ExpressionStackEntry (new BinaryExpression (leftEntry.Expression' ShortCircuitingOpToBinaryOp (sci.Op)' rightEntry.Expression' false' false)' leftEntry.Effects.Lub (rightEntry.Effects)));  				if (!instructionTranslationStyleCache.ContainsKey (sci.Offset))  					instructionTranslationStyleCache.Add (sci.Offset' true);  				return true;  			}  			// else: fallthrough  		}  		// else: fallthrough  	}  	// else: fallthrough  	// Pass 2: Translate to a statement  	if (!TranslateBlock (statements' sci.Left' stack' exid))  		return false;  	var leftEntry2 = stack.FlushAndPopPostState (statements' sci.Right.BeforeState);  	if (leftEntry2 == null)  		return false;  	var rightStatements = BlockToStatements (sci.Right' exid);  	if (rightStatements == null)  		return false;  	var id = sci.Right.AfterState.PeekId (0' nameSupply.GenSym);  	var cell = new VariableCell (id);  	compEnv.AddVariable (id' ArgLocal.Local' false' true' compEnv.SubstituteType (sci.Right.AfterState.PeekType (0)));  	if (statements == null)  		return Failed (false' "short-circuit");  	switch (sci.Op) {  	case ShortCircuitingOp.And:  		statements.Add (new IfThenElseStatement (leftEntry2.Expression' new Statements (rightStatements)' new Statements (new ExpressionStatement (cell.Write (new Int32ConstantExpression (0))))));  		break;  	case ShortCircuitingOp.Or:  		statements.Add (new IfThenElseStatement (leftEntry2.Expression' new Statements (new ExpressionStatement (cell.Write (new Int32ConstantExpression (1))))' new Statements (rightStatements)));  		break;  	default:  		throw new ArgumentOutOfRangeException ();  	}  	if (!stack.Restore (sci.AfterState' 1))  		return false;  	stack.Push (new ExpressionStackEntry (cell.Read ()' BottomE));  	if (!instructionTranslationStyleCache.ContainsKey (sci.Offset))  		instructionTranslationStyleCache.Add (sci.Offset' false);  	return true;  }  case InstructionFlavor.StructuralSwitchPseudo: {  	var ssi = (StructuralSwitchInstruction)instruction;  	if (!TranslateBlock (statements' ssi.Body' stack' exid))  		return false;  	var valueEntry = stack.FlushAndPopPreState (statements' ssi.Body.AfterState);  	if (valueEntry == null)  		return false;  	var cases = new Seq<SwitchStatementCase> ();  	foreach (var c in ssi.Cases) {  		var caseStatements = BlockToStatements (c.Body' exid);  		if (caseStatements == null)  			return false;  		cases.Add (new SwitchStatementCase (c.Values' new Statements (caseStatements)));  	}  	if (statements == null)  		return Failed (false' "structural switch");  	statements.Add (new SwitchStatement (valueEntry.Expression' cases));  	if (!stack.Restore (ssi.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.LoopPseudo: {  	var li = (LoopInstruction)instruction;  	if (!stack.Flush (statements' li.Body.BeforeState))  		return false;  	if (statements == null)  		return Failed (false' "loop");  	var whileStatements = BlockToStatements (li.Body' exid);  	statements.Add (new WhileDoStatement (new Int32ConstantExpression (1)' new Statements (whileStatements)));  	if (!stack.Restore (li.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.WhileDoPseudo: {  	var wdi = (WhileDoInstruction)instruction;  	if (!stack.Flush (statements' wdi.Condition.BeforeState))  		return false;  	var condEntry = BlockToExpression (wdi.Condition' exid);  	if (condEntry == null) {  		var stack1 = new ExpressionStack (compEnv' BottomE' nameSupply.GenSym' wdi.Condition.BeforeState' trace);  		var preCondStatements = new Seq<Statement> ();  		if (!TranslateBlock (preCondStatements' wdi.Condition' stack1' exid))  			return false;  		condEntry = stack1.FlushAndPopPostState (preCondStatements' wdi.Body.BeforeState);  		if (condEntry == null)  			return false;  		var stack2 = new ExpressionStack (compEnv' BottomE' nameSupply.GenSym' wdi.Body.BeforeState' trace);  		var postCondStatements = new Seq<Statement> ();  		if (!TranslateBlock (postCondStatements' wdi.Body' stack2' exid))  			return false;  		if (!stack2.Flush (postCondStatements' wdi.Body.AfterState))  			return false;  		preCondStatements.Add (new IfThenElseStatement (condEntry.Expression' new Statements (postCondStatements)' new Statements (new BreakStatement ())));  		statements.Add (new WhileDoStatement (new Int32ConstantExpression (1)' new Statements (preCondStatements)));  	}  	else {  		var loopStatements = BlockToStatements (wdi.Body' exid);  		if (loopStatements == null)  			return false;  		if (statements == null)  			return Failed (false' "while-do");  		statements.Add (new WhileDoStatement (condEntry.Expression' new Statements (loopStatements)));  	}  	if (!stack.Restore (wdi.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.DoWhilePseudo: {  	var dwi = (DoWhileInstruction)instruction;  	if (!stack.Flush (statements' dwi.Body.BeforeState))  		return false;  	var combined = new Seq<Instruction> ();  	foreach (var i in dwi.Body.Body)  		combined.Add (i);  	foreach (var i in dwi.Condition.Body)  		combined.Add (i);  	var condEntry = default(ExpressionStackEntry);  	var loopStatements = BlockToConditionStatements (new Instructions (null' combined)' dwi.Body.BeforeState' exid' out condEntry);  	if (loopStatements == null)  		return false;  	if (statements == null)  		return Failed (false' "do-while");  	statements.Add (new DoWhileStatement (new Statements (loopStatements)' condEntry.Expression));  	if (!stack.Restore (dwi.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.LoopControlPseudo: {  	var lci = (BreakContinueInstruction)instruction;  	if (!stack.Flush (statements' lci.BeforeState))  		return false;  	if (statements == null)  		return Failed (false' "loop-control");  	var targetState = default(int);  	switch (lci.Op) {  	case BreakContinueOp.Break:  		if (labelToLoopCandidateBreakState != null && labelToLoopCandidateBreakState.TryGetValue (lci.Label' out targetState))  			statements.Add (new GotoPseudoStatement (stateId' targetState));  		else  			statements.Add (new BreakStatement (lci.Label));  		break;  	case BreakContinueOp.Continue:  		if (labelToLoopCandidateContinueState != null && labelToLoopCandidateContinueState.TryGetValue (lci.Label' out targetState))  			statements.Add (new GotoPseudoStatement (stateId' targetState));  		else  			statements.Add (new ContinueStatement (lci.Label));  		break;  	default:  		throw new ArgumentOutOfRangeException ();  	}  	return true;  }  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (instruction.Flavor) {  case InstructionFlavor.Unsupported:  	throw new InvalidOperationException ("unsupported opcode");  case InstructionFlavor.Misc: {  	var misci = (MiscInstruction)instruction;  	switch (misci.Op) {  	case MiscOp.Nop:  	case MiscOp.Break:  		return true;  	case MiscOp.Dup:  		return stack.Dup (statements);  	case MiscOp.Pop:  		return stack.PopAndDiscard (statements);  	case MiscOp.Ldnull:  		stack.Push (new ExpressionStackEntry (new NullConstantExpression ()' BottomE));  		return true;  	case MiscOp.Ckfinite:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' UnaryOp.CheckFinite' false' false)' e.Lub (ThrowsE)));  	case MiscOp.Throw:  		if (!stack.DiscardAll (statements' 1))  			return false;  		if (!stack.PopEvalSE (statements' 1' true' ThrowsE' (s' a) => s.Add (new ThrowStatement (a [0]))))  			return false;  		return true;  	case MiscOp.Rethrow:  		if (!stack.DiscardAll (statements' 0))  			return false;  		if (statements == null)  			return Failed (false' "rethrow");  		if (exid == null)  			throw new InvalidOperationException ("rethrow outside of catch");  		statements.Add (new RethrowStatement (new VariableCell (exid).Read ()));  		return true;  	case MiscOp.LdindRef:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ReadExpression (a [0]).CloneIfStruct (compEnv)' e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ())));  	case MiscOp.LdelemRef:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' true).Read ().CloneIfStruct (compEnv)' e.Lub (ReadHeapOrThrowE)));  	case MiscOp.Ldlen:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' UnaryOp.Length' false' false)' e.Lub (ReadHeapOrThrowE)));  	case MiscOp.StindRef:  		return stack.PopEvalSE (statements' 2' true' instruction.BeforeState.PeekPointsTo (1).WriteEffect ()' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' a [1]))));  	case MiscOp.StelemRef:  		return stack.PopEvalSE (statements' 3' true' WriteHeapOrThrowE' (s' a) => s.Add (new ExpressionStatement (new ElementCell (a [0]' a [1]' false).Write (a [2]))));  	case MiscOp.Ret:  		if (statements == null)  			return Failed (false' "return");  		statements.Add (new ReturnStatement (null));  		return true;  	case MiscOp.RetVal:  		return stack.PopEvalSE (statements' 1' true' BottomE' (s' a) => s.Add (new ReturnStatement (a [0])));  	case MiscOp.Endfilter:  	case MiscOp.Endfinally:  		throw new InvalidOperationException ("endfilter/endfinally instructions should have been removed");  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Branch:  case InstructionFlavor.Switch:  	throw new InvalidOperationException ("branch/switch instructions should have been removed");  case InstructionFlavor.Compare: {  	var cmpi = (CompareInstruction)instruction;  	if (cmpi.Op == CompareOp.CtruePseudo || cmpi.Op == CompareOp.CfalsePseudo) {  		var s = cmpi.Type.Style (compEnv);  		var unop = default(UnaryOp);  		if (s is NumberTypeStyle)  			unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonZero : UnaryOp.IsZero;  		else  			unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonNull : UnaryOp.IsNull;  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' unop' false' cmpi.IsUnsigned)' e));  	}  	else {  		var binop = default(BinaryOp);  		switch (cmpi.Op) {  		case CompareOp.Ceq:  			binop = BinaryOp.Eq;  			break;  		case CompareOp.Clt:  			binop = BinaryOp.Lt;  			break;  		case CompareOp.Cgt:  			binop = BinaryOp.Gt;  			break;  		case CompareOp.CgePseudo:  			binop = BinaryOp.Ge;  			break;  		case CompareOp.ClePseudo:  			binop = BinaryOp.Le;  			break;  		case CompareOp.CnePseudo:  			binop = BinaryOp.Ne;  			break;  		case CompareOp.CtruePseudo:  		case CompareOp.CfalsePseudo:  			// handled above  			throw new InvalidOperationException ();  		default:  			throw new ArgumentOutOfRangeException ();  		}  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new BinaryExpression (a [0]' binop' a [1]' false' cmpi.IsUnsigned)' e));  	}  }  case InstructionFlavor.ArgLocal: {  	var sli = (ArgLocalInstruction)instruction;  	var id = default(JST.Identifier);  	switch (sli.ArgLocal) {  	case ArgLocal.Arg:  		id = compEnv.ValueParameterIds [sli.Index];  		break;  	case ArgLocal.Local:  		id = compEnv.LocalIds [sli.Index];  		break;  	default:  		throw new ArgumentOutOfRangeException ();  	}  	var cell = new VariableCell (id);  	switch (sli.Op) {  	case ArgLocalOp.Ld:  		stack.Push (new ExpressionStackEntry (cell.Read ().CloneIfStruct (compEnv)' ReadArgLocalE (sli.ArgLocal' sli.Index)));  		return true;  	case ArgLocalOp.Lda:  		// Effect will be accounted for on reads/writes  		stack.Push (new ExpressionStackEntry (cell.AddressOf ()' BottomE));  		return true;  	case ArgLocalOp.St:  		return stack.PopEvalSE (statements' 1' true' WriteArgLocalE (sli.ArgLocal' sli.Index)' (s' a) => s.Add (new ExpressionStatement (cell.Write (a [0]))));  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Field: {  	var fieldi = (FieldInstruction)instruction;  	switch (fieldi.Op) {  	case FieldOp.Ldfld:  		if (fieldi.IsStatic) {  			stack.Push (new ExpressionStackEntry (new FieldCell (null' compEnv.SubstituteMember (fieldi.Field)).Read ().CloneIfStruct (compEnv)' ReadHeapE));  			return true;  		}  		else  			return stack.PopEvalPush (statements' 1' true' (a' e) =>  {  				var readEffect = default(Effects);  				var obj = default(Expression);  				if (fieldi.IsViaPointer.Value) {  					readEffect = e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ());  					obj = new ReadExpression (a [0]);  					// no need for clone  				}  				else if (fieldi.Field.DefiningType.Style (compEnv) is ValueTypeStyle) {  					readEffect = e;  					obj = a [0];  				}  				else {  					// Object could be null  					readEffect = e.Lub (ReadHeapOrThrowE);  					obj = a [0];  				}  				return new ExpressionStackEntry (new FieldCell (obj' compEnv.SubstituteMember (fieldi.Field)).Read ().CloneIfStruct (compEnv)' readEffect);  			});  	case FieldOp.Ldflda:  		if (fieldi.IsStatic) {  			// Effect will be accounted for on reads/writes  			stack.Push (new ExpressionStackEntry (new FieldCell (null' compEnv.SubstituteMember (fieldi.Field)).AddressOf ()' BottomE));  			return true;  		}  		else  			return stack.PopEvalPush (statements' 1' true' (a' e) =>  {  				if (fieldi.IsViaPointer.Value)  					// We're just adding an offset to a pointer' so effect will  					// be accounted for when the final pointer is read/written  					return new ExpressionStackEntry (new FieldCell (new ReadExpression (a [0])' compEnv.SubstituteMember (fieldi.Field)).AddressOf ()' e);  				else  					// Must be a reference type' and ref could be null  					return new ExpressionStackEntry (new FieldCell (a [0]' compEnv.SubstituteMember (fieldi.Field)).AddressOf ()' e.Lub (ThrowsE));  			});  	case FieldOp.Stfld:  		if (fieldi.IsStatic)  			return stack.PopEvalSE (statements' 1' true' WriteHeapE' (s' a) => s.Add (new ExpressionStatement (new FieldCell (null' compEnv.SubstituteMember (fieldi.Field)).Write (a [0]))));  		else {  			var writeEffect = fieldi.IsViaPointer.Value ? instruction.BeforeState.PeekPointsTo (1).WriteEffect () : WriteHeapOrThrowE;  			return stack.PopEvalSE (statements' 2' true' writeEffect' (s' a) =>  {  				var obj = fieldi.IsViaPointer.Value ? new ReadExpression (a [0]) : a [0];  				s.Add (new ExpressionStatement (new FieldCell (obj' compEnv.SubstituteMember (fieldi.Field)).Write (a [1])));  			});  		}  	case FieldOp.Ldtoken:  		stack.Push (new ExpressionStackEntry (new FieldHandleConstantExpression (compEnv.SubstituteMember (fieldi.Field))' BottomE));  		return true;  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Method: {  	var methodi = (MethodInstruction)instruction;  	var arity = methodi.Method.ValueParameters.Count;  	switch (methodi.Op) {  	case MethodOp.Ldftn:  		if (methodi.IsVirtual)  			// Object could be null  			return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new CodePointerExpression (a [0]' compEnv.SubstituteMember (methodi.Method))' e.Lub (ReadHeapOrThrowE)));  		else {  			stack.Push (new ExpressionStackEntry (new CodePointerExpression (null' compEnv.SubstituteMember (methodi.Method))' BottomE));  			return true;  		}  	case MethodOp.Call:  		if (methodi.Method.Result == null)  			return stack.PopEvalSE (statements' arity' true' CalleeEffects (methodi.BeforeState' arity)' (s' a) => s.Add (new ExpressionStatement (new CallExpression (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal' compEnv.SubstituteMember (methodi.Method)' CallerArguments (methodi.Constrained' methodi.Method' a)))));  		else  			return stack.PopEvalPush (statements' arity' true' (a' e) => new ExpressionStackEntry (new CallExpression (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal' compEnv.SubstituteMember (methodi.Method)' CallerArguments (methodi.Constrained' methodi.Method' a))' e.Lub (CalleeEffects (methodi.BeforeState' arity))));  	case MethodOp.Newobj:  		arity--;  		return stack.PopEvalPush (statements' arity' true' (a' e) => new ExpressionStackEntry (new NewObjectExpression (compEnv.SubstituteMember (methodi.Method)' CallerArguments (null' methodi.Method' a))' e.Lub (CalleeEffects (methodi.BeforeState' arity))));  	case MethodOp.Ldtoken:  		stack.Push (new ExpressionStackEntry (new MethodHandleConstantExpression (compEnv.SubstituteMember (methodi.Method))' BottomE));  		return true;  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Type: {  	var typei = (TypeInstruction)instruction;  	switch (typei.Op) {  	case TypeOp.Ldobj:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ReadExpression (a [0]).CloneIfStruct (compEnv)' e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ())));  	case TypeOp.Stobj:  		return stack.PopEvalSE (statements' 2' true' instruction.BeforeState.PeekPointsTo (1).WriteEffect ()' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' a [1]))));  	case TypeOp.Cpobj: {  		var copyEffect = instruction.BeforeState.PeekPointsTo (0).ReadEffect ().Lub (instruction.BeforeState.PeekPointsTo (1).WriteEffect ());  		return stack.PopEvalSE (statements' 2' true' copyEffect' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' new ReadExpression (a [1]).CloneIfStruct (compEnv)))));  	}  	case TypeOp.Newarr:  		// Growing the heap is not considered an observable change. But will throw if  		// length < 0  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new NewArrayExpression (a [0]' compEnv.SubstituteType (typei.Type))' e.Lub (ThrowsE)));  	case TypeOp.Initobj:  		return stack.PopEvalSE (statements' 1' true' WriteHeapE' (s' a) => s.Add (new InitializeObjectStatement (a [0])));  	case TypeOp.Castclass:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new CastExpression (a [0]' compEnv.SubstituteType (typei.Type))' e.Lub (ThrowsE)));  	case TypeOp.Isinst:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new IsInstExpression (a [0]' compEnv.SubstituteType (typei.Type))' e));  	case TypeOp.Box:  		// Growing the heap is not considered an observable change  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new NewBoxExpression (a [0]' compEnv.SubstituteType (typei.Type))' e));  	case TypeOp.Unbox:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new BoxCell (a [0]' compEnv.SubstituteType (typei.Type)).AddressOf ()' e.Lub (ThrowsE)));  	case TypeOp.UnboxAny:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new BoxCell (a [0]' compEnv.SubstituteType (typei.Type)).Read ().CloneIfStruct (compEnv)' e.Lub (ThrowsE)));  	case TypeOp.Ldtoken:  		stack.Push (new ExpressionStackEntry (new TypeHandleConstantExpression (compEnv.SubstituteType (typei.Type))' BottomE));  		return true;  	case TypeOp.Ldelem:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' true).Read ().CloneIfStruct (compEnv)' e.Lub (ReadHeapOrThrowE)));  	case TypeOp.Stelem:  		return stack.PopEvalSE (statements' 3' true' WriteHeapOrThrowE' (s' a) => s.Add (new ExpressionStatement (new ElementCell (a [0]' a [1]' false).Write (a [2]))));  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.LdElemAddr:  	// Calculating the pointer may throw if index is out of range.  	// Remaining effect will be accounted for when pointer is read/written.  	return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' false).AddressOf ()' e.Lub (ThrowsE)));  case InstructionFlavor.LdInt32: {  	var int32i = (LdInt32Instruction)instruction;  	stack.Push (new ExpressionStackEntry (new Int32ConstantExpression (int32i.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdInt64: {  	var int64i = (LdInt64Instruction)instruction;  	stack.Push (new ExpressionStackEntry (new Int64ConstantExpression (int64i.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdSingle: {  	var singlei = (LdSingleInstruction)instruction;  	stack.Push (new ExpressionStackEntry (new SingleConstantExpression (singlei.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdDouble: {  	var doublei = (LdDoubleInstruction)instruction;  	stack.Push (new ExpressionStackEntry (new DoubleConstantExpression (doublei.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdString: {  	var stringi = (LdStringInstruction)instruction;  	stack.Push (new ExpressionStackEntry (new StringConstantExpression (stringi.Value)' BottomE));  	return true;  }  case InstructionFlavor.Arith: {  	var arithi = (ArithInstruction)instruction;  	switch (arithi.Op) {  	case ArithOp.Div:  	case ArithOp.Rem:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new BinaryExpression (a [0]' ArithOpToBinaryOp (arithi.Op)' a [1]' arithi.WithOverflow' arithi.IsUnsigned)' e.Lub (ThrowsE)));  	case ArithOp.Add:  	case ArithOp.Sub:  	case ArithOp.Mul:  	case ArithOp.BitAnd:  	case ArithOp.BitOr:  	case ArithOp.BitXor:  	case ArithOp.Shl:  	case ArithOp.Shr:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new BinaryExpression (a [0]' ArithOpToBinaryOp (arithi.Op)' a [1]' arithi.WithOverflow' arithi.IsUnsigned)' e.Lub (arithi.WithOverflow ? ThrowsE : BottomE)));  	case ArithOp.Neg:  	case ArithOp.BitNot:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' ArithOpToUnaryOp (arithi.Op)' arithi.WithOverflow' arithi.IsUnsigned)' e));  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Conv: {  	var convi = (ConvInstruction)instruction;  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ConvertExpression (a [0]' new NamedTypeRef (compEnv.Global.NumberFlavorToQualifiedTypeName [convi.TargetNumberFlavor])' convi.WithOverflow' convi.IsSourceUnsigned)' e.Lub (convi.WithOverflow ? ThrowsE : BottomE)));  }  case InstructionFlavor.Try: {  	if (stack.Depth > 0)  		throw new InvalidOperationException ("stack must be empty on entry to try block");  	var tryi = (TryInstruction)instruction;  	var tryStatements = BlockToTryFaultFinallyStatements (tryi.Body);  	if (tryStatements == null)  		return false;  	var handlers = TranslateHandlers (tryi.Handlers);  	if (handlers == null)  		return false;  	if (statements == null)  		return Failed (false' "try");  	statements.Add (new TryStatement (tryStatements' handlers));  	return true;  }  case InstructionFlavor.IfThenElsePseudo: {  	var itei = (IfThenElseInstruction)instruction;  	var isExpr = default(bool);  	// If outer context is re-translating as statements instead of expression' jump directly  	// to appropriate translation for this instruction  	var couldBeExpression = !instructionTranslationStyleCache.TryGetValue (itei.Offset' out isExpr) || isExpr;  	if (!TranslateBlock (statements' itei.Condition' stack' exid))  		return false;  	if (couldBeExpression && itei.Else != null) {  		// Pass 1: Try to tranlate to an if-then-else expression. Will only work if Then and Else don't  		//         reach into current stack' push exactly one value' and don't need to emit any  		//         statements along the way.  		var thenEntry = BlockToExpression (itei.Then' exid);  		if (thenEntry != null) {  			var elseEntry = BlockToExpression (itei.Else' exid);  			if (elseEntry != null) {  				if (!instructionTranslationStyleCache.ContainsKey (itei.Offset))  					instructionTranslationStyleCache.Add (itei.Offset' true);  				return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new IfThenElseExpression (a [0]' thenEntry.Expression' elseEntry.Expression)' e.Lub (thenEntry.Effects.Lub (elseEntry.Effects))));  			}  			// else: fallthrough  		}  		// else: fallthrough  	}  	// else: fallthrough  	// Pass 2: Translate to a statement  	var noStackChange = itei.Then.NoStackChange && (itei.Else == null || itei.Else.NoStackChange);  	var condEntry = noStackChange ? stack.Pop () : stack.FlushAndPopPostState (statements' itei.Then.BeforeState);  	if (condEntry == null)  		return false;  	var thenStmnts = noStackChange ? BlockToStatementsEmptyStack (itei.Then' exid) : BlockToStatements (itei.Then' exid);  	if (thenStmnts == null)  		return false;  	var elseStmnts = default(Seq<Statement>);  	if (itei.Else != null) {  		elseStmnts = noStackChange ? BlockToStatementsEmptyStack (itei.Else' exid) : BlockToStatements (itei.Else' exid);  		if (elseStmnts == null)  			return false;  	}  	if (statements == null)  		return Failed (false' "if-then-else");  	statements.Add (new IfThenElseStatement (condEntry.Expression' new Statements (thenStmnts)' elseStmnts == null ? null : new Statements (elseStmnts)));  	if (!noStackChange && !stack.Restore (itei.AfterState' 0))  		return false;  	if (!instructionTranslationStyleCache.ContainsKey (itei.Offset))  		instructionTranslationStyleCache.Add (itei.Offset' false);  	return true;  }  case InstructionFlavor.ShortCircuitingPseudo: {  	var sci = (ShortCircuitingInstruction)instruction;  	var isExpr = default(bool);  	// If outer context is re-translating as statements instead of expression' jump directly  	// to appropriate translation for this instruction  	var couldBeExpression = !instructionTranslationStyleCache.TryGetValue (sci.Offset' out isExpr) || isExpr;  	if (couldBeExpression) {  		// Pass 1: Try to translate to an expression.  		var leftEntry = BlockToExpression (sci.Left' exid);  		if (leftEntry != null) {  			var rightEntry = BlockToExpression (sci.Right' exid);  			if (rightEntry != null) {  				stack.Push (new ExpressionStackEntry (new BinaryExpression (leftEntry.Expression' ShortCircuitingOpToBinaryOp (sci.Op)' rightEntry.Expression' false' false)' leftEntry.Effects.Lub (rightEntry.Effects)));  				if (!instructionTranslationStyleCache.ContainsKey (sci.Offset))  					instructionTranslationStyleCache.Add (sci.Offset' true);  				return true;  			}  			// else: fallthrough  		}  		// else: fallthrough  	}  	// else: fallthrough  	// Pass 2: Translate to a statement  	if (!TranslateBlock (statements' sci.Left' stack' exid))  		return false;  	var leftEntry2 = stack.FlushAndPopPostState (statements' sci.Right.BeforeState);  	if (leftEntry2 == null)  		return false;  	var rightStatements = BlockToStatements (sci.Right' exid);  	if (rightStatements == null)  		return false;  	var id = sci.Right.AfterState.PeekId (0' nameSupply.GenSym);  	var cell = new VariableCell (id);  	compEnv.AddVariable (id' ArgLocal.Local' false' true' compEnv.SubstituteType (sci.Right.AfterState.PeekType (0)));  	if (statements == null)  		return Failed (false' "short-circuit");  	switch (sci.Op) {  	case ShortCircuitingOp.And:  		statements.Add (new IfThenElseStatement (leftEntry2.Expression' new Statements (rightStatements)' new Statements (new ExpressionStatement (cell.Write (new Int32ConstantExpression (0))))));  		break;  	case ShortCircuitingOp.Or:  		statements.Add (new IfThenElseStatement (leftEntry2.Expression' new Statements (new ExpressionStatement (cell.Write (new Int32ConstantExpression (1))))' new Statements (rightStatements)));  		break;  	default:  		throw new ArgumentOutOfRangeException ();  	}  	if (!stack.Restore (sci.AfterState' 1))  		return false;  	stack.Push (new ExpressionStackEntry (cell.Read ()' BottomE));  	if (!instructionTranslationStyleCache.ContainsKey (sci.Offset))  		instructionTranslationStyleCache.Add (sci.Offset' false);  	return true;  }  case InstructionFlavor.StructuralSwitchPseudo: {  	var ssi = (StructuralSwitchInstruction)instruction;  	if (!TranslateBlock (statements' ssi.Body' stack' exid))  		return false;  	var valueEntry = stack.FlushAndPopPreState (statements' ssi.Body.AfterState);  	if (valueEntry == null)  		return false;  	var cases = new Seq<SwitchStatementCase> ();  	foreach (var c in ssi.Cases) {  		var caseStatements = BlockToStatements (c.Body' exid);  		if (caseStatements == null)  			return false;  		cases.Add (new SwitchStatementCase (c.Values' new Statements (caseStatements)));  	}  	if (statements == null)  		return Failed (false' "structural switch");  	statements.Add (new SwitchStatement (valueEntry.Expression' cases));  	if (!stack.Restore (ssi.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.LoopPseudo: {  	var li = (LoopInstruction)instruction;  	if (!stack.Flush (statements' li.Body.BeforeState))  		return false;  	if (statements == null)  		return Failed (false' "loop");  	var whileStatements = BlockToStatements (li.Body' exid);  	statements.Add (new WhileDoStatement (new Int32ConstantExpression (1)' new Statements (whileStatements)));  	if (!stack.Restore (li.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.WhileDoPseudo: {  	var wdi = (WhileDoInstruction)instruction;  	if (!stack.Flush (statements' wdi.Condition.BeforeState))  		return false;  	var condEntry = BlockToExpression (wdi.Condition' exid);  	if (condEntry == null) {  		var stack1 = new ExpressionStack (compEnv' BottomE' nameSupply.GenSym' wdi.Condition.BeforeState' trace);  		var preCondStatements = new Seq<Statement> ();  		if (!TranslateBlock (preCondStatements' wdi.Condition' stack1' exid))  			return false;  		condEntry = stack1.FlushAndPopPostState (preCondStatements' wdi.Body.BeforeState);  		if (condEntry == null)  			return false;  		var stack2 = new ExpressionStack (compEnv' BottomE' nameSupply.GenSym' wdi.Body.BeforeState' trace);  		var postCondStatements = new Seq<Statement> ();  		if (!TranslateBlock (postCondStatements' wdi.Body' stack2' exid))  			return false;  		if (!stack2.Flush (postCondStatements' wdi.Body.AfterState))  			return false;  		preCondStatements.Add (new IfThenElseStatement (condEntry.Expression' new Statements (postCondStatements)' new Statements (new BreakStatement ())));  		statements.Add (new WhileDoStatement (new Int32ConstantExpression (1)' new Statements (preCondStatements)));  	}  	else {  		var loopStatements = BlockToStatements (wdi.Body' exid);  		if (loopStatements == null)  			return false;  		if (statements == null)  			return Failed (false' "while-do");  		statements.Add (new WhileDoStatement (condEntry.Expression' new Statements (loopStatements)));  	}  	if (!stack.Restore (wdi.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.DoWhilePseudo: {  	var dwi = (DoWhileInstruction)instruction;  	if (!stack.Flush (statements' dwi.Body.BeforeState))  		return false;  	var combined = new Seq<Instruction> ();  	foreach (var i in dwi.Body.Body)  		combined.Add (i);  	foreach (var i in dwi.Condition.Body)  		combined.Add (i);  	var condEntry = default(ExpressionStackEntry);  	var loopStatements = BlockToConditionStatements (new Instructions (null' combined)' dwi.Body.BeforeState' exid' out condEntry);  	if (loopStatements == null)  		return false;  	if (statements == null)  		return Failed (false' "do-while");  	statements.Add (new DoWhileStatement (new Statements (loopStatements)' condEntry.Expression));  	if (!stack.Restore (dwi.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.LoopControlPseudo: {  	var lci = (BreakContinueInstruction)instruction;  	if (!stack.Flush (statements' lci.BeforeState))  		return false;  	if (statements == null)  		return Failed (false' "loop-control");  	var targetState = default(int);  	switch (lci.Op) {  	case BreakContinueOp.Break:  		if (labelToLoopCandidateBreakState != null && labelToLoopCandidateBreakState.TryGetValue (lci.Label' out targetState))  			statements.Add (new GotoPseudoStatement (stateId' targetState));  		else  			statements.Add (new BreakStatement (lci.Label));  		break;  	case BreakContinueOp.Continue:  		if (labelToLoopCandidateContinueState != null && labelToLoopCandidateContinueState.TryGetValue (lci.Label' out targetState))  			statements.Add (new GotoPseudoStatement (stateId' targetState));  		else  			statements.Add (new ContinueStatement (lci.Label));  		break;  	default:  		throw new ArgumentOutOfRangeException ();  	}  	return true;  }  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (instruction.Flavor) {  case InstructionFlavor.Unsupported:  	throw new InvalidOperationException ("unsupported opcode");  case InstructionFlavor.Misc: {  	var misci = (MiscInstruction)instruction;  	switch (misci.Op) {  	case MiscOp.Nop:  	case MiscOp.Break:  		return true;  	case MiscOp.Dup:  		return stack.Dup (statements);  	case MiscOp.Pop:  		return stack.PopAndDiscard (statements);  	case MiscOp.Ldnull:  		stack.Push (new ExpressionStackEntry (new NullConstantExpression ()' BottomE));  		return true;  	case MiscOp.Ckfinite:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' UnaryOp.CheckFinite' false' false)' e.Lub (ThrowsE)));  	case MiscOp.Throw:  		if (!stack.DiscardAll (statements' 1))  			return false;  		if (!stack.PopEvalSE (statements' 1' true' ThrowsE' (s' a) => s.Add (new ThrowStatement (a [0]))))  			return false;  		return true;  	case MiscOp.Rethrow:  		if (!stack.DiscardAll (statements' 0))  			return false;  		if (statements == null)  			return Failed (false' "rethrow");  		if (exid == null)  			throw new InvalidOperationException ("rethrow outside of catch");  		statements.Add (new RethrowStatement (new VariableCell (exid).Read ()));  		return true;  	case MiscOp.LdindRef:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ReadExpression (a [0]).CloneIfStruct (compEnv)' e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ())));  	case MiscOp.LdelemRef:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' true).Read ().CloneIfStruct (compEnv)' e.Lub (ReadHeapOrThrowE)));  	case MiscOp.Ldlen:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' UnaryOp.Length' false' false)' e.Lub (ReadHeapOrThrowE)));  	case MiscOp.StindRef:  		return stack.PopEvalSE (statements' 2' true' instruction.BeforeState.PeekPointsTo (1).WriteEffect ()' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' a [1]))));  	case MiscOp.StelemRef:  		return stack.PopEvalSE (statements' 3' true' WriteHeapOrThrowE' (s' a) => s.Add (new ExpressionStatement (new ElementCell (a [0]' a [1]' false).Write (a [2]))));  	case MiscOp.Ret:  		if (statements == null)  			return Failed (false' "return");  		statements.Add (new ReturnStatement (null));  		return true;  	case MiscOp.RetVal:  		return stack.PopEvalSE (statements' 1' true' BottomE' (s' a) => s.Add (new ReturnStatement (a [0])));  	case MiscOp.Endfilter:  	case MiscOp.Endfinally:  		throw new InvalidOperationException ("endfilter/endfinally instructions should have been removed");  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Branch:  case InstructionFlavor.Switch:  	throw new InvalidOperationException ("branch/switch instructions should have been removed");  case InstructionFlavor.Compare: {  	var cmpi = (CompareInstruction)instruction;  	if (cmpi.Op == CompareOp.CtruePseudo || cmpi.Op == CompareOp.CfalsePseudo) {  		var s = cmpi.Type.Style (compEnv);  		var unop = default(UnaryOp);  		if (s is NumberTypeStyle)  			unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonZero : UnaryOp.IsZero;  		else  			unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonNull : UnaryOp.IsNull;  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' unop' false' cmpi.IsUnsigned)' e));  	}  	else {  		var binop = default(BinaryOp);  		switch (cmpi.Op) {  		case CompareOp.Ceq:  			binop = BinaryOp.Eq;  			break;  		case CompareOp.Clt:  			binop = BinaryOp.Lt;  			break;  		case CompareOp.Cgt:  			binop = BinaryOp.Gt;  			break;  		case CompareOp.CgePseudo:  			binop = BinaryOp.Ge;  			break;  		case CompareOp.ClePseudo:  			binop = BinaryOp.Le;  			break;  		case CompareOp.CnePseudo:  			binop = BinaryOp.Ne;  			break;  		case CompareOp.CtruePseudo:  		case CompareOp.CfalsePseudo:  			// handled above  			throw new InvalidOperationException ();  		default:  			throw new ArgumentOutOfRangeException ();  		}  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new BinaryExpression (a [0]' binop' a [1]' false' cmpi.IsUnsigned)' e));  	}  }  case InstructionFlavor.ArgLocal: {  	var sli = (ArgLocalInstruction)instruction;  	var id = default(JST.Identifier);  	switch (sli.ArgLocal) {  	case ArgLocal.Arg:  		id = compEnv.ValueParameterIds [sli.Index];  		break;  	case ArgLocal.Local:  		id = compEnv.LocalIds [sli.Index];  		break;  	default:  		throw new ArgumentOutOfRangeException ();  	}  	var cell = new VariableCell (id);  	switch (sli.Op) {  	case ArgLocalOp.Ld:  		stack.Push (new ExpressionStackEntry (cell.Read ().CloneIfStruct (compEnv)' ReadArgLocalE (sli.ArgLocal' sli.Index)));  		return true;  	case ArgLocalOp.Lda:  		// Effect will be accounted for on reads/writes  		stack.Push (new ExpressionStackEntry (cell.AddressOf ()' BottomE));  		return true;  	case ArgLocalOp.St:  		return stack.PopEvalSE (statements' 1' true' WriteArgLocalE (sli.ArgLocal' sli.Index)' (s' a) => s.Add (new ExpressionStatement (cell.Write (a [0]))));  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Field: {  	var fieldi = (FieldInstruction)instruction;  	switch (fieldi.Op) {  	case FieldOp.Ldfld:  		if (fieldi.IsStatic) {  			stack.Push (new ExpressionStackEntry (new FieldCell (null' compEnv.SubstituteMember (fieldi.Field)).Read ().CloneIfStruct (compEnv)' ReadHeapE));  			return true;  		}  		else  			return stack.PopEvalPush (statements' 1' true' (a' e) =>  {  				var readEffect = default(Effects);  				var obj = default(Expression);  				if (fieldi.IsViaPointer.Value) {  					readEffect = e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ());  					obj = new ReadExpression (a [0]);  					// no need for clone  				}  				else if (fieldi.Field.DefiningType.Style (compEnv) is ValueTypeStyle) {  					readEffect = e;  					obj = a [0];  				}  				else {  					// Object could be null  					readEffect = e.Lub (ReadHeapOrThrowE);  					obj = a [0];  				}  				return new ExpressionStackEntry (new FieldCell (obj' compEnv.SubstituteMember (fieldi.Field)).Read ().CloneIfStruct (compEnv)' readEffect);  			});  	case FieldOp.Ldflda:  		if (fieldi.IsStatic) {  			// Effect will be accounted for on reads/writes  			stack.Push (new ExpressionStackEntry (new FieldCell (null' compEnv.SubstituteMember (fieldi.Field)).AddressOf ()' BottomE));  			return true;  		}  		else  			return stack.PopEvalPush (statements' 1' true' (a' e) =>  {  				if (fieldi.IsViaPointer.Value)  					// We're just adding an offset to a pointer' so effect will  					// be accounted for when the final pointer is read/written  					return new ExpressionStackEntry (new FieldCell (new ReadExpression (a [0])' compEnv.SubstituteMember (fieldi.Field)).AddressOf ()' e);  				else  					// Must be a reference type' and ref could be null  					return new ExpressionStackEntry (new FieldCell (a [0]' compEnv.SubstituteMember (fieldi.Field)).AddressOf ()' e.Lub (ThrowsE));  			});  	case FieldOp.Stfld:  		if (fieldi.IsStatic)  			return stack.PopEvalSE (statements' 1' true' WriteHeapE' (s' a) => s.Add (new ExpressionStatement (new FieldCell (null' compEnv.SubstituteMember (fieldi.Field)).Write (a [0]))));  		else {  			var writeEffect = fieldi.IsViaPointer.Value ? instruction.BeforeState.PeekPointsTo (1).WriteEffect () : WriteHeapOrThrowE;  			return stack.PopEvalSE (statements' 2' true' writeEffect' (s' a) =>  {  				var obj = fieldi.IsViaPointer.Value ? new ReadExpression (a [0]) : a [0];  				s.Add (new ExpressionStatement (new FieldCell (obj' compEnv.SubstituteMember (fieldi.Field)).Write (a [1])));  			});  		}  	case FieldOp.Ldtoken:  		stack.Push (new ExpressionStackEntry (new FieldHandleConstantExpression (compEnv.SubstituteMember (fieldi.Field))' BottomE));  		return true;  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Method: {  	var methodi = (MethodInstruction)instruction;  	var arity = methodi.Method.ValueParameters.Count;  	switch (methodi.Op) {  	case MethodOp.Ldftn:  		if (methodi.IsVirtual)  			// Object could be null  			return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new CodePointerExpression (a [0]' compEnv.SubstituteMember (methodi.Method))' e.Lub (ReadHeapOrThrowE)));  		else {  			stack.Push (new ExpressionStackEntry (new CodePointerExpression (null' compEnv.SubstituteMember (methodi.Method))' BottomE));  			return true;  		}  	case MethodOp.Call:  		if (methodi.Method.Result == null)  			return stack.PopEvalSE (statements' arity' true' CalleeEffects (methodi.BeforeState' arity)' (s' a) => s.Add (new ExpressionStatement (new CallExpression (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal' compEnv.SubstituteMember (methodi.Method)' CallerArguments (methodi.Constrained' methodi.Method' a)))));  		else  			return stack.PopEvalPush (statements' arity' true' (a' e) => new ExpressionStackEntry (new CallExpression (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal' compEnv.SubstituteMember (methodi.Method)' CallerArguments (methodi.Constrained' methodi.Method' a))' e.Lub (CalleeEffects (methodi.BeforeState' arity))));  	case MethodOp.Newobj:  		arity--;  		return stack.PopEvalPush (statements' arity' true' (a' e) => new ExpressionStackEntry (new NewObjectExpression (compEnv.SubstituteMember (methodi.Method)' CallerArguments (null' methodi.Method' a))' e.Lub (CalleeEffects (methodi.BeforeState' arity))));  	case MethodOp.Ldtoken:  		stack.Push (new ExpressionStackEntry (new MethodHandleConstantExpression (compEnv.SubstituteMember (methodi.Method))' BottomE));  		return true;  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Type: {  	var typei = (TypeInstruction)instruction;  	switch (typei.Op) {  	case TypeOp.Ldobj:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ReadExpression (a [0]).CloneIfStruct (compEnv)' e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ())));  	case TypeOp.Stobj:  		return stack.PopEvalSE (statements' 2' true' instruction.BeforeState.PeekPointsTo (1).WriteEffect ()' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' a [1]))));  	case TypeOp.Cpobj: {  		var copyEffect = instruction.BeforeState.PeekPointsTo (0).ReadEffect ().Lub (instruction.BeforeState.PeekPointsTo (1).WriteEffect ());  		return stack.PopEvalSE (statements' 2' true' copyEffect' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' new ReadExpression (a [1]).CloneIfStruct (compEnv)))));  	}  	case TypeOp.Newarr:  		// Growing the heap is not considered an observable change. But will throw if  		// length < 0  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new NewArrayExpression (a [0]' compEnv.SubstituteType (typei.Type))' e.Lub (ThrowsE)));  	case TypeOp.Initobj:  		return stack.PopEvalSE (statements' 1' true' WriteHeapE' (s' a) => s.Add (new InitializeObjectStatement (a [0])));  	case TypeOp.Castclass:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new CastExpression (a [0]' compEnv.SubstituteType (typei.Type))' e.Lub (ThrowsE)));  	case TypeOp.Isinst:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new IsInstExpression (a [0]' compEnv.SubstituteType (typei.Type))' e));  	case TypeOp.Box:  		// Growing the heap is not considered an observable change  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new NewBoxExpression (a [0]' compEnv.SubstituteType (typei.Type))' e));  	case TypeOp.Unbox:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new BoxCell (a [0]' compEnv.SubstituteType (typei.Type)).AddressOf ()' e.Lub (ThrowsE)));  	case TypeOp.UnboxAny:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new BoxCell (a [0]' compEnv.SubstituteType (typei.Type)).Read ().CloneIfStruct (compEnv)' e.Lub (ThrowsE)));  	case TypeOp.Ldtoken:  		stack.Push (new ExpressionStackEntry (new TypeHandleConstantExpression (compEnv.SubstituteType (typei.Type))' BottomE));  		return true;  	case TypeOp.Ldelem:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' true).Read ().CloneIfStruct (compEnv)' e.Lub (ReadHeapOrThrowE)));  	case TypeOp.Stelem:  		return stack.PopEvalSE (statements' 3' true' WriteHeapOrThrowE' (s' a) => s.Add (new ExpressionStatement (new ElementCell (a [0]' a [1]' false).Write (a [2]))));  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.LdElemAddr:  	// Calculating the pointer may throw if index is out of range.  	// Remaining effect will be accounted for when pointer is read/written.  	return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' false).AddressOf ()' e.Lub (ThrowsE)));  case InstructionFlavor.LdInt32: {  	var int32i = (LdInt32Instruction)instruction;  	stack.Push (new ExpressionStackEntry (new Int32ConstantExpression (int32i.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdInt64: {  	var int64i = (LdInt64Instruction)instruction;  	stack.Push (new ExpressionStackEntry (new Int64ConstantExpression (int64i.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdSingle: {  	var singlei = (LdSingleInstruction)instruction;  	stack.Push (new ExpressionStackEntry (new SingleConstantExpression (singlei.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdDouble: {  	var doublei = (LdDoubleInstruction)instruction;  	stack.Push (new ExpressionStackEntry (new DoubleConstantExpression (doublei.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdString: {  	var stringi = (LdStringInstruction)instruction;  	stack.Push (new ExpressionStackEntry (new StringConstantExpression (stringi.Value)' BottomE));  	return true;  }  case InstructionFlavor.Arith: {  	var arithi = (ArithInstruction)instruction;  	switch (arithi.Op) {  	case ArithOp.Div:  	case ArithOp.Rem:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new BinaryExpression (a [0]' ArithOpToBinaryOp (arithi.Op)' a [1]' arithi.WithOverflow' arithi.IsUnsigned)' e.Lub (ThrowsE)));  	case ArithOp.Add:  	case ArithOp.Sub:  	case ArithOp.Mul:  	case ArithOp.BitAnd:  	case ArithOp.BitOr:  	case ArithOp.BitXor:  	case ArithOp.Shl:  	case ArithOp.Shr:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new BinaryExpression (a [0]' ArithOpToBinaryOp (arithi.Op)' a [1]' arithi.WithOverflow' arithi.IsUnsigned)' e.Lub (arithi.WithOverflow ? ThrowsE : BottomE)));  	case ArithOp.Neg:  	case ArithOp.BitNot:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' ArithOpToUnaryOp (arithi.Op)' arithi.WithOverflow' arithi.IsUnsigned)' e));  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Conv: {  	var convi = (ConvInstruction)instruction;  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ConvertExpression (a [0]' new NamedTypeRef (compEnv.Global.NumberFlavorToQualifiedTypeName [convi.TargetNumberFlavor])' convi.WithOverflow' convi.IsSourceUnsigned)' e.Lub (convi.WithOverflow ? ThrowsE : BottomE)));  }  case InstructionFlavor.Try: {  	if (stack.Depth > 0)  		throw new InvalidOperationException ("stack must be empty on entry to try block");  	var tryi = (TryInstruction)instruction;  	var tryStatements = BlockToTryFaultFinallyStatements (tryi.Body);  	if (tryStatements == null)  		return false;  	var handlers = TranslateHandlers (tryi.Handlers);  	if (handlers == null)  		return false;  	if (statements == null)  		return Failed (false' "try");  	statements.Add (new TryStatement (tryStatements' handlers));  	return true;  }  case InstructionFlavor.IfThenElsePseudo: {  	var itei = (IfThenElseInstruction)instruction;  	var isExpr = default(bool);  	// If outer context is re-translating as statements instead of expression' jump directly  	// to appropriate translation for this instruction  	var couldBeExpression = !instructionTranslationStyleCache.TryGetValue (itei.Offset' out isExpr) || isExpr;  	if (!TranslateBlock (statements' itei.Condition' stack' exid))  		return false;  	if (couldBeExpression && itei.Else != null) {  		// Pass 1: Try to tranlate to an if-then-else expression. Will only work if Then and Else don't  		//         reach into current stack' push exactly one value' and don't need to emit any  		//         statements along the way.  		var thenEntry = BlockToExpression (itei.Then' exid);  		if (thenEntry != null) {  			var elseEntry = BlockToExpression (itei.Else' exid);  			if (elseEntry != null) {  				if (!instructionTranslationStyleCache.ContainsKey (itei.Offset))  					instructionTranslationStyleCache.Add (itei.Offset' true);  				return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new IfThenElseExpression (a [0]' thenEntry.Expression' elseEntry.Expression)' e.Lub (thenEntry.Effects.Lub (elseEntry.Effects))));  			}  			// else: fallthrough  		}  		// else: fallthrough  	}  	// else: fallthrough  	// Pass 2: Translate to a statement  	var noStackChange = itei.Then.NoStackChange && (itei.Else == null || itei.Else.NoStackChange);  	var condEntry = noStackChange ? stack.Pop () : stack.FlushAndPopPostState (statements' itei.Then.BeforeState);  	if (condEntry == null)  		return false;  	var thenStmnts = noStackChange ? BlockToStatementsEmptyStack (itei.Then' exid) : BlockToStatements (itei.Then' exid);  	if (thenStmnts == null)  		return false;  	var elseStmnts = default(Seq<Statement>);  	if (itei.Else != null) {  		elseStmnts = noStackChange ? BlockToStatementsEmptyStack (itei.Else' exid) : BlockToStatements (itei.Else' exid);  		if (elseStmnts == null)  			return false;  	}  	if (statements == null)  		return Failed (false' "if-then-else");  	statements.Add (new IfThenElseStatement (condEntry.Expression' new Statements (thenStmnts)' elseStmnts == null ? null : new Statements (elseStmnts)));  	if (!noStackChange && !stack.Restore (itei.AfterState' 0))  		return false;  	if (!instructionTranslationStyleCache.ContainsKey (itei.Offset))  		instructionTranslationStyleCache.Add (itei.Offset' false);  	return true;  }  case InstructionFlavor.ShortCircuitingPseudo: {  	var sci = (ShortCircuitingInstruction)instruction;  	var isExpr = default(bool);  	// If outer context is re-translating as statements instead of expression' jump directly  	// to appropriate translation for this instruction  	var couldBeExpression = !instructionTranslationStyleCache.TryGetValue (sci.Offset' out isExpr) || isExpr;  	if (couldBeExpression) {  		// Pass 1: Try to translate to an expression.  		var leftEntry = BlockToExpression (sci.Left' exid);  		if (leftEntry != null) {  			var rightEntry = BlockToExpression (sci.Right' exid);  			if (rightEntry != null) {  				stack.Push (new ExpressionStackEntry (new BinaryExpression (leftEntry.Expression' ShortCircuitingOpToBinaryOp (sci.Op)' rightEntry.Expression' false' false)' leftEntry.Effects.Lub (rightEntry.Effects)));  				if (!instructionTranslationStyleCache.ContainsKey (sci.Offset))  					instructionTranslationStyleCache.Add (sci.Offset' true);  				return true;  			}  			// else: fallthrough  		}  		// else: fallthrough  	}  	// else: fallthrough  	// Pass 2: Translate to a statement  	if (!TranslateBlock (statements' sci.Left' stack' exid))  		return false;  	var leftEntry2 = stack.FlushAndPopPostState (statements' sci.Right.BeforeState);  	if (leftEntry2 == null)  		return false;  	var rightStatements = BlockToStatements (sci.Right' exid);  	if (rightStatements == null)  		return false;  	var id = sci.Right.AfterState.PeekId (0' nameSupply.GenSym);  	var cell = new VariableCell (id);  	compEnv.AddVariable (id' ArgLocal.Local' false' true' compEnv.SubstituteType (sci.Right.AfterState.PeekType (0)));  	if (statements == null)  		return Failed (false' "short-circuit");  	switch (sci.Op) {  	case ShortCircuitingOp.And:  		statements.Add (new IfThenElseStatement (leftEntry2.Expression' new Statements (rightStatements)' new Statements (new ExpressionStatement (cell.Write (new Int32ConstantExpression (0))))));  		break;  	case ShortCircuitingOp.Or:  		statements.Add (new IfThenElseStatement (leftEntry2.Expression' new Statements (new ExpressionStatement (cell.Write (new Int32ConstantExpression (1))))' new Statements (rightStatements)));  		break;  	default:  		throw new ArgumentOutOfRangeException ();  	}  	if (!stack.Restore (sci.AfterState' 1))  		return false;  	stack.Push (new ExpressionStackEntry (cell.Read ()' BottomE));  	if (!instructionTranslationStyleCache.ContainsKey (sci.Offset))  		instructionTranslationStyleCache.Add (sci.Offset' false);  	return true;  }  case InstructionFlavor.StructuralSwitchPseudo: {  	var ssi = (StructuralSwitchInstruction)instruction;  	if (!TranslateBlock (statements' ssi.Body' stack' exid))  		return false;  	var valueEntry = stack.FlushAndPopPreState (statements' ssi.Body.AfterState);  	if (valueEntry == null)  		return false;  	var cases = new Seq<SwitchStatementCase> ();  	foreach (var c in ssi.Cases) {  		var caseStatements = BlockToStatements (c.Body' exid);  		if (caseStatements == null)  			return false;  		cases.Add (new SwitchStatementCase (c.Values' new Statements (caseStatements)));  	}  	if (statements == null)  		return Failed (false' "structural switch");  	statements.Add (new SwitchStatement (valueEntry.Expression' cases));  	if (!stack.Restore (ssi.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.LoopPseudo: {  	var li = (LoopInstruction)instruction;  	if (!stack.Flush (statements' li.Body.BeforeState))  		return false;  	if (statements == null)  		return Failed (false' "loop");  	var whileStatements = BlockToStatements (li.Body' exid);  	statements.Add (new WhileDoStatement (new Int32ConstantExpression (1)' new Statements (whileStatements)));  	if (!stack.Restore (li.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.WhileDoPseudo: {  	var wdi = (WhileDoInstruction)instruction;  	if (!stack.Flush (statements' wdi.Condition.BeforeState))  		return false;  	var condEntry = BlockToExpression (wdi.Condition' exid);  	if (condEntry == null) {  		var stack1 = new ExpressionStack (compEnv' BottomE' nameSupply.GenSym' wdi.Condition.BeforeState' trace);  		var preCondStatements = new Seq<Statement> ();  		if (!TranslateBlock (preCondStatements' wdi.Condition' stack1' exid))  			return false;  		condEntry = stack1.FlushAndPopPostState (preCondStatements' wdi.Body.BeforeState);  		if (condEntry == null)  			return false;  		var stack2 = new ExpressionStack (compEnv' BottomE' nameSupply.GenSym' wdi.Body.BeforeState' trace);  		var postCondStatements = new Seq<Statement> ();  		if (!TranslateBlock (postCondStatements' wdi.Body' stack2' exid))  			return false;  		if (!stack2.Flush (postCondStatements' wdi.Body.AfterState))  			return false;  		preCondStatements.Add (new IfThenElseStatement (condEntry.Expression' new Statements (postCondStatements)' new Statements (new BreakStatement ())));  		statements.Add (new WhileDoStatement (new Int32ConstantExpression (1)' new Statements (preCondStatements)));  	}  	else {  		var loopStatements = BlockToStatements (wdi.Body' exid);  		if (loopStatements == null)  			return false;  		if (statements == null)  			return Failed (false' "while-do");  		statements.Add (new WhileDoStatement (condEntry.Expression' new Statements (loopStatements)));  	}  	if (!stack.Restore (wdi.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.DoWhilePseudo: {  	var dwi = (DoWhileInstruction)instruction;  	if (!stack.Flush (statements' dwi.Body.BeforeState))  		return false;  	var combined = new Seq<Instruction> ();  	foreach (var i in dwi.Body.Body)  		combined.Add (i);  	foreach (var i in dwi.Condition.Body)  		combined.Add (i);  	var condEntry = default(ExpressionStackEntry);  	var loopStatements = BlockToConditionStatements (new Instructions (null' combined)' dwi.Body.BeforeState' exid' out condEntry);  	if (loopStatements == null)  		return false;  	if (statements == null)  		return Failed (false' "do-while");  	statements.Add (new DoWhileStatement (new Statements (loopStatements)' condEntry.Expression));  	if (!stack.Restore (dwi.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.LoopControlPseudo: {  	var lci = (BreakContinueInstruction)instruction;  	if (!stack.Flush (statements' lci.BeforeState))  		return false;  	if (statements == null)  		return Failed (false' "loop-control");  	var targetState = default(int);  	switch (lci.Op) {  	case BreakContinueOp.Break:  		if (labelToLoopCandidateBreakState != null && labelToLoopCandidateBreakState.TryGetValue (lci.Label' out targetState))  			statements.Add (new GotoPseudoStatement (stateId' targetState));  		else  			statements.Add (new BreakStatement (lci.Label));  		break;  	case BreakContinueOp.Continue:  		if (labelToLoopCandidateContinueState != null && labelToLoopCandidateContinueState.TryGetValue (lci.Label' out targetState))  			statements.Add (new GotoPseudoStatement (stateId' targetState));  		else  			statements.Add (new ContinueStatement (lci.Label));  		break;  	default:  		throw new ArgumentOutOfRangeException ();  	}  	return true;  }  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (instruction.Flavor) {  case InstructionFlavor.Unsupported:  	throw new InvalidOperationException ("unsupported opcode");  case InstructionFlavor.Misc: {  	var misci = (MiscInstruction)instruction;  	switch (misci.Op) {  	case MiscOp.Nop:  	case MiscOp.Break:  		return true;  	case MiscOp.Dup:  		return stack.Dup (statements);  	case MiscOp.Pop:  		return stack.PopAndDiscard (statements);  	case MiscOp.Ldnull:  		stack.Push (new ExpressionStackEntry (new NullConstantExpression ()' BottomE));  		return true;  	case MiscOp.Ckfinite:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' UnaryOp.CheckFinite' false' false)' e.Lub (ThrowsE)));  	case MiscOp.Throw:  		if (!stack.DiscardAll (statements' 1))  			return false;  		if (!stack.PopEvalSE (statements' 1' true' ThrowsE' (s' a) => s.Add (new ThrowStatement (a [0]))))  			return false;  		return true;  	case MiscOp.Rethrow:  		if (!stack.DiscardAll (statements' 0))  			return false;  		if (statements == null)  			return Failed (false' "rethrow");  		if (exid == null)  			throw new InvalidOperationException ("rethrow outside of catch");  		statements.Add (new RethrowStatement (new VariableCell (exid).Read ()));  		return true;  	case MiscOp.LdindRef:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ReadExpression (a [0]).CloneIfStruct (compEnv)' e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ())));  	case MiscOp.LdelemRef:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' true).Read ().CloneIfStruct (compEnv)' e.Lub (ReadHeapOrThrowE)));  	case MiscOp.Ldlen:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' UnaryOp.Length' false' false)' e.Lub (ReadHeapOrThrowE)));  	case MiscOp.StindRef:  		return stack.PopEvalSE (statements' 2' true' instruction.BeforeState.PeekPointsTo (1).WriteEffect ()' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' a [1]))));  	case MiscOp.StelemRef:  		return stack.PopEvalSE (statements' 3' true' WriteHeapOrThrowE' (s' a) => s.Add (new ExpressionStatement (new ElementCell (a [0]' a [1]' false).Write (a [2]))));  	case MiscOp.Ret:  		if (statements == null)  			return Failed (false' "return");  		statements.Add (new ReturnStatement (null));  		return true;  	case MiscOp.RetVal:  		return stack.PopEvalSE (statements' 1' true' BottomE' (s' a) => s.Add (new ReturnStatement (a [0])));  	case MiscOp.Endfilter:  	case MiscOp.Endfinally:  		throw new InvalidOperationException ("endfilter/endfinally instructions should have been removed");  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Branch:  case InstructionFlavor.Switch:  	throw new InvalidOperationException ("branch/switch instructions should have been removed");  case InstructionFlavor.Compare: {  	var cmpi = (CompareInstruction)instruction;  	if (cmpi.Op == CompareOp.CtruePseudo || cmpi.Op == CompareOp.CfalsePseudo) {  		var s = cmpi.Type.Style (compEnv);  		var unop = default(UnaryOp);  		if (s is NumberTypeStyle)  			unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonZero : UnaryOp.IsZero;  		else  			unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonNull : UnaryOp.IsNull;  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' unop' false' cmpi.IsUnsigned)' e));  	}  	else {  		var binop = default(BinaryOp);  		switch (cmpi.Op) {  		case CompareOp.Ceq:  			binop = BinaryOp.Eq;  			break;  		case CompareOp.Clt:  			binop = BinaryOp.Lt;  			break;  		case CompareOp.Cgt:  			binop = BinaryOp.Gt;  			break;  		case CompareOp.CgePseudo:  			binop = BinaryOp.Ge;  			break;  		case CompareOp.ClePseudo:  			binop = BinaryOp.Le;  			break;  		case CompareOp.CnePseudo:  			binop = BinaryOp.Ne;  			break;  		case CompareOp.CtruePseudo:  		case CompareOp.CfalsePseudo:  			// handled above  			throw new InvalidOperationException ();  		default:  			throw new ArgumentOutOfRangeException ();  		}  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new BinaryExpression (a [0]' binop' a [1]' false' cmpi.IsUnsigned)' e));  	}  }  case InstructionFlavor.ArgLocal: {  	var sli = (ArgLocalInstruction)instruction;  	var id = default(JST.Identifier);  	switch (sli.ArgLocal) {  	case ArgLocal.Arg:  		id = compEnv.ValueParameterIds [sli.Index];  		break;  	case ArgLocal.Local:  		id = compEnv.LocalIds [sli.Index];  		break;  	default:  		throw new ArgumentOutOfRangeException ();  	}  	var cell = new VariableCell (id);  	switch (sli.Op) {  	case ArgLocalOp.Ld:  		stack.Push (new ExpressionStackEntry (cell.Read ().CloneIfStruct (compEnv)' ReadArgLocalE (sli.ArgLocal' sli.Index)));  		return true;  	case ArgLocalOp.Lda:  		// Effect will be accounted for on reads/writes  		stack.Push (new ExpressionStackEntry (cell.AddressOf ()' BottomE));  		return true;  	case ArgLocalOp.St:  		return stack.PopEvalSE (statements' 1' true' WriteArgLocalE (sli.ArgLocal' sli.Index)' (s' a) => s.Add (new ExpressionStatement (cell.Write (a [0]))));  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Field: {  	var fieldi = (FieldInstruction)instruction;  	switch (fieldi.Op) {  	case FieldOp.Ldfld:  		if (fieldi.IsStatic) {  			stack.Push (new ExpressionStackEntry (new FieldCell (null' compEnv.SubstituteMember (fieldi.Field)).Read ().CloneIfStruct (compEnv)' ReadHeapE));  			return true;  		}  		else  			return stack.PopEvalPush (statements' 1' true' (a' e) =>  {  				var readEffect = default(Effects);  				var obj = default(Expression);  				if (fieldi.IsViaPointer.Value) {  					readEffect = e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ());  					obj = new ReadExpression (a [0]);  					// no need for clone  				}  				else if (fieldi.Field.DefiningType.Style (compEnv) is ValueTypeStyle) {  					readEffect = e;  					obj = a [0];  				}  				else {  					// Object could be null  					readEffect = e.Lub (ReadHeapOrThrowE);  					obj = a [0];  				}  				return new ExpressionStackEntry (new FieldCell (obj' compEnv.SubstituteMember (fieldi.Field)).Read ().CloneIfStruct (compEnv)' readEffect);  			});  	case FieldOp.Ldflda:  		if (fieldi.IsStatic) {  			// Effect will be accounted for on reads/writes  			stack.Push (new ExpressionStackEntry (new FieldCell (null' compEnv.SubstituteMember (fieldi.Field)).AddressOf ()' BottomE));  			return true;  		}  		else  			return stack.PopEvalPush (statements' 1' true' (a' e) =>  {  				if (fieldi.IsViaPointer.Value)  					// We're just adding an offset to a pointer' so effect will  					// be accounted for when the final pointer is read/written  					return new ExpressionStackEntry (new FieldCell (new ReadExpression (a [0])' compEnv.SubstituteMember (fieldi.Field)).AddressOf ()' e);  				else  					// Must be a reference type' and ref could be null  					return new ExpressionStackEntry (new FieldCell (a [0]' compEnv.SubstituteMember (fieldi.Field)).AddressOf ()' e.Lub (ThrowsE));  			});  	case FieldOp.Stfld:  		if (fieldi.IsStatic)  			return stack.PopEvalSE (statements' 1' true' WriteHeapE' (s' a) => s.Add (new ExpressionStatement (new FieldCell (null' compEnv.SubstituteMember (fieldi.Field)).Write (a [0]))));  		else {  			var writeEffect = fieldi.IsViaPointer.Value ? instruction.BeforeState.PeekPointsTo (1).WriteEffect () : WriteHeapOrThrowE;  			return stack.PopEvalSE (statements' 2' true' writeEffect' (s' a) =>  {  				var obj = fieldi.IsViaPointer.Value ? new ReadExpression (a [0]) : a [0];  				s.Add (new ExpressionStatement (new FieldCell (obj' compEnv.SubstituteMember (fieldi.Field)).Write (a [1])));  			});  		}  	case FieldOp.Ldtoken:  		stack.Push (new ExpressionStackEntry (new FieldHandleConstantExpression (compEnv.SubstituteMember (fieldi.Field))' BottomE));  		return true;  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Method: {  	var methodi = (MethodInstruction)instruction;  	var arity = methodi.Method.ValueParameters.Count;  	switch (methodi.Op) {  	case MethodOp.Ldftn:  		if (methodi.IsVirtual)  			// Object could be null  			return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new CodePointerExpression (a [0]' compEnv.SubstituteMember (methodi.Method))' e.Lub (ReadHeapOrThrowE)));  		else {  			stack.Push (new ExpressionStackEntry (new CodePointerExpression (null' compEnv.SubstituteMember (methodi.Method))' BottomE));  			return true;  		}  	case MethodOp.Call:  		if (methodi.Method.Result == null)  			return stack.PopEvalSE (statements' arity' true' CalleeEffects (methodi.BeforeState' arity)' (s' a) => s.Add (new ExpressionStatement (new CallExpression (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal' compEnv.SubstituteMember (methodi.Method)' CallerArguments (methodi.Constrained' methodi.Method' a)))));  		else  			return stack.PopEvalPush (statements' arity' true' (a' e) => new ExpressionStackEntry (new CallExpression (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal' compEnv.SubstituteMember (methodi.Method)' CallerArguments (methodi.Constrained' methodi.Method' a))' e.Lub (CalleeEffects (methodi.BeforeState' arity))));  	case MethodOp.Newobj:  		arity--;  		return stack.PopEvalPush (statements' arity' true' (a' e) => new ExpressionStackEntry (new NewObjectExpression (compEnv.SubstituteMember (methodi.Method)' CallerArguments (null' methodi.Method' a))' e.Lub (CalleeEffects (methodi.BeforeState' arity))));  	case MethodOp.Ldtoken:  		stack.Push (new ExpressionStackEntry (new MethodHandleConstantExpression (compEnv.SubstituteMember (methodi.Method))' BottomE));  		return true;  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Type: {  	var typei = (TypeInstruction)instruction;  	switch (typei.Op) {  	case TypeOp.Ldobj:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ReadExpression (a [0]).CloneIfStruct (compEnv)' e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ())));  	case TypeOp.Stobj:  		return stack.PopEvalSE (statements' 2' true' instruction.BeforeState.PeekPointsTo (1).WriteEffect ()' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' a [1]))));  	case TypeOp.Cpobj: {  		var copyEffect = instruction.BeforeState.PeekPointsTo (0).ReadEffect ().Lub (instruction.BeforeState.PeekPointsTo (1).WriteEffect ());  		return stack.PopEvalSE (statements' 2' true' copyEffect' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' new ReadExpression (a [1]).CloneIfStruct (compEnv)))));  	}  	case TypeOp.Newarr:  		// Growing the heap is not considered an observable change. But will throw if  		// length < 0  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new NewArrayExpression (a [0]' compEnv.SubstituteType (typei.Type))' e.Lub (ThrowsE)));  	case TypeOp.Initobj:  		return stack.PopEvalSE (statements' 1' true' WriteHeapE' (s' a) => s.Add (new InitializeObjectStatement (a [0])));  	case TypeOp.Castclass:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new CastExpression (a [0]' compEnv.SubstituteType (typei.Type))' e.Lub (ThrowsE)));  	case TypeOp.Isinst:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new IsInstExpression (a [0]' compEnv.SubstituteType (typei.Type))' e));  	case TypeOp.Box:  		// Growing the heap is not considered an observable change  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new NewBoxExpression (a [0]' compEnv.SubstituteType (typei.Type))' e));  	case TypeOp.Unbox:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new BoxCell (a [0]' compEnv.SubstituteType (typei.Type)).AddressOf ()' e.Lub (ThrowsE)));  	case TypeOp.UnboxAny:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new BoxCell (a [0]' compEnv.SubstituteType (typei.Type)).Read ().CloneIfStruct (compEnv)' e.Lub (ThrowsE)));  	case TypeOp.Ldtoken:  		stack.Push (new ExpressionStackEntry (new TypeHandleConstantExpression (compEnv.SubstituteType (typei.Type))' BottomE));  		return true;  	case TypeOp.Ldelem:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' true).Read ().CloneIfStruct (compEnv)' e.Lub (ReadHeapOrThrowE)));  	case TypeOp.Stelem:  		return stack.PopEvalSE (statements' 3' true' WriteHeapOrThrowE' (s' a) => s.Add (new ExpressionStatement (new ElementCell (a [0]' a [1]' false).Write (a [2]))));  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.LdElemAddr:  	// Calculating the pointer may throw if index is out of range.  	// Remaining effect will be accounted for when pointer is read/written.  	return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' false).AddressOf ()' e.Lub (ThrowsE)));  case InstructionFlavor.LdInt32: {  	var int32i = (LdInt32Instruction)instruction;  	stack.Push (new ExpressionStackEntry (new Int32ConstantExpression (int32i.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdInt64: {  	var int64i = (LdInt64Instruction)instruction;  	stack.Push (new ExpressionStackEntry (new Int64ConstantExpression (int64i.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdSingle: {  	var singlei = (LdSingleInstruction)instruction;  	stack.Push (new ExpressionStackEntry (new SingleConstantExpression (singlei.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdDouble: {  	var doublei = (LdDoubleInstruction)instruction;  	stack.Push (new ExpressionStackEntry (new DoubleConstantExpression (doublei.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdString: {  	var stringi = (LdStringInstruction)instruction;  	stack.Push (new ExpressionStackEntry (new StringConstantExpression (stringi.Value)' BottomE));  	return true;  }  case InstructionFlavor.Arith: {  	var arithi = (ArithInstruction)instruction;  	switch (arithi.Op) {  	case ArithOp.Div:  	case ArithOp.Rem:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new BinaryExpression (a [0]' ArithOpToBinaryOp (arithi.Op)' a [1]' arithi.WithOverflow' arithi.IsUnsigned)' e.Lub (ThrowsE)));  	case ArithOp.Add:  	case ArithOp.Sub:  	case ArithOp.Mul:  	case ArithOp.BitAnd:  	case ArithOp.BitOr:  	case ArithOp.BitXor:  	case ArithOp.Shl:  	case ArithOp.Shr:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new BinaryExpression (a [0]' ArithOpToBinaryOp (arithi.Op)' a [1]' arithi.WithOverflow' arithi.IsUnsigned)' e.Lub (arithi.WithOverflow ? ThrowsE : BottomE)));  	case ArithOp.Neg:  	case ArithOp.BitNot:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' ArithOpToUnaryOp (arithi.Op)' arithi.WithOverflow' arithi.IsUnsigned)' e));  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Conv: {  	var convi = (ConvInstruction)instruction;  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ConvertExpression (a [0]' new NamedTypeRef (compEnv.Global.NumberFlavorToQualifiedTypeName [convi.TargetNumberFlavor])' convi.WithOverflow' convi.IsSourceUnsigned)' e.Lub (convi.WithOverflow ? ThrowsE : BottomE)));  }  case InstructionFlavor.Try: {  	if (stack.Depth > 0)  		throw new InvalidOperationException ("stack must be empty on entry to try block");  	var tryi = (TryInstruction)instruction;  	var tryStatements = BlockToTryFaultFinallyStatements (tryi.Body);  	if (tryStatements == null)  		return false;  	var handlers = TranslateHandlers (tryi.Handlers);  	if (handlers == null)  		return false;  	if (statements == null)  		return Failed (false' "try");  	statements.Add (new TryStatement (tryStatements' handlers));  	return true;  }  case InstructionFlavor.IfThenElsePseudo: {  	var itei = (IfThenElseInstruction)instruction;  	var isExpr = default(bool);  	// If outer context is re-translating as statements instead of expression' jump directly  	// to appropriate translation for this instruction  	var couldBeExpression = !instructionTranslationStyleCache.TryGetValue (itei.Offset' out isExpr) || isExpr;  	if (!TranslateBlock (statements' itei.Condition' stack' exid))  		return false;  	if (couldBeExpression && itei.Else != null) {  		// Pass 1: Try to tranlate to an if-then-else expression. Will only work if Then and Else don't  		//         reach into current stack' push exactly one value' and don't need to emit any  		//         statements along the way.  		var thenEntry = BlockToExpression (itei.Then' exid);  		if (thenEntry != null) {  			var elseEntry = BlockToExpression (itei.Else' exid);  			if (elseEntry != null) {  				if (!instructionTranslationStyleCache.ContainsKey (itei.Offset))  					instructionTranslationStyleCache.Add (itei.Offset' true);  				return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new IfThenElseExpression (a [0]' thenEntry.Expression' elseEntry.Expression)' e.Lub (thenEntry.Effects.Lub (elseEntry.Effects))));  			}  			// else: fallthrough  		}  		// else: fallthrough  	}  	// else: fallthrough  	// Pass 2: Translate to a statement  	var noStackChange = itei.Then.NoStackChange && (itei.Else == null || itei.Else.NoStackChange);  	var condEntry = noStackChange ? stack.Pop () : stack.FlushAndPopPostState (statements' itei.Then.BeforeState);  	if (condEntry == null)  		return false;  	var thenStmnts = noStackChange ? BlockToStatementsEmptyStack (itei.Then' exid) : BlockToStatements (itei.Then' exid);  	if (thenStmnts == null)  		return false;  	var elseStmnts = default(Seq<Statement>);  	if (itei.Else != null) {  		elseStmnts = noStackChange ? BlockToStatementsEmptyStack (itei.Else' exid) : BlockToStatements (itei.Else' exid);  		if (elseStmnts == null)  			return false;  	}  	if (statements == null)  		return Failed (false' "if-then-else");  	statements.Add (new IfThenElseStatement (condEntry.Expression' new Statements (thenStmnts)' elseStmnts == null ? null : new Statements (elseStmnts)));  	if (!noStackChange && !stack.Restore (itei.AfterState' 0))  		return false;  	if (!instructionTranslationStyleCache.ContainsKey (itei.Offset))  		instructionTranslationStyleCache.Add (itei.Offset' false);  	return true;  }  case InstructionFlavor.ShortCircuitingPseudo: {  	var sci = (ShortCircuitingInstruction)instruction;  	var isExpr = default(bool);  	// If outer context is re-translating as statements instead of expression' jump directly  	// to appropriate translation for this instruction  	var couldBeExpression = !instructionTranslationStyleCache.TryGetValue (sci.Offset' out isExpr) || isExpr;  	if (couldBeExpression) {  		// Pass 1: Try to translate to an expression.  		var leftEntry = BlockToExpression (sci.Left' exid);  		if (leftEntry != null) {  			var rightEntry = BlockToExpression (sci.Right' exid);  			if (rightEntry != null) {  				stack.Push (new ExpressionStackEntry (new BinaryExpression (leftEntry.Expression' ShortCircuitingOpToBinaryOp (sci.Op)' rightEntry.Expression' false' false)' leftEntry.Effects.Lub (rightEntry.Effects)));  				if (!instructionTranslationStyleCache.ContainsKey (sci.Offset))  					instructionTranslationStyleCache.Add (sci.Offset' true);  				return true;  			}  			// else: fallthrough  		}  		// else: fallthrough  	}  	// else: fallthrough  	// Pass 2: Translate to a statement  	if (!TranslateBlock (statements' sci.Left' stack' exid))  		return false;  	var leftEntry2 = stack.FlushAndPopPostState (statements' sci.Right.BeforeState);  	if (leftEntry2 == null)  		return false;  	var rightStatements = BlockToStatements (sci.Right' exid);  	if (rightStatements == null)  		return false;  	var id = sci.Right.AfterState.PeekId (0' nameSupply.GenSym);  	var cell = new VariableCell (id);  	compEnv.AddVariable (id' ArgLocal.Local' false' true' compEnv.SubstituteType (sci.Right.AfterState.PeekType (0)));  	if (statements == null)  		return Failed (false' "short-circuit");  	switch (sci.Op) {  	case ShortCircuitingOp.And:  		statements.Add (new IfThenElseStatement (leftEntry2.Expression' new Statements (rightStatements)' new Statements (new ExpressionStatement (cell.Write (new Int32ConstantExpression (0))))));  		break;  	case ShortCircuitingOp.Or:  		statements.Add (new IfThenElseStatement (leftEntry2.Expression' new Statements (new ExpressionStatement (cell.Write (new Int32ConstantExpression (1))))' new Statements (rightStatements)));  		break;  	default:  		throw new ArgumentOutOfRangeException ();  	}  	if (!stack.Restore (sci.AfterState' 1))  		return false;  	stack.Push (new ExpressionStackEntry (cell.Read ()' BottomE));  	if (!instructionTranslationStyleCache.ContainsKey (sci.Offset))  		instructionTranslationStyleCache.Add (sci.Offset' false);  	return true;  }  case InstructionFlavor.StructuralSwitchPseudo: {  	var ssi = (StructuralSwitchInstruction)instruction;  	if (!TranslateBlock (statements' ssi.Body' stack' exid))  		return false;  	var valueEntry = stack.FlushAndPopPreState (statements' ssi.Body.AfterState);  	if (valueEntry == null)  		return false;  	var cases = new Seq<SwitchStatementCase> ();  	foreach (var c in ssi.Cases) {  		var caseStatements = BlockToStatements (c.Body' exid);  		if (caseStatements == null)  			return false;  		cases.Add (new SwitchStatementCase (c.Values' new Statements (caseStatements)));  	}  	if (statements == null)  		return Failed (false' "structural switch");  	statements.Add (new SwitchStatement (valueEntry.Expression' cases));  	if (!stack.Restore (ssi.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.LoopPseudo: {  	var li = (LoopInstruction)instruction;  	if (!stack.Flush (statements' li.Body.BeforeState))  		return false;  	if (statements == null)  		return Failed (false' "loop");  	var whileStatements = BlockToStatements (li.Body' exid);  	statements.Add (new WhileDoStatement (new Int32ConstantExpression (1)' new Statements (whileStatements)));  	if (!stack.Restore (li.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.WhileDoPseudo: {  	var wdi = (WhileDoInstruction)instruction;  	if (!stack.Flush (statements' wdi.Condition.BeforeState))  		return false;  	var condEntry = BlockToExpression (wdi.Condition' exid);  	if (condEntry == null) {  		var stack1 = new ExpressionStack (compEnv' BottomE' nameSupply.GenSym' wdi.Condition.BeforeState' trace);  		var preCondStatements = new Seq<Statement> ();  		if (!TranslateBlock (preCondStatements' wdi.Condition' stack1' exid))  			return false;  		condEntry = stack1.FlushAndPopPostState (preCondStatements' wdi.Body.BeforeState);  		if (condEntry == null)  			return false;  		var stack2 = new ExpressionStack (compEnv' BottomE' nameSupply.GenSym' wdi.Body.BeforeState' trace);  		var postCondStatements = new Seq<Statement> ();  		if (!TranslateBlock (postCondStatements' wdi.Body' stack2' exid))  			return false;  		if (!stack2.Flush (postCondStatements' wdi.Body.AfterState))  			return false;  		preCondStatements.Add (new IfThenElseStatement (condEntry.Expression' new Statements (postCondStatements)' new Statements (new BreakStatement ())));  		statements.Add (new WhileDoStatement (new Int32ConstantExpression (1)' new Statements (preCondStatements)));  	}  	else {  		var loopStatements = BlockToStatements (wdi.Body' exid);  		if (loopStatements == null)  			return false;  		if (statements == null)  			return Failed (false' "while-do");  		statements.Add (new WhileDoStatement (condEntry.Expression' new Statements (loopStatements)));  	}  	if (!stack.Restore (wdi.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.DoWhilePseudo: {  	var dwi = (DoWhileInstruction)instruction;  	if (!stack.Flush (statements' dwi.Body.BeforeState))  		return false;  	var combined = new Seq<Instruction> ();  	foreach (var i in dwi.Body.Body)  		combined.Add (i);  	foreach (var i in dwi.Condition.Body)  		combined.Add (i);  	var condEntry = default(ExpressionStackEntry);  	var loopStatements = BlockToConditionStatements (new Instructions (null' combined)' dwi.Body.BeforeState' exid' out condEntry);  	if (loopStatements == null)  		return false;  	if (statements == null)  		return Failed (false' "do-while");  	statements.Add (new DoWhileStatement (new Statements (loopStatements)' condEntry.Expression));  	if (!stack.Restore (dwi.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.LoopControlPseudo: {  	var lci = (BreakContinueInstruction)instruction;  	if (!stack.Flush (statements' lci.BeforeState))  		return false;  	if (statements == null)  		return Failed (false' "loop-control");  	var targetState = default(int);  	switch (lci.Op) {  	case BreakContinueOp.Break:  		if (labelToLoopCandidateBreakState != null && labelToLoopCandidateBreakState.TryGetValue (lci.Label' out targetState))  			statements.Add (new GotoPseudoStatement (stateId' targetState));  		else  			statements.Add (new BreakStatement (lci.Label));  		break;  	case BreakContinueOp.Continue:  		if (labelToLoopCandidateContinueState != null && labelToLoopCandidateContinueState.TryGetValue (lci.Label' out targetState))  			statements.Add (new GotoPseudoStatement (stateId' targetState));  		else  			statements.Add (new ContinueStatement (lci.Label));  		break;  	default:  		throw new ArgumentOutOfRangeException ();  	}  	return true;  }  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (instruction.Flavor) {  case InstructionFlavor.Unsupported:  	throw new InvalidOperationException ("unsupported opcode");  case InstructionFlavor.Misc: {  	var misci = (MiscInstruction)instruction;  	switch (misci.Op) {  	case MiscOp.Nop:  	case MiscOp.Break:  		return true;  	case MiscOp.Dup:  		return stack.Dup (statements);  	case MiscOp.Pop:  		return stack.PopAndDiscard (statements);  	case MiscOp.Ldnull:  		stack.Push (new ExpressionStackEntry (new NullConstantExpression ()' BottomE));  		return true;  	case MiscOp.Ckfinite:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' UnaryOp.CheckFinite' false' false)' e.Lub (ThrowsE)));  	case MiscOp.Throw:  		if (!stack.DiscardAll (statements' 1))  			return false;  		if (!stack.PopEvalSE (statements' 1' true' ThrowsE' (s' a) => s.Add (new ThrowStatement (a [0]))))  			return false;  		return true;  	case MiscOp.Rethrow:  		if (!stack.DiscardAll (statements' 0))  			return false;  		if (statements == null)  			return Failed (false' "rethrow");  		if (exid == null)  			throw new InvalidOperationException ("rethrow outside of catch");  		statements.Add (new RethrowStatement (new VariableCell (exid).Read ()));  		return true;  	case MiscOp.LdindRef:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ReadExpression (a [0]).CloneIfStruct (compEnv)' e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ())));  	case MiscOp.LdelemRef:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' true).Read ().CloneIfStruct (compEnv)' e.Lub (ReadHeapOrThrowE)));  	case MiscOp.Ldlen:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' UnaryOp.Length' false' false)' e.Lub (ReadHeapOrThrowE)));  	case MiscOp.StindRef:  		return stack.PopEvalSE (statements' 2' true' instruction.BeforeState.PeekPointsTo (1).WriteEffect ()' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' a [1]))));  	case MiscOp.StelemRef:  		return stack.PopEvalSE (statements' 3' true' WriteHeapOrThrowE' (s' a) => s.Add (new ExpressionStatement (new ElementCell (a [0]' a [1]' false).Write (a [2]))));  	case MiscOp.Ret:  		if (statements == null)  			return Failed (false' "return");  		statements.Add (new ReturnStatement (null));  		return true;  	case MiscOp.RetVal:  		return stack.PopEvalSE (statements' 1' true' BottomE' (s' a) => s.Add (new ReturnStatement (a [0])));  	case MiscOp.Endfilter:  	case MiscOp.Endfinally:  		throw new InvalidOperationException ("endfilter/endfinally instructions should have been removed");  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Branch:  case InstructionFlavor.Switch:  	throw new InvalidOperationException ("branch/switch instructions should have been removed");  case InstructionFlavor.Compare: {  	var cmpi = (CompareInstruction)instruction;  	if (cmpi.Op == CompareOp.CtruePseudo || cmpi.Op == CompareOp.CfalsePseudo) {  		var s = cmpi.Type.Style (compEnv);  		var unop = default(UnaryOp);  		if (s is NumberTypeStyle)  			unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonZero : UnaryOp.IsZero;  		else  			unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonNull : UnaryOp.IsNull;  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' unop' false' cmpi.IsUnsigned)' e));  	}  	else {  		var binop = default(BinaryOp);  		switch (cmpi.Op) {  		case CompareOp.Ceq:  			binop = BinaryOp.Eq;  			break;  		case CompareOp.Clt:  			binop = BinaryOp.Lt;  			break;  		case CompareOp.Cgt:  			binop = BinaryOp.Gt;  			break;  		case CompareOp.CgePseudo:  			binop = BinaryOp.Ge;  			break;  		case CompareOp.ClePseudo:  			binop = BinaryOp.Le;  			break;  		case CompareOp.CnePseudo:  			binop = BinaryOp.Ne;  			break;  		case CompareOp.CtruePseudo:  		case CompareOp.CfalsePseudo:  			// handled above  			throw new InvalidOperationException ();  		default:  			throw new ArgumentOutOfRangeException ();  		}  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new BinaryExpression (a [0]' binop' a [1]' false' cmpi.IsUnsigned)' e));  	}  }  case InstructionFlavor.ArgLocal: {  	var sli = (ArgLocalInstruction)instruction;  	var id = default(JST.Identifier);  	switch (sli.ArgLocal) {  	case ArgLocal.Arg:  		id = compEnv.ValueParameterIds [sli.Index];  		break;  	case ArgLocal.Local:  		id = compEnv.LocalIds [sli.Index];  		break;  	default:  		throw new ArgumentOutOfRangeException ();  	}  	var cell = new VariableCell (id);  	switch (sli.Op) {  	case ArgLocalOp.Ld:  		stack.Push (new ExpressionStackEntry (cell.Read ().CloneIfStruct (compEnv)' ReadArgLocalE (sli.ArgLocal' sli.Index)));  		return true;  	case ArgLocalOp.Lda:  		// Effect will be accounted for on reads/writes  		stack.Push (new ExpressionStackEntry (cell.AddressOf ()' BottomE));  		return true;  	case ArgLocalOp.St:  		return stack.PopEvalSE (statements' 1' true' WriteArgLocalE (sli.ArgLocal' sli.Index)' (s' a) => s.Add (new ExpressionStatement (cell.Write (a [0]))));  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Field: {  	var fieldi = (FieldInstruction)instruction;  	switch (fieldi.Op) {  	case FieldOp.Ldfld:  		if (fieldi.IsStatic) {  			stack.Push (new ExpressionStackEntry (new FieldCell (null' compEnv.SubstituteMember (fieldi.Field)).Read ().CloneIfStruct (compEnv)' ReadHeapE));  			return true;  		}  		else  			return stack.PopEvalPush (statements' 1' true' (a' e) =>  {  				var readEffect = default(Effects);  				var obj = default(Expression);  				if (fieldi.IsViaPointer.Value) {  					readEffect = e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ());  					obj = new ReadExpression (a [0]);  					// no need for clone  				}  				else if (fieldi.Field.DefiningType.Style (compEnv) is ValueTypeStyle) {  					readEffect = e;  					obj = a [0];  				}  				else {  					// Object could be null  					readEffect = e.Lub (ReadHeapOrThrowE);  					obj = a [0];  				}  				return new ExpressionStackEntry (new FieldCell (obj' compEnv.SubstituteMember (fieldi.Field)).Read ().CloneIfStruct (compEnv)' readEffect);  			});  	case FieldOp.Ldflda:  		if (fieldi.IsStatic) {  			// Effect will be accounted for on reads/writes  			stack.Push (new ExpressionStackEntry (new FieldCell (null' compEnv.SubstituteMember (fieldi.Field)).AddressOf ()' BottomE));  			return true;  		}  		else  			return stack.PopEvalPush (statements' 1' true' (a' e) =>  {  				if (fieldi.IsViaPointer.Value)  					// We're just adding an offset to a pointer' so effect will  					// be accounted for when the final pointer is read/written  					return new ExpressionStackEntry (new FieldCell (new ReadExpression (a [0])' compEnv.SubstituteMember (fieldi.Field)).AddressOf ()' e);  				else  					// Must be a reference type' and ref could be null  					return new ExpressionStackEntry (new FieldCell (a [0]' compEnv.SubstituteMember (fieldi.Field)).AddressOf ()' e.Lub (ThrowsE));  			});  	case FieldOp.Stfld:  		if (fieldi.IsStatic)  			return stack.PopEvalSE (statements' 1' true' WriteHeapE' (s' a) => s.Add (new ExpressionStatement (new FieldCell (null' compEnv.SubstituteMember (fieldi.Field)).Write (a [0]))));  		else {  			var writeEffect = fieldi.IsViaPointer.Value ? instruction.BeforeState.PeekPointsTo (1).WriteEffect () : WriteHeapOrThrowE;  			return stack.PopEvalSE (statements' 2' true' writeEffect' (s' a) =>  {  				var obj = fieldi.IsViaPointer.Value ? new ReadExpression (a [0]) : a [0];  				s.Add (new ExpressionStatement (new FieldCell (obj' compEnv.SubstituteMember (fieldi.Field)).Write (a [1])));  			});  		}  	case FieldOp.Ldtoken:  		stack.Push (new ExpressionStackEntry (new FieldHandleConstantExpression (compEnv.SubstituteMember (fieldi.Field))' BottomE));  		return true;  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Method: {  	var methodi = (MethodInstruction)instruction;  	var arity = methodi.Method.ValueParameters.Count;  	switch (methodi.Op) {  	case MethodOp.Ldftn:  		if (methodi.IsVirtual)  			// Object could be null  			return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new CodePointerExpression (a [0]' compEnv.SubstituteMember (methodi.Method))' e.Lub (ReadHeapOrThrowE)));  		else {  			stack.Push (new ExpressionStackEntry (new CodePointerExpression (null' compEnv.SubstituteMember (methodi.Method))' BottomE));  			return true;  		}  	case MethodOp.Call:  		if (methodi.Method.Result == null)  			return stack.PopEvalSE (statements' arity' true' CalleeEffects (methodi.BeforeState' arity)' (s' a) => s.Add (new ExpressionStatement (new CallExpression (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal' compEnv.SubstituteMember (methodi.Method)' CallerArguments (methodi.Constrained' methodi.Method' a)))));  		else  			return stack.PopEvalPush (statements' arity' true' (a' e) => new ExpressionStackEntry (new CallExpression (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal' compEnv.SubstituteMember (methodi.Method)' CallerArguments (methodi.Constrained' methodi.Method' a))' e.Lub (CalleeEffects (methodi.BeforeState' arity))));  	case MethodOp.Newobj:  		arity--;  		return stack.PopEvalPush (statements' arity' true' (a' e) => new ExpressionStackEntry (new NewObjectExpression (compEnv.SubstituteMember (methodi.Method)' CallerArguments (null' methodi.Method' a))' e.Lub (CalleeEffects (methodi.BeforeState' arity))));  	case MethodOp.Ldtoken:  		stack.Push (new ExpressionStackEntry (new MethodHandleConstantExpression (compEnv.SubstituteMember (methodi.Method))' BottomE));  		return true;  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Type: {  	var typei = (TypeInstruction)instruction;  	switch (typei.Op) {  	case TypeOp.Ldobj:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ReadExpression (a [0]).CloneIfStruct (compEnv)' e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ())));  	case TypeOp.Stobj:  		return stack.PopEvalSE (statements' 2' true' instruction.BeforeState.PeekPointsTo (1).WriteEffect ()' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' a [1]))));  	case TypeOp.Cpobj: {  		var copyEffect = instruction.BeforeState.PeekPointsTo (0).ReadEffect ().Lub (instruction.BeforeState.PeekPointsTo (1).WriteEffect ());  		return stack.PopEvalSE (statements' 2' true' copyEffect' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' new ReadExpression (a [1]).CloneIfStruct (compEnv)))));  	}  	case TypeOp.Newarr:  		// Growing the heap is not considered an observable change. But will throw if  		// length < 0  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new NewArrayExpression (a [0]' compEnv.SubstituteType (typei.Type))' e.Lub (ThrowsE)));  	case TypeOp.Initobj:  		return stack.PopEvalSE (statements' 1' true' WriteHeapE' (s' a) => s.Add (new InitializeObjectStatement (a [0])));  	case TypeOp.Castclass:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new CastExpression (a [0]' compEnv.SubstituteType (typei.Type))' e.Lub (ThrowsE)));  	case TypeOp.Isinst:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new IsInstExpression (a [0]' compEnv.SubstituteType (typei.Type))' e));  	case TypeOp.Box:  		// Growing the heap is not considered an observable change  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new NewBoxExpression (a [0]' compEnv.SubstituteType (typei.Type))' e));  	case TypeOp.Unbox:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new BoxCell (a [0]' compEnv.SubstituteType (typei.Type)).AddressOf ()' e.Lub (ThrowsE)));  	case TypeOp.UnboxAny:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new BoxCell (a [0]' compEnv.SubstituteType (typei.Type)).Read ().CloneIfStruct (compEnv)' e.Lub (ThrowsE)));  	case TypeOp.Ldtoken:  		stack.Push (new ExpressionStackEntry (new TypeHandleConstantExpression (compEnv.SubstituteType (typei.Type))' BottomE));  		return true;  	case TypeOp.Ldelem:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' true).Read ().CloneIfStruct (compEnv)' e.Lub (ReadHeapOrThrowE)));  	case TypeOp.Stelem:  		return stack.PopEvalSE (statements' 3' true' WriteHeapOrThrowE' (s' a) => s.Add (new ExpressionStatement (new ElementCell (a [0]' a [1]' false).Write (a [2]))));  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.LdElemAddr:  	// Calculating the pointer may throw if index is out of range.  	// Remaining effect will be accounted for when pointer is read/written.  	return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' false).AddressOf ()' e.Lub (ThrowsE)));  case InstructionFlavor.LdInt32: {  	var int32i = (LdInt32Instruction)instruction;  	stack.Push (new ExpressionStackEntry (new Int32ConstantExpression (int32i.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdInt64: {  	var int64i = (LdInt64Instruction)instruction;  	stack.Push (new ExpressionStackEntry (new Int64ConstantExpression (int64i.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdSingle: {  	var singlei = (LdSingleInstruction)instruction;  	stack.Push (new ExpressionStackEntry (new SingleConstantExpression (singlei.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdDouble: {  	var doublei = (LdDoubleInstruction)instruction;  	stack.Push (new ExpressionStackEntry (new DoubleConstantExpression (doublei.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdString: {  	var stringi = (LdStringInstruction)instruction;  	stack.Push (new ExpressionStackEntry (new StringConstantExpression (stringi.Value)' BottomE));  	return true;  }  case InstructionFlavor.Arith: {  	var arithi = (ArithInstruction)instruction;  	switch (arithi.Op) {  	case ArithOp.Div:  	case ArithOp.Rem:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new BinaryExpression (a [0]' ArithOpToBinaryOp (arithi.Op)' a [1]' arithi.WithOverflow' arithi.IsUnsigned)' e.Lub (ThrowsE)));  	case ArithOp.Add:  	case ArithOp.Sub:  	case ArithOp.Mul:  	case ArithOp.BitAnd:  	case ArithOp.BitOr:  	case ArithOp.BitXor:  	case ArithOp.Shl:  	case ArithOp.Shr:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new BinaryExpression (a [0]' ArithOpToBinaryOp (arithi.Op)' a [1]' arithi.WithOverflow' arithi.IsUnsigned)' e.Lub (arithi.WithOverflow ? ThrowsE : BottomE)));  	case ArithOp.Neg:  	case ArithOp.BitNot:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' ArithOpToUnaryOp (arithi.Op)' arithi.WithOverflow' arithi.IsUnsigned)' e));  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Conv: {  	var convi = (ConvInstruction)instruction;  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ConvertExpression (a [0]' new NamedTypeRef (compEnv.Global.NumberFlavorToQualifiedTypeName [convi.TargetNumberFlavor])' convi.WithOverflow' convi.IsSourceUnsigned)' e.Lub (convi.WithOverflow ? ThrowsE : BottomE)));  }  case InstructionFlavor.Try: {  	if (stack.Depth > 0)  		throw new InvalidOperationException ("stack must be empty on entry to try block");  	var tryi = (TryInstruction)instruction;  	var tryStatements = BlockToTryFaultFinallyStatements (tryi.Body);  	if (tryStatements == null)  		return false;  	var handlers = TranslateHandlers (tryi.Handlers);  	if (handlers == null)  		return false;  	if (statements == null)  		return Failed (false' "try");  	statements.Add (new TryStatement (tryStatements' handlers));  	return true;  }  case InstructionFlavor.IfThenElsePseudo: {  	var itei = (IfThenElseInstruction)instruction;  	var isExpr = default(bool);  	// If outer context is re-translating as statements instead of expression' jump directly  	// to appropriate translation for this instruction  	var couldBeExpression = !instructionTranslationStyleCache.TryGetValue (itei.Offset' out isExpr) || isExpr;  	if (!TranslateBlock (statements' itei.Condition' stack' exid))  		return false;  	if (couldBeExpression && itei.Else != null) {  		// Pass 1: Try to tranlate to an if-then-else expression. Will only work if Then and Else don't  		//         reach into current stack' push exactly one value' and don't need to emit any  		//         statements along the way.  		var thenEntry = BlockToExpression (itei.Then' exid);  		if (thenEntry != null) {  			var elseEntry = BlockToExpression (itei.Else' exid);  			if (elseEntry != null) {  				if (!instructionTranslationStyleCache.ContainsKey (itei.Offset))  					instructionTranslationStyleCache.Add (itei.Offset' true);  				return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new IfThenElseExpression (a [0]' thenEntry.Expression' elseEntry.Expression)' e.Lub (thenEntry.Effects.Lub (elseEntry.Effects))));  			}  			// else: fallthrough  		}  		// else: fallthrough  	}  	// else: fallthrough  	// Pass 2: Translate to a statement  	var noStackChange = itei.Then.NoStackChange && (itei.Else == null || itei.Else.NoStackChange);  	var condEntry = noStackChange ? stack.Pop () : stack.FlushAndPopPostState (statements' itei.Then.BeforeState);  	if (condEntry == null)  		return false;  	var thenStmnts = noStackChange ? BlockToStatementsEmptyStack (itei.Then' exid) : BlockToStatements (itei.Then' exid);  	if (thenStmnts == null)  		return false;  	var elseStmnts = default(Seq<Statement>);  	if (itei.Else != null) {  		elseStmnts = noStackChange ? BlockToStatementsEmptyStack (itei.Else' exid) : BlockToStatements (itei.Else' exid);  		if (elseStmnts == null)  			return false;  	}  	if (statements == null)  		return Failed (false' "if-then-else");  	statements.Add (new IfThenElseStatement (condEntry.Expression' new Statements (thenStmnts)' elseStmnts == null ? null : new Statements (elseStmnts)));  	if (!noStackChange && !stack.Restore (itei.AfterState' 0))  		return false;  	if (!instructionTranslationStyleCache.ContainsKey (itei.Offset))  		instructionTranslationStyleCache.Add (itei.Offset' false);  	return true;  }  case InstructionFlavor.ShortCircuitingPseudo: {  	var sci = (ShortCircuitingInstruction)instruction;  	var isExpr = default(bool);  	// If outer context is re-translating as statements instead of expression' jump directly  	// to appropriate translation for this instruction  	var couldBeExpression = !instructionTranslationStyleCache.TryGetValue (sci.Offset' out isExpr) || isExpr;  	if (couldBeExpression) {  		// Pass 1: Try to translate to an expression.  		var leftEntry = BlockToExpression (sci.Left' exid);  		if (leftEntry != null) {  			var rightEntry = BlockToExpression (sci.Right' exid);  			if (rightEntry != null) {  				stack.Push (new ExpressionStackEntry (new BinaryExpression (leftEntry.Expression' ShortCircuitingOpToBinaryOp (sci.Op)' rightEntry.Expression' false' false)' leftEntry.Effects.Lub (rightEntry.Effects)));  				if (!instructionTranslationStyleCache.ContainsKey (sci.Offset))  					instructionTranslationStyleCache.Add (sci.Offset' true);  				return true;  			}  			// else: fallthrough  		}  		// else: fallthrough  	}  	// else: fallthrough  	// Pass 2: Translate to a statement  	if (!TranslateBlock (statements' sci.Left' stack' exid))  		return false;  	var leftEntry2 = stack.FlushAndPopPostState (statements' sci.Right.BeforeState);  	if (leftEntry2 == null)  		return false;  	var rightStatements = BlockToStatements (sci.Right' exid);  	if (rightStatements == null)  		return false;  	var id = sci.Right.AfterState.PeekId (0' nameSupply.GenSym);  	var cell = new VariableCell (id);  	compEnv.AddVariable (id' ArgLocal.Local' false' true' compEnv.SubstituteType (sci.Right.AfterState.PeekType (0)));  	if (statements == null)  		return Failed (false' "short-circuit");  	switch (sci.Op) {  	case ShortCircuitingOp.And:  		statements.Add (new IfThenElseStatement (leftEntry2.Expression' new Statements (rightStatements)' new Statements (new ExpressionStatement (cell.Write (new Int32ConstantExpression (0))))));  		break;  	case ShortCircuitingOp.Or:  		statements.Add (new IfThenElseStatement (leftEntry2.Expression' new Statements (new ExpressionStatement (cell.Write (new Int32ConstantExpression (1))))' new Statements (rightStatements)));  		break;  	default:  		throw new ArgumentOutOfRangeException ();  	}  	if (!stack.Restore (sci.AfterState' 1))  		return false;  	stack.Push (new ExpressionStackEntry (cell.Read ()' BottomE));  	if (!instructionTranslationStyleCache.ContainsKey (sci.Offset))  		instructionTranslationStyleCache.Add (sci.Offset' false);  	return true;  }  case InstructionFlavor.StructuralSwitchPseudo: {  	var ssi = (StructuralSwitchInstruction)instruction;  	if (!TranslateBlock (statements' ssi.Body' stack' exid))  		return false;  	var valueEntry = stack.FlushAndPopPreState (statements' ssi.Body.AfterState);  	if (valueEntry == null)  		return false;  	var cases = new Seq<SwitchStatementCase> ();  	foreach (var c in ssi.Cases) {  		var caseStatements = BlockToStatements (c.Body' exid);  		if (caseStatements == null)  			return false;  		cases.Add (new SwitchStatementCase (c.Values' new Statements (caseStatements)));  	}  	if (statements == null)  		return Failed (false' "structural switch");  	statements.Add (new SwitchStatement (valueEntry.Expression' cases));  	if (!stack.Restore (ssi.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.LoopPseudo: {  	var li = (LoopInstruction)instruction;  	if (!stack.Flush (statements' li.Body.BeforeState))  		return false;  	if (statements == null)  		return Failed (false' "loop");  	var whileStatements = BlockToStatements (li.Body' exid);  	statements.Add (new WhileDoStatement (new Int32ConstantExpression (1)' new Statements (whileStatements)));  	if (!stack.Restore (li.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.WhileDoPseudo: {  	var wdi = (WhileDoInstruction)instruction;  	if (!stack.Flush (statements' wdi.Condition.BeforeState))  		return false;  	var condEntry = BlockToExpression (wdi.Condition' exid);  	if (condEntry == null) {  		var stack1 = new ExpressionStack (compEnv' BottomE' nameSupply.GenSym' wdi.Condition.BeforeState' trace);  		var preCondStatements = new Seq<Statement> ();  		if (!TranslateBlock (preCondStatements' wdi.Condition' stack1' exid))  			return false;  		condEntry = stack1.FlushAndPopPostState (preCondStatements' wdi.Body.BeforeState);  		if (condEntry == null)  			return false;  		var stack2 = new ExpressionStack (compEnv' BottomE' nameSupply.GenSym' wdi.Body.BeforeState' trace);  		var postCondStatements = new Seq<Statement> ();  		if (!TranslateBlock (postCondStatements' wdi.Body' stack2' exid))  			return false;  		if (!stack2.Flush (postCondStatements' wdi.Body.AfterState))  			return false;  		preCondStatements.Add (new IfThenElseStatement (condEntry.Expression' new Statements (postCondStatements)' new Statements (new BreakStatement ())));  		statements.Add (new WhileDoStatement (new Int32ConstantExpression (1)' new Statements (preCondStatements)));  	}  	else {  		var loopStatements = BlockToStatements (wdi.Body' exid);  		if (loopStatements == null)  			return false;  		if (statements == null)  			return Failed (false' "while-do");  		statements.Add (new WhileDoStatement (condEntry.Expression' new Statements (loopStatements)));  	}  	if (!stack.Restore (wdi.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.DoWhilePseudo: {  	var dwi = (DoWhileInstruction)instruction;  	if (!stack.Flush (statements' dwi.Body.BeforeState))  		return false;  	var combined = new Seq<Instruction> ();  	foreach (var i in dwi.Body.Body)  		combined.Add (i);  	foreach (var i in dwi.Condition.Body)  		combined.Add (i);  	var condEntry = default(ExpressionStackEntry);  	var loopStatements = BlockToConditionStatements (new Instructions (null' combined)' dwi.Body.BeforeState' exid' out condEntry);  	if (loopStatements == null)  		return false;  	if (statements == null)  		return Failed (false' "do-while");  	statements.Add (new DoWhileStatement (new Statements (loopStatements)' condEntry.Expression));  	if (!stack.Restore (dwi.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.LoopControlPseudo: {  	var lci = (BreakContinueInstruction)instruction;  	if (!stack.Flush (statements' lci.BeforeState))  		return false;  	if (statements == null)  		return Failed (false' "loop-control");  	var targetState = default(int);  	switch (lci.Op) {  	case BreakContinueOp.Break:  		if (labelToLoopCandidateBreakState != null && labelToLoopCandidateBreakState.TryGetValue (lci.Label' out targetState))  			statements.Add (new GotoPseudoStatement (stateId' targetState));  		else  			statements.Add (new BreakStatement (lci.Label));  		break;  	case BreakContinueOp.Continue:  		if (labelToLoopCandidateContinueState != null && labelToLoopCandidateContinueState.TryGetValue (lci.Label' out targetState))  			statements.Add (new GotoPseudoStatement (stateId' targetState));  		else  			statements.Add (new ContinueStatement (lci.Label));  		break;  	default:  		throw new ArgumentOutOfRangeException ();  	}  	return true;  }  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (instruction.Flavor) {  case InstructionFlavor.Unsupported:  	throw new InvalidOperationException ("unsupported opcode");  case InstructionFlavor.Misc: {  	var misci = (MiscInstruction)instruction;  	switch (misci.Op) {  	case MiscOp.Nop:  	case MiscOp.Break:  		return true;  	case MiscOp.Dup:  		return stack.Dup (statements);  	case MiscOp.Pop:  		return stack.PopAndDiscard (statements);  	case MiscOp.Ldnull:  		stack.Push (new ExpressionStackEntry (new NullConstantExpression ()' BottomE));  		return true;  	case MiscOp.Ckfinite:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' UnaryOp.CheckFinite' false' false)' e.Lub (ThrowsE)));  	case MiscOp.Throw:  		if (!stack.DiscardAll (statements' 1))  			return false;  		if (!stack.PopEvalSE (statements' 1' true' ThrowsE' (s' a) => s.Add (new ThrowStatement (a [0]))))  			return false;  		return true;  	case MiscOp.Rethrow:  		if (!stack.DiscardAll (statements' 0))  			return false;  		if (statements == null)  			return Failed (false' "rethrow");  		if (exid == null)  			throw new InvalidOperationException ("rethrow outside of catch");  		statements.Add (new RethrowStatement (new VariableCell (exid).Read ()));  		return true;  	case MiscOp.LdindRef:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ReadExpression (a [0]).CloneIfStruct (compEnv)' e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ())));  	case MiscOp.LdelemRef:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' true).Read ().CloneIfStruct (compEnv)' e.Lub (ReadHeapOrThrowE)));  	case MiscOp.Ldlen:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' UnaryOp.Length' false' false)' e.Lub (ReadHeapOrThrowE)));  	case MiscOp.StindRef:  		return stack.PopEvalSE (statements' 2' true' instruction.BeforeState.PeekPointsTo (1).WriteEffect ()' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' a [1]))));  	case MiscOp.StelemRef:  		return stack.PopEvalSE (statements' 3' true' WriteHeapOrThrowE' (s' a) => s.Add (new ExpressionStatement (new ElementCell (a [0]' a [1]' false).Write (a [2]))));  	case MiscOp.Ret:  		if (statements == null)  			return Failed (false' "return");  		statements.Add (new ReturnStatement (null));  		return true;  	case MiscOp.RetVal:  		return stack.PopEvalSE (statements' 1' true' BottomE' (s' a) => s.Add (new ReturnStatement (a [0])));  	case MiscOp.Endfilter:  	case MiscOp.Endfinally:  		throw new InvalidOperationException ("endfilter/endfinally instructions should have been removed");  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Branch:  case InstructionFlavor.Switch:  	throw new InvalidOperationException ("branch/switch instructions should have been removed");  case InstructionFlavor.Compare: {  	var cmpi = (CompareInstruction)instruction;  	if (cmpi.Op == CompareOp.CtruePseudo || cmpi.Op == CompareOp.CfalsePseudo) {  		var s = cmpi.Type.Style (compEnv);  		var unop = default(UnaryOp);  		if (s is NumberTypeStyle)  			unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonZero : UnaryOp.IsZero;  		else  			unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonNull : UnaryOp.IsNull;  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' unop' false' cmpi.IsUnsigned)' e));  	}  	else {  		var binop = default(BinaryOp);  		switch (cmpi.Op) {  		case CompareOp.Ceq:  			binop = BinaryOp.Eq;  			break;  		case CompareOp.Clt:  			binop = BinaryOp.Lt;  			break;  		case CompareOp.Cgt:  			binop = BinaryOp.Gt;  			break;  		case CompareOp.CgePseudo:  			binop = BinaryOp.Ge;  			break;  		case CompareOp.ClePseudo:  			binop = BinaryOp.Le;  			break;  		case CompareOp.CnePseudo:  			binop = BinaryOp.Ne;  			break;  		case CompareOp.CtruePseudo:  		case CompareOp.CfalsePseudo:  			// handled above  			throw new InvalidOperationException ();  		default:  			throw new ArgumentOutOfRangeException ();  		}  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new BinaryExpression (a [0]' binop' a [1]' false' cmpi.IsUnsigned)' e));  	}  }  case InstructionFlavor.ArgLocal: {  	var sli = (ArgLocalInstruction)instruction;  	var id = default(JST.Identifier);  	switch (sli.ArgLocal) {  	case ArgLocal.Arg:  		id = compEnv.ValueParameterIds [sli.Index];  		break;  	case ArgLocal.Local:  		id = compEnv.LocalIds [sli.Index];  		break;  	default:  		throw new ArgumentOutOfRangeException ();  	}  	var cell = new VariableCell (id);  	switch (sli.Op) {  	case ArgLocalOp.Ld:  		stack.Push (new ExpressionStackEntry (cell.Read ().CloneIfStruct (compEnv)' ReadArgLocalE (sli.ArgLocal' sli.Index)));  		return true;  	case ArgLocalOp.Lda:  		// Effect will be accounted for on reads/writes  		stack.Push (new ExpressionStackEntry (cell.AddressOf ()' BottomE));  		return true;  	case ArgLocalOp.St:  		return stack.PopEvalSE (statements' 1' true' WriteArgLocalE (sli.ArgLocal' sli.Index)' (s' a) => s.Add (new ExpressionStatement (cell.Write (a [0]))));  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Field: {  	var fieldi = (FieldInstruction)instruction;  	switch (fieldi.Op) {  	case FieldOp.Ldfld:  		if (fieldi.IsStatic) {  			stack.Push (new ExpressionStackEntry (new FieldCell (null' compEnv.SubstituteMember (fieldi.Field)).Read ().CloneIfStruct (compEnv)' ReadHeapE));  			return true;  		}  		else  			return stack.PopEvalPush (statements' 1' true' (a' e) =>  {  				var readEffect = default(Effects);  				var obj = default(Expression);  				if (fieldi.IsViaPointer.Value) {  					readEffect = e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ());  					obj = new ReadExpression (a [0]);  					// no need for clone  				}  				else if (fieldi.Field.DefiningType.Style (compEnv) is ValueTypeStyle) {  					readEffect = e;  					obj = a [0];  				}  				else {  					// Object could be null  					readEffect = e.Lub (ReadHeapOrThrowE);  					obj = a [0];  				}  				return new ExpressionStackEntry (new FieldCell (obj' compEnv.SubstituteMember (fieldi.Field)).Read ().CloneIfStruct (compEnv)' readEffect);  			});  	case FieldOp.Ldflda:  		if (fieldi.IsStatic) {  			// Effect will be accounted for on reads/writes  			stack.Push (new ExpressionStackEntry (new FieldCell (null' compEnv.SubstituteMember (fieldi.Field)).AddressOf ()' BottomE));  			return true;  		}  		else  			return stack.PopEvalPush (statements' 1' true' (a' e) =>  {  				if (fieldi.IsViaPointer.Value)  					// We're just adding an offset to a pointer' so effect will  					// be accounted for when the final pointer is read/written  					return new ExpressionStackEntry (new FieldCell (new ReadExpression (a [0])' compEnv.SubstituteMember (fieldi.Field)).AddressOf ()' e);  				else  					// Must be a reference type' and ref could be null  					return new ExpressionStackEntry (new FieldCell (a [0]' compEnv.SubstituteMember (fieldi.Field)).AddressOf ()' e.Lub (ThrowsE));  			});  	case FieldOp.Stfld:  		if (fieldi.IsStatic)  			return stack.PopEvalSE (statements' 1' true' WriteHeapE' (s' a) => s.Add (new ExpressionStatement (new FieldCell (null' compEnv.SubstituteMember (fieldi.Field)).Write (a [0]))));  		else {  			var writeEffect = fieldi.IsViaPointer.Value ? instruction.BeforeState.PeekPointsTo (1).WriteEffect () : WriteHeapOrThrowE;  			return stack.PopEvalSE (statements' 2' true' writeEffect' (s' a) =>  {  				var obj = fieldi.IsViaPointer.Value ? new ReadExpression (a [0]) : a [0];  				s.Add (new ExpressionStatement (new FieldCell (obj' compEnv.SubstituteMember (fieldi.Field)).Write (a [1])));  			});  		}  	case FieldOp.Ldtoken:  		stack.Push (new ExpressionStackEntry (new FieldHandleConstantExpression (compEnv.SubstituteMember (fieldi.Field))' BottomE));  		return true;  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Method: {  	var methodi = (MethodInstruction)instruction;  	var arity = methodi.Method.ValueParameters.Count;  	switch (methodi.Op) {  	case MethodOp.Ldftn:  		if (methodi.IsVirtual)  			// Object could be null  			return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new CodePointerExpression (a [0]' compEnv.SubstituteMember (methodi.Method))' e.Lub (ReadHeapOrThrowE)));  		else {  			stack.Push (new ExpressionStackEntry (new CodePointerExpression (null' compEnv.SubstituteMember (methodi.Method))' BottomE));  			return true;  		}  	case MethodOp.Call:  		if (methodi.Method.Result == null)  			return stack.PopEvalSE (statements' arity' true' CalleeEffects (methodi.BeforeState' arity)' (s' a) => s.Add (new ExpressionStatement (new CallExpression (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal' compEnv.SubstituteMember (methodi.Method)' CallerArguments (methodi.Constrained' methodi.Method' a)))));  		else  			return stack.PopEvalPush (statements' arity' true' (a' e) => new ExpressionStackEntry (new CallExpression (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal' compEnv.SubstituteMember (methodi.Method)' CallerArguments (methodi.Constrained' methodi.Method' a))' e.Lub (CalleeEffects (methodi.BeforeState' arity))));  	case MethodOp.Newobj:  		arity--;  		return stack.PopEvalPush (statements' arity' true' (a' e) => new ExpressionStackEntry (new NewObjectExpression (compEnv.SubstituteMember (methodi.Method)' CallerArguments (null' methodi.Method' a))' e.Lub (CalleeEffects (methodi.BeforeState' arity))));  	case MethodOp.Ldtoken:  		stack.Push (new ExpressionStackEntry (new MethodHandleConstantExpression (compEnv.SubstituteMember (methodi.Method))' BottomE));  		return true;  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Type: {  	var typei = (TypeInstruction)instruction;  	switch (typei.Op) {  	case TypeOp.Ldobj:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ReadExpression (a [0]).CloneIfStruct (compEnv)' e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ())));  	case TypeOp.Stobj:  		return stack.PopEvalSE (statements' 2' true' instruction.BeforeState.PeekPointsTo (1).WriteEffect ()' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' a [1]))));  	case TypeOp.Cpobj: {  		var copyEffect = instruction.BeforeState.PeekPointsTo (0).ReadEffect ().Lub (instruction.BeforeState.PeekPointsTo (1).WriteEffect ());  		return stack.PopEvalSE (statements' 2' true' copyEffect' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' new ReadExpression (a [1]).CloneIfStruct (compEnv)))));  	}  	case TypeOp.Newarr:  		// Growing the heap is not considered an observable change. But will throw if  		// length < 0  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new NewArrayExpression (a [0]' compEnv.SubstituteType (typei.Type))' e.Lub (ThrowsE)));  	case TypeOp.Initobj:  		return stack.PopEvalSE (statements' 1' true' WriteHeapE' (s' a) => s.Add (new InitializeObjectStatement (a [0])));  	case TypeOp.Castclass:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new CastExpression (a [0]' compEnv.SubstituteType (typei.Type))' e.Lub (ThrowsE)));  	case TypeOp.Isinst:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new IsInstExpression (a [0]' compEnv.SubstituteType (typei.Type))' e));  	case TypeOp.Box:  		// Growing the heap is not considered an observable change  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new NewBoxExpression (a [0]' compEnv.SubstituteType (typei.Type))' e));  	case TypeOp.Unbox:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new BoxCell (a [0]' compEnv.SubstituteType (typei.Type)).AddressOf ()' e.Lub (ThrowsE)));  	case TypeOp.UnboxAny:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new BoxCell (a [0]' compEnv.SubstituteType (typei.Type)).Read ().CloneIfStruct (compEnv)' e.Lub (ThrowsE)));  	case TypeOp.Ldtoken:  		stack.Push (new ExpressionStackEntry (new TypeHandleConstantExpression (compEnv.SubstituteType (typei.Type))' BottomE));  		return true;  	case TypeOp.Ldelem:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' true).Read ().CloneIfStruct (compEnv)' e.Lub (ReadHeapOrThrowE)));  	case TypeOp.Stelem:  		return stack.PopEvalSE (statements' 3' true' WriteHeapOrThrowE' (s' a) => s.Add (new ExpressionStatement (new ElementCell (a [0]' a [1]' false).Write (a [2]))));  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.LdElemAddr:  	// Calculating the pointer may throw if index is out of range.  	// Remaining effect will be accounted for when pointer is read/written.  	return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' false).AddressOf ()' e.Lub (ThrowsE)));  case InstructionFlavor.LdInt32: {  	var int32i = (LdInt32Instruction)instruction;  	stack.Push (new ExpressionStackEntry (new Int32ConstantExpression (int32i.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdInt64: {  	var int64i = (LdInt64Instruction)instruction;  	stack.Push (new ExpressionStackEntry (new Int64ConstantExpression (int64i.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdSingle: {  	var singlei = (LdSingleInstruction)instruction;  	stack.Push (new ExpressionStackEntry (new SingleConstantExpression (singlei.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdDouble: {  	var doublei = (LdDoubleInstruction)instruction;  	stack.Push (new ExpressionStackEntry (new DoubleConstantExpression (doublei.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdString: {  	var stringi = (LdStringInstruction)instruction;  	stack.Push (new ExpressionStackEntry (new StringConstantExpression (stringi.Value)' BottomE));  	return true;  }  case InstructionFlavor.Arith: {  	var arithi = (ArithInstruction)instruction;  	switch (arithi.Op) {  	case ArithOp.Div:  	case ArithOp.Rem:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new BinaryExpression (a [0]' ArithOpToBinaryOp (arithi.Op)' a [1]' arithi.WithOverflow' arithi.IsUnsigned)' e.Lub (ThrowsE)));  	case ArithOp.Add:  	case ArithOp.Sub:  	case ArithOp.Mul:  	case ArithOp.BitAnd:  	case ArithOp.BitOr:  	case ArithOp.BitXor:  	case ArithOp.Shl:  	case ArithOp.Shr:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new BinaryExpression (a [0]' ArithOpToBinaryOp (arithi.Op)' a [1]' arithi.WithOverflow' arithi.IsUnsigned)' e.Lub (arithi.WithOverflow ? ThrowsE : BottomE)));  	case ArithOp.Neg:  	case ArithOp.BitNot:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' ArithOpToUnaryOp (arithi.Op)' arithi.WithOverflow' arithi.IsUnsigned)' e));  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Conv: {  	var convi = (ConvInstruction)instruction;  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ConvertExpression (a [0]' new NamedTypeRef (compEnv.Global.NumberFlavorToQualifiedTypeName [convi.TargetNumberFlavor])' convi.WithOverflow' convi.IsSourceUnsigned)' e.Lub (convi.WithOverflow ? ThrowsE : BottomE)));  }  case InstructionFlavor.Try: {  	if (stack.Depth > 0)  		throw new InvalidOperationException ("stack must be empty on entry to try block");  	var tryi = (TryInstruction)instruction;  	var tryStatements = BlockToTryFaultFinallyStatements (tryi.Body);  	if (tryStatements == null)  		return false;  	var handlers = TranslateHandlers (tryi.Handlers);  	if (handlers == null)  		return false;  	if (statements == null)  		return Failed (false' "try");  	statements.Add (new TryStatement (tryStatements' handlers));  	return true;  }  case InstructionFlavor.IfThenElsePseudo: {  	var itei = (IfThenElseInstruction)instruction;  	var isExpr = default(bool);  	// If outer context is re-translating as statements instead of expression' jump directly  	// to appropriate translation for this instruction  	var couldBeExpression = !instructionTranslationStyleCache.TryGetValue (itei.Offset' out isExpr) || isExpr;  	if (!TranslateBlock (statements' itei.Condition' stack' exid))  		return false;  	if (couldBeExpression && itei.Else != null) {  		// Pass 1: Try to tranlate to an if-then-else expression. Will only work if Then and Else don't  		//         reach into current stack' push exactly one value' and don't need to emit any  		//         statements along the way.  		var thenEntry = BlockToExpression (itei.Then' exid);  		if (thenEntry != null) {  			var elseEntry = BlockToExpression (itei.Else' exid);  			if (elseEntry != null) {  				if (!instructionTranslationStyleCache.ContainsKey (itei.Offset))  					instructionTranslationStyleCache.Add (itei.Offset' true);  				return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new IfThenElseExpression (a [0]' thenEntry.Expression' elseEntry.Expression)' e.Lub (thenEntry.Effects.Lub (elseEntry.Effects))));  			}  			// else: fallthrough  		}  		// else: fallthrough  	}  	// else: fallthrough  	// Pass 2: Translate to a statement  	var noStackChange = itei.Then.NoStackChange && (itei.Else == null || itei.Else.NoStackChange);  	var condEntry = noStackChange ? stack.Pop () : stack.FlushAndPopPostState (statements' itei.Then.BeforeState);  	if (condEntry == null)  		return false;  	var thenStmnts = noStackChange ? BlockToStatementsEmptyStack (itei.Then' exid) : BlockToStatements (itei.Then' exid);  	if (thenStmnts == null)  		return false;  	var elseStmnts = default(Seq<Statement>);  	if (itei.Else != null) {  		elseStmnts = noStackChange ? BlockToStatementsEmptyStack (itei.Else' exid) : BlockToStatements (itei.Else' exid);  		if (elseStmnts == null)  			return false;  	}  	if (statements == null)  		return Failed (false' "if-then-else");  	statements.Add (new IfThenElseStatement (condEntry.Expression' new Statements (thenStmnts)' elseStmnts == null ? null : new Statements (elseStmnts)));  	if (!noStackChange && !stack.Restore (itei.AfterState' 0))  		return false;  	if (!instructionTranslationStyleCache.ContainsKey (itei.Offset))  		instructionTranslationStyleCache.Add (itei.Offset' false);  	return true;  }  case InstructionFlavor.ShortCircuitingPseudo: {  	var sci = (ShortCircuitingInstruction)instruction;  	var isExpr = default(bool);  	// If outer context is re-translating as statements instead of expression' jump directly  	// to appropriate translation for this instruction  	var couldBeExpression = !instructionTranslationStyleCache.TryGetValue (sci.Offset' out isExpr) || isExpr;  	if (couldBeExpression) {  		// Pass 1: Try to translate to an expression.  		var leftEntry = BlockToExpression (sci.Left' exid);  		if (leftEntry != null) {  			var rightEntry = BlockToExpression (sci.Right' exid);  			if (rightEntry != null) {  				stack.Push (new ExpressionStackEntry (new BinaryExpression (leftEntry.Expression' ShortCircuitingOpToBinaryOp (sci.Op)' rightEntry.Expression' false' false)' leftEntry.Effects.Lub (rightEntry.Effects)));  				if (!instructionTranslationStyleCache.ContainsKey (sci.Offset))  					instructionTranslationStyleCache.Add (sci.Offset' true);  				return true;  			}  			// else: fallthrough  		}  		// else: fallthrough  	}  	// else: fallthrough  	// Pass 2: Translate to a statement  	if (!TranslateBlock (statements' sci.Left' stack' exid))  		return false;  	var leftEntry2 = stack.FlushAndPopPostState (statements' sci.Right.BeforeState);  	if (leftEntry2 == null)  		return false;  	var rightStatements = BlockToStatements (sci.Right' exid);  	if (rightStatements == null)  		return false;  	var id = sci.Right.AfterState.PeekId (0' nameSupply.GenSym);  	var cell = new VariableCell (id);  	compEnv.AddVariable (id' ArgLocal.Local' false' true' compEnv.SubstituteType (sci.Right.AfterState.PeekType (0)));  	if (statements == null)  		return Failed (false' "short-circuit");  	switch (sci.Op) {  	case ShortCircuitingOp.And:  		statements.Add (new IfThenElseStatement (leftEntry2.Expression' new Statements (rightStatements)' new Statements (new ExpressionStatement (cell.Write (new Int32ConstantExpression (0))))));  		break;  	case ShortCircuitingOp.Or:  		statements.Add (new IfThenElseStatement (leftEntry2.Expression' new Statements (new ExpressionStatement (cell.Write (new Int32ConstantExpression (1))))' new Statements (rightStatements)));  		break;  	default:  		throw new ArgumentOutOfRangeException ();  	}  	if (!stack.Restore (sci.AfterState' 1))  		return false;  	stack.Push (new ExpressionStackEntry (cell.Read ()' BottomE));  	if (!instructionTranslationStyleCache.ContainsKey (sci.Offset))  		instructionTranslationStyleCache.Add (sci.Offset' false);  	return true;  }  case InstructionFlavor.StructuralSwitchPseudo: {  	var ssi = (StructuralSwitchInstruction)instruction;  	if (!TranslateBlock (statements' ssi.Body' stack' exid))  		return false;  	var valueEntry = stack.FlushAndPopPreState (statements' ssi.Body.AfterState);  	if (valueEntry == null)  		return false;  	var cases = new Seq<SwitchStatementCase> ();  	foreach (var c in ssi.Cases) {  		var caseStatements = BlockToStatements (c.Body' exid);  		if (caseStatements == null)  			return false;  		cases.Add (new SwitchStatementCase (c.Values' new Statements (caseStatements)));  	}  	if (statements == null)  		return Failed (false' "structural switch");  	statements.Add (new SwitchStatement (valueEntry.Expression' cases));  	if (!stack.Restore (ssi.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.LoopPseudo: {  	var li = (LoopInstruction)instruction;  	if (!stack.Flush (statements' li.Body.BeforeState))  		return false;  	if (statements == null)  		return Failed (false' "loop");  	var whileStatements = BlockToStatements (li.Body' exid);  	statements.Add (new WhileDoStatement (new Int32ConstantExpression (1)' new Statements (whileStatements)));  	if (!stack.Restore (li.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.WhileDoPseudo: {  	var wdi = (WhileDoInstruction)instruction;  	if (!stack.Flush (statements' wdi.Condition.BeforeState))  		return false;  	var condEntry = BlockToExpression (wdi.Condition' exid);  	if (condEntry == null) {  		var stack1 = new ExpressionStack (compEnv' BottomE' nameSupply.GenSym' wdi.Condition.BeforeState' trace);  		var preCondStatements = new Seq<Statement> ();  		if (!TranslateBlock (preCondStatements' wdi.Condition' stack1' exid))  			return false;  		condEntry = stack1.FlushAndPopPostState (preCondStatements' wdi.Body.BeforeState);  		if (condEntry == null)  			return false;  		var stack2 = new ExpressionStack (compEnv' BottomE' nameSupply.GenSym' wdi.Body.BeforeState' trace);  		var postCondStatements = new Seq<Statement> ();  		if (!TranslateBlock (postCondStatements' wdi.Body' stack2' exid))  			return false;  		if (!stack2.Flush (postCondStatements' wdi.Body.AfterState))  			return false;  		preCondStatements.Add (new IfThenElseStatement (condEntry.Expression' new Statements (postCondStatements)' new Statements (new BreakStatement ())));  		statements.Add (new WhileDoStatement (new Int32ConstantExpression (1)' new Statements (preCondStatements)));  	}  	else {  		var loopStatements = BlockToStatements (wdi.Body' exid);  		if (loopStatements == null)  			return false;  		if (statements == null)  			return Failed (false' "while-do");  		statements.Add (new WhileDoStatement (condEntry.Expression' new Statements (loopStatements)));  	}  	if (!stack.Restore (wdi.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.DoWhilePseudo: {  	var dwi = (DoWhileInstruction)instruction;  	if (!stack.Flush (statements' dwi.Body.BeforeState))  		return false;  	var combined = new Seq<Instruction> ();  	foreach (var i in dwi.Body.Body)  		combined.Add (i);  	foreach (var i in dwi.Condition.Body)  		combined.Add (i);  	var condEntry = default(ExpressionStackEntry);  	var loopStatements = BlockToConditionStatements (new Instructions (null' combined)' dwi.Body.BeforeState' exid' out condEntry);  	if (loopStatements == null)  		return false;  	if (statements == null)  		return Failed (false' "do-while");  	statements.Add (new DoWhileStatement (new Statements (loopStatements)' condEntry.Expression));  	if (!stack.Restore (dwi.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.LoopControlPseudo: {  	var lci = (BreakContinueInstruction)instruction;  	if (!stack.Flush (statements' lci.BeforeState))  		return false;  	if (statements == null)  		return Failed (false' "loop-control");  	var targetState = default(int);  	switch (lci.Op) {  	case BreakContinueOp.Break:  		if (labelToLoopCandidateBreakState != null && labelToLoopCandidateBreakState.TryGetValue (lci.Label' out targetState))  			statements.Add (new GotoPseudoStatement (stateId' targetState));  		else  			statements.Add (new BreakStatement (lci.Label));  		break;  	case BreakContinueOp.Continue:  		if (labelToLoopCandidateContinueState != null && labelToLoopCandidateContinueState.TryGetValue (lci.Label' out targetState))  			statements.Add (new GotoPseudoStatement (stateId' targetState));  		else  			statements.Add (new ContinueStatement (lci.Label));  		break;  	default:  		throw new ArgumentOutOfRangeException ();  	}  	return true;  }  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (instruction.Flavor) {  case InstructionFlavor.Unsupported:  	throw new InvalidOperationException ("unsupported opcode");  case InstructionFlavor.Misc: {  	var misci = (MiscInstruction)instruction;  	switch (misci.Op) {  	case MiscOp.Nop:  	case MiscOp.Break:  		return true;  	case MiscOp.Dup:  		return stack.Dup (statements);  	case MiscOp.Pop:  		return stack.PopAndDiscard (statements);  	case MiscOp.Ldnull:  		stack.Push (new ExpressionStackEntry (new NullConstantExpression ()' BottomE));  		return true;  	case MiscOp.Ckfinite:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' UnaryOp.CheckFinite' false' false)' e.Lub (ThrowsE)));  	case MiscOp.Throw:  		if (!stack.DiscardAll (statements' 1))  			return false;  		if (!stack.PopEvalSE (statements' 1' true' ThrowsE' (s' a) => s.Add (new ThrowStatement (a [0]))))  			return false;  		return true;  	case MiscOp.Rethrow:  		if (!stack.DiscardAll (statements' 0))  			return false;  		if (statements == null)  			return Failed (false' "rethrow");  		if (exid == null)  			throw new InvalidOperationException ("rethrow outside of catch");  		statements.Add (new RethrowStatement (new VariableCell (exid).Read ()));  		return true;  	case MiscOp.LdindRef:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ReadExpression (a [0]).CloneIfStruct (compEnv)' e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ())));  	case MiscOp.LdelemRef:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' true).Read ().CloneIfStruct (compEnv)' e.Lub (ReadHeapOrThrowE)));  	case MiscOp.Ldlen:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' UnaryOp.Length' false' false)' e.Lub (ReadHeapOrThrowE)));  	case MiscOp.StindRef:  		return stack.PopEvalSE (statements' 2' true' instruction.BeforeState.PeekPointsTo (1).WriteEffect ()' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' a [1]))));  	case MiscOp.StelemRef:  		return stack.PopEvalSE (statements' 3' true' WriteHeapOrThrowE' (s' a) => s.Add (new ExpressionStatement (new ElementCell (a [0]' a [1]' false).Write (a [2]))));  	case MiscOp.Ret:  		if (statements == null)  			return Failed (false' "return");  		statements.Add (new ReturnStatement (null));  		return true;  	case MiscOp.RetVal:  		return stack.PopEvalSE (statements' 1' true' BottomE' (s' a) => s.Add (new ReturnStatement (a [0])));  	case MiscOp.Endfilter:  	case MiscOp.Endfinally:  		throw new InvalidOperationException ("endfilter/endfinally instructions should have been removed");  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Branch:  case InstructionFlavor.Switch:  	throw new InvalidOperationException ("branch/switch instructions should have been removed");  case InstructionFlavor.Compare: {  	var cmpi = (CompareInstruction)instruction;  	if (cmpi.Op == CompareOp.CtruePseudo || cmpi.Op == CompareOp.CfalsePseudo) {  		var s = cmpi.Type.Style (compEnv);  		var unop = default(UnaryOp);  		if (s is NumberTypeStyle)  			unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonZero : UnaryOp.IsZero;  		else  			unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonNull : UnaryOp.IsNull;  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' unop' false' cmpi.IsUnsigned)' e));  	}  	else {  		var binop = default(BinaryOp);  		switch (cmpi.Op) {  		case CompareOp.Ceq:  			binop = BinaryOp.Eq;  			break;  		case CompareOp.Clt:  			binop = BinaryOp.Lt;  			break;  		case CompareOp.Cgt:  			binop = BinaryOp.Gt;  			break;  		case CompareOp.CgePseudo:  			binop = BinaryOp.Ge;  			break;  		case CompareOp.ClePseudo:  			binop = BinaryOp.Le;  			break;  		case CompareOp.CnePseudo:  			binop = BinaryOp.Ne;  			break;  		case CompareOp.CtruePseudo:  		case CompareOp.CfalsePseudo:  			// handled above  			throw new InvalidOperationException ();  		default:  			throw new ArgumentOutOfRangeException ();  		}  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new BinaryExpression (a [0]' binop' a [1]' false' cmpi.IsUnsigned)' e));  	}  }  case InstructionFlavor.ArgLocal: {  	var sli = (ArgLocalInstruction)instruction;  	var id = default(JST.Identifier);  	switch (sli.ArgLocal) {  	case ArgLocal.Arg:  		id = compEnv.ValueParameterIds [sli.Index];  		break;  	case ArgLocal.Local:  		id = compEnv.LocalIds [sli.Index];  		break;  	default:  		throw new ArgumentOutOfRangeException ();  	}  	var cell = new VariableCell (id);  	switch (sli.Op) {  	case ArgLocalOp.Ld:  		stack.Push (new ExpressionStackEntry (cell.Read ().CloneIfStruct (compEnv)' ReadArgLocalE (sli.ArgLocal' sli.Index)));  		return true;  	case ArgLocalOp.Lda:  		// Effect will be accounted for on reads/writes  		stack.Push (new ExpressionStackEntry (cell.AddressOf ()' BottomE));  		return true;  	case ArgLocalOp.St:  		return stack.PopEvalSE (statements' 1' true' WriteArgLocalE (sli.ArgLocal' sli.Index)' (s' a) => s.Add (new ExpressionStatement (cell.Write (a [0]))));  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Field: {  	var fieldi = (FieldInstruction)instruction;  	switch (fieldi.Op) {  	case FieldOp.Ldfld:  		if (fieldi.IsStatic) {  			stack.Push (new ExpressionStackEntry (new FieldCell (null' compEnv.SubstituteMember (fieldi.Field)).Read ().CloneIfStruct (compEnv)' ReadHeapE));  			return true;  		}  		else  			return stack.PopEvalPush (statements' 1' true' (a' e) =>  {  				var readEffect = default(Effects);  				var obj = default(Expression);  				if (fieldi.IsViaPointer.Value) {  					readEffect = e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ());  					obj = new ReadExpression (a [0]);  					// no need for clone  				}  				else if (fieldi.Field.DefiningType.Style (compEnv) is ValueTypeStyle) {  					readEffect = e;  					obj = a [0];  				}  				else {  					// Object could be null  					readEffect = e.Lub (ReadHeapOrThrowE);  					obj = a [0];  				}  				return new ExpressionStackEntry (new FieldCell (obj' compEnv.SubstituteMember (fieldi.Field)).Read ().CloneIfStruct (compEnv)' readEffect);  			});  	case FieldOp.Ldflda:  		if (fieldi.IsStatic) {  			// Effect will be accounted for on reads/writes  			stack.Push (new ExpressionStackEntry (new FieldCell (null' compEnv.SubstituteMember (fieldi.Field)).AddressOf ()' BottomE));  			return true;  		}  		else  			return stack.PopEvalPush (statements' 1' true' (a' e) =>  {  				if (fieldi.IsViaPointer.Value)  					// We're just adding an offset to a pointer' so effect will  					// be accounted for when the final pointer is read/written  					return new ExpressionStackEntry (new FieldCell (new ReadExpression (a [0])' compEnv.SubstituteMember (fieldi.Field)).AddressOf ()' e);  				else  					// Must be a reference type' and ref could be null  					return new ExpressionStackEntry (new FieldCell (a [0]' compEnv.SubstituteMember (fieldi.Field)).AddressOf ()' e.Lub (ThrowsE));  			});  	case FieldOp.Stfld:  		if (fieldi.IsStatic)  			return stack.PopEvalSE (statements' 1' true' WriteHeapE' (s' a) => s.Add (new ExpressionStatement (new FieldCell (null' compEnv.SubstituteMember (fieldi.Field)).Write (a [0]))));  		else {  			var writeEffect = fieldi.IsViaPointer.Value ? instruction.BeforeState.PeekPointsTo (1).WriteEffect () : WriteHeapOrThrowE;  			return stack.PopEvalSE (statements' 2' true' writeEffect' (s' a) =>  {  				var obj = fieldi.IsViaPointer.Value ? new ReadExpression (a [0]) : a [0];  				s.Add (new ExpressionStatement (new FieldCell (obj' compEnv.SubstituteMember (fieldi.Field)).Write (a [1])));  			});  		}  	case FieldOp.Ldtoken:  		stack.Push (new ExpressionStackEntry (new FieldHandleConstantExpression (compEnv.SubstituteMember (fieldi.Field))' BottomE));  		return true;  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Method: {  	var methodi = (MethodInstruction)instruction;  	var arity = methodi.Method.ValueParameters.Count;  	switch (methodi.Op) {  	case MethodOp.Ldftn:  		if (methodi.IsVirtual)  			// Object could be null  			return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new CodePointerExpression (a [0]' compEnv.SubstituteMember (methodi.Method))' e.Lub (ReadHeapOrThrowE)));  		else {  			stack.Push (new ExpressionStackEntry (new CodePointerExpression (null' compEnv.SubstituteMember (methodi.Method))' BottomE));  			return true;  		}  	case MethodOp.Call:  		if (methodi.Method.Result == null)  			return stack.PopEvalSE (statements' arity' true' CalleeEffects (methodi.BeforeState' arity)' (s' a) => s.Add (new ExpressionStatement (new CallExpression (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal' compEnv.SubstituteMember (methodi.Method)' CallerArguments (methodi.Constrained' methodi.Method' a)))));  		else  			return stack.PopEvalPush (statements' arity' true' (a' e) => new ExpressionStackEntry (new CallExpression (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal' compEnv.SubstituteMember (methodi.Method)' CallerArguments (methodi.Constrained' methodi.Method' a))' e.Lub (CalleeEffects (methodi.BeforeState' arity))));  	case MethodOp.Newobj:  		arity--;  		return stack.PopEvalPush (statements' arity' true' (a' e) => new ExpressionStackEntry (new NewObjectExpression (compEnv.SubstituteMember (methodi.Method)' CallerArguments (null' methodi.Method' a))' e.Lub (CalleeEffects (methodi.BeforeState' arity))));  	case MethodOp.Ldtoken:  		stack.Push (new ExpressionStackEntry (new MethodHandleConstantExpression (compEnv.SubstituteMember (methodi.Method))' BottomE));  		return true;  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Type: {  	var typei = (TypeInstruction)instruction;  	switch (typei.Op) {  	case TypeOp.Ldobj:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ReadExpression (a [0]).CloneIfStruct (compEnv)' e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ())));  	case TypeOp.Stobj:  		return stack.PopEvalSE (statements' 2' true' instruction.BeforeState.PeekPointsTo (1).WriteEffect ()' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' a [1]))));  	case TypeOp.Cpobj: {  		var copyEffect = instruction.BeforeState.PeekPointsTo (0).ReadEffect ().Lub (instruction.BeforeState.PeekPointsTo (1).WriteEffect ());  		return stack.PopEvalSE (statements' 2' true' copyEffect' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' new ReadExpression (a [1]).CloneIfStruct (compEnv)))));  	}  	case TypeOp.Newarr:  		// Growing the heap is not considered an observable change. But will throw if  		// length < 0  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new NewArrayExpression (a [0]' compEnv.SubstituteType (typei.Type))' e.Lub (ThrowsE)));  	case TypeOp.Initobj:  		return stack.PopEvalSE (statements' 1' true' WriteHeapE' (s' a) => s.Add (new InitializeObjectStatement (a [0])));  	case TypeOp.Castclass:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new CastExpression (a [0]' compEnv.SubstituteType (typei.Type))' e.Lub (ThrowsE)));  	case TypeOp.Isinst:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new IsInstExpression (a [0]' compEnv.SubstituteType (typei.Type))' e));  	case TypeOp.Box:  		// Growing the heap is not considered an observable change  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new NewBoxExpression (a [0]' compEnv.SubstituteType (typei.Type))' e));  	case TypeOp.Unbox:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new BoxCell (a [0]' compEnv.SubstituteType (typei.Type)).AddressOf ()' e.Lub (ThrowsE)));  	case TypeOp.UnboxAny:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new BoxCell (a [0]' compEnv.SubstituteType (typei.Type)).Read ().CloneIfStruct (compEnv)' e.Lub (ThrowsE)));  	case TypeOp.Ldtoken:  		stack.Push (new ExpressionStackEntry (new TypeHandleConstantExpression (compEnv.SubstituteType (typei.Type))' BottomE));  		return true;  	case TypeOp.Ldelem:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' true).Read ().CloneIfStruct (compEnv)' e.Lub (ReadHeapOrThrowE)));  	case TypeOp.Stelem:  		return stack.PopEvalSE (statements' 3' true' WriteHeapOrThrowE' (s' a) => s.Add (new ExpressionStatement (new ElementCell (a [0]' a [1]' false).Write (a [2]))));  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.LdElemAddr:  	// Calculating the pointer may throw if index is out of range.  	// Remaining effect will be accounted for when pointer is read/written.  	return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' false).AddressOf ()' e.Lub (ThrowsE)));  case InstructionFlavor.LdInt32: {  	var int32i = (LdInt32Instruction)instruction;  	stack.Push (new ExpressionStackEntry (new Int32ConstantExpression (int32i.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdInt64: {  	var int64i = (LdInt64Instruction)instruction;  	stack.Push (new ExpressionStackEntry (new Int64ConstantExpression (int64i.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdSingle: {  	var singlei = (LdSingleInstruction)instruction;  	stack.Push (new ExpressionStackEntry (new SingleConstantExpression (singlei.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdDouble: {  	var doublei = (LdDoubleInstruction)instruction;  	stack.Push (new ExpressionStackEntry (new DoubleConstantExpression (doublei.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdString: {  	var stringi = (LdStringInstruction)instruction;  	stack.Push (new ExpressionStackEntry (new StringConstantExpression (stringi.Value)' BottomE));  	return true;  }  case InstructionFlavor.Arith: {  	var arithi = (ArithInstruction)instruction;  	switch (arithi.Op) {  	case ArithOp.Div:  	case ArithOp.Rem:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new BinaryExpression (a [0]' ArithOpToBinaryOp (arithi.Op)' a [1]' arithi.WithOverflow' arithi.IsUnsigned)' e.Lub (ThrowsE)));  	case ArithOp.Add:  	case ArithOp.Sub:  	case ArithOp.Mul:  	case ArithOp.BitAnd:  	case ArithOp.BitOr:  	case ArithOp.BitXor:  	case ArithOp.Shl:  	case ArithOp.Shr:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new BinaryExpression (a [0]' ArithOpToBinaryOp (arithi.Op)' a [1]' arithi.WithOverflow' arithi.IsUnsigned)' e.Lub (arithi.WithOverflow ? ThrowsE : BottomE)));  	case ArithOp.Neg:  	case ArithOp.BitNot:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' ArithOpToUnaryOp (arithi.Op)' arithi.WithOverflow' arithi.IsUnsigned)' e));  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Conv: {  	var convi = (ConvInstruction)instruction;  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ConvertExpression (a [0]' new NamedTypeRef (compEnv.Global.NumberFlavorToQualifiedTypeName [convi.TargetNumberFlavor])' convi.WithOverflow' convi.IsSourceUnsigned)' e.Lub (convi.WithOverflow ? ThrowsE : BottomE)));  }  case InstructionFlavor.Try: {  	if (stack.Depth > 0)  		throw new InvalidOperationException ("stack must be empty on entry to try block");  	var tryi = (TryInstruction)instruction;  	var tryStatements = BlockToTryFaultFinallyStatements (tryi.Body);  	if (tryStatements == null)  		return false;  	var handlers = TranslateHandlers (tryi.Handlers);  	if (handlers == null)  		return false;  	if (statements == null)  		return Failed (false' "try");  	statements.Add (new TryStatement (tryStatements' handlers));  	return true;  }  case InstructionFlavor.IfThenElsePseudo: {  	var itei = (IfThenElseInstruction)instruction;  	var isExpr = default(bool);  	// If outer context is re-translating as statements instead of expression' jump directly  	// to appropriate translation for this instruction  	var couldBeExpression = !instructionTranslationStyleCache.TryGetValue (itei.Offset' out isExpr) || isExpr;  	if (!TranslateBlock (statements' itei.Condition' stack' exid))  		return false;  	if (couldBeExpression && itei.Else != null) {  		// Pass 1: Try to tranlate to an if-then-else expression. Will only work if Then and Else don't  		//         reach into current stack' push exactly one value' and don't need to emit any  		//         statements along the way.  		var thenEntry = BlockToExpression (itei.Then' exid);  		if (thenEntry != null) {  			var elseEntry = BlockToExpression (itei.Else' exid);  			if (elseEntry != null) {  				if (!instructionTranslationStyleCache.ContainsKey (itei.Offset))  					instructionTranslationStyleCache.Add (itei.Offset' true);  				return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new IfThenElseExpression (a [0]' thenEntry.Expression' elseEntry.Expression)' e.Lub (thenEntry.Effects.Lub (elseEntry.Effects))));  			}  			// else: fallthrough  		}  		// else: fallthrough  	}  	// else: fallthrough  	// Pass 2: Translate to a statement  	var noStackChange = itei.Then.NoStackChange && (itei.Else == null || itei.Else.NoStackChange);  	var condEntry = noStackChange ? stack.Pop () : stack.FlushAndPopPostState (statements' itei.Then.BeforeState);  	if (condEntry == null)  		return false;  	var thenStmnts = noStackChange ? BlockToStatementsEmptyStack (itei.Then' exid) : BlockToStatements (itei.Then' exid);  	if (thenStmnts == null)  		return false;  	var elseStmnts = default(Seq<Statement>);  	if (itei.Else != null) {  		elseStmnts = noStackChange ? BlockToStatementsEmptyStack (itei.Else' exid) : BlockToStatements (itei.Else' exid);  		if (elseStmnts == null)  			return false;  	}  	if (statements == null)  		return Failed (false' "if-then-else");  	statements.Add (new IfThenElseStatement (condEntry.Expression' new Statements (thenStmnts)' elseStmnts == null ? null : new Statements (elseStmnts)));  	if (!noStackChange && !stack.Restore (itei.AfterState' 0))  		return false;  	if (!instructionTranslationStyleCache.ContainsKey (itei.Offset))  		instructionTranslationStyleCache.Add (itei.Offset' false);  	return true;  }  case InstructionFlavor.ShortCircuitingPseudo: {  	var sci = (ShortCircuitingInstruction)instruction;  	var isExpr = default(bool);  	// If outer context is re-translating as statements instead of expression' jump directly  	// to appropriate translation for this instruction  	var couldBeExpression = !instructionTranslationStyleCache.TryGetValue (sci.Offset' out isExpr) || isExpr;  	if (couldBeExpression) {  		// Pass 1: Try to translate to an expression.  		var leftEntry = BlockToExpression (sci.Left' exid);  		if (leftEntry != null) {  			var rightEntry = BlockToExpression (sci.Right' exid);  			if (rightEntry != null) {  				stack.Push (new ExpressionStackEntry (new BinaryExpression (leftEntry.Expression' ShortCircuitingOpToBinaryOp (sci.Op)' rightEntry.Expression' false' false)' leftEntry.Effects.Lub (rightEntry.Effects)));  				if (!instructionTranslationStyleCache.ContainsKey (sci.Offset))  					instructionTranslationStyleCache.Add (sci.Offset' true);  				return true;  			}  			// else: fallthrough  		}  		// else: fallthrough  	}  	// else: fallthrough  	// Pass 2: Translate to a statement  	if (!TranslateBlock (statements' sci.Left' stack' exid))  		return false;  	var leftEntry2 = stack.FlushAndPopPostState (statements' sci.Right.BeforeState);  	if (leftEntry2 == null)  		return false;  	var rightStatements = BlockToStatements (sci.Right' exid);  	if (rightStatements == null)  		return false;  	var id = sci.Right.AfterState.PeekId (0' nameSupply.GenSym);  	var cell = new VariableCell (id);  	compEnv.AddVariable (id' ArgLocal.Local' false' true' compEnv.SubstituteType (sci.Right.AfterState.PeekType (0)));  	if (statements == null)  		return Failed (false' "short-circuit");  	switch (sci.Op) {  	case ShortCircuitingOp.And:  		statements.Add (new IfThenElseStatement (leftEntry2.Expression' new Statements (rightStatements)' new Statements (new ExpressionStatement (cell.Write (new Int32ConstantExpression (0))))));  		break;  	case ShortCircuitingOp.Or:  		statements.Add (new IfThenElseStatement (leftEntry2.Expression' new Statements (new ExpressionStatement (cell.Write (new Int32ConstantExpression (1))))' new Statements (rightStatements)));  		break;  	default:  		throw new ArgumentOutOfRangeException ();  	}  	if (!stack.Restore (sci.AfterState' 1))  		return false;  	stack.Push (new ExpressionStackEntry (cell.Read ()' BottomE));  	if (!instructionTranslationStyleCache.ContainsKey (sci.Offset))  		instructionTranslationStyleCache.Add (sci.Offset' false);  	return true;  }  case InstructionFlavor.StructuralSwitchPseudo: {  	var ssi = (StructuralSwitchInstruction)instruction;  	if (!TranslateBlock (statements' ssi.Body' stack' exid))  		return false;  	var valueEntry = stack.FlushAndPopPreState (statements' ssi.Body.AfterState);  	if (valueEntry == null)  		return false;  	var cases = new Seq<SwitchStatementCase> ();  	foreach (var c in ssi.Cases) {  		var caseStatements = BlockToStatements (c.Body' exid);  		if (caseStatements == null)  			return false;  		cases.Add (new SwitchStatementCase (c.Values' new Statements (caseStatements)));  	}  	if (statements == null)  		return Failed (false' "structural switch");  	statements.Add (new SwitchStatement (valueEntry.Expression' cases));  	if (!stack.Restore (ssi.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.LoopPseudo: {  	var li = (LoopInstruction)instruction;  	if (!stack.Flush (statements' li.Body.BeforeState))  		return false;  	if (statements == null)  		return Failed (false' "loop");  	var whileStatements = BlockToStatements (li.Body' exid);  	statements.Add (new WhileDoStatement (new Int32ConstantExpression (1)' new Statements (whileStatements)));  	if (!stack.Restore (li.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.WhileDoPseudo: {  	var wdi = (WhileDoInstruction)instruction;  	if (!stack.Flush (statements' wdi.Condition.BeforeState))  		return false;  	var condEntry = BlockToExpression (wdi.Condition' exid);  	if (condEntry == null) {  		var stack1 = new ExpressionStack (compEnv' BottomE' nameSupply.GenSym' wdi.Condition.BeforeState' trace);  		var preCondStatements = new Seq<Statement> ();  		if (!TranslateBlock (preCondStatements' wdi.Condition' stack1' exid))  			return false;  		condEntry = stack1.FlushAndPopPostState (preCondStatements' wdi.Body.BeforeState);  		if (condEntry == null)  			return false;  		var stack2 = new ExpressionStack (compEnv' BottomE' nameSupply.GenSym' wdi.Body.BeforeState' trace);  		var postCondStatements = new Seq<Statement> ();  		if (!TranslateBlock (postCondStatements' wdi.Body' stack2' exid))  			return false;  		if (!stack2.Flush (postCondStatements' wdi.Body.AfterState))  			return false;  		preCondStatements.Add (new IfThenElseStatement (condEntry.Expression' new Statements (postCondStatements)' new Statements (new BreakStatement ())));  		statements.Add (new WhileDoStatement (new Int32ConstantExpression (1)' new Statements (preCondStatements)));  	}  	else {  		var loopStatements = BlockToStatements (wdi.Body' exid);  		if (loopStatements == null)  			return false;  		if (statements == null)  			return Failed (false' "while-do");  		statements.Add (new WhileDoStatement (condEntry.Expression' new Statements (loopStatements)));  	}  	if (!stack.Restore (wdi.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.DoWhilePseudo: {  	var dwi = (DoWhileInstruction)instruction;  	if (!stack.Flush (statements' dwi.Body.BeforeState))  		return false;  	var combined = new Seq<Instruction> ();  	foreach (var i in dwi.Body.Body)  		combined.Add (i);  	foreach (var i in dwi.Condition.Body)  		combined.Add (i);  	var condEntry = default(ExpressionStackEntry);  	var loopStatements = BlockToConditionStatements (new Instructions (null' combined)' dwi.Body.BeforeState' exid' out condEntry);  	if (loopStatements == null)  		return false;  	if (statements == null)  		return Failed (false' "do-while");  	statements.Add (new DoWhileStatement (new Statements (loopStatements)' condEntry.Expression));  	if (!stack.Restore (dwi.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.LoopControlPseudo: {  	var lci = (BreakContinueInstruction)instruction;  	if (!stack.Flush (statements' lci.BeforeState))  		return false;  	if (statements == null)  		return Failed (false' "loop-control");  	var targetState = default(int);  	switch (lci.Op) {  	case BreakContinueOp.Break:  		if (labelToLoopCandidateBreakState != null && labelToLoopCandidateBreakState.TryGetValue (lci.Label' out targetState))  			statements.Add (new GotoPseudoStatement (stateId' targetState));  		else  			statements.Add (new BreakStatement (lci.Label));  		break;  	case BreakContinueOp.Continue:  		if (labelToLoopCandidateContinueState != null && labelToLoopCandidateContinueState.TryGetValue (lci.Label' out targetState))  			statements.Add (new GotoPseudoStatement (stateId' targetState));  		else  			statements.Add (new ContinueStatement (lci.Label));  		break;  	default:  		throw new ArgumentOutOfRangeException ();  	}  	return true;  }  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (instruction.Flavor) {  case InstructionFlavor.Unsupported:  	throw new InvalidOperationException ("unsupported opcode");  case InstructionFlavor.Misc: {  	var misci = (MiscInstruction)instruction;  	switch (misci.Op) {  	case MiscOp.Nop:  	case MiscOp.Break:  		return true;  	case MiscOp.Dup:  		return stack.Dup (statements);  	case MiscOp.Pop:  		return stack.PopAndDiscard (statements);  	case MiscOp.Ldnull:  		stack.Push (new ExpressionStackEntry (new NullConstantExpression ()' BottomE));  		return true;  	case MiscOp.Ckfinite:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' UnaryOp.CheckFinite' false' false)' e.Lub (ThrowsE)));  	case MiscOp.Throw:  		if (!stack.DiscardAll (statements' 1))  			return false;  		if (!stack.PopEvalSE (statements' 1' true' ThrowsE' (s' a) => s.Add (new ThrowStatement (a [0]))))  			return false;  		return true;  	case MiscOp.Rethrow:  		if (!stack.DiscardAll (statements' 0))  			return false;  		if (statements == null)  			return Failed (false' "rethrow");  		if (exid == null)  			throw new InvalidOperationException ("rethrow outside of catch");  		statements.Add (new RethrowStatement (new VariableCell (exid).Read ()));  		return true;  	case MiscOp.LdindRef:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ReadExpression (a [0]).CloneIfStruct (compEnv)' e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ())));  	case MiscOp.LdelemRef:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' true).Read ().CloneIfStruct (compEnv)' e.Lub (ReadHeapOrThrowE)));  	case MiscOp.Ldlen:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' UnaryOp.Length' false' false)' e.Lub (ReadHeapOrThrowE)));  	case MiscOp.StindRef:  		return stack.PopEvalSE (statements' 2' true' instruction.BeforeState.PeekPointsTo (1).WriteEffect ()' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' a [1]))));  	case MiscOp.StelemRef:  		return stack.PopEvalSE (statements' 3' true' WriteHeapOrThrowE' (s' a) => s.Add (new ExpressionStatement (new ElementCell (a [0]' a [1]' false).Write (a [2]))));  	case MiscOp.Ret:  		if (statements == null)  			return Failed (false' "return");  		statements.Add (new ReturnStatement (null));  		return true;  	case MiscOp.RetVal:  		return stack.PopEvalSE (statements' 1' true' BottomE' (s' a) => s.Add (new ReturnStatement (a [0])));  	case MiscOp.Endfilter:  	case MiscOp.Endfinally:  		throw new InvalidOperationException ("endfilter/endfinally instructions should have been removed");  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Branch:  case InstructionFlavor.Switch:  	throw new InvalidOperationException ("branch/switch instructions should have been removed");  case InstructionFlavor.Compare: {  	var cmpi = (CompareInstruction)instruction;  	if (cmpi.Op == CompareOp.CtruePseudo || cmpi.Op == CompareOp.CfalsePseudo) {  		var s = cmpi.Type.Style (compEnv);  		var unop = default(UnaryOp);  		if (s is NumberTypeStyle)  			unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonZero : UnaryOp.IsZero;  		else  			unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonNull : UnaryOp.IsNull;  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' unop' false' cmpi.IsUnsigned)' e));  	}  	else {  		var binop = default(BinaryOp);  		switch (cmpi.Op) {  		case CompareOp.Ceq:  			binop = BinaryOp.Eq;  			break;  		case CompareOp.Clt:  			binop = BinaryOp.Lt;  			break;  		case CompareOp.Cgt:  			binop = BinaryOp.Gt;  			break;  		case CompareOp.CgePseudo:  			binop = BinaryOp.Ge;  			break;  		case CompareOp.ClePseudo:  			binop = BinaryOp.Le;  			break;  		case CompareOp.CnePseudo:  			binop = BinaryOp.Ne;  			break;  		case CompareOp.CtruePseudo:  		case CompareOp.CfalsePseudo:  			// handled above  			throw new InvalidOperationException ();  		default:  			throw new ArgumentOutOfRangeException ();  		}  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new BinaryExpression (a [0]' binop' a [1]' false' cmpi.IsUnsigned)' e));  	}  }  case InstructionFlavor.ArgLocal: {  	var sli = (ArgLocalInstruction)instruction;  	var id = default(JST.Identifier);  	switch (sli.ArgLocal) {  	case ArgLocal.Arg:  		id = compEnv.ValueParameterIds [sli.Index];  		break;  	case ArgLocal.Local:  		id = compEnv.LocalIds [sli.Index];  		break;  	default:  		throw new ArgumentOutOfRangeException ();  	}  	var cell = new VariableCell (id);  	switch (sli.Op) {  	case ArgLocalOp.Ld:  		stack.Push (new ExpressionStackEntry (cell.Read ().CloneIfStruct (compEnv)' ReadArgLocalE (sli.ArgLocal' sli.Index)));  		return true;  	case ArgLocalOp.Lda:  		// Effect will be accounted for on reads/writes  		stack.Push (new ExpressionStackEntry (cell.AddressOf ()' BottomE));  		return true;  	case ArgLocalOp.St:  		return stack.PopEvalSE (statements' 1' true' WriteArgLocalE (sli.ArgLocal' sli.Index)' (s' a) => s.Add (new ExpressionStatement (cell.Write (a [0]))));  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Field: {  	var fieldi = (FieldInstruction)instruction;  	switch (fieldi.Op) {  	case FieldOp.Ldfld:  		if (fieldi.IsStatic) {  			stack.Push (new ExpressionStackEntry (new FieldCell (null' compEnv.SubstituteMember (fieldi.Field)).Read ().CloneIfStruct (compEnv)' ReadHeapE));  			return true;  		}  		else  			return stack.PopEvalPush (statements' 1' true' (a' e) =>  {  				var readEffect = default(Effects);  				var obj = default(Expression);  				if (fieldi.IsViaPointer.Value) {  					readEffect = e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ());  					obj = new ReadExpression (a [0]);  					// no need for clone  				}  				else if (fieldi.Field.DefiningType.Style (compEnv) is ValueTypeStyle) {  					readEffect = e;  					obj = a [0];  				}  				else {  					// Object could be null  					readEffect = e.Lub (ReadHeapOrThrowE);  					obj = a [0];  				}  				return new ExpressionStackEntry (new FieldCell (obj' compEnv.SubstituteMember (fieldi.Field)).Read ().CloneIfStruct (compEnv)' readEffect);  			});  	case FieldOp.Ldflda:  		if (fieldi.IsStatic) {  			// Effect will be accounted for on reads/writes  			stack.Push (new ExpressionStackEntry (new FieldCell (null' compEnv.SubstituteMember (fieldi.Field)).AddressOf ()' BottomE));  			return true;  		}  		else  			return stack.PopEvalPush (statements' 1' true' (a' e) =>  {  				if (fieldi.IsViaPointer.Value)  					// We're just adding an offset to a pointer' so effect will  					// be accounted for when the final pointer is read/written  					return new ExpressionStackEntry (new FieldCell (new ReadExpression (a [0])' compEnv.SubstituteMember (fieldi.Field)).AddressOf ()' e);  				else  					// Must be a reference type' and ref could be null  					return new ExpressionStackEntry (new FieldCell (a [0]' compEnv.SubstituteMember (fieldi.Field)).AddressOf ()' e.Lub (ThrowsE));  			});  	case FieldOp.Stfld:  		if (fieldi.IsStatic)  			return stack.PopEvalSE (statements' 1' true' WriteHeapE' (s' a) => s.Add (new ExpressionStatement (new FieldCell (null' compEnv.SubstituteMember (fieldi.Field)).Write (a [0]))));  		else {  			var writeEffect = fieldi.IsViaPointer.Value ? instruction.BeforeState.PeekPointsTo (1).WriteEffect () : WriteHeapOrThrowE;  			return stack.PopEvalSE (statements' 2' true' writeEffect' (s' a) =>  {  				var obj = fieldi.IsViaPointer.Value ? new ReadExpression (a [0]) : a [0];  				s.Add (new ExpressionStatement (new FieldCell (obj' compEnv.SubstituteMember (fieldi.Field)).Write (a [1])));  			});  		}  	case FieldOp.Ldtoken:  		stack.Push (new ExpressionStackEntry (new FieldHandleConstantExpression (compEnv.SubstituteMember (fieldi.Field))' BottomE));  		return true;  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Method: {  	var methodi = (MethodInstruction)instruction;  	var arity = methodi.Method.ValueParameters.Count;  	switch (methodi.Op) {  	case MethodOp.Ldftn:  		if (methodi.IsVirtual)  			// Object could be null  			return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new CodePointerExpression (a [0]' compEnv.SubstituteMember (methodi.Method))' e.Lub (ReadHeapOrThrowE)));  		else {  			stack.Push (new ExpressionStackEntry (new CodePointerExpression (null' compEnv.SubstituteMember (methodi.Method))' BottomE));  			return true;  		}  	case MethodOp.Call:  		if (methodi.Method.Result == null)  			return stack.PopEvalSE (statements' arity' true' CalleeEffects (methodi.BeforeState' arity)' (s' a) => s.Add (new ExpressionStatement (new CallExpression (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal' compEnv.SubstituteMember (methodi.Method)' CallerArguments (methodi.Constrained' methodi.Method' a)))));  		else  			return stack.PopEvalPush (statements' arity' true' (a' e) => new ExpressionStackEntry (new CallExpression (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal' compEnv.SubstituteMember (methodi.Method)' CallerArguments (methodi.Constrained' methodi.Method' a))' e.Lub (CalleeEffects (methodi.BeforeState' arity))));  	case MethodOp.Newobj:  		arity--;  		return stack.PopEvalPush (statements' arity' true' (a' e) => new ExpressionStackEntry (new NewObjectExpression (compEnv.SubstituteMember (methodi.Method)' CallerArguments (null' methodi.Method' a))' e.Lub (CalleeEffects (methodi.BeforeState' arity))));  	case MethodOp.Ldtoken:  		stack.Push (new ExpressionStackEntry (new MethodHandleConstantExpression (compEnv.SubstituteMember (methodi.Method))' BottomE));  		return true;  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Type: {  	var typei = (TypeInstruction)instruction;  	switch (typei.Op) {  	case TypeOp.Ldobj:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ReadExpression (a [0]).CloneIfStruct (compEnv)' e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ())));  	case TypeOp.Stobj:  		return stack.PopEvalSE (statements' 2' true' instruction.BeforeState.PeekPointsTo (1).WriteEffect ()' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' a [1]))));  	case TypeOp.Cpobj: {  		var copyEffect = instruction.BeforeState.PeekPointsTo (0).ReadEffect ().Lub (instruction.BeforeState.PeekPointsTo (1).WriteEffect ());  		return stack.PopEvalSE (statements' 2' true' copyEffect' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' new ReadExpression (a [1]).CloneIfStruct (compEnv)))));  	}  	case TypeOp.Newarr:  		// Growing the heap is not considered an observable change. But will throw if  		// length < 0  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new NewArrayExpression (a [0]' compEnv.SubstituteType (typei.Type))' e.Lub (ThrowsE)));  	case TypeOp.Initobj:  		return stack.PopEvalSE (statements' 1' true' WriteHeapE' (s' a) => s.Add (new InitializeObjectStatement (a [0])));  	case TypeOp.Castclass:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new CastExpression (a [0]' compEnv.SubstituteType (typei.Type))' e.Lub (ThrowsE)));  	case TypeOp.Isinst:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new IsInstExpression (a [0]' compEnv.SubstituteType (typei.Type))' e));  	case TypeOp.Box:  		// Growing the heap is not considered an observable change  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new NewBoxExpression (a [0]' compEnv.SubstituteType (typei.Type))' e));  	case TypeOp.Unbox:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new BoxCell (a [0]' compEnv.SubstituteType (typei.Type)).AddressOf ()' e.Lub (ThrowsE)));  	case TypeOp.UnboxAny:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new BoxCell (a [0]' compEnv.SubstituteType (typei.Type)).Read ().CloneIfStruct (compEnv)' e.Lub (ThrowsE)));  	case TypeOp.Ldtoken:  		stack.Push (new ExpressionStackEntry (new TypeHandleConstantExpression (compEnv.SubstituteType (typei.Type))' BottomE));  		return true;  	case TypeOp.Ldelem:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' true).Read ().CloneIfStruct (compEnv)' e.Lub (ReadHeapOrThrowE)));  	case TypeOp.Stelem:  		return stack.PopEvalSE (statements' 3' true' WriteHeapOrThrowE' (s' a) => s.Add (new ExpressionStatement (new ElementCell (a [0]' a [1]' false).Write (a [2]))));  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.LdElemAddr:  	// Calculating the pointer may throw if index is out of range.  	// Remaining effect will be accounted for when pointer is read/written.  	return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' false).AddressOf ()' e.Lub (ThrowsE)));  case InstructionFlavor.LdInt32: {  	var int32i = (LdInt32Instruction)instruction;  	stack.Push (new ExpressionStackEntry (new Int32ConstantExpression (int32i.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdInt64: {  	var int64i = (LdInt64Instruction)instruction;  	stack.Push (new ExpressionStackEntry (new Int64ConstantExpression (int64i.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdSingle: {  	var singlei = (LdSingleInstruction)instruction;  	stack.Push (new ExpressionStackEntry (new SingleConstantExpression (singlei.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdDouble: {  	var doublei = (LdDoubleInstruction)instruction;  	stack.Push (new ExpressionStackEntry (new DoubleConstantExpression (doublei.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdString: {  	var stringi = (LdStringInstruction)instruction;  	stack.Push (new ExpressionStackEntry (new StringConstantExpression (stringi.Value)' BottomE));  	return true;  }  case InstructionFlavor.Arith: {  	var arithi = (ArithInstruction)instruction;  	switch (arithi.Op) {  	case ArithOp.Div:  	case ArithOp.Rem:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new BinaryExpression (a [0]' ArithOpToBinaryOp (arithi.Op)' a [1]' arithi.WithOverflow' arithi.IsUnsigned)' e.Lub (ThrowsE)));  	case ArithOp.Add:  	case ArithOp.Sub:  	case ArithOp.Mul:  	case ArithOp.BitAnd:  	case ArithOp.BitOr:  	case ArithOp.BitXor:  	case ArithOp.Shl:  	case ArithOp.Shr:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new BinaryExpression (a [0]' ArithOpToBinaryOp (arithi.Op)' a [1]' arithi.WithOverflow' arithi.IsUnsigned)' e.Lub (arithi.WithOverflow ? ThrowsE : BottomE)));  	case ArithOp.Neg:  	case ArithOp.BitNot:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' ArithOpToUnaryOp (arithi.Op)' arithi.WithOverflow' arithi.IsUnsigned)' e));  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Conv: {  	var convi = (ConvInstruction)instruction;  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ConvertExpression (a [0]' new NamedTypeRef (compEnv.Global.NumberFlavorToQualifiedTypeName [convi.TargetNumberFlavor])' convi.WithOverflow' convi.IsSourceUnsigned)' e.Lub (convi.WithOverflow ? ThrowsE : BottomE)));  }  case InstructionFlavor.Try: {  	if (stack.Depth > 0)  		throw new InvalidOperationException ("stack must be empty on entry to try block");  	var tryi = (TryInstruction)instruction;  	var tryStatements = BlockToTryFaultFinallyStatements (tryi.Body);  	if (tryStatements == null)  		return false;  	var handlers = TranslateHandlers (tryi.Handlers);  	if (handlers == null)  		return false;  	if (statements == null)  		return Failed (false' "try");  	statements.Add (new TryStatement (tryStatements' handlers));  	return true;  }  case InstructionFlavor.IfThenElsePseudo: {  	var itei = (IfThenElseInstruction)instruction;  	var isExpr = default(bool);  	// If outer context is re-translating as statements instead of expression' jump directly  	// to appropriate translation for this instruction  	var couldBeExpression = !instructionTranslationStyleCache.TryGetValue (itei.Offset' out isExpr) || isExpr;  	if (!TranslateBlock (statements' itei.Condition' stack' exid))  		return false;  	if (couldBeExpression && itei.Else != null) {  		// Pass 1: Try to tranlate to an if-then-else expression. Will only work if Then and Else don't  		//         reach into current stack' push exactly one value' and don't need to emit any  		//         statements along the way.  		var thenEntry = BlockToExpression (itei.Then' exid);  		if (thenEntry != null) {  			var elseEntry = BlockToExpression (itei.Else' exid);  			if (elseEntry != null) {  				if (!instructionTranslationStyleCache.ContainsKey (itei.Offset))  					instructionTranslationStyleCache.Add (itei.Offset' true);  				return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new IfThenElseExpression (a [0]' thenEntry.Expression' elseEntry.Expression)' e.Lub (thenEntry.Effects.Lub (elseEntry.Effects))));  			}  			// else: fallthrough  		}  		// else: fallthrough  	}  	// else: fallthrough  	// Pass 2: Translate to a statement  	var noStackChange = itei.Then.NoStackChange && (itei.Else == null || itei.Else.NoStackChange);  	var condEntry = noStackChange ? stack.Pop () : stack.FlushAndPopPostState (statements' itei.Then.BeforeState);  	if (condEntry == null)  		return false;  	var thenStmnts = noStackChange ? BlockToStatementsEmptyStack (itei.Then' exid) : BlockToStatements (itei.Then' exid);  	if (thenStmnts == null)  		return false;  	var elseStmnts = default(Seq<Statement>);  	if (itei.Else != null) {  		elseStmnts = noStackChange ? BlockToStatementsEmptyStack (itei.Else' exid) : BlockToStatements (itei.Else' exid);  		if (elseStmnts == null)  			return false;  	}  	if (statements == null)  		return Failed (false' "if-then-else");  	statements.Add (new IfThenElseStatement (condEntry.Expression' new Statements (thenStmnts)' elseStmnts == null ? null : new Statements (elseStmnts)));  	if (!noStackChange && !stack.Restore (itei.AfterState' 0))  		return false;  	if (!instructionTranslationStyleCache.ContainsKey (itei.Offset))  		instructionTranslationStyleCache.Add (itei.Offset' false);  	return true;  }  case InstructionFlavor.ShortCircuitingPseudo: {  	var sci = (ShortCircuitingInstruction)instruction;  	var isExpr = default(bool);  	// If outer context is re-translating as statements instead of expression' jump directly  	// to appropriate translation for this instruction  	var couldBeExpression = !instructionTranslationStyleCache.TryGetValue (sci.Offset' out isExpr) || isExpr;  	if (couldBeExpression) {  		// Pass 1: Try to translate to an expression.  		var leftEntry = BlockToExpression (sci.Left' exid);  		if (leftEntry != null) {  			var rightEntry = BlockToExpression (sci.Right' exid);  			if (rightEntry != null) {  				stack.Push (new ExpressionStackEntry (new BinaryExpression (leftEntry.Expression' ShortCircuitingOpToBinaryOp (sci.Op)' rightEntry.Expression' false' false)' leftEntry.Effects.Lub (rightEntry.Effects)));  				if (!instructionTranslationStyleCache.ContainsKey (sci.Offset))  					instructionTranslationStyleCache.Add (sci.Offset' true);  				return true;  			}  			// else: fallthrough  		}  		// else: fallthrough  	}  	// else: fallthrough  	// Pass 2: Translate to a statement  	if (!TranslateBlock (statements' sci.Left' stack' exid))  		return false;  	var leftEntry2 = stack.FlushAndPopPostState (statements' sci.Right.BeforeState);  	if (leftEntry2 == null)  		return false;  	var rightStatements = BlockToStatements (sci.Right' exid);  	if (rightStatements == null)  		return false;  	var id = sci.Right.AfterState.PeekId (0' nameSupply.GenSym);  	var cell = new VariableCell (id);  	compEnv.AddVariable (id' ArgLocal.Local' false' true' compEnv.SubstituteType (sci.Right.AfterState.PeekType (0)));  	if (statements == null)  		return Failed (false' "short-circuit");  	switch (sci.Op) {  	case ShortCircuitingOp.And:  		statements.Add (new IfThenElseStatement (leftEntry2.Expression' new Statements (rightStatements)' new Statements (new ExpressionStatement (cell.Write (new Int32ConstantExpression (0))))));  		break;  	case ShortCircuitingOp.Or:  		statements.Add (new IfThenElseStatement (leftEntry2.Expression' new Statements (new ExpressionStatement (cell.Write (new Int32ConstantExpression (1))))' new Statements (rightStatements)));  		break;  	default:  		throw new ArgumentOutOfRangeException ();  	}  	if (!stack.Restore (sci.AfterState' 1))  		return false;  	stack.Push (new ExpressionStackEntry (cell.Read ()' BottomE));  	if (!instructionTranslationStyleCache.ContainsKey (sci.Offset))  		instructionTranslationStyleCache.Add (sci.Offset' false);  	return true;  }  case InstructionFlavor.StructuralSwitchPseudo: {  	var ssi = (StructuralSwitchInstruction)instruction;  	if (!TranslateBlock (statements' ssi.Body' stack' exid))  		return false;  	var valueEntry = stack.FlushAndPopPreState (statements' ssi.Body.AfterState);  	if (valueEntry == null)  		return false;  	var cases = new Seq<SwitchStatementCase> ();  	foreach (var c in ssi.Cases) {  		var caseStatements = BlockToStatements (c.Body' exid);  		if (caseStatements == null)  			return false;  		cases.Add (new SwitchStatementCase (c.Values' new Statements (caseStatements)));  	}  	if (statements == null)  		return Failed (false' "structural switch");  	statements.Add (new SwitchStatement (valueEntry.Expression' cases));  	if (!stack.Restore (ssi.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.LoopPseudo: {  	var li = (LoopInstruction)instruction;  	if (!stack.Flush (statements' li.Body.BeforeState))  		return false;  	if (statements == null)  		return Failed (false' "loop");  	var whileStatements = BlockToStatements (li.Body' exid);  	statements.Add (new WhileDoStatement (new Int32ConstantExpression (1)' new Statements (whileStatements)));  	if (!stack.Restore (li.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.WhileDoPseudo: {  	var wdi = (WhileDoInstruction)instruction;  	if (!stack.Flush (statements' wdi.Condition.BeforeState))  		return false;  	var condEntry = BlockToExpression (wdi.Condition' exid);  	if (condEntry == null) {  		var stack1 = new ExpressionStack (compEnv' BottomE' nameSupply.GenSym' wdi.Condition.BeforeState' trace);  		var preCondStatements = new Seq<Statement> ();  		if (!TranslateBlock (preCondStatements' wdi.Condition' stack1' exid))  			return false;  		condEntry = stack1.FlushAndPopPostState (preCondStatements' wdi.Body.BeforeState);  		if (condEntry == null)  			return false;  		var stack2 = new ExpressionStack (compEnv' BottomE' nameSupply.GenSym' wdi.Body.BeforeState' trace);  		var postCondStatements = new Seq<Statement> ();  		if (!TranslateBlock (postCondStatements' wdi.Body' stack2' exid))  			return false;  		if (!stack2.Flush (postCondStatements' wdi.Body.AfterState))  			return false;  		preCondStatements.Add (new IfThenElseStatement (condEntry.Expression' new Statements (postCondStatements)' new Statements (new BreakStatement ())));  		statements.Add (new WhileDoStatement (new Int32ConstantExpression (1)' new Statements (preCondStatements)));  	}  	else {  		var loopStatements = BlockToStatements (wdi.Body' exid);  		if (loopStatements == null)  			return false;  		if (statements == null)  			return Failed (false' "while-do");  		statements.Add (new WhileDoStatement (condEntry.Expression' new Statements (loopStatements)));  	}  	if (!stack.Restore (wdi.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.DoWhilePseudo: {  	var dwi = (DoWhileInstruction)instruction;  	if (!stack.Flush (statements' dwi.Body.BeforeState))  		return false;  	var combined = new Seq<Instruction> ();  	foreach (var i in dwi.Body.Body)  		combined.Add (i);  	foreach (var i in dwi.Condition.Body)  		combined.Add (i);  	var condEntry = default(ExpressionStackEntry);  	var loopStatements = BlockToConditionStatements (new Instructions (null' combined)' dwi.Body.BeforeState' exid' out condEntry);  	if (loopStatements == null)  		return false;  	if (statements == null)  		return Failed (false' "do-while");  	statements.Add (new DoWhileStatement (new Statements (loopStatements)' condEntry.Expression));  	if (!stack.Restore (dwi.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.LoopControlPseudo: {  	var lci = (BreakContinueInstruction)instruction;  	if (!stack.Flush (statements' lci.BeforeState))  		return false;  	if (statements == null)  		return Failed (false' "loop-control");  	var targetState = default(int);  	switch (lci.Op) {  	case BreakContinueOp.Break:  		if (labelToLoopCandidateBreakState != null && labelToLoopCandidateBreakState.TryGetValue (lci.Label' out targetState))  			statements.Add (new GotoPseudoStatement (stateId' targetState));  		else  			statements.Add (new BreakStatement (lci.Label));  		break;  	case BreakContinueOp.Continue:  		if (labelToLoopCandidateContinueState != null && labelToLoopCandidateContinueState.TryGetValue (lci.Label' out targetState))  			statements.Add (new GotoPseudoStatement (stateId' targetState));  		else  			statements.Add (new ContinueStatement (lci.Label));  		break;  	default:  		throw new ArgumentOutOfRangeException ();  	}  	return true;  }  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (instruction.Flavor) {  case InstructionFlavor.Unsupported:  	throw new InvalidOperationException ("unsupported opcode");  case InstructionFlavor.Misc: {  	var misci = (MiscInstruction)instruction;  	switch (misci.Op) {  	case MiscOp.Nop:  	case MiscOp.Break:  		return true;  	case MiscOp.Dup:  		return stack.Dup (statements);  	case MiscOp.Pop:  		return stack.PopAndDiscard (statements);  	case MiscOp.Ldnull:  		stack.Push (new ExpressionStackEntry (new NullConstantExpression ()' BottomE));  		return true;  	case MiscOp.Ckfinite:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' UnaryOp.CheckFinite' false' false)' e.Lub (ThrowsE)));  	case MiscOp.Throw:  		if (!stack.DiscardAll (statements' 1))  			return false;  		if (!stack.PopEvalSE (statements' 1' true' ThrowsE' (s' a) => s.Add (new ThrowStatement (a [0]))))  			return false;  		return true;  	case MiscOp.Rethrow:  		if (!stack.DiscardAll (statements' 0))  			return false;  		if (statements == null)  			return Failed (false' "rethrow");  		if (exid == null)  			throw new InvalidOperationException ("rethrow outside of catch");  		statements.Add (new RethrowStatement (new VariableCell (exid).Read ()));  		return true;  	case MiscOp.LdindRef:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ReadExpression (a [0]).CloneIfStruct (compEnv)' e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ())));  	case MiscOp.LdelemRef:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' true).Read ().CloneIfStruct (compEnv)' e.Lub (ReadHeapOrThrowE)));  	case MiscOp.Ldlen:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' UnaryOp.Length' false' false)' e.Lub (ReadHeapOrThrowE)));  	case MiscOp.StindRef:  		return stack.PopEvalSE (statements' 2' true' instruction.BeforeState.PeekPointsTo (1).WriteEffect ()' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' a [1]))));  	case MiscOp.StelemRef:  		return stack.PopEvalSE (statements' 3' true' WriteHeapOrThrowE' (s' a) => s.Add (new ExpressionStatement (new ElementCell (a [0]' a [1]' false).Write (a [2]))));  	case MiscOp.Ret:  		if (statements == null)  			return Failed (false' "return");  		statements.Add (new ReturnStatement (null));  		return true;  	case MiscOp.RetVal:  		return stack.PopEvalSE (statements' 1' true' BottomE' (s' a) => s.Add (new ReturnStatement (a [0])));  	case MiscOp.Endfilter:  	case MiscOp.Endfinally:  		throw new InvalidOperationException ("endfilter/endfinally instructions should have been removed");  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Branch:  case InstructionFlavor.Switch:  	throw new InvalidOperationException ("branch/switch instructions should have been removed");  case InstructionFlavor.Compare: {  	var cmpi = (CompareInstruction)instruction;  	if (cmpi.Op == CompareOp.CtruePseudo || cmpi.Op == CompareOp.CfalsePseudo) {  		var s = cmpi.Type.Style (compEnv);  		var unop = default(UnaryOp);  		if (s is NumberTypeStyle)  			unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonZero : UnaryOp.IsZero;  		else  			unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonNull : UnaryOp.IsNull;  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' unop' false' cmpi.IsUnsigned)' e));  	}  	else {  		var binop = default(BinaryOp);  		switch (cmpi.Op) {  		case CompareOp.Ceq:  			binop = BinaryOp.Eq;  			break;  		case CompareOp.Clt:  			binop = BinaryOp.Lt;  			break;  		case CompareOp.Cgt:  			binop = BinaryOp.Gt;  			break;  		case CompareOp.CgePseudo:  			binop = BinaryOp.Ge;  			break;  		case CompareOp.ClePseudo:  			binop = BinaryOp.Le;  			break;  		case CompareOp.CnePseudo:  			binop = BinaryOp.Ne;  			break;  		case CompareOp.CtruePseudo:  		case CompareOp.CfalsePseudo:  			// handled above  			throw new InvalidOperationException ();  		default:  			throw new ArgumentOutOfRangeException ();  		}  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new BinaryExpression (a [0]' binop' a [1]' false' cmpi.IsUnsigned)' e));  	}  }  case InstructionFlavor.ArgLocal: {  	var sli = (ArgLocalInstruction)instruction;  	var id = default(JST.Identifier);  	switch (sli.ArgLocal) {  	case ArgLocal.Arg:  		id = compEnv.ValueParameterIds [sli.Index];  		break;  	case ArgLocal.Local:  		id = compEnv.LocalIds [sli.Index];  		break;  	default:  		throw new ArgumentOutOfRangeException ();  	}  	var cell = new VariableCell (id);  	switch (sli.Op) {  	case ArgLocalOp.Ld:  		stack.Push (new ExpressionStackEntry (cell.Read ().CloneIfStruct (compEnv)' ReadArgLocalE (sli.ArgLocal' sli.Index)));  		return true;  	case ArgLocalOp.Lda:  		// Effect will be accounted for on reads/writes  		stack.Push (new ExpressionStackEntry (cell.AddressOf ()' BottomE));  		return true;  	case ArgLocalOp.St:  		return stack.PopEvalSE (statements' 1' true' WriteArgLocalE (sli.ArgLocal' sli.Index)' (s' a) => s.Add (new ExpressionStatement (cell.Write (a [0]))));  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Field: {  	var fieldi = (FieldInstruction)instruction;  	switch (fieldi.Op) {  	case FieldOp.Ldfld:  		if (fieldi.IsStatic) {  			stack.Push (new ExpressionStackEntry (new FieldCell (null' compEnv.SubstituteMember (fieldi.Field)).Read ().CloneIfStruct (compEnv)' ReadHeapE));  			return true;  		}  		else  			return stack.PopEvalPush (statements' 1' true' (a' e) =>  {  				var readEffect = default(Effects);  				var obj = default(Expression);  				if (fieldi.IsViaPointer.Value) {  					readEffect = e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ());  					obj = new ReadExpression (a [0]);  					// no need for clone  				}  				else if (fieldi.Field.DefiningType.Style (compEnv) is ValueTypeStyle) {  					readEffect = e;  					obj = a [0];  				}  				else {  					// Object could be null  					readEffect = e.Lub (ReadHeapOrThrowE);  					obj = a [0];  				}  				return new ExpressionStackEntry (new FieldCell (obj' compEnv.SubstituteMember (fieldi.Field)).Read ().CloneIfStruct (compEnv)' readEffect);  			});  	case FieldOp.Ldflda:  		if (fieldi.IsStatic) {  			// Effect will be accounted for on reads/writes  			stack.Push (new ExpressionStackEntry (new FieldCell (null' compEnv.SubstituteMember (fieldi.Field)).AddressOf ()' BottomE));  			return true;  		}  		else  			return stack.PopEvalPush (statements' 1' true' (a' e) =>  {  				if (fieldi.IsViaPointer.Value)  					// We're just adding an offset to a pointer' so effect will  					// be accounted for when the final pointer is read/written  					return new ExpressionStackEntry (new FieldCell (new ReadExpression (a [0])' compEnv.SubstituteMember (fieldi.Field)).AddressOf ()' e);  				else  					// Must be a reference type' and ref could be null  					return new ExpressionStackEntry (new FieldCell (a [0]' compEnv.SubstituteMember (fieldi.Field)).AddressOf ()' e.Lub (ThrowsE));  			});  	case FieldOp.Stfld:  		if (fieldi.IsStatic)  			return stack.PopEvalSE (statements' 1' true' WriteHeapE' (s' a) => s.Add (new ExpressionStatement (new FieldCell (null' compEnv.SubstituteMember (fieldi.Field)).Write (a [0]))));  		else {  			var writeEffect = fieldi.IsViaPointer.Value ? instruction.BeforeState.PeekPointsTo (1).WriteEffect () : WriteHeapOrThrowE;  			return stack.PopEvalSE (statements' 2' true' writeEffect' (s' a) =>  {  				var obj = fieldi.IsViaPointer.Value ? new ReadExpression (a [0]) : a [0];  				s.Add (new ExpressionStatement (new FieldCell (obj' compEnv.SubstituteMember (fieldi.Field)).Write (a [1])));  			});  		}  	case FieldOp.Ldtoken:  		stack.Push (new ExpressionStackEntry (new FieldHandleConstantExpression (compEnv.SubstituteMember (fieldi.Field))' BottomE));  		return true;  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Method: {  	var methodi = (MethodInstruction)instruction;  	var arity = methodi.Method.ValueParameters.Count;  	switch (methodi.Op) {  	case MethodOp.Ldftn:  		if (methodi.IsVirtual)  			// Object could be null  			return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new CodePointerExpression (a [0]' compEnv.SubstituteMember (methodi.Method))' e.Lub (ReadHeapOrThrowE)));  		else {  			stack.Push (new ExpressionStackEntry (new CodePointerExpression (null' compEnv.SubstituteMember (methodi.Method))' BottomE));  			return true;  		}  	case MethodOp.Call:  		if (methodi.Method.Result == null)  			return stack.PopEvalSE (statements' arity' true' CalleeEffects (methodi.BeforeState' arity)' (s' a) => s.Add (new ExpressionStatement (new CallExpression (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal' compEnv.SubstituteMember (methodi.Method)' CallerArguments (methodi.Constrained' methodi.Method' a)))));  		else  			return stack.PopEvalPush (statements' arity' true' (a' e) => new ExpressionStackEntry (new CallExpression (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal' compEnv.SubstituteMember (methodi.Method)' CallerArguments (methodi.Constrained' methodi.Method' a))' e.Lub (CalleeEffects (methodi.BeforeState' arity))));  	case MethodOp.Newobj:  		arity--;  		return stack.PopEvalPush (statements' arity' true' (a' e) => new ExpressionStackEntry (new NewObjectExpression (compEnv.SubstituteMember (methodi.Method)' CallerArguments (null' methodi.Method' a))' e.Lub (CalleeEffects (methodi.BeforeState' arity))));  	case MethodOp.Ldtoken:  		stack.Push (new ExpressionStackEntry (new MethodHandleConstantExpression (compEnv.SubstituteMember (methodi.Method))' BottomE));  		return true;  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Type: {  	var typei = (TypeInstruction)instruction;  	switch (typei.Op) {  	case TypeOp.Ldobj:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ReadExpression (a [0]).CloneIfStruct (compEnv)' e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ())));  	case TypeOp.Stobj:  		return stack.PopEvalSE (statements' 2' true' instruction.BeforeState.PeekPointsTo (1).WriteEffect ()' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' a [1]))));  	case TypeOp.Cpobj: {  		var copyEffect = instruction.BeforeState.PeekPointsTo (0).ReadEffect ().Lub (instruction.BeforeState.PeekPointsTo (1).WriteEffect ());  		return stack.PopEvalSE (statements' 2' true' copyEffect' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' new ReadExpression (a [1]).CloneIfStruct (compEnv)))));  	}  	case TypeOp.Newarr:  		// Growing the heap is not considered an observable change. But will throw if  		// length < 0  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new NewArrayExpression (a [0]' compEnv.SubstituteType (typei.Type))' e.Lub (ThrowsE)));  	case TypeOp.Initobj:  		return stack.PopEvalSE (statements' 1' true' WriteHeapE' (s' a) => s.Add (new InitializeObjectStatement (a [0])));  	case TypeOp.Castclass:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new CastExpression (a [0]' compEnv.SubstituteType (typei.Type))' e.Lub (ThrowsE)));  	case TypeOp.Isinst:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new IsInstExpression (a [0]' compEnv.SubstituteType (typei.Type))' e));  	case TypeOp.Box:  		// Growing the heap is not considered an observable change  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new NewBoxExpression (a [0]' compEnv.SubstituteType (typei.Type))' e));  	case TypeOp.Unbox:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new BoxCell (a [0]' compEnv.SubstituteType (typei.Type)).AddressOf ()' e.Lub (ThrowsE)));  	case TypeOp.UnboxAny:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new BoxCell (a [0]' compEnv.SubstituteType (typei.Type)).Read ().CloneIfStruct (compEnv)' e.Lub (ThrowsE)));  	case TypeOp.Ldtoken:  		stack.Push (new ExpressionStackEntry (new TypeHandleConstantExpression (compEnv.SubstituteType (typei.Type))' BottomE));  		return true;  	case TypeOp.Ldelem:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' true).Read ().CloneIfStruct (compEnv)' e.Lub (ReadHeapOrThrowE)));  	case TypeOp.Stelem:  		return stack.PopEvalSE (statements' 3' true' WriteHeapOrThrowE' (s' a) => s.Add (new ExpressionStatement (new ElementCell (a [0]' a [1]' false).Write (a [2]))));  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.LdElemAddr:  	// Calculating the pointer may throw if index is out of range.  	// Remaining effect will be accounted for when pointer is read/written.  	return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' false).AddressOf ()' e.Lub (ThrowsE)));  case InstructionFlavor.LdInt32: {  	var int32i = (LdInt32Instruction)instruction;  	stack.Push (new ExpressionStackEntry (new Int32ConstantExpression (int32i.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdInt64: {  	var int64i = (LdInt64Instruction)instruction;  	stack.Push (new ExpressionStackEntry (new Int64ConstantExpression (int64i.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdSingle: {  	var singlei = (LdSingleInstruction)instruction;  	stack.Push (new ExpressionStackEntry (new SingleConstantExpression (singlei.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdDouble: {  	var doublei = (LdDoubleInstruction)instruction;  	stack.Push (new ExpressionStackEntry (new DoubleConstantExpression (doublei.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdString: {  	var stringi = (LdStringInstruction)instruction;  	stack.Push (new ExpressionStackEntry (new StringConstantExpression (stringi.Value)' BottomE));  	return true;  }  case InstructionFlavor.Arith: {  	var arithi = (ArithInstruction)instruction;  	switch (arithi.Op) {  	case ArithOp.Div:  	case ArithOp.Rem:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new BinaryExpression (a [0]' ArithOpToBinaryOp (arithi.Op)' a [1]' arithi.WithOverflow' arithi.IsUnsigned)' e.Lub (ThrowsE)));  	case ArithOp.Add:  	case ArithOp.Sub:  	case ArithOp.Mul:  	case ArithOp.BitAnd:  	case ArithOp.BitOr:  	case ArithOp.BitXor:  	case ArithOp.Shl:  	case ArithOp.Shr:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new BinaryExpression (a [0]' ArithOpToBinaryOp (arithi.Op)' a [1]' arithi.WithOverflow' arithi.IsUnsigned)' e.Lub (arithi.WithOverflow ? ThrowsE : BottomE)));  	case ArithOp.Neg:  	case ArithOp.BitNot:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' ArithOpToUnaryOp (arithi.Op)' arithi.WithOverflow' arithi.IsUnsigned)' e));  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Conv: {  	var convi = (ConvInstruction)instruction;  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ConvertExpression (a [0]' new NamedTypeRef (compEnv.Global.NumberFlavorToQualifiedTypeName [convi.TargetNumberFlavor])' convi.WithOverflow' convi.IsSourceUnsigned)' e.Lub (convi.WithOverflow ? ThrowsE : BottomE)));  }  case InstructionFlavor.Try: {  	if (stack.Depth > 0)  		throw new InvalidOperationException ("stack must be empty on entry to try block");  	var tryi = (TryInstruction)instruction;  	var tryStatements = BlockToTryFaultFinallyStatements (tryi.Body);  	if (tryStatements == null)  		return false;  	var handlers = TranslateHandlers (tryi.Handlers);  	if (handlers == null)  		return false;  	if (statements == null)  		return Failed (false' "try");  	statements.Add (new TryStatement (tryStatements' handlers));  	return true;  }  case InstructionFlavor.IfThenElsePseudo: {  	var itei = (IfThenElseInstruction)instruction;  	var isExpr = default(bool);  	// If outer context is re-translating as statements instead of expression' jump directly  	// to appropriate translation for this instruction  	var couldBeExpression = !instructionTranslationStyleCache.TryGetValue (itei.Offset' out isExpr) || isExpr;  	if (!TranslateBlock (statements' itei.Condition' stack' exid))  		return false;  	if (couldBeExpression && itei.Else != null) {  		// Pass 1: Try to tranlate to an if-then-else expression. Will only work if Then and Else don't  		//         reach into current stack' push exactly one value' and don't need to emit any  		//         statements along the way.  		var thenEntry = BlockToExpression (itei.Then' exid);  		if (thenEntry != null) {  			var elseEntry = BlockToExpression (itei.Else' exid);  			if (elseEntry != null) {  				if (!instructionTranslationStyleCache.ContainsKey (itei.Offset))  					instructionTranslationStyleCache.Add (itei.Offset' true);  				return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new IfThenElseExpression (a [0]' thenEntry.Expression' elseEntry.Expression)' e.Lub (thenEntry.Effects.Lub (elseEntry.Effects))));  			}  			// else: fallthrough  		}  		// else: fallthrough  	}  	// else: fallthrough  	// Pass 2: Translate to a statement  	var noStackChange = itei.Then.NoStackChange && (itei.Else == null || itei.Else.NoStackChange);  	var condEntry = noStackChange ? stack.Pop () : stack.FlushAndPopPostState (statements' itei.Then.BeforeState);  	if (condEntry == null)  		return false;  	var thenStmnts = noStackChange ? BlockToStatementsEmptyStack (itei.Then' exid) : BlockToStatements (itei.Then' exid);  	if (thenStmnts == null)  		return false;  	var elseStmnts = default(Seq<Statement>);  	if (itei.Else != null) {  		elseStmnts = noStackChange ? BlockToStatementsEmptyStack (itei.Else' exid) : BlockToStatements (itei.Else' exid);  		if (elseStmnts == null)  			return false;  	}  	if (statements == null)  		return Failed (false' "if-then-else");  	statements.Add (new IfThenElseStatement (condEntry.Expression' new Statements (thenStmnts)' elseStmnts == null ? null : new Statements (elseStmnts)));  	if (!noStackChange && !stack.Restore (itei.AfterState' 0))  		return false;  	if (!instructionTranslationStyleCache.ContainsKey (itei.Offset))  		instructionTranslationStyleCache.Add (itei.Offset' false);  	return true;  }  case InstructionFlavor.ShortCircuitingPseudo: {  	var sci = (ShortCircuitingInstruction)instruction;  	var isExpr = default(bool);  	// If outer context is re-translating as statements instead of expression' jump directly  	// to appropriate translation for this instruction  	var couldBeExpression = !instructionTranslationStyleCache.TryGetValue (sci.Offset' out isExpr) || isExpr;  	if (couldBeExpression) {  		// Pass 1: Try to translate to an expression.  		var leftEntry = BlockToExpression (sci.Left' exid);  		if (leftEntry != null) {  			var rightEntry = BlockToExpression (sci.Right' exid);  			if (rightEntry != null) {  				stack.Push (new ExpressionStackEntry (new BinaryExpression (leftEntry.Expression' ShortCircuitingOpToBinaryOp (sci.Op)' rightEntry.Expression' false' false)' leftEntry.Effects.Lub (rightEntry.Effects)));  				if (!instructionTranslationStyleCache.ContainsKey (sci.Offset))  					instructionTranslationStyleCache.Add (sci.Offset' true);  				return true;  			}  			// else: fallthrough  		}  		// else: fallthrough  	}  	// else: fallthrough  	// Pass 2: Translate to a statement  	if (!TranslateBlock (statements' sci.Left' stack' exid))  		return false;  	var leftEntry2 = stack.FlushAndPopPostState (statements' sci.Right.BeforeState);  	if (leftEntry2 == null)  		return false;  	var rightStatements = BlockToStatements (sci.Right' exid);  	if (rightStatements == null)  		return false;  	var id = sci.Right.AfterState.PeekId (0' nameSupply.GenSym);  	var cell = new VariableCell (id);  	compEnv.AddVariable (id' ArgLocal.Local' false' true' compEnv.SubstituteType (sci.Right.AfterState.PeekType (0)));  	if (statements == null)  		return Failed (false' "short-circuit");  	switch (sci.Op) {  	case ShortCircuitingOp.And:  		statements.Add (new IfThenElseStatement (leftEntry2.Expression' new Statements (rightStatements)' new Statements (new ExpressionStatement (cell.Write (new Int32ConstantExpression (0))))));  		break;  	case ShortCircuitingOp.Or:  		statements.Add (new IfThenElseStatement (leftEntry2.Expression' new Statements (new ExpressionStatement (cell.Write (new Int32ConstantExpression (1))))' new Statements (rightStatements)));  		break;  	default:  		throw new ArgumentOutOfRangeException ();  	}  	if (!stack.Restore (sci.AfterState' 1))  		return false;  	stack.Push (new ExpressionStackEntry (cell.Read ()' BottomE));  	if (!instructionTranslationStyleCache.ContainsKey (sci.Offset))  		instructionTranslationStyleCache.Add (sci.Offset' false);  	return true;  }  case InstructionFlavor.StructuralSwitchPseudo: {  	var ssi = (StructuralSwitchInstruction)instruction;  	if (!TranslateBlock (statements' ssi.Body' stack' exid))  		return false;  	var valueEntry = stack.FlushAndPopPreState (statements' ssi.Body.AfterState);  	if (valueEntry == null)  		return false;  	var cases = new Seq<SwitchStatementCase> ();  	foreach (var c in ssi.Cases) {  		var caseStatements = BlockToStatements (c.Body' exid);  		if (caseStatements == null)  			return false;  		cases.Add (new SwitchStatementCase (c.Values' new Statements (caseStatements)));  	}  	if (statements == null)  		return Failed (false' "structural switch");  	statements.Add (new SwitchStatement (valueEntry.Expression' cases));  	if (!stack.Restore (ssi.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.LoopPseudo: {  	var li = (LoopInstruction)instruction;  	if (!stack.Flush (statements' li.Body.BeforeState))  		return false;  	if (statements == null)  		return Failed (false' "loop");  	var whileStatements = BlockToStatements (li.Body' exid);  	statements.Add (new WhileDoStatement (new Int32ConstantExpression (1)' new Statements (whileStatements)));  	if (!stack.Restore (li.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.WhileDoPseudo: {  	var wdi = (WhileDoInstruction)instruction;  	if (!stack.Flush (statements' wdi.Condition.BeforeState))  		return false;  	var condEntry = BlockToExpression (wdi.Condition' exid);  	if (condEntry == null) {  		var stack1 = new ExpressionStack (compEnv' BottomE' nameSupply.GenSym' wdi.Condition.BeforeState' trace);  		var preCondStatements = new Seq<Statement> ();  		if (!TranslateBlock (preCondStatements' wdi.Condition' stack1' exid))  			return false;  		condEntry = stack1.FlushAndPopPostState (preCondStatements' wdi.Body.BeforeState);  		if (condEntry == null)  			return false;  		var stack2 = new ExpressionStack (compEnv' BottomE' nameSupply.GenSym' wdi.Body.BeforeState' trace);  		var postCondStatements = new Seq<Statement> ();  		if (!TranslateBlock (postCondStatements' wdi.Body' stack2' exid))  			return false;  		if (!stack2.Flush (postCondStatements' wdi.Body.AfterState))  			return false;  		preCondStatements.Add (new IfThenElseStatement (condEntry.Expression' new Statements (postCondStatements)' new Statements (new BreakStatement ())));  		statements.Add (new WhileDoStatement (new Int32ConstantExpression (1)' new Statements (preCondStatements)));  	}  	else {  		var loopStatements = BlockToStatements (wdi.Body' exid);  		if (loopStatements == null)  			return false;  		if (statements == null)  			return Failed (false' "while-do");  		statements.Add (new WhileDoStatement (condEntry.Expression' new Statements (loopStatements)));  	}  	if (!stack.Restore (wdi.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.DoWhilePseudo: {  	var dwi = (DoWhileInstruction)instruction;  	if (!stack.Flush (statements' dwi.Body.BeforeState))  		return false;  	var combined = new Seq<Instruction> ();  	foreach (var i in dwi.Body.Body)  		combined.Add (i);  	foreach (var i in dwi.Condition.Body)  		combined.Add (i);  	var condEntry = default(ExpressionStackEntry);  	var loopStatements = BlockToConditionStatements (new Instructions (null' combined)' dwi.Body.BeforeState' exid' out condEntry);  	if (loopStatements == null)  		return false;  	if (statements == null)  		return Failed (false' "do-while");  	statements.Add (new DoWhileStatement (new Statements (loopStatements)' condEntry.Expression));  	if (!stack.Restore (dwi.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.LoopControlPseudo: {  	var lci = (BreakContinueInstruction)instruction;  	if (!stack.Flush (statements' lci.BeforeState))  		return false;  	if (statements == null)  		return Failed (false' "loop-control");  	var targetState = default(int);  	switch (lci.Op) {  	case BreakContinueOp.Break:  		if (labelToLoopCandidateBreakState != null && labelToLoopCandidateBreakState.TryGetValue (lci.Label' out targetState))  			statements.Add (new GotoPseudoStatement (stateId' targetState));  		else  			statements.Add (new BreakStatement (lci.Label));  		break;  	case BreakContinueOp.Continue:  		if (labelToLoopCandidateContinueState != null && labelToLoopCandidateContinueState.TryGetValue (lci.Label' out targetState))  			statements.Add (new GotoPseudoStatement (stateId' targetState));  		else  			statements.Add (new ContinueStatement (lci.Label));  		break;  	default:  		throw new ArgumentOutOfRangeException ();  	}  	return true;  }  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (instruction.Flavor) {  case InstructionFlavor.Unsupported:  	throw new InvalidOperationException ("unsupported opcode");  case InstructionFlavor.Misc: {  	var misci = (MiscInstruction)instruction;  	switch (misci.Op) {  	case MiscOp.Nop:  	case MiscOp.Break:  		return true;  	case MiscOp.Dup:  		return stack.Dup (statements);  	case MiscOp.Pop:  		return stack.PopAndDiscard (statements);  	case MiscOp.Ldnull:  		stack.Push (new ExpressionStackEntry (new NullConstantExpression ()' BottomE));  		return true;  	case MiscOp.Ckfinite:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' UnaryOp.CheckFinite' false' false)' e.Lub (ThrowsE)));  	case MiscOp.Throw:  		if (!stack.DiscardAll (statements' 1))  			return false;  		if (!stack.PopEvalSE (statements' 1' true' ThrowsE' (s' a) => s.Add (new ThrowStatement (a [0]))))  			return false;  		return true;  	case MiscOp.Rethrow:  		if (!stack.DiscardAll (statements' 0))  			return false;  		if (statements == null)  			return Failed (false' "rethrow");  		if (exid == null)  			throw new InvalidOperationException ("rethrow outside of catch");  		statements.Add (new RethrowStatement (new VariableCell (exid).Read ()));  		return true;  	case MiscOp.LdindRef:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ReadExpression (a [0]).CloneIfStruct (compEnv)' e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ())));  	case MiscOp.LdelemRef:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' true).Read ().CloneIfStruct (compEnv)' e.Lub (ReadHeapOrThrowE)));  	case MiscOp.Ldlen:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' UnaryOp.Length' false' false)' e.Lub (ReadHeapOrThrowE)));  	case MiscOp.StindRef:  		return stack.PopEvalSE (statements' 2' true' instruction.BeforeState.PeekPointsTo (1).WriteEffect ()' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' a [1]))));  	case MiscOp.StelemRef:  		return stack.PopEvalSE (statements' 3' true' WriteHeapOrThrowE' (s' a) => s.Add (new ExpressionStatement (new ElementCell (a [0]' a [1]' false).Write (a [2]))));  	case MiscOp.Ret:  		if (statements == null)  			return Failed (false' "return");  		statements.Add (new ReturnStatement (null));  		return true;  	case MiscOp.RetVal:  		return stack.PopEvalSE (statements' 1' true' BottomE' (s' a) => s.Add (new ReturnStatement (a [0])));  	case MiscOp.Endfilter:  	case MiscOp.Endfinally:  		throw new InvalidOperationException ("endfilter/endfinally instructions should have been removed");  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Branch:  case InstructionFlavor.Switch:  	throw new InvalidOperationException ("branch/switch instructions should have been removed");  case InstructionFlavor.Compare: {  	var cmpi = (CompareInstruction)instruction;  	if (cmpi.Op == CompareOp.CtruePseudo || cmpi.Op == CompareOp.CfalsePseudo) {  		var s = cmpi.Type.Style (compEnv);  		var unop = default(UnaryOp);  		if (s is NumberTypeStyle)  			unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonZero : UnaryOp.IsZero;  		else  			unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonNull : UnaryOp.IsNull;  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' unop' false' cmpi.IsUnsigned)' e));  	}  	else {  		var binop = default(BinaryOp);  		switch (cmpi.Op) {  		case CompareOp.Ceq:  			binop = BinaryOp.Eq;  			break;  		case CompareOp.Clt:  			binop = BinaryOp.Lt;  			break;  		case CompareOp.Cgt:  			binop = BinaryOp.Gt;  			break;  		case CompareOp.CgePseudo:  			binop = BinaryOp.Ge;  			break;  		case CompareOp.ClePseudo:  			binop = BinaryOp.Le;  			break;  		case CompareOp.CnePseudo:  			binop = BinaryOp.Ne;  			break;  		case CompareOp.CtruePseudo:  		case CompareOp.CfalsePseudo:  			// handled above  			throw new InvalidOperationException ();  		default:  			throw new ArgumentOutOfRangeException ();  		}  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new BinaryExpression (a [0]' binop' a [1]' false' cmpi.IsUnsigned)' e));  	}  }  case InstructionFlavor.ArgLocal: {  	var sli = (ArgLocalInstruction)instruction;  	var id = default(JST.Identifier);  	switch (sli.ArgLocal) {  	case ArgLocal.Arg:  		id = compEnv.ValueParameterIds [sli.Index];  		break;  	case ArgLocal.Local:  		id = compEnv.LocalIds [sli.Index];  		break;  	default:  		throw new ArgumentOutOfRangeException ();  	}  	var cell = new VariableCell (id);  	switch (sli.Op) {  	case ArgLocalOp.Ld:  		stack.Push (new ExpressionStackEntry (cell.Read ().CloneIfStruct (compEnv)' ReadArgLocalE (sli.ArgLocal' sli.Index)));  		return true;  	case ArgLocalOp.Lda:  		// Effect will be accounted for on reads/writes  		stack.Push (new ExpressionStackEntry (cell.AddressOf ()' BottomE));  		return true;  	case ArgLocalOp.St:  		return stack.PopEvalSE (statements' 1' true' WriteArgLocalE (sli.ArgLocal' sli.Index)' (s' a) => s.Add (new ExpressionStatement (cell.Write (a [0]))));  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Field: {  	var fieldi = (FieldInstruction)instruction;  	switch (fieldi.Op) {  	case FieldOp.Ldfld:  		if (fieldi.IsStatic) {  			stack.Push (new ExpressionStackEntry (new FieldCell (null' compEnv.SubstituteMember (fieldi.Field)).Read ().CloneIfStruct (compEnv)' ReadHeapE));  			return true;  		}  		else  			return stack.PopEvalPush (statements' 1' true' (a' e) =>  {  				var readEffect = default(Effects);  				var obj = default(Expression);  				if (fieldi.IsViaPointer.Value) {  					readEffect = e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ());  					obj = new ReadExpression (a [0]);  					// no need for clone  				}  				else if (fieldi.Field.DefiningType.Style (compEnv) is ValueTypeStyle) {  					readEffect = e;  					obj = a [0];  				}  				else {  					// Object could be null  					readEffect = e.Lub (ReadHeapOrThrowE);  					obj = a [0];  				}  				return new ExpressionStackEntry (new FieldCell (obj' compEnv.SubstituteMember (fieldi.Field)).Read ().CloneIfStruct (compEnv)' readEffect);  			});  	case FieldOp.Ldflda:  		if (fieldi.IsStatic) {  			// Effect will be accounted for on reads/writes  			stack.Push (new ExpressionStackEntry (new FieldCell (null' compEnv.SubstituteMember (fieldi.Field)).AddressOf ()' BottomE));  			return true;  		}  		else  			return stack.PopEvalPush (statements' 1' true' (a' e) =>  {  				if (fieldi.IsViaPointer.Value)  					// We're just adding an offset to a pointer' so effect will  					// be accounted for when the final pointer is read/written  					return new ExpressionStackEntry (new FieldCell (new ReadExpression (a [0])' compEnv.SubstituteMember (fieldi.Field)).AddressOf ()' e);  				else  					// Must be a reference type' and ref could be null  					return new ExpressionStackEntry (new FieldCell (a [0]' compEnv.SubstituteMember (fieldi.Field)).AddressOf ()' e.Lub (ThrowsE));  			});  	case FieldOp.Stfld:  		if (fieldi.IsStatic)  			return stack.PopEvalSE (statements' 1' true' WriteHeapE' (s' a) => s.Add (new ExpressionStatement (new FieldCell (null' compEnv.SubstituteMember (fieldi.Field)).Write (a [0]))));  		else {  			var writeEffect = fieldi.IsViaPointer.Value ? instruction.BeforeState.PeekPointsTo (1).WriteEffect () : WriteHeapOrThrowE;  			return stack.PopEvalSE (statements' 2' true' writeEffect' (s' a) =>  {  				var obj = fieldi.IsViaPointer.Value ? new ReadExpression (a [0]) : a [0];  				s.Add (new ExpressionStatement (new FieldCell (obj' compEnv.SubstituteMember (fieldi.Field)).Write (a [1])));  			});  		}  	case FieldOp.Ldtoken:  		stack.Push (new ExpressionStackEntry (new FieldHandleConstantExpression (compEnv.SubstituteMember (fieldi.Field))' BottomE));  		return true;  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Method: {  	var methodi = (MethodInstruction)instruction;  	var arity = methodi.Method.ValueParameters.Count;  	switch (methodi.Op) {  	case MethodOp.Ldftn:  		if (methodi.IsVirtual)  			// Object could be null  			return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new CodePointerExpression (a [0]' compEnv.SubstituteMember (methodi.Method))' e.Lub (ReadHeapOrThrowE)));  		else {  			stack.Push (new ExpressionStackEntry (new CodePointerExpression (null' compEnv.SubstituteMember (methodi.Method))' BottomE));  			return true;  		}  	case MethodOp.Call:  		if (methodi.Method.Result == null)  			return stack.PopEvalSE (statements' arity' true' CalleeEffects (methodi.BeforeState' arity)' (s' a) => s.Add (new ExpressionStatement (new CallExpression (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal' compEnv.SubstituteMember (methodi.Method)' CallerArguments (methodi.Constrained' methodi.Method' a)))));  		else  			return stack.PopEvalPush (statements' arity' true' (a' e) => new ExpressionStackEntry (new CallExpression (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal' compEnv.SubstituteMember (methodi.Method)' CallerArguments (methodi.Constrained' methodi.Method' a))' e.Lub (CalleeEffects (methodi.BeforeState' arity))));  	case MethodOp.Newobj:  		arity--;  		return stack.PopEvalPush (statements' arity' true' (a' e) => new ExpressionStackEntry (new NewObjectExpression (compEnv.SubstituteMember (methodi.Method)' CallerArguments (null' methodi.Method' a))' e.Lub (CalleeEffects (methodi.BeforeState' arity))));  	case MethodOp.Ldtoken:  		stack.Push (new ExpressionStackEntry (new MethodHandleConstantExpression (compEnv.SubstituteMember (methodi.Method))' BottomE));  		return true;  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Type: {  	var typei = (TypeInstruction)instruction;  	switch (typei.Op) {  	case TypeOp.Ldobj:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ReadExpression (a [0]).CloneIfStruct (compEnv)' e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ())));  	case TypeOp.Stobj:  		return stack.PopEvalSE (statements' 2' true' instruction.BeforeState.PeekPointsTo (1).WriteEffect ()' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' a [1]))));  	case TypeOp.Cpobj: {  		var copyEffect = instruction.BeforeState.PeekPointsTo (0).ReadEffect ().Lub (instruction.BeforeState.PeekPointsTo (1).WriteEffect ());  		return stack.PopEvalSE (statements' 2' true' copyEffect' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' new ReadExpression (a [1]).CloneIfStruct (compEnv)))));  	}  	case TypeOp.Newarr:  		// Growing the heap is not considered an observable change. But will throw if  		// length < 0  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new NewArrayExpression (a [0]' compEnv.SubstituteType (typei.Type))' e.Lub (ThrowsE)));  	case TypeOp.Initobj:  		return stack.PopEvalSE (statements' 1' true' WriteHeapE' (s' a) => s.Add (new InitializeObjectStatement (a [0])));  	case TypeOp.Castclass:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new CastExpression (a [0]' compEnv.SubstituteType (typei.Type))' e.Lub (ThrowsE)));  	case TypeOp.Isinst:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new IsInstExpression (a [0]' compEnv.SubstituteType (typei.Type))' e));  	case TypeOp.Box:  		// Growing the heap is not considered an observable change  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new NewBoxExpression (a [0]' compEnv.SubstituteType (typei.Type))' e));  	case TypeOp.Unbox:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new BoxCell (a [0]' compEnv.SubstituteType (typei.Type)).AddressOf ()' e.Lub (ThrowsE)));  	case TypeOp.UnboxAny:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new BoxCell (a [0]' compEnv.SubstituteType (typei.Type)).Read ().CloneIfStruct (compEnv)' e.Lub (ThrowsE)));  	case TypeOp.Ldtoken:  		stack.Push (new ExpressionStackEntry (new TypeHandleConstantExpression (compEnv.SubstituteType (typei.Type))' BottomE));  		return true;  	case TypeOp.Ldelem:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' true).Read ().CloneIfStruct (compEnv)' e.Lub (ReadHeapOrThrowE)));  	case TypeOp.Stelem:  		return stack.PopEvalSE (statements' 3' true' WriteHeapOrThrowE' (s' a) => s.Add (new ExpressionStatement (new ElementCell (a [0]' a [1]' false).Write (a [2]))));  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.LdElemAddr:  	// Calculating the pointer may throw if index is out of range.  	// Remaining effect will be accounted for when pointer is read/written.  	return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' false).AddressOf ()' e.Lub (ThrowsE)));  case InstructionFlavor.LdInt32: {  	var int32i = (LdInt32Instruction)instruction;  	stack.Push (new ExpressionStackEntry (new Int32ConstantExpression (int32i.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdInt64: {  	var int64i = (LdInt64Instruction)instruction;  	stack.Push (new ExpressionStackEntry (new Int64ConstantExpression (int64i.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdSingle: {  	var singlei = (LdSingleInstruction)instruction;  	stack.Push (new ExpressionStackEntry (new SingleConstantExpression (singlei.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdDouble: {  	var doublei = (LdDoubleInstruction)instruction;  	stack.Push (new ExpressionStackEntry (new DoubleConstantExpression (doublei.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdString: {  	var stringi = (LdStringInstruction)instruction;  	stack.Push (new ExpressionStackEntry (new StringConstantExpression (stringi.Value)' BottomE));  	return true;  }  case InstructionFlavor.Arith: {  	var arithi = (ArithInstruction)instruction;  	switch (arithi.Op) {  	case ArithOp.Div:  	case ArithOp.Rem:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new BinaryExpression (a [0]' ArithOpToBinaryOp (arithi.Op)' a [1]' arithi.WithOverflow' arithi.IsUnsigned)' e.Lub (ThrowsE)));  	case ArithOp.Add:  	case ArithOp.Sub:  	case ArithOp.Mul:  	case ArithOp.BitAnd:  	case ArithOp.BitOr:  	case ArithOp.BitXor:  	case ArithOp.Shl:  	case ArithOp.Shr:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new BinaryExpression (a [0]' ArithOpToBinaryOp (arithi.Op)' a [1]' arithi.WithOverflow' arithi.IsUnsigned)' e.Lub (arithi.WithOverflow ? ThrowsE : BottomE)));  	case ArithOp.Neg:  	case ArithOp.BitNot:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' ArithOpToUnaryOp (arithi.Op)' arithi.WithOverflow' arithi.IsUnsigned)' e));  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Conv: {  	var convi = (ConvInstruction)instruction;  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ConvertExpression (a [0]' new NamedTypeRef (compEnv.Global.NumberFlavorToQualifiedTypeName [convi.TargetNumberFlavor])' convi.WithOverflow' convi.IsSourceUnsigned)' e.Lub (convi.WithOverflow ? ThrowsE : BottomE)));  }  case InstructionFlavor.Try: {  	if (stack.Depth > 0)  		throw new InvalidOperationException ("stack must be empty on entry to try block");  	var tryi = (TryInstruction)instruction;  	var tryStatements = BlockToTryFaultFinallyStatements (tryi.Body);  	if (tryStatements == null)  		return false;  	var handlers = TranslateHandlers (tryi.Handlers);  	if (handlers == null)  		return false;  	if (statements == null)  		return Failed (false' "try");  	statements.Add (new TryStatement (tryStatements' handlers));  	return true;  }  case InstructionFlavor.IfThenElsePseudo: {  	var itei = (IfThenElseInstruction)instruction;  	var isExpr = default(bool);  	// If outer context is re-translating as statements instead of expression' jump directly  	// to appropriate translation for this instruction  	var couldBeExpression = !instructionTranslationStyleCache.TryGetValue (itei.Offset' out isExpr) || isExpr;  	if (!TranslateBlock (statements' itei.Condition' stack' exid))  		return false;  	if (couldBeExpression && itei.Else != null) {  		// Pass 1: Try to tranlate to an if-then-else expression. Will only work if Then and Else don't  		//         reach into current stack' push exactly one value' and don't need to emit any  		//         statements along the way.  		var thenEntry = BlockToExpression (itei.Then' exid);  		if (thenEntry != null) {  			var elseEntry = BlockToExpression (itei.Else' exid);  			if (elseEntry != null) {  				if (!instructionTranslationStyleCache.ContainsKey (itei.Offset))  					instructionTranslationStyleCache.Add (itei.Offset' true);  				return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new IfThenElseExpression (a [0]' thenEntry.Expression' elseEntry.Expression)' e.Lub (thenEntry.Effects.Lub (elseEntry.Effects))));  			}  			// else: fallthrough  		}  		// else: fallthrough  	}  	// else: fallthrough  	// Pass 2: Translate to a statement  	var noStackChange = itei.Then.NoStackChange && (itei.Else == null || itei.Else.NoStackChange);  	var condEntry = noStackChange ? stack.Pop () : stack.FlushAndPopPostState (statements' itei.Then.BeforeState);  	if (condEntry == null)  		return false;  	var thenStmnts = noStackChange ? BlockToStatementsEmptyStack (itei.Then' exid) : BlockToStatements (itei.Then' exid);  	if (thenStmnts == null)  		return false;  	var elseStmnts = default(Seq<Statement>);  	if (itei.Else != null) {  		elseStmnts = noStackChange ? BlockToStatementsEmptyStack (itei.Else' exid) : BlockToStatements (itei.Else' exid);  		if (elseStmnts == null)  			return false;  	}  	if (statements == null)  		return Failed (false' "if-then-else");  	statements.Add (new IfThenElseStatement (condEntry.Expression' new Statements (thenStmnts)' elseStmnts == null ? null : new Statements (elseStmnts)));  	if (!noStackChange && !stack.Restore (itei.AfterState' 0))  		return false;  	if (!instructionTranslationStyleCache.ContainsKey (itei.Offset))  		instructionTranslationStyleCache.Add (itei.Offset' false);  	return true;  }  case InstructionFlavor.ShortCircuitingPseudo: {  	var sci = (ShortCircuitingInstruction)instruction;  	var isExpr = default(bool);  	// If outer context is re-translating as statements instead of expression' jump directly  	// to appropriate translation for this instruction  	var couldBeExpression = !instructionTranslationStyleCache.TryGetValue (sci.Offset' out isExpr) || isExpr;  	if (couldBeExpression) {  		// Pass 1: Try to translate to an expression.  		var leftEntry = BlockToExpression (sci.Left' exid);  		if (leftEntry != null) {  			var rightEntry = BlockToExpression (sci.Right' exid);  			if (rightEntry != null) {  				stack.Push (new ExpressionStackEntry (new BinaryExpression (leftEntry.Expression' ShortCircuitingOpToBinaryOp (sci.Op)' rightEntry.Expression' false' false)' leftEntry.Effects.Lub (rightEntry.Effects)));  				if (!instructionTranslationStyleCache.ContainsKey (sci.Offset))  					instructionTranslationStyleCache.Add (sci.Offset' true);  				return true;  			}  			// else: fallthrough  		}  		// else: fallthrough  	}  	// else: fallthrough  	// Pass 2: Translate to a statement  	if (!TranslateBlock (statements' sci.Left' stack' exid))  		return false;  	var leftEntry2 = stack.FlushAndPopPostState (statements' sci.Right.BeforeState);  	if (leftEntry2 == null)  		return false;  	var rightStatements = BlockToStatements (sci.Right' exid);  	if (rightStatements == null)  		return false;  	var id = sci.Right.AfterState.PeekId (0' nameSupply.GenSym);  	var cell = new VariableCell (id);  	compEnv.AddVariable (id' ArgLocal.Local' false' true' compEnv.SubstituteType (sci.Right.AfterState.PeekType (0)));  	if (statements == null)  		return Failed (false' "short-circuit");  	switch (sci.Op) {  	case ShortCircuitingOp.And:  		statements.Add (new IfThenElseStatement (leftEntry2.Expression' new Statements (rightStatements)' new Statements (new ExpressionStatement (cell.Write (new Int32ConstantExpression (0))))));  		break;  	case ShortCircuitingOp.Or:  		statements.Add (new IfThenElseStatement (leftEntry2.Expression' new Statements (new ExpressionStatement (cell.Write (new Int32ConstantExpression (1))))' new Statements (rightStatements)));  		break;  	default:  		throw new ArgumentOutOfRangeException ();  	}  	if (!stack.Restore (sci.AfterState' 1))  		return false;  	stack.Push (new ExpressionStackEntry (cell.Read ()' BottomE));  	if (!instructionTranslationStyleCache.ContainsKey (sci.Offset))  		instructionTranslationStyleCache.Add (sci.Offset' false);  	return true;  }  case InstructionFlavor.StructuralSwitchPseudo: {  	var ssi = (StructuralSwitchInstruction)instruction;  	if (!TranslateBlock (statements' ssi.Body' stack' exid))  		return false;  	var valueEntry = stack.FlushAndPopPreState (statements' ssi.Body.AfterState);  	if (valueEntry == null)  		return false;  	var cases = new Seq<SwitchStatementCase> ();  	foreach (var c in ssi.Cases) {  		var caseStatements = BlockToStatements (c.Body' exid);  		if (caseStatements == null)  			return false;  		cases.Add (new SwitchStatementCase (c.Values' new Statements (caseStatements)));  	}  	if (statements == null)  		return Failed (false' "structural switch");  	statements.Add (new SwitchStatement (valueEntry.Expression' cases));  	if (!stack.Restore (ssi.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.LoopPseudo: {  	var li = (LoopInstruction)instruction;  	if (!stack.Flush (statements' li.Body.BeforeState))  		return false;  	if (statements == null)  		return Failed (false' "loop");  	var whileStatements = BlockToStatements (li.Body' exid);  	statements.Add (new WhileDoStatement (new Int32ConstantExpression (1)' new Statements (whileStatements)));  	if (!stack.Restore (li.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.WhileDoPseudo: {  	var wdi = (WhileDoInstruction)instruction;  	if (!stack.Flush (statements' wdi.Condition.BeforeState))  		return false;  	var condEntry = BlockToExpression (wdi.Condition' exid);  	if (condEntry == null) {  		var stack1 = new ExpressionStack (compEnv' BottomE' nameSupply.GenSym' wdi.Condition.BeforeState' trace);  		var preCondStatements = new Seq<Statement> ();  		if (!TranslateBlock (preCondStatements' wdi.Condition' stack1' exid))  			return false;  		condEntry = stack1.FlushAndPopPostState (preCondStatements' wdi.Body.BeforeState);  		if (condEntry == null)  			return false;  		var stack2 = new ExpressionStack (compEnv' BottomE' nameSupply.GenSym' wdi.Body.BeforeState' trace);  		var postCondStatements = new Seq<Statement> ();  		if (!TranslateBlock (postCondStatements' wdi.Body' stack2' exid))  			return false;  		if (!stack2.Flush (postCondStatements' wdi.Body.AfterState))  			return false;  		preCondStatements.Add (new IfThenElseStatement (condEntry.Expression' new Statements (postCondStatements)' new Statements (new BreakStatement ())));  		statements.Add (new WhileDoStatement (new Int32ConstantExpression (1)' new Statements (preCondStatements)));  	}  	else {  		var loopStatements = BlockToStatements (wdi.Body' exid);  		if (loopStatements == null)  			return false;  		if (statements == null)  			return Failed (false' "while-do");  		statements.Add (new WhileDoStatement (condEntry.Expression' new Statements (loopStatements)));  	}  	if (!stack.Restore (wdi.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.DoWhilePseudo: {  	var dwi = (DoWhileInstruction)instruction;  	if (!stack.Flush (statements' dwi.Body.BeforeState))  		return false;  	var combined = new Seq<Instruction> ();  	foreach (var i in dwi.Body.Body)  		combined.Add (i);  	foreach (var i in dwi.Condition.Body)  		combined.Add (i);  	var condEntry = default(ExpressionStackEntry);  	var loopStatements = BlockToConditionStatements (new Instructions (null' combined)' dwi.Body.BeforeState' exid' out condEntry);  	if (loopStatements == null)  		return false;  	if (statements == null)  		return Failed (false' "do-while");  	statements.Add (new DoWhileStatement (new Statements (loopStatements)' condEntry.Expression));  	if (!stack.Restore (dwi.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.LoopControlPseudo: {  	var lci = (BreakContinueInstruction)instruction;  	if (!stack.Flush (statements' lci.BeforeState))  		return false;  	if (statements == null)  		return Failed (false' "loop-control");  	var targetState = default(int);  	switch (lci.Op) {  	case BreakContinueOp.Break:  		if (labelToLoopCandidateBreakState != null && labelToLoopCandidateBreakState.TryGetValue (lci.Label' out targetState))  			statements.Add (new GotoPseudoStatement (stateId' targetState));  		else  			statements.Add (new BreakStatement (lci.Label));  		break;  	case BreakContinueOp.Continue:  		if (labelToLoopCandidateContinueState != null && labelToLoopCandidateContinueState.TryGetValue (lci.Label' out targetState))  			statements.Add (new GotoPseudoStatement (stateId' targetState));  		else  			statements.Add (new ContinueStatement (lci.Label));  		break;  	default:  		throw new ArgumentOutOfRangeException ();  	}  	return true;  }  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (instruction.Flavor) {  case InstructionFlavor.Unsupported:  	throw new InvalidOperationException ("unsupported opcode");  case InstructionFlavor.Misc: {  	var misci = (MiscInstruction)instruction;  	switch (misci.Op) {  	case MiscOp.Nop:  	case MiscOp.Break:  		return true;  	case MiscOp.Dup:  		return stack.Dup (statements);  	case MiscOp.Pop:  		return stack.PopAndDiscard (statements);  	case MiscOp.Ldnull:  		stack.Push (new ExpressionStackEntry (new NullConstantExpression ()' BottomE));  		return true;  	case MiscOp.Ckfinite:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' UnaryOp.CheckFinite' false' false)' e.Lub (ThrowsE)));  	case MiscOp.Throw:  		if (!stack.DiscardAll (statements' 1))  			return false;  		if (!stack.PopEvalSE (statements' 1' true' ThrowsE' (s' a) => s.Add (new ThrowStatement (a [0]))))  			return false;  		return true;  	case MiscOp.Rethrow:  		if (!stack.DiscardAll (statements' 0))  			return false;  		if (statements == null)  			return Failed (false' "rethrow");  		if (exid == null)  			throw new InvalidOperationException ("rethrow outside of catch");  		statements.Add (new RethrowStatement (new VariableCell (exid).Read ()));  		return true;  	case MiscOp.LdindRef:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ReadExpression (a [0]).CloneIfStruct (compEnv)' e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ())));  	case MiscOp.LdelemRef:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' true).Read ().CloneIfStruct (compEnv)' e.Lub (ReadHeapOrThrowE)));  	case MiscOp.Ldlen:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' UnaryOp.Length' false' false)' e.Lub (ReadHeapOrThrowE)));  	case MiscOp.StindRef:  		return stack.PopEvalSE (statements' 2' true' instruction.BeforeState.PeekPointsTo (1).WriteEffect ()' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' a [1]))));  	case MiscOp.StelemRef:  		return stack.PopEvalSE (statements' 3' true' WriteHeapOrThrowE' (s' a) => s.Add (new ExpressionStatement (new ElementCell (a [0]' a [1]' false).Write (a [2]))));  	case MiscOp.Ret:  		if (statements == null)  			return Failed (false' "return");  		statements.Add (new ReturnStatement (null));  		return true;  	case MiscOp.RetVal:  		return stack.PopEvalSE (statements' 1' true' BottomE' (s' a) => s.Add (new ReturnStatement (a [0])));  	case MiscOp.Endfilter:  	case MiscOp.Endfinally:  		throw new InvalidOperationException ("endfilter/endfinally instructions should have been removed");  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Branch:  case InstructionFlavor.Switch:  	throw new InvalidOperationException ("branch/switch instructions should have been removed");  case InstructionFlavor.Compare: {  	var cmpi = (CompareInstruction)instruction;  	if (cmpi.Op == CompareOp.CtruePseudo || cmpi.Op == CompareOp.CfalsePseudo) {  		var s = cmpi.Type.Style (compEnv);  		var unop = default(UnaryOp);  		if (s is NumberTypeStyle)  			unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonZero : UnaryOp.IsZero;  		else  			unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonNull : UnaryOp.IsNull;  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' unop' false' cmpi.IsUnsigned)' e));  	}  	else {  		var binop = default(BinaryOp);  		switch (cmpi.Op) {  		case CompareOp.Ceq:  			binop = BinaryOp.Eq;  			break;  		case CompareOp.Clt:  			binop = BinaryOp.Lt;  			break;  		case CompareOp.Cgt:  			binop = BinaryOp.Gt;  			break;  		case CompareOp.CgePseudo:  			binop = BinaryOp.Ge;  			break;  		case CompareOp.ClePseudo:  			binop = BinaryOp.Le;  			break;  		case CompareOp.CnePseudo:  			binop = BinaryOp.Ne;  			break;  		case CompareOp.CtruePseudo:  		case CompareOp.CfalsePseudo:  			// handled above  			throw new InvalidOperationException ();  		default:  			throw new ArgumentOutOfRangeException ();  		}  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new BinaryExpression (a [0]' binop' a [1]' false' cmpi.IsUnsigned)' e));  	}  }  case InstructionFlavor.ArgLocal: {  	var sli = (ArgLocalInstruction)instruction;  	var id = default(JST.Identifier);  	switch (sli.ArgLocal) {  	case ArgLocal.Arg:  		id = compEnv.ValueParameterIds [sli.Index];  		break;  	case ArgLocal.Local:  		id = compEnv.LocalIds [sli.Index];  		break;  	default:  		throw new ArgumentOutOfRangeException ();  	}  	var cell = new VariableCell (id);  	switch (sli.Op) {  	case ArgLocalOp.Ld:  		stack.Push (new ExpressionStackEntry (cell.Read ().CloneIfStruct (compEnv)' ReadArgLocalE (sli.ArgLocal' sli.Index)));  		return true;  	case ArgLocalOp.Lda:  		// Effect will be accounted for on reads/writes  		stack.Push (new ExpressionStackEntry (cell.AddressOf ()' BottomE));  		return true;  	case ArgLocalOp.St:  		return stack.PopEvalSE (statements' 1' true' WriteArgLocalE (sli.ArgLocal' sli.Index)' (s' a) => s.Add (new ExpressionStatement (cell.Write (a [0]))));  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Field: {  	var fieldi = (FieldInstruction)instruction;  	switch (fieldi.Op) {  	case FieldOp.Ldfld:  		if (fieldi.IsStatic) {  			stack.Push (new ExpressionStackEntry (new FieldCell (null' compEnv.SubstituteMember (fieldi.Field)).Read ().CloneIfStruct (compEnv)' ReadHeapE));  			return true;  		}  		else  			return stack.PopEvalPush (statements' 1' true' (a' e) =>  {  				var readEffect = default(Effects);  				var obj = default(Expression);  				if (fieldi.IsViaPointer.Value) {  					readEffect = e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ());  					obj = new ReadExpression (a [0]);  					// no need for clone  				}  				else if (fieldi.Field.DefiningType.Style (compEnv) is ValueTypeStyle) {  					readEffect = e;  					obj = a [0];  				}  				else {  					// Object could be null  					readEffect = e.Lub (ReadHeapOrThrowE);  					obj = a [0];  				}  				return new ExpressionStackEntry (new FieldCell (obj' compEnv.SubstituteMember (fieldi.Field)).Read ().CloneIfStruct (compEnv)' readEffect);  			});  	case FieldOp.Ldflda:  		if (fieldi.IsStatic) {  			// Effect will be accounted for on reads/writes  			stack.Push (new ExpressionStackEntry (new FieldCell (null' compEnv.SubstituteMember (fieldi.Field)).AddressOf ()' BottomE));  			return true;  		}  		else  			return stack.PopEvalPush (statements' 1' true' (a' e) =>  {  				if (fieldi.IsViaPointer.Value)  					// We're just adding an offset to a pointer' so effect will  					// be accounted for when the final pointer is read/written  					return new ExpressionStackEntry (new FieldCell (new ReadExpression (a [0])' compEnv.SubstituteMember (fieldi.Field)).AddressOf ()' e);  				else  					// Must be a reference type' and ref could be null  					return new ExpressionStackEntry (new FieldCell (a [0]' compEnv.SubstituteMember (fieldi.Field)).AddressOf ()' e.Lub (ThrowsE));  			});  	case FieldOp.Stfld:  		if (fieldi.IsStatic)  			return stack.PopEvalSE (statements' 1' true' WriteHeapE' (s' a) => s.Add (new ExpressionStatement (new FieldCell (null' compEnv.SubstituteMember (fieldi.Field)).Write (a [0]))));  		else {  			var writeEffect = fieldi.IsViaPointer.Value ? instruction.BeforeState.PeekPointsTo (1).WriteEffect () : WriteHeapOrThrowE;  			return stack.PopEvalSE (statements' 2' true' writeEffect' (s' a) =>  {  				var obj = fieldi.IsViaPointer.Value ? new ReadExpression (a [0]) : a [0];  				s.Add (new ExpressionStatement (new FieldCell (obj' compEnv.SubstituteMember (fieldi.Field)).Write (a [1])));  			});  		}  	case FieldOp.Ldtoken:  		stack.Push (new ExpressionStackEntry (new FieldHandleConstantExpression (compEnv.SubstituteMember (fieldi.Field))' BottomE));  		return true;  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Method: {  	var methodi = (MethodInstruction)instruction;  	var arity = methodi.Method.ValueParameters.Count;  	switch (methodi.Op) {  	case MethodOp.Ldftn:  		if (methodi.IsVirtual)  			// Object could be null  			return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new CodePointerExpression (a [0]' compEnv.SubstituteMember (methodi.Method))' e.Lub (ReadHeapOrThrowE)));  		else {  			stack.Push (new ExpressionStackEntry (new CodePointerExpression (null' compEnv.SubstituteMember (methodi.Method))' BottomE));  			return true;  		}  	case MethodOp.Call:  		if (methodi.Method.Result == null)  			return stack.PopEvalSE (statements' arity' true' CalleeEffects (methodi.BeforeState' arity)' (s' a) => s.Add (new ExpressionStatement (new CallExpression (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal' compEnv.SubstituteMember (methodi.Method)' CallerArguments (methodi.Constrained' methodi.Method' a)))));  		else  			return stack.PopEvalPush (statements' arity' true' (a' e) => new ExpressionStackEntry (new CallExpression (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal' compEnv.SubstituteMember (methodi.Method)' CallerArguments (methodi.Constrained' methodi.Method' a))' e.Lub (CalleeEffects (methodi.BeforeState' arity))));  	case MethodOp.Newobj:  		arity--;  		return stack.PopEvalPush (statements' arity' true' (a' e) => new ExpressionStackEntry (new NewObjectExpression (compEnv.SubstituteMember (methodi.Method)' CallerArguments (null' methodi.Method' a))' e.Lub (CalleeEffects (methodi.BeforeState' arity))));  	case MethodOp.Ldtoken:  		stack.Push (new ExpressionStackEntry (new MethodHandleConstantExpression (compEnv.SubstituteMember (methodi.Method))' BottomE));  		return true;  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Type: {  	var typei = (TypeInstruction)instruction;  	switch (typei.Op) {  	case TypeOp.Ldobj:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ReadExpression (a [0]).CloneIfStruct (compEnv)' e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ())));  	case TypeOp.Stobj:  		return stack.PopEvalSE (statements' 2' true' instruction.BeforeState.PeekPointsTo (1).WriteEffect ()' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' a [1]))));  	case TypeOp.Cpobj: {  		var copyEffect = instruction.BeforeState.PeekPointsTo (0).ReadEffect ().Lub (instruction.BeforeState.PeekPointsTo (1).WriteEffect ());  		return stack.PopEvalSE (statements' 2' true' copyEffect' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' new ReadExpression (a [1]).CloneIfStruct (compEnv)))));  	}  	case TypeOp.Newarr:  		// Growing the heap is not considered an observable change. But will throw if  		// length < 0  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new NewArrayExpression (a [0]' compEnv.SubstituteType (typei.Type))' e.Lub (ThrowsE)));  	case TypeOp.Initobj:  		return stack.PopEvalSE (statements' 1' true' WriteHeapE' (s' a) => s.Add (new InitializeObjectStatement (a [0])));  	case TypeOp.Castclass:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new CastExpression (a [0]' compEnv.SubstituteType (typei.Type))' e.Lub (ThrowsE)));  	case TypeOp.Isinst:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new IsInstExpression (a [0]' compEnv.SubstituteType (typei.Type))' e));  	case TypeOp.Box:  		// Growing the heap is not considered an observable change  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new NewBoxExpression (a [0]' compEnv.SubstituteType (typei.Type))' e));  	case TypeOp.Unbox:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new BoxCell (a [0]' compEnv.SubstituteType (typei.Type)).AddressOf ()' e.Lub (ThrowsE)));  	case TypeOp.UnboxAny:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new BoxCell (a [0]' compEnv.SubstituteType (typei.Type)).Read ().CloneIfStruct (compEnv)' e.Lub (ThrowsE)));  	case TypeOp.Ldtoken:  		stack.Push (new ExpressionStackEntry (new TypeHandleConstantExpression (compEnv.SubstituteType (typei.Type))' BottomE));  		return true;  	case TypeOp.Ldelem:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' true).Read ().CloneIfStruct (compEnv)' e.Lub (ReadHeapOrThrowE)));  	case TypeOp.Stelem:  		return stack.PopEvalSE (statements' 3' true' WriteHeapOrThrowE' (s' a) => s.Add (new ExpressionStatement (new ElementCell (a [0]' a [1]' false).Write (a [2]))));  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.LdElemAddr:  	// Calculating the pointer may throw if index is out of range.  	// Remaining effect will be accounted for when pointer is read/written.  	return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' false).AddressOf ()' e.Lub (ThrowsE)));  case InstructionFlavor.LdInt32: {  	var int32i = (LdInt32Instruction)instruction;  	stack.Push (new ExpressionStackEntry (new Int32ConstantExpression (int32i.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdInt64: {  	var int64i = (LdInt64Instruction)instruction;  	stack.Push (new ExpressionStackEntry (new Int64ConstantExpression (int64i.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdSingle: {  	var singlei = (LdSingleInstruction)instruction;  	stack.Push (new ExpressionStackEntry (new SingleConstantExpression (singlei.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdDouble: {  	var doublei = (LdDoubleInstruction)instruction;  	stack.Push (new ExpressionStackEntry (new DoubleConstantExpression (doublei.Value)' BottomE));  	return true;  }  case InstructionFlavor.LdString: {  	var stringi = (LdStringInstruction)instruction;  	stack.Push (new ExpressionStackEntry (new StringConstantExpression (stringi.Value)' BottomE));  	return true;  }  case InstructionFlavor.Arith: {  	var arithi = (ArithInstruction)instruction;  	switch (arithi.Op) {  	case ArithOp.Div:  	case ArithOp.Rem:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new BinaryExpression (a [0]' ArithOpToBinaryOp (arithi.Op)' a [1]' arithi.WithOverflow' arithi.IsUnsigned)' e.Lub (ThrowsE)));  	case ArithOp.Add:  	case ArithOp.Sub:  	case ArithOp.Mul:  	case ArithOp.BitAnd:  	case ArithOp.BitOr:  	case ArithOp.BitXor:  	case ArithOp.Shl:  	case ArithOp.Shr:  		return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new BinaryExpression (a [0]' ArithOpToBinaryOp (arithi.Op)' a [1]' arithi.WithOverflow' arithi.IsUnsigned)' e.Lub (arithi.WithOverflow ? ThrowsE : BottomE)));  	case ArithOp.Neg:  	case ArithOp.BitNot:  		return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' ArithOpToUnaryOp (arithi.Op)' arithi.WithOverflow' arithi.IsUnsigned)' e));  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  case InstructionFlavor.Conv: {  	var convi = (ConvInstruction)instruction;  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ConvertExpression (a [0]' new NamedTypeRef (compEnv.Global.NumberFlavorToQualifiedTypeName [convi.TargetNumberFlavor])' convi.WithOverflow' convi.IsSourceUnsigned)' e.Lub (convi.WithOverflow ? ThrowsE : BottomE)));  }  case InstructionFlavor.Try: {  	if (stack.Depth > 0)  		throw new InvalidOperationException ("stack must be empty on entry to try block");  	var tryi = (TryInstruction)instruction;  	var tryStatements = BlockToTryFaultFinallyStatements (tryi.Body);  	if (tryStatements == null)  		return false;  	var handlers = TranslateHandlers (tryi.Handlers);  	if (handlers == null)  		return false;  	if (statements == null)  		return Failed (false' "try");  	statements.Add (new TryStatement (tryStatements' handlers));  	return true;  }  case InstructionFlavor.IfThenElsePseudo: {  	var itei = (IfThenElseInstruction)instruction;  	var isExpr = default(bool);  	// If outer context is re-translating as statements instead of expression' jump directly  	// to appropriate translation for this instruction  	var couldBeExpression = !instructionTranslationStyleCache.TryGetValue (itei.Offset' out isExpr) || isExpr;  	if (!TranslateBlock (statements' itei.Condition' stack' exid))  		return false;  	if (couldBeExpression && itei.Else != null) {  		// Pass 1: Try to tranlate to an if-then-else expression. Will only work if Then and Else don't  		//         reach into current stack' push exactly one value' and don't need to emit any  		//         statements along the way.  		var thenEntry = BlockToExpression (itei.Then' exid);  		if (thenEntry != null) {  			var elseEntry = BlockToExpression (itei.Else' exid);  			if (elseEntry != null) {  				if (!instructionTranslationStyleCache.ContainsKey (itei.Offset))  					instructionTranslationStyleCache.Add (itei.Offset' true);  				return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new IfThenElseExpression (a [0]' thenEntry.Expression' elseEntry.Expression)' e.Lub (thenEntry.Effects.Lub (elseEntry.Effects))));  			}  			// else: fallthrough  		}  		// else: fallthrough  	}  	// else: fallthrough  	// Pass 2: Translate to a statement  	var noStackChange = itei.Then.NoStackChange && (itei.Else == null || itei.Else.NoStackChange);  	var condEntry = noStackChange ? stack.Pop () : stack.FlushAndPopPostState (statements' itei.Then.BeforeState);  	if (condEntry == null)  		return false;  	var thenStmnts = noStackChange ? BlockToStatementsEmptyStack (itei.Then' exid) : BlockToStatements (itei.Then' exid);  	if (thenStmnts == null)  		return false;  	var elseStmnts = default(Seq<Statement>);  	if (itei.Else != null) {  		elseStmnts = noStackChange ? BlockToStatementsEmptyStack (itei.Else' exid) : BlockToStatements (itei.Else' exid);  		if (elseStmnts == null)  			return false;  	}  	if (statements == null)  		return Failed (false' "if-then-else");  	statements.Add (new IfThenElseStatement (condEntry.Expression' new Statements (thenStmnts)' elseStmnts == null ? null : new Statements (elseStmnts)));  	if (!noStackChange && !stack.Restore (itei.AfterState' 0))  		return false;  	if (!instructionTranslationStyleCache.ContainsKey (itei.Offset))  		instructionTranslationStyleCache.Add (itei.Offset' false);  	return true;  }  case InstructionFlavor.ShortCircuitingPseudo: {  	var sci = (ShortCircuitingInstruction)instruction;  	var isExpr = default(bool);  	// If outer context is re-translating as statements instead of expression' jump directly  	// to appropriate translation for this instruction  	var couldBeExpression = !instructionTranslationStyleCache.TryGetValue (sci.Offset' out isExpr) || isExpr;  	if (couldBeExpression) {  		// Pass 1: Try to translate to an expression.  		var leftEntry = BlockToExpression (sci.Left' exid);  		if (leftEntry != null) {  			var rightEntry = BlockToExpression (sci.Right' exid);  			if (rightEntry != null) {  				stack.Push (new ExpressionStackEntry (new BinaryExpression (leftEntry.Expression' ShortCircuitingOpToBinaryOp (sci.Op)' rightEntry.Expression' false' false)' leftEntry.Effects.Lub (rightEntry.Effects)));  				if (!instructionTranslationStyleCache.ContainsKey (sci.Offset))  					instructionTranslationStyleCache.Add (sci.Offset' true);  				return true;  			}  			// else: fallthrough  		}  		// else: fallthrough  	}  	// else: fallthrough  	// Pass 2: Translate to a statement  	if (!TranslateBlock (statements' sci.Left' stack' exid))  		return false;  	var leftEntry2 = stack.FlushAndPopPostState (statements' sci.Right.BeforeState);  	if (leftEntry2 == null)  		return false;  	var rightStatements = BlockToStatements (sci.Right' exid);  	if (rightStatements == null)  		return false;  	var id = sci.Right.AfterState.PeekId (0' nameSupply.GenSym);  	var cell = new VariableCell (id);  	compEnv.AddVariable (id' ArgLocal.Local' false' true' compEnv.SubstituteType (sci.Right.AfterState.PeekType (0)));  	if (statements == null)  		return Failed (false' "short-circuit");  	switch (sci.Op) {  	case ShortCircuitingOp.And:  		statements.Add (new IfThenElseStatement (leftEntry2.Expression' new Statements (rightStatements)' new Statements (new ExpressionStatement (cell.Write (new Int32ConstantExpression (0))))));  		break;  	case ShortCircuitingOp.Or:  		statements.Add (new IfThenElseStatement (leftEntry2.Expression' new Statements (new ExpressionStatement (cell.Write (new Int32ConstantExpression (1))))' new Statements (rightStatements)));  		break;  	default:  		throw new ArgumentOutOfRangeException ();  	}  	if (!stack.Restore (sci.AfterState' 1))  		return false;  	stack.Push (new ExpressionStackEntry (cell.Read ()' BottomE));  	if (!instructionTranslationStyleCache.ContainsKey (sci.Offset))  		instructionTranslationStyleCache.Add (sci.Offset' false);  	return true;  }  case InstructionFlavor.StructuralSwitchPseudo: {  	var ssi = (StructuralSwitchInstruction)instruction;  	if (!TranslateBlock (statements' ssi.Body' stack' exid))  		return false;  	var valueEntry = stack.FlushAndPopPreState (statements' ssi.Body.AfterState);  	if (valueEntry == null)  		return false;  	var cases = new Seq<SwitchStatementCase> ();  	foreach (var c in ssi.Cases) {  		var caseStatements = BlockToStatements (c.Body' exid);  		if (caseStatements == null)  			return false;  		cases.Add (new SwitchStatementCase (c.Values' new Statements (caseStatements)));  	}  	if (statements == null)  		return Failed (false' "structural switch");  	statements.Add (new SwitchStatement (valueEntry.Expression' cases));  	if (!stack.Restore (ssi.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.LoopPseudo: {  	var li = (LoopInstruction)instruction;  	if (!stack.Flush (statements' li.Body.BeforeState))  		return false;  	if (statements == null)  		return Failed (false' "loop");  	var whileStatements = BlockToStatements (li.Body' exid);  	statements.Add (new WhileDoStatement (new Int32ConstantExpression (1)' new Statements (whileStatements)));  	if (!stack.Restore (li.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.WhileDoPseudo: {  	var wdi = (WhileDoInstruction)instruction;  	if (!stack.Flush (statements' wdi.Condition.BeforeState))  		return false;  	var condEntry = BlockToExpression (wdi.Condition' exid);  	if (condEntry == null) {  		var stack1 = new ExpressionStack (compEnv' BottomE' nameSupply.GenSym' wdi.Condition.BeforeState' trace);  		var preCondStatements = new Seq<Statement> ();  		if (!TranslateBlock (preCondStatements' wdi.Condition' stack1' exid))  			return false;  		condEntry = stack1.FlushAndPopPostState (preCondStatements' wdi.Body.BeforeState);  		if (condEntry == null)  			return false;  		var stack2 = new ExpressionStack (compEnv' BottomE' nameSupply.GenSym' wdi.Body.BeforeState' trace);  		var postCondStatements = new Seq<Statement> ();  		if (!TranslateBlock (postCondStatements' wdi.Body' stack2' exid))  			return false;  		if (!stack2.Flush (postCondStatements' wdi.Body.AfterState))  			return false;  		preCondStatements.Add (new IfThenElseStatement (condEntry.Expression' new Statements (postCondStatements)' new Statements (new BreakStatement ())));  		statements.Add (new WhileDoStatement (new Int32ConstantExpression (1)' new Statements (preCondStatements)));  	}  	else {  		var loopStatements = BlockToStatements (wdi.Body' exid);  		if (loopStatements == null)  			return false;  		if (statements == null)  			return Failed (false' "while-do");  		statements.Add (new WhileDoStatement (condEntry.Expression' new Statements (loopStatements)));  	}  	if (!stack.Restore (wdi.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.DoWhilePseudo: {  	var dwi = (DoWhileInstruction)instruction;  	if (!stack.Flush (statements' dwi.Body.BeforeState))  		return false;  	var combined = new Seq<Instruction> ();  	foreach (var i in dwi.Body.Body)  		combined.Add (i);  	foreach (var i in dwi.Condition.Body)  		combined.Add (i);  	var condEntry = default(ExpressionStackEntry);  	var loopStatements = BlockToConditionStatements (new Instructions (null' combined)' dwi.Body.BeforeState' exid' out condEntry);  	if (loopStatements == null)  		return false;  	if (statements == null)  		return Failed (false' "do-while");  	statements.Add (new DoWhileStatement (new Statements (loopStatements)' condEntry.Expression));  	if (!stack.Restore (dwi.AfterState' 0))  		return false;  	return true;  }  case InstructionFlavor.LoopControlPseudo: {  	var lci = (BreakContinueInstruction)instruction;  	if (!stack.Flush (statements' lci.BeforeState))  		return false;  	if (statements == null)  		return Failed (false' "loop-control");  	var targetState = default(int);  	switch (lci.Op) {  	case BreakContinueOp.Break:  		if (labelToLoopCandidateBreakState != null && labelToLoopCandidateBreakState.TryGetValue (lci.Label' out targetState))  			statements.Add (new GotoPseudoStatement (stateId' targetState));  		else  			statements.Add (new BreakStatement (lci.Label));  		break;  	case BreakContinueOp.Continue:  		if (labelToLoopCandidateContinueState != null && labelToLoopCandidateContinueState.TryGetValue (lci.Label' out targetState))  			statements.Add (new GotoPseudoStatement (stateId' targetState));  		else  			statements.Add (new ContinueStatement (lci.Label));  		break;  	default:  		throw new ArgumentOutOfRangeException ();  	}  	return true;  }  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (misci.Op) {  case MiscOp.Nop:  case MiscOp.Break:  	return true;  case MiscOp.Dup:  	return stack.Dup (statements);  case MiscOp.Pop:  	return stack.PopAndDiscard (statements);  case MiscOp.Ldnull:  	stack.Push (new ExpressionStackEntry (new NullConstantExpression ()' BottomE));  	return true;  case MiscOp.Ckfinite:  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' UnaryOp.CheckFinite' false' false)' e.Lub (ThrowsE)));  case MiscOp.Throw:  	if (!stack.DiscardAll (statements' 1))  		return false;  	if (!stack.PopEvalSE (statements' 1' true' ThrowsE' (s' a) => s.Add (new ThrowStatement (a [0]))))  		return false;  	return true;  case MiscOp.Rethrow:  	if (!stack.DiscardAll (statements' 0))  		return false;  	if (statements == null)  		return Failed (false' "rethrow");  	if (exid == null)  		throw new InvalidOperationException ("rethrow outside of catch");  	statements.Add (new RethrowStatement (new VariableCell (exid).Read ()));  	return true;  case MiscOp.LdindRef:  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ReadExpression (a [0]).CloneIfStruct (compEnv)' e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ())));  case MiscOp.LdelemRef:  	return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' true).Read ().CloneIfStruct (compEnv)' e.Lub (ReadHeapOrThrowE)));  case MiscOp.Ldlen:  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' UnaryOp.Length' false' false)' e.Lub (ReadHeapOrThrowE)));  case MiscOp.StindRef:  	return stack.PopEvalSE (statements' 2' true' instruction.BeforeState.PeekPointsTo (1).WriteEffect ()' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' a [1]))));  case MiscOp.StelemRef:  	return stack.PopEvalSE (statements' 3' true' WriteHeapOrThrowE' (s' a) => s.Add (new ExpressionStatement (new ElementCell (a [0]' a [1]' false).Write (a [2]))));  case MiscOp.Ret:  	if (statements == null)  		return Failed (false' "return");  	statements.Add (new ReturnStatement (null));  	return true;  case MiscOp.RetVal:  	return stack.PopEvalSE (statements' 1' true' BottomE' (s' a) => s.Add (new ReturnStatement (a [0])));  case MiscOp.Endfilter:  case MiscOp.Endfinally:  	throw new InvalidOperationException ("endfilter/endfinally instructions should have been removed");  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (misci.Op) {  case MiscOp.Nop:  case MiscOp.Break:  	return true;  case MiscOp.Dup:  	return stack.Dup (statements);  case MiscOp.Pop:  	return stack.PopAndDiscard (statements);  case MiscOp.Ldnull:  	stack.Push (new ExpressionStackEntry (new NullConstantExpression ()' BottomE));  	return true;  case MiscOp.Ckfinite:  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' UnaryOp.CheckFinite' false' false)' e.Lub (ThrowsE)));  case MiscOp.Throw:  	if (!stack.DiscardAll (statements' 1))  		return false;  	if (!stack.PopEvalSE (statements' 1' true' ThrowsE' (s' a) => s.Add (new ThrowStatement (a [0]))))  		return false;  	return true;  case MiscOp.Rethrow:  	if (!stack.DiscardAll (statements' 0))  		return false;  	if (statements == null)  		return Failed (false' "rethrow");  	if (exid == null)  		throw new InvalidOperationException ("rethrow outside of catch");  	statements.Add (new RethrowStatement (new VariableCell (exid).Read ()));  	return true;  case MiscOp.LdindRef:  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ReadExpression (a [0]).CloneIfStruct (compEnv)' e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ())));  case MiscOp.LdelemRef:  	return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' true).Read ().CloneIfStruct (compEnv)' e.Lub (ReadHeapOrThrowE)));  case MiscOp.Ldlen:  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' UnaryOp.Length' false' false)' e.Lub (ReadHeapOrThrowE)));  case MiscOp.StindRef:  	return stack.PopEvalSE (statements' 2' true' instruction.BeforeState.PeekPointsTo (1).WriteEffect ()' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' a [1]))));  case MiscOp.StelemRef:  	return stack.PopEvalSE (statements' 3' true' WriteHeapOrThrowE' (s' a) => s.Add (new ExpressionStatement (new ElementCell (a [0]' a [1]' false).Write (a [2]))));  case MiscOp.Ret:  	if (statements == null)  		return Failed (false' "return");  	statements.Add (new ReturnStatement (null));  	return true;  case MiscOp.RetVal:  	return stack.PopEvalSE (statements' 1' true' BottomE' (s' a) => s.Add (new ReturnStatement (a [0])));  case MiscOp.Endfilter:  case MiscOp.Endfinally:  	throw new InvalidOperationException ("endfilter/endfinally instructions should have been removed");  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (misci.Op) {  case MiscOp.Nop:  case MiscOp.Break:  	return true;  case MiscOp.Dup:  	return stack.Dup (statements);  case MiscOp.Pop:  	return stack.PopAndDiscard (statements);  case MiscOp.Ldnull:  	stack.Push (new ExpressionStackEntry (new NullConstantExpression ()' BottomE));  	return true;  case MiscOp.Ckfinite:  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' UnaryOp.CheckFinite' false' false)' e.Lub (ThrowsE)));  case MiscOp.Throw:  	if (!stack.DiscardAll (statements' 1))  		return false;  	if (!stack.PopEvalSE (statements' 1' true' ThrowsE' (s' a) => s.Add (new ThrowStatement (a [0]))))  		return false;  	return true;  case MiscOp.Rethrow:  	if (!stack.DiscardAll (statements' 0))  		return false;  	if (statements == null)  		return Failed (false' "rethrow");  	if (exid == null)  		throw new InvalidOperationException ("rethrow outside of catch");  	statements.Add (new RethrowStatement (new VariableCell (exid).Read ()));  	return true;  case MiscOp.LdindRef:  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ReadExpression (a [0]).CloneIfStruct (compEnv)' e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ())));  case MiscOp.LdelemRef:  	return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' true).Read ().CloneIfStruct (compEnv)' e.Lub (ReadHeapOrThrowE)));  case MiscOp.Ldlen:  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' UnaryOp.Length' false' false)' e.Lub (ReadHeapOrThrowE)));  case MiscOp.StindRef:  	return stack.PopEvalSE (statements' 2' true' instruction.BeforeState.PeekPointsTo (1).WriteEffect ()' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' a [1]))));  case MiscOp.StelemRef:  	return stack.PopEvalSE (statements' 3' true' WriteHeapOrThrowE' (s' a) => s.Add (new ExpressionStatement (new ElementCell (a [0]' a [1]' false).Write (a [2]))));  case MiscOp.Ret:  	if (statements == null)  		return Failed (false' "return");  	statements.Add (new ReturnStatement (null));  	return true;  case MiscOp.RetVal:  	return stack.PopEvalSE (statements' 1' true' BottomE' (s' a) => s.Add (new ReturnStatement (a [0])));  case MiscOp.Endfilter:  case MiscOp.Endfinally:  	throw new InvalidOperationException ("endfilter/endfinally instructions should have been removed");  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (misci.Op) {  case MiscOp.Nop:  case MiscOp.Break:  	return true;  case MiscOp.Dup:  	return stack.Dup (statements);  case MiscOp.Pop:  	return stack.PopAndDiscard (statements);  case MiscOp.Ldnull:  	stack.Push (new ExpressionStackEntry (new NullConstantExpression ()' BottomE));  	return true;  case MiscOp.Ckfinite:  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' UnaryOp.CheckFinite' false' false)' e.Lub (ThrowsE)));  case MiscOp.Throw:  	if (!stack.DiscardAll (statements' 1))  		return false;  	if (!stack.PopEvalSE (statements' 1' true' ThrowsE' (s' a) => s.Add (new ThrowStatement (a [0]))))  		return false;  	return true;  case MiscOp.Rethrow:  	if (!stack.DiscardAll (statements' 0))  		return false;  	if (statements == null)  		return Failed (false' "rethrow");  	if (exid == null)  		throw new InvalidOperationException ("rethrow outside of catch");  	statements.Add (new RethrowStatement (new VariableCell (exid).Read ()));  	return true;  case MiscOp.LdindRef:  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ReadExpression (a [0]).CloneIfStruct (compEnv)' e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ())));  case MiscOp.LdelemRef:  	return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' true).Read ().CloneIfStruct (compEnv)' e.Lub (ReadHeapOrThrowE)));  case MiscOp.Ldlen:  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' UnaryOp.Length' false' false)' e.Lub (ReadHeapOrThrowE)));  case MiscOp.StindRef:  	return stack.PopEvalSE (statements' 2' true' instruction.BeforeState.PeekPointsTo (1).WriteEffect ()' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' a [1]))));  case MiscOp.StelemRef:  	return stack.PopEvalSE (statements' 3' true' WriteHeapOrThrowE' (s' a) => s.Add (new ExpressionStatement (new ElementCell (a [0]' a [1]' false).Write (a [2]))));  case MiscOp.Ret:  	if (statements == null)  		return Failed (false' "return");  	statements.Add (new ReturnStatement (null));  	return true;  case MiscOp.RetVal:  	return stack.PopEvalSE (statements' 1' true' BottomE' (s' a) => s.Add (new ReturnStatement (a [0])));  case MiscOp.Endfilter:  case MiscOp.Endfinally:  	throw new InvalidOperationException ("endfilter/endfinally instructions should have been removed");  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' true).Read ().CloneIfStruct (compEnv)' e.Lub (ReadHeapOrThrowE)));  
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: return stack.PopEvalSE (statements' 2' true' instruction.BeforeState.PeekPointsTo (1).WriteEffect ()' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' a [1]))));  
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: return stack.PopEvalSE (statements' 3' true' WriteHeapOrThrowE' (s' a) => s.Add (new ExpressionStatement (new ElementCell (a [0]' a [1]' false).Write (a [2]))));  
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: return stack.PopEvalSE (statements' 3' true' WriteHeapOrThrowE' (s' a) => s.Add (new ExpressionStatement (new ElementCell (a [0]' a [1]' false).Write (a [2]))));  
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: if (cmpi.Op == CompareOp.CtruePseudo || cmpi.Op == CompareOp.CfalsePseudo) {  	var s = cmpi.Type.Style (compEnv);  	var unop = default(UnaryOp);  	if (s is NumberTypeStyle)  		unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonZero : UnaryOp.IsZero;  	else  		unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonNull : UnaryOp.IsNull;  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' unop' false' cmpi.IsUnsigned)' e));  }  else {  	var binop = default(BinaryOp);  	switch (cmpi.Op) {  	case CompareOp.Ceq:  		binop = BinaryOp.Eq;  		break;  	case CompareOp.Clt:  		binop = BinaryOp.Lt;  		break;  	case CompareOp.Cgt:  		binop = BinaryOp.Gt;  		break;  	case CompareOp.CgePseudo:  		binop = BinaryOp.Ge;  		break;  	case CompareOp.ClePseudo:  		binop = BinaryOp.Le;  		break;  	case CompareOp.CnePseudo:  		binop = BinaryOp.Ne;  		break;  	case CompareOp.CtruePseudo:  	case CompareOp.CfalsePseudo:  		// handled above  		throw new InvalidOperationException ();  	default:  		throw new ArgumentOutOfRangeException ();  	}  	return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new BinaryExpression (a [0]' binop' a [1]' false' cmpi.IsUnsigned)' e));  }  
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new BinaryExpression (a [0]' binop' a [1]' false' cmpi.IsUnsigned)' e));  
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (fieldi.Op) {  case FieldOp.Ldfld:  	if (fieldi.IsStatic) {  		stack.Push (new ExpressionStackEntry (new FieldCell (null' compEnv.SubstituteMember (fieldi.Field)).Read ().CloneIfStruct (compEnv)' ReadHeapE));  		return true;  	}  	else  		return stack.PopEvalPush (statements' 1' true' (a' e) =>  {  			var readEffect = default(Effects);  			var obj = default(Expression);  			if (fieldi.IsViaPointer.Value) {  				readEffect = e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ());  				obj = new ReadExpression (a [0]);  				// no need for clone  			}  			else if (fieldi.Field.DefiningType.Style (compEnv) is ValueTypeStyle) {  				readEffect = e;  				obj = a [0];  			}  			else {  				// Object could be null  				readEffect = e.Lub (ReadHeapOrThrowE);  				obj = a [0];  			}  			return new ExpressionStackEntry (new FieldCell (obj' compEnv.SubstituteMember (fieldi.Field)).Read ().CloneIfStruct (compEnv)' readEffect);  		});  case FieldOp.Ldflda:  	if (fieldi.IsStatic) {  		// Effect will be accounted for on reads/writes  		stack.Push (new ExpressionStackEntry (new FieldCell (null' compEnv.SubstituteMember (fieldi.Field)).AddressOf ()' BottomE));  		return true;  	}  	else  		return stack.PopEvalPush (statements' 1' true' (a' e) =>  {  			if (fieldi.IsViaPointer.Value)  				// We're just adding an offset to a pointer' so effect will  				// be accounted for when the final pointer is read/written  				return new ExpressionStackEntry (new FieldCell (new ReadExpression (a [0])' compEnv.SubstituteMember (fieldi.Field)).AddressOf ()' e);  			else  				// Must be a reference type' and ref could be null  				return new ExpressionStackEntry (new FieldCell (a [0]' compEnv.SubstituteMember (fieldi.Field)).AddressOf ()' e.Lub (ThrowsE));  		});  case FieldOp.Stfld:  	if (fieldi.IsStatic)  		return stack.PopEvalSE (statements' 1' true' WriteHeapE' (s' a) => s.Add (new ExpressionStatement (new FieldCell (null' compEnv.SubstituteMember (fieldi.Field)).Write (a [0]))));  	else {  		var writeEffect = fieldi.IsViaPointer.Value ? instruction.BeforeState.PeekPointsTo (1).WriteEffect () : WriteHeapOrThrowE;  		return stack.PopEvalSE (statements' 2' true' writeEffect' (s' a) =>  {  			var obj = fieldi.IsViaPointer.Value ? new ReadExpression (a [0]) : a [0];  			s.Add (new ExpressionStatement (new FieldCell (obj' compEnv.SubstituteMember (fieldi.Field)).Write (a [1])));  		});  	}  case FieldOp.Ldtoken:  	stack.Push (new ExpressionStackEntry (new FieldHandleConstantExpression (compEnv.SubstituteMember (fieldi.Field))' BottomE));  	return true;  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: if (fieldi.IsStatic)  	return stack.PopEvalSE (statements' 1' true' WriteHeapE' (s' a) => s.Add (new ExpressionStatement (new FieldCell (null' compEnv.SubstituteMember (fieldi.Field)).Write (a [0]))));  else {  	var writeEffect = fieldi.IsViaPointer.Value ? instruction.BeforeState.PeekPointsTo (1).WriteEffect () : WriteHeapOrThrowE;  	return stack.PopEvalSE (statements' 2' true' writeEffect' (s' a) =>  {  		var obj = fieldi.IsViaPointer.Value ? new ReadExpression (a [0]) : a [0];  		s.Add (new ExpressionStatement (new FieldCell (obj' compEnv.SubstituteMember (fieldi.Field)).Write (a [1])));  	});  }  
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: return stack.PopEvalSE (statements' 2' true' writeEffect' (s' a) =>  {  	var obj = fieldi.IsViaPointer.Value ? new ReadExpression (a [0]) : a [0];  	s.Add (new ExpressionStatement (new FieldCell (obj' compEnv.SubstituteMember (fieldi.Field)).Write (a [1])));  });  
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (typei.Op) {  case TypeOp.Ldobj:  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ReadExpression (a [0]).CloneIfStruct (compEnv)' e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ())));  case TypeOp.Stobj:  	return stack.PopEvalSE (statements' 2' true' instruction.BeforeState.PeekPointsTo (1).WriteEffect ()' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' a [1]))));  case TypeOp.Cpobj: {  	var copyEffect = instruction.BeforeState.PeekPointsTo (0).ReadEffect ().Lub (instruction.BeforeState.PeekPointsTo (1).WriteEffect ());  	return stack.PopEvalSE (statements' 2' true' copyEffect' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' new ReadExpression (a [1]).CloneIfStruct (compEnv)))));  }  case TypeOp.Newarr:  	// Growing the heap is not considered an observable change. But will throw if  	// length < 0  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new NewArrayExpression (a [0]' compEnv.SubstituteType (typei.Type))' e.Lub (ThrowsE)));  case TypeOp.Initobj:  	return stack.PopEvalSE (statements' 1' true' WriteHeapE' (s' a) => s.Add (new InitializeObjectStatement (a [0])));  case TypeOp.Castclass:  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new CastExpression (a [0]' compEnv.SubstituteType (typei.Type))' e.Lub (ThrowsE)));  case TypeOp.Isinst:  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new IsInstExpression (a [0]' compEnv.SubstituteType (typei.Type))' e));  case TypeOp.Box:  	// Growing the heap is not considered an observable change  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new NewBoxExpression (a [0]' compEnv.SubstituteType (typei.Type))' e));  case TypeOp.Unbox:  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new BoxCell (a [0]' compEnv.SubstituteType (typei.Type)).AddressOf ()' e.Lub (ThrowsE)));  case TypeOp.UnboxAny:  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new BoxCell (a [0]' compEnv.SubstituteType (typei.Type)).Read ().CloneIfStruct (compEnv)' e.Lub (ThrowsE)));  case TypeOp.Ldtoken:  	stack.Push (new ExpressionStackEntry (new TypeHandleConstantExpression (compEnv.SubstituteType (typei.Type))' BottomE));  	return true;  case TypeOp.Ldelem:  	return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' true).Read ().CloneIfStruct (compEnv)' e.Lub (ReadHeapOrThrowE)));  case TypeOp.Stelem:  	return stack.PopEvalSE (statements' 3' true' WriteHeapOrThrowE' (s' a) => s.Add (new ExpressionStatement (new ElementCell (a [0]' a [1]' false).Write (a [2]))));  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (typei.Op) {  case TypeOp.Ldobj:  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ReadExpression (a [0]).CloneIfStruct (compEnv)' e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ())));  case TypeOp.Stobj:  	return stack.PopEvalSE (statements' 2' true' instruction.BeforeState.PeekPointsTo (1).WriteEffect ()' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' a [1]))));  case TypeOp.Cpobj: {  	var copyEffect = instruction.BeforeState.PeekPointsTo (0).ReadEffect ().Lub (instruction.BeforeState.PeekPointsTo (1).WriteEffect ());  	return stack.PopEvalSE (statements' 2' true' copyEffect' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' new ReadExpression (a [1]).CloneIfStruct (compEnv)))));  }  case TypeOp.Newarr:  	// Growing the heap is not considered an observable change. But will throw if  	// length < 0  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new NewArrayExpression (a [0]' compEnv.SubstituteType (typei.Type))' e.Lub (ThrowsE)));  case TypeOp.Initobj:  	return stack.PopEvalSE (statements' 1' true' WriteHeapE' (s' a) => s.Add (new InitializeObjectStatement (a [0])));  case TypeOp.Castclass:  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new CastExpression (a [0]' compEnv.SubstituteType (typei.Type))' e.Lub (ThrowsE)));  case TypeOp.Isinst:  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new IsInstExpression (a [0]' compEnv.SubstituteType (typei.Type))' e));  case TypeOp.Box:  	// Growing the heap is not considered an observable change  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new NewBoxExpression (a [0]' compEnv.SubstituteType (typei.Type))' e));  case TypeOp.Unbox:  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new BoxCell (a [0]' compEnv.SubstituteType (typei.Type)).AddressOf ()' e.Lub (ThrowsE)));  case TypeOp.UnboxAny:  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new BoxCell (a [0]' compEnv.SubstituteType (typei.Type)).Read ().CloneIfStruct (compEnv)' e.Lub (ThrowsE)));  case TypeOp.Ldtoken:  	stack.Push (new ExpressionStackEntry (new TypeHandleConstantExpression (compEnv.SubstituteType (typei.Type))' BottomE));  	return true;  case TypeOp.Ldelem:  	return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' true).Read ().CloneIfStruct (compEnv)' e.Lub (ReadHeapOrThrowE)));  case TypeOp.Stelem:  	return stack.PopEvalSE (statements' 3' true' WriteHeapOrThrowE' (s' a) => s.Add (new ExpressionStatement (new ElementCell (a [0]' a [1]' false).Write (a [2]))));  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (typei.Op) {  case TypeOp.Ldobj:  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ReadExpression (a [0]).CloneIfStruct (compEnv)' e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ())));  case TypeOp.Stobj:  	return stack.PopEvalSE (statements' 2' true' instruction.BeforeState.PeekPointsTo (1).WriteEffect ()' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' a [1]))));  case TypeOp.Cpobj: {  	var copyEffect = instruction.BeforeState.PeekPointsTo (0).ReadEffect ().Lub (instruction.BeforeState.PeekPointsTo (1).WriteEffect ());  	return stack.PopEvalSE (statements' 2' true' copyEffect' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' new ReadExpression (a [1]).CloneIfStruct (compEnv)))));  }  case TypeOp.Newarr:  	// Growing the heap is not considered an observable change. But will throw if  	// length < 0  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new NewArrayExpression (a [0]' compEnv.SubstituteType (typei.Type))' e.Lub (ThrowsE)));  case TypeOp.Initobj:  	return stack.PopEvalSE (statements' 1' true' WriteHeapE' (s' a) => s.Add (new InitializeObjectStatement (a [0])));  case TypeOp.Castclass:  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new CastExpression (a [0]' compEnv.SubstituteType (typei.Type))' e.Lub (ThrowsE)));  case TypeOp.Isinst:  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new IsInstExpression (a [0]' compEnv.SubstituteType (typei.Type))' e));  case TypeOp.Box:  	// Growing the heap is not considered an observable change  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new NewBoxExpression (a [0]' compEnv.SubstituteType (typei.Type))' e));  case TypeOp.Unbox:  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new BoxCell (a [0]' compEnv.SubstituteType (typei.Type)).AddressOf ()' e.Lub (ThrowsE)));  case TypeOp.UnboxAny:  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new BoxCell (a [0]' compEnv.SubstituteType (typei.Type)).Read ().CloneIfStruct (compEnv)' e.Lub (ThrowsE)));  case TypeOp.Ldtoken:  	stack.Push (new ExpressionStackEntry (new TypeHandleConstantExpression (compEnv.SubstituteType (typei.Type))' BottomE));  	return true;  case TypeOp.Ldelem:  	return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' true).Read ().CloneIfStruct (compEnv)' e.Lub (ReadHeapOrThrowE)));  case TypeOp.Stelem:  	return stack.PopEvalSE (statements' 3' true' WriteHeapOrThrowE' (s' a) => s.Add (new ExpressionStatement (new ElementCell (a [0]' a [1]' false).Write (a [2]))));  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (typei.Op) {  case TypeOp.Ldobj:  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ReadExpression (a [0]).CloneIfStruct (compEnv)' e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ())));  case TypeOp.Stobj:  	return stack.PopEvalSE (statements' 2' true' instruction.BeforeState.PeekPointsTo (1).WriteEffect ()' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' a [1]))));  case TypeOp.Cpobj: {  	var copyEffect = instruction.BeforeState.PeekPointsTo (0).ReadEffect ().Lub (instruction.BeforeState.PeekPointsTo (1).WriteEffect ());  	return stack.PopEvalSE (statements' 2' true' copyEffect' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' new ReadExpression (a [1]).CloneIfStruct (compEnv)))));  }  case TypeOp.Newarr:  	// Growing the heap is not considered an observable change. But will throw if  	// length < 0  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new NewArrayExpression (a [0]' compEnv.SubstituteType (typei.Type))' e.Lub (ThrowsE)));  case TypeOp.Initobj:  	return stack.PopEvalSE (statements' 1' true' WriteHeapE' (s' a) => s.Add (new InitializeObjectStatement (a [0])));  case TypeOp.Castclass:  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new CastExpression (a [0]' compEnv.SubstituteType (typei.Type))' e.Lub (ThrowsE)));  case TypeOp.Isinst:  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new IsInstExpression (a [0]' compEnv.SubstituteType (typei.Type))' e));  case TypeOp.Box:  	// Growing the heap is not considered an observable change  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new NewBoxExpression (a [0]' compEnv.SubstituteType (typei.Type))' e));  case TypeOp.Unbox:  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new BoxCell (a [0]' compEnv.SubstituteType (typei.Type)).AddressOf ()' e.Lub (ThrowsE)));  case TypeOp.UnboxAny:  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new BoxCell (a [0]' compEnv.SubstituteType (typei.Type)).Read ().CloneIfStruct (compEnv)' e.Lub (ThrowsE)));  case TypeOp.Ldtoken:  	stack.Push (new ExpressionStackEntry (new TypeHandleConstantExpression (compEnv.SubstituteType (typei.Type))' BottomE));  	return true;  case TypeOp.Ldelem:  	return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' true).Read ().CloneIfStruct (compEnv)' e.Lub (ReadHeapOrThrowE)));  case TypeOp.Stelem:  	return stack.PopEvalSE (statements' 3' true' WriteHeapOrThrowE' (s' a) => s.Add (new ExpressionStatement (new ElementCell (a [0]' a [1]' false).Write (a [2]))));  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (typei.Op) {  case TypeOp.Ldobj:  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new ReadExpression (a [0]).CloneIfStruct (compEnv)' e.Lub (instruction.BeforeState.PeekPointsTo (0).ReadEffect ())));  case TypeOp.Stobj:  	return stack.PopEvalSE (statements' 2' true' instruction.BeforeState.PeekPointsTo (1).WriteEffect ()' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' a [1]))));  case TypeOp.Cpobj: {  	var copyEffect = instruction.BeforeState.PeekPointsTo (0).ReadEffect ().Lub (instruction.BeforeState.PeekPointsTo (1).WriteEffect ());  	return stack.PopEvalSE (statements' 2' true' copyEffect' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' new ReadExpression (a [1]).CloneIfStruct (compEnv)))));  }  case TypeOp.Newarr:  	// Growing the heap is not considered an observable change. But will throw if  	// length < 0  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new NewArrayExpression (a [0]' compEnv.SubstituteType (typei.Type))' e.Lub (ThrowsE)));  case TypeOp.Initobj:  	return stack.PopEvalSE (statements' 1' true' WriteHeapE' (s' a) => s.Add (new InitializeObjectStatement (a [0])));  case TypeOp.Castclass:  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new CastExpression (a [0]' compEnv.SubstituteType (typei.Type))' e.Lub (ThrowsE)));  case TypeOp.Isinst:  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new IsInstExpression (a [0]' compEnv.SubstituteType (typei.Type))' e));  case TypeOp.Box:  	// Growing the heap is not considered an observable change  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new NewBoxExpression (a [0]' compEnv.SubstituteType (typei.Type))' e));  case TypeOp.Unbox:  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new BoxCell (a [0]' compEnv.SubstituteType (typei.Type)).AddressOf ()' e.Lub (ThrowsE)));  case TypeOp.UnboxAny:  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new BoxCell (a [0]' compEnv.SubstituteType (typei.Type)).Read ().CloneIfStruct (compEnv)' e.Lub (ThrowsE)));  case TypeOp.Ldtoken:  	stack.Push (new ExpressionStackEntry (new TypeHandleConstantExpression (compEnv.SubstituteType (typei.Type))' BottomE));  	return true;  case TypeOp.Ldelem:  	return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' true).Read ().CloneIfStruct (compEnv)' e.Lub (ReadHeapOrThrowE)));  case TypeOp.Stelem:  	return stack.PopEvalSE (statements' 3' true' WriteHeapOrThrowE' (s' a) => s.Add (new ExpressionStatement (new ElementCell (a [0]' a [1]' false).Write (a [2]))));  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: return stack.PopEvalSE (statements' 2' true' instruction.BeforeState.PeekPointsTo (1).WriteEffect ()' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' a [1]))));  
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: return stack.PopEvalSE (statements' 2' true' copyEffect' (s' a) => s.Add (new ExpressionStatement (new WriteExpression (a [0]' new ReadExpression (a [1]).CloneIfStruct (compEnv)))));  
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' true).Read ().CloneIfStruct (compEnv)' e.Lub (ReadHeapOrThrowE)));  
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: return stack.PopEvalSE (statements' 3' true' WriteHeapOrThrowE' (s' a) => s.Add (new ExpressionStatement (new ElementCell (a [0]' a [1]' false).Write (a [2]))));  
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: return stack.PopEvalSE (statements' 3' true' WriteHeapOrThrowE' (s' a) => s.Add (new ExpressionStatement (new ElementCell (a [0]' a [1]' false).Write (a [2]))));  
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new ElementCell (a [0]' a [1]' false).AddressOf ()' e.Lub (ThrowsE)));  
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (arithi.Op) {  case ArithOp.Div:  case ArithOp.Rem:  	return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new BinaryExpression (a [0]' ArithOpToBinaryOp (arithi.Op)' a [1]' arithi.WithOverflow' arithi.IsUnsigned)' e.Lub (ThrowsE)));  case ArithOp.Add:  case ArithOp.Sub:  case ArithOp.Mul:  case ArithOp.BitAnd:  case ArithOp.BitOr:  case ArithOp.BitXor:  case ArithOp.Shl:  case ArithOp.Shr:  	return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new BinaryExpression (a [0]' ArithOpToBinaryOp (arithi.Op)' a [1]' arithi.WithOverflow' arithi.IsUnsigned)' e.Lub (arithi.WithOverflow ? ThrowsE : BottomE)));  case ArithOp.Neg:  case ArithOp.BitNot:  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' ArithOpToUnaryOp (arithi.Op)' arithi.WithOverflow' arithi.IsUnsigned)' e));  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (arithi.Op) {  case ArithOp.Div:  case ArithOp.Rem:  	return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new BinaryExpression (a [0]' ArithOpToBinaryOp (arithi.Op)' a [1]' arithi.WithOverflow' arithi.IsUnsigned)' e.Lub (ThrowsE)));  case ArithOp.Add:  case ArithOp.Sub:  case ArithOp.Mul:  case ArithOp.BitAnd:  case ArithOp.BitOr:  case ArithOp.BitXor:  case ArithOp.Shl:  case ArithOp.Shr:  	return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new BinaryExpression (a [0]' ArithOpToBinaryOp (arithi.Op)' a [1]' arithi.WithOverflow' arithi.IsUnsigned)' e.Lub (arithi.WithOverflow ? ThrowsE : BottomE)));  case ArithOp.Neg:  case ArithOp.BitNot:  	return stack.PopEvalPush (statements' 1' true' (a' e) => new ExpressionStackEntry (new UnaryExpression (a [0]' ArithOpToUnaryOp (arithi.Op)' arithi.WithOverflow' arithi.IsUnsigned)' e));  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new BinaryExpression (a [0]' ArithOpToBinaryOp (arithi.Op)' a [1]' arithi.WithOverflow' arithi.IsUnsigned)' e.Lub (ThrowsE)));  
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: return stack.PopEvalPush (statements' 2' true' (a' e) => new ExpressionStackEntry (new BinaryExpression (a [0]' ArithOpToBinaryOp (arithi.Op)' a [1]' arithi.WithOverflow' arithi.IsUnsigned)' e.Lub (arithi.WithOverflow ? ThrowsE : BottomE)));  
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,Translate,The following statement contains a magic number: if (preorder.Count == 2) {  	// Only one non-root basic block' so its body is what we need  	var statements = BlockToStatements (preorder [1].Block' null);  	if (statements == null)  		throw new InvalidOperationException ("translation failed");  	return new Statements (statements);  }  else {  	// More than one non-root basic block. Encode transitions between them as a state machine.  	stateId = nameSupply.GenSym ();  	var stateCell = new VariableCell (stateId);  	var statePCCell = new StatePCPseudoCell (stateId);  	compEnv.AddVariable (stateId' ArgLocal.Local' false' false' compEnv.Global.Int32Ref);  	// Pass 1: Collect the  head and break parts of loop candidates.  	//         We can't inline these since they need a state number of their own for   	//         encoding break and continue statements.  	var nonInlinable = new Set<BasicBlock> ();  	foreach (var bb in preorder) {  		var lcbb = bb as LoopCandidateBasicBlock;  		if (lcbb != null) {  			nonInlinable.Add (lcbb.Head);  			nonInlinable.Add (lcbb.Break);  		}  	}  	// Pass 2: Check if we need to handle exceptions' and build a map from non-inlinable basic  	//         blocks to their state numbers  	var withExceptions = false;  	var stateMap = new Map<BasicBlock' int> ();  	foreach (var bb in preorder) {  		switch (bb.Flavor) {  		case BasicBlockFlavor.Root:  		case BasicBlockFlavor.Jump:  		case BasicBlockFlavor.Leave:  		case BasicBlockFlavor.Branch:  		case BasicBlockFlavor.Switch:  		case BasicBlockFlavor.NonReturning:  		case BasicBlockFlavor.LoopCandidate:  			break;  		case BasicBlockFlavor.Try:  		case BasicBlockFlavor.LeaveTry:  		case BasicBlockFlavor.LeaveCatch:  		case BasicBlockFlavor.EndFault:  		case BasicBlockFlavor.EndFinally:  			withExceptions = true;  			break;  		default:  			throw new ArgumentOutOfRangeException ();  		}  		if (bb.Flavor != BasicBlockFlavor.Root && (nonInlinable.Contains (bb) || !CanInlineBlock (bb)))  			stateMap.Add (bb' stateMap.Count);  	}  	// Pass 3: Build map from loop labels to the state representing the break and continue states  	//         for that loop. The above translation code will look there when translating a  	//         break/continue structural instruction to decide what to do.  	labelToLoopCandidateBreakState = new Map<JST.Identifier' int> ();  	labelToLoopCandidateContinueState = new Map<JST.Identifier' int> ();  	foreach (var bb in preorder) {  		var lcbb = bb as LoopCandidateBasicBlock;  		if (lcbb != null) {  			var targetState = default(int);  			if (!stateMap.TryGetValue (lcbb.Head' out targetState))  				throw new InvalidCastException ("head of loop should not have been inlined");  			labelToLoopCandidateContinueState.Add (lcbb.Label' targetState);  			if (!stateMap.TryGetValue (lcbb.Break' out targetState))  				throw new InvalidCastException ("end of loop should not have been inlined");  			labelToLoopCandidateBreakState.Add (lcbb.Label' targetState);  			break;  		}  	}  	// Pass 4: Emit statements and pseudo-statements for each case.  	var statements = new Seq<Statement> ();  	var initialState = default(int);  	if (!stateMap.TryGetValue (preorder [1]' out initialState))  		throw new InvalidOperationException ("initial block cannot be inlined");  	statements.Add (new ExpressionStatement (stateCell.Write (new InitialStatePseudoExpression (initialState))));  	var exid = nameSupply.GenSym ();  	var cases = stateMap.Select (kv => new SwitchStatementCase (new Set<int> {  		kv.Value  	}' CaseBody (stateMap' kv.Key' exid))).ToSeq ();  	// Wrap above in state machine  	var switchStatement = new SwitchStatement (statePCCell.Read ()' cases);  	var innerLoop = new WhileDoStatement (new Int32ConstantExpression (1)' new Statements (switchStatement));  	if (withExceptions) {  		compEnv.AddVariable (exid' ArgLocal.Local' false' true' compEnv.Global.ExceptionRef);  		var handlerStatement = new HandlePseudoStatement (stateId' exid);  		var handler = new TryStatementCatchHandler (new Statements (handlerStatement)' exid' compEnv.Global.ExceptionRef);  		var tryStatement = new TryStatement (new Statements (innerLoop)' new Seq<TryStatementHandler> {  			handler  		});  		var outerLoop = new WhileDoStatement (new Int32ConstantExpression (1)' new Statements (tryStatement));  		statements.Add (outerLoop);  	}  	else  		statements.Add (innerLoop);  	return new Statements (statements);  }  
Magic Number,Microsoft.LiveLabs.CST,MultiDimArrayBounds,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,ConsumeNum,The following statement contains a magic number: while (i < str.Length && str [i] >= '0' && str [i] <= '9') {  	n = n * 10 + (str [i] - '0');  	i++;  }  
Magic Number,Microsoft.LiveLabs.CST,MultiDimArrayBounds,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,ConsumeNum,The following statement contains a magic number: n = n * 10 + (str [i] - '0');  
Magic Number,Microsoft.LiveLabs.CST,MultiDimArrayTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,MultiDimArrayTypeDef,The following statement contains a magic number: for (var i = 0; i < bounds.Rank * 2; i++)  	ctor2Parameters.Add (intParam);  
Magic Number,Microsoft.LiveLabs.CST,CSTWriter,C:\repos\Reactive-Extensions_IL2JS\CST\Writer.cs,AppendMnemonicFileName,The following statement contains a magic number: if (nm.Length > lim)  	nm = "__" + nm.Substring (nm.Length + 2 - lim' lim - 2);  
Magic Number,Microsoft.LiveLabs.CST,CSTWriter,C:\repos\Reactive-Extensions_IL2JS\CST\Writer.cs,AppendMnemonicFileName,The following statement contains a magic number: if (nm.Length > lim)  	nm = "__" + nm.Substring (nm.Length + 2 - lim' lim - 2);  
Magic Number,Microsoft.LiveLabs.CST,CSTWriter,C:\repos\Reactive-Extensions_IL2JS\CST\Writer.cs,AppendMnemonicFileName,The following statement contains a magic number: nm = "__" + nm.Substring (nm.Length + 2 - lim' lim - 2);  
Magic Number,Microsoft.LiveLabs.CST,CSTWriter,C:\repos\Reactive-Extensions_IL2JS\CST\Writer.cs,AppendMnemonicFileName,The following statement contains a magic number: nm = "__" + nm.Substring (nm.Length + 2 - lim' lim - 2);  
Missing Default,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceLooping,The following switch statement is missing a default case: switch (bb.Flavor) {  case BasicBlockFlavor.Try: {  	var trybb = (TryBasicBlock)bb;  	if (!loop.Body.Contains (trybb.Body))  		isCandidateLoop = false;  	break;  }  case BasicBlockFlavor.LoopCandidate: {  	var loopbb = (LoopCandidateBasicBlock)bb;  	if (!loop.Body.Contains (loopbb.Head) || !loop.Body.Contains (loopbb.Break))  		isCandidateLoop = false;  	break;  }  }  
Missing Default,Microsoft.LiveLabs.CST,TypeName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,Append,The following switch statement is missing a default case: switch (w.Style) {  case WriterStyle.ReflectionName: {  	w.AppendName (Types [Types.Count - 1]);  	break;  }  case WriterStyle.ReflectionFullName:  case WriterStyle.Uniform:  case WriterStyle.Debug: {  	if (!string.IsNullOrEmpty (Namespace)) {  		w.AppendName (Namespace);  		w.Append ('.');  	}  	for (var i = 0; i < Types.Count; i++) {  		if (i > 0)  			w.Append ('+');  		w.AppendName (Types [i]);  	}  	break;  }  }  
Missing Default,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,FieldDefFromRow,The following switch statement is missing a default case: switch (row.Flags & PE.FieldAttributes.FieldAccessMask) {  case PE.FieldAttributes.CompilerControlled:  	accessibility = Accessibility.CompilerControlled;  	break;  case PE.FieldAttributes.Private:  	accessibility = Accessibility.Private;  	break;  case PE.FieldAttributes.FamANDAssem:  	accessibility = Accessibility.FamilyANDAssembly;  	break;  case PE.FieldAttributes.Assembly:  	accessibility = Accessibility.Assembly;  	break;  case PE.FieldAttributes.Family:  	accessibility = Accessibility.Family;  	break;  case PE.FieldAttributes.FamORAssem:  	accessibility = Accessibility.FamilyORAssembly;  	break;  case PE.FieldAttributes.Public:  	accessibility = Accessibility.Public;  	break;  }  
Missing Default,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,ParameterTypeDefFromRow,The following switch statement is missing a default case: switch (row.Flags & PE.GenericParamAttributes.VarianceMask) {  case PE.GenericParamAttributes.None:  	variance = ParameterVariance.Invariant;  	break;  case PE.GenericParamAttributes.Covariant:  	variance = ParameterVariance.Covariant;  	break;  case PE.GenericParamAttributes.Contravariant:  	variance = ParameterVariance.Contravariant;  	break;  }  
Missing Default,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,MethodDefFromRow,The following switch statement is missing a default case: switch (row.Flags & PE.MethodAttributes.MemberAccessMask) {  case PE.MethodAttributes.CompilerControlled:  	accessibility = Accessibility.CompilerControlled;  	break;  case PE.MethodAttributes.Private:  	accessibility = Accessibility.Private;  	break;  case PE.MethodAttributes.FamANDAssem:  	accessibility = Accessibility.FamilyANDAssembly;  	break;  case PE.MethodAttributes.Assem:  	accessibility = Accessibility.Assembly;  	break;  case PE.MethodAttributes.Family:  	accessibility = Accessibility.Family;  	break;  case PE.MethodAttributes.FamORAssem:  	accessibility = Accessibility.FamilyORAssembly;  	break;  case PE.MethodAttributes.Public:  	accessibility = Accessibility.Public;  	break;  }  
Missing Default,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,MethodDefFromRow,The following switch statement is missing a default case: switch (row.ImplFlags & PE.MethodImplAttributes.CodeTypeMask) {  case PE.MethodImplAttributes.IL:  case PE.MethodImplAttributes.OPTIL:  	codeFlavor = MethodCodeFlavor.Managed;  	break;  case PE.MethodImplAttributes.Native:  	codeFlavor = MethodCodeFlavor.Native;  	break;  case PE.MethodImplAttributes.Runtime:  	codeFlavor = MethodCodeFlavor.Runtime;  	break;  }  
Missing Default,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The following switch statement is missing a default case: switch (row.Flags & PE.TypeAttributes.VisibilityMask) {  case PE.TypeAttributes.NotPublic:  	accessibility = Accessibility.Private;  	break;  case PE.TypeAttributes.Public:  	accessibility = Accessibility.Public;  	break;  case PE.TypeAttributes.NestedPublic:  	accessibility = Accessibility.Public;  	break;  case PE.TypeAttributes.NestedPrivate:  	accessibility = Accessibility.Private;  	break;  case PE.TypeAttributes.NestedFamily:  	accessibility = Accessibility.Family;  	break;  case PE.TypeAttributes.NestedAssembly:  	accessibility = Accessibility.Assembly;  	break;  case PE.TypeAttributes.NestedFamANDAssem:  	accessibility = Accessibility.FamilyANDAssembly;  	break;  case PE.TypeAttributes.NestedFamORAssem:  	accessibility = Accessibility.FamilyORAssembly;  	break;  }  
Missing Default,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The following switch statement is missing a default case: switch (row.Flags & PE.TypeAttributes.LayoutMask) {  case PE.TypeAttributes.AutoLayout:  	layout = TypeLayout.Auto;  	break;  case PE.TypeAttributes.SequentialLayout:  	layout = TypeLayout.Sequential;  	break;  case PE.TypeAttributes.ExplicitLayout:  	layout = TypeLayout.Explicit;  	break;  }  
Missing Default,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The following switch statement is missing a default case: switch (row.Flags & PE.TypeAttributes.StringFormatMask) {  case PE.TypeAttributes.AnsiClass:  	stringFormat = StringFormat.Ansi;  	break;  case PE.TypeAttributes.UnicodeClass:  	stringFormat = StringFormat.Unicode;  	break;  case PE.TypeAttributes.AutoClass:  	stringFormat = StringFormat.Auto;  	break;  case PE.TypeAttributes.CustomFormatClass:  	stringFormat = StringFormat.Custom;  	break;  }  
