Implementation smell,Namespace,Class,File,Method,Description
Long Method,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,BasicBlockFromIndex,The method has 286 lines of code.
Long Method,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceBranch,The method has 376 lines of code.
Long Method,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceSwitch,The method has 125 lines of code.
Long Method,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceLooping,The method has 175 lines of code.
Long Method,Microsoft.LiveLabs.CST,Global,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,Global,The method has 150 lines of code.
Long Method,Microsoft.LiveLabs.CST,CallExpression,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,Simplify,The method has 112 lines of code.
Long Method,Microsoft.LiveLabs.CST,InstructionLoader,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The method has 750 lines of code.
Long Method,Microsoft.LiveLabs.CST,MachineStateInference,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The method has 576 lines of code.
Long Method,Microsoft.LiveLabs.CST,MachineStateInference,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,BackwardInstruction,The method has 160 lines of code.
Long Method,Microsoft.LiveLabs.CST,Peephole,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Peephole.cs,MoveNext,The method has 140 lines of code.
Long Method,Microsoft.LiveLabs.CST,PELoader,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeRefFromTypeSig,The method has 105 lines of code.
Long Method,Microsoft.LiveLabs.CST,PELoader,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,MethodDefFromRow,The method has 192 lines of code.
Long Method,Microsoft.LiveLabs.CST,PELoader,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The method has 426 lines of code.
Long Method,Microsoft.LiveLabs.CST,ValidityContext,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Validity.cs,PropogateInvalidity,The method has 121 lines of code.
Long Method,Microsoft.LiveLabs.CST,ValidityContext,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Validity.cs,Check,The method has 290 lines of code.
Long Method,Microsoft.LiveLabs.CST,Translator,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The method has 866 lines of code.
Long Method,Microsoft.LiveLabs.CST,Translator,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,CaseBody,The method has 150 lines of code.
Long Method,Microsoft.LiveLabs.CST,Translator,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,Translate,The method has 110 lines of code.
Long Method,Microsoft.LiveLabs.CST,MultiDimArrayTypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,MultiDimArrayTypeDef,The method has 126 lines of code.
Complex Method,Microsoft.LiveLabs.CST,Test,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\BasicBlock.cs,FromBranchOp,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.LiveLabs.CST,Test,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\BasicBlock.cs,FromCompareOp,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.CST,Test,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\BasicBlock.cs,Negate,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.CST,Test,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\BasicBlock.cs,ToCompareInstruction,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.CST,Test,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\BasicBlock.cs,Append,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.LiveLabs.CST,BasicBlock,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\BasicBlock.cs,CoalesceFrom,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.LiveLabs.CST,BBLoop,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\BasicBlockUtils.cs,BBLoop,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.LiveLabs.CST,BBLoop,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\BasicBlockUtils.cs,Append,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.LiveLabs.CST,VariableCell,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Cell.cs,AccumEffects,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,BuildTargetsFrom,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,BasicBlockFromIndex,Cyclomatic complexity of the method is 41
Complex Method,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceJump,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceBranch,Cyclomatic complexity of the method is 20
Complex Method,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceSwitch,Cyclomatic complexity of the method is 19
Complex Method,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceTry,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceNonLooping,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceLooping,Cyclomatic complexity of the method is 50
Complex Method,Microsoft.LiveLabs.CST,PointsTo,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Domain.cs,Append,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.CST,Effects,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Domain.cs,Append,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.LiveLabs.CST,UnaryExpression,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,Simplify,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.LiveLabs.CST,UnaryExpression,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,SimplifyLogNot,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.LiveLabs.CST,UnaryExpression,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,GetHashCode,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.LiveLabs.CST,BinaryExpression,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,SimplifyLogNot,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.CST,BinaryExpression,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,GetHashCode,Cyclomatic complexity of the method is 21
Complex Method,Microsoft.LiveLabs.CST,CallExpression,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,Simplify,Cyclomatic complexity of the method is 22
Complex Method,Microsoft.LiveLabs.CST,UnsupportedInstruction,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,AppendBody,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.LiveLabs.CST,MiscInstruction,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,AppendBody,Cyclomatic complexity of the method is 18
Complex Method,Microsoft.LiveLabs.CST,BranchInstruction,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,AppendBody,Cyclomatic complexity of the method is 16
Complex Method,Microsoft.LiveLabs.CST,CompareInstruction,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,AppendBody,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.LiveLabs.CST,ArgLocalInstruction,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,AppendBody,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.CST,MethodInstruction,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,AppendBody,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.LiveLabs.CST,TypeInstruction,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,AppendBody,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.LiveLabs.CST,ArithInstruction,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,AppendBody,Cyclomatic complexity of the method is 28
Complex Method,Microsoft.LiveLabs.CST,ConvInstruction,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,AppendBody,Cyclomatic complexity of the method is 21
Complex Method,Microsoft.LiveLabs.CST,InstructionLoader,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,Cyclomatic complexity of the method is 213
Complex Method,Microsoft.LiveLabs.CST,MachineState,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MachineState.cs,PeekDereferencableExpectedType,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.LiveLabs.CST,MachineStateInference,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,AddEffectiveInstructionTransitions,Cyclomatic complexity of the method is 21
Complex Method,Microsoft.LiveLabs.CST,MachineStateInference,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,Cyclomatic complexity of the method is 114
Complex Method,Microsoft.LiveLabs.CST,MachineStateInference,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardBlock,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.LiveLabs.CST,MachineStateInference,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,BackwardInstruction,Cyclomatic complexity of the method is 22
Complex Method,Microsoft.LiveLabs.CST,MemberDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,MarkAsUsed,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.CST,MemberDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,TopologicalTypeInit,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.CST,MethodDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,AccumUsedTypeAndMemberDefs,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.LiveLabs.CST,MethodDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,CheckValid,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.LiveLabs.CST,MethodDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,AppendDefinition,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.LiveLabs.CST,MethodDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,AppendModifiers,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.LiveLabs.CST,AssemblyName,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Name.cs,AssemblyName,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.CST,AssemblyName,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Name.cs,Equals,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.CST,AssemblyName,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Name.cs,CompareTo,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.LiveLabs.CST,AssemblyName,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Name.cs,FromReflectionName,Cyclomatic complexity of the method is 21
Complex Method,Microsoft.LiveLabs.CST,PELoader,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeRefFromPrimitiveTypeName,Cyclomatic complexity of the method is 20
Complex Method,Microsoft.LiveLabs.CST,PELoader,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeRefFromTypeSig,Cyclomatic complexity of the method is 21
Complex Method,Microsoft.LiveLabs.CST,PELoader,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeRefFromRow,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.LiveLabs.CST,PELoader,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,ArgsAndResultFromMethodSig,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.LiveLabs.CST,PELoader,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,MethodRefFromRowWithTypeArgs,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.LiveLabs.CST,PELoader,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,FieldDefFromRow,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.LiveLabs.CST,PELoader,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,ParameterTypeDefFromRow,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.CST,PELoader,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,ResolveRow,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.LiveLabs.CST,PELoader,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,MethodDefFromRow,Cyclomatic complexity of the method is 34
Complex Method,Microsoft.LiveLabs.CST,PELoader,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,Cyclomatic complexity of the method is 55
Complex Method,Microsoft.LiveLabs.CST,PELoader,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,MergeAssemblyDefs,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.LiveLabs.CST,PELoader,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,PropertyTypeFromTypeRef,Cyclomatic complexity of the method is 23
Complex Method,Microsoft.LiveLabs.CST,PELoader,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,CustomAttributeFromRow,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.CST,PELoader,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,LoadCustomAttributes,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.CST,MethodSignature,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Signature.cs,Append,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.CST,ValidityContext,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Validity.cs,PropogateInvalidity,Cyclomatic complexity of the method is 29
Complex Method,Microsoft.LiveLabs.CST,ValidityContext,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Validity.cs,Stats,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.CST,ValidityContext,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Validity.cs,Check,Cyclomatic complexity of the method is 24
Complex Method,Microsoft.LiveLabs.CST,Translator,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,ArithOpToBinaryOp,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.LiveLabs.CST,Translator,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateHandlers,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.LiveLabs.CST,Translator,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,Cyclomatic complexity of the method is 147
Complex Method,Microsoft.LiveLabs.CST,Translator,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,CaseBody,Cyclomatic complexity of the method is 31
Complex Method,Microsoft.LiveLabs.CST,Translator,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,Translate,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.LiveLabs.CST,TypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PropogateInvalidity,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.LiveLabs.CST,TypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceIsAssignableTo,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.LiveLabs.CST,DerivingTypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceRespectsParameterConstraint,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.LiveLabs.CST,ParameterTypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceRespectsParameterConstraint,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.LiveLabs.CST,ParameterTypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimIsValidParameterBinding,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.LiveLabs.CST,ParameterTypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,AppendDefinition,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.LiveLabs.CST,NamedTypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,NamedTypeDef,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.CST,NamedTypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,AccumUsedTypeDefs,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.LiveLabs.CST,NamedTypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,MarkAsUsed,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.LiveLabs.CST,RealTypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,CompleteSlotImplementations,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.CST,EnumTypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,EnumTypeDef,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.LiveLabs.CST,NamedTypeRef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeRef.cs,RuntimeFlavor,Cyclomatic complexity of the method is 9
Long Parameter List,Microsoft.LiveLabs.CST,AssemblyDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\AssemblyDef.cs,AssemblyDef,The method has 7 parameters. Parameters: global' annotations' customAttributes' name' references' types' entryPoint
Long Parameter List,Microsoft.LiveLabs.CST,LeaveTryBasicBlock,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\BasicBlock.cs,LeaveTryBasicBlock,The method has 5 parameters. Parameters: id' block' tryblock' handlerPopCount' stackPopCount
Long Parameter List,Microsoft.LiveLabs.CST,LeaveCatchBasicBlock,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\BasicBlock.cs,LeaveCatchBasicBlock,The method has 5 parameters. Parameters: id' block' handler' handlerPopCount' stackPopCount
Long Parameter List,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,BreakReduceJump,The method has 6 parameters. Parameters: root' loop' breakTarget' jumpbb' removed' added
Long Parameter List,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,BreakReduceBranch,The method has 6 parameters. Parameters: root' loop' breakTarget' branchbb' removed' added
Long Parameter List,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,BreakReduceLeaveTry,The method has 6 parameters. Parameters: root' loop' breakTarget' leavebb' removed' added
Long Parameter List,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,BreakReduceLeaveCatch,The method has 6 parameters. Parameters: root' loop' breakTarget' leavebb' removed' added
Long Parameter List,Microsoft.LiveLabs.CST,Effects,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Domain.cs,Effects,The method has 7 parameters. Parameters: argsIsRead' argsIsWrite' localsIsRead' localsIsWrite' heapIsRead' heapIsWrite' exceptions
Long Parameter List,Microsoft.LiveLabs.CST,Effects,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Domain.cs,MakeArgLocal,The method has 6 parameters. Parameters: nArgs' nLocals' argLocal' index' isWrite' couldThrow
Long Parameter List,Microsoft.LiveLabs.CST,TypeEnvironment,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,TypeEnvironment,The method has 5 parameters. Parameters: global' skolemDefs' assembly' type' typeBoundArguments
Long Parameter List,Microsoft.LiveLabs.CST,FieldEnvironment,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,FieldEnvironment,The method has 6 parameters. Parameters: global' skolemDefs' assembly' type' typeBoundArguments' field
Long Parameter List,Microsoft.LiveLabs.CST,EventEnvironment,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,EventEnvironment,The method has 6 parameters. Parameters: global' skolemDefs' assembly' type' typeBoundArguments' evnt
Long Parameter List,Microsoft.LiveLabs.CST,PropertyEnvironment,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,PropertyEnvironment,The method has 6 parameters. Parameters: global' skolemDefs' assembly' type' typeBoundArguments' property
Long Parameter List,Microsoft.LiveLabs.CST,PolymorphicMethodEnvironment,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,PolymorphicMethodEnvironment,The method has 6 parameters. Parameters: global' skolemDefs' assembly' type' typeBoundArguments' method
Long Parameter List,Microsoft.LiveLabs.CST,MethodEnvironment,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,MethodEnvironment,The method has 7 parameters. Parameters: global' skolemDefs' assembly' type' typeBoundArguments' method' methodBoundArguments
Long Parameter List,Microsoft.LiveLabs.CST,CompilationEnvironment,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,CompilationEnvironment,The method has 10 parameters. Parameters: global' skolemDefs' assembly' type' typeBoundArguments' method' methodBoundArguments' variables' valueParameterIds' localIds
Long Parameter List,Microsoft.LiveLabs.CST,CompilationEnvironment,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,AddVariable,The method has 5 parameters. Parameters: id' argLocal' isInit' isReadOnly' type
Long Parameter List,Microsoft.LiveLabs.CST,BinaryExpression,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,BinaryExpression,The method has 5 parameters. Parameters: leftValue' op' rightValue' withOverflow' isUnsigned
Long Parameter List,Microsoft.LiveLabs.CST,ExpressionStack,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\ExpressionStack.cs,ExpressionStack,The method has 5 parameters. Parameters: compEnv' bottom' gensym' state' trace
Long Parameter List,Microsoft.LiveLabs.CST,ExpressionStack,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\ExpressionStack.cs,PopEvalPushSE,The method has 5 parameters. Parameters: statements' arity' isLinear' bodyEffects' f
Long Parameter List,Microsoft.LiveLabs.CST,ExpressionStack,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\ExpressionStack.cs,PopEvalSE,The method has 5 parameters. Parameters: statements' arity' isLinear' bodyEffects' f
Long Parameter List,Microsoft.LiveLabs.CST,Instruction,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,CalcStackChange,The method has 5 parameters. Parameters: depth' pops' pushes' thisPops' thisPushes
Long Parameter List,Microsoft.LiveLabs.CST,MethodInstruction,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,MethodInstruction,The method has 5 parameters. Parameters: offset' op' constrained' isVirtual' method
Long Parameter List,Microsoft.LiveLabs.CST,ArgsLocalsState,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MachineState.cs,PropogateBackwards,The method has 5 parameters. Parameters: other' argLocal' index' isAlive' changed
Long Parameter List,Microsoft.LiveLabs.CST,MachineStateInference,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,BackwardInstruction,The method has 5 parameters. Parameters: context' index' beforeState' afterState' changed
Long Parameter List,Microsoft.LiveLabs.CST,MemberDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,TopologicalAllDeps,The method has 5 parameters. Parameters: global' assemblyDef' typeDef' visitedMemberDefs' sortedMemberDefs
Long Parameter List,Microsoft.LiveLabs.CST,MemberDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,UsedByMembersClosure,The method has 5 parameters. Parameters: global' assemblyDef' typeDef' visitedMemberDefs' scc
Long Parameter List,Microsoft.LiveLabs.CST,MemberDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,TopologicalTypeInit,The method has 6 parameters. Parameters: global' assemblyDef' typeDef' visitedTypeDefs' sortedTypeDefs' visitedMemberDefs
Long Parameter List,Microsoft.LiveLabs.CST,MemberDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,TopologicalTypeInitFromImplementors,The method has 6 parameters. Parameters: global' assemblyDef' typeDef' visitedTypeDefs' sortedTypeDefs' visitedMemberDefs
Long Parameter List,Microsoft.LiveLabs.CST,MethodDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,MethodDef,The method has 15 parameters. Parameters: annotations' customAttributes' name' isStatic' typeParameters' valueParameters' result' methodStyle' hasNewSlot' codeFlavor' isSyncronized' noInlining' isInitLocals' locals' methodBody
Long Parameter List,Microsoft.LiveLabs.CST,MethodDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,PrimMethodReference,The method has 5 parameters. Parameters: global' assemblyDef' typeDef' typeBoundArguments' methodBoundArguments
Long Parameter List,Microsoft.LiveLabs.CST,MethodDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,TopologicalTypeInitFromImplementors,The method has 6 parameters. Parameters: global' assemblyDef' typeDef' visitedTypeDefs' sortedTypeDefs' visitedMemberDefs
Long Parameter List,Microsoft.LiveLabs.CST,FieldDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,FieldDef,The method has 6 parameters. Parameters: annotations' customAttributes' name' isStatic' fieldType' init
Long Parameter List,Microsoft.LiveLabs.CST,EventDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,EventDef,The method has 7 parameters. Parameters: annotations' customAttributes' name' isStatic' add' remove' handlerType
Long Parameter List,Microsoft.LiveLabs.CST,PropertyDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,PropertyDef,The method has 7 parameters. Parameters: annotations' customAttributes' name' isStatic' get' set' fieldType
Long Parameter List,Microsoft.LiveLabs.CST,PolymorphicMethodRef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MemberRef.cs,PolymorphicMethodRef,The method has 7 parameters. Parameters: annotations' definingType' name' isStatic' typeArity' valueParameters' result
Long Parameter List,Microsoft.LiveLabs.CST,PolymorphicMethodRef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MemberRef.cs,PolymorphicMethodRef,The method has 6 parameters. Parameters: definingType' name' isStatic' typeArity' valueParameters' result
Long Parameter List,Microsoft.LiveLabs.CST,MethodRef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MemberRef.cs,MethodRef,The method has 7 parameters. Parameters: annotations' definingType' name' isStatic' methodTypeArguments' valueParameters' result
Long Parameter List,Microsoft.LiveLabs.CST,MethodRef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MemberRef.cs,MethodRef,The method has 6 parameters. Parameters: definingType' name' isStatic' methodTypeArguments' valueParameters' result
Long Parameter List,Microsoft.LiveLabs.CST,PropertyRef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MemberRef.cs,PropertyRef,The method has 6 parameters. Parameters: annotations' definingType' name' isStatic' parameters' result
Long Parameter List,Microsoft.LiveLabs.CST,PropertyRef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MemberRef.cs,PropertyRef,The method has 5 parameters. Parameters: definingType' name' isStatic' parameters' result
Long Parameter List,Microsoft.LiveLabs.CST,MessageContextBuilders,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MessageContextBuilders.cs,Member,The method has 5 parameters. Parameters: parent' global' assemblyDef' typeDef' memberDef
Long Parameter List,Microsoft.LiveLabs.CST,AssemblyName,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Name.cs,AssemblyName,The method has 9 parameters. Parameters: resolution' name' majorVersion' minorVersion' buildNumber' revisionNumber' culture' publicKeyToken' redirectFrom
Long Parameter List,Microsoft.LiveLabs.CST,AssemblyName,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Name.cs,AssemblyName,The method has 8 parameters. Parameters: resolution' name' majorVersion' minorVersion' buildNumber' revisionNumber' culture' publicKeyToken
Long Parameter List,Microsoft.LiveLabs.CST,DllLoadContext,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,DllLoadContext,The method has 5 parameters. Parameters: canonicalFileName' file' readerContext' assemblyRow' assemblyName
Long Parameter List,Microsoft.LiveLabs.CST,PELoader,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,ArgsAndResultFromMethodSig,The method has 7 parameters. Parameters: ctxt' definingTypeRef' name' isStatic' valueParameters' result' sig
Long Parameter List,Microsoft.LiveLabs.CST,PELoader,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,MethodRefFromMethodSig,The method has 7 parameters. Parameters: ctxt' definingTypeRef' name' isStatic' methodBoundArguments' arity' sig
Long Parameter List,Microsoft.LiveLabs.CST,PELoader,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,SignatureFromMethodSig,The method has 5 parameters. Parameters: ctxt' definingTypeRef' name' isStatic' sig
Long Parameter List,Microsoft.LiveLabs.CST,MethodSignature,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Signature.cs,MethodSignature,The method has 5 parameters. Parameters: name' isStatic' typeArity' parameters' result
Long Parameter List,Microsoft.LiveLabs.CST,SimplifierContext,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\SimplifierContext.cs,SimplifierContext,The method has 7 parameters. Parameters: compEnv' nameSupply' subst' statements' contextEffects' database' trace
Long Parameter List,Microsoft.LiveLabs.CST,ValidityContext,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Validity.cs,ImplementableInstruction,The method has 5 parameters. Parameters: ctxt' assemblyDef' typeDef' methodDef' instruction
Long Parameter List,Microsoft.LiveLabs.CST,Variable,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Variable.cs,Variable,The method has 5 parameters. Parameters: id' argLocal' isInit' isReadOnly' type
Long Parameter List,Microsoft.LiveLabs.CST,TypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimAreValidArguments,The method has 5 parameters. Parameters: vctxt' ctxt' originalType' groundEnv' groundTypeBoundArguments
Long Parameter List,Microsoft.LiveLabs.CST,TypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceRespectsParameterConstraint,The method has 7 parameters. Parameters: vctxt' ctxt' originalType' groundEnv' groundTypeBoundArguments' constraint' inCodePointer
Long Parameter List,Microsoft.LiveLabs.CST,TypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceIsAssignableTo,The method has 6 parameters. Parameters: groundEnv' thisAssembly' thisGroundTypeBoundArguments' otherAssembly' otherDef' otherGroundTypeBoundArguments
Long Parameter List,Microsoft.LiveLabs.CST,PointerTypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceRespectsParameterConstraint,The method has 7 parameters. Parameters: vctxt' ctxt' originalType' groundEnv' groundTypeBoundArguments' constraint' inCodePointer
Long Parameter List,Microsoft.LiveLabs.CST,PointerTypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceIsAssignableTo,The method has 6 parameters. Parameters: groundEnv' thisAssembly' thisGroundThisThisGroundTypeArguments' otherAssembly' otherDef' otherGroundGroundTypeArguments
Long Parameter List,Microsoft.LiveLabs.CST,CodePointerTypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceRespectsParameterConstraint,The method has 7 parameters. Parameters: vctxt' ctxt' originalType' groundEnv' groundTypeBoundArguments' constraint' inCodePointer
Long Parameter List,Microsoft.LiveLabs.CST,ArrayTypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceRespectsParameterConstraint,The method has 7 parameters. Parameters: vctxt' ctxt' originalType' groundEnv' groundTypeBoundArguments' constraint' inCodePointer
Long Parameter List,Microsoft.LiveLabs.CST,MultiDimArrayTypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceRespectsParameterConstraint,The method has 7 parameters. Parameters: vctxt' ctxt' originalType' groundEnv' groundTypeBoundArguments' constraint' inCodePointer
Long Parameter List,Microsoft.LiveLabs.CST,MultiDimArrayTypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceIsAssignableTo,The method has 6 parameters. Parameters: groundEnv' thisAssembly' thisGroundTypeBoundArguments' otherAssembly' otherDef' otherGroundTypeBoundArguments
Long Parameter List,Microsoft.LiveLabs.CST,BoxTypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceRespectsParameterConstraint,The method has 7 parameters. Parameters: vctxt' ctxt' originalType' groundEnv' groundTypeBoundArguments' constraint' inCodePointer
Long Parameter List,Microsoft.LiveLabs.CST,NullTypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceRespectsParameterConstraint,The method has 7 parameters. Parameters: vctxt' ctxt' originalType' groundEnv' groundTypeBoundArguments' constraint' inCodePointer
Long Parameter List,Microsoft.LiveLabs.CST,NullTypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceIsAssignableTo,The method has 6 parameters. Parameters: groundEnv' thisAssembly' thisThisGroundTypeArguments' otherAssembly' otherDef' otherGroundTypeArguments
Long Parameter List,Microsoft.LiveLabs.CST,DerivingTypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceRespectsParameterConstraint,The method has 7 parameters. Parameters: vctxt' ctxt' originalType' groundEnv' groundTypeBoundArguments' constraint' inCodePointer
Long Parameter List,Microsoft.LiveLabs.CST,ParameterTypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,ParameterTypeDef,The method has 8 parameters. Parameters: annotations' customAttributes' extends' implements' parameterFlavor' index' variance' constraint
Long Parameter List,Microsoft.LiveLabs.CST,ParameterTypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceRespectsParameterConstraint,The method has 7 parameters. Parameters: vctxt' ctxt' originalType' groundEnv' groundTypeBoundArguments' constraint' inCodePointer
Long Parameter List,Microsoft.LiveLabs.CST,ParameterTypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimIsValidParameterBinding,The method has 7 parameters. Parameters: vctxt' ctxt' originalType' groundEnv' groundTypeBoundArguments' groundMethodBoundArguments' inCodePointer
Long Parameter List,Microsoft.LiveLabs.CST,NamedTypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,NamedTypeDef,The method has 7 parameters. Parameters: annotations' customAttributes' extends' implements' parameters' name' members
Long Parameter List,Microsoft.LiveLabs.CST,RealTypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,RealTypeDef,The method has 11 parameters. Parameters: annotations' customAttributes' extends' implements' parameters' name' members' explicitInterfaceImplementations' isSealed' isAbstract' isCallStaticConstructorEarly
Long Parameter List,Microsoft.LiveLabs.CST,StructTypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,StructTypeDef,The method has 9 parameters. Parameters: annotations' customAttributes' extends' implements' parameters' name' members' slotImplementations' isCallStaticConstructorEarly
Long Parameter List,Microsoft.LiveLabs.CST,VoidTypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,VoidTypeDef,The method has 9 parameters. Parameters: annotations' customAttributes' extends' implements' parameters' name' members' slotImplementations' isCallStaticConstructorEarly
Long Parameter List,Microsoft.LiveLabs.CST,VoidTypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceIsAssignableTo,The method has 6 parameters. Parameters: groundEnv' thisAssembly' thisTypeArguments' otherAssembly' otherDef' otherTypeArguments
Long Parameter List,Microsoft.LiveLabs.CST,VoidTypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceRespectsParameterConstraint,The method has 7 parameters. Parameters: vctxt' ctxt' originalType' groundEnv' groundTypeBoundArguments' constraint' inCodePointer
Long Parameter List,Microsoft.LiveLabs.CST,NumberTypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,NumberTypeDef,The method has 10 parameters. Parameters: annotations' customAttributes' extends' implements' parameters' name' members' numberFlavor' slotImplementations' isCallStaticConstructorEarly
Long Parameter List,Microsoft.LiveLabs.CST,HandleTypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,HandleTypeDef,The method has 10 parameters. Parameters: annotations' customAttributes' extends' implements' parameters' name' members' handleFlavor' slotImplementations' isCallStaticConstructorEarly
Long Parameter List,Microsoft.LiveLabs.CST,NullableTypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,NullableTypeDef,The method has 9 parameters. Parameters: annotations' customAttributes' extends' implements' parameters' name' members' slotImplementations' isCallStaticConstructorEarly
Long Parameter List,Microsoft.LiveLabs.CST,NullableTypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceRespectsParameterConstraint,The method has 7 parameters. Parameters: vctxt' ctxt' originalType' groundEnv' groundTypeBoundArguments' constraint' inCodePointer
Long Parameter List,Microsoft.LiveLabs.CST,EnumTypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,EnumTypeDef,The method has 8 parameters. Parameters: annotations' customAttributes' extends' implements' name' members' slotImplementations' isCallStaticConstructorEarly
Long Parameter List,Microsoft.LiveLabs.CST,DelegateTypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,DelegateTypeDef,The method has 9 parameters. Parameters: annotations' customAttributes' extends' implements' parameters' name' members' slotImplementations' isCallStaticConstructorEarly
Long Parameter List,Microsoft.LiveLabs.CST,ClassTypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,ClassTypeDef,The method has 11 parameters. Parameters: annotations' customAttributes' extends' implements' parameters' name' members' slotImplementations' isSealed' isAbstract' isCallStaticConstructorEarly
Long Parameter List,Microsoft.LiveLabs.CST,ObjectTypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,ObjectTypeDef,The method has 9 parameters. Parameters: annotations' customAttributes' extends' implements' parameters' name' members' slotImplementations' isCallStaticConstructorEarly
Long Parameter List,Microsoft.LiveLabs.CST,StringTypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,StringTypeDef,The method has 9 parameters. Parameters: annotations' customAttributes' extends' implements' parameters' name' members' slotImplementations' isCallStaticConstructorEarly
Long Parameter List,Microsoft.LiveLabs.CST,InterfaceTypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,InterfaceTypeDef,The method has 6 parameters. Parameters: annotations' customAttributes' implements' parameters' name' members
Long Parameter List,Microsoft.LiveLabs.CST,InterfaceTypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceIsAssignableTo,The method has 6 parameters. Parameters: groundEnv' thisAssembly' thisTypeArguments' otherAssembly' otherDef' otherTypeArguments
Long Parameter List,Microsoft.LiveLabs.CST,GenericIEnumerableTypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,GenericIEnumerableTypeDef,The method has 6 parameters. Parameters: annotations' customAttributes' implements' parameters' name' members
Long Identifier,Microsoft.LiveLabs.CST,Constants,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Constants.cs,,The length of the parameter EmptyTryPsuedoStatementHandlers is 31.
Long Identifier,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceSwitch,The length of the parameter allIntermediateAreNonReturningOrJumpToTarget is 44.
Long Identifier,Microsoft.LiveLabs.CST,Global,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,,The length of the parameter ManagedPointerTypeConstructorDef is 32.
Long Identifier,Microsoft.LiveLabs.CST,Global,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,,The length of the parameter ManagedPointerTypeConstructorRef is 32.
Long Identifier,Microsoft.LiveLabs.CST,Global,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,,The length of the parameter UnmanagedPointerTypeConstructorDef is 34.
Long Identifier,Microsoft.LiveLabs.CST,Global,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,,The length of the parameter UnmanagedPointerTypeConstructorRef is 34.
Long Identifier,Microsoft.LiveLabs.CST,Global,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,,The length of the parameter multiDimArrayTypeConstructorDefs is 32.
Long Identifier,Microsoft.LiveLabs.CST,Global,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,,The length of the parameter QualifiedTypeNameToAbbreviation is 31.
Long Identifier,Microsoft.LiveLabs.CST,Global,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,,The length of the parameter QualifiedTypeNameToNumberFlavor is 31.
Long Identifier,Microsoft.LiveLabs.CST,Global,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,,The length of the parameter NumberFlavorToQualifiedTypeName is 31.
Long Identifier,Microsoft.LiveLabs.CST,Global,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,,The length of the parameter QualifiedTypeNameToHandleFlavor is 31.
Long Identifier,Microsoft.LiveLabs.CST,Global,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,,The length of the parameter HandleFlavorToQualifiedTypeName is 31.
Long Identifier,Microsoft.LiveLabs.CST,PELoader,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The length of the parameter explicitInterfaceImplementationRows is 35.
Long Identifier,Microsoft.LiveLabs.CST,PELoader,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The length of the parameter explicitInterfaceImplementations is 32.
Long Identifier,Microsoft.LiveLabs.CST,PELoader,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,,The length of the parameter knownUnavailableCustomAttributeTypes is 36.
Long Identifier,Microsoft.LiveLabs.CST,Translator,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,,The length of the parameter instructionTranslationStyleCache is 32.
Long Identifier,Microsoft.LiveLabs.CST,Translator,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,,The length of the parameter labelToLoopCandidateContinueState is 33.
Long Identifier,Microsoft.LiveLabs.CST,Translator,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,,The length of the parameter labelToLoopCandidateBreakState is 30.
Long Identifier,Microsoft.LiveLabs.CST,PointerTypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceIsAssignableTo,The length of the parameter thisGroundThisThisGroundTypeArguments is 37.
Long Identifier,Microsoft.LiveLabs.CST,PointerTypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceIsAssignableTo,The length of the parameter otherGroundGroundTypeArguments is 30.
Long Identifier,Microsoft.LiveLabs.CST,RealTypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,RealTypeDef,The length of the parameter explicitInterfaceImplementations is 32.
Long Identifier,Microsoft.LiveLabs.CST,RealTypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,,The length of the parameter ExplicitInterfaceImplementations is 32.
Long Statement,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceLooping,The length of the statement  "                                var loopbb = new LoopCandidateBasicBlock(nextBlockId++' loop.Label' loop.Head.Block.BeforeState) { Head = loop.Head' Break = candidateBreakTarget }; " is 148.
Long Statement,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,Root,The length of the statement  "            var root = new RootBasicBlock(nextBlockId++' new MachineState(methEnv' method.ValueParameters.Count' method.Locals.Count)); " is 123.
Long Statement,Microsoft.LiveLabs.CST,PointsTo,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Domain.cs,ReadEffect,The length of the statement  "                return new Effects(Args.Members.Clone()' new IntSet(NumArgs)' Locals.Members.Clone()' new IntSet(NumLocals)' Heap.Value' false' false); " is 135.
Long Statement,Microsoft.LiveLabs.CST,PointsTo,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Domain.cs,WriteEffect,The length of the statement  "                return new Effects(Args.Members.Clone()' Args.Members.Clone()' Locals.Members.Clone()' Locals.Members.Clone()' Heap.Value' Heap.Value' false); " is 142.
Long Statement,Microsoft.LiveLabs.CST,TypeConstructorEnvironment,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,AddSelfTypeBoundArguments,The length of the statement  "                var typeBoundSkolemDefs = Type.Parameters.Select(p => new SkolemDef(Assembly' Type' p.PrimSubstitute(typeBoundArguments' null))); " is 129.
Long Statement,Microsoft.LiveLabs.CST,MethodEnvironment,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,AddVariables,The length of the statement  "            return new CompilationEnvironment(Global' SkolemDefs' Assembly' Type' TypeBoundArguments' Method' MethodBoundArguments' variables' valueParameterIds' localIds); " is 160.
Long Statement,Microsoft.LiveLabs.CST,ExpressionStack,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\ExpressionStack.cs,Dump,The length of the statement  "                compEnv.AddVariable(id' ArgLocal.Local' false' true' compEnv.SubstituteType(state.PeekType(stack.Count - (1 + skip) - i))); " is 123.
Long Statement,Microsoft.LiveLabs.CST,ExpressionStack,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\ExpressionStack.cs,Restore,The length of the statement  "                    (id' ArgLocal.Local' false' true' compEnv.SubstituteType(stateAfterRestore.PeekType(stateAfterRestore.Depth - skip - 1 - i))); " is 126.
Long Statement,Microsoft.LiveLabs.CST,Instructions,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,AccumUsedTypeAndMemberDefs,The length of the statement  "            return Body.Select(i => i.AccumUsedTypeAndMemberDefs(vctxt' ctxt' usedTypes' usedMembers)).FirstOrDefault(v => v != null); " is 122.
Long Statement,Microsoft.LiveLabs.CST,BranchInstruction,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,Clone,The length of the statement  "            return new BranchInstruction(nextInstructionId--' Op' IsUnsigned' Target) { BeforeState = BeforeState' AfterState = AfterState' Type = Type }; " is 142.
Long Statement,Microsoft.LiveLabs.CST,CompareInstruction,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,Clone,The length of the statement  "            return new CompareInstruction(nextInstructionId--' Op' IsUnsigned) { BeforeState = BeforeState' AfterState = AfterState' Type = Type }; " is 135.
Long Statement,Microsoft.LiveLabs.CST,ArgLocalInstruction,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,Clone,The length of the statement  "            return new ArgLocalInstruction(nextInstructionId--' Op' ArgLocal' Index) { BeforeState = BeforeState' AfterState = AfterState }; " is 128.
Long Statement,Microsoft.LiveLabs.CST,FieldInstruction,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,Clone,The length of the statement  "            return new FieldInstruction(nextInstructionId--' Op' Field' IsStatic) { BeforeState = BeforeState' AfterState = AfterState' IsViaPointer = IsViaPointer }; " is 154.
Long Statement,Microsoft.LiveLabs.CST,MethodInstruction,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,Clone,The length of the statement  "            return new MethodInstruction(nextInstructionId--' Op' Constrained' IsVirtual' Method) { BeforeState = BeforeState' AfterState = AfterState }; " is 141.
Long Statement,Microsoft.LiveLabs.CST,LdElemAddrInstruction,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,Clone,The length of the statement  "            return new LdElemAddrInstruction(nextInstructionId--' IsReadonly' Type) { BeforeState = BeforeState' AfterState = AfterState }; " is 127.
Long Statement,Microsoft.LiveLabs.CST,ArithInstruction,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,Clone,The length of the statement  "            return new ArithInstruction(nextInstructionId--' Op' WithOverflow' IsUnsigned) { BeforeState = BeforeState' AfterState = AfterState' Type = Type }; " is 147.
Long Statement,Microsoft.LiveLabs.CST,ConvInstruction,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,Clone,The length of the statement  "            return new ConvInstruction(nextInstructionId--' TargetNumberFlavor' WithOverflow' IsSourceUnsigned) { BeforeState = BeforeState' AfterState = AfterState' SourceType = SourceType }; " is 180.
Long Statement,Microsoft.LiveLabs.CST,TryInstruction,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,Clone,The length of the statement  "            return new TryInstruction(nextInstructionId--' Body.Clone(ref nextInstructionId)' newHandlers) { BeforeState = BeforeState' AfterState = AfterState }; " is 150.
Long Statement,Microsoft.LiveLabs.CST,IfThenElseInstruction,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,IsInlinable,The length of the statement  "            return Condition.IsInlinable(ref numReturns) && Then.IsInlinable(ref numReturns) && (Else == null || Else.IsInlinable(ref numReturns)); " is 135.
Long Statement,Microsoft.LiveLabs.CST,DoWhileInstruction,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,Clone,The length of the statement  "                (nextInstructionId--' Body.Clone(ref nextInstructionId)' Condition.Clone(ref nextInstructionId)) { BeforeState = BeforeState' AfterState = AfterState }; " is 152.
Long Statement,Microsoft.LiveLabs.CST,BreakContinueInstruction,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,Clone,The length of the statement  "            return new BreakContinueInstruction(nextInstructionId--' Op' Label) { BeforeState = BeforeState' AfterState = AfterState }; " is 123.
Long Statement,Microsoft.LiveLabs.CST,MachineState,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MachineState.cs,CloneWithArgLocalPointsTo,The length of the statement  "            return new MachineState(RootEnv' nArgs' nLocals' innerState.Value.CloneWithArgLocalPointsTo(stack' argLocal' index' pointsTo)); " is 127.
Long Statement,Microsoft.LiveLabs.CST,MachineState,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MachineState.cs,PropogateBackwards,The length of the statement  "            innerState.Value.ArgsLocalsState.PropogateBackwards(nextState.innerState.Value.ArgsLocalsState' default(ArgLocal)' -1' false' changed); " is 135.
Long Statement,Microsoft.LiveLabs.CST,MachineState,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MachineState.cs,WriteArgLocal,The length of the statement  "            innerState.Value.ArgsLocalsState.PropogateBackwards(nextState.innerState.Value.ArgsLocalsState' argLocal' index' false' changed); " is 129.
Long Statement,Microsoft.LiveLabs.CST,MachineState,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MachineState.cs,ReadArgLocal,The length of the statement  "            innerState.Value.ArgsLocalsState.PropogateBackwards(nextState.innerState.Value.ArgsLocalsState' argLocal' index' true' changed); " is 128.
Long Statement,Microsoft.LiveLabs.CST,MachineStateInference,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The length of the statement  "                        return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(type)' ArgLocalPT(argi.ArgLocal' argi.Index)); " is 124.
Long Statement,Microsoft.LiveLabs.CST,AssemblyName,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Name.cs,Append,The length of the statement  "            if (w.Global.AssemblyNameResolution == AssemblyNameResolution.Full || w.Global.AssemblyNameResolution == AssemblyNameResolution.NameVersion) " is 140.
Long Statement,Microsoft.LiveLabs.CST,AssemblyName,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Name.cs,Equals,The length of the statement  "            if (MajorVersion != other.MajorVersion || MinorVersion != other.MinorVersion || BuildNumber != other.BuildNumber || RevisionNumber != other.RevisionNumber) " is 155.
Long Statement,Microsoft.LiveLabs.CST,AssemblyName,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Name.cs,FromReflectionName,The length of the statement  "            return new AssemblyName(resolution' name' majorVersion' minorVersion' buildNumber' revisionNumber' culture' publicKeyToken); " is 124.
Long Statement,Microsoft.LiveLabs.CST,Peephole,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Peephole.cs,MoveNext,The length of the statement  "                                        lookahead[0] = new CompareInstruction(compj.Offset' CompareOp.CtruePseudo' false) { Type = compj.Type' BeforeState = ldinti.BeforeState' AfterState = compj.AfterState }; " is 169.
Long Statement,Microsoft.LiveLabs.CST,Peephole,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Peephole.cs,MoveNext,The length of the statement  "                                        lookahead[0] = new CompareInstruction(compj.Offset' CompareOp.CfalsePseudo' false) { Type = compj.Type' BeforeState = ldinti.BeforeState' AfterState = compj.AfterState }; " is 170.
Long Statement,Microsoft.LiveLabs.CST,Peephole,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Peephole.cs,MoveNext,The length of the statement  "                                        lookahead[0] = new CompareInstruction(compj.Offset' CompareOp.CtruePseudo' false) { Type = compj.Type' BeforeState = misci.BeforeState' AfterState = compj.AfterState }; " is 168.
Long Statement,Microsoft.LiveLabs.CST,Peephole,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Peephole.cs,MoveNext,The length of the statement  "                                        lookahead[0] = new CompareInstruction(compj.Offset' CompareOp.CfalsePseudo' false) { Type = compj.Type' BeforeState = misci.BeforeState' AfterState = compj.AfterState }; " is 169.
Long Statement,Microsoft.LiveLabs.CST,DllLoader,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,AssemblyNameFromAssemblyRow,The length of the statement  "            return new AssemblyName(resolution' row.Name.Value' row.MajorVersion' row.MinorVersion' row.BuildNumber' row.RevisionNumber' row.Culture.Value' row.PublicKey.Value); " is 165.
Long Statement,Microsoft.LiveLabs.CST,PELoader,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeRefFromTypeSig,The length of the statement  "                    return global.UnmanagedPointerTypeConstructorRef.ApplyTo(TypeRefFromTypeSigWithCustomMods(ctxt' unmanPtrSig.ElementType)); " is 122.
Long Statement,Microsoft.LiveLabs.CST,PELoader,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeRefFromTypeSig,The length of the statement  "                    return global.ManagedPointerTypeConstructorRef.ApplyTo(annotations' TypeRefFromTypeSig(ctxt' null' manPtrSig.ElementType' true)); " is 129.
Long Statement,Microsoft.LiveLabs.CST,PELoader,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeRefFromTypeSig,The length of the statement  "                    return global.ArrayTypeConstructorRef.ApplyTo(annotations' TypeRefFromTypeSigWithCustomMods(ctxt' arrayTypeSig.ElementType)); " is 125.
Long Statement,Microsoft.LiveLabs.CST,PELoader,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,ArgsAndResultFromMethodSig,The length of the statement  "            if (definingTypeRef.Arguments.Count == 1 && !isStatic && (name.Equals("Set"' StringComparison.Ordinal) || name.Equals("Get"' StringComparison.Ordinal)) && " is 154.
Long Statement,Microsoft.LiveLabs.CST,PELoader,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The length of the statement  "            if (extends != null && (extends.Equals(global.EnumRef) || (!thisTypeRef.Equals(global.EnumRef) && extends.Equals(global.ValueTypeRef)))) " is 136.
Long Statement,Microsoft.LiveLabs.CST,PELoader,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeRefToPropertyTypeName,The length of the statement  "                throw new InvalidOperationException("only types without type arguments may be used as custom attribute property types"); " is 120.
Long Statement,Microsoft.LiveLabs.CST,ValidityContext,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Validity.cs,Stats,The length of the statement  "                tracer.AppendLine(String.Format("{0}: {1} assemblies' {2} types ({3} valid' {4} used)' {5} members ({6} valid' {7} used)"' msg' nAssemblies' nTypes' nValidTypes' nUsedTypes' nMembers' nValidMembers' nUsedMembers)); " is 214.
Long Statement,Microsoft.LiveLabs.CST,ValidityContext,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Validity.cs,Check,The length of the statement  "                    //  - virtual/iface method must have a def and used implementing type => used override/impl methods of that type must have a def " is 128.
Long Statement,Microsoft.LiveLabs.CST,Variable,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Variable.cs,Equals,The length of the statement  "            return Id.Equals(other.Id) && ArgLocal == other.ArgLocal && IsInit == other.IsInit && IsReadOnly == other.IsReadOnly && Type.Equals(other.Type); " is 144.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "                                (new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' ReadHeapE)); " is 129.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "                                         return new ExpressionStackEntry(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' readEffect); " is 134.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "                                         return new ExpressionStackEntry(new FieldCell(new ReadExpression(a[0])' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e); " is 128.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "                                         return new ExpressionStackEntry(new FieldCell(a[0]' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e.Lub(ThrowsE)); " is 121.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "                        stack.Push(new ExpressionStackEntry(new FieldHandleConstantExpression(compEnv.SubstituteMember(fieldi.Field))' BottomE)); " is 121.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "                             new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).Read().CloneIfStruct(compEnv)' e.Lub(ThrowsE))); " is 127.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "                        (new IfThenElseStatement(condEntry.Expression' new Statements(thenStmnts)' elseStmnts == null ? null : new Statements(elseStmnts))); " is 132.
Long Statement,Microsoft.LiveLabs.CST,MultiDimArrayTypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceRespectsParameterConstraint,The length of the statement  "                    vctxt.Log(new InvalidTypeRef(ctxt' originalType' "A multi-dimensional array type cannot be used to instantiate a type parameter with a value-type or constructor constraint")); " is 175.
Long Statement,Microsoft.LiveLabs.CST,MultiDimArrayTypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceIsAssignableTo,The length of the statement  "                return base.PrimInstanceIsAssignableTo(groundEnv' thisAssembly' thisGroundTypeBoundArguments' otherAssembly' otherDef' otherGroundTypeBoundArguments); " is 150.
Long Statement,Microsoft.LiveLabs.CST,ParameterTypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceRespectsParameterConstraint,The length of the statement  "            return base.PrimInstanceRespectsParameterConstraint(vctxt' ctxt' originalType' groundEnv' groundTypeBoundArguments' constraint' inCodePointer); " is 143.
Long Statement,Microsoft.LiveLabs.CST,ParameterTypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimIsValidParameterBinding,The length of the statement  "            if (!boundTypeEnv.Type.PrimInstanceRespectsParameterConstraint(vctxt' ctxt' originalType' groundEnv' boundGroundArguments' Constraint' inCodePointer)) " is 150.
Long Statement,Microsoft.LiveLabs.CST,RealTypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,ImplementingMethod,The length of the statement  "                if (slotRef.DefiningType.Equals(interfaceMethodRef.DefiningType) && slotRef.ExternalSignature.WithoutThis().Equals(interfaceMethodSig)) " is 135.
Long Statement,Microsoft.LiveLabs.CST,EnumTypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,AccumUsedTypeDefs,The length of the statement  "            Invalid = Implementation.AccumUsedTypeDefs(vctxt' MessageContextBuilders.Type(vctxt.Global' assemblyDef' this)' usedTypes); " is 123.
Long Statement,Microsoft.LiveLabs.CST,InterfaceTypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceIsAssignableTo,The length of the statement  "                return base.PrimInstanceIsAssignableTo(groundEnv' thisAssembly' thisTypeArguments' otherAssembly' otherDef' otherTypeArguments); " is 128.
Long Statement,Microsoft.LiveLabs.CST,NamedTypeRef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeRef.cs,PrimSubstitute,The length of the statement  "            return new NamedTypeRef(Annotations' name' arguments.Select(t => t.PrimSubstitute(typeBoundArguments' methodBoundArguments)).ToSeq()); " is 134.
Complex Conditional,Microsoft.LiveLabs.CST,BBLoop,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\BasicBlockUtils.cs,BBLoop,The conditional expression  "headEscapes && tailEscapes && headbranchbb != null && tailbranchbb != null"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,FieldCell,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Cell.cs,EqualBody,The conditional expression  "Object == null && field.Object != null || Object != null && field.Object == null"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceBranch,The conditional expression  "thenbb != null && thenbb.Target.Equals(branchbb) && thenbb.Sources.Count == 1 && group.Add(thenbb) &&                      !group.Contains(branchbb.Fallthrough)"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceBranch,The conditional expression  "elsebb != null && elsebb.Target.Equals(branchbb) && elsebb.Sources.Count == 1 && group.Add(elsebb) &&                      !group.Contains(branchbb.Target)"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceBranch,The conditional expression  "thenbb != null && elsebb != null && thenbb.Target.Equals(elsebb.Target) &&                      elsebb.Sources.Count == 1 && group.Add(elsebb) && !group.Contains(thenbb) &&                      !group.Contains(thenbb.Target) && !thenbb.Target.Equals(thenbb) &&                      IsLoadBooleanBlock(thenbb.Block)"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceBranch,The conditional expression  "thenbb != null && elsebb != null && thenbb.Target.Equals(elsebb.Target) &&                      thenbb.Sources.Count == 1 && group.Add(thenbb) && !group.Contains(elsebb) &&                      !group.Contains(elsebb.Target) && !elsebb.Target.Equals(elsebb) &&                      IsLoadBooleanBlock(elsebb.Block)"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceBranch,The conditional expression  "thenbb != null && branchbb.Fallthrough.Equals(thenbb.Fallthrough) && thenbb.Sources.Count == 1 &&                      group.Add(thenbb) && !group.Contains(thenbb.Target) && !group.Contains(branchbb.Fallthrough)"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceBranch,The conditional expression  "elsebb != null && branchbb.Target.Equals(elsebb.Fallthrough) && elsebb.Sources.Count == 1 &&                      group.Add(elsebb) && !group.Contains(elsebb.Target) && !group.Contains(branchbb.Target)"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceBranch,The conditional expression  "thenbb != null && branchbb.Fallthrough.Equals(thenbb.Target) && thenbb.Sources.Count == 1 &&                      group.Add(thenbb) && !group.Contains(thenbb.Fallthrough) && !group.Contains(branchbb.Fallthrough)"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceBranch,The conditional expression  "elsebb != null && branchbb.Target.Equals(elsebb.Target) && elsebb.Sources.Count == 1 &&                      group.Add(elsebb) && !group.Contains(elsebb.Fallthrough) && !group.Contains(branchbb.Target)"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceBranch,The conditional expression  "thenbb != null && elsebb != null && !branchbb.Equals(thenbb) && !branchbb.Equals(elsebb) &&                      !thenbb.Equals(elsebb) && branchbb.Target.Sources.Count == 1 &&                      branchbb.Fallthrough.Sources.Count == 1"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceBranch,The conditional expression  "group.Add(branchbb.Target) && group.Add(branchbb.Fallthrough) &&                      branchbb.Target.Sources.Count == 1 && branchbb.Fallthrough.Sources.Count == 1 &&                      branchbb.Target.HasSameExit(branchbb.Fallthrough)"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceLoopCandidate,The conditional expression  "(jumpheadbb != null && jumpheadbb.Target.Equals(loopbb.Break) || nonretheadbb != null) &&                  group.Add(headbb) && !group.Contains(loopbb.Break)"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,Effects,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Domain.cs,Lub,The conditional expression  "args == null || locals == null || heap == null || mayThrow == null"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,Effects,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Domain.cs,Lub,The conditional expression  "args == null || locals == null || heap == null || mayThrow == null"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,CodePointerExpression,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,EqualBody,The conditional expression  "Object == null && func.Object != null || Object != null && func.Object == null"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,TranslationContext,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,OutermostTryBlocks,The conditional expression  "first >= 0 && Handlers[first].TryOffset == Handlers[last].TryOffset &&                                 Handlers[first].TryLength == Handlers[last].TryLength &&                                 Handlers[first].Flags == PE.CorILExceptionClause.Exception &&                                 Handlers[last].Flags == PE.CorILExceptionClause.Exception"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,AssemblyName,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Name.cs,Equals,The conditional expression  "MajorVersion != other.MajorVersion || MinorVersion != other.MinorVersion || BuildNumber != other.BuildNumber || RevisionNumber != other.RevisionNumber"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,AssemblyName,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Name.cs,GetKeyword,The conditional expression  "i < str.Length && ((str[i] >= 'a' && str[i] <= 'z') || (str[i] >= 'A' && str[i] <= 'Z'))"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,AssemblyNameSubstitution,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,Add,The conditional expression  "(existTarget == null && target != null) || (existTarget != null && target == null) ||                      (existTarget != null && !existTarget.Equals(target))"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,PELoader,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,ArgsAndResultFromMethodSig,The conditional expression  "definingTypeRef.Arguments.Count == 1 && !isStatic && (name.Equals("Set"' StringComparison.Ordinal) || name.Equals("Get"' StringComparison.Ordinal)) &&                  valParams != null"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,PELoader,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,ArgsAndResultFromMethodSig,The conditional expression  "name.Equals("Get"' StringComparison.Ordinal) && valParams.Count == 1 + bounds.Rank &&                               result != null && result.Equals(definingTypeRef.Arguments[0])"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,PELoader,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,MethodDefFromRow,The conditional expression  "(row.Flags & PE.MethodAttributes.SpecialName) != 0 && (row.Flags & PE.MethodAttributes.RTSpecialName) != 0 &&                  (row.Name.Value.Equals(".ctor"' StringComparison.Ordinal) ||                   row.Name.Value.Equals(".cctor"' StringComparison.Ordinal))"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,PELoader,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The conditional expression  "extends != null && (extends.Equals(global.EnumRef) || (!thisTypeRef.Equals(global.EnumRef) && extends.Equals(global.ValueTypeRef)))"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,PELoader,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The conditional expression  "qtn.Equals(global.EnumRef.QualifiedTypeName) || qtn.Equals(global.ValueTypeRef.QualifiedTypeName) ||                           qtn.Equals(global.DelegateRef.QualifiedTypeName) || qtn.Equals(global.MulticastDelegateRef.QualifiedTypeName) ||                           qtn.Equals(global.ObjectRef.QualifiedTypeName)"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,MethodSignature,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Signature.cs,Equals,The conditional expression  "Result == null && otherMeth.Result != null || Result != null && otherMeth.Result == null"  is complex.
Virtual Method Call from Constructor,Microsoft.LiveLabs.CST,AssemblyDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\AssemblyDef.cs,AssemblyDef,The constructor "AssemblyDef" calls a virtual method "EffectiveName".
Virtual Method Call from Constructor,Microsoft.LiveLabs.CST,CallContext,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\CallContext.cs,CallContext,The constructor "CallContext" calls a virtual method "AccumEffects".
Virtual Method Call from Constructor,Microsoft.LiveLabs.CST,CallContext,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\CallContext.cs,CallContext,The constructor "CallContext" calls a virtual method "IsValue".
Empty Catch Block,Microsoft.LiveLabs.CST,PELoader,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,CustomAttributeFromRow,The method has an empty catch block.
Magic Number,Microsoft.LiveLabs.CST,Test,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\BasicBlock.cs,Rot11,The following statement contains a magic number: return v << 11 | v >> 21;
Magic Number,Microsoft.LiveLabs.CST,Test,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\BasicBlock.cs,Rot11,The following statement contains a magic number: return v << 11 | v >> 21;
Magic Number,Microsoft.LiveLabs.CST,Test,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\BasicBlock.cs,GetHashCode,The following statement contains a magic number: res = Rot11(res) ^ (uint)Op * 47;
Magic Number,Microsoft.LiveLabs.CST,BBEdge,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\BasicBlockUtils.cs,Rot17,The following statement contains a magic number: return (int)(((uint)v << 17) | ((uint)v >> 15));
Magic Number,Microsoft.LiveLabs.CST,BBEdge,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\BasicBlockUtils.cs,Rot17,The following statement contains a magic number: return (int)(((uint)v << 17) | ((uint)v >> 15));
Magic Number,Microsoft.LiveLabs.CST,Constants,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Constants.cs,Rot3,The following statement contains a magic number: return v << 3 | v >> 29;
Magic Number,Microsoft.LiveLabs.CST,Constants,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Constants.cs,Rot3,The following statement contains a magic number: return v << 3 | v >> 29;
Magic Number,Microsoft.LiveLabs.CST,Constants,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Constants.cs,Rot7,The following statement contains a magic number: return v << 7 | v >> 25;
Magic Number,Microsoft.LiveLabs.CST,Constants,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Constants.cs,Rot7,The following statement contains a magic number: return v << 7 | v >> 25;
Magic Number,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,IsDuplicatableBasicBlock,The following statement contains a magic number: var i = FindStartOfStackPrefix(bb.Block.Body' bb.Block.Count - 2' 1);
Magic Number,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,IsDuplicatableBasicBlock,The following statement contains a magic number: i == 0 && bb.Block.Count <= 2
Magic Number,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,Reduce,The following statement contains a magic number: BasicBlockUtils.PostOrder(root).Count > 2
Magic Number,Microsoft.LiveLabs.CST,Int64ConstantExpression,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,GetHashCode,The following statement contains a magic number: res ^= (uint)((ulong)Value >> 32);
Magic Number,Microsoft.LiveLabs.CST,Int64ConstantExpression,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,GetHashCode,The following statement contains a magic number: res ^= (uint)((ulong)Value & ((1LU << 32) - 1));
Magic Number,Microsoft.LiveLabs.CST,SingleConstantExpression,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,GetHashCode,The following statement contains a magic number: res ^= (uint)(v >> 32);
Magic Number,Microsoft.LiveLabs.CST,SingleConstantExpression,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,GetHashCode,The following statement contains a magic number: res ^= (uint)(v & ((1UL << 32) - 1));
Magic Number,Microsoft.LiveLabs.CST,DoubleConstantExpression,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,GetHashCode,The following statement contains a magic number: res ^= (uint)(v >> 32);
Magic Number,Microsoft.LiveLabs.CST,DoubleConstantExpression,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,GetHashCode,The following statement contains a magic number: res ^= (uint)(v & ((1LU << 32) - 1));
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return state;                      case MiscOp.Dup:                          return state.Push(state.Peek(0));                      case MiscOp.Pop:                          return state.Pop(1);                      case MiscOp.Ldnull:                          return state.PushType(global.NullRef' BottomPT);                      case MiscOp.Ckfinite:                          state.PeekExpectedType(0' global.DoubleRef' changed);                          // Assume the instruction can "peek" at top of stack' thus no need for pop/push.                          return state;                      case MiscOp.Throw:                          state.PeekReferenceType(0);                          return state.DiscardStack();                      case MiscOp.Rethrow:                          return state.DiscardStack();                      case MiscOp.LdindRef:                          {                              var elemType = state.PeekPointerToReferenceType(0);                              return state.PopPushType(1' elemType' BottomPT);                          }                      case MiscOp.StindRef:                          {                              var expElemType = state.PeekPointerToReferenceType(1);                              state.PeekExpectedType(0' expElemType' changed);                              return state.Pop(2);                          }                      case MiscOp.LdelemRef:                          {                              state.PeekIndexType(0);                              // WARNING: Type may not be final                              var elemType = state.PeekArrayOfReferenceType(1);                              return state.PopPushType(2' elemType' BottomPT);                          }                      case MiscOp.StelemRef:                          state.PeekReferenceType(0);                          state.PeekIndexType(1);                          state.PeekArrayOfReferenceType(2);                          // Since the value type and array element type may be independently generalized'                          // it is pointless to check that the first is assignable to the second.                          // Instead this check is done at runtime.                          return state.Pop(3);                      case MiscOp.Ldlen:                          state.PeekArrayOfAnyType(0);                          return state.PopPushType(1' global.IntNativeRef' BottomPT);                      case MiscOp.Ret:                          {                              if (state.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return state; // empty                          }                      case MiscOp.RetVal:                          {                              state.PeekExpectedType(0' method.Result.Type' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfilter:                          {                              state.PeekExpectedType(0' global.Int32Ref' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfinally:                          {                              // Control could transfer to an outer finally/fault block' or to the target                              // of a leave instruction. However these transitions are delt with separately.                              return state.DiscardStack();                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:                  {                      var bri = (BranchInstruction)instruction;                      switch (bri.Op)                      {                      case BranchOp.Br:                          UnifyBeforeState(state' bri.Target' changed);                          return state;                      case BranchOp.Brtrue:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' false);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Brfalse:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Breq:                      case BranchOp.Brne:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' true);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Leave:                          {                              // Control could transfer via finally blocks instead of directly to the leave target.                              // Propogate only that the stack must be empty at target. Remaining machine state                              // is dealt with separately.                              UnifyBeforeState                                  (new MachineState(methEnv' method.ValueParameters.Count' method.Locals.Count)'                                   bri.Target'                                   changed);                              return state.DiscardStack();                          }                      case BranchOp.BrLt:                      case BranchOp.BrLe:                      case BranchOp.BrGt:                      case BranchOp.BrGe:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' false);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Switch:                  {                      var switchi = (SwitchInstruction)instruction;                      state.PeekExpectedType(0' global.Int32Ref' changed);                      var newState = state.Pop(1);                      for (var i = 0; i < switchi.CaseTargets.Count; i++)                          UnifyBeforeState(newState' switchi.CaseTargets[i]' changed);                      return newState;                  }              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      // WARNING: Capured type may not be final                      // NOTE: May capture skolemized types                      switch (cmpi.Op)                      {                      case CompareOp.Ceq:                      case CompareOp.CnePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' true);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.Clt:                      case CompareOp.Cgt:                      case CompareOp.CgePseudo:                      case CompareOp.ClePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' false);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.CtruePseudo:                      case CompareOp.CfalsePseudo:                          cmpi.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                          return state.PopPushType(1' global.Int32Ref' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var argi = (ArgLocalInstruction)instruction;                      var type = method.ArgLocalType(argi.ArgLocal' argi.Index);                      switch (argi.Op)                      {                      case ArgLocalOp.Ld:                          return state.PushType(type' state.ArgLocalPointsTo(argi.ArgLocal' argi.Index));                      case ArgLocalOp.Lda:                          return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(type)' ArgLocalPT(argi.ArgLocal' argi.Index));                      case ArgLocalOp.St:                          {                              state.PeekExpectedType(0' type' changed);                              var pointsTo = state.PeekPointsTo(0);                              if (!pointsTo.IsBottom)                              {                                  if (!(type.Style(methEnv) is ManagedPointerTypeStyle))                                      throw new InvalidOperationException                                          ("stack indicates pointer' but parameter or local type does not");                                  if (pointsTo.PointsOutsideOfHeap)                                      throw new InvalidOperationException("arguments cannot point outside of the heap");                              }                              return state.PopAddArgLocalPointsTo(1' argi.ArgLocal' argi.Index' pointsTo);                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      var fieldEnv = fieldi.Field.Enter(methEnv);                      var fieldType = fieldEnv.SubstituteType(fieldEnv.Field.FieldType);                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                              return state.PushType(fieldType' BottomPT);                          else                          {                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' true' changed);                              return state.PopPushType(1' fieldType' BottomPT);                          }                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                              return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          else                          {                              // Underlying type cannot be a struct' otherwise would have a pointer into                              // the stack                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' false' changed);                              return state.PopPushType                                  (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          }                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                          {                              state.PeekExpectedType(0' fieldType' changed);                              return state.Pop(1);                          }                          else                          {                              state.PeekExpectedType(0' fieldType' changed);                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (1' fieldi.Field.DefiningType' false' changed);                              return state.Pop(2);                          }                      case FieldOp.Ldtoken:                          return state.PushType(global.RuntimeFieldHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methi = (MethodInstruction)instruction;                      var sig = (CST.MethodSignature)methi.Method.ExternalSignature;                      switch (methi.Op)                      {                      case MethodOp.Call:                          {                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              if (methi.Constrained != null)                              {                                  if (!methi.IsVirtual || methi.Method.IsStatic)                                      throw new InvalidOperationException                                          ("constrained only valid on virtual calls to instance methods");                                  var thisType = sig.Parameters[0];                                  var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(methi.Constrained);                                  var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo(methi.Constrained);                                  var cs = methi.Constrained.Style(methEnv);                                  if (cs is ValueTypeStyle)                                  {                                      if (thisType.Style(methEnv) is ManagedPointerTypeStyle)                                      {                                          // We pass the argument pointer as is                                          if (!methi.Constrained.IsAssignableTo(methEnv' thisType.Arguments[0]))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                      else                                      {                                          // *Case 1* Morally we deref the argument pointer and box the contents'                                          // but since no supertype of a value type may mutate the underlying value'                                          // we don't need to take a copy of the value when boxing' so in practice                                          // this is a no-op                                          if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                  }                                  else if (cs is ReferenceTypeStyle)                                  {                                      // *Case 2* We dereference the pointer and pass the object reference                                      if (!methi.Constrained.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else if (cs is ParameterTypeStyle)                                  {                                      // Since we are calling an instance method' we know the first argument cannot be                                      // a "naked" type parameter' but is either a class or an interface.                                      // We must decide between cases 1 and 2 above at runtime' but checking as                                      // per case 1 is sufficient now.                                      // NOTE: As for box/classcast/isinst below' if the parameter is                                      // instantiated to a reference type then the type box type is considered                                      // equivalent to the underyling reference type.                                      if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else                                      throw new InvalidOperationException                                          ("constrained must be value' reference or parameter type");                                    state.PeekExpectedType(sig.Parameters.Count - 1' constrainedPtr' changed);                              }                              else if (sig.Parameters.Count > 0)                                  state.PeekExpectedType(sig.Parameters.Count - 1' sig.Parameters[0]' changed);                              if (sig.Result == null)                                  return state.Pop(sig.Parameters.Count);                              else                                  return state.PopPushType(sig.Parameters.Count' sig.Result' BottomPT);                          }                      case MethodOp.Ldftn:                          {                              // NOTE: Verified CLR allows only the two "blessed" sequences:                              //   dup; ldvirtftn; newobj <delegate ctor>                              //   ldftn; newobj <delegate ctor>                              // It is thus possible to check the delegate will capture an instance which                              // implements the loaded method. However' we don't check that here.                              if (methi.IsVirtual)                              {                                  if (methi.Method.IsStatic)                                      throw new InvalidOperationException("cannot ldvirtftn of a static method");                                  var objectType = default(TypeRef);                                  if (sig.Parameters[0].Style(methEnv) is ManagedPointerTypeStyle)                                      // Object should be a box                                      objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(sig.Parameters[0].Arguments[0]);                                  else                                      // Object should match parameter                                      objectType = sig.Parameters[0];                                  state.PeekExpectedType(0' objectType' changed);                                  return state.PopPushType(1' sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                              else                              {                                  if (methi.Method.IsStatic)                                      return state.PushType(sig.ToCodePointer(methEnv.Global)' BottomPT);                                  else                                      return state.PushType(sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                          }                      case MethodOp.Newobj:                          {                              if (methi.Method.IsStatic || sig.Result != null)                                  throw new InvalidOperationException("not a constructor");                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              // First argument to constructor is created by runtime. If definining type is                              // a value type' first argument will be a pointer' but result left on stack                              // will be the value itself.                              return state.PopPushType(sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);                          }                      case MethodOp.Ldtoken:                          return state.PushType(global.RuntimeMethodHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          state.PeekReadPointerType(0' typei.Type);                          return state.PopPushType(1' typei.Type' BottomPT);                      case TypeOp.Stobj:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Cpobj:                          state.PeekReadPointerType(0' typei.Type);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Newarr:                          state.PeekIndexType(0);                          return state.PopPushType(1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo(typei.Type)' BottomPT);                      case TypeOp.Initobj:                          state.PeekWritePointerType(0' typei.Type);                          return state.Pop(1);                      case TypeOp.Castclass:                      case TypeOp.Isinst:                      case TypeOp.Box:                          {                              var resultType = default(TypeRef);                              var s = typei.Type.Style(methEnv);                              if (s is NullableTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type.Arguments[0]);                              else if (s is ValueTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else if (s is ReferenceTypeStyle)                                  resultType = typei.Type;                              else if (s is ParameterTypeStyle)                                  // NOTE: As for constrained call above' if type parameter is instantitated to                                  // a ref type' then this box type is considered equivalent to the                                  // underlying reference type.                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else                                  throw new InvalidOperationException                                      ("can only box/cast to reference' value or parameter type");                              if (typei.Op == TypeOp.Box)                                  state.PeekExpectedType(0' typei.Type' changed);                              else                                  state.PeekReferenceType(0);                              return state.PopPushType(1' resultType' BottomPT);                          }                      case TypeOp.Unbox:                          if (!(typei.Type.Style(methEnv) is ValueTypeStyle))                              // Parameter types are not allowed                              throw new InvalidOperationException("type must be a value type");                          state.PeekBoxedType(0' typei.Type' changed);                          return state.PopPushType(1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(typei.Type)' HeapPT);                      case TypeOp.UnboxAny:                          {                              var s = typei.Type.Style(methEnv);                              if (s is ValueTypeStyle)                                  state.PeekBoxedType(0' typei.Type' changed);                              else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))                                  throw new InvalidOperationException("type must be value' reference or parameter type");                              return state.PopPushType(1' typei.Type' BottomPT);                          }                      case TypeOp.Ldtoken:                          return state.PushType(global.RuntimeTypeHandleRef' BottomPT);                      case TypeOp.Ldelem:                          state.PeekIndexType(0);                          state.PeekReadArrayType(1' typei.Type' false);                          return state.PopPushType(2' typei.Type' BottomPT);                      case TypeOp.Stelem:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekIndexType(1);                          state.PeekWriteArrayType(2' typei.Type);                          return state.Pop(3);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  {                      var ldelemai = (LdElemAddrInstruction)instruction;                      state.PeekIndexType(0);                      // WARNING: May prematurely fail for non-readonly loads                      state.PeekReadArrayType(1' ldelemai.Type' !ldelemai.IsReadonly);                      return state.PopPushType(2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(ldelemai.Type)' HeapPT);                  }              case InstructionFlavor.LdInt32:                  return state.PushType(global.Int32Ref' BottomPT);              case InstructionFlavor.LdInt64:                  return state.PushType(global.Int64Ref' BottomPT);              case InstructionFlavor.LdSingle:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdDouble:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdString:                  return state.PushType(global.StringRef' BottomPT);              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.Div:                      case ArithOp.Rem:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' true);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.Neg:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' true);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' false);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.BitNot:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.Shl:                      case ArithOp.Shr:                          state.PeekExpectedType(0' global.Int32Ref' changed);                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(1' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(2' arithi.Type' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned &&                                           convi.TargetNumberFlavor == NumberFlavor.Double);                      // NOTE: May capture skolemized types                      convi.SourceType = state.PeekNumberType(0' !mustBeInteger);                      return state.PopPushType(1' TypeRef.NumberFrom(methEnv.Global' convi.TargetNumberFlavor)' BottomPT);                  }              case InstructionFlavor.Try:                  {                      var tryi = (TryInstruction)instruction;                      // Isolation:                      //  - There is no way for the current stack shape to influence or be influenced by                      //    inference of the try' since the current stack shape must be empty.                      //  - There is no way for the try to influence the result stack shape' since it must be                      //    empty.                      //  - However pointers in arguments and locals may propogate into and out of try body                      //    via exceptional transitions. The latter are delt with separately.                      if (state.Depth != 0)                          throw new InvalidOperationException("stack should be empty");                      var newState = ForwardBlock                          (new TryBodyInstructionContext(context' index' tryi.Body)' state' changed);                      for (var j = 0; j < tryi.Handlers.Count; j++)                      {                          var h = tryi.Handlers[j];                          var handlerContext = new TryHandlerInstructionContext(context' index' h.Body' j);                          var initHandlerState = new MachineState                              (methEnv' method.ValueParameters.Count' method.Locals.Count);                          switch (h.Flavor)                          {                          case HandlerFlavor.Catch:                              {                                  var catchh = (CatchTryInstructionHandler)h;                                  ForwardBlock(handlerContext' initHandlerState.PushType(catchh.Type' BottomPT)' changed);                                  break;                              }                          case HandlerFlavor.Filter:                              throw new NotSupportedException("filter handler blocks");                          case HandlerFlavor.Fault:                          case HandlerFlavor.Finally:                              ForwardBlock(handlerContext' initHandlerState' changed);                              break;                          default:                              throw new ArgumentOutOfRangeException();                          }                      }                      return newState;                  }              case InstructionFlavor.IfThenElsePseudo:              case InstructionFlavor.ShortCircuitingPseudo:              case InstructionFlavor.StructuralSwitchPseudo:              case InstructionFlavor.LoopPseudo:              case InstructionFlavor.WhileDoPseudo:              case InstructionFlavor.DoWhilePseudo:              case InstructionFlavor.LoopControlPseudo:                  throw new InvalidOperationException("no machine state inference for psuedo-instructions");              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return state;                      case MiscOp.Dup:                          return state.Push(state.Peek(0));                      case MiscOp.Pop:                          return state.Pop(1);                      case MiscOp.Ldnull:                          return state.PushType(global.NullRef' BottomPT);                      case MiscOp.Ckfinite:                          state.PeekExpectedType(0' global.DoubleRef' changed);                          // Assume the instruction can "peek" at top of stack' thus no need for pop/push.                          return state;                      case MiscOp.Throw:                          state.PeekReferenceType(0);                          return state.DiscardStack();                      case MiscOp.Rethrow:                          return state.DiscardStack();                      case MiscOp.LdindRef:                          {                              var elemType = state.PeekPointerToReferenceType(0);                              return state.PopPushType(1' elemType' BottomPT);                          }                      case MiscOp.StindRef:                          {                              var expElemType = state.PeekPointerToReferenceType(1);                              state.PeekExpectedType(0' expElemType' changed);                              return state.Pop(2);                          }                      case MiscOp.LdelemRef:                          {                              state.PeekIndexType(0);                              // WARNING: Type may not be final                              var elemType = state.PeekArrayOfReferenceType(1);                              return state.PopPushType(2' elemType' BottomPT);                          }                      case MiscOp.StelemRef:                          state.PeekReferenceType(0);                          state.PeekIndexType(1);                          state.PeekArrayOfReferenceType(2);                          // Since the value type and array element type may be independently generalized'                          // it is pointless to check that the first is assignable to the second.                          // Instead this check is done at runtime.                          return state.Pop(3);                      case MiscOp.Ldlen:                          state.PeekArrayOfAnyType(0);                          return state.PopPushType(1' global.IntNativeRef' BottomPT);                      case MiscOp.Ret:                          {                              if (state.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return state; // empty                          }                      case MiscOp.RetVal:                          {                              state.PeekExpectedType(0' method.Result.Type' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfilter:                          {                              state.PeekExpectedType(0' global.Int32Ref' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfinally:                          {                              // Control could transfer to an outer finally/fault block' or to the target                              // of a leave instruction. However these transitions are delt with separately.                              return state.DiscardStack();                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:                  {                      var bri = (BranchInstruction)instruction;                      switch (bri.Op)                      {                      case BranchOp.Br:                          UnifyBeforeState(state' bri.Target' changed);                          return state;                      case BranchOp.Brtrue:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' false);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Brfalse:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Breq:                      case BranchOp.Brne:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' true);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Leave:                          {                              // Control could transfer via finally blocks instead of directly to the leave target.                              // Propogate only that the stack must be empty at target. Remaining machine state                              // is dealt with separately.                              UnifyBeforeState                                  (new MachineState(methEnv' method.ValueParameters.Count' method.Locals.Count)'                                   bri.Target'                                   changed);                              return state.DiscardStack();                          }                      case BranchOp.BrLt:                      case BranchOp.BrLe:                      case BranchOp.BrGt:                      case BranchOp.BrGe:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' false);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Switch:                  {                      var switchi = (SwitchInstruction)instruction;                      state.PeekExpectedType(0' global.Int32Ref' changed);                      var newState = state.Pop(1);                      for (var i = 0; i < switchi.CaseTargets.Count; i++)                          UnifyBeforeState(newState' switchi.CaseTargets[i]' changed);                      return newState;                  }              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      // WARNING: Capured type may not be final                      // NOTE: May capture skolemized types                      switch (cmpi.Op)                      {                      case CompareOp.Ceq:                      case CompareOp.CnePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' true);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.Clt:                      case CompareOp.Cgt:                      case CompareOp.CgePseudo:                      case CompareOp.ClePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' false);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.CtruePseudo:                      case CompareOp.CfalsePseudo:                          cmpi.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                          return state.PopPushType(1' global.Int32Ref' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var argi = (ArgLocalInstruction)instruction;                      var type = method.ArgLocalType(argi.ArgLocal' argi.Index);                      switch (argi.Op)                      {                      case ArgLocalOp.Ld:                          return state.PushType(type' state.ArgLocalPointsTo(argi.ArgLocal' argi.Index));                      case ArgLocalOp.Lda:                          return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(type)' ArgLocalPT(argi.ArgLocal' argi.Index));                      case ArgLocalOp.St:                          {                              state.PeekExpectedType(0' type' changed);                              var pointsTo = state.PeekPointsTo(0);                              if (!pointsTo.IsBottom)                              {                                  if (!(type.Style(methEnv) is ManagedPointerTypeStyle))                                      throw new InvalidOperationException                                          ("stack indicates pointer' but parameter or local type does not");                                  if (pointsTo.PointsOutsideOfHeap)                                      throw new InvalidOperationException("arguments cannot point outside of the heap");                              }                              return state.PopAddArgLocalPointsTo(1' argi.ArgLocal' argi.Index' pointsTo);                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      var fieldEnv = fieldi.Field.Enter(methEnv);                      var fieldType = fieldEnv.SubstituteType(fieldEnv.Field.FieldType);                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                              return state.PushType(fieldType' BottomPT);                          else                          {                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' true' changed);                              return state.PopPushType(1' fieldType' BottomPT);                          }                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                              return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          else                          {                              // Underlying type cannot be a struct' otherwise would have a pointer into                              // the stack                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' false' changed);                              return state.PopPushType                                  (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          }                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                          {                              state.PeekExpectedType(0' fieldType' changed);                              return state.Pop(1);                          }                          else                          {                              state.PeekExpectedType(0' fieldType' changed);                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (1' fieldi.Field.DefiningType' false' changed);                              return state.Pop(2);                          }                      case FieldOp.Ldtoken:                          return state.PushType(global.RuntimeFieldHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methi = (MethodInstruction)instruction;                      var sig = (CST.MethodSignature)methi.Method.ExternalSignature;                      switch (methi.Op)                      {                      case MethodOp.Call:                          {                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              if (methi.Constrained != null)                              {                                  if (!methi.IsVirtual || methi.Method.IsStatic)                                      throw new InvalidOperationException                                          ("constrained only valid on virtual calls to instance methods");                                  var thisType = sig.Parameters[0];                                  var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(methi.Constrained);                                  var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo(methi.Constrained);                                  var cs = methi.Constrained.Style(methEnv);                                  if (cs is ValueTypeStyle)                                  {                                      if (thisType.Style(methEnv) is ManagedPointerTypeStyle)                                      {                                          // We pass the argument pointer as is                                          if (!methi.Constrained.IsAssignableTo(methEnv' thisType.Arguments[0]))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                      else                                      {                                          // *Case 1* Morally we deref the argument pointer and box the contents'                                          // but since no supertype of a value type may mutate the underlying value'                                          // we don't need to take a copy of the value when boxing' so in practice                                          // this is a no-op                                          if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                  }                                  else if (cs is ReferenceTypeStyle)                                  {                                      // *Case 2* We dereference the pointer and pass the object reference                                      if (!methi.Constrained.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else if (cs is ParameterTypeStyle)                                  {                                      // Since we are calling an instance method' we know the first argument cannot be                                      // a "naked" type parameter' but is either a class or an interface.                                      // We must decide between cases 1 and 2 above at runtime' but checking as                                      // per case 1 is sufficient now.                                      // NOTE: As for box/classcast/isinst below' if the parameter is                                      // instantiated to a reference type then the type box type is considered                                      // equivalent to the underyling reference type.                                      if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else                                      throw new InvalidOperationException                                          ("constrained must be value' reference or parameter type");                                    state.PeekExpectedType(sig.Parameters.Count - 1' constrainedPtr' changed);                              }                              else if (sig.Parameters.Count > 0)                                  state.PeekExpectedType(sig.Parameters.Count - 1' sig.Parameters[0]' changed);                              if (sig.Result == null)                                  return state.Pop(sig.Parameters.Count);                              else                                  return state.PopPushType(sig.Parameters.Count' sig.Result' BottomPT);                          }                      case MethodOp.Ldftn:                          {                              // NOTE: Verified CLR allows only the two "blessed" sequences:                              //   dup; ldvirtftn; newobj <delegate ctor>                              //   ldftn; newobj <delegate ctor>                              // It is thus possible to check the delegate will capture an instance which                              // implements the loaded method. However' we don't check that here.                              if (methi.IsVirtual)                              {                                  if (methi.Method.IsStatic)                                      throw new InvalidOperationException("cannot ldvirtftn of a static method");                                  var objectType = default(TypeRef);                                  if (sig.Parameters[0].Style(methEnv) is ManagedPointerTypeStyle)                                      // Object should be a box                                      objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(sig.Parameters[0].Arguments[0]);                                  else                                      // Object should match parameter                                      objectType = sig.Parameters[0];                                  state.PeekExpectedType(0' objectType' changed);                                  return state.PopPushType(1' sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                              else                              {                                  if (methi.Method.IsStatic)                                      return state.PushType(sig.ToCodePointer(methEnv.Global)' BottomPT);                                  else                                      return state.PushType(sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                          }                      case MethodOp.Newobj:                          {                              if (methi.Method.IsStatic || sig.Result != null)                                  throw new InvalidOperationException("not a constructor");                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              // First argument to constructor is created by runtime. If definining type is                              // a value type' first argument will be a pointer' but result left on stack                              // will be the value itself.                              return state.PopPushType(sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);                          }                      case MethodOp.Ldtoken:                          return state.PushType(global.RuntimeMethodHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          state.PeekReadPointerType(0' typei.Type);                          return state.PopPushType(1' typei.Type' BottomPT);                      case TypeOp.Stobj:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Cpobj:                          state.PeekReadPointerType(0' typei.Type);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Newarr:                          state.PeekIndexType(0);                          return state.PopPushType(1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo(typei.Type)' BottomPT);                      case TypeOp.Initobj:                          state.PeekWritePointerType(0' typei.Type);                          return state.Pop(1);                      case TypeOp.Castclass:                      case TypeOp.Isinst:                      case TypeOp.Box:                          {                              var resultType = default(TypeRef);                              var s = typei.Type.Style(methEnv);                              if (s is NullableTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type.Arguments[0]);                              else if (s is ValueTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else if (s is ReferenceTypeStyle)                                  resultType = typei.Type;                              else if (s is ParameterTypeStyle)                                  // NOTE: As for constrained call above' if type parameter is instantitated to                                  // a ref type' then this box type is considered equivalent to the                                  // underlying reference type.                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else                                  throw new InvalidOperationException                                      ("can only box/cast to reference' value or parameter type");                              if (typei.Op == TypeOp.Box)                                  state.PeekExpectedType(0' typei.Type' changed);                              else                                  state.PeekReferenceType(0);                              return state.PopPushType(1' resultType' BottomPT);                          }                      case TypeOp.Unbox:                          if (!(typei.Type.Style(methEnv) is ValueTypeStyle))                              // Parameter types are not allowed                              throw new InvalidOperationException("type must be a value type");                          state.PeekBoxedType(0' typei.Type' changed);                          return state.PopPushType(1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(typei.Type)' HeapPT);                      case TypeOp.UnboxAny:                          {                              var s = typei.Type.Style(methEnv);                              if (s is ValueTypeStyle)                                  state.PeekBoxedType(0' typei.Type' changed);                              else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))                                  throw new InvalidOperationException("type must be value' reference or parameter type");                              return state.PopPushType(1' typei.Type' BottomPT);                          }                      case TypeOp.Ldtoken:                          return state.PushType(global.RuntimeTypeHandleRef' BottomPT);                      case TypeOp.Ldelem:                          state.PeekIndexType(0);                          state.PeekReadArrayType(1' typei.Type' false);                          return state.PopPushType(2' typei.Type' BottomPT);                      case TypeOp.Stelem:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekIndexType(1);                          state.PeekWriteArrayType(2' typei.Type);                          return state.Pop(3);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  {                      var ldelemai = (LdElemAddrInstruction)instruction;                      state.PeekIndexType(0);                      // WARNING: May prematurely fail for non-readonly loads                      state.PeekReadArrayType(1' ldelemai.Type' !ldelemai.IsReadonly);                      return state.PopPushType(2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(ldelemai.Type)' HeapPT);                  }              case InstructionFlavor.LdInt32:                  return state.PushType(global.Int32Ref' BottomPT);              case InstructionFlavor.LdInt64:                  return state.PushType(global.Int64Ref' BottomPT);              case InstructionFlavor.LdSingle:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdDouble:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdString:                  return state.PushType(global.StringRef' BottomPT);              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.Div:                      case ArithOp.Rem:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' true);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.Neg:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' true);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' false);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.BitNot:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.Shl:                      case ArithOp.Shr:                          state.PeekExpectedType(0' global.Int32Ref' changed);                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(1' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(2' arithi.Type' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned &&                                           convi.TargetNumberFlavor == NumberFlavor.Double);                      // NOTE: May capture skolemized types                      convi.SourceType = state.PeekNumberType(0' !mustBeInteger);                      return state.PopPushType(1' TypeRef.NumberFrom(methEnv.Global' convi.TargetNumberFlavor)' BottomPT);                  }              case InstructionFlavor.Try:                  {                      var tryi = (TryInstruction)instruction;                      // Isolation:                      //  - There is no way for the current stack shape to influence or be influenced by                      //    inference of the try' since the current stack shape must be empty.                      //  - There is no way for the try to influence the result stack shape' since it must be                      //    empty.                      //  - However pointers in arguments and locals may propogate into and out of try body                      //    via exceptional transitions. The latter are delt with separately.                      if (state.Depth != 0)                          throw new InvalidOperationException("stack should be empty");                      var newState = ForwardBlock                          (new TryBodyInstructionContext(context' index' tryi.Body)' state' changed);                      for (var j = 0; j < tryi.Handlers.Count; j++)                      {                          var h = tryi.Handlers[j];                          var handlerContext = new TryHandlerInstructionContext(context' index' h.Body' j);                          var initHandlerState = new MachineState                              (methEnv' method.ValueParameters.Count' method.Locals.Count);                          switch (h.Flavor)                          {                          case HandlerFlavor.Catch:                              {                                  var catchh = (CatchTryInstructionHandler)h;                                  ForwardBlock(handlerContext' initHandlerState.PushType(catchh.Type' BottomPT)' changed);                                  break;                              }                          case HandlerFlavor.Filter:                              throw new NotSupportedException("filter handler blocks");                          case HandlerFlavor.Fault:                          case HandlerFlavor.Finally:                              ForwardBlock(handlerContext' initHandlerState' changed);                              break;                          default:                              throw new ArgumentOutOfRangeException();                          }                      }                      return newState;                  }              case InstructionFlavor.IfThenElsePseudo:              case InstructionFlavor.ShortCircuitingPseudo:              case InstructionFlavor.StructuralSwitchPseudo:              case InstructionFlavor.LoopPseudo:              case InstructionFlavor.WhileDoPseudo:              case InstructionFlavor.DoWhilePseudo:              case InstructionFlavor.LoopControlPseudo:                  throw new InvalidOperationException("no machine state inference for psuedo-instructions");              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return state;                      case MiscOp.Dup:                          return state.Push(state.Peek(0));                      case MiscOp.Pop:                          return state.Pop(1);                      case MiscOp.Ldnull:                          return state.PushType(global.NullRef' BottomPT);                      case MiscOp.Ckfinite:                          state.PeekExpectedType(0' global.DoubleRef' changed);                          // Assume the instruction can "peek" at top of stack' thus no need for pop/push.                          return state;                      case MiscOp.Throw:                          state.PeekReferenceType(0);                          return state.DiscardStack();                      case MiscOp.Rethrow:                          return state.DiscardStack();                      case MiscOp.LdindRef:                          {                              var elemType = state.PeekPointerToReferenceType(0);                              return state.PopPushType(1' elemType' BottomPT);                          }                      case MiscOp.StindRef:                          {                              var expElemType = state.PeekPointerToReferenceType(1);                              state.PeekExpectedType(0' expElemType' changed);                              return state.Pop(2);                          }                      case MiscOp.LdelemRef:                          {                              state.PeekIndexType(0);                              // WARNING: Type may not be final                              var elemType = state.PeekArrayOfReferenceType(1);                              return state.PopPushType(2' elemType' BottomPT);                          }                      case MiscOp.StelemRef:                          state.PeekReferenceType(0);                          state.PeekIndexType(1);                          state.PeekArrayOfReferenceType(2);                          // Since the value type and array element type may be independently generalized'                          // it is pointless to check that the first is assignable to the second.                          // Instead this check is done at runtime.                          return state.Pop(3);                      case MiscOp.Ldlen:                          state.PeekArrayOfAnyType(0);                          return state.PopPushType(1' global.IntNativeRef' BottomPT);                      case MiscOp.Ret:                          {                              if (state.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return state; // empty                          }                      case MiscOp.RetVal:                          {                              state.PeekExpectedType(0' method.Result.Type' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfilter:                          {                              state.PeekExpectedType(0' global.Int32Ref' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfinally:                          {                              // Control could transfer to an outer finally/fault block' or to the target                              // of a leave instruction. However these transitions are delt with separately.                              return state.DiscardStack();                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:                  {                      var bri = (BranchInstruction)instruction;                      switch (bri.Op)                      {                      case BranchOp.Br:                          UnifyBeforeState(state' bri.Target' changed);                          return state;                      case BranchOp.Brtrue:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' false);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Brfalse:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Breq:                      case BranchOp.Brne:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' true);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Leave:                          {                              // Control could transfer via finally blocks instead of directly to the leave target.                              // Propogate only that the stack must be empty at target. Remaining machine state                              // is dealt with separately.                              UnifyBeforeState                                  (new MachineState(methEnv' method.ValueParameters.Count' method.Locals.Count)'                                   bri.Target'                                   changed);                              return state.DiscardStack();                          }                      case BranchOp.BrLt:                      case BranchOp.BrLe:                      case BranchOp.BrGt:                      case BranchOp.BrGe:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' false);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Switch:                  {                      var switchi = (SwitchInstruction)instruction;                      state.PeekExpectedType(0' global.Int32Ref' changed);                      var newState = state.Pop(1);                      for (var i = 0; i < switchi.CaseTargets.Count; i++)                          UnifyBeforeState(newState' switchi.CaseTargets[i]' changed);                      return newState;                  }              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      // WARNING: Capured type may not be final                      // NOTE: May capture skolemized types                      switch (cmpi.Op)                      {                      case CompareOp.Ceq:                      case CompareOp.CnePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' true);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.Clt:                      case CompareOp.Cgt:                      case CompareOp.CgePseudo:                      case CompareOp.ClePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' false);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.CtruePseudo:                      case CompareOp.CfalsePseudo:                          cmpi.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                          return state.PopPushType(1' global.Int32Ref' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var argi = (ArgLocalInstruction)instruction;                      var type = method.ArgLocalType(argi.ArgLocal' argi.Index);                      switch (argi.Op)                      {                      case ArgLocalOp.Ld:                          return state.PushType(type' state.ArgLocalPointsTo(argi.ArgLocal' argi.Index));                      case ArgLocalOp.Lda:                          return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(type)' ArgLocalPT(argi.ArgLocal' argi.Index));                      case ArgLocalOp.St:                          {                              state.PeekExpectedType(0' type' changed);                              var pointsTo = state.PeekPointsTo(0);                              if (!pointsTo.IsBottom)                              {                                  if (!(type.Style(methEnv) is ManagedPointerTypeStyle))                                      throw new InvalidOperationException                                          ("stack indicates pointer' but parameter or local type does not");                                  if (pointsTo.PointsOutsideOfHeap)                                      throw new InvalidOperationException("arguments cannot point outside of the heap");                              }                              return state.PopAddArgLocalPointsTo(1' argi.ArgLocal' argi.Index' pointsTo);                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      var fieldEnv = fieldi.Field.Enter(methEnv);                      var fieldType = fieldEnv.SubstituteType(fieldEnv.Field.FieldType);                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                              return state.PushType(fieldType' BottomPT);                          else                          {                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' true' changed);                              return state.PopPushType(1' fieldType' BottomPT);                          }                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                              return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          else                          {                              // Underlying type cannot be a struct' otherwise would have a pointer into                              // the stack                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' false' changed);                              return state.PopPushType                                  (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          }                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                          {                              state.PeekExpectedType(0' fieldType' changed);                              return state.Pop(1);                          }                          else                          {                              state.PeekExpectedType(0' fieldType' changed);                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (1' fieldi.Field.DefiningType' false' changed);                              return state.Pop(2);                          }                      case FieldOp.Ldtoken:                          return state.PushType(global.RuntimeFieldHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methi = (MethodInstruction)instruction;                      var sig = (CST.MethodSignature)methi.Method.ExternalSignature;                      switch (methi.Op)                      {                      case MethodOp.Call:                          {                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              if (methi.Constrained != null)                              {                                  if (!methi.IsVirtual || methi.Method.IsStatic)                                      throw new InvalidOperationException                                          ("constrained only valid on virtual calls to instance methods");                                  var thisType = sig.Parameters[0];                                  var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(methi.Constrained);                                  var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo(methi.Constrained);                                  var cs = methi.Constrained.Style(methEnv);                                  if (cs is ValueTypeStyle)                                  {                                      if (thisType.Style(methEnv) is ManagedPointerTypeStyle)                                      {                                          // We pass the argument pointer as is                                          if (!methi.Constrained.IsAssignableTo(methEnv' thisType.Arguments[0]))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                      else                                      {                                          // *Case 1* Morally we deref the argument pointer and box the contents'                                          // but since no supertype of a value type may mutate the underlying value'                                          // we don't need to take a copy of the value when boxing' so in practice                                          // this is a no-op                                          if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                  }                                  else if (cs is ReferenceTypeStyle)                                  {                                      // *Case 2* We dereference the pointer and pass the object reference                                      if (!methi.Constrained.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else if (cs is ParameterTypeStyle)                                  {                                      // Since we are calling an instance method' we know the first argument cannot be                                      // a "naked" type parameter' but is either a class or an interface.                                      // We must decide between cases 1 and 2 above at runtime' but checking as                                      // per case 1 is sufficient now.                                      // NOTE: As for box/classcast/isinst below' if the parameter is                                      // instantiated to a reference type then the type box type is considered                                      // equivalent to the underyling reference type.                                      if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else                                      throw new InvalidOperationException                                          ("constrained must be value' reference or parameter type");                                    state.PeekExpectedType(sig.Parameters.Count - 1' constrainedPtr' changed);                              }                              else if (sig.Parameters.Count > 0)                                  state.PeekExpectedType(sig.Parameters.Count - 1' sig.Parameters[0]' changed);                              if (sig.Result == null)                                  return state.Pop(sig.Parameters.Count);                              else                                  return state.PopPushType(sig.Parameters.Count' sig.Result' BottomPT);                          }                      case MethodOp.Ldftn:                          {                              // NOTE: Verified CLR allows only the two "blessed" sequences:                              //   dup; ldvirtftn; newobj <delegate ctor>                              //   ldftn; newobj <delegate ctor>                              // It is thus possible to check the delegate will capture an instance which                              // implements the loaded method. However' we don't check that here.                              if (methi.IsVirtual)                              {                                  if (methi.Method.IsStatic)                                      throw new InvalidOperationException("cannot ldvirtftn of a static method");                                  var objectType = default(TypeRef);                                  if (sig.Parameters[0].Style(methEnv) is ManagedPointerTypeStyle)                                      // Object should be a box                                      objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(sig.Parameters[0].Arguments[0]);                                  else                                      // Object should match parameter                                      objectType = sig.Parameters[0];                                  state.PeekExpectedType(0' objectType' changed);                                  return state.PopPushType(1' sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                              else                              {                                  if (methi.Method.IsStatic)                                      return state.PushType(sig.ToCodePointer(methEnv.Global)' BottomPT);                                  else                                      return state.PushType(sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                          }                      case MethodOp.Newobj:                          {                              if (methi.Method.IsStatic || sig.Result != null)                                  throw new InvalidOperationException("not a constructor");                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              // First argument to constructor is created by runtime. If definining type is                              // a value type' first argument will be a pointer' but result left on stack                              // will be the value itself.                              return state.PopPushType(sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);                          }                      case MethodOp.Ldtoken:                          return state.PushType(global.RuntimeMethodHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          state.PeekReadPointerType(0' typei.Type);                          return state.PopPushType(1' typei.Type' BottomPT);                      case TypeOp.Stobj:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Cpobj:                          state.PeekReadPointerType(0' typei.Type);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Newarr:                          state.PeekIndexType(0);                          return state.PopPushType(1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo(typei.Type)' BottomPT);                      case TypeOp.Initobj:                          state.PeekWritePointerType(0' typei.Type);                          return state.Pop(1);                      case TypeOp.Castclass:                      case TypeOp.Isinst:                      case TypeOp.Box:                          {                              var resultType = default(TypeRef);                              var s = typei.Type.Style(methEnv);                              if (s is NullableTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type.Arguments[0]);                              else if (s is ValueTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else if (s is ReferenceTypeStyle)                                  resultType = typei.Type;                              else if (s is ParameterTypeStyle)                                  // NOTE: As for constrained call above' if type parameter is instantitated to                                  // a ref type' then this box type is considered equivalent to the                                  // underlying reference type.                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else                                  throw new InvalidOperationException                                      ("can only box/cast to reference' value or parameter type");                              if (typei.Op == TypeOp.Box)                                  state.PeekExpectedType(0' typei.Type' changed);                              else                                  state.PeekReferenceType(0);                              return state.PopPushType(1' resultType' BottomPT);                          }                      case TypeOp.Unbox:                          if (!(typei.Type.Style(methEnv) is ValueTypeStyle))                              // Parameter types are not allowed                              throw new InvalidOperationException("type must be a value type");                          state.PeekBoxedType(0' typei.Type' changed);                          return state.PopPushType(1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(typei.Type)' HeapPT);                      case TypeOp.UnboxAny:                          {                              var s = typei.Type.Style(methEnv);                              if (s is ValueTypeStyle)                                  state.PeekBoxedType(0' typei.Type' changed);                              else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))                                  throw new InvalidOperationException("type must be value' reference or parameter type");                              return state.PopPushType(1' typei.Type' BottomPT);                          }                      case TypeOp.Ldtoken:                          return state.PushType(global.RuntimeTypeHandleRef' BottomPT);                      case TypeOp.Ldelem:                          state.PeekIndexType(0);                          state.PeekReadArrayType(1' typei.Type' false);                          return state.PopPushType(2' typei.Type' BottomPT);                      case TypeOp.Stelem:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekIndexType(1);                          state.PeekWriteArrayType(2' typei.Type);                          return state.Pop(3);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  {                      var ldelemai = (LdElemAddrInstruction)instruction;                      state.PeekIndexType(0);                      // WARNING: May prematurely fail for non-readonly loads                      state.PeekReadArrayType(1' ldelemai.Type' !ldelemai.IsReadonly);                      return state.PopPushType(2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(ldelemai.Type)' HeapPT);                  }              case InstructionFlavor.LdInt32:                  return state.PushType(global.Int32Ref' BottomPT);              case InstructionFlavor.LdInt64:                  return state.PushType(global.Int64Ref' BottomPT);              case InstructionFlavor.LdSingle:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdDouble:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdString:                  return state.PushType(global.StringRef' BottomPT);              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.Div:                      case ArithOp.Rem:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' true);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.Neg:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' true);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' false);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.BitNot:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.Shl:                      case ArithOp.Shr:                          state.PeekExpectedType(0' global.Int32Ref' changed);                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(1' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(2' arithi.Type' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned &&                                           convi.TargetNumberFlavor == NumberFlavor.Double);                      // NOTE: May capture skolemized types                      convi.SourceType = state.PeekNumberType(0' !mustBeInteger);                      return state.PopPushType(1' TypeRef.NumberFrom(methEnv.Global' convi.TargetNumberFlavor)' BottomPT);                  }              case InstructionFlavor.Try:                  {                      var tryi = (TryInstruction)instruction;                      // Isolation:                      //  - There is no way for the current stack shape to influence or be influenced by                      //    inference of the try' since the current stack shape must be empty.                      //  - There is no way for the try to influence the result stack shape' since it must be                      //    empty.                      //  - However pointers in arguments and locals may propogate into and out of try body                      //    via exceptional transitions. The latter are delt with separately.                      if (state.Depth != 0)                          throw new InvalidOperationException("stack should be empty");                      var newState = ForwardBlock                          (new TryBodyInstructionContext(context' index' tryi.Body)' state' changed);                      for (var j = 0; j < tryi.Handlers.Count; j++)                      {                          var h = tryi.Handlers[j];                          var handlerContext = new TryHandlerInstructionContext(context' index' h.Body' j);                          var initHandlerState = new MachineState                              (methEnv' method.ValueParameters.Count' method.Locals.Count);                          switch (h.Flavor)                          {                          case HandlerFlavor.Catch:                              {                                  var catchh = (CatchTryInstructionHandler)h;                                  ForwardBlock(handlerContext' initHandlerState.PushType(catchh.Type' BottomPT)' changed);                                  break;                              }                          case HandlerFlavor.Filter:                              throw new NotSupportedException("filter handler blocks");                          case HandlerFlavor.Fault:                          case HandlerFlavor.Finally:                              ForwardBlock(handlerContext' initHandlerState' changed);                              break;                          default:                              throw new ArgumentOutOfRangeException();                          }                      }                      return newState;                  }              case InstructionFlavor.IfThenElsePseudo:              case InstructionFlavor.ShortCircuitingPseudo:              case InstructionFlavor.StructuralSwitchPseudo:              case InstructionFlavor.LoopPseudo:              case InstructionFlavor.WhileDoPseudo:              case InstructionFlavor.DoWhilePseudo:              case InstructionFlavor.LoopControlPseudo:                  throw new InvalidOperationException("no machine state inference for psuedo-instructions");              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return state;                      case MiscOp.Dup:                          return state.Push(state.Peek(0));                      case MiscOp.Pop:                          return state.Pop(1);                      case MiscOp.Ldnull:                          return state.PushType(global.NullRef' BottomPT);                      case MiscOp.Ckfinite:                          state.PeekExpectedType(0' global.DoubleRef' changed);                          // Assume the instruction can "peek" at top of stack' thus no need for pop/push.                          return state;                      case MiscOp.Throw:                          state.PeekReferenceType(0);                          return state.DiscardStack();                      case MiscOp.Rethrow:                          return state.DiscardStack();                      case MiscOp.LdindRef:                          {                              var elemType = state.PeekPointerToReferenceType(0);                              return state.PopPushType(1' elemType' BottomPT);                          }                      case MiscOp.StindRef:                          {                              var expElemType = state.PeekPointerToReferenceType(1);                              state.PeekExpectedType(0' expElemType' changed);                              return state.Pop(2);                          }                      case MiscOp.LdelemRef:                          {                              state.PeekIndexType(0);                              // WARNING: Type may not be final                              var elemType = state.PeekArrayOfReferenceType(1);                              return state.PopPushType(2' elemType' BottomPT);                          }                      case MiscOp.StelemRef:                          state.PeekReferenceType(0);                          state.PeekIndexType(1);                          state.PeekArrayOfReferenceType(2);                          // Since the value type and array element type may be independently generalized'                          // it is pointless to check that the first is assignable to the second.                          // Instead this check is done at runtime.                          return state.Pop(3);                      case MiscOp.Ldlen:                          state.PeekArrayOfAnyType(0);                          return state.PopPushType(1' global.IntNativeRef' BottomPT);                      case MiscOp.Ret:                          {                              if (state.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return state; // empty                          }                      case MiscOp.RetVal:                          {                              state.PeekExpectedType(0' method.Result.Type' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfilter:                          {                              state.PeekExpectedType(0' global.Int32Ref' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfinally:                          {                              // Control could transfer to an outer finally/fault block' or to the target                              // of a leave instruction. However these transitions are delt with separately.                              return state.DiscardStack();                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:                  {                      var bri = (BranchInstruction)instruction;                      switch (bri.Op)                      {                      case BranchOp.Br:                          UnifyBeforeState(state' bri.Target' changed);                          return state;                      case BranchOp.Brtrue:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' false);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Brfalse:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Breq:                      case BranchOp.Brne:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' true);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Leave:                          {                              // Control could transfer via finally blocks instead of directly to the leave target.                              // Propogate only that the stack must be empty at target. Remaining machine state                              // is dealt with separately.                              UnifyBeforeState                                  (new MachineState(methEnv' method.ValueParameters.Count' method.Locals.Count)'                                   bri.Target'                                   changed);                              return state.DiscardStack();                          }                      case BranchOp.BrLt:                      case BranchOp.BrLe:                      case BranchOp.BrGt:                      case BranchOp.BrGe:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' false);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Switch:                  {                      var switchi = (SwitchInstruction)instruction;                      state.PeekExpectedType(0' global.Int32Ref' changed);                      var newState = state.Pop(1);                      for (var i = 0; i < switchi.CaseTargets.Count; i++)                          UnifyBeforeState(newState' switchi.CaseTargets[i]' changed);                      return newState;                  }              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      // WARNING: Capured type may not be final                      // NOTE: May capture skolemized types                      switch (cmpi.Op)                      {                      case CompareOp.Ceq:                      case CompareOp.CnePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' true);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.Clt:                      case CompareOp.Cgt:                      case CompareOp.CgePseudo:                      case CompareOp.ClePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' false);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.CtruePseudo:                      case CompareOp.CfalsePseudo:                          cmpi.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                          return state.PopPushType(1' global.Int32Ref' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var argi = (ArgLocalInstruction)instruction;                      var type = method.ArgLocalType(argi.ArgLocal' argi.Index);                      switch (argi.Op)                      {                      case ArgLocalOp.Ld:                          return state.PushType(type' state.ArgLocalPointsTo(argi.ArgLocal' argi.Index));                      case ArgLocalOp.Lda:                          return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(type)' ArgLocalPT(argi.ArgLocal' argi.Index));                      case ArgLocalOp.St:                          {                              state.PeekExpectedType(0' type' changed);                              var pointsTo = state.PeekPointsTo(0);                              if (!pointsTo.IsBottom)                              {                                  if (!(type.Style(methEnv) is ManagedPointerTypeStyle))                                      throw new InvalidOperationException                                          ("stack indicates pointer' but parameter or local type does not");                                  if (pointsTo.PointsOutsideOfHeap)                                      throw new InvalidOperationException("arguments cannot point outside of the heap");                              }                              return state.PopAddArgLocalPointsTo(1' argi.ArgLocal' argi.Index' pointsTo);                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      var fieldEnv = fieldi.Field.Enter(methEnv);                      var fieldType = fieldEnv.SubstituteType(fieldEnv.Field.FieldType);                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                              return state.PushType(fieldType' BottomPT);                          else                          {                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' true' changed);                              return state.PopPushType(1' fieldType' BottomPT);                          }                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                              return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          else                          {                              // Underlying type cannot be a struct' otherwise would have a pointer into                              // the stack                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' false' changed);                              return state.PopPushType                                  (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          }                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                          {                              state.PeekExpectedType(0' fieldType' changed);                              return state.Pop(1);                          }                          else                          {                              state.PeekExpectedType(0' fieldType' changed);                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (1' fieldi.Field.DefiningType' false' changed);                              return state.Pop(2);                          }                      case FieldOp.Ldtoken:                          return state.PushType(global.RuntimeFieldHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methi = (MethodInstruction)instruction;                      var sig = (CST.MethodSignature)methi.Method.ExternalSignature;                      switch (methi.Op)                      {                      case MethodOp.Call:                          {                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              if (methi.Constrained != null)                              {                                  if (!methi.IsVirtual || methi.Method.IsStatic)                                      throw new InvalidOperationException                                          ("constrained only valid on virtual calls to instance methods");                                  var thisType = sig.Parameters[0];                                  var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(methi.Constrained);                                  var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo(methi.Constrained);                                  var cs = methi.Constrained.Style(methEnv);                                  if (cs is ValueTypeStyle)                                  {                                      if (thisType.Style(methEnv) is ManagedPointerTypeStyle)                                      {                                          // We pass the argument pointer as is                                          if (!methi.Constrained.IsAssignableTo(methEnv' thisType.Arguments[0]))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                      else                                      {                                          // *Case 1* Morally we deref the argument pointer and box the contents'                                          // but since no supertype of a value type may mutate the underlying value'                                          // we don't need to take a copy of the value when boxing' so in practice                                          // this is a no-op                                          if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                  }                                  else if (cs is ReferenceTypeStyle)                                  {                                      // *Case 2* We dereference the pointer and pass the object reference                                      if (!methi.Constrained.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else if (cs is ParameterTypeStyle)                                  {                                      // Since we are calling an instance method' we know the first argument cannot be                                      // a "naked" type parameter' but is either a class or an interface.                                      // We must decide between cases 1 and 2 above at runtime' but checking as                                      // per case 1 is sufficient now.                                      // NOTE: As for box/classcast/isinst below' if the parameter is                                      // instantiated to a reference type then the type box type is considered                                      // equivalent to the underyling reference type.                                      if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else                                      throw new InvalidOperationException                                          ("constrained must be value' reference or parameter type");                                    state.PeekExpectedType(sig.Parameters.Count - 1' constrainedPtr' changed);                              }                              else if (sig.Parameters.Count > 0)                                  state.PeekExpectedType(sig.Parameters.Count - 1' sig.Parameters[0]' changed);                              if (sig.Result == null)                                  return state.Pop(sig.Parameters.Count);                              else                                  return state.PopPushType(sig.Parameters.Count' sig.Result' BottomPT);                          }                      case MethodOp.Ldftn:                          {                              // NOTE: Verified CLR allows only the two "blessed" sequences:                              //   dup; ldvirtftn; newobj <delegate ctor>                              //   ldftn; newobj <delegate ctor>                              // It is thus possible to check the delegate will capture an instance which                              // implements the loaded method. However' we don't check that here.                              if (methi.IsVirtual)                              {                                  if (methi.Method.IsStatic)                                      throw new InvalidOperationException("cannot ldvirtftn of a static method");                                  var objectType = default(TypeRef);                                  if (sig.Parameters[0].Style(methEnv) is ManagedPointerTypeStyle)                                      // Object should be a box                                      objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(sig.Parameters[0].Arguments[0]);                                  else                                      // Object should match parameter                                      objectType = sig.Parameters[0];                                  state.PeekExpectedType(0' objectType' changed);                                  return state.PopPushType(1' sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                              else                              {                                  if (methi.Method.IsStatic)                                      return state.PushType(sig.ToCodePointer(methEnv.Global)' BottomPT);                                  else                                      return state.PushType(sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                          }                      case MethodOp.Newobj:                          {                              if (methi.Method.IsStatic || sig.Result != null)                                  throw new InvalidOperationException("not a constructor");                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              // First argument to constructor is created by runtime. If definining type is                              // a value type' first argument will be a pointer' but result left on stack                              // will be the value itself.                              return state.PopPushType(sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);                          }                      case MethodOp.Ldtoken:                          return state.PushType(global.RuntimeMethodHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          state.PeekReadPointerType(0' typei.Type);                          return state.PopPushType(1' typei.Type' BottomPT);                      case TypeOp.Stobj:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Cpobj:                          state.PeekReadPointerType(0' typei.Type);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Newarr:                          state.PeekIndexType(0);                          return state.PopPushType(1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo(typei.Type)' BottomPT);                      case TypeOp.Initobj:                          state.PeekWritePointerType(0' typei.Type);                          return state.Pop(1);                      case TypeOp.Castclass:                      case TypeOp.Isinst:                      case TypeOp.Box:                          {                              var resultType = default(TypeRef);                              var s = typei.Type.Style(methEnv);                              if (s is NullableTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type.Arguments[0]);                              else if (s is ValueTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else if (s is ReferenceTypeStyle)                                  resultType = typei.Type;                              else if (s is ParameterTypeStyle)                                  // NOTE: As for constrained call above' if type parameter is instantitated to                                  // a ref type' then this box type is considered equivalent to the                                  // underlying reference type.                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else                                  throw new InvalidOperationException                                      ("can only box/cast to reference' value or parameter type");                              if (typei.Op == TypeOp.Box)                                  state.PeekExpectedType(0' typei.Type' changed);                              else                                  state.PeekReferenceType(0);                              return state.PopPushType(1' resultType' BottomPT);                          }                      case TypeOp.Unbox:                          if (!(typei.Type.Style(methEnv) is ValueTypeStyle))                              // Parameter types are not allowed                              throw new InvalidOperationException("type must be a value type");                          state.PeekBoxedType(0' typei.Type' changed);                          return state.PopPushType(1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(typei.Type)' HeapPT);                      case TypeOp.UnboxAny:                          {                              var s = typei.Type.Style(methEnv);                              if (s is ValueTypeStyle)                                  state.PeekBoxedType(0' typei.Type' changed);                              else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))                                  throw new InvalidOperationException("type must be value' reference or parameter type");                              return state.PopPushType(1' typei.Type' BottomPT);                          }                      case TypeOp.Ldtoken:                          return state.PushType(global.RuntimeTypeHandleRef' BottomPT);                      case TypeOp.Ldelem:                          state.PeekIndexType(0);                          state.PeekReadArrayType(1' typei.Type' false);                          return state.PopPushType(2' typei.Type' BottomPT);                      case TypeOp.Stelem:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekIndexType(1);                          state.PeekWriteArrayType(2' typei.Type);                          return state.Pop(3);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  {                      var ldelemai = (LdElemAddrInstruction)instruction;                      state.PeekIndexType(0);                      // WARNING: May prematurely fail for non-readonly loads                      state.PeekReadArrayType(1' ldelemai.Type' !ldelemai.IsReadonly);                      return state.PopPushType(2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(ldelemai.Type)' HeapPT);                  }              case InstructionFlavor.LdInt32:                  return state.PushType(global.Int32Ref' BottomPT);              case InstructionFlavor.LdInt64:                  return state.PushType(global.Int64Ref' BottomPT);              case InstructionFlavor.LdSingle:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdDouble:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdString:                  return state.PushType(global.StringRef' BottomPT);              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.Div:                      case ArithOp.Rem:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' true);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.Neg:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' true);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' false);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.BitNot:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.Shl:                      case ArithOp.Shr:                          state.PeekExpectedType(0' global.Int32Ref' changed);                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(1' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(2' arithi.Type' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned &&                                           convi.TargetNumberFlavor == NumberFlavor.Double);                      // NOTE: May capture skolemized types                      convi.SourceType = state.PeekNumberType(0' !mustBeInteger);                      return state.PopPushType(1' TypeRef.NumberFrom(methEnv.Global' convi.TargetNumberFlavor)' BottomPT);                  }              case InstructionFlavor.Try:                  {                      var tryi = (TryInstruction)instruction;                      // Isolation:                      //  - There is no way for the current stack shape to influence or be influenced by                      //    inference of the try' since the current stack shape must be empty.                      //  - There is no way for the try to influence the result stack shape' since it must be                      //    empty.                      //  - However pointers in arguments and locals may propogate into and out of try body                      //    via exceptional transitions. The latter are delt with separately.                      if (state.Depth != 0)                          throw new InvalidOperationException("stack should be empty");                      var newState = ForwardBlock                          (new TryBodyInstructionContext(context' index' tryi.Body)' state' changed);                      for (var j = 0; j < tryi.Handlers.Count; j++)                      {                          var h = tryi.Handlers[j];                          var handlerContext = new TryHandlerInstructionContext(context' index' h.Body' j);                          var initHandlerState = new MachineState                              (methEnv' method.ValueParameters.Count' method.Locals.Count);                          switch (h.Flavor)                          {                          case HandlerFlavor.Catch:                              {                                  var catchh = (CatchTryInstructionHandler)h;                                  ForwardBlock(handlerContext' initHandlerState.PushType(catchh.Type' BottomPT)' changed);                                  break;                              }                          case HandlerFlavor.Filter:                              throw new NotSupportedException("filter handler blocks");                          case HandlerFlavor.Fault:                          case HandlerFlavor.Finally:                              ForwardBlock(handlerContext' initHandlerState' changed);                              break;                          default:                              throw new ArgumentOutOfRangeException();                          }                      }                      return newState;                  }              case InstructionFlavor.IfThenElsePseudo:              case InstructionFlavor.ShortCircuitingPseudo:              case InstructionFlavor.StructuralSwitchPseudo:              case InstructionFlavor.LoopPseudo:              case InstructionFlavor.WhileDoPseudo:              case InstructionFlavor.DoWhilePseudo:              case InstructionFlavor.LoopControlPseudo:                  throw new InvalidOperationException("no machine state inference for psuedo-instructions");              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return state;                      case MiscOp.Dup:                          return state.Push(state.Peek(0));                      case MiscOp.Pop:                          return state.Pop(1);                      case MiscOp.Ldnull:                          return state.PushType(global.NullRef' BottomPT);                      case MiscOp.Ckfinite:                          state.PeekExpectedType(0' global.DoubleRef' changed);                          // Assume the instruction can "peek" at top of stack' thus no need for pop/push.                          return state;                      case MiscOp.Throw:                          state.PeekReferenceType(0);                          return state.DiscardStack();                      case MiscOp.Rethrow:                          return state.DiscardStack();                      case MiscOp.LdindRef:                          {                              var elemType = state.PeekPointerToReferenceType(0);                              return state.PopPushType(1' elemType' BottomPT);                          }                      case MiscOp.StindRef:                          {                              var expElemType = state.PeekPointerToReferenceType(1);                              state.PeekExpectedType(0' expElemType' changed);                              return state.Pop(2);                          }                      case MiscOp.LdelemRef:                          {                              state.PeekIndexType(0);                              // WARNING: Type may not be final                              var elemType = state.PeekArrayOfReferenceType(1);                              return state.PopPushType(2' elemType' BottomPT);                          }                      case MiscOp.StelemRef:                          state.PeekReferenceType(0);                          state.PeekIndexType(1);                          state.PeekArrayOfReferenceType(2);                          // Since the value type and array element type may be independently generalized'                          // it is pointless to check that the first is assignable to the second.                          // Instead this check is done at runtime.                          return state.Pop(3);                      case MiscOp.Ldlen:                          state.PeekArrayOfAnyType(0);                          return state.PopPushType(1' global.IntNativeRef' BottomPT);                      case MiscOp.Ret:                          {                              if (state.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return state; // empty                          }                      case MiscOp.RetVal:                          {                              state.PeekExpectedType(0' method.Result.Type' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfilter:                          {                              state.PeekExpectedType(0' global.Int32Ref' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfinally:                          {                              // Control could transfer to an outer finally/fault block' or to the target                              // of a leave instruction. However these transitions are delt with separately.                              return state.DiscardStack();                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:                  {                      var bri = (BranchInstruction)instruction;                      switch (bri.Op)                      {                      case BranchOp.Br:                          UnifyBeforeState(state' bri.Target' changed);                          return state;                      case BranchOp.Brtrue:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' false);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Brfalse:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Breq:                      case BranchOp.Brne:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' true);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Leave:                          {                              // Control could transfer via finally blocks instead of directly to the leave target.                              // Propogate only that the stack must be empty at target. Remaining machine state                              // is dealt with separately.                              UnifyBeforeState                                  (new MachineState(methEnv' method.ValueParameters.Count' method.Locals.Count)'                                   bri.Target'                                   changed);                              return state.DiscardStack();                          }                      case BranchOp.BrLt:                      case BranchOp.BrLe:                      case BranchOp.BrGt:                      case BranchOp.BrGe:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' false);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Switch:                  {                      var switchi = (SwitchInstruction)instruction;                      state.PeekExpectedType(0' global.Int32Ref' changed);                      var newState = state.Pop(1);                      for (var i = 0; i < switchi.CaseTargets.Count; i++)                          UnifyBeforeState(newState' switchi.CaseTargets[i]' changed);                      return newState;                  }              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      // WARNING: Capured type may not be final                      // NOTE: May capture skolemized types                      switch (cmpi.Op)                      {                      case CompareOp.Ceq:                      case CompareOp.CnePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' true);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.Clt:                      case CompareOp.Cgt:                      case CompareOp.CgePseudo:                      case CompareOp.ClePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' false);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.CtruePseudo:                      case CompareOp.CfalsePseudo:                          cmpi.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                          return state.PopPushType(1' global.Int32Ref' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var argi = (ArgLocalInstruction)instruction;                      var type = method.ArgLocalType(argi.ArgLocal' argi.Index);                      switch (argi.Op)                      {                      case ArgLocalOp.Ld:                          return state.PushType(type' state.ArgLocalPointsTo(argi.ArgLocal' argi.Index));                      case ArgLocalOp.Lda:                          return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(type)' ArgLocalPT(argi.ArgLocal' argi.Index));                      case ArgLocalOp.St:                          {                              state.PeekExpectedType(0' type' changed);                              var pointsTo = state.PeekPointsTo(0);                              if (!pointsTo.IsBottom)                              {                                  if (!(type.Style(methEnv) is ManagedPointerTypeStyle))                                      throw new InvalidOperationException                                          ("stack indicates pointer' but parameter or local type does not");                                  if (pointsTo.PointsOutsideOfHeap)                                      throw new InvalidOperationException("arguments cannot point outside of the heap");                              }                              return state.PopAddArgLocalPointsTo(1' argi.ArgLocal' argi.Index' pointsTo);                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      var fieldEnv = fieldi.Field.Enter(methEnv);                      var fieldType = fieldEnv.SubstituteType(fieldEnv.Field.FieldType);                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                              return state.PushType(fieldType' BottomPT);                          else                          {                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' true' changed);                              return state.PopPushType(1' fieldType' BottomPT);                          }                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                              return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          else                          {                              // Underlying type cannot be a struct' otherwise would have a pointer into                              // the stack                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' false' changed);                              return state.PopPushType                                  (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          }                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                          {                              state.PeekExpectedType(0' fieldType' changed);                              return state.Pop(1);                          }                          else                          {                              state.PeekExpectedType(0' fieldType' changed);                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (1' fieldi.Field.DefiningType' false' changed);                              return state.Pop(2);                          }                      case FieldOp.Ldtoken:                          return state.PushType(global.RuntimeFieldHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methi = (MethodInstruction)instruction;                      var sig = (CST.MethodSignature)methi.Method.ExternalSignature;                      switch (methi.Op)                      {                      case MethodOp.Call:                          {                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              if (methi.Constrained != null)                              {                                  if (!methi.IsVirtual || methi.Method.IsStatic)                                      throw new InvalidOperationException                                          ("constrained only valid on virtual calls to instance methods");                                  var thisType = sig.Parameters[0];                                  var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(methi.Constrained);                                  var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo(methi.Constrained);                                  var cs = methi.Constrained.Style(methEnv);                                  if (cs is ValueTypeStyle)                                  {                                      if (thisType.Style(methEnv) is ManagedPointerTypeStyle)                                      {                                          // We pass the argument pointer as is                                          if (!methi.Constrained.IsAssignableTo(methEnv' thisType.Arguments[0]))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                      else                                      {                                          // *Case 1* Morally we deref the argument pointer and box the contents'                                          // but since no supertype of a value type may mutate the underlying value'                                          // we don't need to take a copy of the value when boxing' so in practice                                          // this is a no-op                                          if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                  }                                  else if (cs is ReferenceTypeStyle)                                  {                                      // *Case 2* We dereference the pointer and pass the object reference                                      if (!methi.Constrained.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else if (cs is ParameterTypeStyle)                                  {                                      // Since we are calling an instance method' we know the first argument cannot be                                      // a "naked" type parameter' but is either a class or an interface.                                      // We must decide between cases 1 and 2 above at runtime' but checking as                                      // per case 1 is sufficient now.                                      // NOTE: As for box/classcast/isinst below' if the parameter is                                      // instantiated to a reference type then the type box type is considered                                      // equivalent to the underyling reference type.                                      if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else                                      throw new InvalidOperationException                                          ("constrained must be value' reference or parameter type");                                    state.PeekExpectedType(sig.Parameters.Count - 1' constrainedPtr' changed);                              }                              else if (sig.Parameters.Count > 0)                                  state.PeekExpectedType(sig.Parameters.Count - 1' sig.Parameters[0]' changed);                              if (sig.Result == null)                                  return state.Pop(sig.Parameters.Count);                              else                                  return state.PopPushType(sig.Parameters.Count' sig.Result' BottomPT);                          }                      case MethodOp.Ldftn:                          {                              // NOTE: Verified CLR allows only the two "blessed" sequences:                              //   dup; ldvirtftn; newobj <delegate ctor>                              //   ldftn; newobj <delegate ctor>                              // It is thus possible to check the delegate will capture an instance which                              // implements the loaded method. However' we don't check that here.                              if (methi.IsVirtual)                              {                                  if (methi.Method.IsStatic)                                      throw new InvalidOperationException("cannot ldvirtftn of a static method");                                  var objectType = default(TypeRef);                                  if (sig.Parameters[0].Style(methEnv) is ManagedPointerTypeStyle)                                      // Object should be a box                                      objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(sig.Parameters[0].Arguments[0]);                                  else                                      // Object should match parameter                                      objectType = sig.Parameters[0];                                  state.PeekExpectedType(0' objectType' changed);                                  return state.PopPushType(1' sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                              else                              {                                  if (methi.Method.IsStatic)                                      return state.PushType(sig.ToCodePointer(methEnv.Global)' BottomPT);                                  else                                      return state.PushType(sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                          }                      case MethodOp.Newobj:                          {                              if (methi.Method.IsStatic || sig.Result != null)                                  throw new InvalidOperationException("not a constructor");                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              // First argument to constructor is created by runtime. If definining type is                              // a value type' first argument will be a pointer' but result left on stack                              // will be the value itself.                              return state.PopPushType(sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);                          }                      case MethodOp.Ldtoken:                          return state.PushType(global.RuntimeMethodHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          state.PeekReadPointerType(0' typei.Type);                          return state.PopPushType(1' typei.Type' BottomPT);                      case TypeOp.Stobj:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Cpobj:                          state.PeekReadPointerType(0' typei.Type);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Newarr:                          state.PeekIndexType(0);                          return state.PopPushType(1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo(typei.Type)' BottomPT);                      case TypeOp.Initobj:                          state.PeekWritePointerType(0' typei.Type);                          return state.Pop(1);                      case TypeOp.Castclass:                      case TypeOp.Isinst:                      case TypeOp.Box:                          {                              var resultType = default(TypeRef);                              var s = typei.Type.Style(methEnv);                              if (s is NullableTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type.Arguments[0]);                              else if (s is ValueTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else if (s is ReferenceTypeStyle)                                  resultType = typei.Type;                              else if (s is ParameterTypeStyle)                                  // NOTE: As for constrained call above' if type parameter is instantitated to                                  // a ref type' then this box type is considered equivalent to the                                  // underlying reference type.                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else                                  throw new InvalidOperationException                                      ("can only box/cast to reference' value or parameter type");                              if (typei.Op == TypeOp.Box)                                  state.PeekExpectedType(0' typei.Type' changed);                              else                                  state.PeekReferenceType(0);                              return state.PopPushType(1' resultType' BottomPT);                          }                      case TypeOp.Unbox:                          if (!(typei.Type.Style(methEnv) is ValueTypeStyle))                              // Parameter types are not allowed                              throw new InvalidOperationException("type must be a value type");                          state.PeekBoxedType(0' typei.Type' changed);                          return state.PopPushType(1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(typei.Type)' HeapPT);                      case TypeOp.UnboxAny:                          {                              var s = typei.Type.Style(methEnv);                              if (s is ValueTypeStyle)                                  state.PeekBoxedType(0' typei.Type' changed);                              else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))                                  throw new InvalidOperationException("type must be value' reference or parameter type");                              return state.PopPushType(1' typei.Type' BottomPT);                          }                      case TypeOp.Ldtoken:                          return state.PushType(global.RuntimeTypeHandleRef' BottomPT);                      case TypeOp.Ldelem:                          state.PeekIndexType(0);                          state.PeekReadArrayType(1' typei.Type' false);                          return state.PopPushType(2' typei.Type' BottomPT);                      case TypeOp.Stelem:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekIndexType(1);                          state.PeekWriteArrayType(2' typei.Type);                          return state.Pop(3);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  {                      var ldelemai = (LdElemAddrInstruction)instruction;                      state.PeekIndexType(0);                      // WARNING: May prematurely fail for non-readonly loads                      state.PeekReadArrayType(1' ldelemai.Type' !ldelemai.IsReadonly);                      return state.PopPushType(2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(ldelemai.Type)' HeapPT);                  }              case InstructionFlavor.LdInt32:                  return state.PushType(global.Int32Ref' BottomPT);              case InstructionFlavor.LdInt64:                  return state.PushType(global.Int64Ref' BottomPT);              case InstructionFlavor.LdSingle:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdDouble:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdString:                  return state.PushType(global.StringRef' BottomPT);              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.Div:                      case ArithOp.Rem:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' true);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.Neg:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' true);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' false);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.BitNot:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.Shl:                      case ArithOp.Shr:                          state.PeekExpectedType(0' global.Int32Ref' changed);                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(1' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(2' arithi.Type' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned &&                                           convi.TargetNumberFlavor == NumberFlavor.Double);                      // NOTE: May capture skolemized types                      convi.SourceType = state.PeekNumberType(0' !mustBeInteger);                      return state.PopPushType(1' TypeRef.NumberFrom(methEnv.Global' convi.TargetNumberFlavor)' BottomPT);                  }              case InstructionFlavor.Try:                  {                      var tryi = (TryInstruction)instruction;                      // Isolation:                      //  - There is no way for the current stack shape to influence or be influenced by                      //    inference of the try' since the current stack shape must be empty.                      //  - There is no way for the try to influence the result stack shape' since it must be                      //    empty.                      //  - However pointers in arguments and locals may propogate into and out of try body                      //    via exceptional transitions. The latter are delt with separately.                      if (state.Depth != 0)                          throw new InvalidOperationException("stack should be empty");                      var newState = ForwardBlock                          (new TryBodyInstructionContext(context' index' tryi.Body)' state' changed);                      for (var j = 0; j < tryi.Handlers.Count; j++)                      {                          var h = tryi.Handlers[j];                          var handlerContext = new TryHandlerInstructionContext(context' index' h.Body' j);                          var initHandlerState = new MachineState                              (methEnv' method.ValueParameters.Count' method.Locals.Count);                          switch (h.Flavor)                          {                          case HandlerFlavor.Catch:                              {                                  var catchh = (CatchTryInstructionHandler)h;                                  ForwardBlock(handlerContext' initHandlerState.PushType(catchh.Type' BottomPT)' changed);                                  break;                              }                          case HandlerFlavor.Filter:                              throw new NotSupportedException("filter handler blocks");                          case HandlerFlavor.Fault:                          case HandlerFlavor.Finally:                              ForwardBlock(handlerContext' initHandlerState' changed);                              break;                          default:                              throw new ArgumentOutOfRangeException();                          }                      }                      return newState;                  }              case InstructionFlavor.IfThenElsePseudo:              case InstructionFlavor.ShortCircuitingPseudo:              case InstructionFlavor.StructuralSwitchPseudo:              case InstructionFlavor.LoopPseudo:              case InstructionFlavor.WhileDoPseudo:              case InstructionFlavor.DoWhilePseudo:              case InstructionFlavor.LoopControlPseudo:                  throw new InvalidOperationException("no machine state inference for psuedo-instructions");              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return state;                      case MiscOp.Dup:                          return state.Push(state.Peek(0));                      case MiscOp.Pop:                          return state.Pop(1);                      case MiscOp.Ldnull:                          return state.PushType(global.NullRef' BottomPT);                      case MiscOp.Ckfinite:                          state.PeekExpectedType(0' global.DoubleRef' changed);                          // Assume the instruction can "peek" at top of stack' thus no need for pop/push.                          return state;                      case MiscOp.Throw:                          state.PeekReferenceType(0);                          return state.DiscardStack();                      case MiscOp.Rethrow:                          return state.DiscardStack();                      case MiscOp.LdindRef:                          {                              var elemType = state.PeekPointerToReferenceType(0);                              return state.PopPushType(1' elemType' BottomPT);                          }                      case MiscOp.StindRef:                          {                              var expElemType = state.PeekPointerToReferenceType(1);                              state.PeekExpectedType(0' expElemType' changed);                              return state.Pop(2);                          }                      case MiscOp.LdelemRef:                          {                              state.PeekIndexType(0);                              // WARNING: Type may not be final                              var elemType = state.PeekArrayOfReferenceType(1);                              return state.PopPushType(2' elemType' BottomPT);                          }                      case MiscOp.StelemRef:                          state.PeekReferenceType(0);                          state.PeekIndexType(1);                          state.PeekArrayOfReferenceType(2);                          // Since the value type and array element type may be independently generalized'                          // it is pointless to check that the first is assignable to the second.                          // Instead this check is done at runtime.                          return state.Pop(3);                      case MiscOp.Ldlen:                          state.PeekArrayOfAnyType(0);                          return state.PopPushType(1' global.IntNativeRef' BottomPT);                      case MiscOp.Ret:                          {                              if (state.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return state; // empty                          }                      case MiscOp.RetVal:                          {                              state.PeekExpectedType(0' method.Result.Type' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfilter:                          {                              state.PeekExpectedType(0' global.Int32Ref' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfinally:                          {                              // Control could transfer to an outer finally/fault block' or to the target                              // of a leave instruction. However these transitions are delt with separately.                              return state.DiscardStack();                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:                  {                      var bri = (BranchInstruction)instruction;                      switch (bri.Op)                      {                      case BranchOp.Br:                          UnifyBeforeState(state' bri.Target' changed);                          return state;                      case BranchOp.Brtrue:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' false);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Brfalse:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Breq:                      case BranchOp.Brne:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' true);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Leave:                          {                              // Control could transfer via finally blocks instead of directly to the leave target.                              // Propogate only that the stack must be empty at target. Remaining machine state                              // is dealt with separately.                              UnifyBeforeState                                  (new MachineState(methEnv' method.ValueParameters.Count' method.Locals.Count)'                                   bri.Target'                                   changed);                              return state.DiscardStack();                          }                      case BranchOp.BrLt:                      case BranchOp.BrLe:                      case BranchOp.BrGt:                      case BranchOp.BrGe:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' false);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Switch:                  {                      var switchi = (SwitchInstruction)instruction;                      state.PeekExpectedType(0' global.Int32Ref' changed);                      var newState = state.Pop(1);                      for (var i = 0; i < switchi.CaseTargets.Count; i++)                          UnifyBeforeState(newState' switchi.CaseTargets[i]' changed);                      return newState;                  }              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      // WARNING: Capured type may not be final                      // NOTE: May capture skolemized types                      switch (cmpi.Op)                      {                      case CompareOp.Ceq:                      case CompareOp.CnePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' true);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.Clt:                      case CompareOp.Cgt:                      case CompareOp.CgePseudo:                      case CompareOp.ClePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' false);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.CtruePseudo:                      case CompareOp.CfalsePseudo:                          cmpi.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                          return state.PopPushType(1' global.Int32Ref' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var argi = (ArgLocalInstruction)instruction;                      var type = method.ArgLocalType(argi.ArgLocal' argi.Index);                      switch (argi.Op)                      {                      case ArgLocalOp.Ld:                          return state.PushType(type' state.ArgLocalPointsTo(argi.ArgLocal' argi.Index));                      case ArgLocalOp.Lda:                          return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(type)' ArgLocalPT(argi.ArgLocal' argi.Index));                      case ArgLocalOp.St:                          {                              state.PeekExpectedType(0' type' changed);                              var pointsTo = state.PeekPointsTo(0);                              if (!pointsTo.IsBottom)                              {                                  if (!(type.Style(methEnv) is ManagedPointerTypeStyle))                                      throw new InvalidOperationException                                          ("stack indicates pointer' but parameter or local type does not");                                  if (pointsTo.PointsOutsideOfHeap)                                      throw new InvalidOperationException("arguments cannot point outside of the heap");                              }                              return state.PopAddArgLocalPointsTo(1' argi.ArgLocal' argi.Index' pointsTo);                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      var fieldEnv = fieldi.Field.Enter(methEnv);                      var fieldType = fieldEnv.SubstituteType(fieldEnv.Field.FieldType);                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                              return state.PushType(fieldType' BottomPT);                          else                          {                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' true' changed);                              return state.PopPushType(1' fieldType' BottomPT);                          }                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                              return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          else                          {                              // Underlying type cannot be a struct' otherwise would have a pointer into                              // the stack                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' false' changed);                              return state.PopPushType                                  (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          }                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                          {                              state.PeekExpectedType(0' fieldType' changed);                              return state.Pop(1);                          }                          else                          {                              state.PeekExpectedType(0' fieldType' changed);                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (1' fieldi.Field.DefiningType' false' changed);                              return state.Pop(2);                          }                      case FieldOp.Ldtoken:                          return state.PushType(global.RuntimeFieldHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methi = (MethodInstruction)instruction;                      var sig = (CST.MethodSignature)methi.Method.ExternalSignature;                      switch (methi.Op)                      {                      case MethodOp.Call:                          {                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              if (methi.Constrained != null)                              {                                  if (!methi.IsVirtual || methi.Method.IsStatic)                                      throw new InvalidOperationException                                          ("constrained only valid on virtual calls to instance methods");                                  var thisType = sig.Parameters[0];                                  var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(methi.Constrained);                                  var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo(methi.Constrained);                                  var cs = methi.Constrained.Style(methEnv);                                  if (cs is ValueTypeStyle)                                  {                                      if (thisType.Style(methEnv) is ManagedPointerTypeStyle)                                      {                                          // We pass the argument pointer as is                                          if (!methi.Constrained.IsAssignableTo(methEnv' thisType.Arguments[0]))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                      else                                      {                                          // *Case 1* Morally we deref the argument pointer and box the contents'                                          // but since no supertype of a value type may mutate the underlying value'                                          // we don't need to take a copy of the value when boxing' so in practice                                          // this is a no-op                                          if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                  }                                  else if (cs is ReferenceTypeStyle)                                  {                                      // *Case 2* We dereference the pointer and pass the object reference                                      if (!methi.Constrained.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else if (cs is ParameterTypeStyle)                                  {                                      // Since we are calling an instance method' we know the first argument cannot be                                      // a "naked" type parameter' but is either a class or an interface.                                      // We must decide between cases 1 and 2 above at runtime' but checking as                                      // per case 1 is sufficient now.                                      // NOTE: As for box/classcast/isinst below' if the parameter is                                      // instantiated to a reference type then the type box type is considered                                      // equivalent to the underyling reference type.                                      if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else                                      throw new InvalidOperationException                                          ("constrained must be value' reference or parameter type");                                    state.PeekExpectedType(sig.Parameters.Count - 1' constrainedPtr' changed);                              }                              else if (sig.Parameters.Count > 0)                                  state.PeekExpectedType(sig.Parameters.Count - 1' sig.Parameters[0]' changed);                              if (sig.Result == null)                                  return state.Pop(sig.Parameters.Count);                              else                                  return state.PopPushType(sig.Parameters.Count' sig.Result' BottomPT);                          }                      case MethodOp.Ldftn:                          {                              // NOTE: Verified CLR allows only the two "blessed" sequences:                              //   dup; ldvirtftn; newobj <delegate ctor>                              //   ldftn; newobj <delegate ctor>                              // It is thus possible to check the delegate will capture an instance which                              // implements the loaded method. However' we don't check that here.                              if (methi.IsVirtual)                              {                                  if (methi.Method.IsStatic)                                      throw new InvalidOperationException("cannot ldvirtftn of a static method");                                  var objectType = default(TypeRef);                                  if (sig.Parameters[0].Style(methEnv) is ManagedPointerTypeStyle)                                      // Object should be a box                                      objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(sig.Parameters[0].Arguments[0]);                                  else                                      // Object should match parameter                                      objectType = sig.Parameters[0];                                  state.PeekExpectedType(0' objectType' changed);                                  return state.PopPushType(1' sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                              else                              {                                  if (methi.Method.IsStatic)                                      return state.PushType(sig.ToCodePointer(methEnv.Global)' BottomPT);                                  else                                      return state.PushType(sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                          }                      case MethodOp.Newobj:                          {                              if (methi.Method.IsStatic || sig.Result != null)                                  throw new InvalidOperationException("not a constructor");                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              // First argument to constructor is created by runtime. If definining type is                              // a value type' first argument will be a pointer' but result left on stack                              // will be the value itself.                              return state.PopPushType(sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);                          }                      case MethodOp.Ldtoken:                          return state.PushType(global.RuntimeMethodHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          state.PeekReadPointerType(0' typei.Type);                          return state.PopPushType(1' typei.Type' BottomPT);                      case TypeOp.Stobj:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Cpobj:                          state.PeekReadPointerType(0' typei.Type);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Newarr:                          state.PeekIndexType(0);                          return state.PopPushType(1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo(typei.Type)' BottomPT);                      case TypeOp.Initobj:                          state.PeekWritePointerType(0' typei.Type);                          return state.Pop(1);                      case TypeOp.Castclass:                      case TypeOp.Isinst:                      case TypeOp.Box:                          {                              var resultType = default(TypeRef);                              var s = typei.Type.Style(methEnv);                              if (s is NullableTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type.Arguments[0]);                              else if (s is ValueTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else if (s is ReferenceTypeStyle)                                  resultType = typei.Type;                              else if (s is ParameterTypeStyle)                                  // NOTE: As for constrained call above' if type parameter is instantitated to                                  // a ref type' then this box type is considered equivalent to the                                  // underlying reference type.                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else                                  throw new InvalidOperationException                                      ("can only box/cast to reference' value or parameter type");                              if (typei.Op == TypeOp.Box)                                  state.PeekExpectedType(0' typei.Type' changed);                              else                                  state.PeekReferenceType(0);                              return state.PopPushType(1' resultType' BottomPT);                          }                      case TypeOp.Unbox:                          if (!(typei.Type.Style(methEnv) is ValueTypeStyle))                              // Parameter types are not allowed                              throw new InvalidOperationException("type must be a value type");                          state.PeekBoxedType(0' typei.Type' changed);                          return state.PopPushType(1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(typei.Type)' HeapPT);                      case TypeOp.UnboxAny:                          {                              var s = typei.Type.Style(methEnv);                              if (s is ValueTypeStyle)                                  state.PeekBoxedType(0' typei.Type' changed);                              else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))                                  throw new InvalidOperationException("type must be value' reference or parameter type");                              return state.PopPushType(1' typei.Type' BottomPT);                          }                      case TypeOp.Ldtoken:                          return state.PushType(global.RuntimeTypeHandleRef' BottomPT);                      case TypeOp.Ldelem:                          state.PeekIndexType(0);                          state.PeekReadArrayType(1' typei.Type' false);                          return state.PopPushType(2' typei.Type' BottomPT);                      case TypeOp.Stelem:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekIndexType(1);                          state.PeekWriteArrayType(2' typei.Type);                          return state.Pop(3);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  {                      var ldelemai = (LdElemAddrInstruction)instruction;                      state.PeekIndexType(0);                      // WARNING: May prematurely fail for non-readonly loads                      state.PeekReadArrayType(1' ldelemai.Type' !ldelemai.IsReadonly);                      return state.PopPushType(2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(ldelemai.Type)' HeapPT);                  }              case InstructionFlavor.LdInt32:                  return state.PushType(global.Int32Ref' BottomPT);              case InstructionFlavor.LdInt64:                  return state.PushType(global.Int64Ref' BottomPT);              case InstructionFlavor.LdSingle:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdDouble:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdString:                  return state.PushType(global.StringRef' BottomPT);              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.Div:                      case ArithOp.Rem:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' true);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.Neg:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' true);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' false);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.BitNot:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.Shl:                      case ArithOp.Shr:                          state.PeekExpectedType(0' global.Int32Ref' changed);                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(1' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(2' arithi.Type' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned &&                                           convi.TargetNumberFlavor == NumberFlavor.Double);                      // NOTE: May capture skolemized types                      convi.SourceType = state.PeekNumberType(0' !mustBeInteger);                      return state.PopPushType(1' TypeRef.NumberFrom(methEnv.Global' convi.TargetNumberFlavor)' BottomPT);                  }              case InstructionFlavor.Try:                  {                      var tryi = (TryInstruction)instruction;                      // Isolation:                      //  - There is no way for the current stack shape to influence or be influenced by                      //    inference of the try' since the current stack shape must be empty.                      //  - There is no way for the try to influence the result stack shape' since it must be                      //    empty.                      //  - However pointers in arguments and locals may propogate into and out of try body                      //    via exceptional transitions. The latter are delt with separately.                      if (state.Depth != 0)                          throw new InvalidOperationException("stack should be empty");                      var newState = ForwardBlock                          (new TryBodyInstructionContext(context' index' tryi.Body)' state' changed);                      for (var j = 0; j < tryi.Handlers.Count; j++)                      {                          var h = tryi.Handlers[j];                          var handlerContext = new TryHandlerInstructionContext(context' index' h.Body' j);                          var initHandlerState = new MachineState                              (methEnv' method.ValueParameters.Count' method.Locals.Count);                          switch (h.Flavor)                          {                          case HandlerFlavor.Catch:                              {                                  var catchh = (CatchTryInstructionHandler)h;                                  ForwardBlock(handlerContext' initHandlerState.PushType(catchh.Type' BottomPT)' changed);                                  break;                              }                          case HandlerFlavor.Filter:                              throw new NotSupportedException("filter handler blocks");                          case HandlerFlavor.Fault:                          case HandlerFlavor.Finally:                              ForwardBlock(handlerContext' initHandlerState' changed);                              break;                          default:                              throw new ArgumentOutOfRangeException();                          }                      }                      return newState;                  }              case InstructionFlavor.IfThenElsePseudo:              case InstructionFlavor.ShortCircuitingPseudo:              case InstructionFlavor.StructuralSwitchPseudo:              case InstructionFlavor.LoopPseudo:              case InstructionFlavor.WhileDoPseudo:              case InstructionFlavor.DoWhilePseudo:              case InstructionFlavor.LoopControlPseudo:                  throw new InvalidOperationException("no machine state inference for psuedo-instructions");              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return state;                      case MiscOp.Dup:                          return state.Push(state.Peek(0));                      case MiscOp.Pop:                          return state.Pop(1);                      case MiscOp.Ldnull:                          return state.PushType(global.NullRef' BottomPT);                      case MiscOp.Ckfinite:                          state.PeekExpectedType(0' global.DoubleRef' changed);                          // Assume the instruction can "peek" at top of stack' thus no need for pop/push.                          return state;                      case MiscOp.Throw:                          state.PeekReferenceType(0);                          return state.DiscardStack();                      case MiscOp.Rethrow:                          return state.DiscardStack();                      case MiscOp.LdindRef:                          {                              var elemType = state.PeekPointerToReferenceType(0);                              return state.PopPushType(1' elemType' BottomPT);                          }                      case MiscOp.StindRef:                          {                              var expElemType = state.PeekPointerToReferenceType(1);                              state.PeekExpectedType(0' expElemType' changed);                              return state.Pop(2);                          }                      case MiscOp.LdelemRef:                          {                              state.PeekIndexType(0);                              // WARNING: Type may not be final                              var elemType = state.PeekArrayOfReferenceType(1);                              return state.PopPushType(2' elemType' BottomPT);                          }                      case MiscOp.StelemRef:                          state.PeekReferenceType(0);                          state.PeekIndexType(1);                          state.PeekArrayOfReferenceType(2);                          // Since the value type and array element type may be independently generalized'                          // it is pointless to check that the first is assignable to the second.                          // Instead this check is done at runtime.                          return state.Pop(3);                      case MiscOp.Ldlen:                          state.PeekArrayOfAnyType(0);                          return state.PopPushType(1' global.IntNativeRef' BottomPT);                      case MiscOp.Ret:                          {                              if (state.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return state; // empty                          }                      case MiscOp.RetVal:                          {                              state.PeekExpectedType(0' method.Result.Type' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfilter:                          {                              state.PeekExpectedType(0' global.Int32Ref' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfinally:                          {                              // Control could transfer to an outer finally/fault block' or to the target                              // of a leave instruction. However these transitions are delt with separately.                              return state.DiscardStack();                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:                  {                      var bri = (BranchInstruction)instruction;                      switch (bri.Op)                      {                      case BranchOp.Br:                          UnifyBeforeState(state' bri.Target' changed);                          return state;                      case BranchOp.Brtrue:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' false);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Brfalse:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Breq:                      case BranchOp.Brne:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' true);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Leave:                          {                              // Control could transfer via finally blocks instead of directly to the leave target.                              // Propogate only that the stack must be empty at target. Remaining machine state                              // is dealt with separately.                              UnifyBeforeState                                  (new MachineState(methEnv' method.ValueParameters.Count' method.Locals.Count)'                                   bri.Target'                                   changed);                              return state.DiscardStack();                          }                      case BranchOp.BrLt:                      case BranchOp.BrLe:                      case BranchOp.BrGt:                      case BranchOp.BrGe:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' false);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Switch:                  {                      var switchi = (SwitchInstruction)instruction;                      state.PeekExpectedType(0' global.Int32Ref' changed);                      var newState = state.Pop(1);                      for (var i = 0; i < switchi.CaseTargets.Count; i++)                          UnifyBeforeState(newState' switchi.CaseTargets[i]' changed);                      return newState;                  }              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      // WARNING: Capured type may not be final                      // NOTE: May capture skolemized types                      switch (cmpi.Op)                      {                      case CompareOp.Ceq:                      case CompareOp.CnePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' true);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.Clt:                      case CompareOp.Cgt:                      case CompareOp.CgePseudo:                      case CompareOp.ClePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' false);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.CtruePseudo:                      case CompareOp.CfalsePseudo:                          cmpi.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                          return state.PopPushType(1' global.Int32Ref' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var argi = (ArgLocalInstruction)instruction;                      var type = method.ArgLocalType(argi.ArgLocal' argi.Index);                      switch (argi.Op)                      {                      case ArgLocalOp.Ld:                          return state.PushType(type' state.ArgLocalPointsTo(argi.ArgLocal' argi.Index));                      case ArgLocalOp.Lda:                          return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(type)' ArgLocalPT(argi.ArgLocal' argi.Index));                      case ArgLocalOp.St:                          {                              state.PeekExpectedType(0' type' changed);                              var pointsTo = state.PeekPointsTo(0);                              if (!pointsTo.IsBottom)                              {                                  if (!(type.Style(methEnv) is ManagedPointerTypeStyle))                                      throw new InvalidOperationException                                          ("stack indicates pointer' but parameter or local type does not");                                  if (pointsTo.PointsOutsideOfHeap)                                      throw new InvalidOperationException("arguments cannot point outside of the heap");                              }                              return state.PopAddArgLocalPointsTo(1' argi.ArgLocal' argi.Index' pointsTo);                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      var fieldEnv = fieldi.Field.Enter(methEnv);                      var fieldType = fieldEnv.SubstituteType(fieldEnv.Field.FieldType);                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                              return state.PushType(fieldType' BottomPT);                          else                          {                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' true' changed);                              return state.PopPushType(1' fieldType' BottomPT);                          }                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                              return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          else                          {                              // Underlying type cannot be a struct' otherwise would have a pointer into                              // the stack                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' false' changed);                              return state.PopPushType                                  (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          }                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                          {                              state.PeekExpectedType(0' fieldType' changed);                              return state.Pop(1);                          }                          else                          {                              state.PeekExpectedType(0' fieldType' changed);                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (1' fieldi.Field.DefiningType' false' changed);                              return state.Pop(2);                          }                      case FieldOp.Ldtoken:                          return state.PushType(global.RuntimeFieldHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methi = (MethodInstruction)instruction;                      var sig = (CST.MethodSignature)methi.Method.ExternalSignature;                      switch (methi.Op)                      {                      case MethodOp.Call:                          {                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              if (methi.Constrained != null)                              {                                  if (!methi.IsVirtual || methi.Method.IsStatic)                                      throw new InvalidOperationException                                          ("constrained only valid on virtual calls to instance methods");                                  var thisType = sig.Parameters[0];                                  var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(methi.Constrained);                                  var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo(methi.Constrained);                                  var cs = methi.Constrained.Style(methEnv);                                  if (cs is ValueTypeStyle)                                  {                                      if (thisType.Style(methEnv) is ManagedPointerTypeStyle)                                      {                                          // We pass the argument pointer as is                                          if (!methi.Constrained.IsAssignableTo(methEnv' thisType.Arguments[0]))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                      else                                      {                                          // *Case 1* Morally we deref the argument pointer and box the contents'                                          // but since no supertype of a value type may mutate the underlying value'                                          // we don't need to take a copy of the value when boxing' so in practice                                          // this is a no-op                                          if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                  }                                  else if (cs is ReferenceTypeStyle)                                  {                                      // *Case 2* We dereference the pointer and pass the object reference                                      if (!methi.Constrained.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else if (cs is ParameterTypeStyle)                                  {                                      // Since we are calling an instance method' we know the first argument cannot be                                      // a "naked" type parameter' but is either a class or an interface.                                      // We must decide between cases 1 and 2 above at runtime' but checking as                                      // per case 1 is sufficient now.                                      // NOTE: As for box/classcast/isinst below' if the parameter is                                      // instantiated to a reference type then the type box type is considered                                      // equivalent to the underyling reference type.                                      if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else                                      throw new InvalidOperationException                                          ("constrained must be value' reference or parameter type");                                    state.PeekExpectedType(sig.Parameters.Count - 1' constrainedPtr' changed);                              }                              else if (sig.Parameters.Count > 0)                                  state.PeekExpectedType(sig.Parameters.Count - 1' sig.Parameters[0]' changed);                              if (sig.Result == null)                                  return state.Pop(sig.Parameters.Count);                              else                                  return state.PopPushType(sig.Parameters.Count' sig.Result' BottomPT);                          }                      case MethodOp.Ldftn:                          {                              // NOTE: Verified CLR allows only the two "blessed" sequences:                              //   dup; ldvirtftn; newobj <delegate ctor>                              //   ldftn; newobj <delegate ctor>                              // It is thus possible to check the delegate will capture an instance which                              // implements the loaded method. However' we don't check that here.                              if (methi.IsVirtual)                              {                                  if (methi.Method.IsStatic)                                      throw new InvalidOperationException("cannot ldvirtftn of a static method");                                  var objectType = default(TypeRef);                                  if (sig.Parameters[0].Style(methEnv) is ManagedPointerTypeStyle)                                      // Object should be a box                                      objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(sig.Parameters[0].Arguments[0]);                                  else                                      // Object should match parameter                                      objectType = sig.Parameters[0];                                  state.PeekExpectedType(0' objectType' changed);                                  return state.PopPushType(1' sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                              else                              {                                  if (methi.Method.IsStatic)                                      return state.PushType(sig.ToCodePointer(methEnv.Global)' BottomPT);                                  else                                      return state.PushType(sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                          }                      case MethodOp.Newobj:                          {                              if (methi.Method.IsStatic || sig.Result != null)                                  throw new InvalidOperationException("not a constructor");                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              // First argument to constructor is created by runtime. If definining type is                              // a value type' first argument will be a pointer' but result left on stack                              // will be the value itself.                              return state.PopPushType(sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);                          }                      case MethodOp.Ldtoken:                          return state.PushType(global.RuntimeMethodHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          state.PeekReadPointerType(0' typei.Type);                          return state.PopPushType(1' typei.Type' BottomPT);                      case TypeOp.Stobj:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Cpobj:                          state.PeekReadPointerType(0' typei.Type);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Newarr:                          state.PeekIndexType(0);                          return state.PopPushType(1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo(typei.Type)' BottomPT);                      case TypeOp.Initobj:                          state.PeekWritePointerType(0' typei.Type);                          return state.Pop(1);                      case TypeOp.Castclass:                      case TypeOp.Isinst:                      case TypeOp.Box:                          {                              var resultType = default(TypeRef);                              var s = typei.Type.Style(methEnv);                              if (s is NullableTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type.Arguments[0]);                              else if (s is ValueTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else if (s is ReferenceTypeStyle)                                  resultType = typei.Type;                              else if (s is ParameterTypeStyle)                                  // NOTE: As for constrained call above' if type parameter is instantitated to                                  // a ref type' then this box type is considered equivalent to the                                  // underlying reference type.                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else                                  throw new InvalidOperationException                                      ("can only box/cast to reference' value or parameter type");                              if (typei.Op == TypeOp.Box)                                  state.PeekExpectedType(0' typei.Type' changed);                              else                                  state.PeekReferenceType(0);                              return state.PopPushType(1' resultType' BottomPT);                          }                      case TypeOp.Unbox:                          if (!(typei.Type.Style(methEnv) is ValueTypeStyle))                              // Parameter types are not allowed                              throw new InvalidOperationException("type must be a value type");                          state.PeekBoxedType(0' typei.Type' changed);                          return state.PopPushType(1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(typei.Type)' HeapPT);                      case TypeOp.UnboxAny:                          {                              var s = typei.Type.Style(methEnv);                              if (s is ValueTypeStyle)                                  state.PeekBoxedType(0' typei.Type' changed);                              else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))                                  throw new InvalidOperationException("type must be value' reference or parameter type");                              return state.PopPushType(1' typei.Type' BottomPT);                          }                      case TypeOp.Ldtoken:                          return state.PushType(global.RuntimeTypeHandleRef' BottomPT);                      case TypeOp.Ldelem:                          state.PeekIndexType(0);                          state.PeekReadArrayType(1' typei.Type' false);                          return state.PopPushType(2' typei.Type' BottomPT);                      case TypeOp.Stelem:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekIndexType(1);                          state.PeekWriteArrayType(2' typei.Type);                          return state.Pop(3);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  {                      var ldelemai = (LdElemAddrInstruction)instruction;                      state.PeekIndexType(0);                      // WARNING: May prematurely fail for non-readonly loads                      state.PeekReadArrayType(1' ldelemai.Type' !ldelemai.IsReadonly);                      return state.PopPushType(2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(ldelemai.Type)' HeapPT);                  }              case InstructionFlavor.LdInt32:                  return state.PushType(global.Int32Ref' BottomPT);              case InstructionFlavor.LdInt64:                  return state.PushType(global.Int64Ref' BottomPT);              case InstructionFlavor.LdSingle:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdDouble:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdString:                  return state.PushType(global.StringRef' BottomPT);              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.Div:                      case ArithOp.Rem:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' true);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.Neg:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' true);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' false);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.BitNot:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.Shl:                      case ArithOp.Shr:                          state.PeekExpectedType(0' global.Int32Ref' changed);                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(1' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(2' arithi.Type' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned &&                                           convi.TargetNumberFlavor == NumberFlavor.Double);                      // NOTE: May capture skolemized types                      convi.SourceType = state.PeekNumberType(0' !mustBeInteger);                      return state.PopPushType(1' TypeRef.NumberFrom(methEnv.Global' convi.TargetNumberFlavor)' BottomPT);                  }              case InstructionFlavor.Try:                  {                      var tryi = (TryInstruction)instruction;                      // Isolation:                      //  - There is no way for the current stack shape to influence or be influenced by                      //    inference of the try' since the current stack shape must be empty.                      //  - There is no way for the try to influence the result stack shape' since it must be                      //    empty.                      //  - However pointers in arguments and locals may propogate into and out of try body                      //    via exceptional transitions. The latter are delt with separately.                      if (state.Depth != 0)                          throw new InvalidOperationException("stack should be empty");                      var newState = ForwardBlock                          (new TryBodyInstructionContext(context' index' tryi.Body)' state' changed);                      for (var j = 0; j < tryi.Handlers.Count; j++)                      {                          var h = tryi.Handlers[j];                          var handlerContext = new TryHandlerInstructionContext(context' index' h.Body' j);                          var initHandlerState = new MachineState                              (methEnv' method.ValueParameters.Count' method.Locals.Count);                          switch (h.Flavor)                          {                          case HandlerFlavor.Catch:                              {                                  var catchh = (CatchTryInstructionHandler)h;                                  ForwardBlock(handlerContext' initHandlerState.PushType(catchh.Type' BottomPT)' changed);                                  break;                              }                          case HandlerFlavor.Filter:                              throw new NotSupportedException("filter handler blocks");                          case HandlerFlavor.Fault:                          case HandlerFlavor.Finally:                              ForwardBlock(handlerContext' initHandlerState' changed);                              break;                          default:                              throw new ArgumentOutOfRangeException();                          }                      }                      return newState;                  }              case InstructionFlavor.IfThenElsePseudo:              case InstructionFlavor.ShortCircuitingPseudo:              case InstructionFlavor.StructuralSwitchPseudo:              case InstructionFlavor.LoopPseudo:              case InstructionFlavor.WhileDoPseudo:              case InstructionFlavor.DoWhilePseudo:              case InstructionFlavor.LoopControlPseudo:                  throw new InvalidOperationException("no machine state inference for psuedo-instructions");              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return state;                      case MiscOp.Dup:                          return state.Push(state.Peek(0));                      case MiscOp.Pop:                          return state.Pop(1);                      case MiscOp.Ldnull:                          return state.PushType(global.NullRef' BottomPT);                      case MiscOp.Ckfinite:                          state.PeekExpectedType(0' global.DoubleRef' changed);                          // Assume the instruction can "peek" at top of stack' thus no need for pop/push.                          return state;                      case MiscOp.Throw:                          state.PeekReferenceType(0);                          return state.DiscardStack();                      case MiscOp.Rethrow:                          return state.DiscardStack();                      case MiscOp.LdindRef:                          {                              var elemType = state.PeekPointerToReferenceType(0);                              return state.PopPushType(1' elemType' BottomPT);                          }                      case MiscOp.StindRef:                          {                              var expElemType = state.PeekPointerToReferenceType(1);                              state.PeekExpectedType(0' expElemType' changed);                              return state.Pop(2);                          }                      case MiscOp.LdelemRef:                          {                              state.PeekIndexType(0);                              // WARNING: Type may not be final                              var elemType = state.PeekArrayOfReferenceType(1);                              return state.PopPushType(2' elemType' BottomPT);                          }                      case MiscOp.StelemRef:                          state.PeekReferenceType(0);                          state.PeekIndexType(1);                          state.PeekArrayOfReferenceType(2);                          // Since the value type and array element type may be independently generalized'                          // it is pointless to check that the first is assignable to the second.                          // Instead this check is done at runtime.                          return state.Pop(3);                      case MiscOp.Ldlen:                          state.PeekArrayOfAnyType(0);                          return state.PopPushType(1' global.IntNativeRef' BottomPT);                      case MiscOp.Ret:                          {                              if (state.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return state; // empty                          }                      case MiscOp.RetVal:                          {                              state.PeekExpectedType(0' method.Result.Type' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfilter:                          {                              state.PeekExpectedType(0' global.Int32Ref' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfinally:                          {                              // Control could transfer to an outer finally/fault block' or to the target                              // of a leave instruction. However these transitions are delt with separately.                              return state.DiscardStack();                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:                  {                      var bri = (BranchInstruction)instruction;                      switch (bri.Op)                      {                      case BranchOp.Br:                          UnifyBeforeState(state' bri.Target' changed);                          return state;                      case BranchOp.Brtrue:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' false);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Brfalse:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Breq:                      case BranchOp.Brne:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' true);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Leave:                          {                              // Control could transfer via finally blocks instead of directly to the leave target.                              // Propogate only that the stack must be empty at target. Remaining machine state                              // is dealt with separately.                              UnifyBeforeState                                  (new MachineState(methEnv' method.ValueParameters.Count' method.Locals.Count)'                                   bri.Target'                                   changed);                              return state.DiscardStack();                          }                      case BranchOp.BrLt:                      case BranchOp.BrLe:                      case BranchOp.BrGt:                      case BranchOp.BrGe:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' false);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Switch:                  {                      var switchi = (SwitchInstruction)instruction;                      state.PeekExpectedType(0' global.Int32Ref' changed);                      var newState = state.Pop(1);                      for (var i = 0; i < switchi.CaseTargets.Count; i++)                          UnifyBeforeState(newState' switchi.CaseTargets[i]' changed);                      return newState;                  }              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      // WARNING: Capured type may not be final                      // NOTE: May capture skolemized types                      switch (cmpi.Op)                      {                      case CompareOp.Ceq:                      case CompareOp.CnePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' true);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.Clt:                      case CompareOp.Cgt:                      case CompareOp.CgePseudo:                      case CompareOp.ClePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' false);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.CtruePseudo:                      case CompareOp.CfalsePseudo:                          cmpi.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                          return state.PopPushType(1' global.Int32Ref' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var argi = (ArgLocalInstruction)instruction;                      var type = method.ArgLocalType(argi.ArgLocal' argi.Index);                      switch (argi.Op)                      {                      case ArgLocalOp.Ld:                          return state.PushType(type' state.ArgLocalPointsTo(argi.ArgLocal' argi.Index));                      case ArgLocalOp.Lda:                          return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(type)' ArgLocalPT(argi.ArgLocal' argi.Index));                      case ArgLocalOp.St:                          {                              state.PeekExpectedType(0' type' changed);                              var pointsTo = state.PeekPointsTo(0);                              if (!pointsTo.IsBottom)                              {                                  if (!(type.Style(methEnv) is ManagedPointerTypeStyle))                                      throw new InvalidOperationException                                          ("stack indicates pointer' but parameter or local type does not");                                  if (pointsTo.PointsOutsideOfHeap)                                      throw new InvalidOperationException("arguments cannot point outside of the heap");                              }                              return state.PopAddArgLocalPointsTo(1' argi.ArgLocal' argi.Index' pointsTo);                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      var fieldEnv = fieldi.Field.Enter(methEnv);                      var fieldType = fieldEnv.SubstituteType(fieldEnv.Field.FieldType);                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                              return state.PushType(fieldType' BottomPT);                          else                          {                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' true' changed);                              return state.PopPushType(1' fieldType' BottomPT);                          }                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                              return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          else                          {                              // Underlying type cannot be a struct' otherwise would have a pointer into                              // the stack                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' false' changed);                              return state.PopPushType                                  (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          }                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                          {                              state.PeekExpectedType(0' fieldType' changed);                              return state.Pop(1);                          }                          else                          {                              state.PeekExpectedType(0' fieldType' changed);                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (1' fieldi.Field.DefiningType' false' changed);                              return state.Pop(2);                          }                      case FieldOp.Ldtoken:                          return state.PushType(global.RuntimeFieldHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methi = (MethodInstruction)instruction;                      var sig = (CST.MethodSignature)methi.Method.ExternalSignature;                      switch (methi.Op)                      {                      case MethodOp.Call:                          {                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              if (methi.Constrained != null)                              {                                  if (!methi.IsVirtual || methi.Method.IsStatic)                                      throw new InvalidOperationException                                          ("constrained only valid on virtual calls to instance methods");                                  var thisType = sig.Parameters[0];                                  var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(methi.Constrained);                                  var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo(methi.Constrained);                                  var cs = methi.Constrained.Style(methEnv);                                  if (cs is ValueTypeStyle)                                  {                                      if (thisType.Style(methEnv) is ManagedPointerTypeStyle)                                      {                                          // We pass the argument pointer as is                                          if (!methi.Constrained.IsAssignableTo(methEnv' thisType.Arguments[0]))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                      else                                      {                                          // *Case 1* Morally we deref the argument pointer and box the contents'                                          // but since no supertype of a value type may mutate the underlying value'                                          // we don't need to take a copy of the value when boxing' so in practice                                          // this is a no-op                                          if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                  }                                  else if (cs is ReferenceTypeStyle)                                  {                                      // *Case 2* We dereference the pointer and pass the object reference                                      if (!methi.Constrained.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else if (cs is ParameterTypeStyle)                                  {                                      // Since we are calling an instance method' we know the first argument cannot be                                      // a "naked" type parameter' but is either a class or an interface.                                      // We must decide between cases 1 and 2 above at runtime' but checking as                                      // per case 1 is sufficient now.                                      // NOTE: As for box/classcast/isinst below' if the parameter is                                      // instantiated to a reference type then the type box type is considered                                      // equivalent to the underyling reference type.                                      if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else                                      throw new InvalidOperationException                                          ("constrained must be value' reference or parameter type");                                    state.PeekExpectedType(sig.Parameters.Count - 1' constrainedPtr' changed);                              }                              else if (sig.Parameters.Count > 0)                                  state.PeekExpectedType(sig.Parameters.Count - 1' sig.Parameters[0]' changed);                              if (sig.Result == null)                                  return state.Pop(sig.Parameters.Count);                              else                                  return state.PopPushType(sig.Parameters.Count' sig.Result' BottomPT);                          }                      case MethodOp.Ldftn:                          {                              // NOTE: Verified CLR allows only the two "blessed" sequences:                              //   dup; ldvirtftn; newobj <delegate ctor>                              //   ldftn; newobj <delegate ctor>                              // It is thus possible to check the delegate will capture an instance which                              // implements the loaded method. However' we don't check that here.                              if (methi.IsVirtual)                              {                                  if (methi.Method.IsStatic)                                      throw new InvalidOperationException("cannot ldvirtftn of a static method");                                  var objectType = default(TypeRef);                                  if (sig.Parameters[0].Style(methEnv) is ManagedPointerTypeStyle)                                      // Object should be a box                                      objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(sig.Parameters[0].Arguments[0]);                                  else                                      // Object should match parameter                                      objectType = sig.Parameters[0];                                  state.PeekExpectedType(0' objectType' changed);                                  return state.PopPushType(1' sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                              else                              {                                  if (methi.Method.IsStatic)                                      return state.PushType(sig.ToCodePointer(methEnv.Global)' BottomPT);                                  else                                      return state.PushType(sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                          }                      case MethodOp.Newobj:                          {                              if (methi.Method.IsStatic || sig.Result != null)                                  throw new InvalidOperationException("not a constructor");                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              // First argument to constructor is created by runtime. If definining type is                              // a value type' first argument will be a pointer' but result left on stack                              // will be the value itself.                              return state.PopPushType(sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);                          }                      case MethodOp.Ldtoken:                          return state.PushType(global.RuntimeMethodHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          state.PeekReadPointerType(0' typei.Type);                          return state.PopPushType(1' typei.Type' BottomPT);                      case TypeOp.Stobj:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Cpobj:                          state.PeekReadPointerType(0' typei.Type);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Newarr:                          state.PeekIndexType(0);                          return state.PopPushType(1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo(typei.Type)' BottomPT);                      case TypeOp.Initobj:                          state.PeekWritePointerType(0' typei.Type);                          return state.Pop(1);                      case TypeOp.Castclass:                      case TypeOp.Isinst:                      case TypeOp.Box:                          {                              var resultType = default(TypeRef);                              var s = typei.Type.Style(methEnv);                              if (s is NullableTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type.Arguments[0]);                              else if (s is ValueTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else if (s is ReferenceTypeStyle)                                  resultType = typei.Type;                              else if (s is ParameterTypeStyle)                                  // NOTE: As for constrained call above' if type parameter is instantitated to                                  // a ref type' then this box type is considered equivalent to the                                  // underlying reference type.                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else                                  throw new InvalidOperationException                                      ("can only box/cast to reference' value or parameter type");                              if (typei.Op == TypeOp.Box)                                  state.PeekExpectedType(0' typei.Type' changed);                              else                                  state.PeekReferenceType(0);                              return state.PopPushType(1' resultType' BottomPT);                          }                      case TypeOp.Unbox:                          if (!(typei.Type.Style(methEnv) is ValueTypeStyle))                              // Parameter types are not allowed                              throw new InvalidOperationException("type must be a value type");                          state.PeekBoxedType(0' typei.Type' changed);                          return state.PopPushType(1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(typei.Type)' HeapPT);                      case TypeOp.UnboxAny:                          {                              var s = typei.Type.Style(methEnv);                              if (s is ValueTypeStyle)                                  state.PeekBoxedType(0' typei.Type' changed);                              else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))                                  throw new InvalidOperationException("type must be value' reference or parameter type");                              return state.PopPushType(1' typei.Type' BottomPT);                          }                      case TypeOp.Ldtoken:                          return state.PushType(global.RuntimeTypeHandleRef' BottomPT);                      case TypeOp.Ldelem:                          state.PeekIndexType(0);                          state.PeekReadArrayType(1' typei.Type' false);                          return state.PopPushType(2' typei.Type' BottomPT);                      case TypeOp.Stelem:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekIndexType(1);                          state.PeekWriteArrayType(2' typei.Type);                          return state.Pop(3);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  {                      var ldelemai = (LdElemAddrInstruction)instruction;                      state.PeekIndexType(0);                      // WARNING: May prematurely fail for non-readonly loads                      state.PeekReadArrayType(1' ldelemai.Type' !ldelemai.IsReadonly);                      return state.PopPushType(2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(ldelemai.Type)' HeapPT);                  }              case InstructionFlavor.LdInt32:                  return state.PushType(global.Int32Ref' BottomPT);              case InstructionFlavor.LdInt64:                  return state.PushType(global.Int64Ref' BottomPT);              case InstructionFlavor.LdSingle:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdDouble:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdString:                  return state.PushType(global.StringRef' BottomPT);              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.Div:                      case ArithOp.Rem:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' true);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.Neg:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' true);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' false);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.BitNot:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.Shl:                      case ArithOp.Shr:                          state.PeekExpectedType(0' global.Int32Ref' changed);                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(1' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(2' arithi.Type' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned &&                                           convi.TargetNumberFlavor == NumberFlavor.Double);                      // NOTE: May capture skolemized types                      convi.SourceType = state.PeekNumberType(0' !mustBeInteger);                      return state.PopPushType(1' TypeRef.NumberFrom(methEnv.Global' convi.TargetNumberFlavor)' BottomPT);                  }              case InstructionFlavor.Try:                  {                      var tryi = (TryInstruction)instruction;                      // Isolation:                      //  - There is no way for the current stack shape to influence or be influenced by                      //    inference of the try' since the current stack shape must be empty.                      //  - There is no way for the try to influence the result stack shape' since it must be                      //    empty.                      //  - However pointers in arguments and locals may propogate into and out of try body                      //    via exceptional transitions. The latter are delt with separately.                      if (state.Depth != 0)                          throw new InvalidOperationException("stack should be empty");                      var newState = ForwardBlock                          (new TryBodyInstructionContext(context' index' tryi.Body)' state' changed);                      for (var j = 0; j < tryi.Handlers.Count; j++)                      {                          var h = tryi.Handlers[j];                          var handlerContext = new TryHandlerInstructionContext(context' index' h.Body' j);                          var initHandlerState = new MachineState                              (methEnv' method.ValueParameters.Count' method.Locals.Count);                          switch (h.Flavor)                          {                          case HandlerFlavor.Catch:                              {                                  var catchh = (CatchTryInstructionHandler)h;                                  ForwardBlock(handlerContext' initHandlerState.PushType(catchh.Type' BottomPT)' changed);                                  break;                              }                          case HandlerFlavor.Filter:                              throw new NotSupportedException("filter handler blocks");                          case HandlerFlavor.Fault:                          case HandlerFlavor.Finally:                              ForwardBlock(handlerContext' initHandlerState' changed);                              break;                          default:                              throw new ArgumentOutOfRangeException();                          }                      }                      return newState;                  }              case InstructionFlavor.IfThenElsePseudo:              case InstructionFlavor.ShortCircuitingPseudo:              case InstructionFlavor.StructuralSwitchPseudo:              case InstructionFlavor.LoopPseudo:              case InstructionFlavor.WhileDoPseudo:              case InstructionFlavor.DoWhilePseudo:              case InstructionFlavor.LoopControlPseudo:                  throw new InvalidOperationException("no machine state inference for psuedo-instructions");              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return state;                      case MiscOp.Dup:                          return state.Push(state.Peek(0));                      case MiscOp.Pop:                          return state.Pop(1);                      case MiscOp.Ldnull:                          return state.PushType(global.NullRef' BottomPT);                      case MiscOp.Ckfinite:                          state.PeekExpectedType(0' global.DoubleRef' changed);                          // Assume the instruction can "peek" at top of stack' thus no need for pop/push.                          return state;                      case MiscOp.Throw:                          state.PeekReferenceType(0);                          return state.DiscardStack();                      case MiscOp.Rethrow:                          return state.DiscardStack();                      case MiscOp.LdindRef:                          {                              var elemType = state.PeekPointerToReferenceType(0);                              return state.PopPushType(1' elemType' BottomPT);                          }                      case MiscOp.StindRef:                          {                              var expElemType = state.PeekPointerToReferenceType(1);                              state.PeekExpectedType(0' expElemType' changed);                              return state.Pop(2);                          }                      case MiscOp.LdelemRef:                          {                              state.PeekIndexType(0);                              // WARNING: Type may not be final                              var elemType = state.PeekArrayOfReferenceType(1);                              return state.PopPushType(2' elemType' BottomPT);                          }                      case MiscOp.StelemRef:                          state.PeekReferenceType(0);                          state.PeekIndexType(1);                          state.PeekArrayOfReferenceType(2);                          // Since the value type and array element type may be independently generalized'                          // it is pointless to check that the first is assignable to the second.                          // Instead this check is done at runtime.                          return state.Pop(3);                      case MiscOp.Ldlen:                          state.PeekArrayOfAnyType(0);                          return state.PopPushType(1' global.IntNativeRef' BottomPT);                      case MiscOp.Ret:                          {                              if (state.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return state; // empty                          }                      case MiscOp.RetVal:                          {                              state.PeekExpectedType(0' method.Result.Type' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfilter:                          {                              state.PeekExpectedType(0' global.Int32Ref' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfinally:                          {                              // Control could transfer to an outer finally/fault block' or to the target                              // of a leave instruction. However these transitions are delt with separately.                              return state.DiscardStack();                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:                  {                      var bri = (BranchInstruction)instruction;                      switch (bri.Op)                      {                      case BranchOp.Br:                          UnifyBeforeState(state' bri.Target' changed);                          return state;                      case BranchOp.Brtrue:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' false);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Brfalse:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Breq:                      case BranchOp.Brne:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' true);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Leave:                          {                              // Control could transfer via finally blocks instead of directly to the leave target.                              // Propogate only that the stack must be empty at target. Remaining machine state                              // is dealt with separately.                              UnifyBeforeState                                  (new MachineState(methEnv' method.ValueParameters.Count' method.Locals.Count)'                                   bri.Target'                                   changed);                              return state.DiscardStack();                          }                      case BranchOp.BrLt:                      case BranchOp.BrLe:                      case BranchOp.BrGt:                      case BranchOp.BrGe:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' false);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Switch:                  {                      var switchi = (SwitchInstruction)instruction;                      state.PeekExpectedType(0' global.Int32Ref' changed);                      var newState = state.Pop(1);                      for (var i = 0; i < switchi.CaseTargets.Count; i++)                          UnifyBeforeState(newState' switchi.CaseTargets[i]' changed);                      return newState;                  }              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      // WARNING: Capured type may not be final                      // NOTE: May capture skolemized types                      switch (cmpi.Op)                      {                      case CompareOp.Ceq:                      case CompareOp.CnePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' true);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.Clt:                      case CompareOp.Cgt:                      case CompareOp.CgePseudo:                      case CompareOp.ClePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' false);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.CtruePseudo:                      case CompareOp.CfalsePseudo:                          cmpi.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                          return state.PopPushType(1' global.Int32Ref' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var argi = (ArgLocalInstruction)instruction;                      var type = method.ArgLocalType(argi.ArgLocal' argi.Index);                      switch (argi.Op)                      {                      case ArgLocalOp.Ld:                          return state.PushType(type' state.ArgLocalPointsTo(argi.ArgLocal' argi.Index));                      case ArgLocalOp.Lda:                          return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(type)' ArgLocalPT(argi.ArgLocal' argi.Index));                      case ArgLocalOp.St:                          {                              state.PeekExpectedType(0' type' changed);                              var pointsTo = state.PeekPointsTo(0);                              if (!pointsTo.IsBottom)                              {                                  if (!(type.Style(methEnv) is ManagedPointerTypeStyle))                                      throw new InvalidOperationException                                          ("stack indicates pointer' but parameter or local type does not");                                  if (pointsTo.PointsOutsideOfHeap)                                      throw new InvalidOperationException("arguments cannot point outside of the heap");                              }                              return state.PopAddArgLocalPointsTo(1' argi.ArgLocal' argi.Index' pointsTo);                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      var fieldEnv = fieldi.Field.Enter(methEnv);                      var fieldType = fieldEnv.SubstituteType(fieldEnv.Field.FieldType);                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                              return state.PushType(fieldType' BottomPT);                          else                          {                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' true' changed);                              return state.PopPushType(1' fieldType' BottomPT);                          }                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                              return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          else                          {                              // Underlying type cannot be a struct' otherwise would have a pointer into                              // the stack                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' false' changed);                              return state.PopPushType                                  (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          }                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                          {                              state.PeekExpectedType(0' fieldType' changed);                              return state.Pop(1);                          }                          else                          {                              state.PeekExpectedType(0' fieldType' changed);                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (1' fieldi.Field.DefiningType' false' changed);                              return state.Pop(2);                          }                      case FieldOp.Ldtoken:                          return state.PushType(global.RuntimeFieldHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methi = (MethodInstruction)instruction;                      var sig = (CST.MethodSignature)methi.Method.ExternalSignature;                      switch (methi.Op)                      {                      case MethodOp.Call:                          {                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              if (methi.Constrained != null)                              {                                  if (!methi.IsVirtual || methi.Method.IsStatic)                                      throw new InvalidOperationException                                          ("constrained only valid on virtual calls to instance methods");                                  var thisType = sig.Parameters[0];                                  var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(methi.Constrained);                                  var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo(methi.Constrained);                                  var cs = methi.Constrained.Style(methEnv);                                  if (cs is ValueTypeStyle)                                  {                                      if (thisType.Style(methEnv) is ManagedPointerTypeStyle)                                      {                                          // We pass the argument pointer as is                                          if (!methi.Constrained.IsAssignableTo(methEnv' thisType.Arguments[0]))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                      else                                      {                                          // *Case 1* Morally we deref the argument pointer and box the contents'                                          // but since no supertype of a value type may mutate the underlying value'                                          // we don't need to take a copy of the value when boxing' so in practice                                          // this is a no-op                                          if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                  }                                  else if (cs is ReferenceTypeStyle)                                  {                                      // *Case 2* We dereference the pointer and pass the object reference                                      if (!methi.Constrained.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else if (cs is ParameterTypeStyle)                                  {                                      // Since we are calling an instance method' we know the first argument cannot be                                      // a "naked" type parameter' but is either a class or an interface.                                      // We must decide between cases 1 and 2 above at runtime' but checking as                                      // per case 1 is sufficient now.                                      // NOTE: As for box/classcast/isinst below' if the parameter is                                      // instantiated to a reference type then the type box type is considered                                      // equivalent to the underyling reference type.                                      if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else                                      throw new InvalidOperationException                                          ("constrained must be value' reference or parameter type");                                    state.PeekExpectedType(sig.Parameters.Count - 1' constrainedPtr' changed);                              }                              else if (sig.Parameters.Count > 0)                                  state.PeekExpectedType(sig.Parameters.Count - 1' sig.Parameters[0]' changed);                              if (sig.Result == null)                                  return state.Pop(sig.Parameters.Count);                              else                                  return state.PopPushType(sig.Parameters.Count' sig.Result' BottomPT);                          }                      case MethodOp.Ldftn:                          {                              // NOTE: Verified CLR allows only the two "blessed" sequences:                              //   dup; ldvirtftn; newobj <delegate ctor>                              //   ldftn; newobj <delegate ctor>                              // It is thus possible to check the delegate will capture an instance which                              // implements the loaded method. However' we don't check that here.                              if (methi.IsVirtual)                              {                                  if (methi.Method.IsStatic)                                      throw new InvalidOperationException("cannot ldvirtftn of a static method");                                  var objectType = default(TypeRef);                                  if (sig.Parameters[0].Style(methEnv) is ManagedPointerTypeStyle)                                      // Object should be a box                                      objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(sig.Parameters[0].Arguments[0]);                                  else                                      // Object should match parameter                                      objectType = sig.Parameters[0];                                  state.PeekExpectedType(0' objectType' changed);                                  return state.PopPushType(1' sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                              else                              {                                  if (methi.Method.IsStatic)                                      return state.PushType(sig.ToCodePointer(methEnv.Global)' BottomPT);                                  else                                      return state.PushType(sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                          }                      case MethodOp.Newobj:                          {                              if (methi.Method.IsStatic || sig.Result != null)                                  throw new InvalidOperationException("not a constructor");                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              // First argument to constructor is created by runtime. If definining type is                              // a value type' first argument will be a pointer' but result left on stack                              // will be the value itself.                              return state.PopPushType(sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);                          }                      case MethodOp.Ldtoken:                          return state.PushType(global.RuntimeMethodHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          state.PeekReadPointerType(0' typei.Type);                          return state.PopPushType(1' typei.Type' BottomPT);                      case TypeOp.Stobj:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Cpobj:                          state.PeekReadPointerType(0' typei.Type);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Newarr:                          state.PeekIndexType(0);                          return state.PopPushType(1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo(typei.Type)' BottomPT);                      case TypeOp.Initobj:                          state.PeekWritePointerType(0' typei.Type);                          return state.Pop(1);                      case TypeOp.Castclass:                      case TypeOp.Isinst:                      case TypeOp.Box:                          {                              var resultType = default(TypeRef);                              var s = typei.Type.Style(methEnv);                              if (s is NullableTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type.Arguments[0]);                              else if (s is ValueTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else if (s is ReferenceTypeStyle)                                  resultType = typei.Type;                              else if (s is ParameterTypeStyle)                                  // NOTE: As for constrained call above' if type parameter is instantitated to                                  // a ref type' then this box type is considered equivalent to the                                  // underlying reference type.                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else                                  throw new InvalidOperationException                                      ("can only box/cast to reference' value or parameter type");                              if (typei.Op == TypeOp.Box)                                  state.PeekExpectedType(0' typei.Type' changed);                              else                                  state.PeekReferenceType(0);                              return state.PopPushType(1' resultType' BottomPT);                          }                      case TypeOp.Unbox:                          if (!(typei.Type.Style(methEnv) is ValueTypeStyle))                              // Parameter types are not allowed                              throw new InvalidOperationException("type must be a value type");                          state.PeekBoxedType(0' typei.Type' changed);                          return state.PopPushType(1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(typei.Type)' HeapPT);                      case TypeOp.UnboxAny:                          {                              var s = typei.Type.Style(methEnv);                              if (s is ValueTypeStyle)                                  state.PeekBoxedType(0' typei.Type' changed);                              else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))                                  throw new InvalidOperationException("type must be value' reference or parameter type");                              return state.PopPushType(1' typei.Type' BottomPT);                          }                      case TypeOp.Ldtoken:                          return state.PushType(global.RuntimeTypeHandleRef' BottomPT);                      case TypeOp.Ldelem:                          state.PeekIndexType(0);                          state.PeekReadArrayType(1' typei.Type' false);                          return state.PopPushType(2' typei.Type' BottomPT);                      case TypeOp.Stelem:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekIndexType(1);                          state.PeekWriteArrayType(2' typei.Type);                          return state.Pop(3);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  {                      var ldelemai = (LdElemAddrInstruction)instruction;                      state.PeekIndexType(0);                      // WARNING: May prematurely fail for non-readonly loads                      state.PeekReadArrayType(1' ldelemai.Type' !ldelemai.IsReadonly);                      return state.PopPushType(2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(ldelemai.Type)' HeapPT);                  }              case InstructionFlavor.LdInt32:                  return state.PushType(global.Int32Ref' BottomPT);              case InstructionFlavor.LdInt64:                  return state.PushType(global.Int64Ref' BottomPT);              case InstructionFlavor.LdSingle:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdDouble:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdString:                  return state.PushType(global.StringRef' BottomPT);              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.Div:                      case ArithOp.Rem:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' true);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.Neg:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' true);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' false);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.BitNot:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.Shl:                      case ArithOp.Shr:                          state.PeekExpectedType(0' global.Int32Ref' changed);                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(1' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(2' arithi.Type' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned &&                                           convi.TargetNumberFlavor == NumberFlavor.Double);                      // NOTE: May capture skolemized types                      convi.SourceType = state.PeekNumberType(0' !mustBeInteger);                      return state.PopPushType(1' TypeRef.NumberFrom(methEnv.Global' convi.TargetNumberFlavor)' BottomPT);                  }              case InstructionFlavor.Try:                  {                      var tryi = (TryInstruction)instruction;                      // Isolation:                      //  - There is no way for the current stack shape to influence or be influenced by                      //    inference of the try' since the current stack shape must be empty.                      //  - There is no way for the try to influence the result stack shape' since it must be                      //    empty.                      //  - However pointers in arguments and locals may propogate into and out of try body                      //    via exceptional transitions. The latter are delt with separately.                      if (state.Depth != 0)                          throw new InvalidOperationException("stack should be empty");                      var newState = ForwardBlock                          (new TryBodyInstructionContext(context' index' tryi.Body)' state' changed);                      for (var j = 0; j < tryi.Handlers.Count; j++)                      {                          var h = tryi.Handlers[j];                          var handlerContext = new TryHandlerInstructionContext(context' index' h.Body' j);                          var initHandlerState = new MachineState                              (methEnv' method.ValueParameters.Count' method.Locals.Count);                          switch (h.Flavor)                          {                          case HandlerFlavor.Catch:                              {                                  var catchh = (CatchTryInstructionHandler)h;                                  ForwardBlock(handlerContext' initHandlerState.PushType(catchh.Type' BottomPT)' changed);                                  break;                              }                          case HandlerFlavor.Filter:                              throw new NotSupportedException("filter handler blocks");                          case HandlerFlavor.Fault:                          case HandlerFlavor.Finally:                              ForwardBlock(handlerContext' initHandlerState' changed);                              break;                          default:                              throw new ArgumentOutOfRangeException();                          }                      }                      return newState;                  }              case InstructionFlavor.IfThenElsePseudo:              case InstructionFlavor.ShortCircuitingPseudo:              case InstructionFlavor.StructuralSwitchPseudo:              case InstructionFlavor.LoopPseudo:              case InstructionFlavor.WhileDoPseudo:              case InstructionFlavor.DoWhilePseudo:              case InstructionFlavor.LoopControlPseudo:                  throw new InvalidOperationException("no machine state inference for psuedo-instructions");              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return state;                      case MiscOp.Dup:                          return state.Push(state.Peek(0));                      case MiscOp.Pop:                          return state.Pop(1);                      case MiscOp.Ldnull:                          return state.PushType(global.NullRef' BottomPT);                      case MiscOp.Ckfinite:                          state.PeekExpectedType(0' global.DoubleRef' changed);                          // Assume the instruction can "peek" at top of stack' thus no need for pop/push.                          return state;                      case MiscOp.Throw:                          state.PeekReferenceType(0);                          return state.DiscardStack();                      case MiscOp.Rethrow:                          return state.DiscardStack();                      case MiscOp.LdindRef:                          {                              var elemType = state.PeekPointerToReferenceType(0);                              return state.PopPushType(1' elemType' BottomPT);                          }                      case MiscOp.StindRef:                          {                              var expElemType = state.PeekPointerToReferenceType(1);                              state.PeekExpectedType(0' expElemType' changed);                              return state.Pop(2);                          }                      case MiscOp.LdelemRef:                          {                              state.PeekIndexType(0);                              // WARNING: Type may not be final                              var elemType = state.PeekArrayOfReferenceType(1);                              return state.PopPushType(2' elemType' BottomPT);                          }                      case MiscOp.StelemRef:                          state.PeekReferenceType(0);                          state.PeekIndexType(1);                          state.PeekArrayOfReferenceType(2);                          // Since the value type and array element type may be independently generalized'                          // it is pointless to check that the first is assignable to the second.                          // Instead this check is done at runtime.                          return state.Pop(3);                      case MiscOp.Ldlen:                          state.PeekArrayOfAnyType(0);                          return state.PopPushType(1' global.IntNativeRef' BottomPT);                      case MiscOp.Ret:                          {                              if (state.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return state; // empty                          }                      case MiscOp.RetVal:                          {                              state.PeekExpectedType(0' method.Result.Type' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfilter:                          {                              state.PeekExpectedType(0' global.Int32Ref' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfinally:                          {                              // Control could transfer to an outer finally/fault block' or to the target                              // of a leave instruction. However these transitions are delt with separately.                              return state.DiscardStack();                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:                  {                      var bri = (BranchInstruction)instruction;                      switch (bri.Op)                      {                      case BranchOp.Br:                          UnifyBeforeState(state' bri.Target' changed);                          return state;                      case BranchOp.Brtrue:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' false);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Brfalse:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Breq:                      case BranchOp.Brne:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' true);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Leave:                          {                              // Control could transfer via finally blocks instead of directly to the leave target.                              // Propogate only that the stack must be empty at target. Remaining machine state                              // is dealt with separately.                              UnifyBeforeState                                  (new MachineState(methEnv' method.ValueParameters.Count' method.Locals.Count)'                                   bri.Target'                                   changed);                              return state.DiscardStack();                          }                      case BranchOp.BrLt:                      case BranchOp.BrLe:                      case BranchOp.BrGt:                      case BranchOp.BrGe:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' false);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Switch:                  {                      var switchi = (SwitchInstruction)instruction;                      state.PeekExpectedType(0' global.Int32Ref' changed);                      var newState = state.Pop(1);                      for (var i = 0; i < switchi.CaseTargets.Count; i++)                          UnifyBeforeState(newState' switchi.CaseTargets[i]' changed);                      return newState;                  }              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      // WARNING: Capured type may not be final                      // NOTE: May capture skolemized types                      switch (cmpi.Op)                      {                      case CompareOp.Ceq:                      case CompareOp.CnePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' true);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.Clt:                      case CompareOp.Cgt:                      case CompareOp.CgePseudo:                      case CompareOp.ClePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' false);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.CtruePseudo:                      case CompareOp.CfalsePseudo:                          cmpi.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                          return state.PopPushType(1' global.Int32Ref' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var argi = (ArgLocalInstruction)instruction;                      var type = method.ArgLocalType(argi.ArgLocal' argi.Index);                      switch (argi.Op)                      {                      case ArgLocalOp.Ld:                          return state.PushType(type' state.ArgLocalPointsTo(argi.ArgLocal' argi.Index));                      case ArgLocalOp.Lda:                          return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(type)' ArgLocalPT(argi.ArgLocal' argi.Index));                      case ArgLocalOp.St:                          {                              state.PeekExpectedType(0' type' changed);                              var pointsTo = state.PeekPointsTo(0);                              if (!pointsTo.IsBottom)                              {                                  if (!(type.Style(methEnv) is ManagedPointerTypeStyle))                                      throw new InvalidOperationException                                          ("stack indicates pointer' but parameter or local type does not");                                  if (pointsTo.PointsOutsideOfHeap)                                      throw new InvalidOperationException("arguments cannot point outside of the heap");                              }                              return state.PopAddArgLocalPointsTo(1' argi.ArgLocal' argi.Index' pointsTo);                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      var fieldEnv = fieldi.Field.Enter(methEnv);                      var fieldType = fieldEnv.SubstituteType(fieldEnv.Field.FieldType);                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                              return state.PushType(fieldType' BottomPT);                          else                          {                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' true' changed);                              return state.PopPushType(1' fieldType' BottomPT);                          }                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                              return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          else                          {                              // Underlying type cannot be a struct' otherwise would have a pointer into                              // the stack                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' false' changed);                              return state.PopPushType                                  (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          }                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                          {                              state.PeekExpectedType(0' fieldType' changed);                              return state.Pop(1);                          }                          else                          {                              state.PeekExpectedType(0' fieldType' changed);                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (1' fieldi.Field.DefiningType' false' changed);                              return state.Pop(2);                          }                      case FieldOp.Ldtoken:                          return state.PushType(global.RuntimeFieldHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methi = (MethodInstruction)instruction;                      var sig = (CST.MethodSignature)methi.Method.ExternalSignature;                      switch (methi.Op)                      {                      case MethodOp.Call:                          {                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              if (methi.Constrained != null)                              {                                  if (!methi.IsVirtual || methi.Method.IsStatic)                                      throw new InvalidOperationException                                          ("constrained only valid on virtual calls to instance methods");                                  var thisType = sig.Parameters[0];                                  var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(methi.Constrained);                                  var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo(methi.Constrained);                                  var cs = methi.Constrained.Style(methEnv);                                  if (cs is ValueTypeStyle)                                  {                                      if (thisType.Style(methEnv) is ManagedPointerTypeStyle)                                      {                                          // We pass the argument pointer as is                                          if (!methi.Constrained.IsAssignableTo(methEnv' thisType.Arguments[0]))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                      else                                      {                                          // *Case 1* Morally we deref the argument pointer and box the contents'                                          // but since no supertype of a value type may mutate the underlying value'                                          // we don't need to take a copy of the value when boxing' so in practice                                          // this is a no-op                                          if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                  }                                  else if (cs is ReferenceTypeStyle)                                  {                                      // *Case 2* We dereference the pointer and pass the object reference                                      if (!methi.Constrained.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else if (cs is ParameterTypeStyle)                                  {                                      // Since we are calling an instance method' we know the first argument cannot be                                      // a "naked" type parameter' but is either a class or an interface.                                      // We must decide between cases 1 and 2 above at runtime' but checking as                                      // per case 1 is sufficient now.                                      // NOTE: As for box/classcast/isinst below' if the parameter is                                      // instantiated to a reference type then the type box type is considered                                      // equivalent to the underyling reference type.                                      if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else                                      throw new InvalidOperationException                                          ("constrained must be value' reference or parameter type");                                    state.PeekExpectedType(sig.Parameters.Count - 1' constrainedPtr' changed);                              }                              else if (sig.Parameters.Count > 0)                                  state.PeekExpectedType(sig.Parameters.Count - 1' sig.Parameters[0]' changed);                              if (sig.Result == null)                                  return state.Pop(sig.Parameters.Count);                              else                                  return state.PopPushType(sig.Parameters.Count' sig.Result' BottomPT);                          }                      case MethodOp.Ldftn:                          {                              // NOTE: Verified CLR allows only the two "blessed" sequences:                              //   dup; ldvirtftn; newobj <delegate ctor>                              //   ldftn; newobj <delegate ctor>                              // It is thus possible to check the delegate will capture an instance which                              // implements the loaded method. However' we don't check that here.                              if (methi.IsVirtual)                              {                                  if (methi.Method.IsStatic)                                      throw new InvalidOperationException("cannot ldvirtftn of a static method");                                  var objectType = default(TypeRef);                                  if (sig.Parameters[0].Style(methEnv) is ManagedPointerTypeStyle)                                      // Object should be a box                                      objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(sig.Parameters[0].Arguments[0]);                                  else                                      // Object should match parameter                                      objectType = sig.Parameters[0];                                  state.PeekExpectedType(0' objectType' changed);                                  return state.PopPushType(1' sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                              else                              {                                  if (methi.Method.IsStatic)                                      return state.PushType(sig.ToCodePointer(methEnv.Global)' BottomPT);                                  else                                      return state.PushType(sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                          }                      case MethodOp.Newobj:                          {                              if (methi.Method.IsStatic || sig.Result != null)                                  throw new InvalidOperationException("not a constructor");                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              // First argument to constructor is created by runtime. If definining type is                              // a value type' first argument will be a pointer' but result left on stack                              // will be the value itself.                              return state.PopPushType(sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);                          }                      case MethodOp.Ldtoken:                          return state.PushType(global.RuntimeMethodHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          state.PeekReadPointerType(0' typei.Type);                          return state.PopPushType(1' typei.Type' BottomPT);                      case TypeOp.Stobj:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Cpobj:                          state.PeekReadPointerType(0' typei.Type);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Newarr:                          state.PeekIndexType(0);                          return state.PopPushType(1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo(typei.Type)' BottomPT);                      case TypeOp.Initobj:                          state.PeekWritePointerType(0' typei.Type);                          return state.Pop(1);                      case TypeOp.Castclass:                      case TypeOp.Isinst:                      case TypeOp.Box:                          {                              var resultType = default(TypeRef);                              var s = typei.Type.Style(methEnv);                              if (s is NullableTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type.Arguments[0]);                              else if (s is ValueTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else if (s is ReferenceTypeStyle)                                  resultType = typei.Type;                              else if (s is ParameterTypeStyle)                                  // NOTE: As for constrained call above' if type parameter is instantitated to                                  // a ref type' then this box type is considered equivalent to the                                  // underlying reference type.                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else                                  throw new InvalidOperationException                                      ("can only box/cast to reference' value or parameter type");                              if (typei.Op == TypeOp.Box)                                  state.PeekExpectedType(0' typei.Type' changed);                              else                                  state.PeekReferenceType(0);                              return state.PopPushType(1' resultType' BottomPT);                          }                      case TypeOp.Unbox:                          if (!(typei.Type.Style(methEnv) is ValueTypeStyle))                              // Parameter types are not allowed                              throw new InvalidOperationException("type must be a value type");                          state.PeekBoxedType(0' typei.Type' changed);                          return state.PopPushType(1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(typei.Type)' HeapPT);                      case TypeOp.UnboxAny:                          {                              var s = typei.Type.Style(methEnv);                              if (s is ValueTypeStyle)                                  state.PeekBoxedType(0' typei.Type' changed);                              else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))                                  throw new InvalidOperationException("type must be value' reference or parameter type");                              return state.PopPushType(1' typei.Type' BottomPT);                          }                      case TypeOp.Ldtoken:                          return state.PushType(global.RuntimeTypeHandleRef' BottomPT);                      case TypeOp.Ldelem:                          state.PeekIndexType(0);                          state.PeekReadArrayType(1' typei.Type' false);                          return state.PopPushType(2' typei.Type' BottomPT);                      case TypeOp.Stelem:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekIndexType(1);                          state.PeekWriteArrayType(2' typei.Type);                          return state.Pop(3);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  {                      var ldelemai = (LdElemAddrInstruction)instruction;                      state.PeekIndexType(0);                      // WARNING: May prematurely fail for non-readonly loads                      state.PeekReadArrayType(1' ldelemai.Type' !ldelemai.IsReadonly);                      return state.PopPushType(2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(ldelemai.Type)' HeapPT);                  }              case InstructionFlavor.LdInt32:                  return state.PushType(global.Int32Ref' BottomPT);              case InstructionFlavor.LdInt64:                  return state.PushType(global.Int64Ref' BottomPT);              case InstructionFlavor.LdSingle:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdDouble:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdString:                  return state.PushType(global.StringRef' BottomPT);              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.Div:                      case ArithOp.Rem:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' true);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.Neg:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' true);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' false);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.BitNot:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.Shl:                      case ArithOp.Shr:                          state.PeekExpectedType(0' global.Int32Ref' changed);                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(1' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(2' arithi.Type' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned &&                                           convi.TargetNumberFlavor == NumberFlavor.Double);                      // NOTE: May capture skolemized types                      convi.SourceType = state.PeekNumberType(0' !mustBeInteger);                      return state.PopPushType(1' TypeRef.NumberFrom(methEnv.Global' convi.TargetNumberFlavor)' BottomPT);                  }              case InstructionFlavor.Try:                  {                      var tryi = (TryInstruction)instruction;                      // Isolation:                      //  - There is no way for the current stack shape to influence or be influenced by                      //    inference of the try' since the current stack shape must be empty.                      //  - There is no way for the try to influence the result stack shape' since it must be                      //    empty.                      //  - However pointers in arguments and locals may propogate into and out of try body                      //    via exceptional transitions. The latter are delt with separately.                      if (state.Depth != 0)                          throw new InvalidOperationException("stack should be empty");                      var newState = ForwardBlock                          (new TryBodyInstructionContext(context' index' tryi.Body)' state' changed);                      for (var j = 0; j < tryi.Handlers.Count; j++)                      {                          var h = tryi.Handlers[j];                          var handlerContext = new TryHandlerInstructionContext(context' index' h.Body' j);                          var initHandlerState = new MachineState                              (methEnv' method.ValueParameters.Count' method.Locals.Count);                          switch (h.Flavor)                          {                          case HandlerFlavor.Catch:                              {                                  var catchh = (CatchTryInstructionHandler)h;                                  ForwardBlock(handlerContext' initHandlerState.PushType(catchh.Type' BottomPT)' changed);                                  break;                              }                          case HandlerFlavor.Filter:                              throw new NotSupportedException("filter handler blocks");                          case HandlerFlavor.Fault:                          case HandlerFlavor.Finally:                              ForwardBlock(handlerContext' initHandlerState' changed);                              break;                          default:                              throw new ArgumentOutOfRangeException();                          }                      }                      return newState;                  }              case InstructionFlavor.IfThenElsePseudo:              case InstructionFlavor.ShortCircuitingPseudo:              case InstructionFlavor.StructuralSwitchPseudo:              case InstructionFlavor.LoopPseudo:              case InstructionFlavor.WhileDoPseudo:              case InstructionFlavor.DoWhilePseudo:              case InstructionFlavor.LoopControlPseudo:                  throw new InvalidOperationException("no machine state inference for psuedo-instructions");              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return state;                      case MiscOp.Dup:                          return state.Push(state.Peek(0));                      case MiscOp.Pop:                          return state.Pop(1);                      case MiscOp.Ldnull:                          return state.PushType(global.NullRef' BottomPT);                      case MiscOp.Ckfinite:                          state.PeekExpectedType(0' global.DoubleRef' changed);                          // Assume the instruction can "peek" at top of stack' thus no need for pop/push.                          return state;                      case MiscOp.Throw:                          state.PeekReferenceType(0);                          return state.DiscardStack();                      case MiscOp.Rethrow:                          return state.DiscardStack();                      case MiscOp.LdindRef:                          {                              var elemType = state.PeekPointerToReferenceType(0);                              return state.PopPushType(1' elemType' BottomPT);                          }                      case MiscOp.StindRef:                          {                              var expElemType = state.PeekPointerToReferenceType(1);                              state.PeekExpectedType(0' expElemType' changed);                              return state.Pop(2);                          }                      case MiscOp.LdelemRef:                          {                              state.PeekIndexType(0);                              // WARNING: Type may not be final                              var elemType = state.PeekArrayOfReferenceType(1);                              return state.PopPushType(2' elemType' BottomPT);                          }                      case MiscOp.StelemRef:                          state.PeekReferenceType(0);                          state.PeekIndexType(1);                          state.PeekArrayOfReferenceType(2);                          // Since the value type and array element type may be independently generalized'                          // it is pointless to check that the first is assignable to the second.                          // Instead this check is done at runtime.                          return state.Pop(3);                      case MiscOp.Ldlen:                          state.PeekArrayOfAnyType(0);                          return state.PopPushType(1' global.IntNativeRef' BottomPT);                      case MiscOp.Ret:                          {                              if (state.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return state; // empty                          }                      case MiscOp.RetVal:                          {                              state.PeekExpectedType(0' method.Result.Type' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfilter:                          {                              state.PeekExpectedType(0' global.Int32Ref' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfinally:                          {                              // Control could transfer to an outer finally/fault block' or to the target                              // of a leave instruction. However these transitions are delt with separately.                              return state.DiscardStack();                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:                  {                      var bri = (BranchInstruction)instruction;                      switch (bri.Op)                      {                      case BranchOp.Br:                          UnifyBeforeState(state' bri.Target' changed);                          return state;                      case BranchOp.Brtrue:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' false);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Brfalse:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Breq:                      case BranchOp.Brne:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' true);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Leave:                          {                              // Control could transfer via finally blocks instead of directly to the leave target.                              // Propogate only that the stack must be empty at target. Remaining machine state                              // is dealt with separately.                              UnifyBeforeState                                  (new MachineState(methEnv' method.ValueParameters.Count' method.Locals.Count)'                                   bri.Target'                                   changed);                              return state.DiscardStack();                          }                      case BranchOp.BrLt:                      case BranchOp.BrLe:                      case BranchOp.BrGt:                      case BranchOp.BrGe:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' false);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Switch:                  {                      var switchi = (SwitchInstruction)instruction;                      state.PeekExpectedType(0' global.Int32Ref' changed);                      var newState = state.Pop(1);                      for (var i = 0; i < switchi.CaseTargets.Count; i++)                          UnifyBeforeState(newState' switchi.CaseTargets[i]' changed);                      return newState;                  }              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      // WARNING: Capured type may not be final                      // NOTE: May capture skolemized types                      switch (cmpi.Op)                      {                      case CompareOp.Ceq:                      case CompareOp.CnePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' true);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.Clt:                      case CompareOp.Cgt:                      case CompareOp.CgePseudo:                      case CompareOp.ClePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' false);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.CtruePseudo:                      case CompareOp.CfalsePseudo:                          cmpi.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                          return state.PopPushType(1' global.Int32Ref' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var argi = (ArgLocalInstruction)instruction;                      var type = method.ArgLocalType(argi.ArgLocal' argi.Index);                      switch (argi.Op)                      {                      case ArgLocalOp.Ld:                          return state.PushType(type' state.ArgLocalPointsTo(argi.ArgLocal' argi.Index));                      case ArgLocalOp.Lda:                          return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(type)' ArgLocalPT(argi.ArgLocal' argi.Index));                      case ArgLocalOp.St:                          {                              state.PeekExpectedType(0' type' changed);                              var pointsTo = state.PeekPointsTo(0);                              if (!pointsTo.IsBottom)                              {                                  if (!(type.Style(methEnv) is ManagedPointerTypeStyle))                                      throw new InvalidOperationException                                          ("stack indicates pointer' but parameter or local type does not");                                  if (pointsTo.PointsOutsideOfHeap)                                      throw new InvalidOperationException("arguments cannot point outside of the heap");                              }                              return state.PopAddArgLocalPointsTo(1' argi.ArgLocal' argi.Index' pointsTo);                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      var fieldEnv = fieldi.Field.Enter(methEnv);                      var fieldType = fieldEnv.SubstituteType(fieldEnv.Field.FieldType);                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                              return state.PushType(fieldType' BottomPT);                          else                          {                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' true' changed);                              return state.PopPushType(1' fieldType' BottomPT);                          }                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                              return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          else                          {                              // Underlying type cannot be a struct' otherwise would have a pointer into                              // the stack                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' false' changed);                              return state.PopPushType                                  (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          }                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                          {                              state.PeekExpectedType(0' fieldType' changed);                              return state.Pop(1);                          }                          else                          {                              state.PeekExpectedType(0' fieldType' changed);                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (1' fieldi.Field.DefiningType' false' changed);                              return state.Pop(2);                          }                      case FieldOp.Ldtoken:                          return state.PushType(global.RuntimeFieldHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methi = (MethodInstruction)instruction;                      var sig = (CST.MethodSignature)methi.Method.ExternalSignature;                      switch (methi.Op)                      {                      case MethodOp.Call:                          {                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              if (methi.Constrained != null)                              {                                  if (!methi.IsVirtual || methi.Method.IsStatic)                                      throw new InvalidOperationException                                          ("constrained only valid on virtual calls to instance methods");                                  var thisType = sig.Parameters[0];                                  var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(methi.Constrained);                                  var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo(methi.Constrained);                                  var cs = methi.Constrained.Style(methEnv);                                  if (cs is ValueTypeStyle)                                  {                                      if (thisType.Style(methEnv) is ManagedPointerTypeStyle)                                      {                                          // We pass the argument pointer as is                                          if (!methi.Constrained.IsAssignableTo(methEnv' thisType.Arguments[0]))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                      else                                      {                                          // *Case 1* Morally we deref the argument pointer and box the contents'                                          // but since no supertype of a value type may mutate the underlying value'                                          // we don't need to take a copy of the value when boxing' so in practice                                          // this is a no-op                                          if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                  }                                  else if (cs is ReferenceTypeStyle)                                  {                                      // *Case 2* We dereference the pointer and pass the object reference                                      if (!methi.Constrained.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else if (cs is ParameterTypeStyle)                                  {                                      // Since we are calling an instance method' we know the first argument cannot be                                      // a "naked" type parameter' but is either a class or an interface.                                      // We must decide between cases 1 and 2 above at runtime' but checking as                                      // per case 1 is sufficient now.                                      // NOTE: As for box/classcast/isinst below' if the parameter is                                      // instantiated to a reference type then the type box type is considered                                      // equivalent to the underyling reference type.                                      if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else                                      throw new InvalidOperationException                                          ("constrained must be value' reference or parameter type");                                    state.PeekExpectedType(sig.Parameters.Count - 1' constrainedPtr' changed);                              }                              else if (sig.Parameters.Count > 0)                                  state.PeekExpectedType(sig.Parameters.Count - 1' sig.Parameters[0]' changed);                              if (sig.Result == null)                                  return state.Pop(sig.Parameters.Count);                              else                                  return state.PopPushType(sig.Parameters.Count' sig.Result' BottomPT);                          }                      case MethodOp.Ldftn:                          {                              // NOTE: Verified CLR allows only the two "blessed" sequences:                              //   dup; ldvirtftn; newobj <delegate ctor>                              //   ldftn; newobj <delegate ctor>                              // It is thus possible to check the delegate will capture an instance which                              // implements the loaded method. However' we don't check that here.                              if (methi.IsVirtual)                              {                                  if (methi.Method.IsStatic)                                      throw new InvalidOperationException("cannot ldvirtftn of a static method");                                  var objectType = default(TypeRef);                                  if (sig.Parameters[0].Style(methEnv) is ManagedPointerTypeStyle)                                      // Object should be a box                                      objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(sig.Parameters[0].Arguments[0]);                                  else                                      // Object should match parameter                                      objectType = sig.Parameters[0];                                  state.PeekExpectedType(0' objectType' changed);                                  return state.PopPushType(1' sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                              else                              {                                  if (methi.Method.IsStatic)                                      return state.PushType(sig.ToCodePointer(methEnv.Global)' BottomPT);                                  else                                      return state.PushType(sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                          }                      case MethodOp.Newobj:                          {                              if (methi.Method.IsStatic || sig.Result != null)                                  throw new InvalidOperationException("not a constructor");                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              // First argument to constructor is created by runtime. If definining type is                              // a value type' first argument will be a pointer' but result left on stack                              // will be the value itself.                              return state.PopPushType(sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);                          }                      case MethodOp.Ldtoken:                          return state.PushType(global.RuntimeMethodHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          state.PeekReadPointerType(0' typei.Type);                          return state.PopPushType(1' typei.Type' BottomPT);                      case TypeOp.Stobj:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Cpobj:                          state.PeekReadPointerType(0' typei.Type);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Newarr:                          state.PeekIndexType(0);                          return state.PopPushType(1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo(typei.Type)' BottomPT);                      case TypeOp.Initobj:                          state.PeekWritePointerType(0' typei.Type);                          return state.Pop(1);                      case TypeOp.Castclass:                      case TypeOp.Isinst:                      case TypeOp.Box:                          {                              var resultType = default(TypeRef);                              var s = typei.Type.Style(methEnv);                              if (s is NullableTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type.Arguments[0]);                              else if (s is ValueTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else if (s is ReferenceTypeStyle)                                  resultType = typei.Type;                              else if (s is ParameterTypeStyle)                                  // NOTE: As for constrained call above' if type parameter is instantitated to                                  // a ref type' then this box type is considered equivalent to the                                  // underlying reference type.                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else                                  throw new InvalidOperationException                                      ("can only box/cast to reference' value or parameter type");                              if (typei.Op == TypeOp.Box)                                  state.PeekExpectedType(0' typei.Type' changed);                              else                                  state.PeekReferenceType(0);                              return state.PopPushType(1' resultType' BottomPT);                          }                      case TypeOp.Unbox:                          if (!(typei.Type.Style(methEnv) is ValueTypeStyle))                              // Parameter types are not allowed                              throw new InvalidOperationException("type must be a value type");                          state.PeekBoxedType(0' typei.Type' changed);                          return state.PopPushType(1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(typei.Type)' HeapPT);                      case TypeOp.UnboxAny:                          {                              var s = typei.Type.Style(methEnv);                              if (s is ValueTypeStyle)                                  state.PeekBoxedType(0' typei.Type' changed);                              else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))                                  throw new InvalidOperationException("type must be value' reference or parameter type");                              return state.PopPushType(1' typei.Type' BottomPT);                          }                      case TypeOp.Ldtoken:                          return state.PushType(global.RuntimeTypeHandleRef' BottomPT);                      case TypeOp.Ldelem:                          state.PeekIndexType(0);                          state.PeekReadArrayType(1' typei.Type' false);                          return state.PopPushType(2' typei.Type' BottomPT);                      case TypeOp.Stelem:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekIndexType(1);                          state.PeekWriteArrayType(2' typei.Type);                          return state.Pop(3);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  {                      var ldelemai = (LdElemAddrInstruction)instruction;                      state.PeekIndexType(0);                      // WARNING: May prematurely fail for non-readonly loads                      state.PeekReadArrayType(1' ldelemai.Type' !ldelemai.IsReadonly);                      return state.PopPushType(2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(ldelemai.Type)' HeapPT);                  }              case InstructionFlavor.LdInt32:                  return state.PushType(global.Int32Ref' BottomPT);              case InstructionFlavor.LdInt64:                  return state.PushType(global.Int64Ref' BottomPT);              case InstructionFlavor.LdSingle:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdDouble:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdString:                  return state.PushType(global.StringRef' BottomPT);              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.Div:                      case ArithOp.Rem:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' true);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.Neg:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' true);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' false);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.BitNot:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.Shl:                      case ArithOp.Shr:                          state.PeekExpectedType(0' global.Int32Ref' changed);                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(1' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(2' arithi.Type' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned &&                                           convi.TargetNumberFlavor == NumberFlavor.Double);                      // NOTE: May capture skolemized types                      convi.SourceType = state.PeekNumberType(0' !mustBeInteger);                      return state.PopPushType(1' TypeRef.NumberFrom(methEnv.Global' convi.TargetNumberFlavor)' BottomPT);                  }              case InstructionFlavor.Try:                  {                      var tryi = (TryInstruction)instruction;                      // Isolation:                      //  - There is no way for the current stack shape to influence or be influenced by                      //    inference of the try' since the current stack shape must be empty.                      //  - There is no way for the try to influence the result stack shape' since it must be                      //    empty.                      //  - However pointers in arguments and locals may propogate into and out of try body                      //    via exceptional transitions. The latter are delt with separately.                      if (state.Depth != 0)                          throw new InvalidOperationException("stack should be empty");                      var newState = ForwardBlock                          (new TryBodyInstructionContext(context' index' tryi.Body)' state' changed);                      for (var j = 0; j < tryi.Handlers.Count; j++)                      {                          var h = tryi.Handlers[j];                          var handlerContext = new TryHandlerInstructionContext(context' index' h.Body' j);                          var initHandlerState = new MachineState                              (methEnv' method.ValueParameters.Count' method.Locals.Count);                          switch (h.Flavor)                          {                          case HandlerFlavor.Catch:                              {                                  var catchh = (CatchTryInstructionHandler)h;                                  ForwardBlock(handlerContext' initHandlerState.PushType(catchh.Type' BottomPT)' changed);                                  break;                              }                          case HandlerFlavor.Filter:                              throw new NotSupportedException("filter handler blocks");                          case HandlerFlavor.Fault:                          case HandlerFlavor.Finally:                              ForwardBlock(handlerContext' initHandlerState' changed);                              break;                          default:                              throw new ArgumentOutOfRangeException();                          }                      }                      return newState;                  }              case InstructionFlavor.IfThenElsePseudo:              case InstructionFlavor.ShortCircuitingPseudo:              case InstructionFlavor.StructuralSwitchPseudo:              case InstructionFlavor.LoopPseudo:              case InstructionFlavor.WhileDoPseudo:              case InstructionFlavor.DoWhilePseudo:              case InstructionFlavor.LoopControlPseudo:                  throw new InvalidOperationException("no machine state inference for psuedo-instructions");              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return state;                      case MiscOp.Dup:                          return state.Push(state.Peek(0));                      case MiscOp.Pop:                          return state.Pop(1);                      case MiscOp.Ldnull:                          return state.PushType(global.NullRef' BottomPT);                      case MiscOp.Ckfinite:                          state.PeekExpectedType(0' global.DoubleRef' changed);                          // Assume the instruction can "peek" at top of stack' thus no need for pop/push.                          return state;                      case MiscOp.Throw:                          state.PeekReferenceType(0);                          return state.DiscardStack();                      case MiscOp.Rethrow:                          return state.DiscardStack();                      case MiscOp.LdindRef:                          {                              var elemType = state.PeekPointerToReferenceType(0);                              return state.PopPushType(1' elemType' BottomPT);                          }                      case MiscOp.StindRef:                          {                              var expElemType = state.PeekPointerToReferenceType(1);                              state.PeekExpectedType(0' expElemType' changed);                              return state.Pop(2);                          }                      case MiscOp.LdelemRef:                          {                              state.PeekIndexType(0);                              // WARNING: Type may not be final                              var elemType = state.PeekArrayOfReferenceType(1);                              return state.PopPushType(2' elemType' BottomPT);                          }                      case MiscOp.StelemRef:                          state.PeekReferenceType(0);                          state.PeekIndexType(1);                          state.PeekArrayOfReferenceType(2);                          // Since the value type and array element type may be independently generalized'                          // it is pointless to check that the first is assignable to the second.                          // Instead this check is done at runtime.                          return state.Pop(3);                      case MiscOp.Ldlen:                          state.PeekArrayOfAnyType(0);                          return state.PopPushType(1' global.IntNativeRef' BottomPT);                      case MiscOp.Ret:                          {                              if (state.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return state; // empty                          }                      case MiscOp.RetVal:                          {                              state.PeekExpectedType(0' method.Result.Type' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfilter:                          {                              state.PeekExpectedType(0' global.Int32Ref' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfinally:                          {                              // Control could transfer to an outer finally/fault block' or to the target                              // of a leave instruction. However these transitions are delt with separately.                              return state.DiscardStack();                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:                  {                      var bri = (BranchInstruction)instruction;                      switch (bri.Op)                      {                      case BranchOp.Br:                          UnifyBeforeState(state' bri.Target' changed);                          return state;                      case BranchOp.Brtrue:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' false);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Brfalse:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Breq:                      case BranchOp.Brne:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' true);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Leave:                          {                              // Control could transfer via finally blocks instead of directly to the leave target.                              // Propogate only that the stack must be empty at target. Remaining machine state                              // is dealt with separately.                              UnifyBeforeState                                  (new MachineState(methEnv' method.ValueParameters.Count' method.Locals.Count)'                                   bri.Target'                                   changed);                              return state.DiscardStack();                          }                      case BranchOp.BrLt:                      case BranchOp.BrLe:                      case BranchOp.BrGt:                      case BranchOp.BrGe:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' false);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Switch:                  {                      var switchi = (SwitchInstruction)instruction;                      state.PeekExpectedType(0' global.Int32Ref' changed);                      var newState = state.Pop(1);                      for (var i = 0; i < switchi.CaseTargets.Count; i++)                          UnifyBeforeState(newState' switchi.CaseTargets[i]' changed);                      return newState;                  }              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      // WARNING: Capured type may not be final                      // NOTE: May capture skolemized types                      switch (cmpi.Op)                      {                      case CompareOp.Ceq:                      case CompareOp.CnePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' true);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.Clt:                      case CompareOp.Cgt:                      case CompareOp.CgePseudo:                      case CompareOp.ClePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' false);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.CtruePseudo:                      case CompareOp.CfalsePseudo:                          cmpi.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                          return state.PopPushType(1' global.Int32Ref' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var argi = (ArgLocalInstruction)instruction;                      var type = method.ArgLocalType(argi.ArgLocal' argi.Index);                      switch (argi.Op)                      {                      case ArgLocalOp.Ld:                          return state.PushType(type' state.ArgLocalPointsTo(argi.ArgLocal' argi.Index));                      case ArgLocalOp.Lda:                          return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(type)' ArgLocalPT(argi.ArgLocal' argi.Index));                      case ArgLocalOp.St:                          {                              state.PeekExpectedType(0' type' changed);                              var pointsTo = state.PeekPointsTo(0);                              if (!pointsTo.IsBottom)                              {                                  if (!(type.Style(methEnv) is ManagedPointerTypeStyle))                                      throw new InvalidOperationException                                          ("stack indicates pointer' but parameter or local type does not");                                  if (pointsTo.PointsOutsideOfHeap)                                      throw new InvalidOperationException("arguments cannot point outside of the heap");                              }                              return state.PopAddArgLocalPointsTo(1' argi.ArgLocal' argi.Index' pointsTo);                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      var fieldEnv = fieldi.Field.Enter(methEnv);                      var fieldType = fieldEnv.SubstituteType(fieldEnv.Field.FieldType);                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                              return state.PushType(fieldType' BottomPT);                          else                          {                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' true' changed);                              return state.PopPushType(1' fieldType' BottomPT);                          }                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                              return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          else                          {                              // Underlying type cannot be a struct' otherwise would have a pointer into                              // the stack                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' false' changed);                              return state.PopPushType                                  (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          }                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                          {                              state.PeekExpectedType(0' fieldType' changed);                              return state.Pop(1);                          }                          else                          {                              state.PeekExpectedType(0' fieldType' changed);                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (1' fieldi.Field.DefiningType' false' changed);                              return state.Pop(2);                          }                      case FieldOp.Ldtoken:                          return state.PushType(global.RuntimeFieldHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methi = (MethodInstruction)instruction;                      var sig = (CST.MethodSignature)methi.Method.ExternalSignature;                      switch (methi.Op)                      {                      case MethodOp.Call:                          {                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              if (methi.Constrained != null)                              {                                  if (!methi.IsVirtual || methi.Method.IsStatic)                                      throw new InvalidOperationException                                          ("constrained only valid on virtual calls to instance methods");                                  var thisType = sig.Parameters[0];                                  var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(methi.Constrained);                                  var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo(methi.Constrained);                                  var cs = methi.Constrained.Style(methEnv);                                  if (cs is ValueTypeStyle)                                  {                                      if (thisType.Style(methEnv) is ManagedPointerTypeStyle)                                      {                                          // We pass the argument pointer as is                                          if (!methi.Constrained.IsAssignableTo(methEnv' thisType.Arguments[0]))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                      else                                      {                                          // *Case 1* Morally we deref the argument pointer and box the contents'                                          // but since no supertype of a value type may mutate the underlying value'                                          // we don't need to take a copy of the value when boxing' so in practice                                          // this is a no-op                                          if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                  }                                  else if (cs is ReferenceTypeStyle)                                  {                                      // *Case 2* We dereference the pointer and pass the object reference                                      if (!methi.Constrained.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else if (cs is ParameterTypeStyle)                                  {                                      // Since we are calling an instance method' we know the first argument cannot be                                      // a "naked" type parameter' but is either a class or an interface.                                      // We must decide between cases 1 and 2 above at runtime' but checking as                                      // per case 1 is sufficient now.                                      // NOTE: As for box/classcast/isinst below' if the parameter is                                      // instantiated to a reference type then the type box type is considered                                      // equivalent to the underyling reference type.                                      if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else                                      throw new InvalidOperationException                                          ("constrained must be value' reference or parameter type");                                    state.PeekExpectedType(sig.Parameters.Count - 1' constrainedPtr' changed);                              }                              else if (sig.Parameters.Count > 0)                                  state.PeekExpectedType(sig.Parameters.Count - 1' sig.Parameters[0]' changed);                              if (sig.Result == null)                                  return state.Pop(sig.Parameters.Count);                              else                                  return state.PopPushType(sig.Parameters.Count' sig.Result' BottomPT);                          }                      case MethodOp.Ldftn:                          {                              // NOTE: Verified CLR allows only the two "blessed" sequences:                              //   dup; ldvirtftn; newobj <delegate ctor>                              //   ldftn; newobj <delegate ctor>                              // It is thus possible to check the delegate will capture an instance which                              // implements the loaded method. However' we don't check that here.                              if (methi.IsVirtual)                              {                                  if (methi.Method.IsStatic)                                      throw new InvalidOperationException("cannot ldvirtftn of a static method");                                  var objectType = default(TypeRef);                                  if (sig.Parameters[0].Style(methEnv) is ManagedPointerTypeStyle)                                      // Object should be a box                                      objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(sig.Parameters[0].Arguments[0]);                                  else                                      // Object should match parameter                                      objectType = sig.Parameters[0];                                  state.PeekExpectedType(0' objectType' changed);                                  return state.PopPushType(1' sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                              else                              {                                  if (methi.Method.IsStatic)                                      return state.PushType(sig.ToCodePointer(methEnv.Global)' BottomPT);                                  else                                      return state.PushType(sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                          }                      case MethodOp.Newobj:                          {                              if (methi.Method.IsStatic || sig.Result != null)                                  throw new InvalidOperationException("not a constructor");                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              // First argument to constructor is created by runtime. If definining type is                              // a value type' first argument will be a pointer' but result left on stack                              // will be the value itself.                              return state.PopPushType(sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);                          }                      case MethodOp.Ldtoken:                          return state.PushType(global.RuntimeMethodHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          state.PeekReadPointerType(0' typei.Type);                          return state.PopPushType(1' typei.Type' BottomPT);                      case TypeOp.Stobj:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Cpobj:                          state.PeekReadPointerType(0' typei.Type);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Newarr:                          state.PeekIndexType(0);                          return state.PopPushType(1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo(typei.Type)' BottomPT);                      case TypeOp.Initobj:                          state.PeekWritePointerType(0' typei.Type);                          return state.Pop(1);                      case TypeOp.Castclass:                      case TypeOp.Isinst:                      case TypeOp.Box:                          {                              var resultType = default(TypeRef);                              var s = typei.Type.Style(methEnv);                              if (s is NullableTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type.Arguments[0]);                              else if (s is ValueTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else if (s is ReferenceTypeStyle)                                  resultType = typei.Type;                              else if (s is ParameterTypeStyle)                                  // NOTE: As for constrained call above' if type parameter is instantitated to                                  // a ref type' then this box type is considered equivalent to the                                  // underlying reference type.                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else                                  throw new InvalidOperationException                                      ("can only box/cast to reference' value or parameter type");                              if (typei.Op == TypeOp.Box)                                  state.PeekExpectedType(0' typei.Type' changed);                              else                                  state.PeekReferenceType(0);                              return state.PopPushType(1' resultType' BottomPT);                          }                      case TypeOp.Unbox:                          if (!(typei.Type.Style(methEnv) is ValueTypeStyle))                              // Parameter types are not allowed                              throw new InvalidOperationException("type must be a value type");                          state.PeekBoxedType(0' typei.Type' changed);                          return state.PopPushType(1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(typei.Type)' HeapPT);                      case TypeOp.UnboxAny:                          {                              var s = typei.Type.Style(methEnv);                              if (s is ValueTypeStyle)                                  state.PeekBoxedType(0' typei.Type' changed);                              else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))                                  throw new InvalidOperationException("type must be value' reference or parameter type");                              return state.PopPushType(1' typei.Type' BottomPT);                          }                      case TypeOp.Ldtoken:                          return state.PushType(global.RuntimeTypeHandleRef' BottomPT);                      case TypeOp.Ldelem:                          state.PeekIndexType(0);                          state.PeekReadArrayType(1' typei.Type' false);                          return state.PopPushType(2' typei.Type' BottomPT);                      case TypeOp.Stelem:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekIndexType(1);                          state.PeekWriteArrayType(2' typei.Type);                          return state.Pop(3);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  {                      var ldelemai = (LdElemAddrInstruction)instruction;                      state.PeekIndexType(0);                      // WARNING: May prematurely fail for non-readonly loads                      state.PeekReadArrayType(1' ldelemai.Type' !ldelemai.IsReadonly);                      return state.PopPushType(2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(ldelemai.Type)' HeapPT);                  }              case InstructionFlavor.LdInt32:                  return state.PushType(global.Int32Ref' BottomPT);              case InstructionFlavor.LdInt64:                  return state.PushType(global.Int64Ref' BottomPT);              case InstructionFlavor.LdSingle:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdDouble:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdString:                  return state.PushType(global.StringRef' BottomPT);              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.Div:                      case ArithOp.Rem:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' true);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.Neg:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' true);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' false);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.BitNot:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.Shl:                      case ArithOp.Shr:                          state.PeekExpectedType(0' global.Int32Ref' changed);                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(1' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(2' arithi.Type' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned &&                                           convi.TargetNumberFlavor == NumberFlavor.Double);                      // NOTE: May capture skolemized types                      convi.SourceType = state.PeekNumberType(0' !mustBeInteger);                      return state.PopPushType(1' TypeRef.NumberFrom(methEnv.Global' convi.TargetNumberFlavor)' BottomPT);                  }              case InstructionFlavor.Try:                  {                      var tryi = (TryInstruction)instruction;                      // Isolation:                      //  - There is no way for the current stack shape to influence or be influenced by                      //    inference of the try' since the current stack shape must be empty.                      //  - There is no way for the try to influence the result stack shape' since it must be                      //    empty.                      //  - However pointers in arguments and locals may propogate into and out of try body                      //    via exceptional transitions. The latter are delt with separately.                      if (state.Depth != 0)                          throw new InvalidOperationException("stack should be empty");                      var newState = ForwardBlock                          (new TryBodyInstructionContext(context' index' tryi.Body)' state' changed);                      for (var j = 0; j < tryi.Handlers.Count; j++)                      {                          var h = tryi.Handlers[j];                          var handlerContext = new TryHandlerInstructionContext(context' index' h.Body' j);                          var initHandlerState = new MachineState                              (methEnv' method.ValueParameters.Count' method.Locals.Count);                          switch (h.Flavor)                          {                          case HandlerFlavor.Catch:                              {                                  var catchh = (CatchTryInstructionHandler)h;                                  ForwardBlock(handlerContext' initHandlerState.PushType(catchh.Type' BottomPT)' changed);                                  break;                              }                          case HandlerFlavor.Filter:                              throw new NotSupportedException("filter handler blocks");                          case HandlerFlavor.Fault:                          case HandlerFlavor.Finally:                              ForwardBlock(handlerContext' initHandlerState' changed);                              break;                          default:                              throw new ArgumentOutOfRangeException();                          }                      }                      return newState;                  }              case InstructionFlavor.IfThenElsePseudo:              case InstructionFlavor.ShortCircuitingPseudo:              case InstructionFlavor.StructuralSwitchPseudo:              case InstructionFlavor.LoopPseudo:              case InstructionFlavor.WhileDoPseudo:              case InstructionFlavor.DoWhilePseudo:              case InstructionFlavor.LoopControlPseudo:                  throw new InvalidOperationException("no machine state inference for psuedo-instructions");              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return state;                      case MiscOp.Dup:                          return state.Push(state.Peek(0));                      case MiscOp.Pop:                          return state.Pop(1);                      case MiscOp.Ldnull:                          return state.PushType(global.NullRef' BottomPT);                      case MiscOp.Ckfinite:                          state.PeekExpectedType(0' global.DoubleRef' changed);                          // Assume the instruction can "peek" at top of stack' thus no need for pop/push.                          return state;                      case MiscOp.Throw:                          state.PeekReferenceType(0);                          return state.DiscardStack();                      case MiscOp.Rethrow:                          return state.DiscardStack();                      case MiscOp.LdindRef:                          {                              var elemType = state.PeekPointerToReferenceType(0);                              return state.PopPushType(1' elemType' BottomPT);                          }                      case MiscOp.StindRef:                          {                              var expElemType = state.PeekPointerToReferenceType(1);                              state.PeekExpectedType(0' expElemType' changed);                              return state.Pop(2);                          }                      case MiscOp.LdelemRef:                          {                              state.PeekIndexType(0);                              // WARNING: Type may not be final                              var elemType = state.PeekArrayOfReferenceType(1);                              return state.PopPushType(2' elemType' BottomPT);                          }                      case MiscOp.StelemRef:                          state.PeekReferenceType(0);                          state.PeekIndexType(1);                          state.PeekArrayOfReferenceType(2);                          // Since the value type and array element type may be independently generalized'                          // it is pointless to check that the first is assignable to the second.                          // Instead this check is done at runtime.                          return state.Pop(3);                      case MiscOp.Ldlen:                          state.PeekArrayOfAnyType(0);                          return state.PopPushType(1' global.IntNativeRef' BottomPT);                      case MiscOp.Ret:                          {                              if (state.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return state; // empty                          }                      case MiscOp.RetVal:                          {                              state.PeekExpectedType(0' method.Result.Type' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfilter:                          {                              state.PeekExpectedType(0' global.Int32Ref' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfinally:                          {                              // Control could transfer to an outer finally/fault block' or to the target                              // of a leave instruction. However these transitions are delt with separately.                              return state.DiscardStack();                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:                  {                      var bri = (BranchInstruction)instruction;                      switch (bri.Op)                      {                      case BranchOp.Br:                          UnifyBeforeState(state' bri.Target' changed);                          return state;                      case BranchOp.Brtrue:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' false);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Brfalse:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Breq:                      case BranchOp.Brne:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' true);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Leave:                          {                              // Control could transfer via finally blocks instead of directly to the leave target.                              // Propogate only that the stack must be empty at target. Remaining machine state                              // is dealt with separately.                              UnifyBeforeState                                  (new MachineState(methEnv' method.ValueParameters.Count' method.Locals.Count)'                                   bri.Target'                                   changed);                              return state.DiscardStack();                          }                      case BranchOp.BrLt:                      case BranchOp.BrLe:                      case BranchOp.BrGt:                      case BranchOp.BrGe:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' false);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Switch:                  {                      var switchi = (SwitchInstruction)instruction;                      state.PeekExpectedType(0' global.Int32Ref' changed);                      var newState = state.Pop(1);                      for (var i = 0; i < switchi.CaseTargets.Count; i++)                          UnifyBeforeState(newState' switchi.CaseTargets[i]' changed);                      return newState;                  }              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      // WARNING: Capured type may not be final                      // NOTE: May capture skolemized types                      switch (cmpi.Op)                      {                      case CompareOp.Ceq:                      case CompareOp.CnePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' true);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.Clt:                      case CompareOp.Cgt:                      case CompareOp.CgePseudo:                      case CompareOp.ClePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' false);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.CtruePseudo:                      case CompareOp.CfalsePseudo:                          cmpi.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                          return state.PopPushType(1' global.Int32Ref' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var argi = (ArgLocalInstruction)instruction;                      var type = method.ArgLocalType(argi.ArgLocal' argi.Index);                      switch (argi.Op)                      {                      case ArgLocalOp.Ld:                          return state.PushType(type' state.ArgLocalPointsTo(argi.ArgLocal' argi.Index));                      case ArgLocalOp.Lda:                          return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(type)' ArgLocalPT(argi.ArgLocal' argi.Index));                      case ArgLocalOp.St:                          {                              state.PeekExpectedType(0' type' changed);                              var pointsTo = state.PeekPointsTo(0);                              if (!pointsTo.IsBottom)                              {                                  if (!(type.Style(methEnv) is ManagedPointerTypeStyle))                                      throw new InvalidOperationException                                          ("stack indicates pointer' but parameter or local type does not");                                  if (pointsTo.PointsOutsideOfHeap)                                      throw new InvalidOperationException("arguments cannot point outside of the heap");                              }                              return state.PopAddArgLocalPointsTo(1' argi.ArgLocal' argi.Index' pointsTo);                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      var fieldEnv = fieldi.Field.Enter(methEnv);                      var fieldType = fieldEnv.SubstituteType(fieldEnv.Field.FieldType);                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                              return state.PushType(fieldType' BottomPT);                          else                          {                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' true' changed);                              return state.PopPushType(1' fieldType' BottomPT);                          }                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                              return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          else                          {                              // Underlying type cannot be a struct' otherwise would have a pointer into                              // the stack                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' false' changed);                              return state.PopPushType                                  (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          }                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                          {                              state.PeekExpectedType(0' fieldType' changed);                              return state.Pop(1);                          }                          else                          {                              state.PeekExpectedType(0' fieldType' changed);                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (1' fieldi.Field.DefiningType' false' changed);                              return state.Pop(2);                          }                      case FieldOp.Ldtoken:                          return state.PushType(global.RuntimeFieldHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methi = (MethodInstruction)instruction;                      var sig = (CST.MethodSignature)methi.Method.ExternalSignature;                      switch (methi.Op)                      {                      case MethodOp.Call:                          {                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              if (methi.Constrained != null)                              {                                  if (!methi.IsVirtual || methi.Method.IsStatic)                                      throw new InvalidOperationException                                          ("constrained only valid on virtual calls to instance methods");                                  var thisType = sig.Parameters[0];                                  var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(methi.Constrained);                                  var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo(methi.Constrained);                                  var cs = methi.Constrained.Style(methEnv);                                  if (cs is ValueTypeStyle)                                  {                                      if (thisType.Style(methEnv) is ManagedPointerTypeStyle)                                      {                                          // We pass the argument pointer as is                                          if (!methi.Constrained.IsAssignableTo(methEnv' thisType.Arguments[0]))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                      else                                      {                                          // *Case 1* Morally we deref the argument pointer and box the contents'                                          // but since no supertype of a value type may mutate the underlying value'                                          // we don't need to take a copy of the value when boxing' so in practice                                          // this is a no-op                                          if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                  }                                  else if (cs is ReferenceTypeStyle)                                  {                                      // *Case 2* We dereference the pointer and pass the object reference                                      if (!methi.Constrained.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else if (cs is ParameterTypeStyle)                                  {                                      // Since we are calling an instance method' we know the first argument cannot be                                      // a "naked" type parameter' but is either a class or an interface.                                      // We must decide between cases 1 and 2 above at runtime' but checking as                                      // per case 1 is sufficient now.                                      // NOTE: As for box/classcast/isinst below' if the parameter is                                      // instantiated to a reference type then the type box type is considered                                      // equivalent to the underyling reference type.                                      if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else                                      throw new InvalidOperationException                                          ("constrained must be value' reference or parameter type");                                    state.PeekExpectedType(sig.Parameters.Count - 1' constrainedPtr' changed);                              }                              else if (sig.Parameters.Count > 0)                                  state.PeekExpectedType(sig.Parameters.Count - 1' sig.Parameters[0]' changed);                              if (sig.Result == null)                                  return state.Pop(sig.Parameters.Count);                              else                                  return state.PopPushType(sig.Parameters.Count' sig.Result' BottomPT);                          }                      case MethodOp.Ldftn:                          {                              // NOTE: Verified CLR allows only the two "blessed" sequences:                              //   dup; ldvirtftn; newobj <delegate ctor>                              //   ldftn; newobj <delegate ctor>                              // It is thus possible to check the delegate will capture an instance which                              // implements the loaded method. However' we don't check that here.                              if (methi.IsVirtual)                              {                                  if (methi.Method.IsStatic)                                      throw new InvalidOperationException("cannot ldvirtftn of a static method");                                  var objectType = default(TypeRef);                                  if (sig.Parameters[0].Style(methEnv) is ManagedPointerTypeStyle)                                      // Object should be a box                                      objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(sig.Parameters[0].Arguments[0]);                                  else                                      // Object should match parameter                                      objectType = sig.Parameters[0];                                  state.PeekExpectedType(0' objectType' changed);                                  return state.PopPushType(1' sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                              else                              {                                  if (methi.Method.IsStatic)                                      return state.PushType(sig.ToCodePointer(methEnv.Global)' BottomPT);                                  else                                      return state.PushType(sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                          }                      case MethodOp.Newobj:                          {                              if (methi.Method.IsStatic || sig.Result != null)                                  throw new InvalidOperationException("not a constructor");                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              // First argument to constructor is created by runtime. If definining type is                              // a value type' first argument will be a pointer' but result left on stack                              // will be the value itself.                              return state.PopPushType(sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);                          }                      case MethodOp.Ldtoken:                          return state.PushType(global.RuntimeMethodHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          state.PeekReadPointerType(0' typei.Type);                          return state.PopPushType(1' typei.Type' BottomPT);                      case TypeOp.Stobj:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Cpobj:                          state.PeekReadPointerType(0' typei.Type);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Newarr:                          state.PeekIndexType(0);                          return state.PopPushType(1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo(typei.Type)' BottomPT);                      case TypeOp.Initobj:                          state.PeekWritePointerType(0' typei.Type);                          return state.Pop(1);                      case TypeOp.Castclass:                      case TypeOp.Isinst:                      case TypeOp.Box:                          {                              var resultType = default(TypeRef);                              var s = typei.Type.Style(methEnv);                              if (s is NullableTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type.Arguments[0]);                              else if (s is ValueTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else if (s is ReferenceTypeStyle)                                  resultType = typei.Type;                              else if (s is ParameterTypeStyle)                                  // NOTE: As for constrained call above' if type parameter is instantitated to                                  // a ref type' then this box type is considered equivalent to the                                  // underlying reference type.                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else                                  throw new InvalidOperationException                                      ("can only box/cast to reference' value or parameter type");                              if (typei.Op == TypeOp.Box)                                  state.PeekExpectedType(0' typei.Type' changed);                              else                                  state.PeekReferenceType(0);                              return state.PopPushType(1' resultType' BottomPT);                          }                      case TypeOp.Unbox:                          if (!(typei.Type.Style(methEnv) is ValueTypeStyle))                              // Parameter types are not allowed                              throw new InvalidOperationException("type must be a value type");                          state.PeekBoxedType(0' typei.Type' changed);                          return state.PopPushType(1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(typei.Type)' HeapPT);                      case TypeOp.UnboxAny:                          {                              var s = typei.Type.Style(methEnv);                              if (s is ValueTypeStyle)                                  state.PeekBoxedType(0' typei.Type' changed);                              else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))                                  throw new InvalidOperationException("type must be value' reference or parameter type");                              return state.PopPushType(1' typei.Type' BottomPT);                          }                      case TypeOp.Ldtoken:                          return state.PushType(global.RuntimeTypeHandleRef' BottomPT);                      case TypeOp.Ldelem:                          state.PeekIndexType(0);                          state.PeekReadArrayType(1' typei.Type' false);                          return state.PopPushType(2' typei.Type' BottomPT);                      case TypeOp.Stelem:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekIndexType(1);                          state.PeekWriteArrayType(2' typei.Type);                          return state.Pop(3);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  {                      var ldelemai = (LdElemAddrInstruction)instruction;                      state.PeekIndexType(0);                      // WARNING: May prematurely fail for non-readonly loads                      state.PeekReadArrayType(1' ldelemai.Type' !ldelemai.IsReadonly);                      return state.PopPushType(2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(ldelemai.Type)' HeapPT);                  }              case InstructionFlavor.LdInt32:                  return state.PushType(global.Int32Ref' BottomPT);              case InstructionFlavor.LdInt64:                  return state.PushType(global.Int64Ref' BottomPT);              case InstructionFlavor.LdSingle:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdDouble:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdString:                  return state.PushType(global.StringRef' BottomPT);              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.Div:                      case ArithOp.Rem:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' true);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.Neg:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' true);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' false);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.BitNot:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.Shl:                      case ArithOp.Shr:                          state.PeekExpectedType(0' global.Int32Ref' changed);                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(1' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(2' arithi.Type' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned &&                                           convi.TargetNumberFlavor == NumberFlavor.Double);                      // NOTE: May capture skolemized types                      convi.SourceType = state.PeekNumberType(0' !mustBeInteger);                      return state.PopPushType(1' TypeRef.NumberFrom(methEnv.Global' convi.TargetNumberFlavor)' BottomPT);                  }              case InstructionFlavor.Try:                  {                      var tryi = (TryInstruction)instruction;                      // Isolation:                      //  - There is no way for the current stack shape to influence or be influenced by                      //    inference of the try' since the current stack shape must be empty.                      //  - There is no way for the try to influence the result stack shape' since it must be                      //    empty.                      //  - However pointers in arguments and locals may propogate into and out of try body                      //    via exceptional transitions. The latter are delt with separately.                      if (state.Depth != 0)                          throw new InvalidOperationException("stack should be empty");                      var newState = ForwardBlock                          (new TryBodyInstructionContext(context' index' tryi.Body)' state' changed);                      for (var j = 0; j < tryi.Handlers.Count; j++)                      {                          var h = tryi.Handlers[j];                          var handlerContext = new TryHandlerInstructionContext(context' index' h.Body' j);                          var initHandlerState = new MachineState                              (methEnv' method.ValueParameters.Count' method.Locals.Count);                          switch (h.Flavor)                          {                          case HandlerFlavor.Catch:                              {                                  var catchh = (CatchTryInstructionHandler)h;                                  ForwardBlock(handlerContext' initHandlerState.PushType(catchh.Type' BottomPT)' changed);                                  break;                              }                          case HandlerFlavor.Filter:                              throw new NotSupportedException("filter handler blocks");                          case HandlerFlavor.Fault:                          case HandlerFlavor.Finally:                              ForwardBlock(handlerContext' initHandlerState' changed);                              break;                          default:                              throw new ArgumentOutOfRangeException();                          }                      }                      return newState;                  }              case InstructionFlavor.IfThenElsePseudo:              case InstructionFlavor.ShortCircuitingPseudo:              case InstructionFlavor.StructuralSwitchPseudo:              case InstructionFlavor.LoopPseudo:              case InstructionFlavor.WhileDoPseudo:              case InstructionFlavor.DoWhilePseudo:              case InstructionFlavor.LoopControlPseudo:                  throw new InvalidOperationException("no machine state inference for psuedo-instructions");              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return state;                      case MiscOp.Dup:                          return state.Push(state.Peek(0));                      case MiscOp.Pop:                          return state.Pop(1);                      case MiscOp.Ldnull:                          return state.PushType(global.NullRef' BottomPT);                      case MiscOp.Ckfinite:                          state.PeekExpectedType(0' global.DoubleRef' changed);                          // Assume the instruction can "peek" at top of stack' thus no need for pop/push.                          return state;                      case MiscOp.Throw:                          state.PeekReferenceType(0);                          return state.DiscardStack();                      case MiscOp.Rethrow:                          return state.DiscardStack();                      case MiscOp.LdindRef:                          {                              var elemType = state.PeekPointerToReferenceType(0);                              return state.PopPushType(1' elemType' BottomPT);                          }                      case MiscOp.StindRef:                          {                              var expElemType = state.PeekPointerToReferenceType(1);                              state.PeekExpectedType(0' expElemType' changed);                              return state.Pop(2);                          }                      case MiscOp.LdelemRef:                          {                              state.PeekIndexType(0);                              // WARNING: Type may not be final                              var elemType = state.PeekArrayOfReferenceType(1);                              return state.PopPushType(2' elemType' BottomPT);                          }                      case MiscOp.StelemRef:                          state.PeekReferenceType(0);                          state.PeekIndexType(1);                          state.PeekArrayOfReferenceType(2);                          // Since the value type and array element type may be independently generalized'                          // it is pointless to check that the first is assignable to the second.                          // Instead this check is done at runtime.                          return state.Pop(3);                      case MiscOp.Ldlen:                          state.PeekArrayOfAnyType(0);                          return state.PopPushType(1' global.IntNativeRef' BottomPT);                      case MiscOp.Ret:                          {                              if (state.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return state; // empty                          }                      case MiscOp.RetVal:                          {                              state.PeekExpectedType(0' method.Result.Type' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfilter:                          {                              state.PeekExpectedType(0' global.Int32Ref' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfinally:                          {                              // Control could transfer to an outer finally/fault block' or to the target                              // of a leave instruction. However these transitions are delt with separately.                              return state.DiscardStack();                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:                  {                      var bri = (BranchInstruction)instruction;                      switch (bri.Op)                      {                      case BranchOp.Br:                          UnifyBeforeState(state' bri.Target' changed);                          return state;                      case BranchOp.Brtrue:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' false);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Brfalse:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Breq:                      case BranchOp.Brne:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' true);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Leave:                          {                              // Control could transfer via finally blocks instead of directly to the leave target.                              // Propogate only that the stack must be empty at target. Remaining machine state                              // is dealt with separately.                              UnifyBeforeState                                  (new MachineState(methEnv' method.ValueParameters.Count' method.Locals.Count)'                                   bri.Target'                                   changed);                              return state.DiscardStack();                          }                      case BranchOp.BrLt:                      case BranchOp.BrLe:                      case BranchOp.BrGt:                      case BranchOp.BrGe:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' false);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Switch:                  {                      var switchi = (SwitchInstruction)instruction;                      state.PeekExpectedType(0' global.Int32Ref' changed);                      var newState = state.Pop(1);                      for (var i = 0; i < switchi.CaseTargets.Count; i++)                          UnifyBeforeState(newState' switchi.CaseTargets[i]' changed);                      return newState;                  }              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      // WARNING: Capured type may not be final                      // NOTE: May capture skolemized types                      switch (cmpi.Op)                      {                      case CompareOp.Ceq:                      case CompareOp.CnePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' true);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.Clt:                      case CompareOp.Cgt:                      case CompareOp.CgePseudo:                      case CompareOp.ClePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' false);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.CtruePseudo:                      case CompareOp.CfalsePseudo:                          cmpi.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                          return state.PopPushType(1' global.Int32Ref' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var argi = (ArgLocalInstruction)instruction;                      var type = method.ArgLocalType(argi.ArgLocal' argi.Index);                      switch (argi.Op)                      {                      case ArgLocalOp.Ld:                          return state.PushType(type' state.ArgLocalPointsTo(argi.ArgLocal' argi.Index));                      case ArgLocalOp.Lda:                          return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(type)' ArgLocalPT(argi.ArgLocal' argi.Index));                      case ArgLocalOp.St:                          {                              state.PeekExpectedType(0' type' changed);                              var pointsTo = state.PeekPointsTo(0);                              if (!pointsTo.IsBottom)                              {                                  if (!(type.Style(methEnv) is ManagedPointerTypeStyle))                                      throw new InvalidOperationException                                          ("stack indicates pointer' but parameter or local type does not");                                  if (pointsTo.PointsOutsideOfHeap)                                      throw new InvalidOperationException("arguments cannot point outside of the heap");                              }                              return state.PopAddArgLocalPointsTo(1' argi.ArgLocal' argi.Index' pointsTo);                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      var fieldEnv = fieldi.Field.Enter(methEnv);                      var fieldType = fieldEnv.SubstituteType(fieldEnv.Field.FieldType);                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                              return state.PushType(fieldType' BottomPT);                          else                          {                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' true' changed);                              return state.PopPushType(1' fieldType' BottomPT);                          }                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                              return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          else                          {                              // Underlying type cannot be a struct' otherwise would have a pointer into                              // the stack                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' false' changed);                              return state.PopPushType                                  (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          }                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                          {                              state.PeekExpectedType(0' fieldType' changed);                              return state.Pop(1);                          }                          else                          {                              state.PeekExpectedType(0' fieldType' changed);                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (1' fieldi.Field.DefiningType' false' changed);                              return state.Pop(2);                          }                      case FieldOp.Ldtoken:                          return state.PushType(global.RuntimeFieldHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methi = (MethodInstruction)instruction;                      var sig = (CST.MethodSignature)methi.Method.ExternalSignature;                      switch (methi.Op)                      {                      case MethodOp.Call:                          {                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              if (methi.Constrained != null)                              {                                  if (!methi.IsVirtual || methi.Method.IsStatic)                                      throw new InvalidOperationException                                          ("constrained only valid on virtual calls to instance methods");                                  var thisType = sig.Parameters[0];                                  var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(methi.Constrained);                                  var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo(methi.Constrained);                                  var cs = methi.Constrained.Style(methEnv);                                  if (cs is ValueTypeStyle)                                  {                                      if (thisType.Style(methEnv) is ManagedPointerTypeStyle)                                      {                                          // We pass the argument pointer as is                                          if (!methi.Constrained.IsAssignableTo(methEnv' thisType.Arguments[0]))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                      else                                      {                                          // *Case 1* Morally we deref the argument pointer and box the contents'                                          // but since no supertype of a value type may mutate the underlying value'                                          // we don't need to take a copy of the value when boxing' so in practice                                          // this is a no-op                                          if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                  }                                  else if (cs is ReferenceTypeStyle)                                  {                                      // *Case 2* We dereference the pointer and pass the object reference                                      if (!methi.Constrained.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else if (cs is ParameterTypeStyle)                                  {                                      // Since we are calling an instance method' we know the first argument cannot be                                      // a "naked" type parameter' but is either a class or an interface.                                      // We must decide between cases 1 and 2 above at runtime' but checking as                                      // per case 1 is sufficient now.                                      // NOTE: As for box/classcast/isinst below' if the parameter is                                      // instantiated to a reference type then the type box type is considered                                      // equivalent to the underyling reference type.                                      if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else                                      throw new InvalidOperationException                                          ("constrained must be value' reference or parameter type");                                    state.PeekExpectedType(sig.Parameters.Count - 1' constrainedPtr' changed);                              }                              else if (sig.Parameters.Count > 0)                                  state.PeekExpectedType(sig.Parameters.Count - 1' sig.Parameters[0]' changed);                              if (sig.Result == null)                                  return state.Pop(sig.Parameters.Count);                              else                                  return state.PopPushType(sig.Parameters.Count' sig.Result' BottomPT);                          }                      case MethodOp.Ldftn:                          {                              // NOTE: Verified CLR allows only the two "blessed" sequences:                              //   dup; ldvirtftn; newobj <delegate ctor>                              //   ldftn; newobj <delegate ctor>                              // It is thus possible to check the delegate will capture an instance which                              // implements the loaded method. However' we don't check that here.                              if (methi.IsVirtual)                              {                                  if (methi.Method.IsStatic)                                      throw new InvalidOperationException("cannot ldvirtftn of a static method");                                  var objectType = default(TypeRef);                                  if (sig.Parameters[0].Style(methEnv) is ManagedPointerTypeStyle)                                      // Object should be a box                                      objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(sig.Parameters[0].Arguments[0]);                                  else                                      // Object should match parameter                                      objectType = sig.Parameters[0];                                  state.PeekExpectedType(0' objectType' changed);                                  return state.PopPushType(1' sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                              else                              {                                  if (methi.Method.IsStatic)                                      return state.PushType(sig.ToCodePointer(methEnv.Global)' BottomPT);                                  else                                      return state.PushType(sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                          }                      case MethodOp.Newobj:                          {                              if (methi.Method.IsStatic || sig.Result != null)                                  throw new InvalidOperationException("not a constructor");                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              // First argument to constructor is created by runtime. If definining type is                              // a value type' first argument will be a pointer' but result left on stack                              // will be the value itself.                              return state.PopPushType(sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);                          }                      case MethodOp.Ldtoken:                          return state.PushType(global.RuntimeMethodHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          state.PeekReadPointerType(0' typei.Type);                          return state.PopPushType(1' typei.Type' BottomPT);                      case TypeOp.Stobj:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Cpobj:                          state.PeekReadPointerType(0' typei.Type);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Newarr:                          state.PeekIndexType(0);                          return state.PopPushType(1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo(typei.Type)' BottomPT);                      case TypeOp.Initobj:                          state.PeekWritePointerType(0' typei.Type);                          return state.Pop(1);                      case TypeOp.Castclass:                      case TypeOp.Isinst:                      case TypeOp.Box:                          {                              var resultType = default(TypeRef);                              var s = typei.Type.Style(methEnv);                              if (s is NullableTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type.Arguments[0]);                              else if (s is ValueTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else if (s is ReferenceTypeStyle)                                  resultType = typei.Type;                              else if (s is ParameterTypeStyle)                                  // NOTE: As for constrained call above' if type parameter is instantitated to                                  // a ref type' then this box type is considered equivalent to the                                  // underlying reference type.                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else                                  throw new InvalidOperationException                                      ("can only box/cast to reference' value or parameter type");                              if (typei.Op == TypeOp.Box)                                  state.PeekExpectedType(0' typei.Type' changed);                              else                                  state.PeekReferenceType(0);                              return state.PopPushType(1' resultType' BottomPT);                          }                      case TypeOp.Unbox:                          if (!(typei.Type.Style(methEnv) is ValueTypeStyle))                              // Parameter types are not allowed                              throw new InvalidOperationException("type must be a value type");                          state.PeekBoxedType(0' typei.Type' changed);                          return state.PopPushType(1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(typei.Type)' HeapPT);                      case TypeOp.UnboxAny:                          {                              var s = typei.Type.Style(methEnv);                              if (s is ValueTypeStyle)                                  state.PeekBoxedType(0' typei.Type' changed);                              else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))                                  throw new InvalidOperationException("type must be value' reference or parameter type");                              return state.PopPushType(1' typei.Type' BottomPT);                          }                      case TypeOp.Ldtoken:                          return state.PushType(global.RuntimeTypeHandleRef' BottomPT);                      case TypeOp.Ldelem:                          state.PeekIndexType(0);                          state.PeekReadArrayType(1' typei.Type' false);                          return state.PopPushType(2' typei.Type' BottomPT);                      case TypeOp.Stelem:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekIndexType(1);                          state.PeekWriteArrayType(2' typei.Type);                          return state.Pop(3);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  {                      var ldelemai = (LdElemAddrInstruction)instruction;                      state.PeekIndexType(0);                      // WARNING: May prematurely fail for non-readonly loads                      state.PeekReadArrayType(1' ldelemai.Type' !ldelemai.IsReadonly);                      return state.PopPushType(2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(ldelemai.Type)' HeapPT);                  }              case InstructionFlavor.LdInt32:                  return state.PushType(global.Int32Ref' BottomPT);              case InstructionFlavor.LdInt64:                  return state.PushType(global.Int64Ref' BottomPT);              case InstructionFlavor.LdSingle:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdDouble:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdString:                  return state.PushType(global.StringRef' BottomPT);              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.Div:                      case ArithOp.Rem:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' true);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.Neg:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' true);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' false);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.BitNot:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.Shl:                      case ArithOp.Shr:                          state.PeekExpectedType(0' global.Int32Ref' changed);                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(1' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(2' arithi.Type' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned &&                                           convi.TargetNumberFlavor == NumberFlavor.Double);                      // NOTE: May capture skolemized types                      convi.SourceType = state.PeekNumberType(0' !mustBeInteger);                      return state.PopPushType(1' TypeRef.NumberFrom(methEnv.Global' convi.TargetNumberFlavor)' BottomPT);                  }              case InstructionFlavor.Try:                  {                      var tryi = (TryInstruction)instruction;                      // Isolation:                      //  - There is no way for the current stack shape to influence or be influenced by                      //    inference of the try' since the current stack shape must be empty.                      //  - There is no way for the try to influence the result stack shape' since it must be                      //    empty.                      //  - However pointers in arguments and locals may propogate into and out of try body                      //    via exceptional transitions. The latter are delt with separately.                      if (state.Depth != 0)                          throw new InvalidOperationException("stack should be empty");                      var newState = ForwardBlock                          (new TryBodyInstructionContext(context' index' tryi.Body)' state' changed);                      for (var j = 0; j < tryi.Handlers.Count; j++)                      {                          var h = tryi.Handlers[j];                          var handlerContext = new TryHandlerInstructionContext(context' index' h.Body' j);                          var initHandlerState = new MachineState                              (methEnv' method.ValueParameters.Count' method.Locals.Count);                          switch (h.Flavor)                          {                          case HandlerFlavor.Catch:                              {                                  var catchh = (CatchTryInstructionHandler)h;                                  ForwardBlock(handlerContext' initHandlerState.PushType(catchh.Type' BottomPT)' changed);                                  break;                              }                          case HandlerFlavor.Filter:                              throw new NotSupportedException("filter handler blocks");                          case HandlerFlavor.Fault:                          case HandlerFlavor.Finally:                              ForwardBlock(handlerContext' initHandlerState' changed);                              break;                          default:                              throw new ArgumentOutOfRangeException();                          }                      }                      return newState;                  }              case InstructionFlavor.IfThenElsePseudo:              case InstructionFlavor.ShortCircuitingPseudo:              case InstructionFlavor.StructuralSwitchPseudo:              case InstructionFlavor.LoopPseudo:              case InstructionFlavor.WhileDoPseudo:              case InstructionFlavor.DoWhilePseudo:              case InstructionFlavor.LoopControlPseudo:                  throw new InvalidOperationException("no machine state inference for psuedo-instructions");              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return state;                      case MiscOp.Dup:                          return state.Push(state.Peek(0));                      case MiscOp.Pop:                          return state.Pop(1);                      case MiscOp.Ldnull:                          return state.PushType(global.NullRef' BottomPT);                      case MiscOp.Ckfinite:                          state.PeekExpectedType(0' global.DoubleRef' changed);                          // Assume the instruction can "peek" at top of stack' thus no need for pop/push.                          return state;                      case MiscOp.Throw:                          state.PeekReferenceType(0);                          return state.DiscardStack();                      case MiscOp.Rethrow:                          return state.DiscardStack();                      case MiscOp.LdindRef:                          {                              var elemType = state.PeekPointerToReferenceType(0);                              return state.PopPushType(1' elemType' BottomPT);                          }                      case MiscOp.StindRef:                          {                              var expElemType = state.PeekPointerToReferenceType(1);                              state.PeekExpectedType(0' expElemType' changed);                              return state.Pop(2);                          }                      case MiscOp.LdelemRef:                          {                              state.PeekIndexType(0);                              // WARNING: Type may not be final                              var elemType = state.PeekArrayOfReferenceType(1);                              return state.PopPushType(2' elemType' BottomPT);                          }                      case MiscOp.StelemRef:                          state.PeekReferenceType(0);                          state.PeekIndexType(1);                          state.PeekArrayOfReferenceType(2);                          // Since the value type and array element type may be independently generalized'                          // it is pointless to check that the first is assignable to the second.                          // Instead this check is done at runtime.                          return state.Pop(3);                      case MiscOp.Ldlen:                          state.PeekArrayOfAnyType(0);                          return state.PopPushType(1' global.IntNativeRef' BottomPT);                      case MiscOp.Ret:                          {                              if (state.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return state; // empty                          }                      case MiscOp.RetVal:                          {                              state.PeekExpectedType(0' method.Result.Type' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfilter:                          {                              state.PeekExpectedType(0' global.Int32Ref' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfinally:                          {                              // Control could transfer to an outer finally/fault block' or to the target                              // of a leave instruction. However these transitions are delt with separately.                              return state.DiscardStack();                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:                  {                      var bri = (BranchInstruction)instruction;                      switch (bri.Op)                      {                      case BranchOp.Br:                          UnifyBeforeState(state' bri.Target' changed);                          return state;                      case BranchOp.Brtrue:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' false);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Brfalse:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Breq:                      case BranchOp.Brne:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' true);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Leave:                          {                              // Control could transfer via finally blocks instead of directly to the leave target.                              // Propogate only that the stack must be empty at target. Remaining machine state                              // is dealt with separately.                              UnifyBeforeState                                  (new MachineState(methEnv' method.ValueParameters.Count' method.Locals.Count)'                                   bri.Target'                                   changed);                              return state.DiscardStack();                          }                      case BranchOp.BrLt:                      case BranchOp.BrLe:                      case BranchOp.BrGt:                      case BranchOp.BrGe:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' false);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Switch:                  {                      var switchi = (SwitchInstruction)instruction;                      state.PeekExpectedType(0' global.Int32Ref' changed);                      var newState = state.Pop(1);                      for (var i = 0; i < switchi.CaseTargets.Count; i++)                          UnifyBeforeState(newState' switchi.CaseTargets[i]' changed);                      return newState;                  }              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      // WARNING: Capured type may not be final                      // NOTE: May capture skolemized types                      switch (cmpi.Op)                      {                      case CompareOp.Ceq:                      case CompareOp.CnePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' true);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.Clt:                      case CompareOp.Cgt:                      case CompareOp.CgePseudo:                      case CompareOp.ClePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' false);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.CtruePseudo:                      case CompareOp.CfalsePseudo:                          cmpi.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                          return state.PopPushType(1' global.Int32Ref' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var argi = (ArgLocalInstruction)instruction;                      var type = method.ArgLocalType(argi.ArgLocal' argi.Index);                      switch (argi.Op)                      {                      case ArgLocalOp.Ld:                          return state.PushType(type' state.ArgLocalPointsTo(argi.ArgLocal' argi.Index));                      case ArgLocalOp.Lda:                          return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(type)' ArgLocalPT(argi.ArgLocal' argi.Index));                      case ArgLocalOp.St:                          {                              state.PeekExpectedType(0' type' changed);                              var pointsTo = state.PeekPointsTo(0);                              if (!pointsTo.IsBottom)                              {                                  if (!(type.Style(methEnv) is ManagedPointerTypeStyle))                                      throw new InvalidOperationException                                          ("stack indicates pointer' but parameter or local type does not");                                  if (pointsTo.PointsOutsideOfHeap)                                      throw new InvalidOperationException("arguments cannot point outside of the heap");                              }                              return state.PopAddArgLocalPointsTo(1' argi.ArgLocal' argi.Index' pointsTo);                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      var fieldEnv = fieldi.Field.Enter(methEnv);                      var fieldType = fieldEnv.SubstituteType(fieldEnv.Field.FieldType);                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                              return state.PushType(fieldType' BottomPT);                          else                          {                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' true' changed);                              return state.PopPushType(1' fieldType' BottomPT);                          }                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                              return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          else                          {                              // Underlying type cannot be a struct' otherwise would have a pointer into                              // the stack                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' false' changed);                              return state.PopPushType                                  (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          }                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                          {                              state.PeekExpectedType(0' fieldType' changed);                              return state.Pop(1);                          }                          else                          {                              state.PeekExpectedType(0' fieldType' changed);                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (1' fieldi.Field.DefiningType' false' changed);                              return state.Pop(2);                          }                      case FieldOp.Ldtoken:                          return state.PushType(global.RuntimeFieldHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methi = (MethodInstruction)instruction;                      var sig = (CST.MethodSignature)methi.Method.ExternalSignature;                      switch (methi.Op)                      {                      case MethodOp.Call:                          {                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              if (methi.Constrained != null)                              {                                  if (!methi.IsVirtual || methi.Method.IsStatic)                                      throw new InvalidOperationException                                          ("constrained only valid on virtual calls to instance methods");                                  var thisType = sig.Parameters[0];                                  var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(methi.Constrained);                                  var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo(methi.Constrained);                                  var cs = methi.Constrained.Style(methEnv);                                  if (cs is ValueTypeStyle)                                  {                                      if (thisType.Style(methEnv) is ManagedPointerTypeStyle)                                      {                                          // We pass the argument pointer as is                                          if (!methi.Constrained.IsAssignableTo(methEnv' thisType.Arguments[0]))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                      else                                      {                                          // *Case 1* Morally we deref the argument pointer and box the contents'                                          // but since no supertype of a value type may mutate the underlying value'                                          // we don't need to take a copy of the value when boxing' so in practice                                          // this is a no-op                                          if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                  }                                  else if (cs is ReferenceTypeStyle)                                  {                                      // *Case 2* We dereference the pointer and pass the object reference                                      if (!methi.Constrained.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else if (cs is ParameterTypeStyle)                                  {                                      // Since we are calling an instance method' we know the first argument cannot be                                      // a "naked" type parameter' but is either a class or an interface.                                      // We must decide between cases 1 and 2 above at runtime' but checking as                                      // per case 1 is sufficient now.                                      // NOTE: As for box/classcast/isinst below' if the parameter is                                      // instantiated to a reference type then the type box type is considered                                      // equivalent to the underyling reference type.                                      if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else                                      throw new InvalidOperationException                                          ("constrained must be value' reference or parameter type");                                    state.PeekExpectedType(sig.Parameters.Count - 1' constrainedPtr' changed);                              }                              else if (sig.Parameters.Count > 0)                                  state.PeekExpectedType(sig.Parameters.Count - 1' sig.Parameters[0]' changed);                              if (sig.Result == null)                                  return state.Pop(sig.Parameters.Count);                              else                                  return state.PopPushType(sig.Parameters.Count' sig.Result' BottomPT);                          }                      case MethodOp.Ldftn:                          {                              // NOTE: Verified CLR allows only the two "blessed" sequences:                              //   dup; ldvirtftn; newobj <delegate ctor>                              //   ldftn; newobj <delegate ctor>                              // It is thus possible to check the delegate will capture an instance which                              // implements the loaded method. However' we don't check that here.                              if (methi.IsVirtual)                              {                                  if (methi.Method.IsStatic)                                      throw new InvalidOperationException("cannot ldvirtftn of a static method");                                  var objectType = default(TypeRef);                                  if (sig.Parameters[0].Style(methEnv) is ManagedPointerTypeStyle)                                      // Object should be a box                                      objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(sig.Parameters[0].Arguments[0]);                                  else                                      // Object should match parameter                                      objectType = sig.Parameters[0];                                  state.PeekExpectedType(0' objectType' changed);                                  return state.PopPushType(1' sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                              else                              {                                  if (methi.Method.IsStatic)                                      return state.PushType(sig.ToCodePointer(methEnv.Global)' BottomPT);                                  else                                      return state.PushType(sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                          }                      case MethodOp.Newobj:                          {                              if (methi.Method.IsStatic || sig.Result != null)                                  throw new InvalidOperationException("not a constructor");                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              // First argument to constructor is created by runtime. If definining type is                              // a value type' first argument will be a pointer' but result left on stack                              // will be the value itself.                              return state.PopPushType(sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);                          }                      case MethodOp.Ldtoken:                          return state.PushType(global.RuntimeMethodHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          state.PeekReadPointerType(0' typei.Type);                          return state.PopPushType(1' typei.Type' BottomPT);                      case TypeOp.Stobj:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Cpobj:                          state.PeekReadPointerType(0' typei.Type);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Newarr:                          state.PeekIndexType(0);                          return state.PopPushType(1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo(typei.Type)' BottomPT);                      case TypeOp.Initobj:                          state.PeekWritePointerType(0' typei.Type);                          return state.Pop(1);                      case TypeOp.Castclass:                      case TypeOp.Isinst:                      case TypeOp.Box:                          {                              var resultType = default(TypeRef);                              var s = typei.Type.Style(methEnv);                              if (s is NullableTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type.Arguments[0]);                              else if (s is ValueTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else if (s is ReferenceTypeStyle)                                  resultType = typei.Type;                              else if (s is ParameterTypeStyle)                                  // NOTE: As for constrained call above' if type parameter is instantitated to                                  // a ref type' then this box type is considered equivalent to the                                  // underlying reference type.                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else                                  throw new InvalidOperationException                                      ("can only box/cast to reference' value or parameter type");                              if (typei.Op == TypeOp.Box)                                  state.PeekExpectedType(0' typei.Type' changed);                              else                                  state.PeekReferenceType(0);                              return state.PopPushType(1' resultType' BottomPT);                          }                      case TypeOp.Unbox:                          if (!(typei.Type.Style(methEnv) is ValueTypeStyle))                              // Parameter types are not allowed                              throw new InvalidOperationException("type must be a value type");                          state.PeekBoxedType(0' typei.Type' changed);                          return state.PopPushType(1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(typei.Type)' HeapPT);                      case TypeOp.UnboxAny:                          {                              var s = typei.Type.Style(methEnv);                              if (s is ValueTypeStyle)                                  state.PeekBoxedType(0' typei.Type' changed);                              else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))                                  throw new InvalidOperationException("type must be value' reference or parameter type");                              return state.PopPushType(1' typei.Type' BottomPT);                          }                      case TypeOp.Ldtoken:                          return state.PushType(global.RuntimeTypeHandleRef' BottomPT);                      case TypeOp.Ldelem:                          state.PeekIndexType(0);                          state.PeekReadArrayType(1' typei.Type' false);                          return state.PopPushType(2' typei.Type' BottomPT);                      case TypeOp.Stelem:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekIndexType(1);                          state.PeekWriteArrayType(2' typei.Type);                          return state.Pop(3);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  {                      var ldelemai = (LdElemAddrInstruction)instruction;                      state.PeekIndexType(0);                      // WARNING: May prematurely fail for non-readonly loads                      state.PeekReadArrayType(1' ldelemai.Type' !ldelemai.IsReadonly);                      return state.PopPushType(2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(ldelemai.Type)' HeapPT);                  }              case InstructionFlavor.LdInt32:                  return state.PushType(global.Int32Ref' BottomPT);              case InstructionFlavor.LdInt64:                  return state.PushType(global.Int64Ref' BottomPT);              case InstructionFlavor.LdSingle:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdDouble:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdString:                  return state.PushType(global.StringRef' BottomPT);              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.Div:                      case ArithOp.Rem:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' true);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.Neg:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' true);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' false);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.BitNot:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.Shl:                      case ArithOp.Shr:                          state.PeekExpectedType(0' global.Int32Ref' changed);                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(1' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(2' arithi.Type' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned &&                                           convi.TargetNumberFlavor == NumberFlavor.Double);                      // NOTE: May capture skolemized types                      convi.SourceType = state.PeekNumberType(0' !mustBeInteger);                      return state.PopPushType(1' TypeRef.NumberFrom(methEnv.Global' convi.TargetNumberFlavor)' BottomPT);                  }              case InstructionFlavor.Try:                  {                      var tryi = (TryInstruction)instruction;                      // Isolation:                      //  - There is no way for the current stack shape to influence or be influenced by                      //    inference of the try' since the current stack shape must be empty.                      //  - There is no way for the try to influence the result stack shape' since it must be                      //    empty.                      //  - However pointers in arguments and locals may propogate into and out of try body                      //    via exceptional transitions. The latter are delt with separately.                      if (state.Depth != 0)                          throw new InvalidOperationException("stack should be empty");                      var newState = ForwardBlock                          (new TryBodyInstructionContext(context' index' tryi.Body)' state' changed);                      for (var j = 0; j < tryi.Handlers.Count; j++)                      {                          var h = tryi.Handlers[j];                          var handlerContext = new TryHandlerInstructionContext(context' index' h.Body' j);                          var initHandlerState = new MachineState                              (methEnv' method.ValueParameters.Count' method.Locals.Count);                          switch (h.Flavor)                          {                          case HandlerFlavor.Catch:                              {                                  var catchh = (CatchTryInstructionHandler)h;                                  ForwardBlock(handlerContext' initHandlerState.PushType(catchh.Type' BottomPT)' changed);                                  break;                              }                          case HandlerFlavor.Filter:                              throw new NotSupportedException("filter handler blocks");                          case HandlerFlavor.Fault:                          case HandlerFlavor.Finally:                              ForwardBlock(handlerContext' initHandlerState' changed);                              break;                          default:                              throw new ArgumentOutOfRangeException();                          }                      }                      return newState;                  }              case InstructionFlavor.IfThenElsePseudo:              case InstructionFlavor.ShortCircuitingPseudo:              case InstructionFlavor.StructuralSwitchPseudo:              case InstructionFlavor.LoopPseudo:              case InstructionFlavor.WhileDoPseudo:              case InstructionFlavor.DoWhilePseudo:              case InstructionFlavor.LoopControlPseudo:                  throw new InvalidOperationException("no machine state inference for psuedo-instructions");              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return state;                      case MiscOp.Dup:                          return state.Push(state.Peek(0));                      case MiscOp.Pop:                          return state.Pop(1);                      case MiscOp.Ldnull:                          return state.PushType(global.NullRef' BottomPT);                      case MiscOp.Ckfinite:                          state.PeekExpectedType(0' global.DoubleRef' changed);                          // Assume the instruction can "peek" at top of stack' thus no need for pop/push.                          return state;                      case MiscOp.Throw:                          state.PeekReferenceType(0);                          return state.DiscardStack();                      case MiscOp.Rethrow:                          return state.DiscardStack();                      case MiscOp.LdindRef:                          {                              var elemType = state.PeekPointerToReferenceType(0);                              return state.PopPushType(1' elemType' BottomPT);                          }                      case MiscOp.StindRef:                          {                              var expElemType = state.PeekPointerToReferenceType(1);                              state.PeekExpectedType(0' expElemType' changed);                              return state.Pop(2);                          }                      case MiscOp.LdelemRef:                          {                              state.PeekIndexType(0);                              // WARNING: Type may not be final                              var elemType = state.PeekArrayOfReferenceType(1);                              return state.PopPushType(2' elemType' BottomPT);                          }                      case MiscOp.StelemRef:                          state.PeekReferenceType(0);                          state.PeekIndexType(1);                          state.PeekArrayOfReferenceType(2);                          // Since the value type and array element type may be independently generalized'                          // it is pointless to check that the first is assignable to the second.                          // Instead this check is done at runtime.                          return state.Pop(3);                      case MiscOp.Ldlen:                          state.PeekArrayOfAnyType(0);                          return state.PopPushType(1' global.IntNativeRef' BottomPT);                      case MiscOp.Ret:                          {                              if (state.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return state; // empty                          }                      case MiscOp.RetVal:                          {                              state.PeekExpectedType(0' method.Result.Type' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfilter:                          {                              state.PeekExpectedType(0' global.Int32Ref' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfinally:                          {                              // Control could transfer to an outer finally/fault block' or to the target                              // of a leave instruction. However these transitions are delt with separately.                              return state.DiscardStack();                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:                  {                      var bri = (BranchInstruction)instruction;                      switch (bri.Op)                      {                      case BranchOp.Br:                          UnifyBeforeState(state' bri.Target' changed);                          return state;                      case BranchOp.Brtrue:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' false);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Brfalse:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Breq:                      case BranchOp.Brne:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' true);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Leave:                          {                              // Control could transfer via finally blocks instead of directly to the leave target.                              // Propogate only that the stack must be empty at target. Remaining machine state                              // is dealt with separately.                              UnifyBeforeState                                  (new MachineState(methEnv' method.ValueParameters.Count' method.Locals.Count)'                                   bri.Target'                                   changed);                              return state.DiscardStack();                          }                      case BranchOp.BrLt:                      case BranchOp.BrLe:                      case BranchOp.BrGt:                      case BranchOp.BrGe:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' false);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Switch:                  {                      var switchi = (SwitchInstruction)instruction;                      state.PeekExpectedType(0' global.Int32Ref' changed);                      var newState = state.Pop(1);                      for (var i = 0; i < switchi.CaseTargets.Count; i++)                          UnifyBeforeState(newState' switchi.CaseTargets[i]' changed);                      return newState;                  }              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      // WARNING: Capured type may not be final                      // NOTE: May capture skolemized types                      switch (cmpi.Op)                      {                      case CompareOp.Ceq:                      case CompareOp.CnePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' true);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.Clt:                      case CompareOp.Cgt:                      case CompareOp.CgePseudo:                      case CompareOp.ClePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' false);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.CtruePseudo:                      case CompareOp.CfalsePseudo:                          cmpi.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                          return state.PopPushType(1' global.Int32Ref' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var argi = (ArgLocalInstruction)instruction;                      var type = method.ArgLocalType(argi.ArgLocal' argi.Index);                      switch (argi.Op)                      {                      case ArgLocalOp.Ld:                          return state.PushType(type' state.ArgLocalPointsTo(argi.ArgLocal' argi.Index));                      case ArgLocalOp.Lda:                          return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(type)' ArgLocalPT(argi.ArgLocal' argi.Index));                      case ArgLocalOp.St:                          {                              state.PeekExpectedType(0' type' changed);                              var pointsTo = state.PeekPointsTo(0);                              if (!pointsTo.IsBottom)                              {                                  if (!(type.Style(methEnv) is ManagedPointerTypeStyle))                                      throw new InvalidOperationException                                          ("stack indicates pointer' but parameter or local type does not");                                  if (pointsTo.PointsOutsideOfHeap)                                      throw new InvalidOperationException("arguments cannot point outside of the heap");                              }                              return state.PopAddArgLocalPointsTo(1' argi.ArgLocal' argi.Index' pointsTo);                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      var fieldEnv = fieldi.Field.Enter(methEnv);                      var fieldType = fieldEnv.SubstituteType(fieldEnv.Field.FieldType);                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                              return state.PushType(fieldType' BottomPT);                          else                          {                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' true' changed);                              return state.PopPushType(1' fieldType' BottomPT);                          }                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                              return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          else                          {                              // Underlying type cannot be a struct' otherwise would have a pointer into                              // the stack                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' false' changed);                              return state.PopPushType                                  (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          }                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                          {                              state.PeekExpectedType(0' fieldType' changed);                              return state.Pop(1);                          }                          else                          {                              state.PeekExpectedType(0' fieldType' changed);                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (1' fieldi.Field.DefiningType' false' changed);                              return state.Pop(2);                          }                      case FieldOp.Ldtoken:                          return state.PushType(global.RuntimeFieldHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methi = (MethodInstruction)instruction;                      var sig = (CST.MethodSignature)methi.Method.ExternalSignature;                      switch (methi.Op)                      {                      case MethodOp.Call:                          {                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              if (methi.Constrained != null)                              {                                  if (!methi.IsVirtual || methi.Method.IsStatic)                                      throw new InvalidOperationException                                          ("constrained only valid on virtual calls to instance methods");                                  var thisType = sig.Parameters[0];                                  var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(methi.Constrained);                                  var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo(methi.Constrained);                                  var cs = methi.Constrained.Style(methEnv);                                  if (cs is ValueTypeStyle)                                  {                                      if (thisType.Style(methEnv) is ManagedPointerTypeStyle)                                      {                                          // We pass the argument pointer as is                                          if (!methi.Constrained.IsAssignableTo(methEnv' thisType.Arguments[0]))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                      else                                      {                                          // *Case 1* Morally we deref the argument pointer and box the contents'                                          // but since no supertype of a value type may mutate the underlying value'                                          // we don't need to take a copy of the value when boxing' so in practice                                          // this is a no-op                                          if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                  }                                  else if (cs is ReferenceTypeStyle)                                  {                                      // *Case 2* We dereference the pointer and pass the object reference                                      if (!methi.Constrained.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else if (cs is ParameterTypeStyle)                                  {                                      // Since we are calling an instance method' we know the first argument cannot be                                      // a "naked" type parameter' but is either a class or an interface.                                      // We must decide between cases 1 and 2 above at runtime' but checking as                                      // per case 1 is sufficient now.                                      // NOTE: As for box/classcast/isinst below' if the parameter is                                      // instantiated to a reference type then the type box type is considered                                      // equivalent to the underyling reference type.                                      if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else                                      throw new InvalidOperationException                                          ("constrained must be value' reference or parameter type");                                    state.PeekExpectedType(sig.Parameters.Count - 1' constrainedPtr' changed);                              }                              else if (sig.Parameters.Count > 0)                                  state.PeekExpectedType(sig.Parameters.Count - 1' sig.Parameters[0]' changed);                              if (sig.Result == null)                                  return state.Pop(sig.Parameters.Count);                              else                                  return state.PopPushType(sig.Parameters.Count' sig.Result' BottomPT);                          }                      case MethodOp.Ldftn:                          {                              // NOTE: Verified CLR allows only the two "blessed" sequences:                              //   dup; ldvirtftn; newobj <delegate ctor>                              //   ldftn; newobj <delegate ctor>                              // It is thus possible to check the delegate will capture an instance which                              // implements the loaded method. However' we don't check that here.                              if (methi.IsVirtual)                              {                                  if (methi.Method.IsStatic)                                      throw new InvalidOperationException("cannot ldvirtftn of a static method");                                  var objectType = default(TypeRef);                                  if (sig.Parameters[0].Style(methEnv) is ManagedPointerTypeStyle)                                      // Object should be a box                                      objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(sig.Parameters[0].Arguments[0]);                                  else                                      // Object should match parameter                                      objectType = sig.Parameters[0];                                  state.PeekExpectedType(0' objectType' changed);                                  return state.PopPushType(1' sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                              else                              {                                  if (methi.Method.IsStatic)                                      return state.PushType(sig.ToCodePointer(methEnv.Global)' BottomPT);                                  else                                      return state.PushType(sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                          }                      case MethodOp.Newobj:                          {                              if (methi.Method.IsStatic || sig.Result != null)                                  throw new InvalidOperationException("not a constructor");                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              // First argument to constructor is created by runtime. If definining type is                              // a value type' first argument will be a pointer' but result left on stack                              // will be the value itself.                              return state.PopPushType(sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);                          }                      case MethodOp.Ldtoken:                          return state.PushType(global.RuntimeMethodHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          state.PeekReadPointerType(0' typei.Type);                          return state.PopPushType(1' typei.Type' BottomPT);                      case TypeOp.Stobj:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Cpobj:                          state.PeekReadPointerType(0' typei.Type);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Newarr:                          state.PeekIndexType(0);                          return state.PopPushType(1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo(typei.Type)' BottomPT);                      case TypeOp.Initobj:                          state.PeekWritePointerType(0' typei.Type);                          return state.Pop(1);                      case TypeOp.Castclass:                      case TypeOp.Isinst:                      case TypeOp.Box:                          {                              var resultType = default(TypeRef);                              var s = typei.Type.Style(methEnv);                              if (s is NullableTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type.Arguments[0]);                              else if (s is ValueTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else if (s is ReferenceTypeStyle)                                  resultType = typei.Type;                              else if (s is ParameterTypeStyle)                                  // NOTE: As for constrained call above' if type parameter is instantitated to                                  // a ref type' then this box type is considered equivalent to the                                  // underlying reference type.                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else                                  throw new InvalidOperationException                                      ("can only box/cast to reference' value or parameter type");                              if (typei.Op == TypeOp.Box)                                  state.PeekExpectedType(0' typei.Type' changed);                              else                                  state.PeekReferenceType(0);                              return state.PopPushType(1' resultType' BottomPT);                          }                      case TypeOp.Unbox:                          if (!(typei.Type.Style(methEnv) is ValueTypeStyle))                              // Parameter types are not allowed                              throw new InvalidOperationException("type must be a value type");                          state.PeekBoxedType(0' typei.Type' changed);                          return state.PopPushType(1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(typei.Type)' HeapPT);                      case TypeOp.UnboxAny:                          {                              var s = typei.Type.Style(methEnv);                              if (s is ValueTypeStyle)                                  state.PeekBoxedType(0' typei.Type' changed);                              else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))                                  throw new InvalidOperationException("type must be value' reference or parameter type");                              return state.PopPushType(1' typei.Type' BottomPT);                          }                      case TypeOp.Ldtoken:                          return state.PushType(global.RuntimeTypeHandleRef' BottomPT);                      case TypeOp.Ldelem:                          state.PeekIndexType(0);                          state.PeekReadArrayType(1' typei.Type' false);                          return state.PopPushType(2' typei.Type' BottomPT);                      case TypeOp.Stelem:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekIndexType(1);                          state.PeekWriteArrayType(2' typei.Type);                          return state.Pop(3);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  {                      var ldelemai = (LdElemAddrInstruction)instruction;                      state.PeekIndexType(0);                      // WARNING: May prematurely fail for non-readonly loads                      state.PeekReadArrayType(1' ldelemai.Type' !ldelemai.IsReadonly);                      return state.PopPushType(2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(ldelemai.Type)' HeapPT);                  }              case InstructionFlavor.LdInt32:                  return state.PushType(global.Int32Ref' BottomPT);              case InstructionFlavor.LdInt64:                  return state.PushType(global.Int64Ref' BottomPT);              case InstructionFlavor.LdSingle:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdDouble:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdString:                  return state.PushType(global.StringRef' BottomPT);              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.Div:                      case ArithOp.Rem:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' true);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.Neg:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' true);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' false);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.BitNot:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.Shl:                      case ArithOp.Shr:                          state.PeekExpectedType(0' global.Int32Ref' changed);                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(1' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(2' arithi.Type' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned &&                                           convi.TargetNumberFlavor == NumberFlavor.Double);                      // NOTE: May capture skolemized types                      convi.SourceType = state.PeekNumberType(0' !mustBeInteger);                      return state.PopPushType(1' TypeRef.NumberFrom(methEnv.Global' convi.TargetNumberFlavor)' BottomPT);                  }              case InstructionFlavor.Try:                  {                      var tryi = (TryInstruction)instruction;                      // Isolation:                      //  - There is no way for the current stack shape to influence or be influenced by                      //    inference of the try' since the current stack shape must be empty.                      //  - There is no way for the try to influence the result stack shape' since it must be                      //    empty.                      //  - However pointers in arguments and locals may propogate into and out of try body                      //    via exceptional transitions. The latter are delt with separately.                      if (state.Depth != 0)                          throw new InvalidOperationException("stack should be empty");                      var newState = ForwardBlock                          (new TryBodyInstructionContext(context' index' tryi.Body)' state' changed);                      for (var j = 0; j < tryi.Handlers.Count; j++)                      {                          var h = tryi.Handlers[j];                          var handlerContext = new TryHandlerInstructionContext(context' index' h.Body' j);                          var initHandlerState = new MachineState                              (methEnv' method.ValueParameters.Count' method.Locals.Count);                          switch (h.Flavor)                          {                          case HandlerFlavor.Catch:                              {                                  var catchh = (CatchTryInstructionHandler)h;                                  ForwardBlock(handlerContext' initHandlerState.PushType(catchh.Type' BottomPT)' changed);                                  break;                              }                          case HandlerFlavor.Filter:                              throw new NotSupportedException("filter handler blocks");                          case HandlerFlavor.Fault:                          case HandlerFlavor.Finally:                              ForwardBlock(handlerContext' initHandlerState' changed);                              break;                          default:                              throw new ArgumentOutOfRangeException();                          }                      }                      return newState;                  }              case InstructionFlavor.IfThenElsePseudo:              case InstructionFlavor.ShortCircuitingPseudo:              case InstructionFlavor.StructuralSwitchPseudo:              case InstructionFlavor.LoopPseudo:              case InstructionFlavor.WhileDoPseudo:              case InstructionFlavor.DoWhilePseudo:              case InstructionFlavor.LoopControlPseudo:                  throw new InvalidOperationException("no machine state inference for psuedo-instructions");              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return state;                      case MiscOp.Dup:                          return state.Push(state.Peek(0));                      case MiscOp.Pop:                          return state.Pop(1);                      case MiscOp.Ldnull:                          return state.PushType(global.NullRef' BottomPT);                      case MiscOp.Ckfinite:                          state.PeekExpectedType(0' global.DoubleRef' changed);                          // Assume the instruction can "peek" at top of stack' thus no need for pop/push.                          return state;                      case MiscOp.Throw:                          state.PeekReferenceType(0);                          return state.DiscardStack();                      case MiscOp.Rethrow:                          return state.DiscardStack();                      case MiscOp.LdindRef:                          {                              var elemType = state.PeekPointerToReferenceType(0);                              return state.PopPushType(1' elemType' BottomPT);                          }                      case MiscOp.StindRef:                          {                              var expElemType = state.PeekPointerToReferenceType(1);                              state.PeekExpectedType(0' expElemType' changed);                              return state.Pop(2);                          }                      case MiscOp.LdelemRef:                          {                              state.PeekIndexType(0);                              // WARNING: Type may not be final                              var elemType = state.PeekArrayOfReferenceType(1);                              return state.PopPushType(2' elemType' BottomPT);                          }                      case MiscOp.StelemRef:                          state.PeekReferenceType(0);                          state.PeekIndexType(1);                          state.PeekArrayOfReferenceType(2);                          // Since the value type and array element type may be independently generalized'                          // it is pointless to check that the first is assignable to the second.                          // Instead this check is done at runtime.                          return state.Pop(3);                      case MiscOp.Ldlen:                          state.PeekArrayOfAnyType(0);                          return state.PopPushType(1' global.IntNativeRef' BottomPT);                      case MiscOp.Ret:                          {                              if (state.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return state; // empty                          }                      case MiscOp.RetVal:                          {                              state.PeekExpectedType(0' method.Result.Type' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfilter:                          {                              state.PeekExpectedType(0' global.Int32Ref' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfinally:                          {                              // Control could transfer to an outer finally/fault block' or to the target                              // of a leave instruction. However these transitions are delt with separately.                              return state.DiscardStack();                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:                  {                      var bri = (BranchInstruction)instruction;                      switch (bri.Op)                      {                      case BranchOp.Br:                          UnifyBeforeState(state' bri.Target' changed);                          return state;                      case BranchOp.Brtrue:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' false);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Brfalse:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Breq:                      case BranchOp.Brne:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' true);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Leave:                          {                              // Control could transfer via finally blocks instead of directly to the leave target.                              // Propogate only that the stack must be empty at target. Remaining machine state                              // is dealt with separately.                              UnifyBeforeState                                  (new MachineState(methEnv' method.ValueParameters.Count' method.Locals.Count)'                                   bri.Target'                                   changed);                              return state.DiscardStack();                          }                      case BranchOp.BrLt:                      case BranchOp.BrLe:                      case BranchOp.BrGt:                      case BranchOp.BrGe:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' false);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Switch:                  {                      var switchi = (SwitchInstruction)instruction;                      state.PeekExpectedType(0' global.Int32Ref' changed);                      var newState = state.Pop(1);                      for (var i = 0; i < switchi.CaseTargets.Count; i++)                          UnifyBeforeState(newState' switchi.CaseTargets[i]' changed);                      return newState;                  }              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      // WARNING: Capured type may not be final                      // NOTE: May capture skolemized types                      switch (cmpi.Op)                      {                      case CompareOp.Ceq:                      case CompareOp.CnePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' true);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.Clt:                      case CompareOp.Cgt:                      case CompareOp.CgePseudo:                      case CompareOp.ClePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' false);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.CtruePseudo:                      case CompareOp.CfalsePseudo:                          cmpi.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                          return state.PopPushType(1' global.Int32Ref' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var argi = (ArgLocalInstruction)instruction;                      var type = method.ArgLocalType(argi.ArgLocal' argi.Index);                      switch (argi.Op)                      {                      case ArgLocalOp.Ld:                          return state.PushType(type' state.ArgLocalPointsTo(argi.ArgLocal' argi.Index));                      case ArgLocalOp.Lda:                          return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(type)' ArgLocalPT(argi.ArgLocal' argi.Index));                      case ArgLocalOp.St:                          {                              state.PeekExpectedType(0' type' changed);                              var pointsTo = state.PeekPointsTo(0);                              if (!pointsTo.IsBottom)                              {                                  if (!(type.Style(methEnv) is ManagedPointerTypeStyle))                                      throw new InvalidOperationException                                          ("stack indicates pointer' but parameter or local type does not");                                  if (pointsTo.PointsOutsideOfHeap)                                      throw new InvalidOperationException("arguments cannot point outside of the heap");                              }                              return state.PopAddArgLocalPointsTo(1' argi.ArgLocal' argi.Index' pointsTo);                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      var fieldEnv = fieldi.Field.Enter(methEnv);                      var fieldType = fieldEnv.SubstituteType(fieldEnv.Field.FieldType);                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                              return state.PushType(fieldType' BottomPT);                          else                          {                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' true' changed);                              return state.PopPushType(1' fieldType' BottomPT);                          }                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                              return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          else                          {                              // Underlying type cannot be a struct' otherwise would have a pointer into                              // the stack                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' false' changed);                              return state.PopPushType                                  (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          }                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                          {                              state.PeekExpectedType(0' fieldType' changed);                              return state.Pop(1);                          }                          else                          {                              state.PeekExpectedType(0' fieldType' changed);                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (1' fieldi.Field.DefiningType' false' changed);                              return state.Pop(2);                          }                      case FieldOp.Ldtoken:                          return state.PushType(global.RuntimeFieldHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methi = (MethodInstruction)instruction;                      var sig = (CST.MethodSignature)methi.Method.ExternalSignature;                      switch (methi.Op)                      {                      case MethodOp.Call:                          {                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              if (methi.Constrained != null)                              {                                  if (!methi.IsVirtual || methi.Method.IsStatic)                                      throw new InvalidOperationException                                          ("constrained only valid on virtual calls to instance methods");                                  var thisType = sig.Parameters[0];                                  var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(methi.Constrained);                                  var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo(methi.Constrained);                                  var cs = methi.Constrained.Style(methEnv);                                  if (cs is ValueTypeStyle)                                  {                                      if (thisType.Style(methEnv) is ManagedPointerTypeStyle)                                      {                                          // We pass the argument pointer as is                                          if (!methi.Constrained.IsAssignableTo(methEnv' thisType.Arguments[0]))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                      else                                      {                                          // *Case 1* Morally we deref the argument pointer and box the contents'                                          // but since no supertype of a value type may mutate the underlying value'                                          // we don't need to take a copy of the value when boxing' so in practice                                          // this is a no-op                                          if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                  }                                  else if (cs is ReferenceTypeStyle)                                  {                                      // *Case 2* We dereference the pointer and pass the object reference                                      if (!methi.Constrained.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else if (cs is ParameterTypeStyle)                                  {                                      // Since we are calling an instance method' we know the first argument cannot be                                      // a "naked" type parameter' but is either a class or an interface.                                      // We must decide between cases 1 and 2 above at runtime' but checking as                                      // per case 1 is sufficient now.                                      // NOTE: As for box/classcast/isinst below' if the parameter is                                      // instantiated to a reference type then the type box type is considered                                      // equivalent to the underyling reference type.                                      if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else                                      throw new InvalidOperationException                                          ("constrained must be value' reference or parameter type");                                    state.PeekExpectedType(sig.Parameters.Count - 1' constrainedPtr' changed);                              }                              else if (sig.Parameters.Count > 0)                                  state.PeekExpectedType(sig.Parameters.Count - 1' sig.Parameters[0]' changed);                              if (sig.Result == null)                                  return state.Pop(sig.Parameters.Count);                              else                                  return state.PopPushType(sig.Parameters.Count' sig.Result' BottomPT);                          }                      case MethodOp.Ldftn:                          {                              // NOTE: Verified CLR allows only the two "blessed" sequences:                              //   dup; ldvirtftn; newobj <delegate ctor>                              //   ldftn; newobj <delegate ctor>                              // It is thus possible to check the delegate will capture an instance which                              // implements the loaded method. However' we don't check that here.                              if (methi.IsVirtual)                              {                                  if (methi.Method.IsStatic)                                      throw new InvalidOperationException("cannot ldvirtftn of a static method");                                  var objectType = default(TypeRef);                                  if (sig.Parameters[0].Style(methEnv) is ManagedPointerTypeStyle)                                      // Object should be a box                                      objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(sig.Parameters[0].Arguments[0]);                                  else                                      // Object should match parameter                                      objectType = sig.Parameters[0];                                  state.PeekExpectedType(0' objectType' changed);                                  return state.PopPushType(1' sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                              else                              {                                  if (methi.Method.IsStatic)                                      return state.PushType(sig.ToCodePointer(methEnv.Global)' BottomPT);                                  else                                      return state.PushType(sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                          }                      case MethodOp.Newobj:                          {                              if (methi.Method.IsStatic || sig.Result != null)                                  throw new InvalidOperationException("not a constructor");                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              // First argument to constructor is created by runtime. If definining type is                              // a value type' first argument will be a pointer' but result left on stack                              // will be the value itself.                              return state.PopPushType(sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);                          }                      case MethodOp.Ldtoken:                          return state.PushType(global.RuntimeMethodHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          state.PeekReadPointerType(0' typei.Type);                          return state.PopPushType(1' typei.Type' BottomPT);                      case TypeOp.Stobj:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Cpobj:                          state.PeekReadPointerType(0' typei.Type);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Newarr:                          state.PeekIndexType(0);                          return state.PopPushType(1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo(typei.Type)' BottomPT);                      case TypeOp.Initobj:                          state.PeekWritePointerType(0' typei.Type);                          return state.Pop(1);                      case TypeOp.Castclass:                      case TypeOp.Isinst:                      case TypeOp.Box:                          {                              var resultType = default(TypeRef);                              var s = typei.Type.Style(methEnv);                              if (s is NullableTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type.Arguments[0]);                              else if (s is ValueTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else if (s is ReferenceTypeStyle)                                  resultType = typei.Type;                              else if (s is ParameterTypeStyle)                                  // NOTE: As for constrained call above' if type parameter is instantitated to                                  // a ref type' then this box type is considered equivalent to the                                  // underlying reference type.                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else                                  throw new InvalidOperationException                                      ("can only box/cast to reference' value or parameter type");                              if (typei.Op == TypeOp.Box)                                  state.PeekExpectedType(0' typei.Type' changed);                              else                                  state.PeekReferenceType(0);                              return state.PopPushType(1' resultType' BottomPT);                          }                      case TypeOp.Unbox:                          if (!(typei.Type.Style(methEnv) is ValueTypeStyle))                              // Parameter types are not allowed                              throw new InvalidOperationException("type must be a value type");                          state.PeekBoxedType(0' typei.Type' changed);                          return state.PopPushType(1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(typei.Type)' HeapPT);                      case TypeOp.UnboxAny:                          {                              var s = typei.Type.Style(methEnv);                              if (s is ValueTypeStyle)                                  state.PeekBoxedType(0' typei.Type' changed);                              else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))                                  throw new InvalidOperationException("type must be value' reference or parameter type");                              return state.PopPushType(1' typei.Type' BottomPT);                          }                      case TypeOp.Ldtoken:                          return state.PushType(global.RuntimeTypeHandleRef' BottomPT);                      case TypeOp.Ldelem:                          state.PeekIndexType(0);                          state.PeekReadArrayType(1' typei.Type' false);                          return state.PopPushType(2' typei.Type' BottomPT);                      case TypeOp.Stelem:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekIndexType(1);                          state.PeekWriteArrayType(2' typei.Type);                          return state.Pop(3);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  {                      var ldelemai = (LdElemAddrInstruction)instruction;                      state.PeekIndexType(0);                      // WARNING: May prematurely fail for non-readonly loads                      state.PeekReadArrayType(1' ldelemai.Type' !ldelemai.IsReadonly);                      return state.PopPushType(2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(ldelemai.Type)' HeapPT);                  }              case InstructionFlavor.LdInt32:                  return state.PushType(global.Int32Ref' BottomPT);              case InstructionFlavor.LdInt64:                  return state.PushType(global.Int64Ref' BottomPT);              case InstructionFlavor.LdSingle:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdDouble:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdString:                  return state.PushType(global.StringRef' BottomPT);              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.Div:                      case ArithOp.Rem:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' true);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.Neg:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' true);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' false);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.BitNot:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.Shl:                      case ArithOp.Shr:                          state.PeekExpectedType(0' global.Int32Ref' changed);                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(1' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(2' arithi.Type' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned &&                                           convi.TargetNumberFlavor == NumberFlavor.Double);                      // NOTE: May capture skolemized types                      convi.SourceType = state.PeekNumberType(0' !mustBeInteger);                      return state.PopPushType(1' TypeRef.NumberFrom(methEnv.Global' convi.TargetNumberFlavor)' BottomPT);                  }              case InstructionFlavor.Try:                  {                      var tryi = (TryInstruction)instruction;                      // Isolation:                      //  - There is no way for the current stack shape to influence or be influenced by                      //    inference of the try' since the current stack shape must be empty.                      //  - There is no way for the try to influence the result stack shape' since it must be                      //    empty.                      //  - However pointers in arguments and locals may propogate into and out of try body                      //    via exceptional transitions. The latter are delt with separately.                      if (state.Depth != 0)                          throw new InvalidOperationException("stack should be empty");                      var newState = ForwardBlock                          (new TryBodyInstructionContext(context' index' tryi.Body)' state' changed);                      for (var j = 0; j < tryi.Handlers.Count; j++)                      {                          var h = tryi.Handlers[j];                          var handlerContext = new TryHandlerInstructionContext(context' index' h.Body' j);                          var initHandlerState = new MachineState                              (methEnv' method.ValueParameters.Count' method.Locals.Count);                          switch (h.Flavor)                          {                          case HandlerFlavor.Catch:                              {                                  var catchh = (CatchTryInstructionHandler)h;                                  ForwardBlock(handlerContext' initHandlerState.PushType(catchh.Type' BottomPT)' changed);                                  break;                              }                          case HandlerFlavor.Filter:                              throw new NotSupportedException("filter handler blocks");                          case HandlerFlavor.Fault:                          case HandlerFlavor.Finally:                              ForwardBlock(handlerContext' initHandlerState' changed);                              break;                          default:                              throw new ArgumentOutOfRangeException();                          }                      }                      return newState;                  }              case InstructionFlavor.IfThenElsePseudo:              case InstructionFlavor.ShortCircuitingPseudo:              case InstructionFlavor.StructuralSwitchPseudo:              case InstructionFlavor.LoopPseudo:              case InstructionFlavor.WhileDoPseudo:              case InstructionFlavor.DoWhilePseudo:              case InstructionFlavor.LoopControlPseudo:                  throw new InvalidOperationException("no machine state inference for psuedo-instructions");              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return state;                      case MiscOp.Dup:                          return state.Push(state.Peek(0));                      case MiscOp.Pop:                          return state.Pop(1);                      case MiscOp.Ldnull:                          return state.PushType(global.NullRef' BottomPT);                      case MiscOp.Ckfinite:                          state.PeekExpectedType(0' global.DoubleRef' changed);                          // Assume the instruction can "peek" at top of stack' thus no need for pop/push.                          return state;                      case MiscOp.Throw:                          state.PeekReferenceType(0);                          return state.DiscardStack();                      case MiscOp.Rethrow:                          return state.DiscardStack();                      case MiscOp.LdindRef:                          {                              var elemType = state.PeekPointerToReferenceType(0);                              return state.PopPushType(1' elemType' BottomPT);                          }                      case MiscOp.StindRef:                          {                              var expElemType = state.PeekPointerToReferenceType(1);                              state.PeekExpectedType(0' expElemType' changed);                              return state.Pop(2);                          }                      case MiscOp.LdelemRef:                          {                              state.PeekIndexType(0);                              // WARNING: Type may not be final                              var elemType = state.PeekArrayOfReferenceType(1);                              return state.PopPushType(2' elemType' BottomPT);                          }                      case MiscOp.StelemRef:                          state.PeekReferenceType(0);                          state.PeekIndexType(1);                          state.PeekArrayOfReferenceType(2);                          // Since the value type and array element type may be independently generalized'                          // it is pointless to check that the first is assignable to the second.                          // Instead this check is done at runtime.                          return state.Pop(3);                      case MiscOp.Ldlen:                          state.PeekArrayOfAnyType(0);                          return state.PopPushType(1' global.IntNativeRef' BottomPT);                      case MiscOp.Ret:                          {                              if (state.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return state; // empty                          }                      case MiscOp.RetVal:                          {                              state.PeekExpectedType(0' method.Result.Type' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfilter:                          {                              state.PeekExpectedType(0' global.Int32Ref' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfinally:                          {                              // Control could transfer to an outer finally/fault block' or to the target                              // of a leave instruction. However these transitions are delt with separately.                              return state.DiscardStack();                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:                  {                      var bri = (BranchInstruction)instruction;                      switch (bri.Op)                      {                      case BranchOp.Br:                          UnifyBeforeState(state' bri.Target' changed);                          return state;                      case BranchOp.Brtrue:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' false);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Brfalse:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Breq:                      case BranchOp.Brne:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' true);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Leave:                          {                              // Control could transfer via finally blocks instead of directly to the leave target.                              // Propogate only that the stack must be empty at target. Remaining machine state                              // is dealt with separately.                              UnifyBeforeState                                  (new MachineState(methEnv' method.ValueParameters.Count' method.Locals.Count)'                                   bri.Target'                                   changed);                              return state.DiscardStack();                          }                      case BranchOp.BrLt:                      case BranchOp.BrLe:                      case BranchOp.BrGt:                      case BranchOp.BrGe:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' false);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Switch:                  {                      var switchi = (SwitchInstruction)instruction;                      state.PeekExpectedType(0' global.Int32Ref' changed);                      var newState = state.Pop(1);                      for (var i = 0; i < switchi.CaseTargets.Count; i++)                          UnifyBeforeState(newState' switchi.CaseTargets[i]' changed);                      return newState;                  }              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      // WARNING: Capured type may not be final                      // NOTE: May capture skolemized types                      switch (cmpi.Op)                      {                      case CompareOp.Ceq:                      case CompareOp.CnePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' true);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.Clt:                      case CompareOp.Cgt:                      case CompareOp.CgePseudo:                      case CompareOp.ClePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' false);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.CtruePseudo:                      case CompareOp.CfalsePseudo:                          cmpi.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                          return state.PopPushType(1' global.Int32Ref' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var argi = (ArgLocalInstruction)instruction;                      var type = method.ArgLocalType(argi.ArgLocal' argi.Index);                      switch (argi.Op)                      {                      case ArgLocalOp.Ld:                          return state.PushType(type' state.ArgLocalPointsTo(argi.ArgLocal' argi.Index));                      case ArgLocalOp.Lda:                          return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(type)' ArgLocalPT(argi.ArgLocal' argi.Index));                      case ArgLocalOp.St:                          {                              state.PeekExpectedType(0' type' changed);                              var pointsTo = state.PeekPointsTo(0);                              if (!pointsTo.IsBottom)                              {                                  if (!(type.Style(methEnv) is ManagedPointerTypeStyle))                                      throw new InvalidOperationException                                          ("stack indicates pointer' but parameter or local type does not");                                  if (pointsTo.PointsOutsideOfHeap)                                      throw new InvalidOperationException("arguments cannot point outside of the heap");                              }                              return state.PopAddArgLocalPointsTo(1' argi.ArgLocal' argi.Index' pointsTo);                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      var fieldEnv = fieldi.Field.Enter(methEnv);                      var fieldType = fieldEnv.SubstituteType(fieldEnv.Field.FieldType);                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                              return state.PushType(fieldType' BottomPT);                          else                          {                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' true' changed);                              return state.PopPushType(1' fieldType' BottomPT);                          }                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                              return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          else                          {                              // Underlying type cannot be a struct' otherwise would have a pointer into                              // the stack                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' false' changed);                              return state.PopPushType                                  (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          }                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                          {                              state.PeekExpectedType(0' fieldType' changed);                              return state.Pop(1);                          }                          else                          {                              state.PeekExpectedType(0' fieldType' changed);                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (1' fieldi.Field.DefiningType' false' changed);                              return state.Pop(2);                          }                      case FieldOp.Ldtoken:                          return state.PushType(global.RuntimeFieldHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methi = (MethodInstruction)instruction;                      var sig = (CST.MethodSignature)methi.Method.ExternalSignature;                      switch (methi.Op)                      {                      case MethodOp.Call:                          {                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              if (methi.Constrained != null)                              {                                  if (!methi.IsVirtual || methi.Method.IsStatic)                                      throw new InvalidOperationException                                          ("constrained only valid on virtual calls to instance methods");                                  var thisType = sig.Parameters[0];                                  var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(methi.Constrained);                                  var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo(methi.Constrained);                                  var cs = methi.Constrained.Style(methEnv);                                  if (cs is ValueTypeStyle)                                  {                                      if (thisType.Style(methEnv) is ManagedPointerTypeStyle)                                      {                                          // We pass the argument pointer as is                                          if (!methi.Constrained.IsAssignableTo(methEnv' thisType.Arguments[0]))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                      else                                      {                                          // *Case 1* Morally we deref the argument pointer and box the contents'                                          // but since no supertype of a value type may mutate the underlying value'                                          // we don't need to take a copy of the value when boxing' so in practice                                          // this is a no-op                                          if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                  }                                  else if (cs is ReferenceTypeStyle)                                  {                                      // *Case 2* We dereference the pointer and pass the object reference                                      if (!methi.Constrained.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else if (cs is ParameterTypeStyle)                                  {                                      // Since we are calling an instance method' we know the first argument cannot be                                      // a "naked" type parameter' but is either a class or an interface.                                      // We must decide between cases 1 and 2 above at runtime' but checking as                                      // per case 1 is sufficient now.                                      // NOTE: As for box/classcast/isinst below' if the parameter is                                      // instantiated to a reference type then the type box type is considered                                      // equivalent to the underyling reference type.                                      if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else                                      throw new InvalidOperationException                                          ("constrained must be value' reference or parameter type");                                    state.PeekExpectedType(sig.Parameters.Count - 1' constrainedPtr' changed);                              }                              else if (sig.Parameters.Count > 0)                                  state.PeekExpectedType(sig.Parameters.Count - 1' sig.Parameters[0]' changed);                              if (sig.Result == null)                                  return state.Pop(sig.Parameters.Count);                              else                                  return state.PopPushType(sig.Parameters.Count' sig.Result' BottomPT);                          }                      case MethodOp.Ldftn:                          {                              // NOTE: Verified CLR allows only the two "blessed" sequences:                              //   dup; ldvirtftn; newobj <delegate ctor>                              //   ldftn; newobj <delegate ctor>                              // It is thus possible to check the delegate will capture an instance which                              // implements the loaded method. However' we don't check that here.                              if (methi.IsVirtual)                              {                                  if (methi.Method.IsStatic)                                      throw new InvalidOperationException("cannot ldvirtftn of a static method");                                  var objectType = default(TypeRef);                                  if (sig.Parameters[0].Style(methEnv) is ManagedPointerTypeStyle)                                      // Object should be a box                                      objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(sig.Parameters[0].Arguments[0]);                                  else                                      // Object should match parameter                                      objectType = sig.Parameters[0];                                  state.PeekExpectedType(0' objectType' changed);                                  return state.PopPushType(1' sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                              else                              {                                  if (methi.Method.IsStatic)                                      return state.PushType(sig.ToCodePointer(methEnv.Global)' BottomPT);                                  else                                      return state.PushType(sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                          }                      case MethodOp.Newobj:                          {                              if (methi.Method.IsStatic || sig.Result != null)                                  throw new InvalidOperationException("not a constructor");                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              // First argument to constructor is created by runtime. If definining type is                              // a value type' first argument will be a pointer' but result left on stack                              // will be the value itself.                              return state.PopPushType(sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);                          }                      case MethodOp.Ldtoken:                          return state.PushType(global.RuntimeMethodHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          state.PeekReadPointerType(0' typei.Type);                          return state.PopPushType(1' typei.Type' BottomPT);                      case TypeOp.Stobj:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Cpobj:                          state.PeekReadPointerType(0' typei.Type);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Newarr:                          state.PeekIndexType(0);                          return state.PopPushType(1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo(typei.Type)' BottomPT);                      case TypeOp.Initobj:                          state.PeekWritePointerType(0' typei.Type);                          return state.Pop(1);                      case TypeOp.Castclass:                      case TypeOp.Isinst:                      case TypeOp.Box:                          {                              var resultType = default(TypeRef);                              var s = typei.Type.Style(methEnv);                              if (s is NullableTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type.Arguments[0]);                              else if (s is ValueTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else if (s is ReferenceTypeStyle)                                  resultType = typei.Type;                              else if (s is ParameterTypeStyle)                                  // NOTE: As for constrained call above' if type parameter is instantitated to                                  // a ref type' then this box type is considered equivalent to the                                  // underlying reference type.                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else                                  throw new InvalidOperationException                                      ("can only box/cast to reference' value or parameter type");                              if (typei.Op == TypeOp.Box)                                  state.PeekExpectedType(0' typei.Type' changed);                              else                                  state.PeekReferenceType(0);                              return state.PopPushType(1' resultType' BottomPT);                          }                      case TypeOp.Unbox:                          if (!(typei.Type.Style(methEnv) is ValueTypeStyle))                              // Parameter types are not allowed                              throw new InvalidOperationException("type must be a value type");                          state.PeekBoxedType(0' typei.Type' changed);                          return state.PopPushType(1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(typei.Type)' HeapPT);                      case TypeOp.UnboxAny:                          {                              var s = typei.Type.Style(methEnv);                              if (s is ValueTypeStyle)                                  state.PeekBoxedType(0' typei.Type' changed);                              else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))                                  throw new InvalidOperationException("type must be value' reference or parameter type");                              return state.PopPushType(1' typei.Type' BottomPT);                          }                      case TypeOp.Ldtoken:                          return state.PushType(global.RuntimeTypeHandleRef' BottomPT);                      case TypeOp.Ldelem:                          state.PeekIndexType(0);                          state.PeekReadArrayType(1' typei.Type' false);                          return state.PopPushType(2' typei.Type' BottomPT);                      case TypeOp.Stelem:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekIndexType(1);                          state.PeekWriteArrayType(2' typei.Type);                          return state.Pop(3);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  {                      var ldelemai = (LdElemAddrInstruction)instruction;                      state.PeekIndexType(0);                      // WARNING: May prematurely fail for non-readonly loads                      state.PeekReadArrayType(1' ldelemai.Type' !ldelemai.IsReadonly);                      return state.PopPushType(2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(ldelemai.Type)' HeapPT);                  }              case InstructionFlavor.LdInt32:                  return state.PushType(global.Int32Ref' BottomPT);              case InstructionFlavor.LdInt64:                  return state.PushType(global.Int64Ref' BottomPT);              case InstructionFlavor.LdSingle:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdDouble:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdString:                  return state.PushType(global.StringRef' BottomPT);              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.Div:                      case ArithOp.Rem:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' true);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.Neg:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' true);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' false);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.BitNot:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.Shl:                      case ArithOp.Shr:                          state.PeekExpectedType(0' global.Int32Ref' changed);                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(1' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(2' arithi.Type' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned &&                                           convi.TargetNumberFlavor == NumberFlavor.Double);                      // NOTE: May capture skolemized types                      convi.SourceType = state.PeekNumberType(0' !mustBeInteger);                      return state.PopPushType(1' TypeRef.NumberFrom(methEnv.Global' convi.TargetNumberFlavor)' BottomPT);                  }              case InstructionFlavor.Try:                  {                      var tryi = (TryInstruction)instruction;                      // Isolation:                      //  - There is no way for the current stack shape to influence or be influenced by                      //    inference of the try' since the current stack shape must be empty.                      //  - There is no way for the try to influence the result stack shape' since it must be                      //    empty.                      //  - However pointers in arguments and locals may propogate into and out of try body                      //    via exceptional transitions. The latter are delt with separately.                      if (state.Depth != 0)                          throw new InvalidOperationException("stack should be empty");                      var newState = ForwardBlock                          (new TryBodyInstructionContext(context' index' tryi.Body)' state' changed);                      for (var j = 0; j < tryi.Handlers.Count; j++)                      {                          var h = tryi.Handlers[j];                          var handlerContext = new TryHandlerInstructionContext(context' index' h.Body' j);                          var initHandlerState = new MachineState                              (methEnv' method.ValueParameters.Count' method.Locals.Count);                          switch (h.Flavor)                          {                          case HandlerFlavor.Catch:                              {                                  var catchh = (CatchTryInstructionHandler)h;                                  ForwardBlock(handlerContext' initHandlerState.PushType(catchh.Type' BottomPT)' changed);                                  break;                              }                          case HandlerFlavor.Filter:                              throw new NotSupportedException("filter handler blocks");                          case HandlerFlavor.Fault:                          case HandlerFlavor.Finally:                              ForwardBlock(handlerContext' initHandlerState' changed);                              break;                          default:                              throw new ArgumentOutOfRangeException();                          }                      }                      return newState;                  }              case InstructionFlavor.IfThenElsePseudo:              case InstructionFlavor.ShortCircuitingPseudo:              case InstructionFlavor.StructuralSwitchPseudo:              case InstructionFlavor.LoopPseudo:              case InstructionFlavor.WhileDoPseudo:              case InstructionFlavor.DoWhilePseudo:              case InstructionFlavor.LoopControlPseudo:                  throw new InvalidOperationException("no machine state inference for psuedo-instructions");              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,SourceTarget,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,GetHashCode,The following statement contains a magic number: var x = (uint)Source.Offset * 27u;
Magic Number,Microsoft.LiveLabs.CST,SourceTarget,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,GetHashCode,The following statement contains a magic number: var y = (uint)Target * 19u;
Magic Number,Microsoft.LiveLabs.CST,SourceTarget,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,GetHashCode,The following statement contains a magic number: return (int)((x << 7) | (x >> 25) ^ y);
Magic Number,Microsoft.LiveLabs.CST,SourceTarget,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,GetHashCode,The following statement contains a magic number: return (int)((x << 7) | (x >> 25) ^ y);
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Name.cs,AssemblyName,The following statement contains a magic number: publicKeyToken = new byte[8];
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Name.cs,AssemblyName,The following statement contains a magic number: i < 8
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Name.cs,AssemblyName,The following statement contains a magic number: publicKeyToken.Length > 8
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Name.cs,GetNum,The following statement contains a magic number: v = v * 10 + (str[i++] - '0');
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Name.cs,GetByte,The following statement contains a magic number: v = v * 16 + (str[i] - '0');
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Name.cs,GetByte,The following statement contains a magic number: i < str.Length && n < 2
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Name.cs,GetByte,The following statement contains a magic number: return n == 2 ? v : -1;
Magic Number,Microsoft.LiveLabs.CST,PELoader,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,ArgsAndResultFromMethodSig,The following statement contains a magic number: name.Equals("Set"' StringComparison.Ordinal) && valParams.Count == 2 + bounds.Rank &&                          valParams[valParams.Count - 1].Equals(definingTypeRef.Arguments[0])
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return true;                      case MiscOp.Dup:                          return stack.Dup(statements);                      case MiscOp.Pop:                          return stack.PopAndDiscard(statements);                      case MiscOp.Ldnull:                          stack.Push(new ExpressionStackEntry(new NullConstantExpression()' BottomE));                          return true;                      case MiscOp.Ckfinite:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.CheckFinite' false' false)' e.Lub(ThrowsE)));                      case MiscOp.Throw:                          if (!stack.DiscardAll(statements' 1))                              return false;                          if (!stack.PopEvalSE(statements' 1' true' ThrowsE' (s' a) => s.Add(new ThrowStatement(a[0]))))                              return false;                          return true;                      case MiscOp.Rethrow:                          if (!stack.DiscardAll(statements' 0))                              return false;                          if (statements == null)                              return Failed(false' "rethrow");                          if (exid == null)                              throw new InvalidOperationException("rethrow outside of catch");                          statements.Add(new RethrowStatement(new VariableCell(exid).Read()));                          return true;                      case MiscOp.LdindRef:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case MiscOp.LdelemRef:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.Ldlen:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.Length' false' false)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.StindRef:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case MiscOp.StelemRef:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add                                   (new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      case MiscOp.Ret:                          if (statements == null)                              return Failed(false' "return");                          statements.Add(new ReturnStatement(null));                          return true;                      case MiscOp.RetVal:                          return stack.PopEvalSE                              (statements' 1' true' BottomE' (s' a) => s.Add(new ReturnStatement(a[0])));                      case MiscOp.Endfilter:                      case MiscOp.Endfinally:                          throw new InvalidOperationException                              ("endfilter/endfinally instructions should have been removed");                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:              case InstructionFlavor.Switch:                  throw new InvalidOperationException("branch/switch instructions should have been removed");              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      if (cmpi.Op == CompareOp.CtruePseudo || cmpi.Op == CompareOp.CfalsePseudo)                      {                          var s = cmpi.Type.Style(compEnv);                          var unop = default(UnaryOp);                          if (s is NumberTypeStyle)                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonZero : UnaryOp.IsZero;                          else                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonNull : UnaryOp.IsNull;                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new UnaryExpression(a[0]' unop' false' cmpi.IsUnsigned)' e));                      }                      else                      {                          var binop = default(BinaryOp);                          switch (cmpi.Op)                          {                          case CompareOp.Ceq:                              binop = BinaryOp.Eq;                              break;                          case CompareOp.Clt:                              binop = BinaryOp.Lt;                              break;                          case CompareOp.Cgt:                              binop = BinaryOp.Gt;                              break;                          case CompareOp.CgePseudo:                              binop = BinaryOp.Ge;                              break;                          case CompareOp.ClePseudo:                              binop = BinaryOp.Le;                              break;                          case CompareOp.CnePseudo:                              binop = BinaryOp.Ne;                              break;                          case CompareOp.CtruePseudo:                          case CompareOp.CfalsePseudo:                              // handled above                              throw new InvalidOperationException();                          default:                              throw new ArgumentOutOfRangeException();                          }                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression(a[0]' binop' a[1]' false' cmpi.IsUnsigned)' e));                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var sli = (ArgLocalInstruction)instruction;                      var id = default(JST.Identifier);                      switch (sli.ArgLocal)                      {                      case ArgLocal.Arg:                          id = compEnv.ValueParameterIds[sli.Index];                          break;                      case ArgLocal.Local:                          id = compEnv.LocalIds[sli.Index];                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      var cell = new VariableCell(id);                      switch (sli.Op)                      {                      case ArgLocalOp.Ld:                          stack.Push                              (new ExpressionStackEntry                                   (cell.Read().CloneIfStruct(compEnv)' ReadArgLocalE(sli.ArgLocal' sli.Index)));                          return true;                      case ArgLocalOp.Lda:                          // Effect will be accounted for on reads/writes                          stack.Push(new ExpressionStackEntry(cell.AddressOf()' BottomE));                          return true;                      case ArgLocalOp.St:                          return stack.PopEvalSE                              (statements'                               1'                               true'                               WriteArgLocalE(sli.ArgLocal' sli.Index)'                               (s' a) => s.Add(new ExpressionStatement(cell.Write(a[0]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                          {                              stack.Push                                  (new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' ReadHeapE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                       {                                           var readEffect = default(Effects);                                           var obj = default(Expression);                                           if (fieldi.IsViaPointer.Value)                                           {                                               readEffect = e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect());                                               obj = new ReadExpression(a[0]); // no need for clone                                           }                                           else if (fieldi.Field.DefiningType.Style(compEnv) is ValueTypeStyle)                                           {                                               readEffect = e;                                               obj = a[0];                                           }                                           else                                           {                                               // Object could be null                                               readEffect = e.Lub(ReadHeapOrThrowE);                                               obj = a[0];                                           }                                           return new ExpressionStackEntry(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' readEffect);                                       });                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                          {                              // Effect will be accounted for on reads/writes                              stack.Push(new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' BottomE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   {                                       if (fieldi.IsViaPointer.Value)                                           // We're just adding an offset to a pointer' so effect will                                           // be accounted for when the final pointer is read/written                                           return new ExpressionStackEntry(new FieldCell(new ReadExpression(a[0])' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e);                                       else                                           // Must be a reference type' and ref could be null                                           return new ExpressionStackEntry(new FieldCell(a[0]' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e.Lub(ThrowsE));                                   });                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                              return stack.PopEvalSE                                  (statements'                                   1'                                   true'                                   WriteHeapE'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Write(a[0]))));                          else                          {                              var writeEffect = fieldi.IsViaPointer.Value                                                    ? instruction.BeforeState.PeekPointsTo(1).WriteEffect()                                                    : WriteHeapOrThrowE;                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   writeEffect'                                   (s' a) =>                                       {                                           var obj = fieldi.IsViaPointer.Value ? new ReadExpression(a[0]) : a[0];                                           s.Add(new ExpressionStatement(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Write(a[1])));                                       });                          }                      case FieldOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new FieldHandleConstantExpression(compEnv.SubstituteMember(fieldi.Field))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methodi = (MethodInstruction)instruction;                      var arity = methodi.Method.ValueParameters.Count;                      switch (methodi.Op)                      {                      case MethodOp.Ldftn:                          if (methodi.IsVirtual)                              // Object could be null                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CodePointerExpression(a[0]' compEnv.SubstituteMember(methodi.Method))' e.Lub(ReadHeapOrThrowE)));                          else                          {                              stack.Push                                  (new ExpressionStackEntry(new CodePointerExpression(null' compEnv.SubstituteMember(methodi.Method))' BottomE));                              return true;                          }                      case MethodOp.Call:                          if (methodi.Method.Result == null)                              return stack.PopEvalSE                                  (statements'                                   arity'                                   true'                                   CalleeEffects(methodi.BeforeState' arity)'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new CallExpression                                                 (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal'                                                  compEnv.SubstituteMember(methodi.Method)'                                                  CallerArguments(methodi.Constrained' methodi.Method' a)))));                          else                              return stack.PopEvalPush                                  (statements'                                   arity'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CallExpression                                            (methodi.IsVirtual? CallFlavor.Virtual : CallFlavor.Normal'                                             compEnv.SubstituteMember(methodi.Method)'                                             CallerArguments(methodi.Constrained' methodi.Method' a))'                                        e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Newobj:                          arity--;                          return stack.PopEvalPush                              (statements'                               arity'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new NewObjectExpression(compEnv.SubstituteMember(methodi.Method)' CallerArguments(null' methodi.Method' a))'                                    e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Ldtoken:                          stack.Push                              (new ExpressionStackEntry(new MethodHandleConstantExpression(compEnv.SubstituteMember(methodi.Method))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case TypeOp.Stobj:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case TypeOp.Cpobj:                          {                              var copyEffect = instruction.BeforeState.PeekPointsTo(0).ReadEffect().Lub                                  (instruction.BeforeState.PeekPointsTo(1).WriteEffect());                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   copyEffect'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new WriteExpression(a[0]' new ReadExpression(a[1]).CloneIfStruct(compEnv)))));                          }                      case TypeOp.Newarr:                          // Growing the heap is not considered an observable change. But will throw if                          // length < 0                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new NewArrayExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Initobj:                          return stack.PopEvalSE                              (statements' 1' true' WriteHeapE' (s' a) => s.Add(new InitializeObjectStatement(a[0])));                      case TypeOp.Castclass:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new CastExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Isinst:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new IsInstExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Box:                          // Growing the heap is not considered an observable change                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new NewBoxExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Unbox:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).AddressOf()' e.Lub(ThrowsE)));                      case TypeOp.UnboxAny:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).Read().CloneIfStruct(compEnv)' e.Lub(ThrowsE)));                      case TypeOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new TypeHandleConstantExpression(compEnv.SubstituteType(typei.Type))' BottomE));                          return true;                      case TypeOp.Ldelem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case TypeOp.Stelem:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add(new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  // Calculating the pointer may throw if index is out of range.                  // Remaining effect will be accounted for when pointer is read/written.                  return stack.PopEvalPush                      (statements'                       2'                       true'                       (a' e) =>                       new ExpressionStackEntry(new ElementCell(a[0]' a[1]' false).AddressOf()' e.Lub(ThrowsE)));              case InstructionFlavor.LdInt32:                  {                      var int32i = (LdInt32Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int32ConstantExpression(int32i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdInt64:                  {                      var int64i = (LdInt64Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int64ConstantExpression(int64i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdSingle:                  {                      var singlei = (LdSingleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new SingleConstantExpression(singlei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdDouble:                  {                      var doublei = (LdDoubleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new DoubleConstantExpression(doublei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdString:                  {                      var stringi = (LdStringInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new StringConstantExpression(stringi.Value)' BottomE));                      return true;                  }              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Div:                      case ArithOp.Rem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(ThrowsE)));                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                      case ArithOp.Shl:                      case ArithOp.Shr:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(arithi.WithOverflow ? ThrowsE : BottomE)));                      case ArithOp.Neg:                      case ArithOp.BitNot:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression                                        (a[0]' ArithOpToUnaryOp(arithi.Op)' arithi.WithOverflow' arithi.IsUnsigned)'                                    e));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      return stack.PopEvalPush                          (statements'                           1'                           true'                           (a' e) =>                           new ExpressionStackEntry                               (new ConvertExpression                                    (a[0]'                                     new NamedTypeRef                                         (compEnv.Global.NumberFlavorToQualifiedTypeName[convi.TargetNumberFlavor])'                                     convi.WithOverflow'                                     convi.IsSourceUnsigned)'                                e.Lub(convi.WithOverflow ? ThrowsE : BottomE)));                  }              case InstructionFlavor.Try:                  {                      if (stack.Depth > 0)                          throw new InvalidOperationException("stack must be empty on entry to try block");                      var tryi = (TryInstruction)instruction;                      var tryStatements = BlockToTryFaultFinallyStatements(tryi.Body);                      if (tryStatements == null)                          return false;                      var handlers = TranslateHandlers(tryi.Handlers);                      if (handlers == null)                          return false;                      if (statements == null)                          return Failed(false' "try");                      statements.Add(new TryStatement(tryStatements' handlers));                      return true;                  }              case InstructionFlavor.IfThenElsePseudo:                  {                      var itei = (IfThenElseInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(itei.Offset' out isExpr) ||                                              isExpr;                        if (!TranslateBlock(statements' itei.Condition' stack' exid))                          return false;                      if (couldBeExpression && itei.Else != null)                      {                          // Pass 1: Try to tranlate to an if-then-else expression. Will only work if Then and Else don't                          //         reach into current stack' push exactly one value' and don't need to emit any                          //         statements along the way.                          var thenEntry = BlockToExpression(itei.Then' exid);                          if (thenEntry != null)                          {                              var elseEntry = BlockToExpression(itei.Else' exid);                              if (elseEntry != null)                              {                                  if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                                      instructionTranslationStyleCache.Add(itei.Offset' true);                                  return stack.PopEvalPush                                      (statements'                                       1'                                       true'                                       (a' e) =>                                       new ExpressionStackEntry                                           (new IfThenElseExpression(a[0]' thenEntry.Expression' elseEntry.Expression)'                                            e.Lub(thenEntry.Effects.Lub(elseEntry.Effects))));                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      var noStackChange = itei.Then.NoStackChange && (itei.Else == null || itei.Else.NoStackChange);                      var condEntry = noStackChange                                          ? stack.Pop()                                          : stack.FlushAndPopPostState(statements' itei.Then.BeforeState);                      if (condEntry == null)                          return false;                      var thenStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Then' exid)                                           : BlockToStatements(itei.Then' exid);                      if (thenStmnts == null)                          return false;                      var elseStmnts = default(Seq<Statement>);                      if (itei.Else != null)                      {                          elseStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Else' exid)                                           : BlockToStatements(itei.Else' exid);                          if (elseStmnts == null)                              return false;                      }                      if (statements == null)                          return Failed(false' "if-then-else");                      statements.Add                          (new IfThenElseStatement(condEntry.Expression' new Statements(thenStmnts)' elseStmnts == null ? null : new Statements(elseStmnts)));                      if (!noStackChange && !stack.Restore(itei.AfterState' 0))                          return false;                      if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                          instructionTranslationStyleCache.Add(itei.Offset' false);                      return true;                  }              case InstructionFlavor.ShortCircuitingPseudo:                  {                      var sci = (ShortCircuitingInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(sci.Offset' out isExpr) ||                                              isExpr;                      if (couldBeExpression)                      {                          // Pass 1: Try to translate to an expression.                          var leftEntry = BlockToExpression(sci.Left' exid);                          if (leftEntry != null)                          {                              var rightEntry = BlockToExpression(sci.Right' exid);                              if (rightEntry != null)                              {                                  stack.Push                                      (new ExpressionStackEntry                                           (new BinaryExpression                                                (leftEntry.Expression'                                                 ShortCircuitingOpToBinaryOp(sci.Op)'                                                 rightEntry.Expression'                                                 false'                                                 false)'                                            leftEntry.Effects.Lub(rightEntry.Effects)));                                  if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                                      instructionTranslationStyleCache.Add(sci.Offset' true);                                  return true;                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      if (!TranslateBlock(statements' sci.Left' stack' exid))                          return false;                      var leftEntry2 = stack.FlushAndPopPostState(statements' sci.Right.BeforeState);                      if (leftEntry2 == null)                          return false;                      var rightStatements = BlockToStatements(sci.Right' exid);                      if (rightStatements == null)                          return false;                      var id = sci.Right.AfterState.PeekId(0' nameSupply.GenSym);                      var cell = new VariableCell(id);                      compEnv.AddVariable(id' ArgLocal.Local' false' true' compEnv.SubstituteType(sci.Right.AfterState.PeekType(0)));                      if (statements == null)                          return Failed(false' "short-circuit");                      switch (sci.Op)                      {                      case ShortCircuitingOp.And:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements(rightStatements)'                                    new Statements                                        (new ExpressionStatement(cell.Write(new Int32ConstantExpression(0))))));                          break;                      case ShortCircuitingOp.Or:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements                                        (new ExpressionStatement                                             (cell.Write(new Int32ConstantExpression(1))))'                                    new Statements(rightStatements)));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      if (!stack.Restore(sci.AfterState' 1))                          return false;                      stack.Push(new ExpressionStackEntry(cell.Read()' BottomE));                      if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                          instructionTranslationStyleCache.Add(sci.Offset' false);                      return true;                  }              case InstructionFlavor.StructuralSwitchPseudo:                  {                      var ssi = (StructuralSwitchInstruction)instruction;                      if (!TranslateBlock(statements' ssi.Body' stack' exid))                          return false;                      var valueEntry = stack.FlushAndPopPreState(statements' ssi.Body.AfterState);                      if (valueEntry == null)                          return false;                      var cases = new Seq<SwitchStatementCase>();                      foreach (var c in ssi.Cases)                      {                          var caseStatements = BlockToStatements(c.Body' exid);                          if (caseStatements == null)                              return false;                          cases.Add(new SwitchStatementCase(c.Values' new Statements(caseStatements)));                      }                      if (statements == null)                          return Failed(false' "structural switch");                      statements.Add(new SwitchStatement(valueEntry.Expression' cases));                      if (!stack.Restore(ssi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopPseudo:                  {                      var li = (LoopInstruction)instruction;                      if (!stack.Flush(statements' li.Body.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop");                      var whileStatements = BlockToStatements(li.Body' exid);                      statements.Add                          (new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(whileStatements)));                      if (!stack.Restore(li.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.WhileDoPseudo:                  {                      var wdi = (WhileDoInstruction)instruction;                      if (!stack.Flush(statements' wdi.Condition.BeforeState))                          return false;                      var condEntry = BlockToExpression(wdi.Condition' exid);                      if (condEntry == null)                      {                          var stack1 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Condition.BeforeState' trace);                          var preCondStatements = new Seq<Statement>();                          if (!TranslateBlock(preCondStatements' wdi.Condition' stack1' exid))                              return false;                          condEntry = stack1.FlushAndPopPostState(preCondStatements' wdi.Body.BeforeState);                          if (condEntry == null)                              return false;                          var stack2 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Body.BeforeState' trace);                          var postCondStatements = new Seq<Statement>();                          if (!TranslateBlock(postCondStatements' wdi.Body' stack2' exid))                              return false;                          if (!stack2.Flush(postCondStatements' wdi.Body.AfterState))                              return false;                          preCondStatements.Add                              (new IfThenElseStatement                                   (condEntry.Expression'                                    new Statements(postCondStatements)'                                    new Statements(new BreakStatement())));                          statements.Add(new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(preCondStatements)));                      }                      else                      {                          var loopStatements = BlockToStatements(wdi.Body' exid);                          if (loopStatements == null)                              return false;                          if (statements == null)                              return Failed(false' "while-do");                          statements.Add(new WhileDoStatement(condEntry.Expression' new Statements(loopStatements)));                      }                      if (!stack.Restore(wdi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.DoWhilePseudo:                  {                      var dwi = (DoWhileInstruction)instruction;                      if (!stack.Flush(statements' dwi.Body.BeforeState))                          return false;                      var combined = new Seq<Instruction>();                      foreach (var i in dwi.Body.Body)                          combined.Add(i);                      foreach (var i in dwi.Condition.Body)                          combined.Add(i);                      var condEntry = default(ExpressionStackEntry);                      var loopStatements = BlockToConditionStatements                          (new Instructions(null' combined)' dwi.Body.BeforeState' exid' out condEntry);                      if (loopStatements == null)                          return false;                      if (statements == null)                          return Failed(false' "do-while");                      statements.Add(new DoWhileStatement(new Statements(loopStatements)' condEntry.Expression));                      if (!stack.Restore(dwi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopControlPseudo:                  {                      var lci = (BreakContinueInstruction)instruction;                      if (!stack.Flush(statements' lci.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop-control");                      var targetState = default(int);                      switch (lci.Op)                      {                      case BreakContinueOp.Break:                          if (labelToLoopCandidateBreakState != null &&                              labelToLoopCandidateBreakState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new BreakStatement(lci.Label));                          break;                      case BreakContinueOp.Continue:                          if (labelToLoopCandidateContinueState != null &&                              labelToLoopCandidateContinueState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new ContinueStatement(lci.Label));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      return true;                  }              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return true;                      case MiscOp.Dup:                          return stack.Dup(statements);                      case MiscOp.Pop:                          return stack.PopAndDiscard(statements);                      case MiscOp.Ldnull:                          stack.Push(new ExpressionStackEntry(new NullConstantExpression()' BottomE));                          return true;                      case MiscOp.Ckfinite:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.CheckFinite' false' false)' e.Lub(ThrowsE)));                      case MiscOp.Throw:                          if (!stack.DiscardAll(statements' 1))                              return false;                          if (!stack.PopEvalSE(statements' 1' true' ThrowsE' (s' a) => s.Add(new ThrowStatement(a[0]))))                              return false;                          return true;                      case MiscOp.Rethrow:                          if (!stack.DiscardAll(statements' 0))                              return false;                          if (statements == null)                              return Failed(false' "rethrow");                          if (exid == null)                              throw new InvalidOperationException("rethrow outside of catch");                          statements.Add(new RethrowStatement(new VariableCell(exid).Read()));                          return true;                      case MiscOp.LdindRef:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case MiscOp.LdelemRef:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.Ldlen:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.Length' false' false)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.StindRef:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case MiscOp.StelemRef:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add                                   (new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      case MiscOp.Ret:                          if (statements == null)                              return Failed(false' "return");                          statements.Add(new ReturnStatement(null));                          return true;                      case MiscOp.RetVal:                          return stack.PopEvalSE                              (statements' 1' true' BottomE' (s' a) => s.Add(new ReturnStatement(a[0])));                      case MiscOp.Endfilter:                      case MiscOp.Endfinally:                          throw new InvalidOperationException                              ("endfilter/endfinally instructions should have been removed");                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:              case InstructionFlavor.Switch:                  throw new InvalidOperationException("branch/switch instructions should have been removed");              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      if (cmpi.Op == CompareOp.CtruePseudo || cmpi.Op == CompareOp.CfalsePseudo)                      {                          var s = cmpi.Type.Style(compEnv);                          var unop = default(UnaryOp);                          if (s is NumberTypeStyle)                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonZero : UnaryOp.IsZero;                          else                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonNull : UnaryOp.IsNull;                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new UnaryExpression(a[0]' unop' false' cmpi.IsUnsigned)' e));                      }                      else                      {                          var binop = default(BinaryOp);                          switch (cmpi.Op)                          {                          case CompareOp.Ceq:                              binop = BinaryOp.Eq;                              break;                          case CompareOp.Clt:                              binop = BinaryOp.Lt;                              break;                          case CompareOp.Cgt:                              binop = BinaryOp.Gt;                              break;                          case CompareOp.CgePseudo:                              binop = BinaryOp.Ge;                              break;                          case CompareOp.ClePseudo:                              binop = BinaryOp.Le;                              break;                          case CompareOp.CnePseudo:                              binop = BinaryOp.Ne;                              break;                          case CompareOp.CtruePseudo:                          case CompareOp.CfalsePseudo:                              // handled above                              throw new InvalidOperationException();                          default:                              throw new ArgumentOutOfRangeException();                          }                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression(a[0]' binop' a[1]' false' cmpi.IsUnsigned)' e));                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var sli = (ArgLocalInstruction)instruction;                      var id = default(JST.Identifier);                      switch (sli.ArgLocal)                      {                      case ArgLocal.Arg:                          id = compEnv.ValueParameterIds[sli.Index];                          break;                      case ArgLocal.Local:                          id = compEnv.LocalIds[sli.Index];                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      var cell = new VariableCell(id);                      switch (sli.Op)                      {                      case ArgLocalOp.Ld:                          stack.Push                              (new ExpressionStackEntry                                   (cell.Read().CloneIfStruct(compEnv)' ReadArgLocalE(sli.ArgLocal' sli.Index)));                          return true;                      case ArgLocalOp.Lda:                          // Effect will be accounted for on reads/writes                          stack.Push(new ExpressionStackEntry(cell.AddressOf()' BottomE));                          return true;                      case ArgLocalOp.St:                          return stack.PopEvalSE                              (statements'                               1'                               true'                               WriteArgLocalE(sli.ArgLocal' sli.Index)'                               (s' a) => s.Add(new ExpressionStatement(cell.Write(a[0]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                          {                              stack.Push                                  (new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' ReadHeapE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                       {                                           var readEffect = default(Effects);                                           var obj = default(Expression);                                           if (fieldi.IsViaPointer.Value)                                           {                                               readEffect = e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect());                                               obj = new ReadExpression(a[0]); // no need for clone                                           }                                           else if (fieldi.Field.DefiningType.Style(compEnv) is ValueTypeStyle)                                           {                                               readEffect = e;                                               obj = a[0];                                           }                                           else                                           {                                               // Object could be null                                               readEffect = e.Lub(ReadHeapOrThrowE);                                               obj = a[0];                                           }                                           return new ExpressionStackEntry(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' readEffect);                                       });                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                          {                              // Effect will be accounted for on reads/writes                              stack.Push(new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' BottomE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   {                                       if (fieldi.IsViaPointer.Value)                                           // We're just adding an offset to a pointer' so effect will                                           // be accounted for when the final pointer is read/written                                           return new ExpressionStackEntry(new FieldCell(new ReadExpression(a[0])' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e);                                       else                                           // Must be a reference type' and ref could be null                                           return new ExpressionStackEntry(new FieldCell(a[0]' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e.Lub(ThrowsE));                                   });                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                              return stack.PopEvalSE                                  (statements'                                   1'                                   true'                                   WriteHeapE'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Write(a[0]))));                          else                          {                              var writeEffect = fieldi.IsViaPointer.Value                                                    ? instruction.BeforeState.PeekPointsTo(1).WriteEffect()                                                    : WriteHeapOrThrowE;                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   writeEffect'                                   (s' a) =>                                       {                                           var obj = fieldi.IsViaPointer.Value ? new ReadExpression(a[0]) : a[0];                                           s.Add(new ExpressionStatement(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Write(a[1])));                                       });                          }                      case FieldOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new FieldHandleConstantExpression(compEnv.SubstituteMember(fieldi.Field))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methodi = (MethodInstruction)instruction;                      var arity = methodi.Method.ValueParameters.Count;                      switch (methodi.Op)                      {                      case MethodOp.Ldftn:                          if (methodi.IsVirtual)                              // Object could be null                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CodePointerExpression(a[0]' compEnv.SubstituteMember(methodi.Method))' e.Lub(ReadHeapOrThrowE)));                          else                          {                              stack.Push                                  (new ExpressionStackEntry(new CodePointerExpression(null' compEnv.SubstituteMember(methodi.Method))' BottomE));                              return true;                          }                      case MethodOp.Call:                          if (methodi.Method.Result == null)                              return stack.PopEvalSE                                  (statements'                                   arity'                                   true'                                   CalleeEffects(methodi.BeforeState' arity)'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new CallExpression                                                 (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal'                                                  compEnv.SubstituteMember(methodi.Method)'                                                  CallerArguments(methodi.Constrained' methodi.Method' a)))));                          else                              return stack.PopEvalPush                                  (statements'                                   arity'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CallExpression                                            (methodi.IsVirtual? CallFlavor.Virtual : CallFlavor.Normal'                                             compEnv.SubstituteMember(methodi.Method)'                                             CallerArguments(methodi.Constrained' methodi.Method' a))'                                        e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Newobj:                          arity--;                          return stack.PopEvalPush                              (statements'                               arity'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new NewObjectExpression(compEnv.SubstituteMember(methodi.Method)' CallerArguments(null' methodi.Method' a))'                                    e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Ldtoken:                          stack.Push                              (new ExpressionStackEntry(new MethodHandleConstantExpression(compEnv.SubstituteMember(methodi.Method))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case TypeOp.Stobj:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case TypeOp.Cpobj:                          {                              var copyEffect = instruction.BeforeState.PeekPointsTo(0).ReadEffect().Lub                                  (instruction.BeforeState.PeekPointsTo(1).WriteEffect());                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   copyEffect'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new WriteExpression(a[0]' new ReadExpression(a[1]).CloneIfStruct(compEnv)))));                          }                      case TypeOp.Newarr:                          // Growing the heap is not considered an observable change. But will throw if                          // length < 0                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new NewArrayExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Initobj:                          return stack.PopEvalSE                              (statements' 1' true' WriteHeapE' (s' a) => s.Add(new InitializeObjectStatement(a[0])));                      case TypeOp.Castclass:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new CastExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Isinst:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new IsInstExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Box:                          // Growing the heap is not considered an observable change                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new NewBoxExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Unbox:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).AddressOf()' e.Lub(ThrowsE)));                      case TypeOp.UnboxAny:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).Read().CloneIfStruct(compEnv)' e.Lub(ThrowsE)));                      case TypeOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new TypeHandleConstantExpression(compEnv.SubstituteType(typei.Type))' BottomE));                          return true;                      case TypeOp.Ldelem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case TypeOp.Stelem:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add(new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  // Calculating the pointer may throw if index is out of range.                  // Remaining effect will be accounted for when pointer is read/written.                  return stack.PopEvalPush                      (statements'                       2'                       true'                       (a' e) =>                       new ExpressionStackEntry(new ElementCell(a[0]' a[1]' false).AddressOf()' e.Lub(ThrowsE)));              case InstructionFlavor.LdInt32:                  {                      var int32i = (LdInt32Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int32ConstantExpression(int32i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdInt64:                  {                      var int64i = (LdInt64Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int64ConstantExpression(int64i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdSingle:                  {                      var singlei = (LdSingleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new SingleConstantExpression(singlei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdDouble:                  {                      var doublei = (LdDoubleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new DoubleConstantExpression(doublei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdString:                  {                      var stringi = (LdStringInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new StringConstantExpression(stringi.Value)' BottomE));                      return true;                  }              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Div:                      case ArithOp.Rem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(ThrowsE)));                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                      case ArithOp.Shl:                      case ArithOp.Shr:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(arithi.WithOverflow ? ThrowsE : BottomE)));                      case ArithOp.Neg:                      case ArithOp.BitNot:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression                                        (a[0]' ArithOpToUnaryOp(arithi.Op)' arithi.WithOverflow' arithi.IsUnsigned)'                                    e));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      return stack.PopEvalPush                          (statements'                           1'                           true'                           (a' e) =>                           new ExpressionStackEntry                               (new ConvertExpression                                    (a[0]'                                     new NamedTypeRef                                         (compEnv.Global.NumberFlavorToQualifiedTypeName[convi.TargetNumberFlavor])'                                     convi.WithOverflow'                                     convi.IsSourceUnsigned)'                                e.Lub(convi.WithOverflow ? ThrowsE : BottomE)));                  }              case InstructionFlavor.Try:                  {                      if (stack.Depth > 0)                          throw new InvalidOperationException("stack must be empty on entry to try block");                      var tryi = (TryInstruction)instruction;                      var tryStatements = BlockToTryFaultFinallyStatements(tryi.Body);                      if (tryStatements == null)                          return false;                      var handlers = TranslateHandlers(tryi.Handlers);                      if (handlers == null)                          return false;                      if (statements == null)                          return Failed(false' "try");                      statements.Add(new TryStatement(tryStatements' handlers));                      return true;                  }              case InstructionFlavor.IfThenElsePseudo:                  {                      var itei = (IfThenElseInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(itei.Offset' out isExpr) ||                                              isExpr;                        if (!TranslateBlock(statements' itei.Condition' stack' exid))                          return false;                      if (couldBeExpression && itei.Else != null)                      {                          // Pass 1: Try to tranlate to an if-then-else expression. Will only work if Then and Else don't                          //         reach into current stack' push exactly one value' and don't need to emit any                          //         statements along the way.                          var thenEntry = BlockToExpression(itei.Then' exid);                          if (thenEntry != null)                          {                              var elseEntry = BlockToExpression(itei.Else' exid);                              if (elseEntry != null)                              {                                  if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                                      instructionTranslationStyleCache.Add(itei.Offset' true);                                  return stack.PopEvalPush                                      (statements'                                       1'                                       true'                                       (a' e) =>                                       new ExpressionStackEntry                                           (new IfThenElseExpression(a[0]' thenEntry.Expression' elseEntry.Expression)'                                            e.Lub(thenEntry.Effects.Lub(elseEntry.Effects))));                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      var noStackChange = itei.Then.NoStackChange && (itei.Else == null || itei.Else.NoStackChange);                      var condEntry = noStackChange                                          ? stack.Pop()                                          : stack.FlushAndPopPostState(statements' itei.Then.BeforeState);                      if (condEntry == null)                          return false;                      var thenStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Then' exid)                                           : BlockToStatements(itei.Then' exid);                      if (thenStmnts == null)                          return false;                      var elseStmnts = default(Seq<Statement>);                      if (itei.Else != null)                      {                          elseStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Else' exid)                                           : BlockToStatements(itei.Else' exid);                          if (elseStmnts == null)                              return false;                      }                      if (statements == null)                          return Failed(false' "if-then-else");                      statements.Add                          (new IfThenElseStatement(condEntry.Expression' new Statements(thenStmnts)' elseStmnts == null ? null : new Statements(elseStmnts)));                      if (!noStackChange && !stack.Restore(itei.AfterState' 0))                          return false;                      if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                          instructionTranslationStyleCache.Add(itei.Offset' false);                      return true;                  }              case InstructionFlavor.ShortCircuitingPseudo:                  {                      var sci = (ShortCircuitingInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(sci.Offset' out isExpr) ||                                              isExpr;                      if (couldBeExpression)                      {                          // Pass 1: Try to translate to an expression.                          var leftEntry = BlockToExpression(sci.Left' exid);                          if (leftEntry != null)                          {                              var rightEntry = BlockToExpression(sci.Right' exid);                              if (rightEntry != null)                              {                                  stack.Push                                      (new ExpressionStackEntry                                           (new BinaryExpression                                                (leftEntry.Expression'                                                 ShortCircuitingOpToBinaryOp(sci.Op)'                                                 rightEntry.Expression'                                                 false'                                                 false)'                                            leftEntry.Effects.Lub(rightEntry.Effects)));                                  if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                                      instructionTranslationStyleCache.Add(sci.Offset' true);                                  return true;                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      if (!TranslateBlock(statements' sci.Left' stack' exid))                          return false;                      var leftEntry2 = stack.FlushAndPopPostState(statements' sci.Right.BeforeState);                      if (leftEntry2 == null)                          return false;                      var rightStatements = BlockToStatements(sci.Right' exid);                      if (rightStatements == null)                          return false;                      var id = sci.Right.AfterState.PeekId(0' nameSupply.GenSym);                      var cell = new VariableCell(id);                      compEnv.AddVariable(id' ArgLocal.Local' false' true' compEnv.SubstituteType(sci.Right.AfterState.PeekType(0)));                      if (statements == null)                          return Failed(false' "short-circuit");                      switch (sci.Op)                      {                      case ShortCircuitingOp.And:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements(rightStatements)'                                    new Statements                                        (new ExpressionStatement(cell.Write(new Int32ConstantExpression(0))))));                          break;                      case ShortCircuitingOp.Or:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements                                        (new ExpressionStatement                                             (cell.Write(new Int32ConstantExpression(1))))'                                    new Statements(rightStatements)));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      if (!stack.Restore(sci.AfterState' 1))                          return false;                      stack.Push(new ExpressionStackEntry(cell.Read()' BottomE));                      if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                          instructionTranslationStyleCache.Add(sci.Offset' false);                      return true;                  }              case InstructionFlavor.StructuralSwitchPseudo:                  {                      var ssi = (StructuralSwitchInstruction)instruction;                      if (!TranslateBlock(statements' ssi.Body' stack' exid))                          return false;                      var valueEntry = stack.FlushAndPopPreState(statements' ssi.Body.AfterState);                      if (valueEntry == null)                          return false;                      var cases = new Seq<SwitchStatementCase>();                      foreach (var c in ssi.Cases)                      {                          var caseStatements = BlockToStatements(c.Body' exid);                          if (caseStatements == null)                              return false;                          cases.Add(new SwitchStatementCase(c.Values' new Statements(caseStatements)));                      }                      if (statements == null)                          return Failed(false' "structural switch");                      statements.Add(new SwitchStatement(valueEntry.Expression' cases));                      if (!stack.Restore(ssi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopPseudo:                  {                      var li = (LoopInstruction)instruction;                      if (!stack.Flush(statements' li.Body.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop");                      var whileStatements = BlockToStatements(li.Body' exid);                      statements.Add                          (new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(whileStatements)));                      if (!stack.Restore(li.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.WhileDoPseudo:                  {                      var wdi = (WhileDoInstruction)instruction;                      if (!stack.Flush(statements' wdi.Condition.BeforeState))                          return false;                      var condEntry = BlockToExpression(wdi.Condition' exid);                      if (condEntry == null)                      {                          var stack1 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Condition.BeforeState' trace);                          var preCondStatements = new Seq<Statement>();                          if (!TranslateBlock(preCondStatements' wdi.Condition' stack1' exid))                              return false;                          condEntry = stack1.FlushAndPopPostState(preCondStatements' wdi.Body.BeforeState);                          if (condEntry == null)                              return false;                          var stack2 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Body.BeforeState' trace);                          var postCondStatements = new Seq<Statement>();                          if (!TranslateBlock(postCondStatements' wdi.Body' stack2' exid))                              return false;                          if (!stack2.Flush(postCondStatements' wdi.Body.AfterState))                              return false;                          preCondStatements.Add                              (new IfThenElseStatement                                   (condEntry.Expression'                                    new Statements(postCondStatements)'                                    new Statements(new BreakStatement())));                          statements.Add(new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(preCondStatements)));                      }                      else                      {                          var loopStatements = BlockToStatements(wdi.Body' exid);                          if (loopStatements == null)                              return false;                          if (statements == null)                              return Failed(false' "while-do");                          statements.Add(new WhileDoStatement(condEntry.Expression' new Statements(loopStatements)));                      }                      if (!stack.Restore(wdi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.DoWhilePseudo:                  {                      var dwi = (DoWhileInstruction)instruction;                      if (!stack.Flush(statements' dwi.Body.BeforeState))                          return false;                      var combined = new Seq<Instruction>();                      foreach (var i in dwi.Body.Body)                          combined.Add(i);                      foreach (var i in dwi.Condition.Body)                          combined.Add(i);                      var condEntry = default(ExpressionStackEntry);                      var loopStatements = BlockToConditionStatements                          (new Instructions(null' combined)' dwi.Body.BeforeState' exid' out condEntry);                      if (loopStatements == null)                          return false;                      if (statements == null)                          return Failed(false' "do-while");                      statements.Add(new DoWhileStatement(new Statements(loopStatements)' condEntry.Expression));                      if (!stack.Restore(dwi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopControlPseudo:                  {                      var lci = (BreakContinueInstruction)instruction;                      if (!stack.Flush(statements' lci.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop-control");                      var targetState = default(int);                      switch (lci.Op)                      {                      case BreakContinueOp.Break:                          if (labelToLoopCandidateBreakState != null &&                              labelToLoopCandidateBreakState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new BreakStatement(lci.Label));                          break;                      case BreakContinueOp.Continue:                          if (labelToLoopCandidateContinueState != null &&                              labelToLoopCandidateContinueState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new ContinueStatement(lci.Label));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      return true;                  }              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return true;                      case MiscOp.Dup:                          return stack.Dup(statements);                      case MiscOp.Pop:                          return stack.PopAndDiscard(statements);                      case MiscOp.Ldnull:                          stack.Push(new ExpressionStackEntry(new NullConstantExpression()' BottomE));                          return true;                      case MiscOp.Ckfinite:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.CheckFinite' false' false)' e.Lub(ThrowsE)));                      case MiscOp.Throw:                          if (!stack.DiscardAll(statements' 1))                              return false;                          if (!stack.PopEvalSE(statements' 1' true' ThrowsE' (s' a) => s.Add(new ThrowStatement(a[0]))))                              return false;                          return true;                      case MiscOp.Rethrow:                          if (!stack.DiscardAll(statements' 0))                              return false;                          if (statements == null)                              return Failed(false' "rethrow");                          if (exid == null)                              throw new InvalidOperationException("rethrow outside of catch");                          statements.Add(new RethrowStatement(new VariableCell(exid).Read()));                          return true;                      case MiscOp.LdindRef:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case MiscOp.LdelemRef:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.Ldlen:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.Length' false' false)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.StindRef:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case MiscOp.StelemRef:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add                                   (new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      case MiscOp.Ret:                          if (statements == null)                              return Failed(false' "return");                          statements.Add(new ReturnStatement(null));                          return true;                      case MiscOp.RetVal:                          return stack.PopEvalSE                              (statements' 1' true' BottomE' (s' a) => s.Add(new ReturnStatement(a[0])));                      case MiscOp.Endfilter:                      case MiscOp.Endfinally:                          throw new InvalidOperationException                              ("endfilter/endfinally instructions should have been removed");                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:              case InstructionFlavor.Switch:                  throw new InvalidOperationException("branch/switch instructions should have been removed");              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      if (cmpi.Op == CompareOp.CtruePseudo || cmpi.Op == CompareOp.CfalsePseudo)                      {                          var s = cmpi.Type.Style(compEnv);                          var unop = default(UnaryOp);                          if (s is NumberTypeStyle)                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonZero : UnaryOp.IsZero;                          else                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonNull : UnaryOp.IsNull;                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new UnaryExpression(a[0]' unop' false' cmpi.IsUnsigned)' e));                      }                      else                      {                          var binop = default(BinaryOp);                          switch (cmpi.Op)                          {                          case CompareOp.Ceq:                              binop = BinaryOp.Eq;                              break;                          case CompareOp.Clt:                              binop = BinaryOp.Lt;                              break;                          case CompareOp.Cgt:                              binop = BinaryOp.Gt;                              break;                          case CompareOp.CgePseudo:                              binop = BinaryOp.Ge;                              break;                          case CompareOp.ClePseudo:                              binop = BinaryOp.Le;                              break;                          case CompareOp.CnePseudo:                              binop = BinaryOp.Ne;                              break;                          case CompareOp.CtruePseudo:                          case CompareOp.CfalsePseudo:                              // handled above                              throw new InvalidOperationException();                          default:                              throw new ArgumentOutOfRangeException();                          }                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression(a[0]' binop' a[1]' false' cmpi.IsUnsigned)' e));                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var sli = (ArgLocalInstruction)instruction;                      var id = default(JST.Identifier);                      switch (sli.ArgLocal)                      {                      case ArgLocal.Arg:                          id = compEnv.ValueParameterIds[sli.Index];                          break;                      case ArgLocal.Local:                          id = compEnv.LocalIds[sli.Index];                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      var cell = new VariableCell(id);                      switch (sli.Op)                      {                      case ArgLocalOp.Ld:                          stack.Push                              (new ExpressionStackEntry                                   (cell.Read().CloneIfStruct(compEnv)' ReadArgLocalE(sli.ArgLocal' sli.Index)));                          return true;                      case ArgLocalOp.Lda:                          // Effect will be accounted for on reads/writes                          stack.Push(new ExpressionStackEntry(cell.AddressOf()' BottomE));                          return true;                      case ArgLocalOp.St:                          return stack.PopEvalSE                              (statements'                               1'                               true'                               WriteArgLocalE(sli.ArgLocal' sli.Index)'                               (s' a) => s.Add(new ExpressionStatement(cell.Write(a[0]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                          {                              stack.Push                                  (new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' ReadHeapE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                       {                                           var readEffect = default(Effects);                                           var obj = default(Expression);                                           if (fieldi.IsViaPointer.Value)                                           {                                               readEffect = e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect());                                               obj = new ReadExpression(a[0]); // no need for clone                                           }                                           else if (fieldi.Field.DefiningType.Style(compEnv) is ValueTypeStyle)                                           {                                               readEffect = e;                                               obj = a[0];                                           }                                           else                                           {                                               // Object could be null                                               readEffect = e.Lub(ReadHeapOrThrowE);                                               obj = a[0];                                           }                                           return new ExpressionStackEntry(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' readEffect);                                       });                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                          {                              // Effect will be accounted for on reads/writes                              stack.Push(new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' BottomE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   {                                       if (fieldi.IsViaPointer.Value)                                           // We're just adding an offset to a pointer' so effect will                                           // be accounted for when the final pointer is read/written                                           return new ExpressionStackEntry(new FieldCell(new ReadExpression(a[0])' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e);                                       else                                           // Must be a reference type' and ref could be null                                           return new ExpressionStackEntry(new FieldCell(a[0]' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e.Lub(ThrowsE));                                   });                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                              return stack.PopEvalSE                                  (statements'                                   1'                                   true'                                   WriteHeapE'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Write(a[0]))));                          else                          {                              var writeEffect = fieldi.IsViaPointer.Value                                                    ? instruction.BeforeState.PeekPointsTo(1).WriteEffect()                                                    : WriteHeapOrThrowE;                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   writeEffect'                                   (s' a) =>                                       {                                           var obj = fieldi.IsViaPointer.Value ? new ReadExpression(a[0]) : a[0];                                           s.Add(new ExpressionStatement(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Write(a[1])));                                       });                          }                      case FieldOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new FieldHandleConstantExpression(compEnv.SubstituteMember(fieldi.Field))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methodi = (MethodInstruction)instruction;                      var arity = methodi.Method.ValueParameters.Count;                      switch (methodi.Op)                      {                      case MethodOp.Ldftn:                          if (methodi.IsVirtual)                              // Object could be null                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CodePointerExpression(a[0]' compEnv.SubstituteMember(methodi.Method))' e.Lub(ReadHeapOrThrowE)));                          else                          {                              stack.Push                                  (new ExpressionStackEntry(new CodePointerExpression(null' compEnv.SubstituteMember(methodi.Method))' BottomE));                              return true;                          }                      case MethodOp.Call:                          if (methodi.Method.Result == null)                              return stack.PopEvalSE                                  (statements'                                   arity'                                   true'                                   CalleeEffects(methodi.BeforeState' arity)'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new CallExpression                                                 (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal'                                                  compEnv.SubstituteMember(methodi.Method)'                                                  CallerArguments(methodi.Constrained' methodi.Method' a)))));                          else                              return stack.PopEvalPush                                  (statements'                                   arity'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CallExpression                                            (methodi.IsVirtual? CallFlavor.Virtual : CallFlavor.Normal'                                             compEnv.SubstituteMember(methodi.Method)'                                             CallerArguments(methodi.Constrained' methodi.Method' a))'                                        e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Newobj:                          arity--;                          return stack.PopEvalPush                              (statements'                               arity'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new NewObjectExpression(compEnv.SubstituteMember(methodi.Method)' CallerArguments(null' methodi.Method' a))'                                    e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Ldtoken:                          stack.Push                              (new ExpressionStackEntry(new MethodHandleConstantExpression(compEnv.SubstituteMember(methodi.Method))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case TypeOp.Stobj:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case TypeOp.Cpobj:                          {                              var copyEffect = instruction.BeforeState.PeekPointsTo(0).ReadEffect().Lub                                  (instruction.BeforeState.PeekPointsTo(1).WriteEffect());                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   copyEffect'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new WriteExpression(a[0]' new ReadExpression(a[1]).CloneIfStruct(compEnv)))));                          }                      case TypeOp.Newarr:                          // Growing the heap is not considered an observable change. But will throw if                          // length < 0                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new NewArrayExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Initobj:                          return stack.PopEvalSE                              (statements' 1' true' WriteHeapE' (s' a) => s.Add(new InitializeObjectStatement(a[0])));                      case TypeOp.Castclass:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new CastExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Isinst:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new IsInstExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Box:                          // Growing the heap is not considered an observable change                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new NewBoxExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Unbox:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).AddressOf()' e.Lub(ThrowsE)));                      case TypeOp.UnboxAny:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).Read().CloneIfStruct(compEnv)' e.Lub(ThrowsE)));                      case TypeOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new TypeHandleConstantExpression(compEnv.SubstituteType(typei.Type))' BottomE));                          return true;                      case TypeOp.Ldelem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case TypeOp.Stelem:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add(new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  // Calculating the pointer may throw if index is out of range.                  // Remaining effect will be accounted for when pointer is read/written.                  return stack.PopEvalPush                      (statements'                       2'                       true'                       (a' e) =>                       new ExpressionStackEntry(new ElementCell(a[0]' a[1]' false).AddressOf()' e.Lub(ThrowsE)));              case InstructionFlavor.LdInt32:                  {                      var int32i = (LdInt32Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int32ConstantExpression(int32i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdInt64:                  {                      var int64i = (LdInt64Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int64ConstantExpression(int64i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdSingle:                  {                      var singlei = (LdSingleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new SingleConstantExpression(singlei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdDouble:                  {                      var doublei = (LdDoubleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new DoubleConstantExpression(doublei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdString:                  {                      var stringi = (LdStringInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new StringConstantExpression(stringi.Value)' BottomE));                      return true;                  }              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Div:                      case ArithOp.Rem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(ThrowsE)));                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                      case ArithOp.Shl:                      case ArithOp.Shr:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(arithi.WithOverflow ? ThrowsE : BottomE)));                      case ArithOp.Neg:                      case ArithOp.BitNot:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression                                        (a[0]' ArithOpToUnaryOp(arithi.Op)' arithi.WithOverflow' arithi.IsUnsigned)'                                    e));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      return stack.PopEvalPush                          (statements'                           1'                           true'                           (a' e) =>                           new ExpressionStackEntry                               (new ConvertExpression                                    (a[0]'                                     new NamedTypeRef                                         (compEnv.Global.NumberFlavorToQualifiedTypeName[convi.TargetNumberFlavor])'                                     convi.WithOverflow'                                     convi.IsSourceUnsigned)'                                e.Lub(convi.WithOverflow ? ThrowsE : BottomE)));                  }              case InstructionFlavor.Try:                  {                      if (stack.Depth > 0)                          throw new InvalidOperationException("stack must be empty on entry to try block");                      var tryi = (TryInstruction)instruction;                      var tryStatements = BlockToTryFaultFinallyStatements(tryi.Body);                      if (tryStatements == null)                          return false;                      var handlers = TranslateHandlers(tryi.Handlers);                      if (handlers == null)                          return false;                      if (statements == null)                          return Failed(false' "try");                      statements.Add(new TryStatement(tryStatements' handlers));                      return true;                  }              case InstructionFlavor.IfThenElsePseudo:                  {                      var itei = (IfThenElseInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(itei.Offset' out isExpr) ||                                              isExpr;                        if (!TranslateBlock(statements' itei.Condition' stack' exid))                          return false;                      if (couldBeExpression && itei.Else != null)                      {                          // Pass 1: Try to tranlate to an if-then-else expression. Will only work if Then and Else don't                          //         reach into current stack' push exactly one value' and don't need to emit any                          //         statements along the way.                          var thenEntry = BlockToExpression(itei.Then' exid);                          if (thenEntry != null)                          {                              var elseEntry = BlockToExpression(itei.Else' exid);                              if (elseEntry != null)                              {                                  if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                                      instructionTranslationStyleCache.Add(itei.Offset' true);                                  return stack.PopEvalPush                                      (statements'                                       1'                                       true'                                       (a' e) =>                                       new ExpressionStackEntry                                           (new IfThenElseExpression(a[0]' thenEntry.Expression' elseEntry.Expression)'                                            e.Lub(thenEntry.Effects.Lub(elseEntry.Effects))));                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      var noStackChange = itei.Then.NoStackChange && (itei.Else == null || itei.Else.NoStackChange);                      var condEntry = noStackChange                                          ? stack.Pop()                                          : stack.FlushAndPopPostState(statements' itei.Then.BeforeState);                      if (condEntry == null)                          return false;                      var thenStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Then' exid)                                           : BlockToStatements(itei.Then' exid);                      if (thenStmnts == null)                          return false;                      var elseStmnts = default(Seq<Statement>);                      if (itei.Else != null)                      {                          elseStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Else' exid)                                           : BlockToStatements(itei.Else' exid);                          if (elseStmnts == null)                              return false;                      }                      if (statements == null)                          return Failed(false' "if-then-else");                      statements.Add                          (new IfThenElseStatement(condEntry.Expression' new Statements(thenStmnts)' elseStmnts == null ? null : new Statements(elseStmnts)));                      if (!noStackChange && !stack.Restore(itei.AfterState' 0))                          return false;                      if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                          instructionTranslationStyleCache.Add(itei.Offset' false);                      return true;                  }              case InstructionFlavor.ShortCircuitingPseudo:                  {                      var sci = (ShortCircuitingInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(sci.Offset' out isExpr) ||                                              isExpr;                      if (couldBeExpression)                      {                          // Pass 1: Try to translate to an expression.                          var leftEntry = BlockToExpression(sci.Left' exid);                          if (leftEntry != null)                          {                              var rightEntry = BlockToExpression(sci.Right' exid);                              if (rightEntry != null)                              {                                  stack.Push                                      (new ExpressionStackEntry                                           (new BinaryExpression                                                (leftEntry.Expression'                                                 ShortCircuitingOpToBinaryOp(sci.Op)'                                                 rightEntry.Expression'                                                 false'                                                 false)'                                            leftEntry.Effects.Lub(rightEntry.Effects)));                                  if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                                      instructionTranslationStyleCache.Add(sci.Offset' true);                                  return true;                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      if (!TranslateBlock(statements' sci.Left' stack' exid))                          return false;                      var leftEntry2 = stack.FlushAndPopPostState(statements' sci.Right.BeforeState);                      if (leftEntry2 == null)                          return false;                      var rightStatements = BlockToStatements(sci.Right' exid);                      if (rightStatements == null)                          return false;                      var id = sci.Right.AfterState.PeekId(0' nameSupply.GenSym);                      var cell = new VariableCell(id);                      compEnv.AddVariable(id' ArgLocal.Local' false' true' compEnv.SubstituteType(sci.Right.AfterState.PeekType(0)));                      if (statements == null)                          return Failed(false' "short-circuit");                      switch (sci.Op)                      {                      case ShortCircuitingOp.And:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements(rightStatements)'                                    new Statements                                        (new ExpressionStatement(cell.Write(new Int32ConstantExpression(0))))));                          break;                      case ShortCircuitingOp.Or:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements                                        (new ExpressionStatement                                             (cell.Write(new Int32ConstantExpression(1))))'                                    new Statements(rightStatements)));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      if (!stack.Restore(sci.AfterState' 1))                          return false;                      stack.Push(new ExpressionStackEntry(cell.Read()' BottomE));                      if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                          instructionTranslationStyleCache.Add(sci.Offset' false);                      return true;                  }              case InstructionFlavor.StructuralSwitchPseudo:                  {                      var ssi = (StructuralSwitchInstruction)instruction;                      if (!TranslateBlock(statements' ssi.Body' stack' exid))                          return false;                      var valueEntry = stack.FlushAndPopPreState(statements' ssi.Body.AfterState);                      if (valueEntry == null)                          return false;                      var cases = new Seq<SwitchStatementCase>();                      foreach (var c in ssi.Cases)                      {                          var caseStatements = BlockToStatements(c.Body' exid);                          if (caseStatements == null)                              return false;                          cases.Add(new SwitchStatementCase(c.Values' new Statements(caseStatements)));                      }                      if (statements == null)                          return Failed(false' "structural switch");                      statements.Add(new SwitchStatement(valueEntry.Expression' cases));                      if (!stack.Restore(ssi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopPseudo:                  {                      var li = (LoopInstruction)instruction;                      if (!stack.Flush(statements' li.Body.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop");                      var whileStatements = BlockToStatements(li.Body' exid);                      statements.Add                          (new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(whileStatements)));                      if (!stack.Restore(li.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.WhileDoPseudo:                  {                      var wdi = (WhileDoInstruction)instruction;                      if (!stack.Flush(statements' wdi.Condition.BeforeState))                          return false;                      var condEntry = BlockToExpression(wdi.Condition' exid);                      if (condEntry == null)                      {                          var stack1 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Condition.BeforeState' trace);                          var preCondStatements = new Seq<Statement>();                          if (!TranslateBlock(preCondStatements' wdi.Condition' stack1' exid))                              return false;                          condEntry = stack1.FlushAndPopPostState(preCondStatements' wdi.Body.BeforeState);                          if (condEntry == null)                              return false;                          var stack2 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Body.BeforeState' trace);                          var postCondStatements = new Seq<Statement>();                          if (!TranslateBlock(postCondStatements' wdi.Body' stack2' exid))                              return false;                          if (!stack2.Flush(postCondStatements' wdi.Body.AfterState))                              return false;                          preCondStatements.Add                              (new IfThenElseStatement                                   (condEntry.Expression'                                    new Statements(postCondStatements)'                                    new Statements(new BreakStatement())));                          statements.Add(new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(preCondStatements)));                      }                      else                      {                          var loopStatements = BlockToStatements(wdi.Body' exid);                          if (loopStatements == null)                              return false;                          if (statements == null)                              return Failed(false' "while-do");                          statements.Add(new WhileDoStatement(condEntry.Expression' new Statements(loopStatements)));                      }                      if (!stack.Restore(wdi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.DoWhilePseudo:                  {                      var dwi = (DoWhileInstruction)instruction;                      if (!stack.Flush(statements' dwi.Body.BeforeState))                          return false;                      var combined = new Seq<Instruction>();                      foreach (var i in dwi.Body.Body)                          combined.Add(i);                      foreach (var i in dwi.Condition.Body)                          combined.Add(i);                      var condEntry = default(ExpressionStackEntry);                      var loopStatements = BlockToConditionStatements                          (new Instructions(null' combined)' dwi.Body.BeforeState' exid' out condEntry);                      if (loopStatements == null)                          return false;                      if (statements == null)                          return Failed(false' "do-while");                      statements.Add(new DoWhileStatement(new Statements(loopStatements)' condEntry.Expression));                      if (!stack.Restore(dwi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopControlPseudo:                  {                      var lci = (BreakContinueInstruction)instruction;                      if (!stack.Flush(statements' lci.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop-control");                      var targetState = default(int);                      switch (lci.Op)                      {                      case BreakContinueOp.Break:                          if (labelToLoopCandidateBreakState != null &&                              labelToLoopCandidateBreakState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new BreakStatement(lci.Label));                          break;                      case BreakContinueOp.Continue:                          if (labelToLoopCandidateContinueState != null &&                              labelToLoopCandidateContinueState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new ContinueStatement(lci.Label));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      return true;                  }              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return true;                      case MiscOp.Dup:                          return stack.Dup(statements);                      case MiscOp.Pop:                          return stack.PopAndDiscard(statements);                      case MiscOp.Ldnull:                          stack.Push(new ExpressionStackEntry(new NullConstantExpression()' BottomE));                          return true;                      case MiscOp.Ckfinite:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.CheckFinite' false' false)' e.Lub(ThrowsE)));                      case MiscOp.Throw:                          if (!stack.DiscardAll(statements' 1))                              return false;                          if (!stack.PopEvalSE(statements' 1' true' ThrowsE' (s' a) => s.Add(new ThrowStatement(a[0]))))                              return false;                          return true;                      case MiscOp.Rethrow:                          if (!stack.DiscardAll(statements' 0))                              return false;                          if (statements == null)                              return Failed(false' "rethrow");                          if (exid == null)                              throw new InvalidOperationException("rethrow outside of catch");                          statements.Add(new RethrowStatement(new VariableCell(exid).Read()));                          return true;                      case MiscOp.LdindRef:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case MiscOp.LdelemRef:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.Ldlen:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.Length' false' false)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.StindRef:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case MiscOp.StelemRef:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add                                   (new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      case MiscOp.Ret:                          if (statements == null)                              return Failed(false' "return");                          statements.Add(new ReturnStatement(null));                          return true;                      case MiscOp.RetVal:                          return stack.PopEvalSE                              (statements' 1' true' BottomE' (s' a) => s.Add(new ReturnStatement(a[0])));                      case MiscOp.Endfilter:                      case MiscOp.Endfinally:                          throw new InvalidOperationException                              ("endfilter/endfinally instructions should have been removed");                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:              case InstructionFlavor.Switch:                  throw new InvalidOperationException("branch/switch instructions should have been removed");              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      if (cmpi.Op == CompareOp.CtruePseudo || cmpi.Op == CompareOp.CfalsePseudo)                      {                          var s = cmpi.Type.Style(compEnv);                          var unop = default(UnaryOp);                          if (s is NumberTypeStyle)                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonZero : UnaryOp.IsZero;                          else                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonNull : UnaryOp.IsNull;                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new UnaryExpression(a[0]' unop' false' cmpi.IsUnsigned)' e));                      }                      else                      {                          var binop = default(BinaryOp);                          switch (cmpi.Op)                          {                          case CompareOp.Ceq:                              binop = BinaryOp.Eq;                              break;                          case CompareOp.Clt:                              binop = BinaryOp.Lt;                              break;                          case CompareOp.Cgt:                              binop = BinaryOp.Gt;                              break;                          case CompareOp.CgePseudo:                              binop = BinaryOp.Ge;                              break;                          case CompareOp.ClePseudo:                              binop = BinaryOp.Le;                              break;                          case CompareOp.CnePseudo:                              binop = BinaryOp.Ne;                              break;                          case CompareOp.CtruePseudo:                          case CompareOp.CfalsePseudo:                              // handled above                              throw new InvalidOperationException();                          default:                              throw new ArgumentOutOfRangeException();                          }                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression(a[0]' binop' a[1]' false' cmpi.IsUnsigned)' e));                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var sli = (ArgLocalInstruction)instruction;                      var id = default(JST.Identifier);                      switch (sli.ArgLocal)                      {                      case ArgLocal.Arg:                          id = compEnv.ValueParameterIds[sli.Index];                          break;                      case ArgLocal.Local:                          id = compEnv.LocalIds[sli.Index];                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      var cell = new VariableCell(id);                      switch (sli.Op)                      {                      case ArgLocalOp.Ld:                          stack.Push                              (new ExpressionStackEntry                                   (cell.Read().CloneIfStruct(compEnv)' ReadArgLocalE(sli.ArgLocal' sli.Index)));                          return true;                      case ArgLocalOp.Lda:                          // Effect will be accounted for on reads/writes                          stack.Push(new ExpressionStackEntry(cell.AddressOf()' BottomE));                          return true;                      case ArgLocalOp.St:                          return stack.PopEvalSE                              (statements'                               1'                               true'                               WriteArgLocalE(sli.ArgLocal' sli.Index)'                               (s' a) => s.Add(new ExpressionStatement(cell.Write(a[0]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                          {                              stack.Push                                  (new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' ReadHeapE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                       {                                           var readEffect = default(Effects);                                           var obj = default(Expression);                                           if (fieldi.IsViaPointer.Value)                                           {                                               readEffect = e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect());                                               obj = new ReadExpression(a[0]); // no need for clone                                           }                                           else if (fieldi.Field.DefiningType.Style(compEnv) is ValueTypeStyle)                                           {                                               readEffect = e;                                               obj = a[0];                                           }                                           else                                           {                                               // Object could be null                                               readEffect = e.Lub(ReadHeapOrThrowE);                                               obj = a[0];                                           }                                           return new ExpressionStackEntry(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' readEffect);                                       });                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                          {                              // Effect will be accounted for on reads/writes                              stack.Push(new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' BottomE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   {                                       if (fieldi.IsViaPointer.Value)                                           // We're just adding an offset to a pointer' so effect will                                           // be accounted for when the final pointer is read/written                                           return new ExpressionStackEntry(new FieldCell(new ReadExpression(a[0])' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e);                                       else                                           // Must be a reference type' and ref could be null                                           return new ExpressionStackEntry(new FieldCell(a[0]' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e.Lub(ThrowsE));                                   });                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                              return stack.PopEvalSE                                  (statements'                                   1'                                   true'                                   WriteHeapE'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Write(a[0]))));                          else                          {                              var writeEffect = fieldi.IsViaPointer.Value                                                    ? instruction.BeforeState.PeekPointsTo(1).WriteEffect()                                                    : WriteHeapOrThrowE;                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   writeEffect'                                   (s' a) =>                                       {                                           var obj = fieldi.IsViaPointer.Value ? new ReadExpression(a[0]) : a[0];                                           s.Add(new ExpressionStatement(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Write(a[1])));                                       });                          }                      case FieldOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new FieldHandleConstantExpression(compEnv.SubstituteMember(fieldi.Field))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methodi = (MethodInstruction)instruction;                      var arity = methodi.Method.ValueParameters.Count;                      switch (methodi.Op)                      {                      case MethodOp.Ldftn:                          if (methodi.IsVirtual)                              // Object could be null                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CodePointerExpression(a[0]' compEnv.SubstituteMember(methodi.Method))' e.Lub(ReadHeapOrThrowE)));                          else                          {                              stack.Push                                  (new ExpressionStackEntry(new CodePointerExpression(null' compEnv.SubstituteMember(methodi.Method))' BottomE));                              return true;                          }                      case MethodOp.Call:                          if (methodi.Method.Result == null)                              return stack.PopEvalSE                                  (statements'                                   arity'                                   true'                                   CalleeEffects(methodi.BeforeState' arity)'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new CallExpression                                                 (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal'                                                  compEnv.SubstituteMember(methodi.Method)'                                                  CallerArguments(methodi.Constrained' methodi.Method' a)))));                          else                              return stack.PopEvalPush                                  (statements'                                   arity'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CallExpression                                            (methodi.IsVirtual? CallFlavor.Virtual : CallFlavor.Normal'                                             compEnv.SubstituteMember(methodi.Method)'                                             CallerArguments(methodi.Constrained' methodi.Method' a))'                                        e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Newobj:                          arity--;                          return stack.PopEvalPush                              (statements'                               arity'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new NewObjectExpression(compEnv.SubstituteMember(methodi.Method)' CallerArguments(null' methodi.Method' a))'                                    e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Ldtoken:                          stack.Push                              (new ExpressionStackEntry(new MethodHandleConstantExpression(compEnv.SubstituteMember(methodi.Method))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case TypeOp.Stobj:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case TypeOp.Cpobj:                          {                              var copyEffect = instruction.BeforeState.PeekPointsTo(0).ReadEffect().Lub                                  (instruction.BeforeState.PeekPointsTo(1).WriteEffect());                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   copyEffect'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new WriteExpression(a[0]' new ReadExpression(a[1]).CloneIfStruct(compEnv)))));                          }                      case TypeOp.Newarr:                          // Growing the heap is not considered an observable change. But will throw if                          // length < 0                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new NewArrayExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Initobj:                          return stack.PopEvalSE                              (statements' 1' true' WriteHeapE' (s' a) => s.Add(new InitializeObjectStatement(a[0])));                      case TypeOp.Castclass:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new CastExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Isinst:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new IsInstExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Box:                          // Growing the heap is not considered an observable change                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new NewBoxExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Unbox:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).AddressOf()' e.Lub(ThrowsE)));                      case TypeOp.UnboxAny:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).Read().CloneIfStruct(compEnv)' e.Lub(ThrowsE)));                      case TypeOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new TypeHandleConstantExpression(compEnv.SubstituteType(typei.Type))' BottomE));                          return true;                      case TypeOp.Ldelem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case TypeOp.Stelem:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add(new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  // Calculating the pointer may throw if index is out of range.                  // Remaining effect will be accounted for when pointer is read/written.                  return stack.PopEvalPush                      (statements'                       2'                       true'                       (a' e) =>                       new ExpressionStackEntry(new ElementCell(a[0]' a[1]' false).AddressOf()' e.Lub(ThrowsE)));              case InstructionFlavor.LdInt32:                  {                      var int32i = (LdInt32Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int32ConstantExpression(int32i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdInt64:                  {                      var int64i = (LdInt64Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int64ConstantExpression(int64i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdSingle:                  {                      var singlei = (LdSingleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new SingleConstantExpression(singlei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdDouble:                  {                      var doublei = (LdDoubleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new DoubleConstantExpression(doublei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdString:                  {                      var stringi = (LdStringInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new StringConstantExpression(stringi.Value)' BottomE));                      return true;                  }              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Div:                      case ArithOp.Rem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(ThrowsE)));                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                      case ArithOp.Shl:                      case ArithOp.Shr:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(arithi.WithOverflow ? ThrowsE : BottomE)));                      case ArithOp.Neg:                      case ArithOp.BitNot:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression                                        (a[0]' ArithOpToUnaryOp(arithi.Op)' arithi.WithOverflow' arithi.IsUnsigned)'                                    e));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      return stack.PopEvalPush                          (statements'                           1'                           true'                           (a' e) =>                           new ExpressionStackEntry                               (new ConvertExpression                                    (a[0]'                                     new NamedTypeRef                                         (compEnv.Global.NumberFlavorToQualifiedTypeName[convi.TargetNumberFlavor])'                                     convi.WithOverflow'                                     convi.IsSourceUnsigned)'                                e.Lub(convi.WithOverflow ? ThrowsE : BottomE)));                  }              case InstructionFlavor.Try:                  {                      if (stack.Depth > 0)                          throw new InvalidOperationException("stack must be empty on entry to try block");                      var tryi = (TryInstruction)instruction;                      var tryStatements = BlockToTryFaultFinallyStatements(tryi.Body);                      if (tryStatements == null)                          return false;                      var handlers = TranslateHandlers(tryi.Handlers);                      if (handlers == null)                          return false;                      if (statements == null)                          return Failed(false' "try");                      statements.Add(new TryStatement(tryStatements' handlers));                      return true;                  }              case InstructionFlavor.IfThenElsePseudo:                  {                      var itei = (IfThenElseInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(itei.Offset' out isExpr) ||                                              isExpr;                        if (!TranslateBlock(statements' itei.Condition' stack' exid))                          return false;                      if (couldBeExpression && itei.Else != null)                      {                          // Pass 1: Try to tranlate to an if-then-else expression. Will only work if Then and Else don't                          //         reach into current stack' push exactly one value' and don't need to emit any                          //         statements along the way.                          var thenEntry = BlockToExpression(itei.Then' exid);                          if (thenEntry != null)                          {                              var elseEntry = BlockToExpression(itei.Else' exid);                              if (elseEntry != null)                              {                                  if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                                      instructionTranslationStyleCache.Add(itei.Offset' true);                                  return stack.PopEvalPush                                      (statements'                                       1'                                       true'                                       (a' e) =>                                       new ExpressionStackEntry                                           (new IfThenElseExpression(a[0]' thenEntry.Expression' elseEntry.Expression)'                                            e.Lub(thenEntry.Effects.Lub(elseEntry.Effects))));                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      var noStackChange = itei.Then.NoStackChange && (itei.Else == null || itei.Else.NoStackChange);                      var condEntry = noStackChange                                          ? stack.Pop()                                          : stack.FlushAndPopPostState(statements' itei.Then.BeforeState);                      if (condEntry == null)                          return false;                      var thenStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Then' exid)                                           : BlockToStatements(itei.Then' exid);                      if (thenStmnts == null)                          return false;                      var elseStmnts = default(Seq<Statement>);                      if (itei.Else != null)                      {                          elseStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Else' exid)                                           : BlockToStatements(itei.Else' exid);                          if (elseStmnts == null)                              return false;                      }                      if (statements == null)                          return Failed(false' "if-then-else");                      statements.Add                          (new IfThenElseStatement(condEntry.Expression' new Statements(thenStmnts)' elseStmnts == null ? null : new Statements(elseStmnts)));                      if (!noStackChange && !stack.Restore(itei.AfterState' 0))                          return false;                      if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                          instructionTranslationStyleCache.Add(itei.Offset' false);                      return true;                  }              case InstructionFlavor.ShortCircuitingPseudo:                  {                      var sci = (ShortCircuitingInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(sci.Offset' out isExpr) ||                                              isExpr;                      if (couldBeExpression)                      {                          // Pass 1: Try to translate to an expression.                          var leftEntry = BlockToExpression(sci.Left' exid);                          if (leftEntry != null)                          {                              var rightEntry = BlockToExpression(sci.Right' exid);                              if (rightEntry != null)                              {                                  stack.Push                                      (new ExpressionStackEntry                                           (new BinaryExpression                                                (leftEntry.Expression'                                                 ShortCircuitingOpToBinaryOp(sci.Op)'                                                 rightEntry.Expression'                                                 false'                                                 false)'                                            leftEntry.Effects.Lub(rightEntry.Effects)));                                  if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                                      instructionTranslationStyleCache.Add(sci.Offset' true);                                  return true;                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      if (!TranslateBlock(statements' sci.Left' stack' exid))                          return false;                      var leftEntry2 = stack.FlushAndPopPostState(statements' sci.Right.BeforeState);                      if (leftEntry2 == null)                          return false;                      var rightStatements = BlockToStatements(sci.Right' exid);                      if (rightStatements == null)                          return false;                      var id = sci.Right.AfterState.PeekId(0' nameSupply.GenSym);                      var cell = new VariableCell(id);                      compEnv.AddVariable(id' ArgLocal.Local' false' true' compEnv.SubstituteType(sci.Right.AfterState.PeekType(0)));                      if (statements == null)                          return Failed(false' "short-circuit");                      switch (sci.Op)                      {                      case ShortCircuitingOp.And:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements(rightStatements)'                                    new Statements                                        (new ExpressionStatement(cell.Write(new Int32ConstantExpression(0))))));                          break;                      case ShortCircuitingOp.Or:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements                                        (new ExpressionStatement                                             (cell.Write(new Int32ConstantExpression(1))))'                                    new Statements(rightStatements)));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      if (!stack.Restore(sci.AfterState' 1))                          return false;                      stack.Push(new ExpressionStackEntry(cell.Read()' BottomE));                      if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                          instructionTranslationStyleCache.Add(sci.Offset' false);                      return true;                  }              case InstructionFlavor.StructuralSwitchPseudo:                  {                      var ssi = (StructuralSwitchInstruction)instruction;                      if (!TranslateBlock(statements' ssi.Body' stack' exid))                          return false;                      var valueEntry = stack.FlushAndPopPreState(statements' ssi.Body.AfterState);                      if (valueEntry == null)                          return false;                      var cases = new Seq<SwitchStatementCase>();                      foreach (var c in ssi.Cases)                      {                          var caseStatements = BlockToStatements(c.Body' exid);                          if (caseStatements == null)                              return false;                          cases.Add(new SwitchStatementCase(c.Values' new Statements(caseStatements)));                      }                      if (statements == null)                          return Failed(false' "structural switch");                      statements.Add(new SwitchStatement(valueEntry.Expression' cases));                      if (!stack.Restore(ssi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopPseudo:                  {                      var li = (LoopInstruction)instruction;                      if (!stack.Flush(statements' li.Body.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop");                      var whileStatements = BlockToStatements(li.Body' exid);                      statements.Add                          (new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(whileStatements)));                      if (!stack.Restore(li.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.WhileDoPseudo:                  {                      var wdi = (WhileDoInstruction)instruction;                      if (!stack.Flush(statements' wdi.Condition.BeforeState))                          return false;                      var condEntry = BlockToExpression(wdi.Condition' exid);                      if (condEntry == null)                      {                          var stack1 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Condition.BeforeState' trace);                          var preCondStatements = new Seq<Statement>();                          if (!TranslateBlock(preCondStatements' wdi.Condition' stack1' exid))                              return false;                          condEntry = stack1.FlushAndPopPostState(preCondStatements' wdi.Body.BeforeState);                          if (condEntry == null)                              return false;                          var stack2 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Body.BeforeState' trace);                          var postCondStatements = new Seq<Statement>();                          if (!TranslateBlock(postCondStatements' wdi.Body' stack2' exid))                              return false;                          if (!stack2.Flush(postCondStatements' wdi.Body.AfterState))                              return false;                          preCondStatements.Add                              (new IfThenElseStatement                                   (condEntry.Expression'                                    new Statements(postCondStatements)'                                    new Statements(new BreakStatement())));                          statements.Add(new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(preCondStatements)));                      }                      else                      {                          var loopStatements = BlockToStatements(wdi.Body' exid);                          if (loopStatements == null)                              return false;                          if (statements == null)                              return Failed(false' "while-do");                          statements.Add(new WhileDoStatement(condEntry.Expression' new Statements(loopStatements)));                      }                      if (!stack.Restore(wdi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.DoWhilePseudo:                  {                      var dwi = (DoWhileInstruction)instruction;                      if (!stack.Flush(statements' dwi.Body.BeforeState))                          return false;                      var combined = new Seq<Instruction>();                      foreach (var i in dwi.Body.Body)                          combined.Add(i);                      foreach (var i in dwi.Condition.Body)                          combined.Add(i);                      var condEntry = default(ExpressionStackEntry);                      var loopStatements = BlockToConditionStatements                          (new Instructions(null' combined)' dwi.Body.BeforeState' exid' out condEntry);                      if (loopStatements == null)                          return false;                      if (statements == null)                          return Failed(false' "do-while");                      statements.Add(new DoWhileStatement(new Statements(loopStatements)' condEntry.Expression));                      if (!stack.Restore(dwi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopControlPseudo:                  {                      var lci = (BreakContinueInstruction)instruction;                      if (!stack.Flush(statements' lci.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop-control");                      var targetState = default(int);                      switch (lci.Op)                      {                      case BreakContinueOp.Break:                          if (labelToLoopCandidateBreakState != null &&                              labelToLoopCandidateBreakState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new BreakStatement(lci.Label));                          break;                      case BreakContinueOp.Continue:                          if (labelToLoopCandidateContinueState != null &&                              labelToLoopCandidateContinueState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new ContinueStatement(lci.Label));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      return true;                  }              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return true;                      case MiscOp.Dup:                          return stack.Dup(statements);                      case MiscOp.Pop:                          return stack.PopAndDiscard(statements);                      case MiscOp.Ldnull:                          stack.Push(new ExpressionStackEntry(new NullConstantExpression()' BottomE));                          return true;                      case MiscOp.Ckfinite:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.CheckFinite' false' false)' e.Lub(ThrowsE)));                      case MiscOp.Throw:                          if (!stack.DiscardAll(statements' 1))                              return false;                          if (!stack.PopEvalSE(statements' 1' true' ThrowsE' (s' a) => s.Add(new ThrowStatement(a[0]))))                              return false;                          return true;                      case MiscOp.Rethrow:                          if (!stack.DiscardAll(statements' 0))                              return false;                          if (statements == null)                              return Failed(false' "rethrow");                          if (exid == null)                              throw new InvalidOperationException("rethrow outside of catch");                          statements.Add(new RethrowStatement(new VariableCell(exid).Read()));                          return true;                      case MiscOp.LdindRef:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case MiscOp.LdelemRef:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.Ldlen:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.Length' false' false)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.StindRef:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case MiscOp.StelemRef:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add                                   (new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      case MiscOp.Ret:                          if (statements == null)                              return Failed(false' "return");                          statements.Add(new ReturnStatement(null));                          return true;                      case MiscOp.RetVal:                          return stack.PopEvalSE                              (statements' 1' true' BottomE' (s' a) => s.Add(new ReturnStatement(a[0])));                      case MiscOp.Endfilter:                      case MiscOp.Endfinally:                          throw new InvalidOperationException                              ("endfilter/endfinally instructions should have been removed");                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:              case InstructionFlavor.Switch:                  throw new InvalidOperationException("branch/switch instructions should have been removed");              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      if (cmpi.Op == CompareOp.CtruePseudo || cmpi.Op == CompareOp.CfalsePseudo)                      {                          var s = cmpi.Type.Style(compEnv);                          var unop = default(UnaryOp);                          if (s is NumberTypeStyle)                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonZero : UnaryOp.IsZero;                          else                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonNull : UnaryOp.IsNull;                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new UnaryExpression(a[0]' unop' false' cmpi.IsUnsigned)' e));                      }                      else                      {                          var binop = default(BinaryOp);                          switch (cmpi.Op)                          {                          case CompareOp.Ceq:                              binop = BinaryOp.Eq;                              break;                          case CompareOp.Clt:                              binop = BinaryOp.Lt;                              break;                          case CompareOp.Cgt:                              binop = BinaryOp.Gt;                              break;                          case CompareOp.CgePseudo:                              binop = BinaryOp.Ge;                              break;                          case CompareOp.ClePseudo:                              binop = BinaryOp.Le;                              break;                          case CompareOp.CnePseudo:                              binop = BinaryOp.Ne;                              break;                          case CompareOp.CtruePseudo:                          case CompareOp.CfalsePseudo:                              // handled above                              throw new InvalidOperationException();                          default:                              throw new ArgumentOutOfRangeException();                          }                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression(a[0]' binop' a[1]' false' cmpi.IsUnsigned)' e));                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var sli = (ArgLocalInstruction)instruction;                      var id = default(JST.Identifier);                      switch (sli.ArgLocal)                      {                      case ArgLocal.Arg:                          id = compEnv.ValueParameterIds[sli.Index];                          break;                      case ArgLocal.Local:                          id = compEnv.LocalIds[sli.Index];                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      var cell = new VariableCell(id);                      switch (sli.Op)                      {                      case ArgLocalOp.Ld:                          stack.Push                              (new ExpressionStackEntry                                   (cell.Read().CloneIfStruct(compEnv)' ReadArgLocalE(sli.ArgLocal' sli.Index)));                          return true;                      case ArgLocalOp.Lda:                          // Effect will be accounted for on reads/writes                          stack.Push(new ExpressionStackEntry(cell.AddressOf()' BottomE));                          return true;                      case ArgLocalOp.St:                          return stack.PopEvalSE                              (statements'                               1'                               true'                               WriteArgLocalE(sli.ArgLocal' sli.Index)'                               (s' a) => s.Add(new ExpressionStatement(cell.Write(a[0]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                          {                              stack.Push                                  (new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' ReadHeapE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                       {                                           var readEffect = default(Effects);                                           var obj = default(Expression);                                           if (fieldi.IsViaPointer.Value)                                           {                                               readEffect = e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect());                                               obj = new ReadExpression(a[0]); // no need for clone                                           }                                           else if (fieldi.Field.DefiningType.Style(compEnv) is ValueTypeStyle)                                           {                                               readEffect = e;                                               obj = a[0];                                           }                                           else                                           {                                               // Object could be null                                               readEffect = e.Lub(ReadHeapOrThrowE);                                               obj = a[0];                                           }                                           return new ExpressionStackEntry(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' readEffect);                                       });                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                          {                              // Effect will be accounted for on reads/writes                              stack.Push(new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' BottomE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   {                                       if (fieldi.IsViaPointer.Value)                                           // We're just adding an offset to a pointer' so effect will                                           // be accounted for when the final pointer is read/written                                           return new ExpressionStackEntry(new FieldCell(new ReadExpression(a[0])' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e);                                       else                                           // Must be a reference type' and ref could be null                                           return new ExpressionStackEntry(new FieldCell(a[0]' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e.Lub(ThrowsE));                                   });                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                              return stack.PopEvalSE                                  (statements'                                   1'                                   true'                                   WriteHeapE'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Write(a[0]))));                          else                          {                              var writeEffect = fieldi.IsViaPointer.Value                                                    ? instruction.BeforeState.PeekPointsTo(1).WriteEffect()                                                    : WriteHeapOrThrowE;                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   writeEffect'                                   (s' a) =>                                       {                                           var obj = fieldi.IsViaPointer.Value ? new ReadExpression(a[0]) : a[0];                                           s.Add(new ExpressionStatement(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Write(a[1])));                                       });                          }                      case FieldOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new FieldHandleConstantExpression(compEnv.SubstituteMember(fieldi.Field))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methodi = (MethodInstruction)instruction;                      var arity = methodi.Method.ValueParameters.Count;                      switch (methodi.Op)                      {                      case MethodOp.Ldftn:                          if (methodi.IsVirtual)                              // Object could be null                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CodePointerExpression(a[0]' compEnv.SubstituteMember(methodi.Method))' e.Lub(ReadHeapOrThrowE)));                          else                          {                              stack.Push                                  (new ExpressionStackEntry(new CodePointerExpression(null' compEnv.SubstituteMember(methodi.Method))' BottomE));                              return true;                          }                      case MethodOp.Call:                          if (methodi.Method.Result == null)                              return stack.PopEvalSE                                  (statements'                                   arity'                                   true'                                   CalleeEffects(methodi.BeforeState' arity)'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new CallExpression                                                 (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal'                                                  compEnv.SubstituteMember(methodi.Method)'                                                  CallerArguments(methodi.Constrained' methodi.Method' a)))));                          else                              return stack.PopEvalPush                                  (statements'                                   arity'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CallExpression                                            (methodi.IsVirtual? CallFlavor.Virtual : CallFlavor.Normal'                                             compEnv.SubstituteMember(methodi.Method)'                                             CallerArguments(methodi.Constrained' methodi.Method' a))'                                        e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Newobj:                          arity--;                          return stack.PopEvalPush                              (statements'                               arity'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new NewObjectExpression(compEnv.SubstituteMember(methodi.Method)' CallerArguments(null' methodi.Method' a))'                                    e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Ldtoken:                          stack.Push                              (new ExpressionStackEntry(new MethodHandleConstantExpression(compEnv.SubstituteMember(methodi.Method))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case TypeOp.Stobj:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case TypeOp.Cpobj:                          {                              var copyEffect = instruction.BeforeState.PeekPointsTo(0).ReadEffect().Lub                                  (instruction.BeforeState.PeekPointsTo(1).WriteEffect());                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   copyEffect'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new WriteExpression(a[0]' new ReadExpression(a[1]).CloneIfStruct(compEnv)))));                          }                      case TypeOp.Newarr:                          // Growing the heap is not considered an observable change. But will throw if                          // length < 0                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new NewArrayExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Initobj:                          return stack.PopEvalSE                              (statements' 1' true' WriteHeapE' (s' a) => s.Add(new InitializeObjectStatement(a[0])));                      case TypeOp.Castclass:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new CastExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Isinst:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new IsInstExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Box:                          // Growing the heap is not considered an observable change                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new NewBoxExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Unbox:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).AddressOf()' e.Lub(ThrowsE)));                      case TypeOp.UnboxAny:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).Read().CloneIfStruct(compEnv)' e.Lub(ThrowsE)));                      case TypeOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new TypeHandleConstantExpression(compEnv.SubstituteType(typei.Type))' BottomE));                          return true;                      case TypeOp.Ldelem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case TypeOp.Stelem:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add(new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  // Calculating the pointer may throw if index is out of range.                  // Remaining effect will be accounted for when pointer is read/written.                  return stack.PopEvalPush                      (statements'                       2'                       true'                       (a' e) =>                       new ExpressionStackEntry(new ElementCell(a[0]' a[1]' false).AddressOf()' e.Lub(ThrowsE)));              case InstructionFlavor.LdInt32:                  {                      var int32i = (LdInt32Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int32ConstantExpression(int32i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdInt64:                  {                      var int64i = (LdInt64Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int64ConstantExpression(int64i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdSingle:                  {                      var singlei = (LdSingleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new SingleConstantExpression(singlei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdDouble:                  {                      var doublei = (LdDoubleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new DoubleConstantExpression(doublei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdString:                  {                      var stringi = (LdStringInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new StringConstantExpression(stringi.Value)' BottomE));                      return true;                  }              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Div:                      case ArithOp.Rem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(ThrowsE)));                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                      case ArithOp.Shl:                      case ArithOp.Shr:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(arithi.WithOverflow ? ThrowsE : BottomE)));                      case ArithOp.Neg:                      case ArithOp.BitNot:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression                                        (a[0]' ArithOpToUnaryOp(arithi.Op)' arithi.WithOverflow' arithi.IsUnsigned)'                                    e));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      return stack.PopEvalPush                          (statements'                           1'                           true'                           (a' e) =>                           new ExpressionStackEntry                               (new ConvertExpression                                    (a[0]'                                     new NamedTypeRef                                         (compEnv.Global.NumberFlavorToQualifiedTypeName[convi.TargetNumberFlavor])'                                     convi.WithOverflow'                                     convi.IsSourceUnsigned)'                                e.Lub(convi.WithOverflow ? ThrowsE : BottomE)));                  }              case InstructionFlavor.Try:                  {                      if (stack.Depth > 0)                          throw new InvalidOperationException("stack must be empty on entry to try block");                      var tryi = (TryInstruction)instruction;                      var tryStatements = BlockToTryFaultFinallyStatements(tryi.Body);                      if (tryStatements == null)                          return false;                      var handlers = TranslateHandlers(tryi.Handlers);                      if (handlers == null)                          return false;                      if (statements == null)                          return Failed(false' "try");                      statements.Add(new TryStatement(tryStatements' handlers));                      return true;                  }              case InstructionFlavor.IfThenElsePseudo:                  {                      var itei = (IfThenElseInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(itei.Offset' out isExpr) ||                                              isExpr;                        if (!TranslateBlock(statements' itei.Condition' stack' exid))                          return false;                      if (couldBeExpression && itei.Else != null)                      {                          // Pass 1: Try to tranlate to an if-then-else expression. Will only work if Then and Else don't                          //         reach into current stack' push exactly one value' and don't need to emit any                          //         statements along the way.                          var thenEntry = BlockToExpression(itei.Then' exid);                          if (thenEntry != null)                          {                              var elseEntry = BlockToExpression(itei.Else' exid);                              if (elseEntry != null)                              {                                  if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                                      instructionTranslationStyleCache.Add(itei.Offset' true);                                  return stack.PopEvalPush                                      (statements'                                       1'                                       true'                                       (a' e) =>                                       new ExpressionStackEntry                                           (new IfThenElseExpression(a[0]' thenEntry.Expression' elseEntry.Expression)'                                            e.Lub(thenEntry.Effects.Lub(elseEntry.Effects))));                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      var noStackChange = itei.Then.NoStackChange && (itei.Else == null || itei.Else.NoStackChange);                      var condEntry = noStackChange                                          ? stack.Pop()                                          : stack.FlushAndPopPostState(statements' itei.Then.BeforeState);                      if (condEntry == null)                          return false;                      var thenStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Then' exid)                                           : BlockToStatements(itei.Then' exid);                      if (thenStmnts == null)                          return false;                      var elseStmnts = default(Seq<Statement>);                      if (itei.Else != null)                      {                          elseStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Else' exid)                                           : BlockToStatements(itei.Else' exid);                          if (elseStmnts == null)                              return false;                      }                      if (statements == null)                          return Failed(false' "if-then-else");                      statements.Add                          (new IfThenElseStatement(condEntry.Expression' new Statements(thenStmnts)' elseStmnts == null ? null : new Statements(elseStmnts)));                      if (!noStackChange && !stack.Restore(itei.AfterState' 0))                          return false;                      if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                          instructionTranslationStyleCache.Add(itei.Offset' false);                      return true;                  }              case InstructionFlavor.ShortCircuitingPseudo:                  {                      var sci = (ShortCircuitingInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(sci.Offset' out isExpr) ||                                              isExpr;                      if (couldBeExpression)                      {                          // Pass 1: Try to translate to an expression.                          var leftEntry = BlockToExpression(sci.Left' exid);                          if (leftEntry != null)                          {                              var rightEntry = BlockToExpression(sci.Right' exid);                              if (rightEntry != null)                              {                                  stack.Push                                      (new ExpressionStackEntry                                           (new BinaryExpression                                                (leftEntry.Expression'                                                 ShortCircuitingOpToBinaryOp(sci.Op)'                                                 rightEntry.Expression'                                                 false'                                                 false)'                                            leftEntry.Effects.Lub(rightEntry.Effects)));                                  if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                                      instructionTranslationStyleCache.Add(sci.Offset' true);                                  return true;                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      if (!TranslateBlock(statements' sci.Left' stack' exid))                          return false;                      var leftEntry2 = stack.FlushAndPopPostState(statements' sci.Right.BeforeState);                      if (leftEntry2 == null)                          return false;                      var rightStatements = BlockToStatements(sci.Right' exid);                      if (rightStatements == null)                          return false;                      var id = sci.Right.AfterState.PeekId(0' nameSupply.GenSym);                      var cell = new VariableCell(id);                      compEnv.AddVariable(id' ArgLocal.Local' false' true' compEnv.SubstituteType(sci.Right.AfterState.PeekType(0)));                      if (statements == null)                          return Failed(false' "short-circuit");                      switch (sci.Op)                      {                      case ShortCircuitingOp.And:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements(rightStatements)'                                    new Statements                                        (new ExpressionStatement(cell.Write(new Int32ConstantExpression(0))))));                          break;                      case ShortCircuitingOp.Or:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements                                        (new ExpressionStatement                                             (cell.Write(new Int32ConstantExpression(1))))'                                    new Statements(rightStatements)));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      if (!stack.Restore(sci.AfterState' 1))                          return false;                      stack.Push(new ExpressionStackEntry(cell.Read()' BottomE));                      if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                          instructionTranslationStyleCache.Add(sci.Offset' false);                      return true;                  }              case InstructionFlavor.StructuralSwitchPseudo:                  {                      var ssi = (StructuralSwitchInstruction)instruction;                      if (!TranslateBlock(statements' ssi.Body' stack' exid))                          return false;                      var valueEntry = stack.FlushAndPopPreState(statements' ssi.Body.AfterState);                      if (valueEntry == null)                          return false;                      var cases = new Seq<SwitchStatementCase>();                      foreach (var c in ssi.Cases)                      {                          var caseStatements = BlockToStatements(c.Body' exid);                          if (caseStatements == null)                              return false;                          cases.Add(new SwitchStatementCase(c.Values' new Statements(caseStatements)));                      }                      if (statements == null)                          return Failed(false' "structural switch");                      statements.Add(new SwitchStatement(valueEntry.Expression' cases));                      if (!stack.Restore(ssi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopPseudo:                  {                      var li = (LoopInstruction)instruction;                      if (!stack.Flush(statements' li.Body.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop");                      var whileStatements = BlockToStatements(li.Body' exid);                      statements.Add                          (new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(whileStatements)));                      if (!stack.Restore(li.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.WhileDoPseudo:                  {                      var wdi = (WhileDoInstruction)instruction;                      if (!stack.Flush(statements' wdi.Condition.BeforeState))                          return false;                      var condEntry = BlockToExpression(wdi.Condition' exid);                      if (condEntry == null)                      {                          var stack1 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Condition.BeforeState' trace);                          var preCondStatements = new Seq<Statement>();                          if (!TranslateBlock(preCondStatements' wdi.Condition' stack1' exid))                              return false;                          condEntry = stack1.FlushAndPopPostState(preCondStatements' wdi.Body.BeforeState);                          if (condEntry == null)                              return false;                          var stack2 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Body.BeforeState' trace);                          var postCondStatements = new Seq<Statement>();                          if (!TranslateBlock(postCondStatements' wdi.Body' stack2' exid))                              return false;                          if (!stack2.Flush(postCondStatements' wdi.Body.AfterState))                              return false;                          preCondStatements.Add                              (new IfThenElseStatement                                   (condEntry.Expression'                                    new Statements(postCondStatements)'                                    new Statements(new BreakStatement())));                          statements.Add(new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(preCondStatements)));                      }                      else                      {                          var loopStatements = BlockToStatements(wdi.Body' exid);                          if (loopStatements == null)                              return false;                          if (statements == null)                              return Failed(false' "while-do");                          statements.Add(new WhileDoStatement(condEntry.Expression' new Statements(loopStatements)));                      }                      if (!stack.Restore(wdi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.DoWhilePseudo:                  {                      var dwi = (DoWhileInstruction)instruction;                      if (!stack.Flush(statements' dwi.Body.BeforeState))                          return false;                      var combined = new Seq<Instruction>();                      foreach (var i in dwi.Body.Body)                          combined.Add(i);                      foreach (var i in dwi.Condition.Body)                          combined.Add(i);                      var condEntry = default(ExpressionStackEntry);                      var loopStatements = BlockToConditionStatements                          (new Instructions(null' combined)' dwi.Body.BeforeState' exid' out condEntry);                      if (loopStatements == null)                          return false;                      if (statements == null)                          return Failed(false' "do-while");                      statements.Add(new DoWhileStatement(new Statements(loopStatements)' condEntry.Expression));                      if (!stack.Restore(dwi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopControlPseudo:                  {                      var lci = (BreakContinueInstruction)instruction;                      if (!stack.Flush(statements' lci.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop-control");                      var targetState = default(int);                      switch (lci.Op)                      {                      case BreakContinueOp.Break:                          if (labelToLoopCandidateBreakState != null &&                              labelToLoopCandidateBreakState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new BreakStatement(lci.Label));                          break;                      case BreakContinueOp.Continue:                          if (labelToLoopCandidateContinueState != null &&                              labelToLoopCandidateContinueState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new ContinueStatement(lci.Label));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      return true;                  }              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return true;                      case MiscOp.Dup:                          return stack.Dup(statements);                      case MiscOp.Pop:                          return stack.PopAndDiscard(statements);                      case MiscOp.Ldnull:                          stack.Push(new ExpressionStackEntry(new NullConstantExpression()' BottomE));                          return true;                      case MiscOp.Ckfinite:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.CheckFinite' false' false)' e.Lub(ThrowsE)));                      case MiscOp.Throw:                          if (!stack.DiscardAll(statements' 1))                              return false;                          if (!stack.PopEvalSE(statements' 1' true' ThrowsE' (s' a) => s.Add(new ThrowStatement(a[0]))))                              return false;                          return true;                      case MiscOp.Rethrow:                          if (!stack.DiscardAll(statements' 0))                              return false;                          if (statements == null)                              return Failed(false' "rethrow");                          if (exid == null)                              throw new InvalidOperationException("rethrow outside of catch");                          statements.Add(new RethrowStatement(new VariableCell(exid).Read()));                          return true;                      case MiscOp.LdindRef:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case MiscOp.LdelemRef:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.Ldlen:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.Length' false' false)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.StindRef:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case MiscOp.StelemRef:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add                                   (new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      case MiscOp.Ret:                          if (statements == null)                              return Failed(false' "return");                          statements.Add(new ReturnStatement(null));                          return true;                      case MiscOp.RetVal:                          return stack.PopEvalSE                              (statements' 1' true' BottomE' (s' a) => s.Add(new ReturnStatement(a[0])));                      case MiscOp.Endfilter:                      case MiscOp.Endfinally:                          throw new InvalidOperationException                              ("endfilter/endfinally instructions should have been removed");                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:              case InstructionFlavor.Switch:                  throw new InvalidOperationException("branch/switch instructions should have been removed");              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      if (cmpi.Op == CompareOp.CtruePseudo || cmpi.Op == CompareOp.CfalsePseudo)                      {                          var s = cmpi.Type.Style(compEnv);                          var unop = default(UnaryOp);                          if (s is NumberTypeStyle)                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonZero : UnaryOp.IsZero;                          else                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonNull : UnaryOp.IsNull;                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new UnaryExpression(a[0]' unop' false' cmpi.IsUnsigned)' e));                      }                      else                      {                          var binop = default(BinaryOp);                          switch (cmpi.Op)                          {                          case CompareOp.Ceq:                              binop = BinaryOp.Eq;                              break;                          case CompareOp.Clt:                              binop = BinaryOp.Lt;                              break;                          case CompareOp.Cgt:                              binop = BinaryOp.Gt;                              break;                          case CompareOp.CgePseudo:                              binop = BinaryOp.Ge;                              break;                          case CompareOp.ClePseudo:                              binop = BinaryOp.Le;                              break;                          case CompareOp.CnePseudo:                              binop = BinaryOp.Ne;                              break;                          case CompareOp.CtruePseudo:                          case CompareOp.CfalsePseudo:                              // handled above                              throw new InvalidOperationException();                          default:                              throw new ArgumentOutOfRangeException();                          }                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression(a[0]' binop' a[1]' false' cmpi.IsUnsigned)' e));                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var sli = (ArgLocalInstruction)instruction;                      var id = default(JST.Identifier);                      switch (sli.ArgLocal)                      {                      case ArgLocal.Arg:                          id = compEnv.ValueParameterIds[sli.Index];                          break;                      case ArgLocal.Local:                          id = compEnv.LocalIds[sli.Index];                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      var cell = new VariableCell(id);                      switch (sli.Op)                      {                      case ArgLocalOp.Ld:                          stack.Push                              (new ExpressionStackEntry                                   (cell.Read().CloneIfStruct(compEnv)' ReadArgLocalE(sli.ArgLocal' sli.Index)));                          return true;                      case ArgLocalOp.Lda:                          // Effect will be accounted for on reads/writes                          stack.Push(new ExpressionStackEntry(cell.AddressOf()' BottomE));                          return true;                      case ArgLocalOp.St:                          return stack.PopEvalSE                              (statements'                               1'                               true'                               WriteArgLocalE(sli.ArgLocal' sli.Index)'                               (s' a) => s.Add(new ExpressionStatement(cell.Write(a[0]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                          {                              stack.Push                                  (new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' ReadHeapE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                       {                                           var readEffect = default(Effects);                                           var obj = default(Expression);                                           if (fieldi.IsViaPointer.Value)                                           {                                               readEffect = e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect());                                               obj = new ReadExpression(a[0]); // no need for clone                                           }                                           else if (fieldi.Field.DefiningType.Style(compEnv) is ValueTypeStyle)                                           {                                               readEffect = e;                                               obj = a[0];                                           }                                           else                                           {                                               // Object could be null                                               readEffect = e.Lub(ReadHeapOrThrowE);                                               obj = a[0];                                           }                                           return new ExpressionStackEntry(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' readEffect);                                       });                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                          {                              // Effect will be accounted for on reads/writes                              stack.Push(new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' BottomE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   {                                       if (fieldi.IsViaPointer.Value)                                           // We're just adding an offset to a pointer' so effect will                                           // be accounted for when the final pointer is read/written                                           return new ExpressionStackEntry(new FieldCell(new ReadExpression(a[0])' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e);                                       else                                           // Must be a reference type' and ref could be null                                           return new ExpressionStackEntry(new FieldCell(a[0]' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e.Lub(ThrowsE));                                   });                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                              return stack.PopEvalSE                                  (statements'                                   1'                                   true'                                   WriteHeapE'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Write(a[0]))));                          else                          {                              var writeEffect = fieldi.IsViaPointer.Value                                                    ? instruction.BeforeState.PeekPointsTo(1).WriteEffect()                                                    : WriteHeapOrThrowE;                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   writeEffect'                                   (s' a) =>                                       {                                           var obj = fieldi.IsViaPointer.Value ? new ReadExpression(a[0]) : a[0];                                           s.Add(new ExpressionStatement(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Write(a[1])));                                       });                          }                      case FieldOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new FieldHandleConstantExpression(compEnv.SubstituteMember(fieldi.Field))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methodi = (MethodInstruction)instruction;                      var arity = methodi.Method.ValueParameters.Count;                      switch (methodi.Op)                      {                      case MethodOp.Ldftn:                          if (methodi.IsVirtual)                              // Object could be null                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CodePointerExpression(a[0]' compEnv.SubstituteMember(methodi.Method))' e.Lub(ReadHeapOrThrowE)));                          else                          {                              stack.Push                                  (new ExpressionStackEntry(new CodePointerExpression(null' compEnv.SubstituteMember(methodi.Method))' BottomE));                              return true;                          }                      case MethodOp.Call:                          if (methodi.Method.Result == null)                              return stack.PopEvalSE                                  (statements'                                   arity'                                   true'                                   CalleeEffects(methodi.BeforeState' arity)'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new CallExpression                                                 (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal'                                                  compEnv.SubstituteMember(methodi.Method)'                                                  CallerArguments(methodi.Constrained' methodi.Method' a)))));                          else                              return stack.PopEvalPush                                  (statements'                                   arity'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CallExpression                                            (methodi.IsVirtual? CallFlavor.Virtual : CallFlavor.Normal'                                             compEnv.SubstituteMember(methodi.Method)'                                             CallerArguments(methodi.Constrained' methodi.Method' a))'                                        e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Newobj:                          arity--;                          return stack.PopEvalPush                              (statements'                               arity'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new NewObjectExpression(compEnv.SubstituteMember(methodi.Method)' CallerArguments(null' methodi.Method' a))'                                    e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Ldtoken:                          stack.Push                              (new ExpressionStackEntry(new MethodHandleConstantExpression(compEnv.SubstituteMember(methodi.Method))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case TypeOp.Stobj:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case TypeOp.Cpobj:                          {                              var copyEffect = instruction.BeforeState.PeekPointsTo(0).ReadEffect().Lub                                  (instruction.BeforeState.PeekPointsTo(1).WriteEffect());                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   copyEffect'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new WriteExpression(a[0]' new ReadExpression(a[1]).CloneIfStruct(compEnv)))));                          }                      case TypeOp.Newarr:                          // Growing the heap is not considered an observable change. But will throw if                          // length < 0                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new NewArrayExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Initobj:                          return stack.PopEvalSE                              (statements' 1' true' WriteHeapE' (s' a) => s.Add(new InitializeObjectStatement(a[0])));                      case TypeOp.Castclass:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new CastExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Isinst:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new IsInstExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Box:                          // Growing the heap is not considered an observable change                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new NewBoxExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Unbox:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).AddressOf()' e.Lub(ThrowsE)));                      case TypeOp.UnboxAny:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).Read().CloneIfStruct(compEnv)' e.Lub(ThrowsE)));                      case TypeOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new TypeHandleConstantExpression(compEnv.SubstituteType(typei.Type))' BottomE));                          return true;                      case TypeOp.Ldelem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case TypeOp.Stelem:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add(new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  // Calculating the pointer may throw if index is out of range.                  // Remaining effect will be accounted for when pointer is read/written.                  return stack.PopEvalPush                      (statements'                       2'                       true'                       (a' e) =>                       new ExpressionStackEntry(new ElementCell(a[0]' a[1]' false).AddressOf()' e.Lub(ThrowsE)));              case InstructionFlavor.LdInt32:                  {                      var int32i = (LdInt32Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int32ConstantExpression(int32i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdInt64:                  {                      var int64i = (LdInt64Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int64ConstantExpression(int64i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdSingle:                  {                      var singlei = (LdSingleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new SingleConstantExpression(singlei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdDouble:                  {                      var doublei = (LdDoubleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new DoubleConstantExpression(doublei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdString:                  {                      var stringi = (LdStringInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new StringConstantExpression(stringi.Value)' BottomE));                      return true;                  }              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Div:                      case ArithOp.Rem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(ThrowsE)));                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                      case ArithOp.Shl:                      case ArithOp.Shr:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(arithi.WithOverflow ? ThrowsE : BottomE)));                      case ArithOp.Neg:                      case ArithOp.BitNot:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression                                        (a[0]' ArithOpToUnaryOp(arithi.Op)' arithi.WithOverflow' arithi.IsUnsigned)'                                    e));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      return stack.PopEvalPush                          (statements'                           1'                           true'                           (a' e) =>                           new ExpressionStackEntry                               (new ConvertExpression                                    (a[0]'                                     new NamedTypeRef                                         (compEnv.Global.NumberFlavorToQualifiedTypeName[convi.TargetNumberFlavor])'                                     convi.WithOverflow'                                     convi.IsSourceUnsigned)'                                e.Lub(convi.WithOverflow ? ThrowsE : BottomE)));                  }              case InstructionFlavor.Try:                  {                      if (stack.Depth > 0)                          throw new InvalidOperationException("stack must be empty on entry to try block");                      var tryi = (TryInstruction)instruction;                      var tryStatements = BlockToTryFaultFinallyStatements(tryi.Body);                      if (tryStatements == null)                          return false;                      var handlers = TranslateHandlers(tryi.Handlers);                      if (handlers == null)                          return false;                      if (statements == null)                          return Failed(false' "try");                      statements.Add(new TryStatement(tryStatements' handlers));                      return true;                  }              case InstructionFlavor.IfThenElsePseudo:                  {                      var itei = (IfThenElseInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(itei.Offset' out isExpr) ||                                              isExpr;                        if (!TranslateBlock(statements' itei.Condition' stack' exid))                          return false;                      if (couldBeExpression && itei.Else != null)                      {                          // Pass 1: Try to tranlate to an if-then-else expression. Will only work if Then and Else don't                          //         reach into current stack' push exactly one value' and don't need to emit any                          //         statements along the way.                          var thenEntry = BlockToExpression(itei.Then' exid);                          if (thenEntry != null)                          {                              var elseEntry = BlockToExpression(itei.Else' exid);                              if (elseEntry != null)                              {                                  if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                                      instructionTranslationStyleCache.Add(itei.Offset' true);                                  return stack.PopEvalPush                                      (statements'                                       1'                                       true'                                       (a' e) =>                                       new ExpressionStackEntry                                           (new IfThenElseExpression(a[0]' thenEntry.Expression' elseEntry.Expression)'                                            e.Lub(thenEntry.Effects.Lub(elseEntry.Effects))));                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      var noStackChange = itei.Then.NoStackChange && (itei.Else == null || itei.Else.NoStackChange);                      var condEntry = noStackChange                                          ? stack.Pop()                                          : stack.FlushAndPopPostState(statements' itei.Then.BeforeState);                      if (condEntry == null)                          return false;                      var thenStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Then' exid)                                           : BlockToStatements(itei.Then' exid);                      if (thenStmnts == null)                          return false;                      var elseStmnts = default(Seq<Statement>);                      if (itei.Else != null)                      {                          elseStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Else' exid)                                           : BlockToStatements(itei.Else' exid);                          if (elseStmnts == null)                              return false;                      }                      if (statements == null)                          return Failed(false' "if-then-else");                      statements.Add                          (new IfThenElseStatement(condEntry.Expression' new Statements(thenStmnts)' elseStmnts == null ? null : new Statements(elseStmnts)));                      if (!noStackChange && !stack.Restore(itei.AfterState' 0))                          return false;                      if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                          instructionTranslationStyleCache.Add(itei.Offset' false);                      return true;                  }              case InstructionFlavor.ShortCircuitingPseudo:                  {                      var sci = (ShortCircuitingInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(sci.Offset' out isExpr) ||                                              isExpr;                      if (couldBeExpression)                      {                          // Pass 1: Try to translate to an expression.                          var leftEntry = BlockToExpression(sci.Left' exid);                          if (leftEntry != null)                          {                              var rightEntry = BlockToExpression(sci.Right' exid);                              if (rightEntry != null)                              {                                  stack.Push                                      (new ExpressionStackEntry                                           (new BinaryExpression                                                (leftEntry.Expression'                                                 ShortCircuitingOpToBinaryOp(sci.Op)'                                                 rightEntry.Expression'                                                 false'                                                 false)'                                            leftEntry.Effects.Lub(rightEntry.Effects)));                                  if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                                      instructionTranslationStyleCache.Add(sci.Offset' true);                                  return true;                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      if (!TranslateBlock(statements' sci.Left' stack' exid))                          return false;                      var leftEntry2 = stack.FlushAndPopPostState(statements' sci.Right.BeforeState);                      if (leftEntry2 == null)                          return false;                      var rightStatements = BlockToStatements(sci.Right' exid);                      if (rightStatements == null)                          return false;                      var id = sci.Right.AfterState.PeekId(0' nameSupply.GenSym);                      var cell = new VariableCell(id);                      compEnv.AddVariable(id' ArgLocal.Local' false' true' compEnv.SubstituteType(sci.Right.AfterState.PeekType(0)));                      if (statements == null)                          return Failed(false' "short-circuit");                      switch (sci.Op)                      {                      case ShortCircuitingOp.And:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements(rightStatements)'                                    new Statements                                        (new ExpressionStatement(cell.Write(new Int32ConstantExpression(0))))));                          break;                      case ShortCircuitingOp.Or:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements                                        (new ExpressionStatement                                             (cell.Write(new Int32ConstantExpression(1))))'                                    new Statements(rightStatements)));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      if (!stack.Restore(sci.AfterState' 1))                          return false;                      stack.Push(new ExpressionStackEntry(cell.Read()' BottomE));                      if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                          instructionTranslationStyleCache.Add(sci.Offset' false);                      return true;                  }              case InstructionFlavor.StructuralSwitchPseudo:                  {                      var ssi = (StructuralSwitchInstruction)instruction;                      if (!TranslateBlock(statements' ssi.Body' stack' exid))                          return false;                      var valueEntry = stack.FlushAndPopPreState(statements' ssi.Body.AfterState);                      if (valueEntry == null)                          return false;                      var cases = new Seq<SwitchStatementCase>();                      foreach (var c in ssi.Cases)                      {                          var caseStatements = BlockToStatements(c.Body' exid);                          if (caseStatements == null)                              return false;                          cases.Add(new SwitchStatementCase(c.Values' new Statements(caseStatements)));                      }                      if (statements == null)                          return Failed(false' "structural switch");                      statements.Add(new SwitchStatement(valueEntry.Expression' cases));                      if (!stack.Restore(ssi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopPseudo:                  {                      var li = (LoopInstruction)instruction;                      if (!stack.Flush(statements' li.Body.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop");                      var whileStatements = BlockToStatements(li.Body' exid);                      statements.Add                          (new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(whileStatements)));                      if (!stack.Restore(li.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.WhileDoPseudo:                  {                      var wdi = (WhileDoInstruction)instruction;                      if (!stack.Flush(statements' wdi.Condition.BeforeState))                          return false;                      var condEntry = BlockToExpression(wdi.Condition' exid);                      if (condEntry == null)                      {                          var stack1 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Condition.BeforeState' trace);                          var preCondStatements = new Seq<Statement>();                          if (!TranslateBlock(preCondStatements' wdi.Condition' stack1' exid))                              return false;                          condEntry = stack1.FlushAndPopPostState(preCondStatements' wdi.Body.BeforeState);                          if (condEntry == null)                              return false;                          var stack2 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Body.BeforeState' trace);                          var postCondStatements = new Seq<Statement>();                          if (!TranslateBlock(postCondStatements' wdi.Body' stack2' exid))                              return false;                          if (!stack2.Flush(postCondStatements' wdi.Body.AfterState))                              return false;                          preCondStatements.Add                              (new IfThenElseStatement                                   (condEntry.Expression'                                    new Statements(postCondStatements)'                                    new Statements(new BreakStatement())));                          statements.Add(new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(preCondStatements)));                      }                      else                      {                          var loopStatements = BlockToStatements(wdi.Body' exid);                          if (loopStatements == null)                              return false;                          if (statements == null)                              return Failed(false' "while-do");                          statements.Add(new WhileDoStatement(condEntry.Expression' new Statements(loopStatements)));                      }                      if (!stack.Restore(wdi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.DoWhilePseudo:                  {                      var dwi = (DoWhileInstruction)instruction;                      if (!stack.Flush(statements' dwi.Body.BeforeState))                          return false;                      var combined = new Seq<Instruction>();                      foreach (var i in dwi.Body.Body)                          combined.Add(i);                      foreach (var i in dwi.Condition.Body)                          combined.Add(i);                      var condEntry = default(ExpressionStackEntry);                      var loopStatements = BlockToConditionStatements                          (new Instructions(null' combined)' dwi.Body.BeforeState' exid' out condEntry);                      if (loopStatements == null)                          return false;                      if (statements == null)                          return Failed(false' "do-while");                      statements.Add(new DoWhileStatement(new Statements(loopStatements)' condEntry.Expression));                      if (!stack.Restore(dwi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopControlPseudo:                  {                      var lci = (BreakContinueInstruction)instruction;                      if (!stack.Flush(statements' lci.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop-control");                      var targetState = default(int);                      switch (lci.Op)                      {                      case BreakContinueOp.Break:                          if (labelToLoopCandidateBreakState != null &&                              labelToLoopCandidateBreakState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new BreakStatement(lci.Label));                          break;                      case BreakContinueOp.Continue:                          if (labelToLoopCandidateContinueState != null &&                              labelToLoopCandidateContinueState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new ContinueStatement(lci.Label));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      return true;                  }              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return true;                      case MiscOp.Dup:                          return stack.Dup(statements);                      case MiscOp.Pop:                          return stack.PopAndDiscard(statements);                      case MiscOp.Ldnull:                          stack.Push(new ExpressionStackEntry(new NullConstantExpression()' BottomE));                          return true;                      case MiscOp.Ckfinite:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.CheckFinite' false' false)' e.Lub(ThrowsE)));                      case MiscOp.Throw:                          if (!stack.DiscardAll(statements' 1))                              return false;                          if (!stack.PopEvalSE(statements' 1' true' ThrowsE' (s' a) => s.Add(new ThrowStatement(a[0]))))                              return false;                          return true;                      case MiscOp.Rethrow:                          if (!stack.DiscardAll(statements' 0))                              return false;                          if (statements == null)                              return Failed(false' "rethrow");                          if (exid == null)                              throw new InvalidOperationException("rethrow outside of catch");                          statements.Add(new RethrowStatement(new VariableCell(exid).Read()));                          return true;                      case MiscOp.LdindRef:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case MiscOp.LdelemRef:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.Ldlen:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.Length' false' false)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.StindRef:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case MiscOp.StelemRef:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add                                   (new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      case MiscOp.Ret:                          if (statements == null)                              return Failed(false' "return");                          statements.Add(new ReturnStatement(null));                          return true;                      case MiscOp.RetVal:                          return stack.PopEvalSE                              (statements' 1' true' BottomE' (s' a) => s.Add(new ReturnStatement(a[0])));                      case MiscOp.Endfilter:                      case MiscOp.Endfinally:                          throw new InvalidOperationException                              ("endfilter/endfinally instructions should have been removed");                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:              case InstructionFlavor.Switch:                  throw new InvalidOperationException("branch/switch instructions should have been removed");              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      if (cmpi.Op == CompareOp.CtruePseudo || cmpi.Op == CompareOp.CfalsePseudo)                      {                          var s = cmpi.Type.Style(compEnv);                          var unop = default(UnaryOp);                          if (s is NumberTypeStyle)                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonZero : UnaryOp.IsZero;                          else                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonNull : UnaryOp.IsNull;                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new UnaryExpression(a[0]' unop' false' cmpi.IsUnsigned)' e));                      }                      else                      {                          var binop = default(BinaryOp);                          switch (cmpi.Op)                          {                          case CompareOp.Ceq:                              binop = BinaryOp.Eq;                              break;                          case CompareOp.Clt:                              binop = BinaryOp.Lt;                              break;                          case CompareOp.Cgt:                              binop = BinaryOp.Gt;                              break;                          case CompareOp.CgePseudo:                              binop = BinaryOp.Ge;                              break;                          case CompareOp.ClePseudo:                              binop = BinaryOp.Le;                              break;                          case CompareOp.CnePseudo:                              binop = BinaryOp.Ne;                              break;                          case CompareOp.CtruePseudo:                          case CompareOp.CfalsePseudo:                              // handled above                              throw new InvalidOperationException();                          default:                              throw new ArgumentOutOfRangeException();                          }                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression(a[0]' binop' a[1]' false' cmpi.IsUnsigned)' e));                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var sli = (ArgLocalInstruction)instruction;                      var id = default(JST.Identifier);                      switch (sli.ArgLocal)                      {                      case ArgLocal.Arg:                          id = compEnv.ValueParameterIds[sli.Index];                          break;                      case ArgLocal.Local:                          id = compEnv.LocalIds[sli.Index];                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      var cell = new VariableCell(id);                      switch (sli.Op)                      {                      case ArgLocalOp.Ld:                          stack.Push                              (new ExpressionStackEntry                                   (cell.Read().CloneIfStruct(compEnv)' ReadArgLocalE(sli.ArgLocal' sli.Index)));                          return true;                      case ArgLocalOp.Lda:                          // Effect will be accounted for on reads/writes                          stack.Push(new ExpressionStackEntry(cell.AddressOf()' BottomE));                          return true;                      case ArgLocalOp.St:                          return stack.PopEvalSE                              (statements'                               1'                               true'                               WriteArgLocalE(sli.ArgLocal' sli.Index)'                               (s' a) => s.Add(new ExpressionStatement(cell.Write(a[0]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                          {                              stack.Push                                  (new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' ReadHeapE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                       {                                           var readEffect = default(Effects);                                           var obj = default(Expression);                                           if (fieldi.IsViaPointer.Value)                                           {                                               readEffect = e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect());                                               obj = new ReadExpression(a[0]); // no need for clone                                           }                                           else if (fieldi.Field.DefiningType.Style(compEnv) is ValueTypeStyle)                                           {                                               readEffect = e;                                               obj = a[0];                                           }                                           else                                           {                                               // Object could be null                                               readEffect = e.Lub(ReadHeapOrThrowE);                                               obj = a[0];                                           }                                           return new ExpressionStackEntry(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' readEffect);                                       });                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                          {                              // Effect will be accounted for on reads/writes                              stack.Push(new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' BottomE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   {                                       if (fieldi.IsViaPointer.Value)                                           // We're just adding an offset to a pointer' so effect will                                           // be accounted for when the final pointer is read/written                                           return new ExpressionStackEntry(new FieldCell(new ReadExpression(a[0])' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e);                                       else                                           // Must be a reference type' and ref could be null                                           return new ExpressionStackEntry(new FieldCell(a[0]' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e.Lub(ThrowsE));                                   });                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                              return stack.PopEvalSE                                  (statements'                                   1'                                   true'                                   WriteHeapE'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Write(a[0]))));                          else                          {                              var writeEffect = fieldi.IsViaPointer.Value                                                    ? instruction.BeforeState.PeekPointsTo(1).WriteEffect()                                                    : WriteHeapOrThrowE;                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   writeEffect'                                   (s' a) =>                                       {                                           var obj = fieldi.IsViaPointer.Value ? new ReadExpression(a[0]) : a[0];                                           s.Add(new ExpressionStatement(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Write(a[1])));                                       });                          }                      case FieldOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new FieldHandleConstantExpression(compEnv.SubstituteMember(fieldi.Field))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methodi = (MethodInstruction)instruction;                      var arity = methodi.Method.ValueParameters.Count;                      switch (methodi.Op)                      {                      case MethodOp.Ldftn:                          if (methodi.IsVirtual)                              // Object could be null                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CodePointerExpression(a[0]' compEnv.SubstituteMember(methodi.Method))' e.Lub(ReadHeapOrThrowE)));                          else                          {                              stack.Push                                  (new ExpressionStackEntry(new CodePointerExpression(null' compEnv.SubstituteMember(methodi.Method))' BottomE));                              return true;                          }                      case MethodOp.Call:                          if (methodi.Method.Result == null)                              return stack.PopEvalSE                                  (statements'                                   arity'                                   true'                                   CalleeEffects(methodi.BeforeState' arity)'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new CallExpression                                                 (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal'                                                  compEnv.SubstituteMember(methodi.Method)'                                                  CallerArguments(methodi.Constrained' methodi.Method' a)))));                          else                              return stack.PopEvalPush                                  (statements'                                   arity'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CallExpression                                            (methodi.IsVirtual? CallFlavor.Virtual : CallFlavor.Normal'                                             compEnv.SubstituteMember(methodi.Method)'                                             CallerArguments(methodi.Constrained' methodi.Method' a))'                                        e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Newobj:                          arity--;                          return stack.PopEvalPush                              (statements'                               arity'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new NewObjectExpression(compEnv.SubstituteMember(methodi.Method)' CallerArguments(null' methodi.Method' a))'                                    e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Ldtoken:                          stack.Push                              (new ExpressionStackEntry(new MethodHandleConstantExpression(compEnv.SubstituteMember(methodi.Method))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case TypeOp.Stobj:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case TypeOp.Cpobj:                          {                              var copyEffect = instruction.BeforeState.PeekPointsTo(0).ReadEffect().Lub                                  (instruction.BeforeState.PeekPointsTo(1).WriteEffect());                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   copyEffect'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new WriteExpression(a[0]' new ReadExpression(a[1]).CloneIfStruct(compEnv)))));                          }                      case TypeOp.Newarr:                          // Growing the heap is not considered an observable change. But will throw if                          // length < 0                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new NewArrayExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Initobj:                          return stack.PopEvalSE                              (statements' 1' true' WriteHeapE' (s' a) => s.Add(new InitializeObjectStatement(a[0])));                      case TypeOp.Castclass:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new CastExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Isinst:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new IsInstExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Box:                          // Growing the heap is not considered an observable change                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new NewBoxExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Unbox:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).AddressOf()' e.Lub(ThrowsE)));                      case TypeOp.UnboxAny:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).Read().CloneIfStruct(compEnv)' e.Lub(ThrowsE)));                      case TypeOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new TypeHandleConstantExpression(compEnv.SubstituteType(typei.Type))' BottomE));                          return true;                      case TypeOp.Ldelem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case TypeOp.Stelem:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add(new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  // Calculating the pointer may throw if index is out of range.                  // Remaining effect will be accounted for when pointer is read/written.                  return stack.PopEvalPush                      (statements'                       2'                       true'                       (a' e) =>                       new ExpressionStackEntry(new ElementCell(a[0]' a[1]' false).AddressOf()' e.Lub(ThrowsE)));              case InstructionFlavor.LdInt32:                  {                      var int32i = (LdInt32Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int32ConstantExpression(int32i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdInt64:                  {                      var int64i = (LdInt64Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int64ConstantExpression(int64i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdSingle:                  {                      var singlei = (LdSingleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new SingleConstantExpression(singlei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdDouble:                  {                      var doublei = (LdDoubleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new DoubleConstantExpression(doublei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdString:                  {                      var stringi = (LdStringInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new StringConstantExpression(stringi.Value)' BottomE));                      return true;                  }              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Div:                      case ArithOp.Rem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(ThrowsE)));                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                      case ArithOp.Shl:                      case ArithOp.Shr:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(arithi.WithOverflow ? ThrowsE : BottomE)));                      case ArithOp.Neg:                      case ArithOp.BitNot:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression                                        (a[0]' ArithOpToUnaryOp(arithi.Op)' arithi.WithOverflow' arithi.IsUnsigned)'                                    e));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      return stack.PopEvalPush                          (statements'                           1'                           true'                           (a' e) =>                           new ExpressionStackEntry                               (new ConvertExpression                                    (a[0]'                                     new NamedTypeRef                                         (compEnv.Global.NumberFlavorToQualifiedTypeName[convi.TargetNumberFlavor])'                                     convi.WithOverflow'                                     convi.IsSourceUnsigned)'                                e.Lub(convi.WithOverflow ? ThrowsE : BottomE)));                  }              case InstructionFlavor.Try:                  {                      if (stack.Depth > 0)                          throw new InvalidOperationException("stack must be empty on entry to try block");                      var tryi = (TryInstruction)instruction;                      var tryStatements = BlockToTryFaultFinallyStatements(tryi.Body);                      if (tryStatements == null)                          return false;                      var handlers = TranslateHandlers(tryi.Handlers);                      if (handlers == null)                          return false;                      if (statements == null)                          return Failed(false' "try");                      statements.Add(new TryStatement(tryStatements' handlers));                      return true;                  }              case InstructionFlavor.IfThenElsePseudo:                  {                      var itei = (IfThenElseInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(itei.Offset' out isExpr) ||                                              isExpr;                        if (!TranslateBlock(statements' itei.Condition' stack' exid))                          return false;                      if (couldBeExpression && itei.Else != null)                      {                          // Pass 1: Try to tranlate to an if-then-else expression. Will only work if Then and Else don't                          //         reach into current stack' push exactly one value' and don't need to emit any                          //         statements along the way.                          var thenEntry = BlockToExpression(itei.Then' exid);                          if (thenEntry != null)                          {                              var elseEntry = BlockToExpression(itei.Else' exid);                              if (elseEntry != null)                              {                                  if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                                      instructionTranslationStyleCache.Add(itei.Offset' true);                                  return stack.PopEvalPush                                      (statements'                                       1'                                       true'                                       (a' e) =>                                       new ExpressionStackEntry                                           (new IfThenElseExpression(a[0]' thenEntry.Expression' elseEntry.Expression)'                                            e.Lub(thenEntry.Effects.Lub(elseEntry.Effects))));                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      var noStackChange = itei.Then.NoStackChange && (itei.Else == null || itei.Else.NoStackChange);                      var condEntry = noStackChange                                          ? stack.Pop()                                          : stack.FlushAndPopPostState(statements' itei.Then.BeforeState);                      if (condEntry == null)                          return false;                      var thenStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Then' exid)                                           : BlockToStatements(itei.Then' exid);                      if (thenStmnts == null)                          return false;                      var elseStmnts = default(Seq<Statement>);                      if (itei.Else != null)                      {                          elseStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Else' exid)                                           : BlockToStatements(itei.Else' exid);                          if (elseStmnts == null)                              return false;                      }                      if (statements == null)                          return Failed(false' "if-then-else");                      statements.Add                          (new IfThenElseStatement(condEntry.Expression' new Statements(thenStmnts)' elseStmnts == null ? null : new Statements(elseStmnts)));                      if (!noStackChange && !stack.Restore(itei.AfterState' 0))                          return false;                      if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                          instructionTranslationStyleCache.Add(itei.Offset' false);                      return true;                  }              case InstructionFlavor.ShortCircuitingPseudo:                  {                      var sci = (ShortCircuitingInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(sci.Offset' out isExpr) ||                                              isExpr;                      if (couldBeExpression)                      {                          // Pass 1: Try to translate to an expression.                          var leftEntry = BlockToExpression(sci.Left' exid);                          if (leftEntry != null)                          {                              var rightEntry = BlockToExpression(sci.Right' exid);                              if (rightEntry != null)                              {                                  stack.Push                                      (new ExpressionStackEntry                                           (new BinaryExpression                                                (leftEntry.Expression'                                                 ShortCircuitingOpToBinaryOp(sci.Op)'                                                 rightEntry.Expression'                                                 false'                                                 false)'                                            leftEntry.Effects.Lub(rightEntry.Effects)));                                  if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                                      instructionTranslationStyleCache.Add(sci.Offset' true);                                  return true;                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      if (!TranslateBlock(statements' sci.Left' stack' exid))                          return false;                      var leftEntry2 = stack.FlushAndPopPostState(statements' sci.Right.BeforeState);                      if (leftEntry2 == null)                          return false;                      var rightStatements = BlockToStatements(sci.Right' exid);                      if (rightStatements == null)                          return false;                      var id = sci.Right.AfterState.PeekId(0' nameSupply.GenSym);                      var cell = new VariableCell(id);                      compEnv.AddVariable(id' ArgLocal.Local' false' true' compEnv.SubstituteType(sci.Right.AfterState.PeekType(0)));                      if (statements == null)                          return Failed(false' "short-circuit");                      switch (sci.Op)                      {                      case ShortCircuitingOp.And:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements(rightStatements)'                                    new Statements                                        (new ExpressionStatement(cell.Write(new Int32ConstantExpression(0))))));                          break;                      case ShortCircuitingOp.Or:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements                                        (new ExpressionStatement                                             (cell.Write(new Int32ConstantExpression(1))))'                                    new Statements(rightStatements)));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      if (!stack.Restore(sci.AfterState' 1))                          return false;                      stack.Push(new ExpressionStackEntry(cell.Read()' BottomE));                      if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                          instructionTranslationStyleCache.Add(sci.Offset' false);                      return true;                  }              case InstructionFlavor.StructuralSwitchPseudo:                  {                      var ssi = (StructuralSwitchInstruction)instruction;                      if (!TranslateBlock(statements' ssi.Body' stack' exid))                          return false;                      var valueEntry = stack.FlushAndPopPreState(statements' ssi.Body.AfterState);                      if (valueEntry == null)                          return false;                      var cases = new Seq<SwitchStatementCase>();                      foreach (var c in ssi.Cases)                      {                          var caseStatements = BlockToStatements(c.Body' exid);                          if (caseStatements == null)                              return false;                          cases.Add(new SwitchStatementCase(c.Values' new Statements(caseStatements)));                      }                      if (statements == null)                          return Failed(false' "structural switch");                      statements.Add(new SwitchStatement(valueEntry.Expression' cases));                      if (!stack.Restore(ssi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopPseudo:                  {                      var li = (LoopInstruction)instruction;                      if (!stack.Flush(statements' li.Body.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop");                      var whileStatements = BlockToStatements(li.Body' exid);                      statements.Add                          (new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(whileStatements)));                      if (!stack.Restore(li.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.WhileDoPseudo:                  {                      var wdi = (WhileDoInstruction)instruction;                      if (!stack.Flush(statements' wdi.Condition.BeforeState))                          return false;                      var condEntry = BlockToExpression(wdi.Condition' exid);                      if (condEntry == null)                      {                          var stack1 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Condition.BeforeState' trace);                          var preCondStatements = new Seq<Statement>();                          if (!TranslateBlock(preCondStatements' wdi.Condition' stack1' exid))                              return false;                          condEntry = stack1.FlushAndPopPostState(preCondStatements' wdi.Body.BeforeState);                          if (condEntry == null)                              return false;                          var stack2 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Body.BeforeState' trace);                          var postCondStatements = new Seq<Statement>();                          if (!TranslateBlock(postCondStatements' wdi.Body' stack2' exid))                              return false;                          if (!stack2.Flush(postCondStatements' wdi.Body.AfterState))                              return false;                          preCondStatements.Add                              (new IfThenElseStatement                                   (condEntry.Expression'                                    new Statements(postCondStatements)'                                    new Statements(new BreakStatement())));                          statements.Add(new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(preCondStatements)));                      }                      else                      {                          var loopStatements = BlockToStatements(wdi.Body' exid);                          if (loopStatements == null)                              return false;                          if (statements == null)                              return Failed(false' "while-do");                          statements.Add(new WhileDoStatement(condEntry.Expression' new Statements(loopStatements)));                      }                      if (!stack.Restore(wdi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.DoWhilePseudo:                  {                      var dwi = (DoWhileInstruction)instruction;                      if (!stack.Flush(statements' dwi.Body.BeforeState))                          return false;                      var combined = new Seq<Instruction>();                      foreach (var i in dwi.Body.Body)                          combined.Add(i);                      foreach (var i in dwi.Condition.Body)                          combined.Add(i);                      var condEntry = default(ExpressionStackEntry);                      var loopStatements = BlockToConditionStatements                          (new Instructions(null' combined)' dwi.Body.BeforeState' exid' out condEntry);                      if (loopStatements == null)                          return false;                      if (statements == null)                          return Failed(false' "do-while");                      statements.Add(new DoWhileStatement(new Statements(loopStatements)' condEntry.Expression));                      if (!stack.Restore(dwi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopControlPseudo:                  {                      var lci = (BreakContinueInstruction)instruction;                      if (!stack.Flush(statements' lci.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop-control");                      var targetState = default(int);                      switch (lci.Op)                      {                      case BreakContinueOp.Break:                          if (labelToLoopCandidateBreakState != null &&                              labelToLoopCandidateBreakState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new BreakStatement(lci.Label));                          break;                      case BreakContinueOp.Continue:                          if (labelToLoopCandidateContinueState != null &&                              labelToLoopCandidateContinueState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new ContinueStatement(lci.Label));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      return true;                  }              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return true;                      case MiscOp.Dup:                          return stack.Dup(statements);                      case MiscOp.Pop:                          return stack.PopAndDiscard(statements);                      case MiscOp.Ldnull:                          stack.Push(new ExpressionStackEntry(new NullConstantExpression()' BottomE));                          return true;                      case MiscOp.Ckfinite:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.CheckFinite' false' false)' e.Lub(ThrowsE)));                      case MiscOp.Throw:                          if (!stack.DiscardAll(statements' 1))                              return false;                          if (!stack.PopEvalSE(statements' 1' true' ThrowsE' (s' a) => s.Add(new ThrowStatement(a[0]))))                              return false;                          return true;                      case MiscOp.Rethrow:                          if (!stack.DiscardAll(statements' 0))                              return false;                          if (statements == null)                              return Failed(false' "rethrow");                          if (exid == null)                              throw new InvalidOperationException("rethrow outside of catch");                          statements.Add(new RethrowStatement(new VariableCell(exid).Read()));                          return true;                      case MiscOp.LdindRef:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case MiscOp.LdelemRef:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.Ldlen:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.Length' false' false)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.StindRef:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case MiscOp.StelemRef:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add                                   (new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      case MiscOp.Ret:                          if (statements == null)                              return Failed(false' "return");                          statements.Add(new ReturnStatement(null));                          return true;                      case MiscOp.RetVal:                          return stack.PopEvalSE                              (statements' 1' true' BottomE' (s' a) => s.Add(new ReturnStatement(a[0])));                      case MiscOp.Endfilter:                      case MiscOp.Endfinally:                          throw new InvalidOperationException                              ("endfilter/endfinally instructions should have been removed");                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:              case InstructionFlavor.Switch:                  throw new InvalidOperationException("branch/switch instructions should have been removed");              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      if (cmpi.Op == CompareOp.CtruePseudo || cmpi.Op == CompareOp.CfalsePseudo)                      {                          var s = cmpi.Type.Style(compEnv);                          var unop = default(UnaryOp);                          if (s is NumberTypeStyle)                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonZero : UnaryOp.IsZero;                          else                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonNull : UnaryOp.IsNull;                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new UnaryExpression(a[0]' unop' false' cmpi.IsUnsigned)' e));                      }                      else                      {                          var binop = default(BinaryOp);                          switch (cmpi.Op)                          {                          case CompareOp.Ceq:                              binop = BinaryOp.Eq;                              break;                          case CompareOp.Clt:                              binop = BinaryOp.Lt;                              break;                          case CompareOp.Cgt:                              binop = BinaryOp.Gt;                              break;                          case CompareOp.CgePseudo:                              binop = BinaryOp.Ge;                              break;                          case CompareOp.ClePseudo:                              binop = BinaryOp.Le;                              break;                          case CompareOp.CnePseudo:                              binop = BinaryOp.Ne;                              break;                          case CompareOp.CtruePseudo:                          case CompareOp.CfalsePseudo:                              // handled above                              throw new InvalidOperationException();                          default:                              throw new ArgumentOutOfRangeException();                          }                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression(a[0]' binop' a[1]' false' cmpi.IsUnsigned)' e));                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var sli = (ArgLocalInstruction)instruction;                      var id = default(JST.Identifier);                      switch (sli.ArgLocal)                      {                      case ArgLocal.Arg:                          id = compEnv.ValueParameterIds[sli.Index];                          break;                      case ArgLocal.Local:                          id = compEnv.LocalIds[sli.Index];                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      var cell = new VariableCell(id);                      switch (sli.Op)                      {                      case ArgLocalOp.Ld:                          stack.Push                              (new ExpressionStackEntry                                   (cell.Read().CloneIfStruct(compEnv)' ReadArgLocalE(sli.ArgLocal' sli.Index)));                          return true;                      case ArgLocalOp.Lda:                          // Effect will be accounted for on reads/writes                          stack.Push(new ExpressionStackEntry(cell.AddressOf()' BottomE));                          return true;                      case ArgLocalOp.St:                          return stack.PopEvalSE                              (statements'                               1'                               true'                               WriteArgLocalE(sli.ArgLocal' sli.Index)'                               (s' a) => s.Add(new ExpressionStatement(cell.Write(a[0]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                          {                              stack.Push                                  (new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' ReadHeapE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                       {                                           var readEffect = default(Effects);                                           var obj = default(Expression);                                           if (fieldi.IsViaPointer.Value)                                           {                                               readEffect = e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect());                                               obj = new ReadExpression(a[0]); // no need for clone                                           }                                           else if (fieldi.Field.DefiningType.Style(compEnv) is ValueTypeStyle)                                           {                                               readEffect = e;                                               obj = a[0];                                           }                                           else                                           {                                               // Object could be null                                               readEffect = e.Lub(ReadHeapOrThrowE);                                               obj = a[0];                                           }                                           return new ExpressionStackEntry(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' readEffect);                                       });                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                          {                              // Effect will be accounted for on reads/writes                              stack.Push(new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' BottomE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   {                                       if (fieldi.IsViaPointer.Value)                                           // We're just adding an offset to a pointer' so effect will                                           // be accounted for when the final pointer is read/written                                           return new ExpressionStackEntry(new FieldCell(new ReadExpression(a[0])' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e);                                       else                                           // Must be a reference type' and ref could be null                                           return new ExpressionStackEntry(new FieldCell(a[0]' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e.Lub(ThrowsE));                                   });                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                              return stack.PopEvalSE                                  (statements'                                   1'                                   true'                                   WriteHeapE'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Write(a[0]))));                          else                          {                              var writeEffect = fieldi.IsViaPointer.Value                                                    ? instruction.BeforeState.PeekPointsTo(1).WriteEffect()                                                    : WriteHeapOrThrowE;                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   writeEffect'                                   (s' a) =>                                       {                                           var obj = fieldi.IsViaPointer.Value ? new ReadExpression(a[0]) : a[0];                                           s.Add(new ExpressionStatement(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Write(a[1])));                                       });                          }                      case FieldOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new FieldHandleConstantExpression(compEnv.SubstituteMember(fieldi.Field))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methodi = (MethodInstruction)instruction;                      var arity = methodi.Method.ValueParameters.Count;                      switch (methodi.Op)                      {                      case MethodOp.Ldftn:                          if (methodi.IsVirtual)                              // Object could be null                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CodePointerExpression(a[0]' compEnv.SubstituteMember(methodi.Method))' e.Lub(ReadHeapOrThrowE)));                          else                          {                              stack.Push                                  (new ExpressionStackEntry(new CodePointerExpression(null' compEnv.SubstituteMember(methodi.Method))' BottomE));                              return true;                          }                      case MethodOp.Call:                          if (methodi.Method.Result == null)                              return stack.PopEvalSE                                  (statements'                                   arity'                                   true'                                   CalleeEffects(methodi.BeforeState' arity)'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new CallExpression                                                 (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal'                                                  compEnv.SubstituteMember(methodi.Method)'                                                  CallerArguments(methodi.Constrained' methodi.Method' a)))));                          else                              return stack.PopEvalPush                                  (statements'                                   arity'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CallExpression                                            (methodi.IsVirtual? CallFlavor.Virtual : CallFlavor.Normal'                                             compEnv.SubstituteMember(methodi.Method)'                                             CallerArguments(methodi.Constrained' methodi.Method' a))'                                        e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Newobj:                          arity--;                          return stack.PopEvalPush                              (statements'                               arity'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new NewObjectExpression(compEnv.SubstituteMember(methodi.Method)' CallerArguments(null' methodi.Method' a))'                                    e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Ldtoken:                          stack.Push                              (new ExpressionStackEntry(new MethodHandleConstantExpression(compEnv.SubstituteMember(methodi.Method))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case TypeOp.Stobj:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case TypeOp.Cpobj:                          {                              var copyEffect = instruction.BeforeState.PeekPointsTo(0).ReadEffect().Lub                                  (instruction.BeforeState.PeekPointsTo(1).WriteEffect());                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   copyEffect'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new WriteExpression(a[0]' new ReadExpression(a[1]).CloneIfStruct(compEnv)))));                          }                      case TypeOp.Newarr:                          // Growing the heap is not considered an observable change. But will throw if                          // length < 0                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new NewArrayExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Initobj:                          return stack.PopEvalSE                              (statements' 1' true' WriteHeapE' (s' a) => s.Add(new InitializeObjectStatement(a[0])));                      case TypeOp.Castclass:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new CastExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Isinst:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new IsInstExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Box:                          // Growing the heap is not considered an observable change                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new NewBoxExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Unbox:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).AddressOf()' e.Lub(ThrowsE)));                      case TypeOp.UnboxAny:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).Read().CloneIfStruct(compEnv)' e.Lub(ThrowsE)));                      case TypeOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new TypeHandleConstantExpression(compEnv.SubstituteType(typei.Type))' BottomE));                          return true;                      case TypeOp.Ldelem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case TypeOp.Stelem:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add(new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  // Calculating the pointer may throw if index is out of range.                  // Remaining effect will be accounted for when pointer is read/written.                  return stack.PopEvalPush                      (statements'                       2'                       true'                       (a' e) =>                       new ExpressionStackEntry(new ElementCell(a[0]' a[1]' false).AddressOf()' e.Lub(ThrowsE)));              case InstructionFlavor.LdInt32:                  {                      var int32i = (LdInt32Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int32ConstantExpression(int32i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdInt64:                  {                      var int64i = (LdInt64Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int64ConstantExpression(int64i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdSingle:                  {                      var singlei = (LdSingleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new SingleConstantExpression(singlei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdDouble:                  {                      var doublei = (LdDoubleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new DoubleConstantExpression(doublei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdString:                  {                      var stringi = (LdStringInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new StringConstantExpression(stringi.Value)' BottomE));                      return true;                  }              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Div:                      case ArithOp.Rem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(ThrowsE)));                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                      case ArithOp.Shl:                      case ArithOp.Shr:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(arithi.WithOverflow ? ThrowsE : BottomE)));                      case ArithOp.Neg:                      case ArithOp.BitNot:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression                                        (a[0]' ArithOpToUnaryOp(arithi.Op)' arithi.WithOverflow' arithi.IsUnsigned)'                                    e));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      return stack.PopEvalPush                          (statements'                           1'                           true'                           (a' e) =>                           new ExpressionStackEntry                               (new ConvertExpression                                    (a[0]'                                     new NamedTypeRef                                         (compEnv.Global.NumberFlavorToQualifiedTypeName[convi.TargetNumberFlavor])'                                     convi.WithOverflow'                                     convi.IsSourceUnsigned)'                                e.Lub(convi.WithOverflow ? ThrowsE : BottomE)));                  }              case InstructionFlavor.Try:                  {                      if (stack.Depth > 0)                          throw new InvalidOperationException("stack must be empty on entry to try block");                      var tryi = (TryInstruction)instruction;                      var tryStatements = BlockToTryFaultFinallyStatements(tryi.Body);                      if (tryStatements == null)                          return false;                      var handlers = TranslateHandlers(tryi.Handlers);                      if (handlers == null)                          return false;                      if (statements == null)                          return Failed(false' "try");                      statements.Add(new TryStatement(tryStatements' handlers));                      return true;                  }              case InstructionFlavor.IfThenElsePseudo:                  {                      var itei = (IfThenElseInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(itei.Offset' out isExpr) ||                                              isExpr;                        if (!TranslateBlock(statements' itei.Condition' stack' exid))                          return false;                      if (couldBeExpression && itei.Else != null)                      {                          // Pass 1: Try to tranlate to an if-then-else expression. Will only work if Then and Else don't                          //         reach into current stack' push exactly one value' and don't need to emit any                          //         statements along the way.                          var thenEntry = BlockToExpression(itei.Then' exid);                          if (thenEntry != null)                          {                              var elseEntry = BlockToExpression(itei.Else' exid);                              if (elseEntry != null)                              {                                  if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                                      instructionTranslationStyleCache.Add(itei.Offset' true);                                  return stack.PopEvalPush                                      (statements'                                       1'                                       true'                                       (a' e) =>                                       new ExpressionStackEntry                                           (new IfThenElseExpression(a[0]' thenEntry.Expression' elseEntry.Expression)'                                            e.Lub(thenEntry.Effects.Lub(elseEntry.Effects))));                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      var noStackChange = itei.Then.NoStackChange && (itei.Else == null || itei.Else.NoStackChange);                      var condEntry = noStackChange                                          ? stack.Pop()                                          : stack.FlushAndPopPostState(statements' itei.Then.BeforeState);                      if (condEntry == null)                          return false;                      var thenStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Then' exid)                                           : BlockToStatements(itei.Then' exid);                      if (thenStmnts == null)                          return false;                      var elseStmnts = default(Seq<Statement>);                      if (itei.Else != null)                      {                          elseStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Else' exid)                                           : BlockToStatements(itei.Else' exid);                          if (elseStmnts == null)                              return false;                      }                      if (statements == null)                          return Failed(false' "if-then-else");                      statements.Add                          (new IfThenElseStatement(condEntry.Expression' new Statements(thenStmnts)' elseStmnts == null ? null : new Statements(elseStmnts)));                      if (!noStackChange && !stack.Restore(itei.AfterState' 0))                          return false;                      if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                          instructionTranslationStyleCache.Add(itei.Offset' false);                      return true;                  }              case InstructionFlavor.ShortCircuitingPseudo:                  {                      var sci = (ShortCircuitingInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(sci.Offset' out isExpr) ||                                              isExpr;                      if (couldBeExpression)                      {                          // Pass 1: Try to translate to an expression.                          var leftEntry = BlockToExpression(sci.Left' exid);                          if (leftEntry != null)                          {                              var rightEntry = BlockToExpression(sci.Right' exid);                              if (rightEntry != null)                              {                                  stack.Push                                      (new ExpressionStackEntry                                           (new BinaryExpression                                                (leftEntry.Expression'                                                 ShortCircuitingOpToBinaryOp(sci.Op)'                                                 rightEntry.Expression'                                                 false'                                                 false)'                                            leftEntry.Effects.Lub(rightEntry.Effects)));                                  if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                                      instructionTranslationStyleCache.Add(sci.Offset' true);                                  return true;                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      if (!TranslateBlock(statements' sci.Left' stack' exid))                          return false;                      var leftEntry2 = stack.FlushAndPopPostState(statements' sci.Right.BeforeState);                      if (leftEntry2 == null)                          return false;                      var rightStatements = BlockToStatements(sci.Right' exid);                      if (rightStatements == null)                          return false;                      var id = sci.Right.AfterState.PeekId(0' nameSupply.GenSym);                      var cell = new VariableCell(id);                      compEnv.AddVariable(id' ArgLocal.Local' false' true' compEnv.SubstituteType(sci.Right.AfterState.PeekType(0)));                      if (statements == null)                          return Failed(false' "short-circuit");                      switch (sci.Op)                      {                      case ShortCircuitingOp.And:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements(rightStatements)'                                    new Statements                                        (new ExpressionStatement(cell.Write(new Int32ConstantExpression(0))))));                          break;                      case ShortCircuitingOp.Or:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements                                        (new ExpressionStatement                                             (cell.Write(new Int32ConstantExpression(1))))'                                    new Statements(rightStatements)));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      if (!stack.Restore(sci.AfterState' 1))                          return false;                      stack.Push(new ExpressionStackEntry(cell.Read()' BottomE));                      if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                          instructionTranslationStyleCache.Add(sci.Offset' false);                      return true;                  }              case InstructionFlavor.StructuralSwitchPseudo:                  {                      var ssi = (StructuralSwitchInstruction)instruction;                      if (!TranslateBlock(statements' ssi.Body' stack' exid))                          return false;                      var valueEntry = stack.FlushAndPopPreState(statements' ssi.Body.AfterState);                      if (valueEntry == null)                          return false;                      var cases = new Seq<SwitchStatementCase>();                      foreach (var c in ssi.Cases)                      {                          var caseStatements = BlockToStatements(c.Body' exid);                          if (caseStatements == null)                              return false;                          cases.Add(new SwitchStatementCase(c.Values' new Statements(caseStatements)));                      }                      if (statements == null)                          return Failed(false' "structural switch");                      statements.Add(new SwitchStatement(valueEntry.Expression' cases));                      if (!stack.Restore(ssi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopPseudo:                  {                      var li = (LoopInstruction)instruction;                      if (!stack.Flush(statements' li.Body.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop");                      var whileStatements = BlockToStatements(li.Body' exid);                      statements.Add                          (new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(whileStatements)));                      if (!stack.Restore(li.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.WhileDoPseudo:                  {                      var wdi = (WhileDoInstruction)instruction;                      if (!stack.Flush(statements' wdi.Condition.BeforeState))                          return false;                      var condEntry = BlockToExpression(wdi.Condition' exid);                      if (condEntry == null)                      {                          var stack1 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Condition.BeforeState' trace);                          var preCondStatements = new Seq<Statement>();                          if (!TranslateBlock(preCondStatements' wdi.Condition' stack1' exid))                              return false;                          condEntry = stack1.FlushAndPopPostState(preCondStatements' wdi.Body.BeforeState);                          if (condEntry == null)                              return false;                          var stack2 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Body.BeforeState' trace);                          var postCondStatements = new Seq<Statement>();                          if (!TranslateBlock(postCondStatements' wdi.Body' stack2' exid))                              return false;                          if (!stack2.Flush(postCondStatements' wdi.Body.AfterState))                              return false;                          preCondStatements.Add                              (new IfThenElseStatement                                   (condEntry.Expression'                                    new Statements(postCondStatements)'                                    new Statements(new BreakStatement())));                          statements.Add(new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(preCondStatements)));                      }                      else                      {                          var loopStatements = BlockToStatements(wdi.Body' exid);                          if (loopStatements == null)                              return false;                          if (statements == null)                              return Failed(false' "while-do");                          statements.Add(new WhileDoStatement(condEntry.Expression' new Statements(loopStatements)));                      }                      if (!stack.Restore(wdi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.DoWhilePseudo:                  {                      var dwi = (DoWhileInstruction)instruction;                      if (!stack.Flush(statements' dwi.Body.BeforeState))                          return false;                      var combined = new Seq<Instruction>();                      foreach (var i in dwi.Body.Body)                          combined.Add(i);                      foreach (var i in dwi.Condition.Body)                          combined.Add(i);                      var condEntry = default(ExpressionStackEntry);                      var loopStatements = BlockToConditionStatements                          (new Instructions(null' combined)' dwi.Body.BeforeState' exid' out condEntry);                      if (loopStatements == null)                          return false;                      if (statements == null)                          return Failed(false' "do-while");                      statements.Add(new DoWhileStatement(new Statements(loopStatements)' condEntry.Expression));                      if (!stack.Restore(dwi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopControlPseudo:                  {                      var lci = (BreakContinueInstruction)instruction;                      if (!stack.Flush(statements' lci.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop-control");                      var targetState = default(int);                      switch (lci.Op)                      {                      case BreakContinueOp.Break:                          if (labelToLoopCandidateBreakState != null &&                              labelToLoopCandidateBreakState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new BreakStatement(lci.Label));                          break;                      case BreakContinueOp.Continue:                          if (labelToLoopCandidateContinueState != null &&                              labelToLoopCandidateContinueState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new ContinueStatement(lci.Label));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      return true;                  }              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return true;                      case MiscOp.Dup:                          return stack.Dup(statements);                      case MiscOp.Pop:                          return stack.PopAndDiscard(statements);                      case MiscOp.Ldnull:                          stack.Push(new ExpressionStackEntry(new NullConstantExpression()' BottomE));                          return true;                      case MiscOp.Ckfinite:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.CheckFinite' false' false)' e.Lub(ThrowsE)));                      case MiscOp.Throw:                          if (!stack.DiscardAll(statements' 1))                              return false;                          if (!stack.PopEvalSE(statements' 1' true' ThrowsE' (s' a) => s.Add(new ThrowStatement(a[0]))))                              return false;                          return true;                      case MiscOp.Rethrow:                          if (!stack.DiscardAll(statements' 0))                              return false;                          if (statements == null)                              return Failed(false' "rethrow");                          if (exid == null)                              throw new InvalidOperationException("rethrow outside of catch");                          statements.Add(new RethrowStatement(new VariableCell(exid).Read()));                          return true;                      case MiscOp.LdindRef:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case MiscOp.LdelemRef:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.Ldlen:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.Length' false' false)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.StindRef:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case MiscOp.StelemRef:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add                                   (new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      case MiscOp.Ret:                          if (statements == null)                              return Failed(false' "return");                          statements.Add(new ReturnStatement(null));                          return true;                      case MiscOp.RetVal:                          return stack.PopEvalSE                              (statements' 1' true' BottomE' (s' a) => s.Add(new ReturnStatement(a[0])));                      case MiscOp.Endfilter:                      case MiscOp.Endfinally:                          throw new InvalidOperationException                              ("endfilter/endfinally instructions should have been removed");                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:              case InstructionFlavor.Switch:                  throw new InvalidOperationException("branch/switch instructions should have been removed");              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      if (cmpi.Op == CompareOp.CtruePseudo || cmpi.Op == CompareOp.CfalsePseudo)                      {                          var s = cmpi.Type.Style(compEnv);                          var unop = default(UnaryOp);                          if (s is NumberTypeStyle)                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonZero : UnaryOp.IsZero;                          else                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonNull : UnaryOp.IsNull;                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new UnaryExpression(a[0]' unop' false' cmpi.IsUnsigned)' e));                      }                      else                      {                          var binop = default(BinaryOp);                          switch (cmpi.Op)                          {                          case CompareOp.Ceq:                              binop = BinaryOp.Eq;                              break;                          case CompareOp.Clt:                              binop = BinaryOp.Lt;                              break;                          case CompareOp.Cgt:                              binop = BinaryOp.Gt;                              break;                          case CompareOp.CgePseudo:                              binop = BinaryOp.Ge;                              break;                          case CompareOp.ClePseudo:                              binop = BinaryOp.Le;                              break;                          case CompareOp.CnePseudo:                              binop = BinaryOp.Ne;                              break;                          case CompareOp.CtruePseudo:                          case CompareOp.CfalsePseudo:                              // handled above                              throw new InvalidOperationException();                          default:                              throw new ArgumentOutOfRangeException();                          }                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression(a[0]' binop' a[1]' false' cmpi.IsUnsigned)' e));                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var sli = (ArgLocalInstruction)instruction;                      var id = default(JST.Identifier);                      switch (sli.ArgLocal)                      {                      case ArgLocal.Arg:                          id = compEnv.ValueParameterIds[sli.Index];                          break;                      case ArgLocal.Local:                          id = compEnv.LocalIds[sli.Index];                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      var cell = new VariableCell(id);                      switch (sli.Op)                      {                      case ArgLocalOp.Ld:                          stack.Push                              (new ExpressionStackEntry                                   (cell.Read().CloneIfStruct(compEnv)' ReadArgLocalE(sli.ArgLocal' sli.Index)));                          return true;                      case ArgLocalOp.Lda:                          // Effect will be accounted for on reads/writes                          stack.Push(new ExpressionStackEntry(cell.AddressOf()' BottomE));                          return true;                      case ArgLocalOp.St:                          return stack.PopEvalSE                              (statements'                               1'                               true'                               WriteArgLocalE(sli.ArgLocal' sli.Index)'                               (s' a) => s.Add(new ExpressionStatement(cell.Write(a[0]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                          {                              stack.Push                                  (new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' ReadHeapE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                       {                                           var readEffect = default(Effects);                                           var obj = default(Expression);                                           if (fieldi.IsViaPointer.Value)                                           {                                               readEffect = e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect());                                               obj = new ReadExpression(a[0]); // no need for clone                                           }                                           else if (fieldi.Field.DefiningType.Style(compEnv) is ValueTypeStyle)                                           {                                               readEffect = e;                                               obj = a[0];                                           }                                           else                                           {                                               // Object could be null                                               readEffect = e.Lub(ReadHeapOrThrowE);                                               obj = a[0];                                           }                                           return new ExpressionStackEntry(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' readEffect);                                       });                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                          {                              // Effect will be accounted for on reads/writes                              stack.Push(new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' BottomE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   {                                       if (fieldi.IsViaPointer.Value)                                           // We're just adding an offset to a pointer' so effect will                                           // be accounted for when the final pointer is read/written                                           return new ExpressionStackEntry(new FieldCell(new ReadExpression(a[0])' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e);                                       else                                           // Must be a reference type' and ref could be null                                           return new ExpressionStackEntry(new FieldCell(a[0]' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e.Lub(ThrowsE));                                   });                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                              return stack.PopEvalSE                                  (statements'                                   1'                                   true'                                   WriteHeapE'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Write(a[0]))));                          else                          {                              var writeEffect = fieldi.IsViaPointer.Value                                                    ? instruction.BeforeState.PeekPointsTo(1).WriteEffect()                                                    : WriteHeapOrThrowE;                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   writeEffect'                                   (s' a) =>                                       {                                           var obj = fieldi.IsViaPointer.Value ? new ReadExpression(a[0]) : a[0];                                           s.Add(new ExpressionStatement(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Write(a[1])));                                       });                          }                      case FieldOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new FieldHandleConstantExpression(compEnv.SubstituteMember(fieldi.Field))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methodi = (MethodInstruction)instruction;                      var arity = methodi.Method.ValueParameters.Count;                      switch (methodi.Op)                      {                      case MethodOp.Ldftn:                          if (methodi.IsVirtual)                              // Object could be null                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CodePointerExpression(a[0]' compEnv.SubstituteMember(methodi.Method))' e.Lub(ReadHeapOrThrowE)));                          else                          {                              stack.Push                                  (new ExpressionStackEntry(new CodePointerExpression(null' compEnv.SubstituteMember(methodi.Method))' BottomE));                              return true;                          }                      case MethodOp.Call:                          if (methodi.Method.Result == null)                              return stack.PopEvalSE                                  (statements'                                   arity'                                   true'                                   CalleeEffects(methodi.BeforeState' arity)'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new CallExpression                                                 (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal'                                                  compEnv.SubstituteMember(methodi.Method)'                                                  CallerArguments(methodi.Constrained' methodi.Method' a)))));                          else                              return stack.PopEvalPush                                  (statements'                                   arity'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CallExpression                                            (methodi.IsVirtual? CallFlavor.Virtual : CallFlavor.Normal'                                             compEnv.SubstituteMember(methodi.Method)'                                             CallerArguments(methodi.Constrained' methodi.Method' a))'                                        e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Newobj:                          arity--;                          return stack.PopEvalPush                              (statements'                               arity'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new NewObjectExpression(compEnv.SubstituteMember(methodi.Method)' CallerArguments(null' methodi.Method' a))'                                    e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Ldtoken:                          stack.Push                              (new ExpressionStackEntry(new MethodHandleConstantExpression(compEnv.SubstituteMember(methodi.Method))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case TypeOp.Stobj:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case TypeOp.Cpobj:                          {                              var copyEffect = instruction.BeforeState.PeekPointsTo(0).ReadEffect().Lub                                  (instruction.BeforeState.PeekPointsTo(1).WriteEffect());                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   copyEffect'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new WriteExpression(a[0]' new ReadExpression(a[1]).CloneIfStruct(compEnv)))));                          }                      case TypeOp.Newarr:                          // Growing the heap is not considered an observable change. But will throw if                          // length < 0                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new NewArrayExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Initobj:                          return stack.PopEvalSE                              (statements' 1' true' WriteHeapE' (s' a) => s.Add(new InitializeObjectStatement(a[0])));                      case TypeOp.Castclass:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new CastExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Isinst:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new IsInstExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Box:                          // Growing the heap is not considered an observable change                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new NewBoxExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Unbox:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).AddressOf()' e.Lub(ThrowsE)));                      case TypeOp.UnboxAny:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).Read().CloneIfStruct(compEnv)' e.Lub(ThrowsE)));                      case TypeOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new TypeHandleConstantExpression(compEnv.SubstituteType(typei.Type))' BottomE));                          return true;                      case TypeOp.Ldelem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case TypeOp.Stelem:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add(new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  // Calculating the pointer may throw if index is out of range.                  // Remaining effect will be accounted for when pointer is read/written.                  return stack.PopEvalPush                      (statements'                       2'                       true'                       (a' e) =>                       new ExpressionStackEntry(new ElementCell(a[0]' a[1]' false).AddressOf()' e.Lub(ThrowsE)));              case InstructionFlavor.LdInt32:                  {                      var int32i = (LdInt32Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int32ConstantExpression(int32i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdInt64:                  {                      var int64i = (LdInt64Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int64ConstantExpression(int64i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdSingle:                  {                      var singlei = (LdSingleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new SingleConstantExpression(singlei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdDouble:                  {                      var doublei = (LdDoubleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new DoubleConstantExpression(doublei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdString:                  {                      var stringi = (LdStringInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new StringConstantExpression(stringi.Value)' BottomE));                      return true;                  }              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Div:                      case ArithOp.Rem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(ThrowsE)));                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                      case ArithOp.Shl:                      case ArithOp.Shr:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(arithi.WithOverflow ? ThrowsE : BottomE)));                      case ArithOp.Neg:                      case ArithOp.BitNot:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression                                        (a[0]' ArithOpToUnaryOp(arithi.Op)' arithi.WithOverflow' arithi.IsUnsigned)'                                    e));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      return stack.PopEvalPush                          (statements'                           1'                           true'                           (a' e) =>                           new ExpressionStackEntry                               (new ConvertExpression                                    (a[0]'                                     new NamedTypeRef                                         (compEnv.Global.NumberFlavorToQualifiedTypeName[convi.TargetNumberFlavor])'                                     convi.WithOverflow'                                     convi.IsSourceUnsigned)'                                e.Lub(convi.WithOverflow ? ThrowsE : BottomE)));                  }              case InstructionFlavor.Try:                  {                      if (stack.Depth > 0)                          throw new InvalidOperationException("stack must be empty on entry to try block");                      var tryi = (TryInstruction)instruction;                      var tryStatements = BlockToTryFaultFinallyStatements(tryi.Body);                      if (tryStatements == null)                          return false;                      var handlers = TranslateHandlers(tryi.Handlers);                      if (handlers == null)                          return false;                      if (statements == null)                          return Failed(false' "try");                      statements.Add(new TryStatement(tryStatements' handlers));                      return true;                  }              case InstructionFlavor.IfThenElsePseudo:                  {                      var itei = (IfThenElseInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(itei.Offset' out isExpr) ||                                              isExpr;                        if (!TranslateBlock(statements' itei.Condition' stack' exid))                          return false;                      if (couldBeExpression && itei.Else != null)                      {                          // Pass 1: Try to tranlate to an if-then-else expression. Will only work if Then and Else don't                          //         reach into current stack' push exactly one value' and don't need to emit any                          //         statements along the way.                          var thenEntry = BlockToExpression(itei.Then' exid);                          if (thenEntry != null)                          {                              var elseEntry = BlockToExpression(itei.Else' exid);                              if (elseEntry != null)                              {                                  if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                                      instructionTranslationStyleCache.Add(itei.Offset' true);                                  return stack.PopEvalPush                                      (statements'                                       1'                                       true'                                       (a' e) =>                                       new ExpressionStackEntry                                           (new IfThenElseExpression(a[0]' thenEntry.Expression' elseEntry.Expression)'                                            e.Lub(thenEntry.Effects.Lub(elseEntry.Effects))));                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      var noStackChange = itei.Then.NoStackChange && (itei.Else == null || itei.Else.NoStackChange);                      var condEntry = noStackChange                                          ? stack.Pop()                                          : stack.FlushAndPopPostState(statements' itei.Then.BeforeState);                      if (condEntry == null)                          return false;                      var thenStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Then' exid)                                           : BlockToStatements(itei.Then' exid);                      if (thenStmnts == null)                          return false;                      var elseStmnts = default(Seq<Statement>);                      if (itei.Else != null)                      {                          elseStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Else' exid)                                           : BlockToStatements(itei.Else' exid);                          if (elseStmnts == null)                              return false;                      }                      if (statements == null)                          return Failed(false' "if-then-else");                      statements.Add                          (new IfThenElseStatement(condEntry.Expression' new Statements(thenStmnts)' elseStmnts == null ? null : new Statements(elseStmnts)));                      if (!noStackChange && !stack.Restore(itei.AfterState' 0))                          return false;                      if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                          instructionTranslationStyleCache.Add(itei.Offset' false);                      return true;                  }              case InstructionFlavor.ShortCircuitingPseudo:                  {                      var sci = (ShortCircuitingInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(sci.Offset' out isExpr) ||                                              isExpr;                      if (couldBeExpression)                      {                          // Pass 1: Try to translate to an expression.                          var leftEntry = BlockToExpression(sci.Left' exid);                          if (leftEntry != null)                          {                              var rightEntry = BlockToExpression(sci.Right' exid);                              if (rightEntry != null)                              {                                  stack.Push                                      (new ExpressionStackEntry                                           (new BinaryExpression                                                (leftEntry.Expression'                                                 ShortCircuitingOpToBinaryOp(sci.Op)'                                                 rightEntry.Expression'                                                 false'                                                 false)'                                            leftEntry.Effects.Lub(rightEntry.Effects)));                                  if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                                      instructionTranslationStyleCache.Add(sci.Offset' true);                                  return true;                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      if (!TranslateBlock(statements' sci.Left' stack' exid))                          return false;                      var leftEntry2 = stack.FlushAndPopPostState(statements' sci.Right.BeforeState);                      if (leftEntry2 == null)                          return false;                      var rightStatements = BlockToStatements(sci.Right' exid);                      if (rightStatements == null)                          return false;                      var id = sci.Right.AfterState.PeekId(0' nameSupply.GenSym);                      var cell = new VariableCell(id);                      compEnv.AddVariable(id' ArgLocal.Local' false' true' compEnv.SubstituteType(sci.Right.AfterState.PeekType(0)));                      if (statements == null)                          return Failed(false' "short-circuit");                      switch (sci.Op)                      {                      case ShortCircuitingOp.And:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements(rightStatements)'                                    new Statements                                        (new ExpressionStatement(cell.Write(new Int32ConstantExpression(0))))));                          break;                      case ShortCircuitingOp.Or:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements                                        (new ExpressionStatement                                             (cell.Write(new Int32ConstantExpression(1))))'                                    new Statements(rightStatements)));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      if (!stack.Restore(sci.AfterState' 1))                          return false;                      stack.Push(new ExpressionStackEntry(cell.Read()' BottomE));                      if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                          instructionTranslationStyleCache.Add(sci.Offset' false);                      return true;                  }              case InstructionFlavor.StructuralSwitchPseudo:                  {                      var ssi = (StructuralSwitchInstruction)instruction;                      if (!TranslateBlock(statements' ssi.Body' stack' exid))                          return false;                      var valueEntry = stack.FlushAndPopPreState(statements' ssi.Body.AfterState);                      if (valueEntry == null)                          return false;                      var cases = new Seq<SwitchStatementCase>();                      foreach (var c in ssi.Cases)                      {                          var caseStatements = BlockToStatements(c.Body' exid);                          if (caseStatements == null)                              return false;                          cases.Add(new SwitchStatementCase(c.Values' new Statements(caseStatements)));                      }                      if (statements == null)                          return Failed(false' "structural switch");                      statements.Add(new SwitchStatement(valueEntry.Expression' cases));                      if (!stack.Restore(ssi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopPseudo:                  {                      var li = (LoopInstruction)instruction;                      if (!stack.Flush(statements' li.Body.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop");                      var whileStatements = BlockToStatements(li.Body' exid);                      statements.Add                          (new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(whileStatements)));                      if (!stack.Restore(li.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.WhileDoPseudo:                  {                      var wdi = (WhileDoInstruction)instruction;                      if (!stack.Flush(statements' wdi.Condition.BeforeState))                          return false;                      var condEntry = BlockToExpression(wdi.Condition' exid);                      if (condEntry == null)                      {                          var stack1 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Condition.BeforeState' trace);                          var preCondStatements = new Seq<Statement>();                          if (!TranslateBlock(preCondStatements' wdi.Condition' stack1' exid))                              return false;                          condEntry = stack1.FlushAndPopPostState(preCondStatements' wdi.Body.BeforeState);                          if (condEntry == null)                              return false;                          var stack2 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Body.BeforeState' trace);                          var postCondStatements = new Seq<Statement>();                          if (!TranslateBlock(postCondStatements' wdi.Body' stack2' exid))                              return false;                          if (!stack2.Flush(postCondStatements' wdi.Body.AfterState))                              return false;                          preCondStatements.Add                              (new IfThenElseStatement                                   (condEntry.Expression'                                    new Statements(postCondStatements)'                                    new Statements(new BreakStatement())));                          statements.Add(new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(preCondStatements)));                      }                      else                      {                          var loopStatements = BlockToStatements(wdi.Body' exid);                          if (loopStatements == null)                              return false;                          if (statements == null)                              return Failed(false' "while-do");                          statements.Add(new WhileDoStatement(condEntry.Expression' new Statements(loopStatements)));                      }                      if (!stack.Restore(wdi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.DoWhilePseudo:                  {                      var dwi = (DoWhileInstruction)instruction;                      if (!stack.Flush(statements' dwi.Body.BeforeState))                          return false;                      var combined = new Seq<Instruction>();                      foreach (var i in dwi.Body.Body)                          combined.Add(i);                      foreach (var i in dwi.Condition.Body)                          combined.Add(i);                      var condEntry = default(ExpressionStackEntry);                      var loopStatements = BlockToConditionStatements                          (new Instructions(null' combined)' dwi.Body.BeforeState' exid' out condEntry);                      if (loopStatements == null)                          return false;                      if (statements == null)                          return Failed(false' "do-while");                      statements.Add(new DoWhileStatement(new Statements(loopStatements)' condEntry.Expression));                      if (!stack.Restore(dwi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopControlPseudo:                  {                      var lci = (BreakContinueInstruction)instruction;                      if (!stack.Flush(statements' lci.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop-control");                      var targetState = default(int);                      switch (lci.Op)                      {                      case BreakContinueOp.Break:                          if (labelToLoopCandidateBreakState != null &&                              labelToLoopCandidateBreakState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new BreakStatement(lci.Label));                          break;                      case BreakContinueOp.Continue:                          if (labelToLoopCandidateContinueState != null &&                              labelToLoopCandidateContinueState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new ContinueStatement(lci.Label));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      return true;                  }              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return true;                      case MiscOp.Dup:                          return stack.Dup(statements);                      case MiscOp.Pop:                          return stack.PopAndDiscard(statements);                      case MiscOp.Ldnull:                          stack.Push(new ExpressionStackEntry(new NullConstantExpression()' BottomE));                          return true;                      case MiscOp.Ckfinite:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.CheckFinite' false' false)' e.Lub(ThrowsE)));                      case MiscOp.Throw:                          if (!stack.DiscardAll(statements' 1))                              return false;                          if (!stack.PopEvalSE(statements' 1' true' ThrowsE' (s' a) => s.Add(new ThrowStatement(a[0]))))                              return false;                          return true;                      case MiscOp.Rethrow:                          if (!stack.DiscardAll(statements' 0))                              return false;                          if (statements == null)                              return Failed(false' "rethrow");                          if (exid == null)                              throw new InvalidOperationException("rethrow outside of catch");                          statements.Add(new RethrowStatement(new VariableCell(exid).Read()));                          return true;                      case MiscOp.LdindRef:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case MiscOp.LdelemRef:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.Ldlen:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.Length' false' false)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.StindRef:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case MiscOp.StelemRef:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add                                   (new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      case MiscOp.Ret:                          if (statements == null)                              return Failed(false' "return");                          statements.Add(new ReturnStatement(null));                          return true;                      case MiscOp.RetVal:                          return stack.PopEvalSE                              (statements' 1' true' BottomE' (s' a) => s.Add(new ReturnStatement(a[0])));                      case MiscOp.Endfilter:                      case MiscOp.Endfinally:                          throw new InvalidOperationException                              ("endfilter/endfinally instructions should have been removed");                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:              case InstructionFlavor.Switch:                  throw new InvalidOperationException("branch/switch instructions should have been removed");              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      if (cmpi.Op == CompareOp.CtruePseudo || cmpi.Op == CompareOp.CfalsePseudo)                      {                          var s = cmpi.Type.Style(compEnv);                          var unop = default(UnaryOp);                          if (s is NumberTypeStyle)                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonZero : UnaryOp.IsZero;                          else                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonNull : UnaryOp.IsNull;                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new UnaryExpression(a[0]' unop' false' cmpi.IsUnsigned)' e));                      }                      else                      {                          var binop = default(BinaryOp);                          switch (cmpi.Op)                          {                          case CompareOp.Ceq:                              binop = BinaryOp.Eq;                              break;                          case CompareOp.Clt:                              binop = BinaryOp.Lt;                              break;                          case CompareOp.Cgt:                              binop = BinaryOp.Gt;                              break;                          case CompareOp.CgePseudo:                              binop = BinaryOp.Ge;                              break;                          case CompareOp.ClePseudo:                              binop = BinaryOp.Le;                              break;                          case CompareOp.CnePseudo:                              binop = BinaryOp.Ne;                              break;                          case CompareOp.CtruePseudo:                          case CompareOp.CfalsePseudo:                              // handled above                              throw new InvalidOperationException();                          default:                              throw new ArgumentOutOfRangeException();                          }                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression(a[0]' binop' a[1]' false' cmpi.IsUnsigned)' e));                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var sli = (ArgLocalInstruction)instruction;                      var id = default(JST.Identifier);                      switch (sli.ArgLocal)                      {                      case ArgLocal.Arg:                          id = compEnv.ValueParameterIds[sli.Index];                          break;                      case ArgLocal.Local:                          id = compEnv.LocalIds[sli.Index];                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      var cell = new VariableCell(id);                      switch (sli.Op)                      {                      case ArgLocalOp.Ld:                          stack.Push                              (new ExpressionStackEntry                                   (cell.Read().CloneIfStruct(compEnv)' ReadArgLocalE(sli.ArgLocal' sli.Index)));                          return true;                      case ArgLocalOp.Lda:                          // Effect will be accounted for on reads/writes                          stack.Push(new ExpressionStackEntry(cell.AddressOf()' BottomE));                          return true;                      case ArgLocalOp.St:                          return stack.PopEvalSE                              (statements'                               1'                               true'                               WriteArgLocalE(sli.ArgLocal' sli.Index)'                               (s' a) => s.Add(new ExpressionStatement(cell.Write(a[0]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                          {                              stack.Push                                  (new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' ReadHeapE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                       {                                           var readEffect = default(Effects);                                           var obj = default(Expression);                                           if (fieldi.IsViaPointer.Value)                                           {                                               readEffect = e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect());                                               obj = new ReadExpression(a[0]); // no need for clone                                           }                                           else if (fieldi.Field.DefiningType.Style(compEnv) is ValueTypeStyle)                                           {                                               readEffect = e;                                               obj = a[0];                                           }                                           else                                           {                                               // Object could be null                                               readEffect = e.Lub(ReadHeapOrThrowE);                                               obj = a[0];                                           }                                           return new ExpressionStackEntry(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' readEffect);                                       });                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                          {                              // Effect will be accounted for on reads/writes                              stack.Push(new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' BottomE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   {                                       if (fieldi.IsViaPointer.Value)                                           // We're just adding an offset to a pointer' so effect will                                           // be accounted for when the final pointer is read/written                                           return new ExpressionStackEntry(new FieldCell(new ReadExpression(a[0])' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e);                                       else                                           // Must be a reference type' and ref could be null                                           return new ExpressionStackEntry(new FieldCell(a[0]' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e.Lub(ThrowsE));                                   });                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                              return stack.PopEvalSE                                  (statements'                                   1'                                   true'                                   WriteHeapE'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Write(a[0]))));                          else                          {                              var writeEffect = fieldi.IsViaPointer.Value                                                    ? instruction.BeforeState.PeekPointsTo(1).WriteEffect()                                                    : WriteHeapOrThrowE;                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   writeEffect'                                   (s' a) =>                                       {                                           var obj = fieldi.IsViaPointer.Value ? new ReadExpression(a[0]) : a[0];                                           s.Add(new ExpressionStatement(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Write(a[1])));                                       });                          }                      case FieldOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new FieldHandleConstantExpression(compEnv.SubstituteMember(fieldi.Field))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methodi = (MethodInstruction)instruction;                      var arity = methodi.Method.ValueParameters.Count;                      switch (methodi.Op)                      {                      case MethodOp.Ldftn:                          if (methodi.IsVirtual)                              // Object could be null                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CodePointerExpression(a[0]' compEnv.SubstituteMember(methodi.Method))' e.Lub(ReadHeapOrThrowE)));                          else                          {                              stack.Push                                  (new ExpressionStackEntry(new CodePointerExpression(null' compEnv.SubstituteMember(methodi.Method))' BottomE));                              return true;                          }                      case MethodOp.Call:                          if (methodi.Method.Result == null)                              return stack.PopEvalSE                                  (statements'                                   arity'                                   true'                                   CalleeEffects(methodi.BeforeState' arity)'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new CallExpression                                                 (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal'                                                  compEnv.SubstituteMember(methodi.Method)'                                                  CallerArguments(methodi.Constrained' methodi.Method' a)))));                          else                              return stack.PopEvalPush                                  (statements'                                   arity'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CallExpression                                            (methodi.IsVirtual? CallFlavor.Virtual : CallFlavor.Normal'                                             compEnv.SubstituteMember(methodi.Method)'                                             CallerArguments(methodi.Constrained' methodi.Method' a))'                                        e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Newobj:                          arity--;                          return stack.PopEvalPush                              (statements'                               arity'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new NewObjectExpression(compEnv.SubstituteMember(methodi.Method)' CallerArguments(null' methodi.Method' a))'                                    e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Ldtoken:                          stack.Push                              (new ExpressionStackEntry(new MethodHandleConstantExpression(compEnv.SubstituteMember(methodi.Method))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case TypeOp.Stobj:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case TypeOp.Cpobj:                          {                              var copyEffect = instruction.BeforeState.PeekPointsTo(0).ReadEffect().Lub                                  (instruction.BeforeState.PeekPointsTo(1).WriteEffect());                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   copyEffect'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new WriteExpression(a[0]' new ReadExpression(a[1]).CloneIfStruct(compEnv)))));                          }                      case TypeOp.Newarr:                          // Growing the heap is not considered an observable change. But will throw if                          // length < 0                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new NewArrayExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Initobj:                          return stack.PopEvalSE                              (statements' 1' true' WriteHeapE' (s' a) => s.Add(new InitializeObjectStatement(a[0])));                      case TypeOp.Castclass:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new CastExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Isinst:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new IsInstExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Box:                          // Growing the heap is not considered an observable change                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new NewBoxExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Unbox:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).AddressOf()' e.Lub(ThrowsE)));                      case TypeOp.UnboxAny:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).Read().CloneIfStruct(compEnv)' e.Lub(ThrowsE)));                      case TypeOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new TypeHandleConstantExpression(compEnv.SubstituteType(typei.Type))' BottomE));                          return true;                      case TypeOp.Ldelem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case TypeOp.Stelem:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add(new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  // Calculating the pointer may throw if index is out of range.                  // Remaining effect will be accounted for when pointer is read/written.                  return stack.PopEvalPush                      (statements'                       2'                       true'                       (a' e) =>                       new ExpressionStackEntry(new ElementCell(a[0]' a[1]' false).AddressOf()' e.Lub(ThrowsE)));              case InstructionFlavor.LdInt32:                  {                      var int32i = (LdInt32Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int32ConstantExpression(int32i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdInt64:                  {                      var int64i = (LdInt64Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int64ConstantExpression(int64i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdSingle:                  {                      var singlei = (LdSingleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new SingleConstantExpression(singlei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdDouble:                  {                      var doublei = (LdDoubleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new DoubleConstantExpression(doublei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdString:                  {                      var stringi = (LdStringInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new StringConstantExpression(stringi.Value)' BottomE));                      return true;                  }              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Div:                      case ArithOp.Rem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(ThrowsE)));                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                      case ArithOp.Shl:                      case ArithOp.Shr:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(arithi.WithOverflow ? ThrowsE : BottomE)));                      case ArithOp.Neg:                      case ArithOp.BitNot:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression                                        (a[0]' ArithOpToUnaryOp(arithi.Op)' arithi.WithOverflow' arithi.IsUnsigned)'                                    e));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      return stack.PopEvalPush                          (statements'                           1'                           true'                           (a' e) =>                           new ExpressionStackEntry                               (new ConvertExpression                                    (a[0]'                                     new NamedTypeRef                                         (compEnv.Global.NumberFlavorToQualifiedTypeName[convi.TargetNumberFlavor])'                                     convi.WithOverflow'                                     convi.IsSourceUnsigned)'                                e.Lub(convi.WithOverflow ? ThrowsE : BottomE)));                  }              case InstructionFlavor.Try:                  {                      if (stack.Depth > 0)                          throw new InvalidOperationException("stack must be empty on entry to try block");                      var tryi = (TryInstruction)instruction;                      var tryStatements = BlockToTryFaultFinallyStatements(tryi.Body);                      if (tryStatements == null)                          return false;                      var handlers = TranslateHandlers(tryi.Handlers);                      if (handlers == null)                          return false;                      if (statements == null)                          return Failed(false' "try");                      statements.Add(new TryStatement(tryStatements' handlers));                      return true;                  }              case InstructionFlavor.IfThenElsePseudo:                  {                      var itei = (IfThenElseInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(itei.Offset' out isExpr) ||                                              isExpr;                        if (!TranslateBlock(statements' itei.Condition' stack' exid))                          return false;                      if (couldBeExpression && itei.Else != null)                      {                          // Pass 1: Try to tranlate to an if-then-else expression. Will only work if Then and Else don't                          //         reach into current stack' push exactly one value' and don't need to emit any                          //         statements along the way.                          var thenEntry = BlockToExpression(itei.Then' exid);                          if (thenEntry != null)                          {                              var elseEntry = BlockToExpression(itei.Else' exid);                              if (elseEntry != null)                              {                                  if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                                      instructionTranslationStyleCache.Add(itei.Offset' true);                                  return stack.PopEvalPush                                      (statements'                                       1'                                       true'                                       (a' e) =>                                       new ExpressionStackEntry                                           (new IfThenElseExpression(a[0]' thenEntry.Expression' elseEntry.Expression)'                                            e.Lub(thenEntry.Effects.Lub(elseEntry.Effects))));                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      var noStackChange = itei.Then.NoStackChange && (itei.Else == null || itei.Else.NoStackChange);                      var condEntry = noStackChange                                          ? stack.Pop()                                          : stack.FlushAndPopPostState(statements' itei.Then.BeforeState);                      if (condEntry == null)                          return false;                      var thenStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Then' exid)                                           : BlockToStatements(itei.Then' exid);                      if (thenStmnts == null)                          return false;                      var elseStmnts = default(Seq<Statement>);                      if (itei.Else != null)                      {                          elseStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Else' exid)                                           : BlockToStatements(itei.Else' exid);                          if (elseStmnts == null)                              return false;                      }                      if (statements == null)                          return Failed(false' "if-then-else");                      statements.Add                          (new IfThenElseStatement(condEntry.Expression' new Statements(thenStmnts)' elseStmnts == null ? null : new Statements(elseStmnts)));                      if (!noStackChange && !stack.Restore(itei.AfterState' 0))                          return false;                      if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                          instructionTranslationStyleCache.Add(itei.Offset' false);                      return true;                  }              case InstructionFlavor.ShortCircuitingPseudo:                  {                      var sci = (ShortCircuitingInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(sci.Offset' out isExpr) ||                                              isExpr;                      if (couldBeExpression)                      {                          // Pass 1: Try to translate to an expression.                          var leftEntry = BlockToExpression(sci.Left' exid);                          if (leftEntry != null)                          {                              var rightEntry = BlockToExpression(sci.Right' exid);                              if (rightEntry != null)                              {                                  stack.Push                                      (new ExpressionStackEntry                                           (new BinaryExpression                                                (leftEntry.Expression'                                                 ShortCircuitingOpToBinaryOp(sci.Op)'                                                 rightEntry.Expression'                                                 false'                                                 false)'                                            leftEntry.Effects.Lub(rightEntry.Effects)));                                  if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                                      instructionTranslationStyleCache.Add(sci.Offset' true);                                  return true;                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      if (!TranslateBlock(statements' sci.Left' stack' exid))                          return false;                      var leftEntry2 = stack.FlushAndPopPostState(statements' sci.Right.BeforeState);                      if (leftEntry2 == null)                          return false;                      var rightStatements = BlockToStatements(sci.Right' exid);                      if (rightStatements == null)                          return false;                      var id = sci.Right.AfterState.PeekId(0' nameSupply.GenSym);                      var cell = new VariableCell(id);                      compEnv.AddVariable(id' ArgLocal.Local' false' true' compEnv.SubstituteType(sci.Right.AfterState.PeekType(0)));                      if (statements == null)                          return Failed(false' "short-circuit");                      switch (sci.Op)                      {                      case ShortCircuitingOp.And:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements(rightStatements)'                                    new Statements                                        (new ExpressionStatement(cell.Write(new Int32ConstantExpression(0))))));                          break;                      case ShortCircuitingOp.Or:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements                                        (new ExpressionStatement                                             (cell.Write(new Int32ConstantExpression(1))))'                                    new Statements(rightStatements)));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      if (!stack.Restore(sci.AfterState' 1))                          return false;                      stack.Push(new ExpressionStackEntry(cell.Read()' BottomE));                      if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                          instructionTranslationStyleCache.Add(sci.Offset' false);                      return true;                  }              case InstructionFlavor.StructuralSwitchPseudo:                  {                      var ssi = (StructuralSwitchInstruction)instruction;                      if (!TranslateBlock(statements' ssi.Body' stack' exid))                          return false;                      var valueEntry = stack.FlushAndPopPreState(statements' ssi.Body.AfterState);                      if (valueEntry == null)                          return false;                      var cases = new Seq<SwitchStatementCase>();                      foreach (var c in ssi.Cases)                      {                          var caseStatements = BlockToStatements(c.Body' exid);                          if (caseStatements == null)                              return false;                          cases.Add(new SwitchStatementCase(c.Values' new Statements(caseStatements)));                      }                      if (statements == null)                          return Failed(false' "structural switch");                      statements.Add(new SwitchStatement(valueEntry.Expression' cases));                      if (!stack.Restore(ssi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopPseudo:                  {                      var li = (LoopInstruction)instruction;                      if (!stack.Flush(statements' li.Body.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop");                      var whileStatements = BlockToStatements(li.Body' exid);                      statements.Add                          (new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(whileStatements)));                      if (!stack.Restore(li.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.WhileDoPseudo:                  {                      var wdi = (WhileDoInstruction)instruction;                      if (!stack.Flush(statements' wdi.Condition.BeforeState))                          return false;                      var condEntry = BlockToExpression(wdi.Condition' exid);                      if (condEntry == null)                      {                          var stack1 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Condition.BeforeState' trace);                          var preCondStatements = new Seq<Statement>();                          if (!TranslateBlock(preCondStatements' wdi.Condition' stack1' exid))                              return false;                          condEntry = stack1.FlushAndPopPostState(preCondStatements' wdi.Body.BeforeState);                          if (condEntry == null)                              return false;                          var stack2 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Body.BeforeState' trace);                          var postCondStatements = new Seq<Statement>();                          if (!TranslateBlock(postCondStatements' wdi.Body' stack2' exid))                              return false;                          if (!stack2.Flush(postCondStatements' wdi.Body.AfterState))                              return false;                          preCondStatements.Add                              (new IfThenElseStatement                                   (condEntry.Expression'                                    new Statements(postCondStatements)'                                    new Statements(new BreakStatement())));                          statements.Add(new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(preCondStatements)));                      }                      else                      {                          var loopStatements = BlockToStatements(wdi.Body' exid);                          if (loopStatements == null)                              return false;                          if (statements == null)                              return Failed(false' "while-do");                          statements.Add(new WhileDoStatement(condEntry.Expression' new Statements(loopStatements)));                      }                      if (!stack.Restore(wdi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.DoWhilePseudo:                  {                      var dwi = (DoWhileInstruction)instruction;                      if (!stack.Flush(statements' dwi.Body.BeforeState))                          return false;                      var combined = new Seq<Instruction>();                      foreach (var i in dwi.Body.Body)                          combined.Add(i);                      foreach (var i in dwi.Condition.Body)                          combined.Add(i);                      var condEntry = default(ExpressionStackEntry);                      var loopStatements = BlockToConditionStatements                          (new Instructions(null' combined)' dwi.Body.BeforeState' exid' out condEntry);                      if (loopStatements == null)                          return false;                      if (statements == null)                          return Failed(false' "do-while");                      statements.Add(new DoWhileStatement(new Statements(loopStatements)' condEntry.Expression));                      if (!stack.Restore(dwi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopControlPseudo:                  {                      var lci = (BreakContinueInstruction)instruction;                      if (!stack.Flush(statements' lci.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop-control");                      var targetState = default(int);                      switch (lci.Op)                      {                      case BreakContinueOp.Break:                          if (labelToLoopCandidateBreakState != null &&                              labelToLoopCandidateBreakState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new BreakStatement(lci.Label));                          break;                      case BreakContinueOp.Continue:                          if (labelToLoopCandidateContinueState != null &&                              labelToLoopCandidateContinueState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new ContinueStatement(lci.Label));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      return true;                  }              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return true;                      case MiscOp.Dup:                          return stack.Dup(statements);                      case MiscOp.Pop:                          return stack.PopAndDiscard(statements);                      case MiscOp.Ldnull:                          stack.Push(new ExpressionStackEntry(new NullConstantExpression()' BottomE));                          return true;                      case MiscOp.Ckfinite:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.CheckFinite' false' false)' e.Lub(ThrowsE)));                      case MiscOp.Throw:                          if (!stack.DiscardAll(statements' 1))                              return false;                          if (!stack.PopEvalSE(statements' 1' true' ThrowsE' (s' a) => s.Add(new ThrowStatement(a[0]))))                              return false;                          return true;                      case MiscOp.Rethrow:                          if (!stack.DiscardAll(statements' 0))                              return false;                          if (statements == null)                              return Failed(false' "rethrow");                          if (exid == null)                              throw new InvalidOperationException("rethrow outside of catch");                          statements.Add(new RethrowStatement(new VariableCell(exid).Read()));                          return true;                      case MiscOp.LdindRef:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case MiscOp.LdelemRef:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.Ldlen:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.Length' false' false)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.StindRef:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case MiscOp.StelemRef:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add                                   (new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      case MiscOp.Ret:                          if (statements == null)                              return Failed(false' "return");                          statements.Add(new ReturnStatement(null));                          return true;                      case MiscOp.RetVal:                          return stack.PopEvalSE                              (statements' 1' true' BottomE' (s' a) => s.Add(new ReturnStatement(a[0])));                      case MiscOp.Endfilter:                      case MiscOp.Endfinally:                          throw new InvalidOperationException                              ("endfilter/endfinally instructions should have been removed");                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:              case InstructionFlavor.Switch:                  throw new InvalidOperationException("branch/switch instructions should have been removed");              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      if (cmpi.Op == CompareOp.CtruePseudo || cmpi.Op == CompareOp.CfalsePseudo)                      {                          var s = cmpi.Type.Style(compEnv);                          var unop = default(UnaryOp);                          if (s is NumberTypeStyle)                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonZero : UnaryOp.IsZero;                          else                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonNull : UnaryOp.IsNull;                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new UnaryExpression(a[0]' unop' false' cmpi.IsUnsigned)' e));                      }                      else                      {                          var binop = default(BinaryOp);                          switch (cmpi.Op)                          {                          case CompareOp.Ceq:                              binop = BinaryOp.Eq;                              break;                          case CompareOp.Clt:                              binop = BinaryOp.Lt;                              break;                          case CompareOp.Cgt:                              binop = BinaryOp.Gt;                              break;                          case CompareOp.CgePseudo:                              binop = BinaryOp.Ge;                              break;                          case CompareOp.ClePseudo:                              binop = BinaryOp.Le;                              break;                          case CompareOp.CnePseudo:                              binop = BinaryOp.Ne;                              break;                          case CompareOp.CtruePseudo:                          case CompareOp.CfalsePseudo:                              // handled above                              throw new InvalidOperationException();                          default:                              throw new ArgumentOutOfRangeException();                          }                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression(a[0]' binop' a[1]' false' cmpi.IsUnsigned)' e));                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var sli = (ArgLocalInstruction)instruction;                      var id = default(JST.Identifier);                      switch (sli.ArgLocal)                      {                      case ArgLocal.Arg:                          id = compEnv.ValueParameterIds[sli.Index];                          break;                      case ArgLocal.Local:                          id = compEnv.LocalIds[sli.Index];                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      var cell = new VariableCell(id);                      switch (sli.Op)                      {                      case ArgLocalOp.Ld:                          stack.Push                              (new ExpressionStackEntry                                   (cell.Read().CloneIfStruct(compEnv)' ReadArgLocalE(sli.ArgLocal' sli.Index)));                          return true;                      case ArgLocalOp.Lda:                          // Effect will be accounted for on reads/writes                          stack.Push(new ExpressionStackEntry(cell.AddressOf()' BottomE));                          return true;                      case ArgLocalOp.St:                          return stack.PopEvalSE                              (statements'                               1'                               true'                               WriteArgLocalE(sli.ArgLocal' sli.Index)'                               (s' a) => s.Add(new ExpressionStatement(cell.Write(a[0]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                          {                              stack.Push                                  (new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' ReadHeapE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                       {                                           var readEffect = default(Effects);                                           var obj = default(Expression);                                           if (fieldi.IsViaPointer.Value)                                           {                                               readEffect = e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect());                                               obj = new ReadExpression(a[0]); // no need for clone                                           }                                           else if (fieldi.Field.DefiningType.Style(compEnv) is ValueTypeStyle)                                           {                                               readEffect = e;                                               obj = a[0];                                           }                                           else                                           {                                               // Object could be null                                               readEffect = e.Lub(ReadHeapOrThrowE);                                               obj = a[0];                                           }                                           return new ExpressionStackEntry(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' readEffect);                                       });                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                          {                              // Effect will be accounted for on reads/writes                              stack.Push(new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' BottomE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   {                                       if (fieldi.IsViaPointer.Value)                                           // We're just adding an offset to a pointer' so effect will                                           // be accounted for when the final pointer is read/written                                           return new ExpressionStackEntry(new FieldCell(new ReadExpression(a[0])' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e);                                       else                                           // Must be a reference type' and ref could be null                                           return new ExpressionStackEntry(new FieldCell(a[0]' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e.Lub(ThrowsE));                                   });                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                              return stack.PopEvalSE                                  (statements'                                   1'                                   true'                                   WriteHeapE'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Write(a[0]))));                          else                          {                              var writeEffect = fieldi.IsViaPointer.Value                                                    ? instruction.BeforeState.PeekPointsTo(1).WriteEffect()                                                    : WriteHeapOrThrowE;                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   writeEffect'                                   (s' a) =>                                       {                                           var obj = fieldi.IsViaPointer.Value ? new ReadExpression(a[0]) : a[0];                                           s.Add(new ExpressionStatement(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Write(a[1])));                                       });                          }                      case FieldOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new FieldHandleConstantExpression(compEnv.SubstituteMember(fieldi.Field))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methodi = (MethodInstruction)instruction;                      var arity = methodi.Method.ValueParameters.Count;                      switch (methodi.Op)                      {                      case MethodOp.Ldftn:                          if (methodi.IsVirtual)                              // Object could be null                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CodePointerExpression(a[0]' compEnv.SubstituteMember(methodi.Method))' e.Lub(ReadHeapOrThrowE)));                          else                          {                              stack.Push                                  (new ExpressionStackEntry(new CodePointerExpression(null' compEnv.SubstituteMember(methodi.Method))' BottomE));                              return true;                          }                      case MethodOp.Call:                          if (methodi.Method.Result == null)                              return stack.PopEvalSE                                  (statements'                                   arity'                                   true'                                   CalleeEffects(methodi.BeforeState' arity)'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new CallExpression                                                 (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal'                                                  compEnv.SubstituteMember(methodi.Method)'                                                  CallerArguments(methodi.Constrained' methodi.Method' a)))));                          else                              return stack.PopEvalPush                                  (statements'                                   arity'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CallExpression                                            (methodi.IsVirtual? CallFlavor.Virtual : CallFlavor.Normal'                                             compEnv.SubstituteMember(methodi.Method)'                                             CallerArguments(methodi.Constrained' methodi.Method' a))'                                        e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Newobj:                          arity--;                          return stack.PopEvalPush                              (statements'                               arity'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new NewObjectExpression(compEnv.SubstituteMember(methodi.Method)' CallerArguments(null' methodi.Method' a))'                                    e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Ldtoken:                          stack.Push                              (new ExpressionStackEntry(new MethodHandleConstantExpression(compEnv.SubstituteMember(methodi.Method))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case TypeOp.Stobj:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case TypeOp.Cpobj:                          {                              var copyEffect = instruction.BeforeState.PeekPointsTo(0).ReadEffect().Lub                                  (instruction.BeforeState.PeekPointsTo(1).WriteEffect());                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   copyEffect'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new WriteExpression(a[0]' new ReadExpression(a[1]).CloneIfStruct(compEnv)))));                          }                      case TypeOp.Newarr:                          // Growing the heap is not considered an observable change. But will throw if                          // length < 0                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new NewArrayExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Initobj:                          return stack.PopEvalSE                              (statements' 1' true' WriteHeapE' (s' a) => s.Add(new InitializeObjectStatement(a[0])));                      case TypeOp.Castclass:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new CastExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Isinst:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new IsInstExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Box:                          // Growing the heap is not considered an observable change                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new NewBoxExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Unbox:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).AddressOf()' e.Lub(ThrowsE)));                      case TypeOp.UnboxAny:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).Read().CloneIfStruct(compEnv)' e.Lub(ThrowsE)));                      case TypeOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new TypeHandleConstantExpression(compEnv.SubstituteType(typei.Type))' BottomE));                          return true;                      case TypeOp.Ldelem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case TypeOp.Stelem:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add(new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  // Calculating the pointer may throw if index is out of range.                  // Remaining effect will be accounted for when pointer is read/written.                  return stack.PopEvalPush                      (statements'                       2'                       true'                       (a' e) =>                       new ExpressionStackEntry(new ElementCell(a[0]' a[1]' false).AddressOf()' e.Lub(ThrowsE)));              case InstructionFlavor.LdInt32:                  {                      var int32i = (LdInt32Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int32ConstantExpression(int32i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdInt64:                  {                      var int64i = (LdInt64Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int64ConstantExpression(int64i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdSingle:                  {                      var singlei = (LdSingleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new SingleConstantExpression(singlei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdDouble:                  {                      var doublei = (LdDoubleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new DoubleConstantExpression(doublei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdString:                  {                      var stringi = (LdStringInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new StringConstantExpression(stringi.Value)' BottomE));                      return true;                  }              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Div:                      case ArithOp.Rem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(ThrowsE)));                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                      case ArithOp.Shl:                      case ArithOp.Shr:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(arithi.WithOverflow ? ThrowsE : BottomE)));                      case ArithOp.Neg:                      case ArithOp.BitNot:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression                                        (a[0]' ArithOpToUnaryOp(arithi.Op)' arithi.WithOverflow' arithi.IsUnsigned)'                                    e));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      return stack.PopEvalPush                          (statements'                           1'                           true'                           (a' e) =>                           new ExpressionStackEntry                               (new ConvertExpression                                    (a[0]'                                     new NamedTypeRef                                         (compEnv.Global.NumberFlavorToQualifiedTypeName[convi.TargetNumberFlavor])'                                     convi.WithOverflow'                                     convi.IsSourceUnsigned)'                                e.Lub(convi.WithOverflow ? ThrowsE : BottomE)));                  }              case InstructionFlavor.Try:                  {                      if (stack.Depth > 0)                          throw new InvalidOperationException("stack must be empty on entry to try block");                      var tryi = (TryInstruction)instruction;                      var tryStatements = BlockToTryFaultFinallyStatements(tryi.Body);                      if (tryStatements == null)                          return false;                      var handlers = TranslateHandlers(tryi.Handlers);                      if (handlers == null)                          return false;                      if (statements == null)                          return Failed(false' "try");                      statements.Add(new TryStatement(tryStatements' handlers));                      return true;                  }              case InstructionFlavor.IfThenElsePseudo:                  {                      var itei = (IfThenElseInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(itei.Offset' out isExpr) ||                                              isExpr;                        if (!TranslateBlock(statements' itei.Condition' stack' exid))                          return false;                      if (couldBeExpression && itei.Else != null)                      {                          // Pass 1: Try to tranlate to an if-then-else expression. Will only work if Then and Else don't                          //         reach into current stack' push exactly one value' and don't need to emit any                          //         statements along the way.                          var thenEntry = BlockToExpression(itei.Then' exid);                          if (thenEntry != null)                          {                              var elseEntry = BlockToExpression(itei.Else' exid);                              if (elseEntry != null)                              {                                  if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                                      instructionTranslationStyleCache.Add(itei.Offset' true);                                  return stack.PopEvalPush                                      (statements'                                       1'                                       true'                                       (a' e) =>                                       new ExpressionStackEntry                                           (new IfThenElseExpression(a[0]' thenEntry.Expression' elseEntry.Expression)'                                            e.Lub(thenEntry.Effects.Lub(elseEntry.Effects))));                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      var noStackChange = itei.Then.NoStackChange && (itei.Else == null || itei.Else.NoStackChange);                      var condEntry = noStackChange                                          ? stack.Pop()                                          : stack.FlushAndPopPostState(statements' itei.Then.BeforeState);                      if (condEntry == null)                          return false;                      var thenStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Then' exid)                                           : BlockToStatements(itei.Then' exid);                      if (thenStmnts == null)                          return false;                      var elseStmnts = default(Seq<Statement>);                      if (itei.Else != null)                      {                          elseStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Else' exid)                                           : BlockToStatements(itei.Else' exid);                          if (elseStmnts == null)                              return false;                      }                      if (statements == null)                          return Failed(false' "if-then-else");                      statements.Add                          (new IfThenElseStatement(condEntry.Expression' new Statements(thenStmnts)' elseStmnts == null ? null : new Statements(elseStmnts)));                      if (!noStackChange && !stack.Restore(itei.AfterState' 0))                          return false;                      if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                          instructionTranslationStyleCache.Add(itei.Offset' false);                      return true;                  }              case InstructionFlavor.ShortCircuitingPseudo:                  {                      var sci = (ShortCircuitingInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(sci.Offset' out isExpr) ||                                              isExpr;                      if (couldBeExpression)                      {                          // Pass 1: Try to translate to an expression.                          var leftEntry = BlockToExpression(sci.Left' exid);                          if (leftEntry != null)                          {                              var rightEntry = BlockToExpression(sci.Right' exid);                              if (rightEntry != null)                              {                                  stack.Push                                      (new ExpressionStackEntry                                           (new BinaryExpression                                                (leftEntry.Expression'                                                 ShortCircuitingOpToBinaryOp(sci.Op)'                                                 rightEntry.Expression'                                                 false'                                                 false)'                                            leftEntry.Effects.Lub(rightEntry.Effects)));                                  if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                                      instructionTranslationStyleCache.Add(sci.Offset' true);                                  return true;                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      if (!TranslateBlock(statements' sci.Left' stack' exid))                          return false;                      var leftEntry2 = stack.FlushAndPopPostState(statements' sci.Right.BeforeState);                      if (leftEntry2 == null)                          return false;                      var rightStatements = BlockToStatements(sci.Right' exid);                      if (rightStatements == null)                          return false;                      var id = sci.Right.AfterState.PeekId(0' nameSupply.GenSym);                      var cell = new VariableCell(id);                      compEnv.AddVariable(id' ArgLocal.Local' false' true' compEnv.SubstituteType(sci.Right.AfterState.PeekType(0)));                      if (statements == null)                          return Failed(false' "short-circuit");                      switch (sci.Op)                      {                      case ShortCircuitingOp.And:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements(rightStatements)'                                    new Statements                                        (new ExpressionStatement(cell.Write(new Int32ConstantExpression(0))))));                          break;                      case ShortCircuitingOp.Or:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements                                        (new ExpressionStatement                                             (cell.Write(new Int32ConstantExpression(1))))'                                    new Statements(rightStatements)));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      if (!stack.Restore(sci.AfterState' 1))                          return false;                      stack.Push(new ExpressionStackEntry(cell.Read()' BottomE));                      if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                          instructionTranslationStyleCache.Add(sci.Offset' false);                      return true;                  }              case InstructionFlavor.StructuralSwitchPseudo:                  {                      var ssi = (StructuralSwitchInstruction)instruction;                      if (!TranslateBlock(statements' ssi.Body' stack' exid))                          return false;                      var valueEntry = stack.FlushAndPopPreState(statements' ssi.Body.AfterState);                      if (valueEntry == null)                          return false;                      var cases = new Seq<SwitchStatementCase>();                      foreach (var c in ssi.Cases)                      {                          var caseStatements = BlockToStatements(c.Body' exid);                          if (caseStatements == null)                              return false;                          cases.Add(new SwitchStatementCase(c.Values' new Statements(caseStatements)));                      }                      if (statements == null)                          return Failed(false' "structural switch");                      statements.Add(new SwitchStatement(valueEntry.Expression' cases));                      if (!stack.Restore(ssi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopPseudo:                  {                      var li = (LoopInstruction)instruction;                      if (!stack.Flush(statements' li.Body.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop");                      var whileStatements = BlockToStatements(li.Body' exid);                      statements.Add                          (new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(whileStatements)));                      if (!stack.Restore(li.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.WhileDoPseudo:                  {                      var wdi = (WhileDoInstruction)instruction;                      if (!stack.Flush(statements' wdi.Condition.BeforeState))                          return false;                      var condEntry = BlockToExpression(wdi.Condition' exid);                      if (condEntry == null)                      {                          var stack1 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Condition.BeforeState' trace);                          var preCondStatements = new Seq<Statement>();                          if (!TranslateBlock(preCondStatements' wdi.Condition' stack1' exid))                              return false;                          condEntry = stack1.FlushAndPopPostState(preCondStatements' wdi.Body.BeforeState);                          if (condEntry == null)                              return false;                          var stack2 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Body.BeforeState' trace);                          var postCondStatements = new Seq<Statement>();                          if (!TranslateBlock(postCondStatements' wdi.Body' stack2' exid))                              return false;                          if (!stack2.Flush(postCondStatements' wdi.Body.AfterState))                              return false;                          preCondStatements.Add                              (new IfThenElseStatement                                   (condEntry.Expression'                                    new Statements(postCondStatements)'                                    new Statements(new BreakStatement())));                          statements.Add(new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(preCondStatements)));                      }                      else                      {                          var loopStatements = BlockToStatements(wdi.Body' exid);                          if (loopStatements == null)                              return false;                          if (statements == null)                              return Failed(false' "while-do");                          statements.Add(new WhileDoStatement(condEntry.Expression' new Statements(loopStatements)));                      }                      if (!stack.Restore(wdi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.DoWhilePseudo:                  {                      var dwi = (DoWhileInstruction)instruction;                      if (!stack.Flush(statements' dwi.Body.BeforeState))                          return false;                      var combined = new Seq<Instruction>();                      foreach (var i in dwi.Body.Body)                          combined.Add(i);                      foreach (var i in dwi.Condition.Body)                          combined.Add(i);                      var condEntry = default(ExpressionStackEntry);                      var loopStatements = BlockToConditionStatements                          (new Instructions(null' combined)' dwi.Body.BeforeState' exid' out condEntry);                      if (loopStatements == null)                          return false;                      if (statements == null)                          return Failed(false' "do-while");                      statements.Add(new DoWhileStatement(new Statements(loopStatements)' condEntry.Expression));                      if (!stack.Restore(dwi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopControlPseudo:                  {                      var lci = (BreakContinueInstruction)instruction;                      if (!stack.Flush(statements' lci.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop-control");                      var targetState = default(int);                      switch (lci.Op)                      {                      case BreakContinueOp.Break:                          if (labelToLoopCandidateBreakState != null &&                              labelToLoopCandidateBreakState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new BreakStatement(lci.Label));                          break;                      case BreakContinueOp.Continue:                          if (labelToLoopCandidateContinueState != null &&                              labelToLoopCandidateContinueState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new ContinueStatement(lci.Label));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      return true;                  }              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return true;                      case MiscOp.Dup:                          return stack.Dup(statements);                      case MiscOp.Pop:                          return stack.PopAndDiscard(statements);                      case MiscOp.Ldnull:                          stack.Push(new ExpressionStackEntry(new NullConstantExpression()' BottomE));                          return true;                      case MiscOp.Ckfinite:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.CheckFinite' false' false)' e.Lub(ThrowsE)));                      case MiscOp.Throw:                          if (!stack.DiscardAll(statements' 1))                              return false;                          if (!stack.PopEvalSE(statements' 1' true' ThrowsE' (s' a) => s.Add(new ThrowStatement(a[0]))))                              return false;                          return true;                      case MiscOp.Rethrow:                          if (!stack.DiscardAll(statements' 0))                              return false;                          if (statements == null)                              return Failed(false' "rethrow");                          if (exid == null)                              throw new InvalidOperationException("rethrow outside of catch");                          statements.Add(new RethrowStatement(new VariableCell(exid).Read()));                          return true;                      case MiscOp.LdindRef:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case MiscOp.LdelemRef:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.Ldlen:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.Length' false' false)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.StindRef:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case MiscOp.StelemRef:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add                                   (new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      case MiscOp.Ret:                          if (statements == null)                              return Failed(false' "return");                          statements.Add(new ReturnStatement(null));                          return true;                      case MiscOp.RetVal:                          return stack.PopEvalSE                              (statements' 1' true' BottomE' (s' a) => s.Add(new ReturnStatement(a[0])));                      case MiscOp.Endfilter:                      case MiscOp.Endfinally:                          throw new InvalidOperationException                              ("endfilter/endfinally instructions should have been removed");                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:              case InstructionFlavor.Switch:                  throw new InvalidOperationException("branch/switch instructions should have been removed");              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      if (cmpi.Op == CompareOp.CtruePseudo || cmpi.Op == CompareOp.CfalsePseudo)                      {                          var s = cmpi.Type.Style(compEnv);                          var unop = default(UnaryOp);                          if (s is NumberTypeStyle)                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonZero : UnaryOp.IsZero;                          else                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonNull : UnaryOp.IsNull;                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new UnaryExpression(a[0]' unop' false' cmpi.IsUnsigned)' e));                      }                      else                      {                          var binop = default(BinaryOp);                          switch (cmpi.Op)                          {                          case CompareOp.Ceq:                              binop = BinaryOp.Eq;                              break;                          case CompareOp.Clt:                              binop = BinaryOp.Lt;                              break;                          case CompareOp.Cgt:                              binop = BinaryOp.Gt;                              break;                          case CompareOp.CgePseudo:                              binop = BinaryOp.Ge;                              break;                          case CompareOp.ClePseudo:                              binop = BinaryOp.Le;                              break;                          case CompareOp.CnePseudo:                              binop = BinaryOp.Ne;                              break;                          case CompareOp.CtruePseudo:                          case CompareOp.CfalsePseudo:                              // handled above                              throw new InvalidOperationException();                          default:                              throw new ArgumentOutOfRangeException();                          }                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression(a[0]' binop' a[1]' false' cmpi.IsUnsigned)' e));                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var sli = (ArgLocalInstruction)instruction;                      var id = default(JST.Identifier);                      switch (sli.ArgLocal)                      {                      case ArgLocal.Arg:                          id = compEnv.ValueParameterIds[sli.Index];                          break;                      case ArgLocal.Local:                          id = compEnv.LocalIds[sli.Index];                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      var cell = new VariableCell(id);                      switch (sli.Op)                      {                      case ArgLocalOp.Ld:                          stack.Push                              (new ExpressionStackEntry                                   (cell.Read().CloneIfStruct(compEnv)' ReadArgLocalE(sli.ArgLocal' sli.Index)));                          return true;                      case ArgLocalOp.Lda:                          // Effect will be accounted for on reads/writes                          stack.Push(new ExpressionStackEntry(cell.AddressOf()' BottomE));                          return true;                      case ArgLocalOp.St:                          return stack.PopEvalSE                              (statements'                               1'                               true'                               WriteArgLocalE(sli.ArgLocal' sli.Index)'                               (s' a) => s.Add(new ExpressionStatement(cell.Write(a[0]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                          {                              stack.Push                                  (new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' ReadHeapE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                       {                                           var readEffect = default(Effects);                                           var obj = default(Expression);                                           if (fieldi.IsViaPointer.Value)                                           {                                               readEffect = e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect());                                               obj = new ReadExpression(a[0]); // no need for clone                                           }                                           else if (fieldi.Field.DefiningType.Style(compEnv) is ValueTypeStyle)                                           {                                               readEffect = e;                                               obj = a[0];                                           }                                           else                                           {                                               // Object could be null                                               readEffect = e.Lub(ReadHeapOrThrowE);                                               obj = a[0];                                           }                                           return new ExpressionStackEntry(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' readEffect);                                       });                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                          {                              // Effect will be accounted for on reads/writes                              stack.Push(new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' BottomE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   {                                       if (fieldi.IsViaPointer.Value)                                           // We're just adding an offset to a pointer' so effect will                                           // be accounted for when the final pointer is read/written                                           return new ExpressionStackEntry(new FieldCell(new ReadExpression(a[0])' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e);                                       else                                           // Must be a reference type' and ref could be null                                           return new ExpressionStackEntry(new FieldCell(a[0]' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e.Lub(ThrowsE));                                   });                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                              return stack.PopEvalSE                                  (statements'                                   1'                                   true'                                   WriteHeapE'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Write(a[0]))));                          else                          {                              var writeEffect = fieldi.IsViaPointer.Value                                                    ? instruction.BeforeState.PeekPointsTo(1).WriteEffect()                                                    : WriteHeapOrThrowE;                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   writeEffect'                                   (s' a) =>                                       {                                           var obj = fieldi.IsViaPointer.Value ? new ReadExpression(a[0]) : a[0];                                           s.Add(new ExpressionStatement(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Write(a[1])));                                       });                          }                      case FieldOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new FieldHandleConstantExpression(compEnv.SubstituteMember(fieldi.Field))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methodi = (MethodInstruction)instruction;                      var arity = methodi.Method.ValueParameters.Count;                      switch (methodi.Op)                      {                      case MethodOp.Ldftn:                          if (methodi.IsVirtual)                              // Object could be null                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CodePointerExpression(a[0]' compEnv.SubstituteMember(methodi.Method))' e.Lub(ReadHeapOrThrowE)));                          else                          {                              stack.Push                                  (new ExpressionStackEntry(new CodePointerExpression(null' compEnv.SubstituteMember(methodi.Method))' BottomE));                              return true;                          }                      case MethodOp.Call:                          if (methodi.Method.Result == null)                              return stack.PopEvalSE                                  (statements'                                   arity'                                   true'                                   CalleeEffects(methodi.BeforeState' arity)'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new CallExpression                                                 (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal'                                                  compEnv.SubstituteMember(methodi.Method)'                                                  CallerArguments(methodi.Constrained' methodi.Method' a)))));                          else                              return stack.PopEvalPush                                  (statements'                                   arity'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CallExpression                                            (methodi.IsVirtual? CallFlavor.Virtual : CallFlavor.Normal'                                             compEnv.SubstituteMember(methodi.Method)'                                             CallerArguments(methodi.Constrained' methodi.Method' a))'                                        e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Newobj:                          arity--;                          return stack.PopEvalPush                              (statements'                               arity'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new NewObjectExpression(compEnv.SubstituteMember(methodi.Method)' CallerArguments(null' methodi.Method' a))'                                    e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Ldtoken:                          stack.Push                              (new ExpressionStackEntry(new MethodHandleConstantExpression(compEnv.SubstituteMember(methodi.Method))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case TypeOp.Stobj:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case TypeOp.Cpobj:                          {                              var copyEffect = instruction.BeforeState.PeekPointsTo(0).ReadEffect().Lub                                  (instruction.BeforeState.PeekPointsTo(1).WriteEffect());                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   copyEffect'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new WriteExpression(a[0]' new ReadExpression(a[1]).CloneIfStruct(compEnv)))));                          }                      case TypeOp.Newarr:                          // Growing the heap is not considered an observable change. But will throw if                          // length < 0                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new NewArrayExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Initobj:                          return stack.PopEvalSE                              (statements' 1' true' WriteHeapE' (s' a) => s.Add(new InitializeObjectStatement(a[0])));                      case TypeOp.Castclass:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new CastExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Isinst:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new IsInstExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Box:                          // Growing the heap is not considered an observable change                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new NewBoxExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Unbox:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).AddressOf()' e.Lub(ThrowsE)));                      case TypeOp.UnboxAny:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).Read().CloneIfStruct(compEnv)' e.Lub(ThrowsE)));                      case TypeOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new TypeHandleConstantExpression(compEnv.SubstituteType(typei.Type))' BottomE));                          return true;                      case TypeOp.Ldelem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case TypeOp.Stelem:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add(new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  // Calculating the pointer may throw if index is out of range.                  // Remaining effect will be accounted for when pointer is read/written.                  return stack.PopEvalPush                      (statements'                       2'                       true'                       (a' e) =>                       new ExpressionStackEntry(new ElementCell(a[0]' a[1]' false).AddressOf()' e.Lub(ThrowsE)));              case InstructionFlavor.LdInt32:                  {                      var int32i = (LdInt32Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int32ConstantExpression(int32i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdInt64:                  {                      var int64i = (LdInt64Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int64ConstantExpression(int64i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdSingle:                  {                      var singlei = (LdSingleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new SingleConstantExpression(singlei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdDouble:                  {                      var doublei = (LdDoubleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new DoubleConstantExpression(doublei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdString:                  {                      var stringi = (LdStringInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new StringConstantExpression(stringi.Value)' BottomE));                      return true;                  }              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Div:                      case ArithOp.Rem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(ThrowsE)));                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                      case ArithOp.Shl:                      case ArithOp.Shr:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(arithi.WithOverflow ? ThrowsE : BottomE)));                      case ArithOp.Neg:                      case ArithOp.BitNot:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression                                        (a[0]' ArithOpToUnaryOp(arithi.Op)' arithi.WithOverflow' arithi.IsUnsigned)'                                    e));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      return stack.PopEvalPush                          (statements'                           1'                           true'                           (a' e) =>                           new ExpressionStackEntry                               (new ConvertExpression                                    (a[0]'                                     new NamedTypeRef                                         (compEnv.Global.NumberFlavorToQualifiedTypeName[convi.TargetNumberFlavor])'                                     convi.WithOverflow'                                     convi.IsSourceUnsigned)'                                e.Lub(convi.WithOverflow ? ThrowsE : BottomE)));                  }              case InstructionFlavor.Try:                  {                      if (stack.Depth > 0)                          throw new InvalidOperationException("stack must be empty on entry to try block");                      var tryi = (TryInstruction)instruction;                      var tryStatements = BlockToTryFaultFinallyStatements(tryi.Body);                      if (tryStatements == null)                          return false;                      var handlers = TranslateHandlers(tryi.Handlers);                      if (handlers == null)                          return false;                      if (statements == null)                          return Failed(false' "try");                      statements.Add(new TryStatement(tryStatements' handlers));                      return true;                  }              case InstructionFlavor.IfThenElsePseudo:                  {                      var itei = (IfThenElseInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(itei.Offset' out isExpr) ||                                              isExpr;                        if (!TranslateBlock(statements' itei.Condition' stack' exid))                          return false;                      if (couldBeExpression && itei.Else != null)                      {                          // Pass 1: Try to tranlate to an if-then-else expression. Will only work if Then and Else don't                          //         reach into current stack' push exactly one value' and don't need to emit any                          //         statements along the way.                          var thenEntry = BlockToExpression(itei.Then' exid);                          if (thenEntry != null)                          {                              var elseEntry = BlockToExpression(itei.Else' exid);                              if (elseEntry != null)                              {                                  if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                                      instructionTranslationStyleCache.Add(itei.Offset' true);                                  return stack.PopEvalPush                                      (statements'                                       1'                                       true'                                       (a' e) =>                                       new ExpressionStackEntry                                           (new IfThenElseExpression(a[0]' thenEntry.Expression' elseEntry.Expression)'                                            e.Lub(thenEntry.Effects.Lub(elseEntry.Effects))));                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      var noStackChange = itei.Then.NoStackChange && (itei.Else == null || itei.Else.NoStackChange);                      var condEntry = noStackChange                                          ? stack.Pop()                                          : stack.FlushAndPopPostState(statements' itei.Then.BeforeState);                      if (condEntry == null)                          return false;                      var thenStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Then' exid)                                           : BlockToStatements(itei.Then' exid);                      if (thenStmnts == null)                          return false;                      var elseStmnts = default(Seq<Statement>);                      if (itei.Else != null)                      {                          elseStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Else' exid)                                           : BlockToStatements(itei.Else' exid);                          if (elseStmnts == null)                              return false;                      }                      if (statements == null)                          return Failed(false' "if-then-else");                      statements.Add                          (new IfThenElseStatement(condEntry.Expression' new Statements(thenStmnts)' elseStmnts == null ? null : new Statements(elseStmnts)));                      if (!noStackChange && !stack.Restore(itei.AfterState' 0))                          return false;                      if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                          instructionTranslationStyleCache.Add(itei.Offset' false);                      return true;                  }              case InstructionFlavor.ShortCircuitingPseudo:                  {                      var sci = (ShortCircuitingInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(sci.Offset' out isExpr) ||                                              isExpr;                      if (couldBeExpression)                      {                          // Pass 1: Try to translate to an expression.                          var leftEntry = BlockToExpression(sci.Left' exid);                          if (leftEntry != null)                          {                              var rightEntry = BlockToExpression(sci.Right' exid);                              if (rightEntry != null)                              {                                  stack.Push                                      (new ExpressionStackEntry                                           (new BinaryExpression                                                (leftEntry.Expression'                                                 ShortCircuitingOpToBinaryOp(sci.Op)'                                                 rightEntry.Expression'                                                 false'                                                 false)'                                            leftEntry.Effects.Lub(rightEntry.Effects)));                                  if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                                      instructionTranslationStyleCache.Add(sci.Offset' true);                                  return true;                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      if (!TranslateBlock(statements' sci.Left' stack' exid))                          return false;                      var leftEntry2 = stack.FlushAndPopPostState(statements' sci.Right.BeforeState);                      if (leftEntry2 == null)                          return false;                      var rightStatements = BlockToStatements(sci.Right' exid);                      if (rightStatements == null)                          return false;                      var id = sci.Right.AfterState.PeekId(0' nameSupply.GenSym);                      var cell = new VariableCell(id);                      compEnv.AddVariable(id' ArgLocal.Local' false' true' compEnv.SubstituteType(sci.Right.AfterState.PeekType(0)));                      if (statements == null)                          return Failed(false' "short-circuit");                      switch (sci.Op)                      {                      case ShortCircuitingOp.And:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements(rightStatements)'                                    new Statements                                        (new ExpressionStatement(cell.Write(new Int32ConstantExpression(0))))));                          break;                      case ShortCircuitingOp.Or:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements                                        (new ExpressionStatement                                             (cell.Write(new Int32ConstantExpression(1))))'                                    new Statements(rightStatements)));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      if (!stack.Restore(sci.AfterState' 1))                          return false;                      stack.Push(new ExpressionStackEntry(cell.Read()' BottomE));                      if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                          instructionTranslationStyleCache.Add(sci.Offset' false);                      return true;                  }              case InstructionFlavor.StructuralSwitchPseudo:                  {                      var ssi = (StructuralSwitchInstruction)instruction;                      if (!TranslateBlock(statements' ssi.Body' stack' exid))                          return false;                      var valueEntry = stack.FlushAndPopPreState(statements' ssi.Body.AfterState);                      if (valueEntry == null)                          return false;                      var cases = new Seq<SwitchStatementCase>();                      foreach (var c in ssi.Cases)                      {                          var caseStatements = BlockToStatements(c.Body' exid);                          if (caseStatements == null)                              return false;                          cases.Add(new SwitchStatementCase(c.Values' new Statements(caseStatements)));                      }                      if (statements == null)                          return Failed(false' "structural switch");                      statements.Add(new SwitchStatement(valueEntry.Expression' cases));                      if (!stack.Restore(ssi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopPseudo:                  {                      var li = (LoopInstruction)instruction;                      if (!stack.Flush(statements' li.Body.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop");                      var whileStatements = BlockToStatements(li.Body' exid);                      statements.Add                          (new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(whileStatements)));                      if (!stack.Restore(li.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.WhileDoPseudo:                  {                      var wdi = (WhileDoInstruction)instruction;                      if (!stack.Flush(statements' wdi.Condition.BeforeState))                          return false;                      var condEntry = BlockToExpression(wdi.Condition' exid);                      if (condEntry == null)                      {                          var stack1 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Condition.BeforeState' trace);                          var preCondStatements = new Seq<Statement>();                          if (!TranslateBlock(preCondStatements' wdi.Condition' stack1' exid))                              return false;                          condEntry = stack1.FlushAndPopPostState(preCondStatements' wdi.Body.BeforeState);                          if (condEntry == null)                              return false;                          var stack2 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Body.BeforeState' trace);                          var postCondStatements = new Seq<Statement>();                          if (!TranslateBlock(postCondStatements' wdi.Body' stack2' exid))                              return false;                          if (!stack2.Flush(postCondStatements' wdi.Body.AfterState))                              return false;                          preCondStatements.Add                              (new IfThenElseStatement                                   (condEntry.Expression'                                    new Statements(postCondStatements)'                                    new Statements(new BreakStatement())));                          statements.Add(new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(preCondStatements)));                      }                      else                      {                          var loopStatements = BlockToStatements(wdi.Body' exid);                          if (loopStatements == null)                              return false;                          if (statements == null)                              return Failed(false' "while-do");                          statements.Add(new WhileDoStatement(condEntry.Expression' new Statements(loopStatements)));                      }                      if (!stack.Restore(wdi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.DoWhilePseudo:                  {                      var dwi = (DoWhileInstruction)instruction;                      if (!stack.Flush(statements' dwi.Body.BeforeState))                          return false;                      var combined = new Seq<Instruction>();                      foreach (var i in dwi.Body.Body)                          combined.Add(i);                      foreach (var i in dwi.Condition.Body)                          combined.Add(i);                      var condEntry = default(ExpressionStackEntry);                      var loopStatements = BlockToConditionStatements                          (new Instructions(null' combined)' dwi.Body.BeforeState' exid' out condEntry);                      if (loopStatements == null)                          return false;                      if (statements == null)                          return Failed(false' "do-while");                      statements.Add(new DoWhileStatement(new Statements(loopStatements)' condEntry.Expression));                      if (!stack.Restore(dwi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopControlPseudo:                  {                      var lci = (BreakContinueInstruction)instruction;                      if (!stack.Flush(statements' lci.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop-control");                      var targetState = default(int);                      switch (lci.Op)                      {                      case BreakContinueOp.Break:                          if (labelToLoopCandidateBreakState != null &&                              labelToLoopCandidateBreakState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new BreakStatement(lci.Label));                          break;                      case BreakContinueOp.Continue:                          if (labelToLoopCandidateContinueState != null &&                              labelToLoopCandidateContinueState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new ContinueStatement(lci.Label));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      return true;                  }              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return true;                      case MiscOp.Dup:                          return stack.Dup(statements);                      case MiscOp.Pop:                          return stack.PopAndDiscard(statements);                      case MiscOp.Ldnull:                          stack.Push(new ExpressionStackEntry(new NullConstantExpression()' BottomE));                          return true;                      case MiscOp.Ckfinite:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.CheckFinite' false' false)' e.Lub(ThrowsE)));                      case MiscOp.Throw:                          if (!stack.DiscardAll(statements' 1))                              return false;                          if (!stack.PopEvalSE(statements' 1' true' ThrowsE' (s' a) => s.Add(new ThrowStatement(a[0]))))                              return false;                          return true;                      case MiscOp.Rethrow:                          if (!stack.DiscardAll(statements' 0))                              return false;                          if (statements == null)                              return Failed(false' "rethrow");                          if (exid == null)                              throw new InvalidOperationException("rethrow outside of catch");                          statements.Add(new RethrowStatement(new VariableCell(exid).Read()));                          return true;                      case MiscOp.LdindRef:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case MiscOp.LdelemRef:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.Ldlen:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.Length' false' false)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.StindRef:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case MiscOp.StelemRef:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add                                   (new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      case MiscOp.Ret:                          if (statements == null)                              return Failed(false' "return");                          statements.Add(new ReturnStatement(null));                          return true;                      case MiscOp.RetVal:                          return stack.PopEvalSE                              (statements' 1' true' BottomE' (s' a) => s.Add(new ReturnStatement(a[0])));                      case MiscOp.Endfilter:                      case MiscOp.Endfinally:                          throw new InvalidOperationException                              ("endfilter/endfinally instructions should have been removed");                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:              case InstructionFlavor.Switch:                  throw new InvalidOperationException("branch/switch instructions should have been removed");              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      if (cmpi.Op == CompareOp.CtruePseudo || cmpi.Op == CompareOp.CfalsePseudo)                      {                          var s = cmpi.Type.Style(compEnv);                          var unop = default(UnaryOp);                          if (s is NumberTypeStyle)                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonZero : UnaryOp.IsZero;                          else                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonNull : UnaryOp.IsNull;                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new UnaryExpression(a[0]' unop' false' cmpi.IsUnsigned)' e));                      }                      else                      {                          var binop = default(BinaryOp);                          switch (cmpi.Op)                          {                          case CompareOp.Ceq:                              binop = BinaryOp.Eq;                              break;                          case CompareOp.Clt:                              binop = BinaryOp.Lt;                              break;                          case CompareOp.Cgt:                              binop = BinaryOp.Gt;                              break;                          case CompareOp.CgePseudo:                              binop = BinaryOp.Ge;                              break;                          case CompareOp.ClePseudo:                              binop = BinaryOp.Le;                              break;                          case CompareOp.CnePseudo:                              binop = BinaryOp.Ne;                              break;                          case CompareOp.CtruePseudo:                          case CompareOp.CfalsePseudo:                              // handled above                              throw new InvalidOperationException();                          default:                              throw new ArgumentOutOfRangeException();                          }                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression(a[0]' binop' a[1]' false' cmpi.IsUnsigned)' e));                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var sli = (ArgLocalInstruction)instruction;                      var id = default(JST.Identifier);                      switch (sli.ArgLocal)                      {                      case ArgLocal.Arg:                          id = compEnv.ValueParameterIds[sli.Index];                          break;                      case ArgLocal.Local:                          id = compEnv.LocalIds[sli.Index];                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      var cell = new VariableCell(id);                      switch (sli.Op)                      {                      case ArgLocalOp.Ld:                          stack.Push                              (new ExpressionStackEntry                                   (cell.Read().CloneIfStruct(compEnv)' ReadArgLocalE(sli.ArgLocal' sli.Index)));                          return true;                      case ArgLocalOp.Lda:                          // Effect will be accounted for on reads/writes                          stack.Push(new ExpressionStackEntry(cell.AddressOf()' BottomE));                          return true;                      case ArgLocalOp.St:                          return stack.PopEvalSE                              (statements'                               1'                               true'                               WriteArgLocalE(sli.ArgLocal' sli.Index)'                               (s' a) => s.Add(new ExpressionStatement(cell.Write(a[0]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                          {                              stack.Push                                  (new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' ReadHeapE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                       {                                           var readEffect = default(Effects);                                           var obj = default(Expression);                                           if (fieldi.IsViaPointer.Value)                                           {                                               readEffect = e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect());                                               obj = new ReadExpression(a[0]); // no need for clone                                           }                                           else if (fieldi.Field.DefiningType.Style(compEnv) is ValueTypeStyle)                                           {                                               readEffect = e;                                               obj = a[0];                                           }                                           else                                           {                                               // Object could be null                                               readEffect = e.Lub(ReadHeapOrThrowE);                                               obj = a[0];                                           }                                           return new ExpressionStackEntry(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' readEffect);                                       });                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                          {                              // Effect will be accounted for on reads/writes                              stack.Push(new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' BottomE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   {                                       if (fieldi.IsViaPointer.Value)                                           // We're just adding an offset to a pointer' so effect will                                           // be accounted for when the final pointer is read/written                                           return new ExpressionStackEntry(new FieldCell(new ReadExpression(a[0])' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e);                                       else                                           // Must be a reference type' and ref could be null                                           return new ExpressionStackEntry(new FieldCell(a[0]' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e.Lub(ThrowsE));                                   });                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                              return stack.PopEvalSE                                  (statements'                                   1'                                   true'                                   WriteHeapE'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Write(a[0]))));                          else                          {                              var writeEffect = fieldi.IsViaPointer.Value                                                    ? instruction.BeforeState.PeekPointsTo(1).WriteEffect()                                                    : WriteHeapOrThrowE;                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   writeEffect'                                   (s' a) =>                                       {                                           var obj = fieldi.IsViaPointer.Value ? new ReadExpression(a[0]) : a[0];                                           s.Add(new ExpressionStatement(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Write(a[1])));                                       });                          }                      case FieldOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new FieldHandleConstantExpression(compEnv.SubstituteMember(fieldi.Field))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methodi = (MethodInstruction)instruction;                      var arity = methodi.Method.ValueParameters.Count;                      switch (methodi.Op)                      {                      case MethodOp.Ldftn:                          if (methodi.IsVirtual)                              // Object could be null                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CodePointerExpression(a[0]' compEnv.SubstituteMember(methodi.Method))' e.Lub(ReadHeapOrThrowE)));                          else                          {                              stack.Push                                  (new ExpressionStackEntry(new CodePointerExpression(null' compEnv.SubstituteMember(methodi.Method))' BottomE));                              return true;                          }                      case MethodOp.Call:                          if (methodi.Method.Result == null)                              return stack.PopEvalSE                                  (statements'                                   arity'                                   true'                                   CalleeEffects(methodi.BeforeState' arity)'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new CallExpression                                                 (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal'                                                  compEnv.SubstituteMember(methodi.Method)'                                                  CallerArguments(methodi.Constrained' methodi.Method' a)))));                          else                              return stack.PopEvalPush                                  (statements'                                   arity'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CallExpression                                            (methodi.IsVirtual? CallFlavor.Virtual : CallFlavor.Normal'                                             compEnv.SubstituteMember(methodi.Method)'                                             CallerArguments(methodi.Constrained' methodi.Method' a))'                                        e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Newobj:                          arity--;                          return stack.PopEvalPush                              (statements'                               arity'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new NewObjectExpression(compEnv.SubstituteMember(methodi.Method)' CallerArguments(null' methodi.Method' a))'                                    e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Ldtoken:                          stack.Push                              (new ExpressionStackEntry(new MethodHandleConstantExpression(compEnv.SubstituteMember(methodi.Method))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case TypeOp.Stobj:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case TypeOp.Cpobj:                          {                              var copyEffect = instruction.BeforeState.PeekPointsTo(0).ReadEffect().Lub                                  (instruction.BeforeState.PeekPointsTo(1).WriteEffect());                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   copyEffect'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new WriteExpression(a[0]' new ReadExpression(a[1]).CloneIfStruct(compEnv)))));                          }                      case TypeOp.Newarr:                          // Growing the heap is not considered an observable change. But will throw if                          // length < 0                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new NewArrayExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Initobj:                          return stack.PopEvalSE                              (statements' 1' true' WriteHeapE' (s' a) => s.Add(new InitializeObjectStatement(a[0])));                      case TypeOp.Castclass:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new CastExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Isinst:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new IsInstExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Box:                          // Growing the heap is not considered an observable change                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new NewBoxExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Unbox:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).AddressOf()' e.Lub(ThrowsE)));                      case TypeOp.UnboxAny:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).Read().CloneIfStruct(compEnv)' e.Lub(ThrowsE)));                      case TypeOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new TypeHandleConstantExpression(compEnv.SubstituteType(typei.Type))' BottomE));                          return true;                      case TypeOp.Ldelem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case TypeOp.Stelem:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add(new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  // Calculating the pointer may throw if index is out of range.                  // Remaining effect will be accounted for when pointer is read/written.                  return stack.PopEvalPush                      (statements'                       2'                       true'                       (a' e) =>                       new ExpressionStackEntry(new ElementCell(a[0]' a[1]' false).AddressOf()' e.Lub(ThrowsE)));              case InstructionFlavor.LdInt32:                  {                      var int32i = (LdInt32Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int32ConstantExpression(int32i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdInt64:                  {                      var int64i = (LdInt64Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int64ConstantExpression(int64i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdSingle:                  {                      var singlei = (LdSingleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new SingleConstantExpression(singlei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdDouble:                  {                      var doublei = (LdDoubleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new DoubleConstantExpression(doublei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdString:                  {                      var stringi = (LdStringInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new StringConstantExpression(stringi.Value)' BottomE));                      return true;                  }              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Div:                      case ArithOp.Rem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(ThrowsE)));                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                      case ArithOp.Shl:                      case ArithOp.Shr:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(arithi.WithOverflow ? ThrowsE : BottomE)));                      case ArithOp.Neg:                      case ArithOp.BitNot:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression                                        (a[0]' ArithOpToUnaryOp(arithi.Op)' arithi.WithOverflow' arithi.IsUnsigned)'                                    e));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      return stack.PopEvalPush                          (statements'                           1'                           true'                           (a' e) =>                           new ExpressionStackEntry                               (new ConvertExpression                                    (a[0]'                                     new NamedTypeRef                                         (compEnv.Global.NumberFlavorToQualifiedTypeName[convi.TargetNumberFlavor])'                                     convi.WithOverflow'                                     convi.IsSourceUnsigned)'                                e.Lub(convi.WithOverflow ? ThrowsE : BottomE)));                  }              case InstructionFlavor.Try:                  {                      if (stack.Depth > 0)                          throw new InvalidOperationException("stack must be empty on entry to try block");                      var tryi = (TryInstruction)instruction;                      var tryStatements = BlockToTryFaultFinallyStatements(tryi.Body);                      if (tryStatements == null)                          return false;                      var handlers = TranslateHandlers(tryi.Handlers);                      if (handlers == null)                          return false;                      if (statements == null)                          return Failed(false' "try");                      statements.Add(new TryStatement(tryStatements' handlers));                      return true;                  }              case InstructionFlavor.IfThenElsePseudo:                  {                      var itei = (IfThenElseInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(itei.Offset' out isExpr) ||                                              isExpr;                        if (!TranslateBlock(statements' itei.Condition' stack' exid))                          return false;                      if (couldBeExpression && itei.Else != null)                      {                          // Pass 1: Try to tranlate to an if-then-else expression. Will only work if Then and Else don't                          //         reach into current stack' push exactly one value' and don't need to emit any                          //         statements along the way.                          var thenEntry = BlockToExpression(itei.Then' exid);                          if (thenEntry != null)                          {                              var elseEntry = BlockToExpression(itei.Else' exid);                              if (elseEntry != null)                              {                                  if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                                      instructionTranslationStyleCache.Add(itei.Offset' true);                                  return stack.PopEvalPush                                      (statements'                                       1'                                       true'                                       (a' e) =>                                       new ExpressionStackEntry                                           (new IfThenElseExpression(a[0]' thenEntry.Expression' elseEntry.Expression)'                                            e.Lub(thenEntry.Effects.Lub(elseEntry.Effects))));                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      var noStackChange = itei.Then.NoStackChange && (itei.Else == null || itei.Else.NoStackChange);                      var condEntry = noStackChange                                          ? stack.Pop()                                          : stack.FlushAndPopPostState(statements' itei.Then.BeforeState);                      if (condEntry == null)                          return false;                      var thenStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Then' exid)                                           : BlockToStatements(itei.Then' exid);                      if (thenStmnts == null)                          return false;                      var elseStmnts = default(Seq<Statement>);                      if (itei.Else != null)                      {                          elseStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Else' exid)                                           : BlockToStatements(itei.Else' exid);                          if (elseStmnts == null)                              return false;                      }                      if (statements == null)                          return Failed(false' "if-then-else");                      statements.Add                          (new IfThenElseStatement(condEntry.Expression' new Statements(thenStmnts)' elseStmnts == null ? null : new Statements(elseStmnts)));                      if (!noStackChange && !stack.Restore(itei.AfterState' 0))                          return false;                      if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                          instructionTranslationStyleCache.Add(itei.Offset' false);                      return true;                  }              case InstructionFlavor.ShortCircuitingPseudo:                  {                      var sci = (ShortCircuitingInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(sci.Offset' out isExpr) ||                                              isExpr;                      if (couldBeExpression)                      {                          // Pass 1: Try to translate to an expression.                          var leftEntry = BlockToExpression(sci.Left' exid);                          if (leftEntry != null)                          {                              var rightEntry = BlockToExpression(sci.Right' exid);                              if (rightEntry != null)                              {                                  stack.Push                                      (new ExpressionStackEntry                                           (new BinaryExpression                                                (leftEntry.Expression'                                                 ShortCircuitingOpToBinaryOp(sci.Op)'                                                 rightEntry.Expression'                                                 false'                                                 false)'                                            leftEntry.Effects.Lub(rightEntry.Effects)));                                  if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                                      instructionTranslationStyleCache.Add(sci.Offset' true);                                  return true;                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      if (!TranslateBlock(statements' sci.Left' stack' exid))                          return false;                      var leftEntry2 = stack.FlushAndPopPostState(statements' sci.Right.BeforeState);                      if (leftEntry2 == null)                          return false;                      var rightStatements = BlockToStatements(sci.Right' exid);                      if (rightStatements == null)                          return false;                      var id = sci.Right.AfterState.PeekId(0' nameSupply.GenSym);                      var cell = new VariableCell(id);                      compEnv.AddVariable(id' ArgLocal.Local' false' true' compEnv.SubstituteType(sci.Right.AfterState.PeekType(0)));                      if (statements == null)                          return Failed(false' "short-circuit");                      switch (sci.Op)                      {                      case ShortCircuitingOp.And:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements(rightStatements)'                                    new Statements                                        (new ExpressionStatement(cell.Write(new Int32ConstantExpression(0))))));                          break;                      case ShortCircuitingOp.Or:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements                                        (new ExpressionStatement                                             (cell.Write(new Int32ConstantExpression(1))))'                                    new Statements(rightStatements)));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      if (!stack.Restore(sci.AfterState' 1))                          return false;                      stack.Push(new ExpressionStackEntry(cell.Read()' BottomE));                      if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                          instructionTranslationStyleCache.Add(sci.Offset' false);                      return true;                  }              case InstructionFlavor.StructuralSwitchPseudo:                  {                      var ssi = (StructuralSwitchInstruction)instruction;                      if (!TranslateBlock(statements' ssi.Body' stack' exid))                          return false;                      var valueEntry = stack.FlushAndPopPreState(statements' ssi.Body.AfterState);                      if (valueEntry == null)                          return false;                      var cases = new Seq<SwitchStatementCase>();                      foreach (var c in ssi.Cases)                      {                          var caseStatements = BlockToStatements(c.Body' exid);                          if (caseStatements == null)                              return false;                          cases.Add(new SwitchStatementCase(c.Values' new Statements(caseStatements)));                      }                      if (statements == null)                          return Failed(false' "structural switch");                      statements.Add(new SwitchStatement(valueEntry.Expression' cases));                      if (!stack.Restore(ssi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopPseudo:                  {                      var li = (LoopInstruction)instruction;                      if (!stack.Flush(statements' li.Body.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop");                      var whileStatements = BlockToStatements(li.Body' exid);                      statements.Add                          (new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(whileStatements)));                      if (!stack.Restore(li.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.WhileDoPseudo:                  {                      var wdi = (WhileDoInstruction)instruction;                      if (!stack.Flush(statements' wdi.Condition.BeforeState))                          return false;                      var condEntry = BlockToExpression(wdi.Condition' exid);                      if (condEntry == null)                      {                          var stack1 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Condition.BeforeState' trace);                          var preCondStatements = new Seq<Statement>();                          if (!TranslateBlock(preCondStatements' wdi.Condition' stack1' exid))                              return false;                          condEntry = stack1.FlushAndPopPostState(preCondStatements' wdi.Body.BeforeState);                          if (condEntry == null)                              return false;                          var stack2 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Body.BeforeState' trace);                          var postCondStatements = new Seq<Statement>();                          if (!TranslateBlock(postCondStatements' wdi.Body' stack2' exid))                              return false;                          if (!stack2.Flush(postCondStatements' wdi.Body.AfterState))                              return false;                          preCondStatements.Add                              (new IfThenElseStatement                                   (condEntry.Expression'                                    new Statements(postCondStatements)'                                    new Statements(new BreakStatement())));                          statements.Add(new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(preCondStatements)));                      }                      else                      {                          var loopStatements = BlockToStatements(wdi.Body' exid);                          if (loopStatements == null)                              return false;                          if (statements == null)                              return Failed(false' "while-do");                          statements.Add(new WhileDoStatement(condEntry.Expression' new Statements(loopStatements)));                      }                      if (!stack.Restore(wdi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.DoWhilePseudo:                  {                      var dwi = (DoWhileInstruction)instruction;                      if (!stack.Flush(statements' dwi.Body.BeforeState))                          return false;                      var combined = new Seq<Instruction>();                      foreach (var i in dwi.Body.Body)                          combined.Add(i);                      foreach (var i in dwi.Condition.Body)                          combined.Add(i);                      var condEntry = default(ExpressionStackEntry);                      var loopStatements = BlockToConditionStatements                          (new Instructions(null' combined)' dwi.Body.BeforeState' exid' out condEntry);                      if (loopStatements == null)                          return false;                      if (statements == null)                          return Failed(false' "do-while");                      statements.Add(new DoWhileStatement(new Statements(loopStatements)' condEntry.Expression));                      if (!stack.Restore(dwi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopControlPseudo:                  {                      var lci = (BreakContinueInstruction)instruction;                      if (!stack.Flush(statements' lci.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop-control");                      var targetState = default(int);                      switch (lci.Op)                      {                      case BreakContinueOp.Break:                          if (labelToLoopCandidateBreakState != null &&                              labelToLoopCandidateBreakState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new BreakStatement(lci.Label));                          break;                      case BreakContinueOp.Continue:                          if (labelToLoopCandidateContinueState != null &&                              labelToLoopCandidateContinueState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new ContinueStatement(lci.Label));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      return true;                  }              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return true;                      case MiscOp.Dup:                          return stack.Dup(statements);                      case MiscOp.Pop:                          return stack.PopAndDiscard(statements);                      case MiscOp.Ldnull:                          stack.Push(new ExpressionStackEntry(new NullConstantExpression()' BottomE));                          return true;                      case MiscOp.Ckfinite:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.CheckFinite' false' false)' e.Lub(ThrowsE)));                      case MiscOp.Throw:                          if (!stack.DiscardAll(statements' 1))                              return false;                          if (!stack.PopEvalSE(statements' 1' true' ThrowsE' (s' a) => s.Add(new ThrowStatement(a[0]))))                              return false;                          return true;                      case MiscOp.Rethrow:                          if (!stack.DiscardAll(statements' 0))                              return false;                          if (statements == null)                              return Failed(false' "rethrow");                          if (exid == null)                              throw new InvalidOperationException("rethrow outside of catch");                          statements.Add(new RethrowStatement(new VariableCell(exid).Read()));                          return true;                      case MiscOp.LdindRef:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case MiscOp.LdelemRef:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.Ldlen:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.Length' false' false)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.StindRef:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case MiscOp.StelemRef:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add                                   (new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      case MiscOp.Ret:                          if (statements == null)                              return Failed(false' "return");                          statements.Add(new ReturnStatement(null));                          return true;                      case MiscOp.RetVal:                          return stack.PopEvalSE                              (statements' 1' true' BottomE' (s' a) => s.Add(new ReturnStatement(a[0])));                      case MiscOp.Endfilter:                      case MiscOp.Endfinally:                          throw new InvalidOperationException                              ("endfilter/endfinally instructions should have been removed");                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:              case InstructionFlavor.Switch:                  throw new InvalidOperationException("branch/switch instructions should have been removed");              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      if (cmpi.Op == CompareOp.CtruePseudo || cmpi.Op == CompareOp.CfalsePseudo)                      {                          var s = cmpi.Type.Style(compEnv);                          var unop = default(UnaryOp);                          if (s is NumberTypeStyle)                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonZero : UnaryOp.IsZero;                          else                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonNull : UnaryOp.IsNull;                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new UnaryExpression(a[0]' unop' false' cmpi.IsUnsigned)' e));                      }                      else                      {                          var binop = default(BinaryOp);                          switch (cmpi.Op)                          {                          case CompareOp.Ceq:                              binop = BinaryOp.Eq;                              break;                          case CompareOp.Clt:                              binop = BinaryOp.Lt;                              break;                          case CompareOp.Cgt:                              binop = BinaryOp.Gt;                              break;                          case CompareOp.CgePseudo:                              binop = BinaryOp.Ge;                              break;                          case CompareOp.ClePseudo:                              binop = BinaryOp.Le;                              break;                          case CompareOp.CnePseudo:                              binop = BinaryOp.Ne;                              break;                          case CompareOp.CtruePseudo:                          case CompareOp.CfalsePseudo:                              // handled above                              throw new InvalidOperationException();                          default:                              throw new ArgumentOutOfRangeException();                          }                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression(a[0]' binop' a[1]' false' cmpi.IsUnsigned)' e));                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var sli = (ArgLocalInstruction)instruction;                      var id = default(JST.Identifier);                      switch (sli.ArgLocal)                      {                      case ArgLocal.Arg:                          id = compEnv.ValueParameterIds[sli.Index];                          break;                      case ArgLocal.Local:                          id = compEnv.LocalIds[sli.Index];                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      var cell = new VariableCell(id);                      switch (sli.Op)                      {                      case ArgLocalOp.Ld:                          stack.Push                              (new ExpressionStackEntry                                   (cell.Read().CloneIfStruct(compEnv)' ReadArgLocalE(sli.ArgLocal' sli.Index)));                          return true;                      case ArgLocalOp.Lda:                          // Effect will be accounted for on reads/writes                          stack.Push(new ExpressionStackEntry(cell.AddressOf()' BottomE));                          return true;                      case ArgLocalOp.St:                          return stack.PopEvalSE                              (statements'                               1'                               true'                               WriteArgLocalE(sli.ArgLocal' sli.Index)'                               (s' a) => s.Add(new ExpressionStatement(cell.Write(a[0]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                          {                              stack.Push                                  (new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' ReadHeapE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                       {                                           var readEffect = default(Effects);                                           var obj = default(Expression);                                           if (fieldi.IsViaPointer.Value)                                           {                                               readEffect = e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect());                                               obj = new ReadExpression(a[0]); // no need for clone                                           }                                           else if (fieldi.Field.DefiningType.Style(compEnv) is ValueTypeStyle)                                           {                                               readEffect = e;                                               obj = a[0];                                           }                                           else                                           {                                               // Object could be null                                               readEffect = e.Lub(ReadHeapOrThrowE);                                               obj = a[0];                                           }                                           return new ExpressionStackEntry(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' readEffect);                                       });                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                          {                              // Effect will be accounted for on reads/writes                              stack.Push(new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' BottomE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   {                                       if (fieldi.IsViaPointer.Value)                                           // We're just adding an offset to a pointer' so effect will                                           // be accounted for when the final pointer is read/written                                           return new ExpressionStackEntry(new FieldCell(new ReadExpression(a[0])' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e);                                       else                                           // Must be a reference type' and ref could be null                                           return new ExpressionStackEntry(new FieldCell(a[0]' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e.Lub(ThrowsE));                                   });                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                              return stack.PopEvalSE                                  (statements'                                   1'                                   true'                                   WriteHeapE'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Write(a[0]))));                          else                          {                              var writeEffect = fieldi.IsViaPointer.Value                                                    ? instruction.BeforeState.PeekPointsTo(1).WriteEffect()                                                    : WriteHeapOrThrowE;                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   writeEffect'                                   (s' a) =>                                       {                                           var obj = fieldi.IsViaPointer.Value ? new ReadExpression(a[0]) : a[0];                                           s.Add(new ExpressionStatement(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Write(a[1])));                                       });                          }                      case FieldOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new FieldHandleConstantExpression(compEnv.SubstituteMember(fieldi.Field))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methodi = (MethodInstruction)instruction;                      var arity = methodi.Method.ValueParameters.Count;                      switch (methodi.Op)                      {                      case MethodOp.Ldftn:                          if (methodi.IsVirtual)                              // Object could be null                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CodePointerExpression(a[0]' compEnv.SubstituteMember(methodi.Method))' e.Lub(ReadHeapOrThrowE)));                          else                          {                              stack.Push                                  (new ExpressionStackEntry(new CodePointerExpression(null' compEnv.SubstituteMember(methodi.Method))' BottomE));                              return true;                          }                      case MethodOp.Call:                          if (methodi.Method.Result == null)                              return stack.PopEvalSE                                  (statements'                                   arity'                                   true'                                   CalleeEffects(methodi.BeforeState' arity)'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new CallExpression                                                 (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal'                                                  compEnv.SubstituteMember(methodi.Method)'                                                  CallerArguments(methodi.Constrained' methodi.Method' a)))));                          else                              return stack.PopEvalPush                                  (statements'                                   arity'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CallExpression                                            (methodi.IsVirtual? CallFlavor.Virtual : CallFlavor.Normal'                                             compEnv.SubstituteMember(methodi.Method)'                                             CallerArguments(methodi.Constrained' methodi.Method' a))'                                        e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Newobj:                          arity--;                          return stack.PopEvalPush                              (statements'                               arity'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new NewObjectExpression(compEnv.SubstituteMember(methodi.Method)' CallerArguments(null' methodi.Method' a))'                                    e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Ldtoken:                          stack.Push                              (new ExpressionStackEntry(new MethodHandleConstantExpression(compEnv.SubstituteMember(methodi.Method))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case TypeOp.Stobj:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case TypeOp.Cpobj:                          {                              var copyEffect = instruction.BeforeState.PeekPointsTo(0).ReadEffect().Lub                                  (instruction.BeforeState.PeekPointsTo(1).WriteEffect());                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   copyEffect'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new WriteExpression(a[0]' new ReadExpression(a[1]).CloneIfStruct(compEnv)))));                          }                      case TypeOp.Newarr:                          // Growing the heap is not considered an observable change. But will throw if                          // length < 0                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new NewArrayExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Initobj:                          return stack.PopEvalSE                              (statements' 1' true' WriteHeapE' (s' a) => s.Add(new InitializeObjectStatement(a[0])));                      case TypeOp.Castclass:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new CastExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Isinst:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new IsInstExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Box:                          // Growing the heap is not considered an observable change                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new NewBoxExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Unbox:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).AddressOf()' e.Lub(ThrowsE)));                      case TypeOp.UnboxAny:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).Read().CloneIfStruct(compEnv)' e.Lub(ThrowsE)));                      case TypeOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new TypeHandleConstantExpression(compEnv.SubstituteType(typei.Type))' BottomE));                          return true;                      case TypeOp.Ldelem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case TypeOp.Stelem:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add(new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  // Calculating the pointer may throw if index is out of range.                  // Remaining effect will be accounted for when pointer is read/written.                  return stack.PopEvalPush                      (statements'                       2'                       true'                       (a' e) =>                       new ExpressionStackEntry(new ElementCell(a[0]' a[1]' false).AddressOf()' e.Lub(ThrowsE)));              case InstructionFlavor.LdInt32:                  {                      var int32i = (LdInt32Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int32ConstantExpression(int32i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdInt64:                  {                      var int64i = (LdInt64Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int64ConstantExpression(int64i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdSingle:                  {                      var singlei = (LdSingleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new SingleConstantExpression(singlei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdDouble:                  {                      var doublei = (LdDoubleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new DoubleConstantExpression(doublei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdString:                  {                      var stringi = (LdStringInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new StringConstantExpression(stringi.Value)' BottomE));                      return true;                  }              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Div:                      case ArithOp.Rem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(ThrowsE)));                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                      case ArithOp.Shl:                      case ArithOp.Shr:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(arithi.WithOverflow ? ThrowsE : BottomE)));                      case ArithOp.Neg:                      case ArithOp.BitNot:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression                                        (a[0]' ArithOpToUnaryOp(arithi.Op)' arithi.WithOverflow' arithi.IsUnsigned)'                                    e));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      return stack.PopEvalPush                          (statements'                           1'                           true'                           (a' e) =>                           new ExpressionStackEntry                               (new ConvertExpression                                    (a[0]'                                     new NamedTypeRef                                         (compEnv.Global.NumberFlavorToQualifiedTypeName[convi.TargetNumberFlavor])'                                     convi.WithOverflow'                                     convi.IsSourceUnsigned)'                                e.Lub(convi.WithOverflow ? ThrowsE : BottomE)));                  }              case InstructionFlavor.Try:                  {                      if (stack.Depth > 0)                          throw new InvalidOperationException("stack must be empty on entry to try block");                      var tryi = (TryInstruction)instruction;                      var tryStatements = BlockToTryFaultFinallyStatements(tryi.Body);                      if (tryStatements == null)                          return false;                      var handlers = TranslateHandlers(tryi.Handlers);                      if (handlers == null)                          return false;                      if (statements == null)                          return Failed(false' "try");                      statements.Add(new TryStatement(tryStatements' handlers));                      return true;                  }              case InstructionFlavor.IfThenElsePseudo:                  {                      var itei = (IfThenElseInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(itei.Offset' out isExpr) ||                                              isExpr;                        if (!TranslateBlock(statements' itei.Condition' stack' exid))                          return false;                      if (couldBeExpression && itei.Else != null)                      {                          // Pass 1: Try to tranlate to an if-then-else expression. Will only work if Then and Else don't                          //         reach into current stack' push exactly one value' and don't need to emit any                          //         statements along the way.                          var thenEntry = BlockToExpression(itei.Then' exid);                          if (thenEntry != null)                          {                              var elseEntry = BlockToExpression(itei.Else' exid);                              if (elseEntry != null)                              {                                  if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                                      instructionTranslationStyleCache.Add(itei.Offset' true);                                  return stack.PopEvalPush                                      (statements'                                       1'                                       true'                                       (a' e) =>                                       new ExpressionStackEntry                                           (new IfThenElseExpression(a[0]' thenEntry.Expression' elseEntry.Expression)'                                            e.Lub(thenEntry.Effects.Lub(elseEntry.Effects))));                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      var noStackChange = itei.Then.NoStackChange && (itei.Else == null || itei.Else.NoStackChange);                      var condEntry = noStackChange                                          ? stack.Pop()                                          : stack.FlushAndPopPostState(statements' itei.Then.BeforeState);                      if (condEntry == null)                          return false;                      var thenStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Then' exid)                                           : BlockToStatements(itei.Then' exid);                      if (thenStmnts == null)                          return false;                      var elseStmnts = default(Seq<Statement>);                      if (itei.Else != null)                      {                          elseStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Else' exid)                                           : BlockToStatements(itei.Else' exid);                          if (elseStmnts == null)                              return false;                      }                      if (statements == null)                          return Failed(false' "if-then-else");                      statements.Add                          (new IfThenElseStatement(condEntry.Expression' new Statements(thenStmnts)' elseStmnts == null ? null : new Statements(elseStmnts)));                      if (!noStackChange && !stack.Restore(itei.AfterState' 0))                          return false;                      if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                          instructionTranslationStyleCache.Add(itei.Offset' false);                      return true;                  }              case InstructionFlavor.ShortCircuitingPseudo:                  {                      var sci = (ShortCircuitingInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(sci.Offset' out isExpr) ||                                              isExpr;                      if (couldBeExpression)                      {                          // Pass 1: Try to translate to an expression.                          var leftEntry = BlockToExpression(sci.Left' exid);                          if (leftEntry != null)                          {                              var rightEntry = BlockToExpression(sci.Right' exid);                              if (rightEntry != null)                              {                                  stack.Push                                      (new ExpressionStackEntry                                           (new BinaryExpression                                                (leftEntry.Expression'                                                 ShortCircuitingOpToBinaryOp(sci.Op)'                                                 rightEntry.Expression'                                                 false'                                                 false)'                                            leftEntry.Effects.Lub(rightEntry.Effects)));                                  if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                                      instructionTranslationStyleCache.Add(sci.Offset' true);                                  return true;                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      if (!TranslateBlock(statements' sci.Left' stack' exid))                          return false;                      var leftEntry2 = stack.FlushAndPopPostState(statements' sci.Right.BeforeState);                      if (leftEntry2 == null)                          return false;                      var rightStatements = BlockToStatements(sci.Right' exid);                      if (rightStatements == null)                          return false;                      var id = sci.Right.AfterState.PeekId(0' nameSupply.GenSym);                      var cell = new VariableCell(id);                      compEnv.AddVariable(id' ArgLocal.Local' false' true' compEnv.SubstituteType(sci.Right.AfterState.PeekType(0)));                      if (statements == null)                          return Failed(false' "short-circuit");                      switch (sci.Op)                      {                      case ShortCircuitingOp.And:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements(rightStatements)'                                    new Statements                                        (new ExpressionStatement(cell.Write(new Int32ConstantExpression(0))))));                          break;                      case ShortCircuitingOp.Or:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements                                        (new ExpressionStatement                                             (cell.Write(new Int32ConstantExpression(1))))'                                    new Statements(rightStatements)));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      if (!stack.Restore(sci.AfterState' 1))                          return false;                      stack.Push(new ExpressionStackEntry(cell.Read()' BottomE));                      if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                          instructionTranslationStyleCache.Add(sci.Offset' false);                      return true;                  }              case InstructionFlavor.StructuralSwitchPseudo:                  {                      var ssi = (StructuralSwitchInstruction)instruction;                      if (!TranslateBlock(statements' ssi.Body' stack' exid))                          return false;                      var valueEntry = stack.FlushAndPopPreState(statements' ssi.Body.AfterState);                      if (valueEntry == null)                          return false;                      var cases = new Seq<SwitchStatementCase>();                      foreach (var c in ssi.Cases)                      {                          var caseStatements = BlockToStatements(c.Body' exid);                          if (caseStatements == null)                              return false;                          cases.Add(new SwitchStatementCase(c.Values' new Statements(caseStatements)));                      }                      if (statements == null)                          return Failed(false' "structural switch");                      statements.Add(new SwitchStatement(valueEntry.Expression' cases));                      if (!stack.Restore(ssi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopPseudo:                  {                      var li = (LoopInstruction)instruction;                      if (!stack.Flush(statements' li.Body.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop");                      var whileStatements = BlockToStatements(li.Body' exid);                      statements.Add                          (new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(whileStatements)));                      if (!stack.Restore(li.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.WhileDoPseudo:                  {                      var wdi = (WhileDoInstruction)instruction;                      if (!stack.Flush(statements' wdi.Condition.BeforeState))                          return false;                      var condEntry = BlockToExpression(wdi.Condition' exid);                      if (condEntry == null)                      {                          var stack1 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Condition.BeforeState' trace);                          var preCondStatements = new Seq<Statement>();                          if (!TranslateBlock(preCondStatements' wdi.Condition' stack1' exid))                              return false;                          condEntry = stack1.FlushAndPopPostState(preCondStatements' wdi.Body.BeforeState);                          if (condEntry == null)                              return false;                          var stack2 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Body.BeforeState' trace);                          var postCondStatements = new Seq<Statement>();                          if (!TranslateBlock(postCondStatements' wdi.Body' stack2' exid))                              return false;                          if (!stack2.Flush(postCondStatements' wdi.Body.AfterState))                              return false;                          preCondStatements.Add                              (new IfThenElseStatement                                   (condEntry.Expression'                                    new Statements(postCondStatements)'                                    new Statements(new BreakStatement())));                          statements.Add(new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(preCondStatements)));                      }                      else                      {                          var loopStatements = BlockToStatements(wdi.Body' exid);                          if (loopStatements == null)                              return false;                          if (statements == null)                              return Failed(false' "while-do");                          statements.Add(new WhileDoStatement(condEntry.Expression' new Statements(loopStatements)));                      }                      if (!stack.Restore(wdi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.DoWhilePseudo:                  {                      var dwi = (DoWhileInstruction)instruction;                      if (!stack.Flush(statements' dwi.Body.BeforeState))                          return false;                      var combined = new Seq<Instruction>();                      foreach (var i in dwi.Body.Body)                          combined.Add(i);                      foreach (var i in dwi.Condition.Body)                          combined.Add(i);                      var condEntry = default(ExpressionStackEntry);                      var loopStatements = BlockToConditionStatements                          (new Instructions(null' combined)' dwi.Body.BeforeState' exid' out condEntry);                      if (loopStatements == null)                          return false;                      if (statements == null)                          return Failed(false' "do-while");                      statements.Add(new DoWhileStatement(new Statements(loopStatements)' condEntry.Expression));                      if (!stack.Restore(dwi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopControlPseudo:                  {                      var lci = (BreakContinueInstruction)instruction;                      if (!stack.Flush(statements' lci.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop-control");                      var targetState = default(int);                      switch (lci.Op)                      {                      case BreakContinueOp.Break:                          if (labelToLoopCandidateBreakState != null &&                              labelToLoopCandidateBreakState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new BreakStatement(lci.Label));                          break;                      case BreakContinueOp.Continue:                          if (labelToLoopCandidateContinueState != null &&                              labelToLoopCandidateContinueState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new ContinueStatement(lci.Label));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      return true;                  }              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,Translate,The following statement contains a magic number: preorder.Count == 2
Magic Number,Microsoft.LiveLabs.CST,MultiDimArrayBounds,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,ConsumeNum,The following statement contains a magic number: n = n*10 + (str[i] - '0');
Magic Number,Microsoft.LiveLabs.CST,MultiDimArrayTypeDef,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,MultiDimArrayTypeDef,The following statement contains a magic number: i < bounds.Rank*2
Magic Number,Microsoft.LiveLabs.CST,CSTWriter,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Writer.cs,AppendMnemonicFileName,The following statement contains a magic number: var lim = 40;
Magic Number,Microsoft.LiveLabs.CST,CSTWriter,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Writer.cs,AppendMnemonicFileName,The following statement contains a magic number: nm = "__" + nm.Substring(nm.Length + 2 - lim' lim - 2);
Magic Number,Microsoft.LiveLabs.CST,CSTWriter,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Writer.cs,AppendMnemonicFileName,The following statement contains a magic number: nm = "__" + nm.Substring(nm.Length + 2 - lim' lim - 2);
Missing Default,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceLooping,The following switch statement is missing a default case: switch (bb.Flavor)                          {                              case BasicBlockFlavor.Try:                              {                                  var trybb = (TryBasicBlock)bb;                                  if (!loop.Body.Contains(trybb.Body))                                      isCandidateLoop = false;                                  break;                              }                              case BasicBlockFlavor.LoopCandidate:                              {                                  var loopbb = (LoopCandidateBasicBlock)bb;                                  if (!loop.Body.Contains(loopbb.Head) || !loop.Body.Contains(loopbb.Break))                                      isCandidateLoop = false;                                  break;                              }                          }
Missing Default,Microsoft.LiveLabs.CST,TypeName,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\Name.cs,Append,The following switch statement is missing a default case: switch (w.Style)              {              case WriterStyle.ReflectionName:                  {                      w.AppendName(Types[Types.Count - 1]);                      break;                  }              case WriterStyle.ReflectionFullName:              case WriterStyle.Uniform:              case WriterStyle.Debug:                  {                      if (!string.IsNullOrEmpty(Namespace))                      {                          w.AppendName(Namespace);                          w.Append('.');                      }                      for (var i = 0; i < Types.Count; i++)                      {                          if (i > 0)                              w.Append('+');                          w.AppendName(Types[i]);                      }                      break;                  }              }
Missing Default,Microsoft.LiveLabs.CST,PELoader,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,FieldDefFromRow,The following switch statement is missing a default case: switch (row.Flags & PE.FieldAttributes.FieldAccessMask)              {              case PE.FieldAttributes.CompilerControlled:                  accessibility = Accessibility.CompilerControlled;                  break;              case PE.FieldAttributes.Private:                  accessibility = Accessibility.Private;                  break;              case PE.FieldAttributes.FamANDAssem:                  accessibility = Accessibility.FamilyANDAssembly;                  break;              case PE.FieldAttributes.Assembly:                  accessibility = Accessibility.Assembly;                  break;              case PE.FieldAttributes.Family:                  accessibility = Accessibility.Family;                  break;              case PE.FieldAttributes.FamORAssem:                  accessibility = Accessibility.FamilyORAssembly;                  break;              case PE.FieldAttributes.Public:                  accessibility = Accessibility.Public;                  break;              }
Missing Default,Microsoft.LiveLabs.CST,PELoader,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,ParameterTypeDefFromRow,The following switch statement is missing a default case: switch (row.Flags & PE.GenericParamAttributes.VarianceMask)              {              case PE.GenericParamAttributes.None:                  variance = ParameterVariance.Invariant;                  break;              case PE.GenericParamAttributes.Covariant:                  variance = ParameterVariance.Covariant;                  break;              case PE.GenericParamAttributes.Contravariant:                  variance = ParameterVariance.Contravariant;                  break;              }
Missing Default,Microsoft.LiveLabs.CST,PELoader,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,MethodDefFromRow,The following switch statement is missing a default case: switch (row.Flags & PE.MethodAttributes.MemberAccessMask)              {              case PE.MethodAttributes.CompilerControlled:                  accessibility = Accessibility.CompilerControlled;                  break;              case PE.MethodAttributes.Private:                  accessibility = Accessibility.Private;                  break;              case PE.MethodAttributes.FamANDAssem:                  accessibility = Accessibility.FamilyANDAssembly;                  break;              case PE.MethodAttributes.Assem:                  accessibility = Accessibility.Assembly;                  break;              case PE.MethodAttributes.Family:                  accessibility = Accessibility.Family;                  break;              case PE.MethodAttributes.FamORAssem:                  accessibility = Accessibility.FamilyORAssembly;                  break;              case PE.MethodAttributes.Public:                  accessibility = Accessibility.Public;                  break;              }
Missing Default,Microsoft.LiveLabs.CST,PELoader,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,MethodDefFromRow,The following switch statement is missing a default case: switch (row.ImplFlags & PE.MethodImplAttributes.CodeTypeMask)              {              case PE.MethodImplAttributes.IL:              case PE.MethodImplAttributes.OPTIL:                  codeFlavor = MethodCodeFlavor.Managed;                  break;              case PE.MethodImplAttributes.Native:                  codeFlavor = MethodCodeFlavor.Native;                  break;              case PE.MethodImplAttributes.Runtime:                  codeFlavor = MethodCodeFlavor.Runtime;                  break;              }
Missing Default,Microsoft.LiveLabs.CST,PELoader,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The following switch statement is missing a default case: switch (row.Flags & PE.TypeAttributes.VisibilityMask)              {              case PE.TypeAttributes.NotPublic:                  accessibility = Accessibility.Private;                  break;              case PE.TypeAttributes.Public:                  accessibility = Accessibility.Public;                  break;              case PE.TypeAttributes.NestedPublic:                  accessibility = Accessibility.Public;                  break;              case PE.TypeAttributes.NestedPrivate:                  accessibility = Accessibility.Private;                  break;              case PE.TypeAttributes.NestedFamily:                  accessibility = Accessibility.Family;                  break;              case PE.TypeAttributes.NestedAssembly:                  accessibility = Accessibility.Assembly;                  break;              case PE.TypeAttributes.NestedFamANDAssem:                  accessibility = Accessibility.FamilyANDAssembly;                  break;              case PE.TypeAttributes.NestedFamORAssem:                  accessibility = Accessibility.FamilyORAssembly;                  break;              }
Missing Default,Microsoft.LiveLabs.CST,PELoader,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The following switch statement is missing a default case: switch (row.Flags & PE.TypeAttributes.LayoutMask)              {              case PE.TypeAttributes.AutoLayout:                  layout = TypeLayout.Auto;                  break;              case PE.TypeAttributes.SequentialLayout:                  layout = TypeLayout.Sequential;                  break;              case PE.TypeAttributes.ExplicitLayout:                  layout = TypeLayout.Explicit;                  break;              }
Missing Default,Microsoft.LiveLabs.CST,PELoader,C:\research\architectureSmells\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The following switch statement is missing a default case: switch (row.Flags & PE.TypeAttributes.StringFormatMask)              {              case PE.TypeAttributes.AnsiClass:                  stringFormat = StringFormat.Ansi;                  break;              case PE.TypeAttributes.UnicodeClass:                  stringFormat = StringFormat.Unicode;                  break;              case PE.TypeAttributes.AutoClass:                  stringFormat = StringFormat.Auto;                  break;              case PE.TypeAttributes.CustomFormatClass:                  stringFormat = StringFormat.Custom;                  break;              }
