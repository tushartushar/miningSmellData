Implementation smell,Namespace,Class,File,Method,Description
Long Method,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,BasicBlockFromIndex,The method has 286 lines of code.
Long Method,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceBranch,The method has 376 lines of code.
Long Method,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceSwitch,The method has 125 lines of code.
Long Method,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceLooping,The method has 175 lines of code.
Long Method,Microsoft.LiveLabs.CST,Global,C:\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,Global,The method has 150 lines of code.
Long Method,Microsoft.LiveLabs.CST,CallExpression,C:\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,Simplify,The method has 112 lines of code.
Long Method,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The method has 750 lines of code.
Long Method,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The method has 576 lines of code.
Long Method,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,BackwardInstruction,The method has 160 lines of code.
Long Method,Microsoft.LiveLabs.CST,Peephole,C:\repos\Reactive-Extensions_IL2JS\CST\Peephole.cs,MoveNext,The method has 140 lines of code.
Long Method,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeRefFromTypeSig,The method has 105 lines of code.
Long Method,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,MethodDefFromRow,The method has 192 lines of code.
Long Method,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The method has 426 lines of code.
Long Method,Microsoft.LiveLabs.CST,ValidityContext,C:\repos\Reactive-Extensions_IL2JS\CST\Validity.cs,PropogateInvalidity,The method has 121 lines of code.
Long Method,Microsoft.LiveLabs.CST,ValidityContext,C:\repos\Reactive-Extensions_IL2JS\CST\Validity.cs,Check,The method has 290 lines of code.
Long Method,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The method has 866 lines of code.
Long Method,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,CaseBody,The method has 150 lines of code.
Long Method,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,Translate,The method has 110 lines of code.
Long Method,Microsoft.LiveLabs.CST,MultiDimArrayTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,MultiDimArrayTypeDef,The method has 126 lines of code.
Complex Method,Microsoft.LiveLabs.CST,BasicBlock,C:\repos\Reactive-Extensions_IL2JS\CST\BasicBlock.cs,CoalesceFrom,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.LiveLabs.CST,VariableCell,C:\repos\Reactive-Extensions_IL2JS\CST\Cell.cs,AccumEffects,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceBranch,Cyclomatic complexity of the method is 20
Complex Method,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceSwitch,Cyclomatic complexity of the method is 18
Complex Method,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceLooping,Cyclomatic complexity of the method is 25
Complex Method,Microsoft.LiveLabs.CST,PointsTo,C:\repos\Reactive-Extensions_IL2JS\CST\Domain.cs,Append,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.CST,Effects,C:\repos\Reactive-Extensions_IL2JS\CST\Domain.cs,Append,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardBlock,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.LiveLabs.CST,MemberDef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,MarkAsUsed,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.CST,MemberDef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,TopologicalTypeInit,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.CST,MethodDef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,AccumUsedTypeAndMemberDefs,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.LiveLabs.CST,MethodDef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,CheckValid,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.LiveLabs.CST,MethodDef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,AppendDefinition,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,AssemblyName,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,Equals,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,CompareTo,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,ArgsAndResultFromMethodSig,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,MethodDefFromRow,Cyclomatic complexity of the method is 22
Complex Method,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,Cyclomatic complexity of the method is 31
Complex Method,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,MergeAssemblyDefs,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,CustomAttributeFromRow,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.CST,MethodSignature,C:\repos\Reactive-Extensions_IL2JS\CST\Signature.cs,Append,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.LiveLabs.CST,ValidityContext,C:\repos\Reactive-Extensions_IL2JS\CST\Validity.cs,PropogateInvalidity,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.CST,ValidityContext,C:\repos\Reactive-Extensions_IL2JS\CST\Validity.cs,Stats,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.CST,ValidityContext,C:\repos\Reactive-Extensions_IL2JS\CST\Validity.cs,Check,Cyclomatic complexity of the method is 19
Complex Method,Microsoft.LiveLabs.CST,TypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PropogateInvalidity,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.LiveLabs.CST,TypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceIsAssignableTo,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.LiveLabs.CST,ParameterTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimIsValidParameterBinding,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.CST,NamedTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,AccumUsedTypeDefs,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.LiveLabs.CST,NamedTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,MarkAsUsed,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.LiveLabs.CST,RealTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,CompleteSlotImplementations,Cyclomatic complexity of the method is 8
Long Parameter List,Microsoft.LiveLabs.CST,AssemblyDef,C:\repos\Reactive-Extensions_IL2JS\CST\AssemblyDef.cs,AssemblyDef,The method has 7 parameters. Parameters: global' annotations' customAttributes' name' references' types' entryPoint
Long Parameter List,Microsoft.LiveLabs.CST,LeaveTryBasicBlock,C:\repos\Reactive-Extensions_IL2JS\CST\BasicBlock.cs,LeaveTryBasicBlock,The method has 5 parameters. Parameters: id' block' tryblock' handlerPopCount' stackPopCount
Long Parameter List,Microsoft.LiveLabs.CST,LeaveCatchBasicBlock,C:\repos\Reactive-Extensions_IL2JS\CST\BasicBlock.cs,LeaveCatchBasicBlock,The method has 5 parameters. Parameters: id' block' handler' handlerPopCount' stackPopCount
Long Parameter List,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,BreakReduceJump,The method has 6 parameters. Parameters: root' loop' breakTarget' jumpbb' removed' added
Long Parameter List,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,BreakReduceBranch,The method has 6 parameters. Parameters: root' loop' breakTarget' branchbb' removed' added
Long Parameter List,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,BreakReduceLeaveTry,The method has 6 parameters. Parameters: root' loop' breakTarget' leavebb' removed' added
Long Parameter List,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,BreakReduceLeaveCatch,The method has 6 parameters. Parameters: root' loop' breakTarget' leavebb' removed' added
Long Parameter List,Microsoft.LiveLabs.CST,Effects,C:\repos\Reactive-Extensions_IL2JS\CST\Domain.cs,Effects,The method has 7 parameters. Parameters: argsIsRead' argsIsWrite' localsIsRead' localsIsWrite' heapIsRead' heapIsWrite' exceptions
Long Parameter List,Microsoft.LiveLabs.CST,Effects,C:\repos\Reactive-Extensions_IL2JS\CST\Domain.cs,MakeArgLocal,The method has 6 parameters. Parameters: nArgs' nLocals' argLocal' index' isWrite' couldThrow
Long Parameter List,Microsoft.LiveLabs.CST,TypeEnvironment,C:\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,TypeEnvironment,The method has 5 parameters. Parameters: global' skolemDefs' assembly' type' typeBoundArguments
Long Parameter List,Microsoft.LiveLabs.CST,FieldEnvironment,C:\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,FieldEnvironment,The method has 6 parameters. Parameters: global' skolemDefs' assembly' type' typeBoundArguments' field
Long Parameter List,Microsoft.LiveLabs.CST,EventEnvironment,C:\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,EventEnvironment,The method has 6 parameters. Parameters: global' skolemDefs' assembly' type' typeBoundArguments' evnt
Long Parameter List,Microsoft.LiveLabs.CST,PropertyEnvironment,C:\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,PropertyEnvironment,The method has 6 parameters. Parameters: global' skolemDefs' assembly' type' typeBoundArguments' property
Long Parameter List,Microsoft.LiveLabs.CST,PolymorphicMethodEnvironment,C:\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,PolymorphicMethodEnvironment,The method has 6 parameters. Parameters: global' skolemDefs' assembly' type' typeBoundArguments' method
Long Parameter List,Microsoft.LiveLabs.CST,MethodEnvironment,C:\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,MethodEnvironment,The method has 7 parameters. Parameters: global' skolemDefs' assembly' type' typeBoundArguments' method' methodBoundArguments
Long Parameter List,Microsoft.LiveLabs.CST,CompilationEnvironment,C:\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,CompilationEnvironment,The method has 10 parameters. Parameters: global' skolemDefs' assembly' type' typeBoundArguments' method' methodBoundArguments' variables' valueParameterIds' localIds
Long Parameter List,Microsoft.LiveLabs.CST,CompilationEnvironment,C:\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,AddVariable,The method has 5 parameters. Parameters: id' argLocal' isInit' isReadOnly' type
Long Parameter List,Microsoft.LiveLabs.CST,BinaryExpression,C:\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,BinaryExpression,The method has 5 parameters. Parameters: leftValue' op' rightValue' withOverflow' isUnsigned
Long Parameter List,Microsoft.LiveLabs.CST,ExpressionStack,C:\repos\Reactive-Extensions_IL2JS\CST\ExpressionStack.cs,ExpressionStack,The method has 5 parameters. Parameters: compEnv' bottom' gensym' state' trace
Long Parameter List,Microsoft.LiveLabs.CST,ExpressionStack,C:\repos\Reactive-Extensions_IL2JS\CST\ExpressionStack.cs,PopEvalPushSE,The method has 5 parameters. Parameters: statements' arity' isLinear' bodyEffects' f
Long Parameter List,Microsoft.LiveLabs.CST,ExpressionStack,C:\repos\Reactive-Extensions_IL2JS\CST\ExpressionStack.cs,PopEvalSE,The method has 5 parameters. Parameters: statements' arity' isLinear' bodyEffects' f
Long Parameter List,Microsoft.LiveLabs.CST,Instruction,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,CalcStackChange,The method has 5 parameters. Parameters: depth' pops' pushes' thisPops' thisPushes
Long Parameter List,Microsoft.LiveLabs.CST,MethodInstruction,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,MethodInstruction,The method has 5 parameters. Parameters: offset' op' constrained' isVirtual' method
Long Parameter List,Microsoft.LiveLabs.CST,ArgsLocalsState,C:\repos\Reactive-Extensions_IL2JS\CST\MachineState.cs,PropogateBackwards,The method has 5 parameters. Parameters: other' argLocal' index' isAlive' changed
Long Parameter List,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,BackwardInstruction,The method has 5 parameters. Parameters: context' index' beforeState' afterState' changed
Long Parameter List,Microsoft.LiveLabs.CST,MemberDef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,TopologicalAllDeps,The method has 5 parameters. Parameters: global' assemblyDef' typeDef' visitedMemberDefs' sortedMemberDefs
Long Parameter List,Microsoft.LiveLabs.CST,MemberDef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,UsedByMembersClosure,The method has 5 parameters. Parameters: global' assemblyDef' typeDef' visitedMemberDefs' scc
Long Parameter List,Microsoft.LiveLabs.CST,MemberDef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,TopologicalTypeInit,The method has 6 parameters. Parameters: global' assemblyDef' typeDef' visitedTypeDefs' sortedTypeDefs' visitedMemberDefs
Long Parameter List,Microsoft.LiveLabs.CST,MemberDef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,TopologicalTypeInitFromImplementors,The method has 6 parameters. Parameters: global' assemblyDef' typeDef' visitedTypeDefs' sortedTypeDefs' visitedMemberDefs
Long Parameter List,Microsoft.LiveLabs.CST,MethodDef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,MethodDef,The method has 15 parameters. Parameters: annotations' customAttributes' name' isStatic' typeParameters' valueParameters' result' methodStyle' hasNewSlot' codeFlavor' isSyncronized' noInlining' isInitLocals' locals' methodBody
Long Parameter List,Microsoft.LiveLabs.CST,MethodDef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,PrimMethodReference,The method has 5 parameters. Parameters: global' assemblyDef' typeDef' typeBoundArguments' methodBoundArguments
Long Parameter List,Microsoft.LiveLabs.CST,MethodDef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,TopologicalTypeInitFromImplementors,The method has 6 parameters. Parameters: global' assemblyDef' typeDef' visitedTypeDefs' sortedTypeDefs' visitedMemberDefs
Long Parameter List,Microsoft.LiveLabs.CST,FieldDef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,FieldDef,The method has 6 parameters. Parameters: annotations' customAttributes' name' isStatic' fieldType' init
Long Parameter List,Microsoft.LiveLabs.CST,EventDef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,EventDef,The method has 7 parameters. Parameters: annotations' customAttributes' name' isStatic' add' remove' handlerType
Long Parameter List,Microsoft.LiveLabs.CST,PropertyDef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberDef.cs,PropertyDef,The method has 7 parameters. Parameters: annotations' customAttributes' name' isStatic' get' set' fieldType
Long Parameter List,Microsoft.LiveLabs.CST,PolymorphicMethodRef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberRef.cs,PolymorphicMethodRef,The method has 7 parameters. Parameters: annotations' definingType' name' isStatic' typeArity' valueParameters' result
Long Parameter List,Microsoft.LiveLabs.CST,PolymorphicMethodRef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberRef.cs,PolymorphicMethodRef,The method has 6 parameters. Parameters: definingType' name' isStatic' typeArity' valueParameters' result
Long Parameter List,Microsoft.LiveLabs.CST,MethodRef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberRef.cs,MethodRef,The method has 7 parameters. Parameters: annotations' definingType' name' isStatic' methodTypeArguments' valueParameters' result
Long Parameter List,Microsoft.LiveLabs.CST,MethodRef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberRef.cs,MethodRef,The method has 6 parameters. Parameters: definingType' name' isStatic' methodTypeArguments' valueParameters' result
Long Parameter List,Microsoft.LiveLabs.CST,PropertyRef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberRef.cs,PropertyRef,The method has 6 parameters. Parameters: annotations' definingType' name' isStatic' parameters' result
Long Parameter List,Microsoft.LiveLabs.CST,PropertyRef,C:\repos\Reactive-Extensions_IL2JS\CST\MemberRef.cs,PropertyRef,The method has 5 parameters. Parameters: definingType' name' isStatic' parameters' result
Long Parameter List,Microsoft.LiveLabs.CST,MessageContextBuilders,C:\repos\Reactive-Extensions_IL2JS\CST\MessageContextBuilders.cs,Member,The method has 5 parameters. Parameters: parent' global' assemblyDef' typeDef' memberDef
Long Parameter List,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,AssemblyName,The method has 9 parameters. Parameters: resolution' name' majorVersion' minorVersion' buildNumber' revisionNumber' culture' publicKeyToken' redirectFrom
Long Parameter List,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,AssemblyName,The method has 8 parameters. Parameters: resolution' name' majorVersion' minorVersion' buildNumber' revisionNumber' culture' publicKeyToken
Long Parameter List,Microsoft.LiveLabs.CST,DllLoadContext,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,DllLoadContext,The method has 5 parameters. Parameters: canonicalFileName' file' readerContext' assemblyRow' assemblyName
Long Parameter List,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,ArgsAndResultFromMethodSig,The method has 7 parameters. Parameters: ctxt' definingTypeRef' name' isStatic' valueParameters' result' sig
Long Parameter List,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,MethodRefFromMethodSig,The method has 7 parameters. Parameters: ctxt' definingTypeRef' name' isStatic' methodBoundArguments' arity' sig
Long Parameter List,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,SignatureFromMethodSig,The method has 5 parameters. Parameters: ctxt' definingTypeRef' name' isStatic' sig
Long Parameter List,Microsoft.LiveLabs.CST,MethodSignature,C:\repos\Reactive-Extensions_IL2JS\CST\Signature.cs,MethodSignature,The method has 5 parameters. Parameters: name' isStatic' typeArity' parameters' result
Long Parameter List,Microsoft.LiveLabs.CST,SimplifierContext,C:\repos\Reactive-Extensions_IL2JS\CST\SimplifierContext.cs,SimplifierContext,The method has 7 parameters. Parameters: compEnv' nameSupply' subst' statements' contextEffects' database' trace
Long Parameter List,Microsoft.LiveLabs.CST,ValidityContext,C:\repos\Reactive-Extensions_IL2JS\CST\Validity.cs,ImplementableInstruction,The method has 5 parameters. Parameters: ctxt' assemblyDef' typeDef' methodDef' instruction
Long Parameter List,Microsoft.LiveLabs.CST,Variable,C:\repos\Reactive-Extensions_IL2JS\CST\Variable.cs,Variable,The method has 5 parameters. Parameters: id' argLocal' isInit' isReadOnly' type
Long Parameter List,Microsoft.LiveLabs.CST,TypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimAreValidArguments,The method has 5 parameters. Parameters: vctxt' ctxt' originalType' groundEnv' groundTypeBoundArguments
Long Parameter List,Microsoft.LiveLabs.CST,TypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceRespectsParameterConstraint,The method has 7 parameters. Parameters: vctxt' ctxt' originalType' groundEnv' groundTypeBoundArguments' constraint' inCodePointer
Long Parameter List,Microsoft.LiveLabs.CST,TypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceIsAssignableTo,The method has 6 parameters. Parameters: groundEnv' thisAssembly' thisGroundTypeBoundArguments' otherAssembly' otherDef' otherGroundTypeBoundArguments
Long Parameter List,Microsoft.LiveLabs.CST,PointerTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceRespectsParameterConstraint,The method has 7 parameters. Parameters: vctxt' ctxt' originalType' groundEnv' groundTypeBoundArguments' constraint' inCodePointer
Long Parameter List,Microsoft.LiveLabs.CST,PointerTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceIsAssignableTo,The method has 6 parameters. Parameters: groundEnv' thisAssembly' thisGroundThisThisGroundTypeArguments' otherAssembly' otherDef' otherGroundGroundTypeArguments
Long Parameter List,Microsoft.LiveLabs.CST,CodePointerTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceRespectsParameterConstraint,The method has 7 parameters. Parameters: vctxt' ctxt' originalType' groundEnv' groundTypeBoundArguments' constraint' inCodePointer
Long Parameter List,Microsoft.LiveLabs.CST,ArrayTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceRespectsParameterConstraint,The method has 7 parameters. Parameters: vctxt' ctxt' originalType' groundEnv' groundTypeBoundArguments' constraint' inCodePointer
Long Parameter List,Microsoft.LiveLabs.CST,MultiDimArrayTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceRespectsParameterConstraint,The method has 7 parameters. Parameters: vctxt' ctxt' originalType' groundEnv' groundTypeBoundArguments' constraint' inCodePointer
Long Parameter List,Microsoft.LiveLabs.CST,MultiDimArrayTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceIsAssignableTo,The method has 6 parameters. Parameters: groundEnv' thisAssembly' thisGroundTypeBoundArguments' otherAssembly' otherDef' otherGroundTypeBoundArguments
Long Parameter List,Microsoft.LiveLabs.CST,BoxTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceRespectsParameterConstraint,The method has 7 parameters. Parameters: vctxt' ctxt' originalType' groundEnv' groundTypeBoundArguments' constraint' inCodePointer
Long Parameter List,Microsoft.LiveLabs.CST,NullTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceRespectsParameterConstraint,The method has 7 parameters. Parameters: vctxt' ctxt' originalType' groundEnv' groundTypeBoundArguments' constraint' inCodePointer
Long Parameter List,Microsoft.LiveLabs.CST,NullTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceIsAssignableTo,The method has 6 parameters. Parameters: groundEnv' thisAssembly' thisThisGroundTypeArguments' otherAssembly' otherDef' otherGroundTypeArguments
Long Parameter List,Microsoft.LiveLabs.CST,DerivingTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceRespectsParameterConstraint,The method has 7 parameters. Parameters: vctxt' ctxt' originalType' groundEnv' groundTypeBoundArguments' constraint' inCodePointer
Long Parameter List,Microsoft.LiveLabs.CST,ParameterTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,ParameterTypeDef,The method has 8 parameters. Parameters: annotations' customAttributes' extends' implements' parameterFlavor' index' variance' constraint
Long Parameter List,Microsoft.LiveLabs.CST,ParameterTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceRespectsParameterConstraint,The method has 7 parameters. Parameters: vctxt' ctxt' originalType' groundEnv' groundTypeBoundArguments' constraint' inCodePointer
Long Parameter List,Microsoft.LiveLabs.CST,ParameterTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimIsValidParameterBinding,The method has 7 parameters. Parameters: vctxt' ctxt' originalType' groundEnv' groundTypeBoundArguments' groundMethodBoundArguments' inCodePointer
Long Parameter List,Microsoft.LiveLabs.CST,NamedTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,NamedTypeDef,The method has 7 parameters. Parameters: annotations' customAttributes' extends' implements' parameters' name' members
Long Parameter List,Microsoft.LiveLabs.CST,RealTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,RealTypeDef,The method has 11 parameters. Parameters: annotations' customAttributes' extends' implements' parameters' name' members' explicitInterfaceImplementations' isSealed' isAbstract' isCallStaticConstructorEarly
Long Parameter List,Microsoft.LiveLabs.CST,StructTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,StructTypeDef,The method has 9 parameters. Parameters: annotations' customAttributes' extends' implements' parameters' name' members' slotImplementations' isCallStaticConstructorEarly
Long Parameter List,Microsoft.LiveLabs.CST,VoidTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,VoidTypeDef,The method has 9 parameters. Parameters: annotations' customAttributes' extends' implements' parameters' name' members' slotImplementations' isCallStaticConstructorEarly
Long Parameter List,Microsoft.LiveLabs.CST,VoidTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceIsAssignableTo,The method has 6 parameters. Parameters: groundEnv' thisAssembly' thisTypeArguments' otherAssembly' otherDef' otherTypeArguments
Long Parameter List,Microsoft.LiveLabs.CST,VoidTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceRespectsParameterConstraint,The method has 7 parameters. Parameters: vctxt' ctxt' originalType' groundEnv' groundTypeBoundArguments' constraint' inCodePointer
Long Parameter List,Microsoft.LiveLabs.CST,NumberTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,NumberTypeDef,The method has 10 parameters. Parameters: annotations' customAttributes' extends' implements' parameters' name' members' numberFlavor' slotImplementations' isCallStaticConstructorEarly
Long Parameter List,Microsoft.LiveLabs.CST,HandleTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,HandleTypeDef,The method has 10 parameters. Parameters: annotations' customAttributes' extends' implements' parameters' name' members' handleFlavor' slotImplementations' isCallStaticConstructorEarly
Long Parameter List,Microsoft.LiveLabs.CST,NullableTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,NullableTypeDef,The method has 9 parameters. Parameters: annotations' customAttributes' extends' implements' parameters' name' members' slotImplementations' isCallStaticConstructorEarly
Long Parameter List,Microsoft.LiveLabs.CST,NullableTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceRespectsParameterConstraint,The method has 7 parameters. Parameters: vctxt' ctxt' originalType' groundEnv' groundTypeBoundArguments' constraint' inCodePointer
Long Parameter List,Microsoft.LiveLabs.CST,EnumTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,EnumTypeDef,The method has 8 parameters. Parameters: annotations' customAttributes' extends' implements' name' members' slotImplementations' isCallStaticConstructorEarly
Long Parameter List,Microsoft.LiveLabs.CST,DelegateTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,DelegateTypeDef,The method has 9 parameters. Parameters: annotations' customAttributes' extends' implements' parameters' name' members' slotImplementations' isCallStaticConstructorEarly
Long Parameter List,Microsoft.LiveLabs.CST,ClassTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,ClassTypeDef,The method has 11 parameters. Parameters: annotations' customAttributes' extends' implements' parameters' name' members' slotImplementations' isSealed' isAbstract' isCallStaticConstructorEarly
Long Parameter List,Microsoft.LiveLabs.CST,ObjectTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,ObjectTypeDef,The method has 9 parameters. Parameters: annotations' customAttributes' extends' implements' parameters' name' members' slotImplementations' isCallStaticConstructorEarly
Long Parameter List,Microsoft.LiveLabs.CST,StringTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,StringTypeDef,The method has 9 parameters. Parameters: annotations' customAttributes' extends' implements' parameters' name' members' slotImplementations' isCallStaticConstructorEarly
Long Parameter List,Microsoft.LiveLabs.CST,InterfaceTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,InterfaceTypeDef,The method has 6 parameters. Parameters: annotations' customAttributes' implements' parameters' name' members
Long Parameter List,Microsoft.LiveLabs.CST,InterfaceTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceIsAssignableTo,The method has 6 parameters. Parameters: groundEnv' thisAssembly' thisTypeArguments' otherAssembly' otherDef' otherTypeArguments
Long Parameter List,Microsoft.LiveLabs.CST,GenericIEnumerableTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,GenericIEnumerableTypeDef,The method has 6 parameters. Parameters: annotations' customAttributes' implements' parameters' name' members
Long Identifier,Microsoft.LiveLabs.CST,Constants,C:\repos\Reactive-Extensions_IL2JS\CST\Constants.cs,,The length of the parameter EmptyTryPsuedoStatementHandlers is 31.
Long Identifier,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceSwitch,The length of the parameter allIntermediateAreNonReturningOrJumpToTarget is 44.
Long Identifier,Microsoft.LiveLabs.CST,Global,C:\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,,The length of the parameter ManagedPointerTypeConstructorDef is 32.
Long Identifier,Microsoft.LiveLabs.CST,Global,C:\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,,The length of the parameter ManagedPointerTypeConstructorRef is 32.
Long Identifier,Microsoft.LiveLabs.CST,Global,C:\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,,The length of the parameter UnmanagedPointerTypeConstructorDef is 34.
Long Identifier,Microsoft.LiveLabs.CST,Global,C:\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,,The length of the parameter UnmanagedPointerTypeConstructorRef is 34.
Long Identifier,Microsoft.LiveLabs.CST,Global,C:\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,,The length of the parameter multiDimArrayTypeConstructorDefs is 32.
Long Identifier,Microsoft.LiveLabs.CST,Global,C:\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,,The length of the parameter QualifiedTypeNameToAbbreviation is 31.
Long Identifier,Microsoft.LiveLabs.CST,Global,C:\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,,The length of the parameter QualifiedTypeNameToNumberFlavor is 31.
Long Identifier,Microsoft.LiveLabs.CST,Global,C:\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,,The length of the parameter NumberFlavorToQualifiedTypeName is 31.
Long Identifier,Microsoft.LiveLabs.CST,Global,C:\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,,The length of the parameter QualifiedTypeNameToHandleFlavor is 31.
Long Identifier,Microsoft.LiveLabs.CST,Global,C:\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,,The length of the parameter HandleFlavorToQualifiedTypeName is 31.
Long Identifier,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The length of the parameter explicitInterfaceImplementationRows is 35.
Long Identifier,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The length of the parameter explicitInterfaceImplementations is 32.
Long Identifier,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,,The length of the parameter knownUnavailableCustomAttributeTypes is 36.
Long Identifier,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,,The length of the parameter instructionTranslationStyleCache is 32.
Long Identifier,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,,The length of the parameter labelToLoopCandidateContinueState is 33.
Long Identifier,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,,The length of the parameter labelToLoopCandidateBreakState is 30.
Long Identifier,Microsoft.LiveLabs.CST,PointerTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceIsAssignableTo,The length of the parameter thisGroundThisThisGroundTypeArguments is 37.
Long Identifier,Microsoft.LiveLabs.CST,PointerTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceIsAssignableTo,The length of the parameter otherGroundGroundTypeArguments is 30.
Long Identifier,Microsoft.LiveLabs.CST,RealTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,RealTypeDef,The length of the parameter explicitInterfaceImplementations is 32.
Long Identifier,Microsoft.LiveLabs.CST,RealTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,,The length of the parameter ExplicitInterfaceImplementations is 32.
Long Statement,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceLooping,The length of the statement  "                                var loopbb = new LoopCandidateBasicBlock(nextBlockId++' loop.Label' loop.Head.Block.BeforeState) { Head = loop.Head' Break = candidateBreakTarget }; " is 148.
Long Statement,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,Root,The length of the statement  "            var root = new RootBasicBlock(nextBlockId++' new MachineState(methEnv' method.ValueParameters.Count' method.Locals.Count)); " is 123.
Long Statement,Microsoft.LiveLabs.CST,PointsTo,C:\repos\Reactive-Extensions_IL2JS\CST\Domain.cs,ReadEffect,The length of the statement  "                return new Effects(Args.Members.Clone()' new IntSet(NumArgs)' Locals.Members.Clone()' new IntSet(NumLocals)' Heap.Value' false' false); " is 135.
Long Statement,Microsoft.LiveLabs.CST,PointsTo,C:\repos\Reactive-Extensions_IL2JS\CST\Domain.cs,WriteEffect,The length of the statement  "                return new Effects(Args.Members.Clone()' Args.Members.Clone()' Locals.Members.Clone()' Locals.Members.Clone()' Heap.Value' Heap.Value' false); " is 142.
Long Statement,Microsoft.LiveLabs.CST,TypeConstructorEnvironment,C:\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,AddSelfTypeBoundArguments,The length of the statement  "                var typeBoundSkolemDefs = Type.Parameters.Select(p => new SkolemDef(Assembly' Type' p.PrimSubstitute(typeBoundArguments' null))); " is 129.
Long Statement,Microsoft.LiveLabs.CST,MethodEnvironment,C:\repos\Reactive-Extensions_IL2JS\CST\Environment.cs,AddVariables,The length of the statement  "            return new CompilationEnvironment(Global' SkolemDefs' Assembly' Type' TypeBoundArguments' Method' MethodBoundArguments' variables' valueParameterIds' localIds); " is 160.
Long Statement,Microsoft.LiveLabs.CST,ExpressionStack,C:\repos\Reactive-Extensions_IL2JS\CST\ExpressionStack.cs,Dump,The length of the statement  "                compEnv.AddVariable(id' ArgLocal.Local' false' true' compEnv.SubstituteType(state.PeekType(stack.Count - (1 + skip) - i))); " is 123.
Long Statement,Microsoft.LiveLabs.CST,ExpressionStack,C:\repos\Reactive-Extensions_IL2JS\CST\ExpressionStack.cs,Restore,The length of the statement  "                    (id' ArgLocal.Local' false' true' compEnv.SubstituteType(stateAfterRestore.PeekType(stateAfterRestore.Depth - skip - 1 - i))); " is 126.
Long Statement,Microsoft.LiveLabs.CST,Instructions,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,AccumUsedTypeAndMemberDefs,The length of the statement  "            return Body.Select(i => i.AccumUsedTypeAndMemberDefs(vctxt' ctxt' usedTypes' usedMembers)).FirstOrDefault(v => v != null); " is 122.
Long Statement,Microsoft.LiveLabs.CST,BranchInstruction,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,Clone,The length of the statement  "            return new BranchInstruction(nextInstructionId--' Op' IsUnsigned' Target) { BeforeState = BeforeState' AfterState = AfterState' Type = Type }; " is 142.
Long Statement,Microsoft.LiveLabs.CST,CompareInstruction,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,Clone,The length of the statement  "            return new CompareInstruction(nextInstructionId--' Op' IsUnsigned) { BeforeState = BeforeState' AfterState = AfterState' Type = Type }; " is 135.
Long Statement,Microsoft.LiveLabs.CST,ArgLocalInstruction,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,Clone,The length of the statement  "            return new ArgLocalInstruction(nextInstructionId--' Op' ArgLocal' Index) { BeforeState = BeforeState' AfterState = AfterState }; " is 128.
Long Statement,Microsoft.LiveLabs.CST,FieldInstruction,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,Clone,The length of the statement  "            return new FieldInstruction(nextInstructionId--' Op' Field' IsStatic) { BeforeState = BeforeState' AfterState = AfterState' IsViaPointer = IsViaPointer }; " is 154.
Long Statement,Microsoft.LiveLabs.CST,MethodInstruction,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,Clone,The length of the statement  "            return new MethodInstruction(nextInstructionId--' Op' Constrained' IsVirtual' Method) { BeforeState = BeforeState' AfterState = AfterState }; " is 141.
Long Statement,Microsoft.LiveLabs.CST,LdElemAddrInstruction,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,Clone,The length of the statement  "            return new LdElemAddrInstruction(nextInstructionId--' IsReadonly' Type) { BeforeState = BeforeState' AfterState = AfterState }; " is 127.
Long Statement,Microsoft.LiveLabs.CST,ArithInstruction,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,Clone,The length of the statement  "            return new ArithInstruction(nextInstructionId--' Op' WithOverflow' IsUnsigned) { BeforeState = BeforeState' AfterState = AfterState' Type = Type }; " is 147.
Long Statement,Microsoft.LiveLabs.CST,ConvInstruction,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,Clone,The length of the statement  "            return new ConvInstruction(nextInstructionId--' TargetNumberFlavor' WithOverflow' IsSourceUnsigned) { BeforeState = BeforeState' AfterState = AfterState' SourceType = SourceType }; " is 180.
Long Statement,Microsoft.LiveLabs.CST,TryInstruction,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,Clone,The length of the statement  "            return new TryInstruction(nextInstructionId--' Body.Clone(ref nextInstructionId)' newHandlers) { BeforeState = BeforeState' AfterState = AfterState }; " is 150.
Long Statement,Microsoft.LiveLabs.CST,IfThenElseInstruction,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,IsInlinable,The length of the statement  "            return Condition.IsInlinable(ref numReturns) && Then.IsInlinable(ref numReturns) && (Else == null || Else.IsInlinable(ref numReturns)); " is 135.
Long Statement,Microsoft.LiveLabs.CST,DoWhileInstruction,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,Clone,The length of the statement  "                (nextInstructionId--' Body.Clone(ref nextInstructionId)' Condition.Clone(ref nextInstructionId)) { BeforeState = BeforeState' AfterState = AfterState }; " is 152.
Long Statement,Microsoft.LiveLabs.CST,BreakContinueInstruction,C:\repos\Reactive-Extensions_IL2JS\CST\Instruction.cs,Clone,The length of the statement  "            return new BreakContinueInstruction(nextInstructionId--' Op' Label) { BeforeState = BeforeState' AfterState = AfterState }; " is 123.
Long Statement,Microsoft.LiveLabs.CST,MachineState,C:\repos\Reactive-Extensions_IL2JS\CST\MachineState.cs,CloneWithArgLocalPointsTo,The length of the statement  "            return new MachineState(RootEnv' nArgs' nLocals' innerState.Value.CloneWithArgLocalPointsTo(stack' argLocal' index' pointsTo)); " is 127.
Long Statement,Microsoft.LiveLabs.CST,MachineState,C:\repos\Reactive-Extensions_IL2JS\CST\MachineState.cs,PropogateBackwards,The length of the statement  "            innerState.Value.ArgsLocalsState.PropogateBackwards(nextState.innerState.Value.ArgsLocalsState' default(ArgLocal)' -1' false' changed); " is 135.
Long Statement,Microsoft.LiveLabs.CST,MachineState,C:\repos\Reactive-Extensions_IL2JS\CST\MachineState.cs,WriteArgLocal,The length of the statement  "            innerState.Value.ArgsLocalsState.PropogateBackwards(nextState.innerState.Value.ArgsLocalsState' argLocal' index' false' changed); " is 129.
Long Statement,Microsoft.LiveLabs.CST,MachineState,C:\repos\Reactive-Extensions_IL2JS\CST\MachineState.cs,ReadArgLocal,The length of the statement  "            innerState.Value.ArgsLocalsState.PropogateBackwards(nextState.innerState.Value.ArgsLocalsState' argLocal' index' true' changed); " is 128.
Long Statement,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The length of the statement  "                        return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(type)' ArgLocalPT(argi.ArgLocal' argi.Index)); " is 124.
Long Statement,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,Append,The length of the statement  "            if (w.Global.AssemblyNameResolution == AssemblyNameResolution.Full || w.Global.AssemblyNameResolution == AssemblyNameResolution.NameVersion) " is 140.
Long Statement,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,Equals,The length of the statement  "            if (MajorVersion != other.MajorVersion || MinorVersion != other.MinorVersion || BuildNumber != other.BuildNumber || RevisionNumber != other.RevisionNumber) " is 155.
Long Statement,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,FromReflectionName,The length of the statement  "            return new AssemblyName(resolution' name' majorVersion' minorVersion' buildNumber' revisionNumber' culture' publicKeyToken); " is 124.
Long Statement,Microsoft.LiveLabs.CST,Peephole,C:\repos\Reactive-Extensions_IL2JS\CST\Peephole.cs,MoveNext,The length of the statement  "                                        lookahead[0] = new CompareInstruction(compj.Offset' CompareOp.CtruePseudo' false) { Type = compj.Type' BeforeState = ldinti.BeforeState' AfterState = compj.AfterState }; " is 169.
Long Statement,Microsoft.LiveLabs.CST,Peephole,C:\repos\Reactive-Extensions_IL2JS\CST\Peephole.cs,MoveNext,The length of the statement  "                                        lookahead[0] = new CompareInstruction(compj.Offset' CompareOp.CfalsePseudo' false) { Type = compj.Type' BeforeState = ldinti.BeforeState' AfterState = compj.AfterState }; " is 170.
Long Statement,Microsoft.LiveLabs.CST,Peephole,C:\repos\Reactive-Extensions_IL2JS\CST\Peephole.cs,MoveNext,The length of the statement  "                                        lookahead[0] = new CompareInstruction(compj.Offset' CompareOp.CtruePseudo' false) { Type = compj.Type' BeforeState = misci.BeforeState' AfterState = compj.AfterState }; " is 168.
Long Statement,Microsoft.LiveLabs.CST,Peephole,C:\repos\Reactive-Extensions_IL2JS\CST\Peephole.cs,MoveNext,The length of the statement  "                                        lookahead[0] = new CompareInstruction(compj.Offset' CompareOp.CfalsePseudo' false) { Type = compj.Type' BeforeState = misci.BeforeState' AfterState = compj.AfterState }; " is 169.
Long Statement,Microsoft.LiveLabs.CST,DllLoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,AssemblyNameFromAssemblyRow,The length of the statement  "            return new AssemblyName(resolution' row.Name.Value' row.MajorVersion' row.MinorVersion' row.BuildNumber' row.RevisionNumber' row.Culture.Value' row.PublicKey.Value); " is 165.
Long Statement,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeRefFromTypeSig,The length of the statement  "                    return global.UnmanagedPointerTypeConstructorRef.ApplyTo(TypeRefFromTypeSigWithCustomMods(ctxt' unmanPtrSig.ElementType)); " is 122.
Long Statement,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeRefFromTypeSig,The length of the statement  "                    return global.ManagedPointerTypeConstructorRef.ApplyTo(annotations' TypeRefFromTypeSig(ctxt' null' manPtrSig.ElementType' true)); " is 129.
Long Statement,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeRefFromTypeSig,The length of the statement  "                    return global.ArrayTypeConstructorRef.ApplyTo(annotations' TypeRefFromTypeSigWithCustomMods(ctxt' arrayTypeSig.ElementType)); " is 125.
Long Statement,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,ArgsAndResultFromMethodSig,The length of the statement  "            if (definingTypeRef.Arguments.Count == 1 && !isStatic && (name.Equals("Set"' StringComparison.Ordinal) || name.Equals("Get"' StringComparison.Ordinal)) && " is 154.
Long Statement,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The length of the statement  "            if (extends != null && (extends.Equals(global.EnumRef) || (!thisTypeRef.Equals(global.EnumRef) && extends.Equals(global.ValueTypeRef)))) " is 136.
Long Statement,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeRefToPropertyTypeName,The length of the statement  "                throw new InvalidOperationException("only types without type arguments may be used as custom attribute property types"); " is 120.
Long Statement,Microsoft.LiveLabs.CST,ValidityContext,C:\repos\Reactive-Extensions_IL2JS\CST\Validity.cs,Stats,The length of the statement  "                tracer.AppendLine(String.Format("{0}: {1} assemblies' {2} types ({3} valid' {4} used)' {5} members ({6} valid' {7} used)"' msg' nAssemblies' nTypes' nValidTypes' nUsedTypes' nMembers' nValidMembers' nUsedMembers)); " is 214.
Long Statement,Microsoft.LiveLabs.CST,ValidityContext,C:\repos\Reactive-Extensions_IL2JS\CST\Validity.cs,Check,The length of the statement  "                    //  - virtual/iface method must have a def and used implementing type => used override/impl methods of that type must have a def " is 128.
Long Statement,Microsoft.LiveLabs.CST,Variable,C:\repos\Reactive-Extensions_IL2JS\CST\Variable.cs,Equals,The length of the statement  "            return Id.Equals(other.Id) && ArgLocal == other.ArgLocal && IsInit == other.IsInit && IsReadOnly == other.IsReadOnly && Type.Equals(other.Type); " is 144.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "                                (new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' ReadHeapE)); " is 129.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "                                         return new ExpressionStackEntry(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' readEffect); " is 134.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "                                         return new ExpressionStackEntry(new FieldCell(new ReadExpression(a[0])' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e); " is 128.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "                                         return new ExpressionStackEntry(new FieldCell(a[0]' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e.Lub(ThrowsE)); " is 121.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "                        stack.Push(new ExpressionStackEntry(new FieldHandleConstantExpression(compEnv.SubstituteMember(fieldi.Field))' BottomE)); " is 121.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "                             new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).Read().CloneIfStruct(compEnv)' e.Lub(ThrowsE))); " is 127.
Long Statement,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The length of the statement  "                        (new IfThenElseStatement(condEntry.Expression' new Statements(thenStmnts)' elseStmnts == null ? null : new Statements(elseStmnts))); " is 132.
Long Statement,Microsoft.LiveLabs.CST,MultiDimArrayTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceRespectsParameterConstraint,The length of the statement  "                    vctxt.Log(new InvalidTypeRef(ctxt' originalType' "A multi-dimensional array type cannot be used to instantiate a type parameter with a value-type or constructor constraint")); " is 175.
Long Statement,Microsoft.LiveLabs.CST,MultiDimArrayTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceIsAssignableTo,The length of the statement  "                return base.PrimInstanceIsAssignableTo(groundEnv' thisAssembly' thisGroundTypeBoundArguments' otherAssembly' otherDef' otherGroundTypeBoundArguments); " is 150.
Long Statement,Microsoft.LiveLabs.CST,ParameterTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceRespectsParameterConstraint,The length of the statement  "            return base.PrimInstanceRespectsParameterConstraint(vctxt' ctxt' originalType' groundEnv' groundTypeBoundArguments' constraint' inCodePointer); " is 143.
Long Statement,Microsoft.LiveLabs.CST,ParameterTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimIsValidParameterBinding,The length of the statement  "            if (!boundTypeEnv.Type.PrimInstanceRespectsParameterConstraint(vctxt' ctxt' originalType' groundEnv' boundGroundArguments' Constraint' inCodePointer)) " is 150.
Long Statement,Microsoft.LiveLabs.CST,RealTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,ImplementingMethod,The length of the statement  "                if (slotRef.DefiningType.Equals(interfaceMethodRef.DefiningType) && slotRef.ExternalSignature.WithoutThis().Equals(interfaceMethodSig)) " is 135.
Long Statement,Microsoft.LiveLabs.CST,EnumTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,AccumUsedTypeDefs,The length of the statement  "            Invalid = Implementation.AccumUsedTypeDefs(vctxt' MessageContextBuilders.Type(vctxt.Global' assemblyDef' this)' usedTypes); " is 123.
Long Statement,Microsoft.LiveLabs.CST,InterfaceTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,PrimInstanceIsAssignableTo,The length of the statement  "                return base.PrimInstanceIsAssignableTo(groundEnv' thisAssembly' thisTypeArguments' otherAssembly' otherDef' otherTypeArguments); " is 128.
Long Statement,Microsoft.LiveLabs.CST,NamedTypeRef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeRef.cs,PrimSubstitute,The length of the statement  "            return new NamedTypeRef(Annotations' name' arguments.Select(t => t.PrimSubstitute(typeBoundArguments' methodBoundArguments)).ToSeq()); " is 134.
Complex Conditional,Microsoft.LiveLabs.CST,BBLoop,C:\repos\Reactive-Extensions_IL2JS\CST\BasicBlockUtils.cs,BBLoop,The conditional expression  "headEscapes && tailEscapes && headbranchbb != null && tailbranchbb != null"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,FieldCell,C:\repos\Reactive-Extensions_IL2JS\CST\Cell.cs,EqualBody,The conditional expression  "Object == null && field.Object != null || Object != null && field.Object == null"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceBranch,The conditional expression  "thenbb != null && thenbb.Target.Equals(branchbb) && thenbb.Sources.Count == 1 && group.Add(thenbb) &&                      !group.Contains(branchbb.Fallthrough)"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceBranch,The conditional expression  "elsebb != null && elsebb.Target.Equals(branchbb) && elsebb.Sources.Count == 1 && group.Add(elsebb) &&                      !group.Contains(branchbb.Target)"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceBranch,The conditional expression  "thenbb != null && elsebb != null && thenbb.Target.Equals(elsebb.Target) &&                      elsebb.Sources.Count == 1 && group.Add(elsebb) && !group.Contains(thenbb) &&                      !group.Contains(thenbb.Target) && !thenbb.Target.Equals(thenbb) &&                      IsLoadBooleanBlock(thenbb.Block)"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceBranch,The conditional expression  "thenbb != null && elsebb != null && thenbb.Target.Equals(elsebb.Target) &&                      thenbb.Sources.Count == 1 && group.Add(thenbb) && !group.Contains(elsebb) &&                      !group.Contains(elsebb.Target) && !elsebb.Target.Equals(elsebb) &&                      IsLoadBooleanBlock(elsebb.Block)"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceBranch,The conditional expression  "thenbb != null && branchbb.Fallthrough.Equals(thenbb.Fallthrough) && thenbb.Sources.Count == 1 &&                      group.Add(thenbb) && !group.Contains(thenbb.Target) && !group.Contains(branchbb.Fallthrough)"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceBranch,The conditional expression  "elsebb != null && branchbb.Target.Equals(elsebb.Fallthrough) && elsebb.Sources.Count == 1 &&                      group.Add(elsebb) && !group.Contains(elsebb.Target) && !group.Contains(branchbb.Target)"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceBranch,The conditional expression  "thenbb != null && branchbb.Fallthrough.Equals(thenbb.Target) && thenbb.Sources.Count == 1 &&                      group.Add(thenbb) && !group.Contains(thenbb.Fallthrough) && !group.Contains(branchbb.Fallthrough)"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceBranch,The conditional expression  "elsebb != null && branchbb.Target.Equals(elsebb.Target) && elsebb.Sources.Count == 1 &&                      group.Add(elsebb) && !group.Contains(elsebb.Fallthrough) && !group.Contains(branchbb.Target)"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceBranch,The conditional expression  "thenbb != null && elsebb != null && !branchbb.Equals(thenbb) && !branchbb.Equals(elsebb) &&                      !thenbb.Equals(elsebb) && branchbb.Target.Sources.Count == 1 &&                      branchbb.Fallthrough.Sources.Count == 1"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceBranch,The conditional expression  "group.Add(branchbb.Target) && group.Add(branchbb.Fallthrough) &&                      branchbb.Target.Sources.Count == 1 && branchbb.Fallthrough.Sources.Count == 1 &&                      branchbb.Target.HasSameExit(branchbb.Fallthrough)"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceLoopCandidate,The conditional expression  "(jumpheadbb != null && jumpheadbb.Target.Equals(loopbb.Break) || nonretheadbb != null) &&                  group.Add(headbb) && !group.Contains(loopbb.Break)"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,Effects,C:\repos\Reactive-Extensions_IL2JS\CST\Domain.cs,Lub,The conditional expression  "args == null || locals == null || heap == null || mayThrow == null"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,Effects,C:\repos\Reactive-Extensions_IL2JS\CST\Domain.cs,Lub,The conditional expression  "args == null || locals == null || heap == null || mayThrow == null"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,CodePointerExpression,C:\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,EqualBody,The conditional expression  "Object == null && func.Object != null || Object != null && func.Object == null"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,TranslationContext,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,OutermostTryBlocks,The conditional expression  "first >= 0 && Handlers[first].TryOffset == Handlers[last].TryOffset &&                                 Handlers[first].TryLength == Handlers[last].TryLength &&                                 Handlers[first].Flags == PE.CorILExceptionClause.Exception &&                                 Handlers[last].Flags == PE.CorILExceptionClause.Exception"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,Equals,The conditional expression  "MajorVersion != other.MajorVersion || MinorVersion != other.MinorVersion || BuildNumber != other.BuildNumber || RevisionNumber != other.RevisionNumber"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,GetKeyword,The conditional expression  "i < str.Length && ((str[i] >= 'a' && str[i] <= 'z') || (str[i] >= 'A' && str[i] <= 'Z'))"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,AssemblyNameSubstitution,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,Add,The conditional expression  "(existTarget == null && target != null) || (existTarget != null && target == null) ||                      (existTarget != null && !existTarget.Equals(target))"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,ArgsAndResultFromMethodSig,The conditional expression  "definingTypeRef.Arguments.Count == 1 && !isStatic && (name.Equals("Set"' StringComparison.Ordinal) || name.Equals("Get"' StringComparison.Ordinal)) &&                  valParams != null"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,ArgsAndResultFromMethodSig,The conditional expression  "name.Equals("Get"' StringComparison.Ordinal) && valParams.Count == 1 + bounds.Rank &&                               result != null && result.Equals(definingTypeRef.Arguments[0])"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,MethodDefFromRow,The conditional expression  "(row.Flags & PE.MethodAttributes.SpecialName) != 0 && (row.Flags & PE.MethodAttributes.RTSpecialName) != 0 &&                  (row.Name.Value.Equals(".ctor"' StringComparison.Ordinal) ||                   row.Name.Value.Equals(".cctor"' StringComparison.Ordinal))"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The conditional expression  "extends != null && (extends.Equals(global.EnumRef) || (!thisTypeRef.Equals(global.EnumRef) && extends.Equals(global.ValueTypeRef)))"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The conditional expression  "qtn.Equals(global.EnumRef.QualifiedTypeName) || qtn.Equals(global.ValueTypeRef.QualifiedTypeName) ||                           qtn.Equals(global.DelegateRef.QualifiedTypeName) || qtn.Equals(global.MulticastDelegateRef.QualifiedTypeName) ||                           qtn.Equals(global.ObjectRef.QualifiedTypeName)"  is complex.
Complex Conditional,Microsoft.LiveLabs.CST,MethodSignature,C:\repos\Reactive-Extensions_IL2JS\CST\Signature.cs,Equals,The conditional expression  "Result == null && otherMeth.Result != null || Result != null && otherMeth.Result == null"  is complex.
Virtual Method Call from Constructor,Microsoft.LiveLabs.CST,AssemblyDef,C:\repos\Reactive-Extensions_IL2JS\CST\AssemblyDef.cs,AssemblyDef,The constructor "AssemblyDef" calls a virtual method "EffectiveName".
Virtual Method Call from Constructor,Microsoft.LiveLabs.CST,CallContext,C:\repos\Reactive-Extensions_IL2JS\CST\CallContext.cs,CallContext,The constructor "CallContext" calls a virtual method "AccumEffects".
Virtual Method Call from Constructor,Microsoft.LiveLabs.CST,CallContext,C:\repos\Reactive-Extensions_IL2JS\CST\CallContext.cs,CallContext,The constructor "CallContext" calls a virtual method "IsValue".
Empty Catch Block,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,CustomAttributeFromRow,The method has an empty catch block.
Magic Number,Microsoft.LiveLabs.CST,Test,C:\repos\Reactive-Extensions_IL2JS\CST\BasicBlock.cs,Rot11,The following statement contains a magic number: return v << 11 | v >> 21;
Magic Number,Microsoft.LiveLabs.CST,Test,C:\repos\Reactive-Extensions_IL2JS\CST\BasicBlock.cs,Rot11,The following statement contains a magic number: return v << 11 | v >> 21;
Magic Number,Microsoft.LiveLabs.CST,Test,C:\repos\Reactive-Extensions_IL2JS\CST\BasicBlock.cs,GetHashCode,The following statement contains a magic number: res = Rot11(res) ^ (uint)Op * 47;
Magic Number,Microsoft.LiveLabs.CST,BBEdge,C:\repos\Reactive-Extensions_IL2JS\CST\BasicBlockUtils.cs,Rot17,The following statement contains a magic number: return (int)(((uint)v << 17) | ((uint)v >> 15));
Magic Number,Microsoft.LiveLabs.CST,BBEdge,C:\repos\Reactive-Extensions_IL2JS\CST\BasicBlockUtils.cs,Rot17,The following statement contains a magic number: return (int)(((uint)v << 17) | ((uint)v >> 15));
Magic Number,Microsoft.LiveLabs.CST,Constants,C:\repos\Reactive-Extensions_IL2JS\CST\Constants.cs,Rot3,The following statement contains a magic number: return v << 3 | v >> 29;
Magic Number,Microsoft.LiveLabs.CST,Constants,C:\repos\Reactive-Extensions_IL2JS\CST\Constants.cs,Rot3,The following statement contains a magic number: return v << 3 | v >> 29;
Magic Number,Microsoft.LiveLabs.CST,Constants,C:\repos\Reactive-Extensions_IL2JS\CST\Constants.cs,Rot7,The following statement contains a magic number: return v << 7 | v >> 25;
Magic Number,Microsoft.LiveLabs.CST,Constants,C:\repos\Reactive-Extensions_IL2JS\CST\Constants.cs,Rot7,The following statement contains a magic number: return v << 7 | v >> 25;
Magic Number,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,IsDuplicatableBasicBlock,The following statement contains a magic number: var i = FindStartOfStackPrefix(bb.Block.Body' bb.Block.Count - 2' 1);
Magic Number,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,IsDuplicatableBasicBlock,The following statement contains a magic number: if (i == 0 && bb.Block.Count <= 2) // threshold of 2 instructions                  return true;
Magic Number,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,Reduce,The following statement contains a magic number: if (tracer != null)              {                  if (BasicBlockUtils.PostOrder(root).Count > 2)                      tracer.AppendLine("WARNING: Did not reduce all control flow.");                  else                      tracer.AppendLine("All control flow reduced.");              }
Magic Number,Microsoft.LiveLabs.CST,Int64ConstantExpression,C:\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,GetHashCode,The following statement contains a magic number: res ^= (uint)((ulong)Value >> 32);
Magic Number,Microsoft.LiveLabs.CST,Int64ConstantExpression,C:\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,GetHashCode,The following statement contains a magic number: res ^= (uint)((ulong)Value & ((1LU << 32) - 1));
Magic Number,Microsoft.LiveLabs.CST,SingleConstantExpression,C:\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,GetHashCode,The following statement contains a magic number: res ^= (uint)(v >> 32);
Magic Number,Microsoft.LiveLabs.CST,SingleConstantExpression,C:\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,GetHashCode,The following statement contains a magic number: res ^= (uint)(v & ((1UL << 32) - 1));
Magic Number,Microsoft.LiveLabs.CST,DoubleConstantExpression,C:\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,GetHashCode,The following statement contains a magic number: res ^= (uint)(v >> 32);
Magic Number,Microsoft.LiveLabs.CST,DoubleConstantExpression,C:\repos\Reactive-Extensions_IL2JS\CST\Expression.cs,GetHashCode,The following statement contains a magic number: res ^= (uint)(v & ((1LU << 32) - 1));
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: while (!ctxt.AtEnd(i))              {                  var j = i > ctxt.Start ? ctxt.JumpOverHandlers(i) : i;                  if (j > i)                      i = j;                  else                  {                      var ehcs = ctxt.OutermostTryBlocks(i);                      if (ehcs != null)                      {                          // A try instruction begins here with given handlers                          var offset = ctxt.Instructions[i].Offset;                          var tryCtxt = new TryTranslationContext(ctxt' i' ehcs);                          var tryBlock = InstructionsFromContext(tryCtxt);                            var handlers = new Seq<TryInstructionHandler>();                          foreach (var ehc in ehcs)                          {                              var handlerCtxt = new HandlerTranslationContext                                  (tryCtxt' ctxt.OffsetToIndex[ehc.HandlerOffset]' ehc);                              var handlerBlock = InstructionsFromContext(handlerCtxt);                              switch (ehc.Flags)                              {                              case PE.CorILExceptionClause.Exception:                                  handlers.Add(new CatchTryInstructionHandler((TypeRef)ehc.Class' handlerBlock));                                  break;                              case PE.CorILExceptionClause.Filter:                                  {                                      var filterCtxt = new FilterTranslationContext                                          (tryCtxt' ctxt.OffsetToIndex[ehc.FilterOffset]' ehc);                                      var filterBlock = InstructionsFromContext(filterCtxt);                                      handlers.Add(new FilterTryInstructionHandler(filterBlock' handlerBlock));                                      break;                                  }                              case PE.CorILExceptionClause.Finally:                                  handlers.Add(new FinallyTryInstructionHandler(handlerBlock));                                  break;                              case PE.CorILExceptionClause.Fault:                                  handlers.Add(new FaultTryInstructionHandler(handlerBlock));                                  break;                              default:                                  throw new ArgumentOutOfRangeException();                              }                          }                          instructions.Add(new TryInstruction(offset' tryBlock' handlers));                            // Jump over try block                          var nextOffset = ehcs[0].TryOffset + ehcs[0].TryLength;                          if (!ctxt.OffsetToIndex.TryGetValue(nextOffset' out i))                              i = ctxt.Instructions.Length;                      }                      else                      {                          var instruction = ctxt.Instructions[i++];                          var offset = instruction.Offset;                            while (instruction.OpCode == PE.OpCode.Unaligned || instruction.OpCode == PE.OpCode.Volatile ||                                 instruction.OpCode == PE.OpCode.Tailcall)                          {                              // Skip over any ignored prefixes' but remember instruction begins at original offset                              // NOTE: What ever happened to the "no." prefix mentioned in the spec?                              if (i >= ctxt.Instructions.Length)                                  throw new InvalidOperationException("invalid instructions");                              instruction = ctxt.Instructions[i++];                          }                          switch (instruction.OpCode)                          {                          case PE.OpCode.Cpblk:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Cpblk));                              break;                          case PE.OpCode.Initblk:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Initblk));                              break;                          case PE.OpCode.Arglist:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Arglist));                              break;                          case PE.OpCode.Localloc:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Localloc));                              break;                          case PE.OpCode.Jmp:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Jmp));                              break;                          case PE.OpCode.Calli:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Calli));                              break;                          case PE.OpCode.Sizeof:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Sizeof));                              break;                          case PE.OpCode.Mkrefany:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Mkrefany));                              break;                          case PE.OpCode.Refanytype:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Refanytype));                              break;                          case PE.OpCode.Refanyval:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Refanyval));                              break;                          case PE.OpCode.Nop:                              instructions.Add(new MiscInstruction(offset' MiscOp.Nop));                              break;                          case PE.OpCode.Break:                              instructions.Add(new MiscInstruction(offset' MiscOp.Break));                              break;                          case PE.OpCode.Dup:                              instructions.Add(new MiscInstruction(offset' MiscOp.Dup));                              break;                          case PE.OpCode.Pop:                              instructions.Add(new MiscInstruction(offset' MiscOp.Pop));                              break;                          case PE.OpCode.Ldnull:                              instructions.Add(new MiscInstruction(offset' MiscOp.Ldnull));                              break;                          case PE.OpCode.Ckfinite:                              instructions.Add(new MiscInstruction(offset' MiscOp.Ckfinite));                              break;                          case PE.OpCode.Throw:                              instructions.Add(new MiscInstruction(offset' MiscOp.Throw));                              break;                          case PE.OpCode.Rethrow:                              instructions.Add(new MiscInstruction(offset' MiscOp.Rethrow));                              break;                          case PE.OpCode.Ldind_ref:                              instructions.Add(new MiscInstruction(offset' MiscOp.LdindRef));                              break;                          case PE.OpCode.Stind_ref:                              instructions.Add(new MiscInstruction(offset' MiscOp.StindRef));                              break;                          case PE.OpCode.Ldelem_ref:                              instructions.Add(new MiscInstruction(offset' MiscOp.LdelemRef));                              break;                          case PE.OpCode.Stelem_ref:                              instructions.Add(new MiscInstruction(offset' MiscOp.StelemRef));                              break;                          case PE.OpCode.Ldlen:                              instructions.Add(new MiscInstruction(offset' MiscOp.Ldlen));                              break;                          case PE.OpCode.Ret:                              if (ctxt.ResultType == null)                                  instructions.Add(new MiscInstruction(offset' MiscOp.Ret));                              else                                  instructions.Add(new MiscInstruction(offset' MiscOp.RetVal));                              break;                          case PE.OpCode.Endfilter:                              instructions.Add(new MiscInstruction(offset' MiscOp.Endfilter));                              break;                          case PE.OpCode.Endfinally: // aka EndFault                              instructions.Add(new MiscInstruction(offset' MiscOp.Endfinally));                              break;                          case PE.OpCode.Br_s:                          case PE.OpCode.Br:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Br' false' (int)instruction.Value));                              break;                          case PE.OpCode.Brtrue_s: // aka brinst.s                          case PE.OpCode.Brtrue: // aka brinst                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Brtrue' false' (int)instruction.Value));                              break;                          case PE.OpCode.Brfalse_s: // aka brzero.s' brnull.s                          case PE.OpCode.Brfalse: // aka brzero' brnull                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Brfalse' false' (int)instruction.Value));                              break;                          case PE.OpCode.Beq:                          case PE.OpCode.Beq_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Breq' false' (int)instruction.Value));                              break;                          case PE.OpCode.Bne_un:                          case PE.OpCode.Bne_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Brne' false' (int)instruction.Value));                              break;                          case PE.OpCode.Leave:                          case PE.OpCode.Leave_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Leave' false' (int)instruction.Value));                              break;                          case PE.OpCode.Blt:                          case PE.OpCode.Blt_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrLt' false' (int)instruction.Value));                              break;                          case PE.OpCode.Blt_un:                          case PE.OpCode.Blt_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrLt' true' (int)instruction.Value));                              break;                          case PE.OpCode.Ble:                          case PE.OpCode.Ble_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrLe' false' (int)instruction.Value));                              break;                          case PE.OpCode.Ble_un:                          case PE.OpCode.Ble_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrLe' true' (int)instruction.Value));                              break;                          case PE.OpCode.Bgt:                          case PE.OpCode.Bgt_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrGt' false' (int)instruction.Value));                              break;                          case PE.OpCode.Bgt_un:                          case PE.OpCode.Bgt_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrGt' true' (int)instruction.Value));                              break;                          case PE.OpCode.Bge:                          case PE.OpCode.Bge_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrGe' false' (int)instruction.Value));                              break;                          case PE.OpCode.Bge_un:                          case PE.OpCode.Bge_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrGe' true' (int)instruction.Value));                              break;                          case PE.OpCode.Switch:                              instructions.Add(new SwitchInstruction(offset' (Seq<int>)instruction.Value));                              break;                          case PE.OpCode.Ceq:                              instructions.Add(new CompareInstruction(offset' CompareOp.Ceq' false));                              break;                          case PE.OpCode.Clt:                              instructions.Add(new CompareInstruction(offset' CompareOp.Clt' false));                              break;                          case PE.OpCode.Clt_un:                              instructions.Add(new CompareInstruction(offset' CompareOp.Clt' true));                              break;                          case PE.OpCode.Cgt:                              instructions.Add(new CompareInstruction(offset' CompareOp.Cgt' false));                              break;                          case PE.OpCode.Cgt_un:                              instructions.Add(new CompareInstruction(offset' CompareOp.Cgt' true));                              break;                          case PE.OpCode.Ldarg_0:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));                              break;                          case PE.OpCode.Ldarg_1:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));                              break;                          case PE.OpCode.Ldarg_2:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));                              break;                          case PE.OpCode.Ldarg_3:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));                              break;                          case PE.OpCode.Ldarg:                          case PE.OpCode.Ldarg_s:                              instructions.Add                                  (new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));                              break;                          case PE.OpCode.Ldarga:                          case PE.OpCode.Ldarga_s:                              instructions.Add                                  (new ArgLocalInstruction(offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));                              break;                          case PE.OpCode.Starg:                          case PE.OpCode.Starg_s:                              instructions.Add                                  (new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));                              break;                          case PE.OpCode.Ldloc_0:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Local' 0));                              break;                          case PE.OpCode.Ldloc_1:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Local' 1));                              break;                          case PE.OpCode.Ldloc_2:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Local' 2));                              break;                          case PE.OpCode.Ldloc_3:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Local' 3));                              break;                          case PE.OpCode.Ldloc:                          case PE.OpCode.Ldloc_s:                              instructions.Add                                  (new ArgLocalInstruction                                       (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));                              break;                          case PE.OpCode.Ldloca:                          case PE.OpCode.Ldloca_s:                              instructions.Add                                  (new ArgLocalInstruction                                       (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));                              break;                          case PE.OpCode.Stloc_0:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Local' 0));                              break;                          case PE.OpCode.Stloc_1:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Local' 1));                              break;                          case PE.OpCode.Stloc_2:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Local' 2));                              break;                          case PE.OpCode.Stloc_3:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Local' 3));                              break;                          case PE.OpCode.Stloc:                          case PE.OpCode.Stloc_s:                              instructions.Add                                  (new ArgLocalInstruction                                       (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));                              break;                          case PE.OpCode.Ldfld:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));                              break;                          case PE.OpCode.Ldsfld:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));                              break;                          case PE.OpCode.Ldflda:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));                              break;                          case PE.OpCode.Ldsflda:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));                              break;                          case PE.OpCode.Stfld:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));                              break;                          case PE.OpCode.Stsfld:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));                              break;                          case PE.OpCode.Ldtoken:                              {                                  if (instruction.Value is FieldRef)                                      instructions.Add                                          (new FieldInstruction                                               (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));                                  else if (instruction.Value is MethodRef)                                      instructions.Add                                          (new MethodInstruction                                               (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));                                  else if (instruction.Value is TypeRef)                                      // NOTE: May be a higher-kinded type                                      instructions.Add                                          (new TypeInstruction(offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));                                  else                                      throw new InvalidOperationException("unexpected ldtoken instruction value");                                  break;                              }                          case PE.OpCode.Constrained:                              {                                  var constrained = (TypeRef)instruction.Value;                                  if (i >= ctxt.Instructions.Length)                                      throw new InvalidOperationException("invalid instructions");                                  instruction = ctxt.Instructions[i++];                                  if (instruction.OpCode != PE.OpCode.Callvirt)                                      throw new InvalidOperationException("invalid instruction");                                  instructions.Add                                      (new MethodInstruction                                           (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));                                  break;                              }                          case PE.OpCode.Call:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Callvirt:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Ldftn:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Ldvirtftn:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Newobj:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Ldind_i1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.Int8Ref));                              break;                          case PE.OpCode.Ldind_u1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.UInt8Ref));                              break;                          case PE.OpCode.Ldind_i2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.Int16Ref));                              break;                          case PE.OpCode.Ldind_u2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.UInt16Ref));                              break;                          case PE.OpCode.Ldind_i4:                          case PE.OpCode.Ldind_u4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.Int32Ref));                              break;                          case PE.OpCode.Ldind_i8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.Int64Ref));                              break;                          case PE.OpCode.Ldind_i:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.IntNativeRef));                              break;                          case PE.OpCode.Ldind_r4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.SingleRef));                              break;                          case PE.OpCode.Ldind_r8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.DoubleRef));                              break;                          case PE.OpCode.Ldobj:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Stind_i1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.Int8Ref));                              break;                          case PE.OpCode.Stind_i2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.Int16Ref));                              break;                          case PE.OpCode.Stind_i4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.Int32Ref));                              break;                          case PE.OpCode.Stind_i8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.Int64Ref));                              break;                          case PE.OpCode.Stind_i:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.IntNativeRef));                              break;                          case PE.OpCode.Stind_r4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.SingleRef));                              break;                          case PE.OpCode.Stind_r8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.DoubleRef));                              break;                          case PE.OpCode.Stobj:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Cpobj:                              instructions.Add(new TypeInstruction(offset' TypeOp.Cpobj' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Newarr:                              instructions.Add(new TypeInstruction(offset' TypeOp.Newarr' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Initobj:                              instructions.Add(new TypeInstruction(offset' TypeOp.Initobj' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Castclass:                              instructions.Add                                  (new TypeInstruction(offset' TypeOp.Castclass' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Isinst:                              instructions.Add(new TypeInstruction(offset' TypeOp.Isinst' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Box:                              instructions.Add(new TypeInstruction(offset' TypeOp.Box' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Unbox:                              instructions.Add(new TypeInstruction(offset' TypeOp.Unbox' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Unbox_any:                              instructions.Add(new TypeInstruction(offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Ldelem_i1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.Int8Ref));                              break;                          case PE.OpCode.Ldelem_u1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.UInt8Ref));                              break;                          case PE.OpCode.Ldelem_i2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.Int16Ref));                              break;                          case PE.OpCode.Ldelem_u2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.UInt16Ref));                              break;                          case PE.OpCode.Ldelem_i4:                          case PE.OpCode.Ldelem_u4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.Int32Ref));                              break;                          case PE.OpCode.Ldelem_i:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.IntNativeRef));                              break;                          case PE.OpCode.Ldelem_i8: // aka ldelem.u8                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.Int64Ref));                              break;                          case PE.OpCode.Ldelem_r4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.SingleRef));                              break;                          case PE.OpCode.Ldelem_r8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.DoubleRef));                              break;                          case PE.OpCode.Ldelem: // aka ldelem.any                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Stelem_i1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.Int8Ref));                              break;                          case PE.OpCode.Stelem_i2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.Int16Ref));                              break;                          case PE.OpCode.Stelem_i4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.Int32Ref));                              break;                          case PE.OpCode.Stelem_i8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.Int64Ref));                              break;                          case PE.OpCode.Stelem_i:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.IntNativeRef));                              break;                          case PE.OpCode.Stelem_r4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.SingleRef));                              break;                          case PE.OpCode.Stelem_r8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.DoubleRef));                              break;                          case PE.OpCode.Stelem: // aka stelem.any                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Readonly:                              if (i >= ctxt.Instructions.Length)                                  throw new InvalidOperationException("invalid instruction");                              instruction = ctxt.Instructions[i++];                              if (instruction.OpCode != PE.OpCode.Ldelema)                                  throw new InvalidOperationException("invalid instruction");                              instructions.Add(new LdElemAddrInstruction(offset' true' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Ldelema:                              instructions.Add(new LdElemAddrInstruction(offset' false' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Ldc_i4_0:                              instructions.Add(new LdInt32Instruction(offset' 0));                              break;                          case PE.OpCode.Ldc_i4_1:                              instructions.Add(new LdInt32Instruction(offset' 1));                              break;                          case PE.OpCode.Ldc_i4_2:                              instructions.Add(new LdInt32Instruction(offset' 2));                              break;                          case PE.OpCode.Ldc_i4_3:                              instructions.Add(new LdInt32Instruction(offset' 3));                              break;                          case PE.OpCode.Ldc_i4_4:                              instructions.Add(new LdInt32Instruction(offset' 4));                              break;                          case PE.OpCode.Ldc_i4_5:                              instructions.Add(new LdInt32Instruction(offset' 5));                              break;                          case PE.OpCode.Ldc_i4_6:                              instructions.Add(new LdInt32Instruction(offset' 6));                              break;                          case PE.OpCode.Ldc_i4_7:                              instructions.Add(new LdInt32Instruction(offset' 7));                              break;                          case PE.OpCode.Ldc_i4_8:                              instructions.Add(new LdInt32Instruction(offset' 8));                              break;                          case PE.OpCode.Ldc_i4_m1:                              instructions.Add(new LdInt32Instruction(offset' -1));                              break;                          case PE.OpCode.Ldc_i4:                          case PE.OpCode.Ldc_i4_s:                              instructions.Add(new LdInt32Instruction(offset' (int)instruction.Value));                              break;                          case PE.OpCode.Ldc_i8:                              instructions.Add(new LdInt64Instruction(offset' (long)instruction.Value));                              break;                          case PE.OpCode.Ldc_r4:                              instructions.Add(new LdSingleInstruction(offset' (float)instruction.Value));                              break;                          case PE.OpCode.Ldc_r8:                              instructions.Add(new LdDoubleInstruction(offset' (double)instruction.Value));                              break;                          case PE.OpCode.Ldstr:                              instructions.Add(new LdStringInstruction(offset' (string)instruction.Value));                              break;                          case PE.OpCode.Add:                              instructions.Add(new ArithInstruction(offset' ArithOp.Add' false' false));                              break;                          case PE.OpCode.Add_ovf:                              instructions.Add(new ArithInstruction(offset' ArithOp.Add' true' false));                              break;                          case PE.OpCode.Add_ovf_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Add' true' true));                              break;                          case PE.OpCode.Sub:                              instructions.Add(new ArithInstruction(offset' ArithOp.Sub' false' false));                              break;                          case PE.OpCode.Sub_ovf:                              instructions.Add(new ArithInstruction(offset' ArithOp.Sub' true' false));                              break;                          case PE.OpCode.Sub_ovf_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Sub' true' true));                              break;                          case PE.OpCode.Mul:                              instructions.Add(new ArithInstruction(offset' ArithOp.Mul' false' false));                              break;                          case PE.OpCode.Mul_ovf:                              instructions.Add(new ArithInstruction(offset' ArithOp.Mul' true' false));                              break;                          case PE.OpCode.Mul_ovf_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Mul' true' true));                              break;                          case PE.OpCode.Div:                              instructions.Add(new ArithInstruction(offset' ArithOp.Div' false' false));                              break;                          case PE.OpCode.Div_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Div' false' true));                              break;                          case PE.OpCode.Rem:                              instructions.Add(new ArithInstruction(offset' ArithOp.Rem' false' false));                              break;                          case PE.OpCode.Rem_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Rem' false' true));                              break;                          case PE.OpCode.Neg:                              instructions.Add(new ArithInstruction(offset' ArithOp.Neg' false' false));                              break;                          case PE.OpCode.And:                              instructions.Add(new ArithInstruction(offset' ArithOp.BitAnd' false' false));                              break;                          case PE.OpCode.Or:                              instructions.Add(new ArithInstruction(offset' ArithOp.BitOr' false' false));                              break;                          case PE.OpCode.Xor:                              instructions.Add(new ArithInstruction(offset' ArithOp.BitXor' false' false));                              break;                          case PE.OpCode.Not:                              instructions.Add(new ArithInstruction(offset' ArithOp.BitNot' false' false));                              break;                          case PE.OpCode.Shl:                              instructions.Add(new ArithInstruction(offset' ArithOp.Shl' false' false));                              break;                          case PE.OpCode.Shr:                              instructions.Add(new ArithInstruction(offset' ArithOp.Shr' false' false));                              break;                          case PE.OpCode.Shr_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Shr' false' true));                              break;                          case PE.OpCode.Conv_i1:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int8' false' false));                              break;                          case PE.OpCode.Conv_u1:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt8' false' false));                              break;                          case PE.OpCode.Conv_i2:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int16' false' false));                              break;                          case PE.OpCode.Conv_u2:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt16' false' false));                              break;                          case PE.OpCode.Conv_i4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int32' false' false));                              break;                          case PE.OpCode.Conv_u4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt32' false' false));                              break;                          case PE.OpCode.Conv_i8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int64' false' false));                              break;                          case PE.OpCode.Conv_u8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt64' false' false));                              break;                          case PE.OpCode.Conv_i:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.IntNative' false' false));                              break;                          case PE.OpCode.Conv_u:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UIntNative' false' false));                              break;                          case PE.OpCode.Conv_r4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Single' false' false));                              break;                          case PE.OpCode.Conv_r8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Double' false' false));                              break;                          case PE.OpCode.Conv_r_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Double' false' true));                              break;                          case PE.OpCode.Conv_ovf_i1:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int8' true' false));                              break;                          case PE.OpCode.Conv_ovf_u1:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt8' true' false));                              break;                          case PE.OpCode.Conv_ovf_i2:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int16' true' false));                              break;                          case PE.OpCode.Conv_ovf_u2:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt16' true' false));                              break;                          case PE.OpCode.Conv_ovf_i4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int32' true' false));                              break;                          case PE.OpCode.Conv_ovf_u4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt32' true' false));                              break;                          case PE.OpCode.Conv_ovf_i8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int64' true' false));                              break;                          case PE.OpCode.Conv_ovf_u8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt64' true' false));                              break;                          case PE.OpCode.Conv_ovf_i:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.IntNative' true' false));                              break;                          case PE.OpCode.Conv_ovf_u:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UIntNative' true' false));                              break;                          case PE.OpCode.Conv_ovf_i1_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int8' true' true));                              break;                          case PE.OpCode.Conv_ovf_u1_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt8' true' true));                              break;                          case PE.OpCode.Conv_ovf_i2_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int16' true' true));                              break;                          case PE.OpCode.Conv_ovf_u2_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt16' true' true));                              break;                          case PE.OpCode.Conv_ovf_i4_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int32' true' true));                              break;                          case PE.OpCode.Conv_ovf_u4_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt32' true' true));                              break;                          case PE.OpCode.Conv_ovf_i8_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int64' true' true));                              break;                          case PE.OpCode.Conv_ovf_u8_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt64' true' true));                              break;                          case PE.OpCode.Conv_ovf_i_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.IntNative' true' true));                              break;                          case PE.OpCode.Conv_ovf_u_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UIntNative' true' true));                              break;                          default:                              throw new InvalidOperationException("invalid instruction");                            }                      }                  }              }
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: while (!ctxt.AtEnd(i))              {                  var j = i > ctxt.Start ? ctxt.JumpOverHandlers(i) : i;                  if (j > i)                      i = j;                  else                  {                      var ehcs = ctxt.OutermostTryBlocks(i);                      if (ehcs != null)                      {                          // A try instruction begins here with given handlers                          var offset = ctxt.Instructions[i].Offset;                          var tryCtxt = new TryTranslationContext(ctxt' i' ehcs);                          var tryBlock = InstructionsFromContext(tryCtxt);                            var handlers = new Seq<TryInstructionHandler>();                          foreach (var ehc in ehcs)                          {                              var handlerCtxt = new HandlerTranslationContext                                  (tryCtxt' ctxt.OffsetToIndex[ehc.HandlerOffset]' ehc);                              var handlerBlock = InstructionsFromContext(handlerCtxt);                              switch (ehc.Flags)                              {                              case PE.CorILExceptionClause.Exception:                                  handlers.Add(new CatchTryInstructionHandler((TypeRef)ehc.Class' handlerBlock));                                  break;                              case PE.CorILExceptionClause.Filter:                                  {                                      var filterCtxt = new FilterTranslationContext                                          (tryCtxt' ctxt.OffsetToIndex[ehc.FilterOffset]' ehc);                                      var filterBlock = InstructionsFromContext(filterCtxt);                                      handlers.Add(new FilterTryInstructionHandler(filterBlock' handlerBlock));                                      break;                                  }                              case PE.CorILExceptionClause.Finally:                                  handlers.Add(new FinallyTryInstructionHandler(handlerBlock));                                  break;                              case PE.CorILExceptionClause.Fault:                                  handlers.Add(new FaultTryInstructionHandler(handlerBlock));                                  break;                              default:                                  throw new ArgumentOutOfRangeException();                              }                          }                          instructions.Add(new TryInstruction(offset' tryBlock' handlers));                            // Jump over try block                          var nextOffset = ehcs[0].TryOffset + ehcs[0].TryLength;                          if (!ctxt.OffsetToIndex.TryGetValue(nextOffset' out i))                              i = ctxt.Instructions.Length;                      }                      else                      {                          var instruction = ctxt.Instructions[i++];                          var offset = instruction.Offset;                            while (instruction.OpCode == PE.OpCode.Unaligned || instruction.OpCode == PE.OpCode.Volatile ||                                 instruction.OpCode == PE.OpCode.Tailcall)                          {                              // Skip over any ignored prefixes' but remember instruction begins at original offset                              // NOTE: What ever happened to the "no." prefix mentioned in the spec?                              if (i >= ctxt.Instructions.Length)                                  throw new InvalidOperationException("invalid instructions");                              instruction = ctxt.Instructions[i++];                          }                          switch (instruction.OpCode)                          {                          case PE.OpCode.Cpblk:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Cpblk));                              break;                          case PE.OpCode.Initblk:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Initblk));                              break;                          case PE.OpCode.Arglist:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Arglist));                              break;                          case PE.OpCode.Localloc:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Localloc));                              break;                          case PE.OpCode.Jmp:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Jmp));                              break;                          case PE.OpCode.Calli:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Calli));                              break;                          case PE.OpCode.Sizeof:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Sizeof));                              break;                          case PE.OpCode.Mkrefany:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Mkrefany));                              break;                          case PE.OpCode.Refanytype:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Refanytype));                              break;                          case PE.OpCode.Refanyval:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Refanyval));                              break;                          case PE.OpCode.Nop:                              instructions.Add(new MiscInstruction(offset' MiscOp.Nop));                              break;                          case PE.OpCode.Break:                              instructions.Add(new MiscInstruction(offset' MiscOp.Break));                              break;                          case PE.OpCode.Dup:                              instructions.Add(new MiscInstruction(offset' MiscOp.Dup));                              break;                          case PE.OpCode.Pop:                              instructions.Add(new MiscInstruction(offset' MiscOp.Pop));                              break;                          case PE.OpCode.Ldnull:                              instructions.Add(new MiscInstruction(offset' MiscOp.Ldnull));                              break;                          case PE.OpCode.Ckfinite:                              instructions.Add(new MiscInstruction(offset' MiscOp.Ckfinite));                              break;                          case PE.OpCode.Throw:                              instructions.Add(new MiscInstruction(offset' MiscOp.Throw));                              break;                          case PE.OpCode.Rethrow:                              instructions.Add(new MiscInstruction(offset' MiscOp.Rethrow));                              break;                          case PE.OpCode.Ldind_ref:                              instructions.Add(new MiscInstruction(offset' MiscOp.LdindRef));                              break;                          case PE.OpCode.Stind_ref:                              instructions.Add(new MiscInstruction(offset' MiscOp.StindRef));                              break;                          case PE.OpCode.Ldelem_ref:                              instructions.Add(new MiscInstruction(offset' MiscOp.LdelemRef));                              break;                          case PE.OpCode.Stelem_ref:                              instructions.Add(new MiscInstruction(offset' MiscOp.StelemRef));                              break;                          case PE.OpCode.Ldlen:                              instructions.Add(new MiscInstruction(offset' MiscOp.Ldlen));                              break;                          case PE.OpCode.Ret:                              if (ctxt.ResultType == null)                                  instructions.Add(new MiscInstruction(offset' MiscOp.Ret));                              else                                  instructions.Add(new MiscInstruction(offset' MiscOp.RetVal));                              break;                          case PE.OpCode.Endfilter:                              instructions.Add(new MiscInstruction(offset' MiscOp.Endfilter));                              break;                          case PE.OpCode.Endfinally: // aka EndFault                              instructions.Add(new MiscInstruction(offset' MiscOp.Endfinally));                              break;                          case PE.OpCode.Br_s:                          case PE.OpCode.Br:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Br' false' (int)instruction.Value));                              break;                          case PE.OpCode.Brtrue_s: // aka brinst.s                          case PE.OpCode.Brtrue: // aka brinst                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Brtrue' false' (int)instruction.Value));                              break;                          case PE.OpCode.Brfalse_s: // aka brzero.s' brnull.s                          case PE.OpCode.Brfalse: // aka brzero' brnull                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Brfalse' false' (int)instruction.Value));                              break;                          case PE.OpCode.Beq:                          case PE.OpCode.Beq_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Breq' false' (int)instruction.Value));                              break;                          case PE.OpCode.Bne_un:                          case PE.OpCode.Bne_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Brne' false' (int)instruction.Value));                              break;                          case PE.OpCode.Leave:                          case PE.OpCode.Leave_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Leave' false' (int)instruction.Value));                              break;                          case PE.OpCode.Blt:                          case PE.OpCode.Blt_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrLt' false' (int)instruction.Value));                              break;                          case PE.OpCode.Blt_un:                          case PE.OpCode.Blt_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrLt' true' (int)instruction.Value));                              break;                          case PE.OpCode.Ble:                          case PE.OpCode.Ble_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrLe' false' (int)instruction.Value));                              break;                          case PE.OpCode.Ble_un:                          case PE.OpCode.Ble_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrLe' true' (int)instruction.Value));                              break;                          case PE.OpCode.Bgt:                          case PE.OpCode.Bgt_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrGt' false' (int)instruction.Value));                              break;                          case PE.OpCode.Bgt_un:                          case PE.OpCode.Bgt_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrGt' true' (int)instruction.Value));                              break;                          case PE.OpCode.Bge:                          case PE.OpCode.Bge_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrGe' false' (int)instruction.Value));                              break;                          case PE.OpCode.Bge_un:                          case PE.OpCode.Bge_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrGe' true' (int)instruction.Value));                              break;                          case PE.OpCode.Switch:                              instructions.Add(new SwitchInstruction(offset' (Seq<int>)instruction.Value));                              break;                          case PE.OpCode.Ceq:                              instructions.Add(new CompareInstruction(offset' CompareOp.Ceq' false));                              break;                          case PE.OpCode.Clt:                              instructions.Add(new CompareInstruction(offset' CompareOp.Clt' false));                              break;                          case PE.OpCode.Clt_un:                              instructions.Add(new CompareInstruction(offset' CompareOp.Clt' true));                              break;                          case PE.OpCode.Cgt:                              instructions.Add(new CompareInstruction(offset' CompareOp.Cgt' false));                              break;                          case PE.OpCode.Cgt_un:                              instructions.Add(new CompareInstruction(offset' CompareOp.Cgt' true));                              break;                          case PE.OpCode.Ldarg_0:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));                              break;                          case PE.OpCode.Ldarg_1:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));                              break;                          case PE.OpCode.Ldarg_2:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));                              break;                          case PE.OpCode.Ldarg_3:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));                              break;                          case PE.OpCode.Ldarg:                          case PE.OpCode.Ldarg_s:                              instructions.Add                                  (new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));                              break;                          case PE.OpCode.Ldarga:                          case PE.OpCode.Ldarga_s:                              instructions.Add                                  (new ArgLocalInstruction(offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));                              break;                          case PE.OpCode.Starg:                          case PE.OpCode.Starg_s:                              instructions.Add                                  (new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));                              break;                          case PE.OpCode.Ldloc_0:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Local' 0));                              break;                          case PE.OpCode.Ldloc_1:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Local' 1));                              break;                          case PE.OpCode.Ldloc_2:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Local' 2));                              break;                          case PE.OpCode.Ldloc_3:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Local' 3));                              break;                          case PE.OpCode.Ldloc:                          case PE.OpCode.Ldloc_s:                              instructions.Add                                  (new ArgLocalInstruction                                       (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));                              break;                          case PE.OpCode.Ldloca:                          case PE.OpCode.Ldloca_s:                              instructions.Add                                  (new ArgLocalInstruction                                       (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));                              break;                          case PE.OpCode.Stloc_0:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Local' 0));                              break;                          case PE.OpCode.Stloc_1:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Local' 1));                              break;                          case PE.OpCode.Stloc_2:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Local' 2));                              break;                          case PE.OpCode.Stloc_3:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Local' 3));                              break;                          case PE.OpCode.Stloc:                          case PE.OpCode.Stloc_s:                              instructions.Add                                  (new ArgLocalInstruction                                       (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));                              break;                          case PE.OpCode.Ldfld:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));                              break;                          case PE.OpCode.Ldsfld:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));                              break;                          case PE.OpCode.Ldflda:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));                              break;                          case PE.OpCode.Ldsflda:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));                              break;                          case PE.OpCode.Stfld:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));                              break;                          case PE.OpCode.Stsfld:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));                              break;                          case PE.OpCode.Ldtoken:                              {                                  if (instruction.Value is FieldRef)                                      instructions.Add                                          (new FieldInstruction                                               (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));                                  else if (instruction.Value is MethodRef)                                      instructions.Add                                          (new MethodInstruction                                               (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));                                  else if (instruction.Value is TypeRef)                                      // NOTE: May be a higher-kinded type                                      instructions.Add                                          (new TypeInstruction(offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));                                  else                                      throw new InvalidOperationException("unexpected ldtoken instruction value");                                  break;                              }                          case PE.OpCode.Constrained:                              {                                  var constrained = (TypeRef)instruction.Value;                                  if (i >= ctxt.Instructions.Length)                                      throw new InvalidOperationException("invalid instructions");                                  instruction = ctxt.Instructions[i++];                                  if (instruction.OpCode != PE.OpCode.Callvirt)                                      throw new InvalidOperationException("invalid instruction");                                  instructions.Add                                      (new MethodInstruction                                           (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));                                  break;                              }                          case PE.OpCode.Call:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Callvirt:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Ldftn:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Ldvirtftn:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Newobj:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Ldind_i1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.Int8Ref));                              break;                          case PE.OpCode.Ldind_u1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.UInt8Ref));                              break;                          case PE.OpCode.Ldind_i2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.Int16Ref));                              break;                          case PE.OpCode.Ldind_u2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.UInt16Ref));                              break;                          case PE.OpCode.Ldind_i4:                          case PE.OpCode.Ldind_u4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.Int32Ref));                              break;                          case PE.OpCode.Ldind_i8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.Int64Ref));                              break;                          case PE.OpCode.Ldind_i:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.IntNativeRef));                              break;                          case PE.OpCode.Ldind_r4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.SingleRef));                              break;                          case PE.OpCode.Ldind_r8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.DoubleRef));                              break;                          case PE.OpCode.Ldobj:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Stind_i1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.Int8Ref));                              break;                          case PE.OpCode.Stind_i2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.Int16Ref));                              break;                          case PE.OpCode.Stind_i4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.Int32Ref));                              break;                          case PE.OpCode.Stind_i8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.Int64Ref));                              break;                          case PE.OpCode.Stind_i:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.IntNativeRef));                              break;                          case PE.OpCode.Stind_r4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.SingleRef));                              break;                          case PE.OpCode.Stind_r8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.DoubleRef));                              break;                          case PE.OpCode.Stobj:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Cpobj:                              instructions.Add(new TypeInstruction(offset' TypeOp.Cpobj' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Newarr:                              instructions.Add(new TypeInstruction(offset' TypeOp.Newarr' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Initobj:                              instructions.Add(new TypeInstruction(offset' TypeOp.Initobj' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Castclass:                              instructions.Add                                  (new TypeInstruction(offset' TypeOp.Castclass' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Isinst:                              instructions.Add(new TypeInstruction(offset' TypeOp.Isinst' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Box:                              instructions.Add(new TypeInstruction(offset' TypeOp.Box' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Unbox:                              instructions.Add(new TypeInstruction(offset' TypeOp.Unbox' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Unbox_any:                              instructions.Add(new TypeInstruction(offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Ldelem_i1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.Int8Ref));                              break;                          case PE.OpCode.Ldelem_u1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.UInt8Ref));                              break;                          case PE.OpCode.Ldelem_i2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.Int16Ref));                              break;                          case PE.OpCode.Ldelem_u2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.UInt16Ref));                              break;                          case PE.OpCode.Ldelem_i4:                          case PE.OpCode.Ldelem_u4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.Int32Ref));                              break;                          case PE.OpCode.Ldelem_i:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.IntNativeRef));                              break;                          case PE.OpCode.Ldelem_i8: // aka ldelem.u8                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.Int64Ref));                              break;                          case PE.OpCode.Ldelem_r4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.SingleRef));                              break;                          case PE.OpCode.Ldelem_r8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.DoubleRef));                              break;                          case PE.OpCode.Ldelem: // aka ldelem.any                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Stelem_i1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.Int8Ref));                              break;                          case PE.OpCode.Stelem_i2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.Int16Ref));                              break;                          case PE.OpCode.Stelem_i4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.Int32Ref));                              break;                          case PE.OpCode.Stelem_i8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.Int64Ref));                              break;                          case PE.OpCode.Stelem_i:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.IntNativeRef));                              break;                          case PE.OpCode.Stelem_r4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.SingleRef));                              break;                          case PE.OpCode.Stelem_r8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.DoubleRef));                              break;                          case PE.OpCode.Stelem: // aka stelem.any                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Readonly:                              if (i >= ctxt.Instructions.Length)                                  throw new InvalidOperationException("invalid instruction");                              instruction = ctxt.Instructions[i++];                              if (instruction.OpCode != PE.OpCode.Ldelema)                                  throw new InvalidOperationException("invalid instruction");                              instructions.Add(new LdElemAddrInstruction(offset' true' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Ldelema:                              instructions.Add(new LdElemAddrInstruction(offset' false' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Ldc_i4_0:                              instructions.Add(new LdInt32Instruction(offset' 0));                              break;                          case PE.OpCode.Ldc_i4_1:                              instructions.Add(new LdInt32Instruction(offset' 1));                              break;                          case PE.OpCode.Ldc_i4_2:                              instructions.Add(new LdInt32Instruction(offset' 2));                              break;                          case PE.OpCode.Ldc_i4_3:                              instructions.Add(new LdInt32Instruction(offset' 3));                              break;                          case PE.OpCode.Ldc_i4_4:                              instructions.Add(new LdInt32Instruction(offset' 4));                              break;                          case PE.OpCode.Ldc_i4_5:                              instructions.Add(new LdInt32Instruction(offset' 5));                              break;                          case PE.OpCode.Ldc_i4_6:                              instructions.Add(new LdInt32Instruction(offset' 6));                              break;                          case PE.OpCode.Ldc_i4_7:                              instructions.Add(new LdInt32Instruction(offset' 7));                              break;                          case PE.OpCode.Ldc_i4_8:                              instructions.Add(new LdInt32Instruction(offset' 8));                              break;                          case PE.OpCode.Ldc_i4_m1:                              instructions.Add(new LdInt32Instruction(offset' -1));                              break;                          case PE.OpCode.Ldc_i4:                          case PE.OpCode.Ldc_i4_s:                              instructions.Add(new LdInt32Instruction(offset' (int)instruction.Value));                              break;                          case PE.OpCode.Ldc_i8:                              instructions.Add(new LdInt64Instruction(offset' (long)instruction.Value));                              break;                          case PE.OpCode.Ldc_r4:                              instructions.Add(new LdSingleInstruction(offset' (float)instruction.Value));                              break;                          case PE.OpCode.Ldc_r8:                              instructions.Add(new LdDoubleInstruction(offset' (double)instruction.Value));                              break;                          case PE.OpCode.Ldstr:                              instructions.Add(new LdStringInstruction(offset' (string)instruction.Value));                              break;                          case PE.OpCode.Add:                              instructions.Add(new ArithInstruction(offset' ArithOp.Add' false' false));                              break;                          case PE.OpCode.Add_ovf:                              instructions.Add(new ArithInstruction(offset' ArithOp.Add' true' false));                              break;                          case PE.OpCode.Add_ovf_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Add' true' true));                              break;                          case PE.OpCode.Sub:                              instructions.Add(new ArithInstruction(offset' ArithOp.Sub' false' false));                              break;                          case PE.OpCode.Sub_ovf:                              instructions.Add(new ArithInstruction(offset' ArithOp.Sub' true' false));                              break;                          case PE.OpCode.Sub_ovf_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Sub' true' true));                              break;                          case PE.OpCode.Mul:                              instructions.Add(new ArithInstruction(offset' ArithOp.Mul' false' false));                              break;                          case PE.OpCode.Mul_ovf:                              instructions.Add(new ArithInstruction(offset' ArithOp.Mul' true' false));                              break;                          case PE.OpCode.Mul_ovf_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Mul' true' true));                              break;                          case PE.OpCode.Div:                              instructions.Add(new ArithInstruction(offset' ArithOp.Div' false' false));                              break;                          case PE.OpCode.Div_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Div' false' true));                              break;                          case PE.OpCode.Rem:                              instructions.Add(new ArithInstruction(offset' ArithOp.Rem' false' false));                              break;                          case PE.OpCode.Rem_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Rem' false' true));                              break;                          case PE.OpCode.Neg:                              instructions.Add(new ArithInstruction(offset' ArithOp.Neg' false' false));                              break;                          case PE.OpCode.And:                              instructions.Add(new ArithInstruction(offset' ArithOp.BitAnd' false' false));                              break;                          case PE.OpCode.Or:                              instructions.Add(new ArithInstruction(offset' ArithOp.BitOr' false' false));                              break;                          case PE.OpCode.Xor:                              instructions.Add(new ArithInstruction(offset' ArithOp.BitXor' false' false));                              break;                          case PE.OpCode.Not:                              instructions.Add(new ArithInstruction(offset' ArithOp.BitNot' false' false));                              break;                          case PE.OpCode.Shl:                              instructions.Add(new ArithInstruction(offset' ArithOp.Shl' false' false));                              break;                          case PE.OpCode.Shr:                              instructions.Add(new ArithInstruction(offset' ArithOp.Shr' false' false));                              break;                          case PE.OpCode.Shr_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Shr' false' true));                              break;                          case PE.OpCode.Conv_i1:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int8' false' false));                              break;                          case PE.OpCode.Conv_u1:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt8' false' false));                              break;                          case PE.OpCode.Conv_i2:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int16' false' false));                              break;                          case PE.OpCode.Conv_u2:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt16' false' false));                              break;                          case PE.OpCode.Conv_i4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int32' false' false));                              break;                          case PE.OpCode.Conv_u4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt32' false' false));                              break;                          case PE.OpCode.Conv_i8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int64' false' false));                              break;                          case PE.OpCode.Conv_u8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt64' false' false));                              break;                          case PE.OpCode.Conv_i:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.IntNative' false' false));                              break;                          case PE.OpCode.Conv_u:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UIntNative' false' false));                              break;                          case PE.OpCode.Conv_r4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Single' false' false));                              break;                          case PE.OpCode.Conv_r8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Double' false' false));                              break;                          case PE.OpCode.Conv_r_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Double' false' true));                              break;                          case PE.OpCode.Conv_ovf_i1:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int8' true' false));                              break;                          case PE.OpCode.Conv_ovf_u1:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt8' true' false));                              break;                          case PE.OpCode.Conv_ovf_i2:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int16' true' false));                              break;                          case PE.OpCode.Conv_ovf_u2:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt16' true' false));                              break;                          case PE.OpCode.Conv_ovf_i4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int32' true' false));                              break;                          case PE.OpCode.Conv_ovf_u4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt32' true' false));                              break;                          case PE.OpCode.Conv_ovf_i8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int64' true' false));                              break;                          case PE.OpCode.Conv_ovf_u8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt64' true' false));                              break;                          case PE.OpCode.Conv_ovf_i:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.IntNative' true' false));                              break;                          case PE.OpCode.Conv_ovf_u:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UIntNative' true' false));                              break;                          case PE.OpCode.Conv_ovf_i1_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int8' true' true));                              break;                          case PE.OpCode.Conv_ovf_u1_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt8' true' true));                              break;                          case PE.OpCode.Conv_ovf_i2_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int16' true' true));                              break;                          case PE.OpCode.Conv_ovf_u2_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt16' true' true));                              break;                          case PE.OpCode.Conv_ovf_i4_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int32' true' true));                              break;                          case PE.OpCode.Conv_ovf_u4_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt32' true' true));                              break;                          case PE.OpCode.Conv_ovf_i8_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int64' true' true));                              break;                          case PE.OpCode.Conv_ovf_u8_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt64' true' true));                              break;                          case PE.OpCode.Conv_ovf_i_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.IntNative' true' true));                              break;                          case PE.OpCode.Conv_ovf_u_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UIntNative' true' true));                              break;                          default:                              throw new InvalidOperationException("invalid instruction");                            }                      }                  }              }
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: while (!ctxt.AtEnd(i))              {                  var j = i > ctxt.Start ? ctxt.JumpOverHandlers(i) : i;                  if (j > i)                      i = j;                  else                  {                      var ehcs = ctxt.OutermostTryBlocks(i);                      if (ehcs != null)                      {                          // A try instruction begins here with given handlers                          var offset = ctxt.Instructions[i].Offset;                          var tryCtxt = new TryTranslationContext(ctxt' i' ehcs);                          var tryBlock = InstructionsFromContext(tryCtxt);                            var handlers = new Seq<TryInstructionHandler>();                          foreach (var ehc in ehcs)                          {                              var handlerCtxt = new HandlerTranslationContext                                  (tryCtxt' ctxt.OffsetToIndex[ehc.HandlerOffset]' ehc);                              var handlerBlock = InstructionsFromContext(handlerCtxt);                              switch (ehc.Flags)                              {                              case PE.CorILExceptionClause.Exception:                                  handlers.Add(new CatchTryInstructionHandler((TypeRef)ehc.Class' handlerBlock));                                  break;                              case PE.CorILExceptionClause.Filter:                                  {                                      var filterCtxt = new FilterTranslationContext                                          (tryCtxt' ctxt.OffsetToIndex[ehc.FilterOffset]' ehc);                                      var filterBlock = InstructionsFromContext(filterCtxt);                                      handlers.Add(new FilterTryInstructionHandler(filterBlock' handlerBlock));                                      break;                                  }                              case PE.CorILExceptionClause.Finally:                                  handlers.Add(new FinallyTryInstructionHandler(handlerBlock));                                  break;                              case PE.CorILExceptionClause.Fault:                                  handlers.Add(new FaultTryInstructionHandler(handlerBlock));                                  break;                              default:                                  throw new ArgumentOutOfRangeException();                              }                          }                          instructions.Add(new TryInstruction(offset' tryBlock' handlers));                            // Jump over try block                          var nextOffset = ehcs[0].TryOffset + ehcs[0].TryLength;                          if (!ctxt.OffsetToIndex.TryGetValue(nextOffset' out i))                              i = ctxt.Instructions.Length;                      }                      else                      {                          var instruction = ctxt.Instructions[i++];                          var offset = instruction.Offset;                            while (instruction.OpCode == PE.OpCode.Unaligned || instruction.OpCode == PE.OpCode.Volatile ||                                 instruction.OpCode == PE.OpCode.Tailcall)                          {                              // Skip over any ignored prefixes' but remember instruction begins at original offset                              // NOTE: What ever happened to the "no." prefix mentioned in the spec?                              if (i >= ctxt.Instructions.Length)                                  throw new InvalidOperationException("invalid instructions");                              instruction = ctxt.Instructions[i++];                          }                          switch (instruction.OpCode)                          {                          case PE.OpCode.Cpblk:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Cpblk));                              break;                          case PE.OpCode.Initblk:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Initblk));                              break;                          case PE.OpCode.Arglist:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Arglist));                              break;                          case PE.OpCode.Localloc:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Localloc));                              break;                          case PE.OpCode.Jmp:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Jmp));                              break;                          case PE.OpCode.Calli:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Calli));                              break;                          case PE.OpCode.Sizeof:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Sizeof));                              break;                          case PE.OpCode.Mkrefany:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Mkrefany));                              break;                          case PE.OpCode.Refanytype:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Refanytype));                              break;                          case PE.OpCode.Refanyval:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Refanyval));                              break;                          case PE.OpCode.Nop:                              instructions.Add(new MiscInstruction(offset' MiscOp.Nop));                              break;                          case PE.OpCode.Break:                              instructions.Add(new MiscInstruction(offset' MiscOp.Break));                              break;                          case PE.OpCode.Dup:                              instructions.Add(new MiscInstruction(offset' MiscOp.Dup));                              break;                          case PE.OpCode.Pop:                              instructions.Add(new MiscInstruction(offset' MiscOp.Pop));                              break;                          case PE.OpCode.Ldnull:                              instructions.Add(new MiscInstruction(offset' MiscOp.Ldnull));                              break;                          case PE.OpCode.Ckfinite:                              instructions.Add(new MiscInstruction(offset' MiscOp.Ckfinite));                              break;                          case PE.OpCode.Throw:                              instructions.Add(new MiscInstruction(offset' MiscOp.Throw));                              break;                          case PE.OpCode.Rethrow:                              instructions.Add(new MiscInstruction(offset' MiscOp.Rethrow));                              break;                          case PE.OpCode.Ldind_ref:                              instructions.Add(new MiscInstruction(offset' MiscOp.LdindRef));                              break;                          case PE.OpCode.Stind_ref:                              instructions.Add(new MiscInstruction(offset' MiscOp.StindRef));                              break;                          case PE.OpCode.Ldelem_ref:                              instructions.Add(new MiscInstruction(offset' MiscOp.LdelemRef));                              break;                          case PE.OpCode.Stelem_ref:                              instructions.Add(new MiscInstruction(offset' MiscOp.StelemRef));                              break;                          case PE.OpCode.Ldlen:                              instructions.Add(new MiscInstruction(offset' MiscOp.Ldlen));                              break;                          case PE.OpCode.Ret:                              if (ctxt.ResultType == null)                                  instructions.Add(new MiscInstruction(offset' MiscOp.Ret));                              else                                  instructions.Add(new MiscInstruction(offset' MiscOp.RetVal));                              break;                          case PE.OpCode.Endfilter:                              instructions.Add(new MiscInstruction(offset' MiscOp.Endfilter));                              break;                          case PE.OpCode.Endfinally: // aka EndFault                              instructions.Add(new MiscInstruction(offset' MiscOp.Endfinally));                              break;                          case PE.OpCode.Br_s:                          case PE.OpCode.Br:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Br' false' (int)instruction.Value));                              break;                          case PE.OpCode.Brtrue_s: // aka brinst.s                          case PE.OpCode.Brtrue: // aka brinst                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Brtrue' false' (int)instruction.Value));                              break;                          case PE.OpCode.Brfalse_s: // aka brzero.s' brnull.s                          case PE.OpCode.Brfalse: // aka brzero' brnull                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Brfalse' false' (int)instruction.Value));                              break;                          case PE.OpCode.Beq:                          case PE.OpCode.Beq_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Breq' false' (int)instruction.Value));                              break;                          case PE.OpCode.Bne_un:                          case PE.OpCode.Bne_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Brne' false' (int)instruction.Value));                              break;                          case PE.OpCode.Leave:                          case PE.OpCode.Leave_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Leave' false' (int)instruction.Value));                              break;                          case PE.OpCode.Blt:                          case PE.OpCode.Blt_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrLt' false' (int)instruction.Value));                              break;                          case PE.OpCode.Blt_un:                          case PE.OpCode.Blt_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrLt' true' (int)instruction.Value));                              break;                          case PE.OpCode.Ble:                          case PE.OpCode.Ble_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrLe' false' (int)instruction.Value));                              break;                          case PE.OpCode.Ble_un:                          case PE.OpCode.Ble_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrLe' true' (int)instruction.Value));                              break;                          case PE.OpCode.Bgt:                          case PE.OpCode.Bgt_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrGt' false' (int)instruction.Value));                              break;                          case PE.OpCode.Bgt_un:                          case PE.OpCode.Bgt_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrGt' true' (int)instruction.Value));                              break;                          case PE.OpCode.Bge:                          case PE.OpCode.Bge_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrGe' false' (int)instruction.Value));                              break;                          case PE.OpCode.Bge_un:                          case PE.OpCode.Bge_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrGe' true' (int)instruction.Value));                              break;                          case PE.OpCode.Switch:                              instructions.Add(new SwitchInstruction(offset' (Seq<int>)instruction.Value));                              break;                          case PE.OpCode.Ceq:                              instructions.Add(new CompareInstruction(offset' CompareOp.Ceq' false));                              break;                          case PE.OpCode.Clt:                              instructions.Add(new CompareInstruction(offset' CompareOp.Clt' false));                              break;                          case PE.OpCode.Clt_un:                              instructions.Add(new CompareInstruction(offset' CompareOp.Clt' true));                              break;                          case PE.OpCode.Cgt:                              instructions.Add(new CompareInstruction(offset' CompareOp.Cgt' false));                              break;                          case PE.OpCode.Cgt_un:                              instructions.Add(new CompareInstruction(offset' CompareOp.Cgt' true));                              break;                          case PE.OpCode.Ldarg_0:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));                              break;                          case PE.OpCode.Ldarg_1:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));                              break;                          case PE.OpCode.Ldarg_2:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));                              break;                          case PE.OpCode.Ldarg_3:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));                              break;                          case PE.OpCode.Ldarg:                          case PE.OpCode.Ldarg_s:                              instructions.Add                                  (new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));                              break;                          case PE.OpCode.Ldarga:                          case PE.OpCode.Ldarga_s:                              instructions.Add                                  (new ArgLocalInstruction(offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));                              break;                          case PE.OpCode.Starg:                          case PE.OpCode.Starg_s:                              instructions.Add                                  (new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));                              break;                          case PE.OpCode.Ldloc_0:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Local' 0));                              break;                          case PE.OpCode.Ldloc_1:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Local' 1));                              break;                          case PE.OpCode.Ldloc_2:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Local' 2));                              break;                          case PE.OpCode.Ldloc_3:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Local' 3));                              break;                          case PE.OpCode.Ldloc:                          case PE.OpCode.Ldloc_s:                              instructions.Add                                  (new ArgLocalInstruction                                       (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));                              break;                          case PE.OpCode.Ldloca:                          case PE.OpCode.Ldloca_s:                              instructions.Add                                  (new ArgLocalInstruction                                       (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));                              break;                          case PE.OpCode.Stloc_0:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Local' 0));                              break;                          case PE.OpCode.Stloc_1:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Local' 1));                              break;                          case PE.OpCode.Stloc_2:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Local' 2));                              break;                          case PE.OpCode.Stloc_3:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Local' 3));                              break;                          case PE.OpCode.Stloc:                          case PE.OpCode.Stloc_s:                              instructions.Add                                  (new ArgLocalInstruction                                       (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));                              break;                          case PE.OpCode.Ldfld:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));                              break;                          case PE.OpCode.Ldsfld:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));                              break;                          case PE.OpCode.Ldflda:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));                              break;                          case PE.OpCode.Ldsflda:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));                              break;                          case PE.OpCode.Stfld:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));                              break;                          case PE.OpCode.Stsfld:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));                              break;                          case PE.OpCode.Ldtoken:                              {                                  if (instruction.Value is FieldRef)                                      instructions.Add                                          (new FieldInstruction                                               (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));                                  else if (instruction.Value is MethodRef)                                      instructions.Add                                          (new MethodInstruction                                               (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));                                  else if (instruction.Value is TypeRef)                                      // NOTE: May be a higher-kinded type                                      instructions.Add                                          (new TypeInstruction(offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));                                  else                                      throw new InvalidOperationException("unexpected ldtoken instruction value");                                  break;                              }                          case PE.OpCode.Constrained:                              {                                  var constrained = (TypeRef)instruction.Value;                                  if (i >= ctxt.Instructions.Length)                                      throw new InvalidOperationException("invalid instructions");                                  instruction = ctxt.Instructions[i++];                                  if (instruction.OpCode != PE.OpCode.Callvirt)                                      throw new InvalidOperationException("invalid instruction");                                  instructions.Add                                      (new MethodInstruction                                           (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));                                  break;                              }                          case PE.OpCode.Call:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Callvirt:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Ldftn:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Ldvirtftn:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Newobj:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Ldind_i1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.Int8Ref));                              break;                          case PE.OpCode.Ldind_u1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.UInt8Ref));                              break;                          case PE.OpCode.Ldind_i2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.Int16Ref));                              break;                          case PE.OpCode.Ldind_u2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.UInt16Ref));                              break;                          case PE.OpCode.Ldind_i4:                          case PE.OpCode.Ldind_u4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.Int32Ref));                              break;                          case PE.OpCode.Ldind_i8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.Int64Ref));                              break;                          case PE.OpCode.Ldind_i:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.IntNativeRef));                              break;                          case PE.OpCode.Ldind_r4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.SingleRef));                              break;                          case PE.OpCode.Ldind_r8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.DoubleRef));                              break;                          case PE.OpCode.Ldobj:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Stind_i1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.Int8Ref));                              break;                          case PE.OpCode.Stind_i2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.Int16Ref));                              break;                          case PE.OpCode.Stind_i4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.Int32Ref));                              break;                          case PE.OpCode.Stind_i8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.Int64Ref));                              break;                          case PE.OpCode.Stind_i:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.IntNativeRef));                              break;                          case PE.OpCode.Stind_r4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.SingleRef));                              break;                          case PE.OpCode.Stind_r8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.DoubleRef));                              break;                          case PE.OpCode.Stobj:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Cpobj:                              instructions.Add(new TypeInstruction(offset' TypeOp.Cpobj' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Newarr:                              instructions.Add(new TypeInstruction(offset' TypeOp.Newarr' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Initobj:                              instructions.Add(new TypeInstruction(offset' TypeOp.Initobj' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Castclass:                              instructions.Add                                  (new TypeInstruction(offset' TypeOp.Castclass' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Isinst:                              instructions.Add(new TypeInstruction(offset' TypeOp.Isinst' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Box:                              instructions.Add(new TypeInstruction(offset' TypeOp.Box' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Unbox:                              instructions.Add(new TypeInstruction(offset' TypeOp.Unbox' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Unbox_any:                              instructions.Add(new TypeInstruction(offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Ldelem_i1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.Int8Ref));                              break;                          case PE.OpCode.Ldelem_u1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.UInt8Ref));                              break;                          case PE.OpCode.Ldelem_i2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.Int16Ref));                              break;                          case PE.OpCode.Ldelem_u2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.UInt16Ref));                              break;                          case PE.OpCode.Ldelem_i4:                          case PE.OpCode.Ldelem_u4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.Int32Ref));                              break;                          case PE.OpCode.Ldelem_i:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.IntNativeRef));                              break;                          case PE.OpCode.Ldelem_i8: // aka ldelem.u8                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.Int64Ref));                              break;                          case PE.OpCode.Ldelem_r4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.SingleRef));                              break;                          case PE.OpCode.Ldelem_r8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.DoubleRef));                              break;                          case PE.OpCode.Ldelem: // aka ldelem.any                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Stelem_i1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.Int8Ref));                              break;                          case PE.OpCode.Stelem_i2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.Int16Ref));                              break;                          case PE.OpCode.Stelem_i4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.Int32Ref));                              break;                          case PE.OpCode.Stelem_i8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.Int64Ref));                              break;                          case PE.OpCode.Stelem_i:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.IntNativeRef));                              break;                          case PE.OpCode.Stelem_r4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.SingleRef));                              break;                          case PE.OpCode.Stelem_r8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.DoubleRef));                              break;                          case PE.OpCode.Stelem: // aka stelem.any                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Readonly:                              if (i >= ctxt.Instructions.Length)                                  throw new InvalidOperationException("invalid instruction");                              instruction = ctxt.Instructions[i++];                              if (instruction.OpCode != PE.OpCode.Ldelema)                                  throw new InvalidOperationException("invalid instruction");                              instructions.Add(new LdElemAddrInstruction(offset' true' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Ldelema:                              instructions.Add(new LdElemAddrInstruction(offset' false' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Ldc_i4_0:                              instructions.Add(new LdInt32Instruction(offset' 0));                              break;                          case PE.OpCode.Ldc_i4_1:                              instructions.Add(new LdInt32Instruction(offset' 1));                              break;                          case PE.OpCode.Ldc_i4_2:                              instructions.Add(new LdInt32Instruction(offset' 2));                              break;                          case PE.OpCode.Ldc_i4_3:                              instructions.Add(new LdInt32Instruction(offset' 3));                              break;                          case PE.OpCode.Ldc_i4_4:                              instructions.Add(new LdInt32Instruction(offset' 4));                              break;                          case PE.OpCode.Ldc_i4_5:                              instructions.Add(new LdInt32Instruction(offset' 5));                              break;                          case PE.OpCode.Ldc_i4_6:                              instructions.Add(new LdInt32Instruction(offset' 6));                              break;                          case PE.OpCode.Ldc_i4_7:                              instructions.Add(new LdInt32Instruction(offset' 7));                              break;                          case PE.OpCode.Ldc_i4_8:                              instructions.Add(new LdInt32Instruction(offset' 8));                              break;                          case PE.OpCode.Ldc_i4_m1:                              instructions.Add(new LdInt32Instruction(offset' -1));                              break;                          case PE.OpCode.Ldc_i4:                          case PE.OpCode.Ldc_i4_s:                              instructions.Add(new LdInt32Instruction(offset' (int)instruction.Value));                              break;                          case PE.OpCode.Ldc_i8:                              instructions.Add(new LdInt64Instruction(offset' (long)instruction.Value));                              break;                          case PE.OpCode.Ldc_r4:                              instructions.Add(new LdSingleInstruction(offset' (float)instruction.Value));                              break;                          case PE.OpCode.Ldc_r8:                              instructions.Add(new LdDoubleInstruction(offset' (double)instruction.Value));                              break;                          case PE.OpCode.Ldstr:                              instructions.Add(new LdStringInstruction(offset' (string)instruction.Value));                              break;                          case PE.OpCode.Add:                              instructions.Add(new ArithInstruction(offset' ArithOp.Add' false' false));                              break;                          case PE.OpCode.Add_ovf:                              instructions.Add(new ArithInstruction(offset' ArithOp.Add' true' false));                              break;                          case PE.OpCode.Add_ovf_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Add' true' true));                              break;                          case PE.OpCode.Sub:                              instructions.Add(new ArithInstruction(offset' ArithOp.Sub' false' false));                              break;                          case PE.OpCode.Sub_ovf:                              instructions.Add(new ArithInstruction(offset' ArithOp.Sub' true' false));                              break;                          case PE.OpCode.Sub_ovf_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Sub' true' true));                              break;                          case PE.OpCode.Mul:                              instructions.Add(new ArithInstruction(offset' ArithOp.Mul' false' false));                              break;                          case PE.OpCode.Mul_ovf:                              instructions.Add(new ArithInstruction(offset' ArithOp.Mul' true' false));                              break;                          case PE.OpCode.Mul_ovf_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Mul' true' true));                              break;                          case PE.OpCode.Div:                              instructions.Add(new ArithInstruction(offset' ArithOp.Div' false' false));                              break;                          case PE.OpCode.Div_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Div' false' true));                              break;                          case PE.OpCode.Rem:                              instructions.Add(new ArithInstruction(offset' ArithOp.Rem' false' false));                              break;                          case PE.OpCode.Rem_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Rem' false' true));                              break;                          case PE.OpCode.Neg:                              instructions.Add(new ArithInstruction(offset' ArithOp.Neg' false' false));                              break;                          case PE.OpCode.And:                              instructions.Add(new ArithInstruction(offset' ArithOp.BitAnd' false' false));                              break;                          case PE.OpCode.Or:                              instructions.Add(new ArithInstruction(offset' ArithOp.BitOr' false' false));                              break;                          case PE.OpCode.Xor:                              instructions.Add(new ArithInstruction(offset' ArithOp.BitXor' false' false));                              break;                          case PE.OpCode.Not:                              instructions.Add(new ArithInstruction(offset' ArithOp.BitNot' false' false));                              break;                          case PE.OpCode.Shl:                              instructions.Add(new ArithInstruction(offset' ArithOp.Shl' false' false));                              break;                          case PE.OpCode.Shr:                              instructions.Add(new ArithInstruction(offset' ArithOp.Shr' false' false));                              break;                          case PE.OpCode.Shr_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Shr' false' true));                              break;                          case PE.OpCode.Conv_i1:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int8' false' false));                              break;                          case PE.OpCode.Conv_u1:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt8' false' false));                              break;                          case PE.OpCode.Conv_i2:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int16' false' false));                              break;                          case PE.OpCode.Conv_u2:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt16' false' false));                              break;                          case PE.OpCode.Conv_i4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int32' false' false));                              break;                          case PE.OpCode.Conv_u4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt32' false' false));                              break;                          case PE.OpCode.Conv_i8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int64' false' false));                              break;                          case PE.OpCode.Conv_u8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt64' false' false));                              break;                          case PE.OpCode.Conv_i:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.IntNative' false' false));                              break;                          case PE.OpCode.Conv_u:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UIntNative' false' false));                              break;                          case PE.OpCode.Conv_r4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Single' false' false));                              break;                          case PE.OpCode.Conv_r8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Double' false' false));                              break;                          case PE.OpCode.Conv_r_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Double' false' true));                              break;                          case PE.OpCode.Conv_ovf_i1:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int8' true' false));                              break;                          case PE.OpCode.Conv_ovf_u1:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt8' true' false));                              break;                          case PE.OpCode.Conv_ovf_i2:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int16' true' false));                              break;                          case PE.OpCode.Conv_ovf_u2:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt16' true' false));                              break;                          case PE.OpCode.Conv_ovf_i4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int32' true' false));                              break;                          case PE.OpCode.Conv_ovf_u4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt32' true' false));                              break;                          case PE.OpCode.Conv_ovf_i8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int64' true' false));                              break;                          case PE.OpCode.Conv_ovf_u8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt64' true' false));                              break;                          case PE.OpCode.Conv_ovf_i:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.IntNative' true' false));                              break;                          case PE.OpCode.Conv_ovf_u:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UIntNative' true' false));                              break;                          case PE.OpCode.Conv_ovf_i1_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int8' true' true));                              break;                          case PE.OpCode.Conv_ovf_u1_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt8' true' true));                              break;                          case PE.OpCode.Conv_ovf_i2_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int16' true' true));                              break;                          case PE.OpCode.Conv_ovf_u2_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt16' true' true));                              break;                          case PE.OpCode.Conv_ovf_i4_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int32' true' true));                              break;                          case PE.OpCode.Conv_ovf_u4_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt32' true' true));                              break;                          case PE.OpCode.Conv_ovf_i8_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int64' true' true));                              break;                          case PE.OpCode.Conv_ovf_u8_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt64' true' true));                              break;                          case PE.OpCode.Conv_ovf_i_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.IntNative' true' true));                              break;                          case PE.OpCode.Conv_ovf_u_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UIntNative' true' true));                              break;                          default:                              throw new InvalidOperationException("invalid instruction");                            }                      }                  }              }
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: while (!ctxt.AtEnd(i))              {                  var j = i > ctxt.Start ? ctxt.JumpOverHandlers(i) : i;                  if (j > i)                      i = j;                  else                  {                      var ehcs = ctxt.OutermostTryBlocks(i);                      if (ehcs != null)                      {                          // A try instruction begins here with given handlers                          var offset = ctxt.Instructions[i].Offset;                          var tryCtxt = new TryTranslationContext(ctxt' i' ehcs);                          var tryBlock = InstructionsFromContext(tryCtxt);                            var handlers = new Seq<TryInstructionHandler>();                          foreach (var ehc in ehcs)                          {                              var handlerCtxt = new HandlerTranslationContext                                  (tryCtxt' ctxt.OffsetToIndex[ehc.HandlerOffset]' ehc);                              var handlerBlock = InstructionsFromContext(handlerCtxt);                              switch (ehc.Flags)                              {                              case PE.CorILExceptionClause.Exception:                                  handlers.Add(new CatchTryInstructionHandler((TypeRef)ehc.Class' handlerBlock));                                  break;                              case PE.CorILExceptionClause.Filter:                                  {                                      var filterCtxt = new FilterTranslationContext                                          (tryCtxt' ctxt.OffsetToIndex[ehc.FilterOffset]' ehc);                                      var filterBlock = InstructionsFromContext(filterCtxt);                                      handlers.Add(new FilterTryInstructionHandler(filterBlock' handlerBlock));                                      break;                                  }                              case PE.CorILExceptionClause.Finally:                                  handlers.Add(new FinallyTryInstructionHandler(handlerBlock));                                  break;                              case PE.CorILExceptionClause.Fault:                                  handlers.Add(new FaultTryInstructionHandler(handlerBlock));                                  break;                              default:                                  throw new ArgumentOutOfRangeException();                              }                          }                          instructions.Add(new TryInstruction(offset' tryBlock' handlers));                            // Jump over try block                          var nextOffset = ehcs[0].TryOffset + ehcs[0].TryLength;                          if (!ctxt.OffsetToIndex.TryGetValue(nextOffset' out i))                              i = ctxt.Instructions.Length;                      }                      else                      {                          var instruction = ctxt.Instructions[i++];                          var offset = instruction.Offset;                            while (instruction.OpCode == PE.OpCode.Unaligned || instruction.OpCode == PE.OpCode.Volatile ||                                 instruction.OpCode == PE.OpCode.Tailcall)                          {                              // Skip over any ignored prefixes' but remember instruction begins at original offset                              // NOTE: What ever happened to the "no." prefix mentioned in the spec?                              if (i >= ctxt.Instructions.Length)                                  throw new InvalidOperationException("invalid instructions");                              instruction = ctxt.Instructions[i++];                          }                          switch (instruction.OpCode)                          {                          case PE.OpCode.Cpblk:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Cpblk));                              break;                          case PE.OpCode.Initblk:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Initblk));                              break;                          case PE.OpCode.Arglist:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Arglist));                              break;                          case PE.OpCode.Localloc:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Localloc));                              break;                          case PE.OpCode.Jmp:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Jmp));                              break;                          case PE.OpCode.Calli:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Calli));                              break;                          case PE.OpCode.Sizeof:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Sizeof));                              break;                          case PE.OpCode.Mkrefany:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Mkrefany));                              break;                          case PE.OpCode.Refanytype:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Refanytype));                              break;                          case PE.OpCode.Refanyval:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Refanyval));                              break;                          case PE.OpCode.Nop:                              instructions.Add(new MiscInstruction(offset' MiscOp.Nop));                              break;                          case PE.OpCode.Break:                              instructions.Add(new MiscInstruction(offset' MiscOp.Break));                              break;                          case PE.OpCode.Dup:                              instructions.Add(new MiscInstruction(offset' MiscOp.Dup));                              break;                          case PE.OpCode.Pop:                              instructions.Add(new MiscInstruction(offset' MiscOp.Pop));                              break;                          case PE.OpCode.Ldnull:                              instructions.Add(new MiscInstruction(offset' MiscOp.Ldnull));                              break;                          case PE.OpCode.Ckfinite:                              instructions.Add(new MiscInstruction(offset' MiscOp.Ckfinite));                              break;                          case PE.OpCode.Throw:                              instructions.Add(new MiscInstruction(offset' MiscOp.Throw));                              break;                          case PE.OpCode.Rethrow:                              instructions.Add(new MiscInstruction(offset' MiscOp.Rethrow));                              break;                          case PE.OpCode.Ldind_ref:                              instructions.Add(new MiscInstruction(offset' MiscOp.LdindRef));                              break;                          case PE.OpCode.Stind_ref:                              instructions.Add(new MiscInstruction(offset' MiscOp.StindRef));                              break;                          case PE.OpCode.Ldelem_ref:                              instructions.Add(new MiscInstruction(offset' MiscOp.LdelemRef));                              break;                          case PE.OpCode.Stelem_ref:                              instructions.Add(new MiscInstruction(offset' MiscOp.StelemRef));                              break;                          case PE.OpCode.Ldlen:                              instructions.Add(new MiscInstruction(offset' MiscOp.Ldlen));                              break;                          case PE.OpCode.Ret:                              if (ctxt.ResultType == null)                                  instructions.Add(new MiscInstruction(offset' MiscOp.Ret));                              else                                  instructions.Add(new MiscInstruction(offset' MiscOp.RetVal));                              break;                          case PE.OpCode.Endfilter:                              instructions.Add(new MiscInstruction(offset' MiscOp.Endfilter));                              break;                          case PE.OpCode.Endfinally: // aka EndFault                              instructions.Add(new MiscInstruction(offset' MiscOp.Endfinally));                              break;                          case PE.OpCode.Br_s:                          case PE.OpCode.Br:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Br' false' (int)instruction.Value));                              break;                          case PE.OpCode.Brtrue_s: // aka brinst.s                          case PE.OpCode.Brtrue: // aka brinst                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Brtrue' false' (int)instruction.Value));                              break;                          case PE.OpCode.Brfalse_s: // aka brzero.s' brnull.s                          case PE.OpCode.Brfalse: // aka brzero' brnull                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Brfalse' false' (int)instruction.Value));                              break;                          case PE.OpCode.Beq:                          case PE.OpCode.Beq_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Breq' false' (int)instruction.Value));                              break;                          case PE.OpCode.Bne_un:                          case PE.OpCode.Bne_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Brne' false' (int)instruction.Value));                              break;                          case PE.OpCode.Leave:                          case PE.OpCode.Leave_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Leave' false' (int)instruction.Value));                              break;                          case PE.OpCode.Blt:                          case PE.OpCode.Blt_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrLt' false' (int)instruction.Value));                              break;                          case PE.OpCode.Blt_un:                          case PE.OpCode.Blt_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrLt' true' (int)instruction.Value));                              break;                          case PE.OpCode.Ble:                          case PE.OpCode.Ble_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrLe' false' (int)instruction.Value));                              break;                          case PE.OpCode.Ble_un:                          case PE.OpCode.Ble_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrLe' true' (int)instruction.Value));                              break;                          case PE.OpCode.Bgt:                          case PE.OpCode.Bgt_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrGt' false' (int)instruction.Value));                              break;                          case PE.OpCode.Bgt_un:                          case PE.OpCode.Bgt_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrGt' true' (int)instruction.Value));                              break;                          case PE.OpCode.Bge:                          case PE.OpCode.Bge_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrGe' false' (int)instruction.Value));                              break;                          case PE.OpCode.Bge_un:                          case PE.OpCode.Bge_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrGe' true' (int)instruction.Value));                              break;                          case PE.OpCode.Switch:                              instructions.Add(new SwitchInstruction(offset' (Seq<int>)instruction.Value));                              break;                          case PE.OpCode.Ceq:                              instructions.Add(new CompareInstruction(offset' CompareOp.Ceq' false));                              break;                          case PE.OpCode.Clt:                              instructions.Add(new CompareInstruction(offset' CompareOp.Clt' false));                              break;                          case PE.OpCode.Clt_un:                              instructions.Add(new CompareInstruction(offset' CompareOp.Clt' true));                              break;                          case PE.OpCode.Cgt:                              instructions.Add(new CompareInstruction(offset' CompareOp.Cgt' false));                              break;                          case PE.OpCode.Cgt_un:                              instructions.Add(new CompareInstruction(offset' CompareOp.Cgt' true));                              break;                          case PE.OpCode.Ldarg_0:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));                              break;                          case PE.OpCode.Ldarg_1:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));                              break;                          case PE.OpCode.Ldarg_2:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));                              break;                          case PE.OpCode.Ldarg_3:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));                              break;                          case PE.OpCode.Ldarg:                          case PE.OpCode.Ldarg_s:                              instructions.Add                                  (new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));                              break;                          case PE.OpCode.Ldarga:                          case PE.OpCode.Ldarga_s:                              instructions.Add                                  (new ArgLocalInstruction(offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));                              break;                          case PE.OpCode.Starg:                          case PE.OpCode.Starg_s:                              instructions.Add                                  (new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));                              break;                          case PE.OpCode.Ldloc_0:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Local' 0));                              break;                          case PE.OpCode.Ldloc_1:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Local' 1));                              break;                          case PE.OpCode.Ldloc_2:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Local' 2));                              break;                          case PE.OpCode.Ldloc_3:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Local' 3));                              break;                          case PE.OpCode.Ldloc:                          case PE.OpCode.Ldloc_s:                              instructions.Add                                  (new ArgLocalInstruction                                       (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));                              break;                          case PE.OpCode.Ldloca:                          case PE.OpCode.Ldloca_s:                              instructions.Add                                  (new ArgLocalInstruction                                       (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));                              break;                          case PE.OpCode.Stloc_0:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Local' 0));                              break;                          case PE.OpCode.Stloc_1:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Local' 1));                              break;                          case PE.OpCode.Stloc_2:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Local' 2));                              break;                          case PE.OpCode.Stloc_3:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Local' 3));                              break;                          case PE.OpCode.Stloc:                          case PE.OpCode.Stloc_s:                              instructions.Add                                  (new ArgLocalInstruction                                       (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));                              break;                          case PE.OpCode.Ldfld:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));                              break;                          case PE.OpCode.Ldsfld:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));                              break;                          case PE.OpCode.Ldflda:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));                              break;                          case PE.OpCode.Ldsflda:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));                              break;                          case PE.OpCode.Stfld:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));                              break;                          case PE.OpCode.Stsfld:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));                              break;                          case PE.OpCode.Ldtoken:                              {                                  if (instruction.Value is FieldRef)                                      instructions.Add                                          (new FieldInstruction                                               (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));                                  else if (instruction.Value is MethodRef)                                      instructions.Add                                          (new MethodInstruction                                               (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));                                  else if (instruction.Value is TypeRef)                                      // NOTE: May be a higher-kinded type                                      instructions.Add                                          (new TypeInstruction(offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));                                  else                                      throw new InvalidOperationException("unexpected ldtoken instruction value");                                  break;                              }                          case PE.OpCode.Constrained:                              {                                  var constrained = (TypeRef)instruction.Value;                                  if (i >= ctxt.Instructions.Length)                                      throw new InvalidOperationException("invalid instructions");                                  instruction = ctxt.Instructions[i++];                                  if (instruction.OpCode != PE.OpCode.Callvirt)                                      throw new InvalidOperationException("invalid instruction");                                  instructions.Add                                      (new MethodInstruction                                           (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));                                  break;                              }                          case PE.OpCode.Call:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Callvirt:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Ldftn:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Ldvirtftn:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Newobj:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Ldind_i1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.Int8Ref));                              break;                          case PE.OpCode.Ldind_u1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.UInt8Ref));                              break;                          case PE.OpCode.Ldind_i2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.Int16Ref));                              break;                          case PE.OpCode.Ldind_u2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.UInt16Ref));                              break;                          case PE.OpCode.Ldind_i4:                          case PE.OpCode.Ldind_u4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.Int32Ref));                              break;                          case PE.OpCode.Ldind_i8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.Int64Ref));                              break;                          case PE.OpCode.Ldind_i:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.IntNativeRef));                              break;                          case PE.OpCode.Ldind_r4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.SingleRef));                              break;                          case PE.OpCode.Ldind_r8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.DoubleRef));                              break;                          case PE.OpCode.Ldobj:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Stind_i1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.Int8Ref));                              break;                          case PE.OpCode.Stind_i2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.Int16Ref));                              break;                          case PE.OpCode.Stind_i4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.Int32Ref));                              break;                          case PE.OpCode.Stind_i8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.Int64Ref));                              break;                          case PE.OpCode.Stind_i:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.IntNativeRef));                              break;                          case PE.OpCode.Stind_r4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.SingleRef));                              break;                          case PE.OpCode.Stind_r8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.DoubleRef));                              break;                          case PE.OpCode.Stobj:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Cpobj:                              instructions.Add(new TypeInstruction(offset' TypeOp.Cpobj' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Newarr:                              instructions.Add(new TypeInstruction(offset' TypeOp.Newarr' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Initobj:                              instructions.Add(new TypeInstruction(offset' TypeOp.Initobj' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Castclass:                              instructions.Add                                  (new TypeInstruction(offset' TypeOp.Castclass' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Isinst:                              instructions.Add(new TypeInstruction(offset' TypeOp.Isinst' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Box:                              instructions.Add(new TypeInstruction(offset' TypeOp.Box' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Unbox:                              instructions.Add(new TypeInstruction(offset' TypeOp.Unbox' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Unbox_any:                              instructions.Add(new TypeInstruction(offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Ldelem_i1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.Int8Ref));                              break;                          case PE.OpCode.Ldelem_u1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.UInt8Ref));                              break;                          case PE.OpCode.Ldelem_i2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.Int16Ref));                              break;                          case PE.OpCode.Ldelem_u2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.UInt16Ref));                              break;                          case PE.OpCode.Ldelem_i4:                          case PE.OpCode.Ldelem_u4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.Int32Ref));                              break;                          case PE.OpCode.Ldelem_i:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.IntNativeRef));                              break;                          case PE.OpCode.Ldelem_i8: // aka ldelem.u8                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.Int64Ref));                              break;                          case PE.OpCode.Ldelem_r4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.SingleRef));                              break;                          case PE.OpCode.Ldelem_r8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.DoubleRef));                              break;                          case PE.OpCode.Ldelem: // aka ldelem.any                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Stelem_i1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.Int8Ref));                              break;                          case PE.OpCode.Stelem_i2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.Int16Ref));                              break;                          case PE.OpCode.Stelem_i4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.Int32Ref));                              break;                          case PE.OpCode.Stelem_i8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.Int64Ref));                              break;                          case PE.OpCode.Stelem_i:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.IntNativeRef));                              break;                          case PE.OpCode.Stelem_r4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.SingleRef));                              break;                          case PE.OpCode.Stelem_r8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.DoubleRef));                              break;                          case PE.OpCode.Stelem: // aka stelem.any                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Readonly:                              if (i >= ctxt.Instructions.Length)                                  throw new InvalidOperationException("invalid instruction");                              instruction = ctxt.Instructions[i++];                              if (instruction.OpCode != PE.OpCode.Ldelema)                                  throw new InvalidOperationException("invalid instruction");                              instructions.Add(new LdElemAddrInstruction(offset' true' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Ldelema:                              instructions.Add(new LdElemAddrInstruction(offset' false' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Ldc_i4_0:                              instructions.Add(new LdInt32Instruction(offset' 0));                              break;                          case PE.OpCode.Ldc_i4_1:                              instructions.Add(new LdInt32Instruction(offset' 1));                              break;                          case PE.OpCode.Ldc_i4_2:                              instructions.Add(new LdInt32Instruction(offset' 2));                              break;                          case PE.OpCode.Ldc_i4_3:                              instructions.Add(new LdInt32Instruction(offset' 3));                              break;                          case PE.OpCode.Ldc_i4_4:                              instructions.Add(new LdInt32Instruction(offset' 4));                              break;                          case PE.OpCode.Ldc_i4_5:                              instructions.Add(new LdInt32Instruction(offset' 5));                              break;                          case PE.OpCode.Ldc_i4_6:                              instructions.Add(new LdInt32Instruction(offset' 6));                              break;                          case PE.OpCode.Ldc_i4_7:                              instructions.Add(new LdInt32Instruction(offset' 7));                              break;                          case PE.OpCode.Ldc_i4_8:                              instructions.Add(new LdInt32Instruction(offset' 8));                              break;                          case PE.OpCode.Ldc_i4_m1:                              instructions.Add(new LdInt32Instruction(offset' -1));                              break;                          case PE.OpCode.Ldc_i4:                          case PE.OpCode.Ldc_i4_s:                              instructions.Add(new LdInt32Instruction(offset' (int)instruction.Value));                              break;                          case PE.OpCode.Ldc_i8:                              instructions.Add(new LdInt64Instruction(offset' (long)instruction.Value));                              break;                          case PE.OpCode.Ldc_r4:                              instructions.Add(new LdSingleInstruction(offset' (float)instruction.Value));                              break;                          case PE.OpCode.Ldc_r8:                              instructions.Add(new LdDoubleInstruction(offset' (double)instruction.Value));                              break;                          case PE.OpCode.Ldstr:                              instructions.Add(new LdStringInstruction(offset' (string)instruction.Value));                              break;                          case PE.OpCode.Add:                              instructions.Add(new ArithInstruction(offset' ArithOp.Add' false' false));                              break;                          case PE.OpCode.Add_ovf:                              instructions.Add(new ArithInstruction(offset' ArithOp.Add' true' false));                              break;                          case PE.OpCode.Add_ovf_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Add' true' true));                              break;                          case PE.OpCode.Sub:                              instructions.Add(new ArithInstruction(offset' ArithOp.Sub' false' false));                              break;                          case PE.OpCode.Sub_ovf:                              instructions.Add(new ArithInstruction(offset' ArithOp.Sub' true' false));                              break;                          case PE.OpCode.Sub_ovf_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Sub' true' true));                              break;                          case PE.OpCode.Mul:                              instructions.Add(new ArithInstruction(offset' ArithOp.Mul' false' false));                              break;                          case PE.OpCode.Mul_ovf:                              instructions.Add(new ArithInstruction(offset' ArithOp.Mul' true' false));                              break;                          case PE.OpCode.Mul_ovf_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Mul' true' true));                              break;                          case PE.OpCode.Div:                              instructions.Add(new ArithInstruction(offset' ArithOp.Div' false' false));                              break;                          case PE.OpCode.Div_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Div' false' true));                              break;                          case PE.OpCode.Rem:                              instructions.Add(new ArithInstruction(offset' ArithOp.Rem' false' false));                              break;                          case PE.OpCode.Rem_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Rem' false' true));                              break;                          case PE.OpCode.Neg:                              instructions.Add(new ArithInstruction(offset' ArithOp.Neg' false' false));                              break;                          case PE.OpCode.And:                              instructions.Add(new ArithInstruction(offset' ArithOp.BitAnd' false' false));                              break;                          case PE.OpCode.Or:                              instructions.Add(new ArithInstruction(offset' ArithOp.BitOr' false' false));                              break;                          case PE.OpCode.Xor:                              instructions.Add(new ArithInstruction(offset' ArithOp.BitXor' false' false));                              break;                          case PE.OpCode.Not:                              instructions.Add(new ArithInstruction(offset' ArithOp.BitNot' false' false));                              break;                          case PE.OpCode.Shl:                              instructions.Add(new ArithInstruction(offset' ArithOp.Shl' false' false));                              break;                          case PE.OpCode.Shr:                              instructions.Add(new ArithInstruction(offset' ArithOp.Shr' false' false));                              break;                          case PE.OpCode.Shr_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Shr' false' true));                              break;                          case PE.OpCode.Conv_i1:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int8' false' false));                              break;                          case PE.OpCode.Conv_u1:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt8' false' false));                              break;                          case PE.OpCode.Conv_i2:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int16' false' false));                              break;                          case PE.OpCode.Conv_u2:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt16' false' false));                              break;                          case PE.OpCode.Conv_i4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int32' false' false));                              break;                          case PE.OpCode.Conv_u4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt32' false' false));                              break;                          case PE.OpCode.Conv_i8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int64' false' false));                              break;                          case PE.OpCode.Conv_u8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt64' false' false));                              break;                          case PE.OpCode.Conv_i:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.IntNative' false' false));                              break;                          case PE.OpCode.Conv_u:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UIntNative' false' false));                              break;                          case PE.OpCode.Conv_r4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Single' false' false));                              break;                          case PE.OpCode.Conv_r8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Double' false' false));                              break;                          case PE.OpCode.Conv_r_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Double' false' true));                              break;                          case PE.OpCode.Conv_ovf_i1:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int8' true' false));                              break;                          case PE.OpCode.Conv_ovf_u1:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt8' true' false));                              break;                          case PE.OpCode.Conv_ovf_i2:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int16' true' false));                              break;                          case PE.OpCode.Conv_ovf_u2:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt16' true' false));                              break;                          case PE.OpCode.Conv_ovf_i4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int32' true' false));                              break;                          case PE.OpCode.Conv_ovf_u4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt32' true' false));                              break;                          case PE.OpCode.Conv_ovf_i8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int64' true' false));                              break;                          case PE.OpCode.Conv_ovf_u8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt64' true' false));                              break;                          case PE.OpCode.Conv_ovf_i:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.IntNative' true' false));                              break;                          case PE.OpCode.Conv_ovf_u:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UIntNative' true' false));                              break;                          case PE.OpCode.Conv_ovf_i1_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int8' true' true));                              break;                          case PE.OpCode.Conv_ovf_u1_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt8' true' true));                              break;                          case PE.OpCode.Conv_ovf_i2_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int16' true' true));                              break;                          case PE.OpCode.Conv_ovf_u2_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt16' true' true));                              break;                          case PE.OpCode.Conv_ovf_i4_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int32' true' true));                              break;                          case PE.OpCode.Conv_ovf_u4_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt32' true' true));                              break;                          case PE.OpCode.Conv_ovf_i8_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int64' true' true));                              break;                          case PE.OpCode.Conv_ovf_u8_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt64' true' true));                              break;                          case PE.OpCode.Conv_ovf_i_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.IntNative' true' true));                              break;                          case PE.OpCode.Conv_ovf_u_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UIntNative' true' true));                              break;                          default:                              throw new InvalidOperationException("invalid instruction");                            }                      }                  }              }
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: while (!ctxt.AtEnd(i))              {                  var j = i > ctxt.Start ? ctxt.JumpOverHandlers(i) : i;                  if (j > i)                      i = j;                  else                  {                      var ehcs = ctxt.OutermostTryBlocks(i);                      if (ehcs != null)                      {                          // A try instruction begins here with given handlers                          var offset = ctxt.Instructions[i].Offset;                          var tryCtxt = new TryTranslationContext(ctxt' i' ehcs);                          var tryBlock = InstructionsFromContext(tryCtxt);                            var handlers = new Seq<TryInstructionHandler>();                          foreach (var ehc in ehcs)                          {                              var handlerCtxt = new HandlerTranslationContext                                  (tryCtxt' ctxt.OffsetToIndex[ehc.HandlerOffset]' ehc);                              var handlerBlock = InstructionsFromContext(handlerCtxt);                              switch (ehc.Flags)                              {                              case PE.CorILExceptionClause.Exception:                                  handlers.Add(new CatchTryInstructionHandler((TypeRef)ehc.Class' handlerBlock));                                  break;                              case PE.CorILExceptionClause.Filter:                                  {                                      var filterCtxt = new FilterTranslationContext                                          (tryCtxt' ctxt.OffsetToIndex[ehc.FilterOffset]' ehc);                                      var filterBlock = InstructionsFromContext(filterCtxt);                                      handlers.Add(new FilterTryInstructionHandler(filterBlock' handlerBlock));                                      break;                                  }                              case PE.CorILExceptionClause.Finally:                                  handlers.Add(new FinallyTryInstructionHandler(handlerBlock));                                  break;                              case PE.CorILExceptionClause.Fault:                                  handlers.Add(new FaultTryInstructionHandler(handlerBlock));                                  break;                              default:                                  throw new ArgumentOutOfRangeException();                              }                          }                          instructions.Add(new TryInstruction(offset' tryBlock' handlers));                            // Jump over try block                          var nextOffset = ehcs[0].TryOffset + ehcs[0].TryLength;                          if (!ctxt.OffsetToIndex.TryGetValue(nextOffset' out i))                              i = ctxt.Instructions.Length;                      }                      else                      {                          var instruction = ctxt.Instructions[i++];                          var offset = instruction.Offset;                            while (instruction.OpCode == PE.OpCode.Unaligned || instruction.OpCode == PE.OpCode.Volatile ||                                 instruction.OpCode == PE.OpCode.Tailcall)                          {                              // Skip over any ignored prefixes' but remember instruction begins at original offset                              // NOTE: What ever happened to the "no." prefix mentioned in the spec?                              if (i >= ctxt.Instructions.Length)                                  throw new InvalidOperationException("invalid instructions");                              instruction = ctxt.Instructions[i++];                          }                          switch (instruction.OpCode)                          {                          case PE.OpCode.Cpblk:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Cpblk));                              break;                          case PE.OpCode.Initblk:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Initblk));                              break;                          case PE.OpCode.Arglist:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Arglist));                              break;                          case PE.OpCode.Localloc:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Localloc));                              break;                          case PE.OpCode.Jmp:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Jmp));                              break;                          case PE.OpCode.Calli:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Calli));                              break;                          case PE.OpCode.Sizeof:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Sizeof));                              break;                          case PE.OpCode.Mkrefany:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Mkrefany));                              break;                          case PE.OpCode.Refanytype:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Refanytype));                              break;                          case PE.OpCode.Refanyval:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Refanyval));                              break;                          case PE.OpCode.Nop:                              instructions.Add(new MiscInstruction(offset' MiscOp.Nop));                              break;                          case PE.OpCode.Break:                              instructions.Add(new MiscInstruction(offset' MiscOp.Break));                              break;                          case PE.OpCode.Dup:                              instructions.Add(new MiscInstruction(offset' MiscOp.Dup));                              break;                          case PE.OpCode.Pop:                              instructions.Add(new MiscInstruction(offset' MiscOp.Pop));                              break;                          case PE.OpCode.Ldnull:                              instructions.Add(new MiscInstruction(offset' MiscOp.Ldnull));                              break;                          case PE.OpCode.Ckfinite:                              instructions.Add(new MiscInstruction(offset' MiscOp.Ckfinite));                              break;                          case PE.OpCode.Throw:                              instructions.Add(new MiscInstruction(offset' MiscOp.Throw));                              break;                          case PE.OpCode.Rethrow:                              instructions.Add(new MiscInstruction(offset' MiscOp.Rethrow));                              break;                          case PE.OpCode.Ldind_ref:                              instructions.Add(new MiscInstruction(offset' MiscOp.LdindRef));                              break;                          case PE.OpCode.Stind_ref:                              instructions.Add(new MiscInstruction(offset' MiscOp.StindRef));                              break;                          case PE.OpCode.Ldelem_ref:                              instructions.Add(new MiscInstruction(offset' MiscOp.LdelemRef));                              break;                          case PE.OpCode.Stelem_ref:                              instructions.Add(new MiscInstruction(offset' MiscOp.StelemRef));                              break;                          case PE.OpCode.Ldlen:                              instructions.Add(new MiscInstruction(offset' MiscOp.Ldlen));                              break;                          case PE.OpCode.Ret:                              if (ctxt.ResultType == null)                                  instructions.Add(new MiscInstruction(offset' MiscOp.Ret));                              else                                  instructions.Add(new MiscInstruction(offset' MiscOp.RetVal));                              break;                          case PE.OpCode.Endfilter:                              instructions.Add(new MiscInstruction(offset' MiscOp.Endfilter));                              break;                          case PE.OpCode.Endfinally: // aka EndFault                              instructions.Add(new MiscInstruction(offset' MiscOp.Endfinally));                              break;                          case PE.OpCode.Br_s:                          case PE.OpCode.Br:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Br' false' (int)instruction.Value));                              break;                          case PE.OpCode.Brtrue_s: // aka brinst.s                          case PE.OpCode.Brtrue: // aka brinst                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Brtrue' false' (int)instruction.Value));                              break;                          case PE.OpCode.Brfalse_s: // aka brzero.s' brnull.s                          case PE.OpCode.Brfalse: // aka brzero' brnull                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Brfalse' false' (int)instruction.Value));                              break;                          case PE.OpCode.Beq:                          case PE.OpCode.Beq_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Breq' false' (int)instruction.Value));                              break;                          case PE.OpCode.Bne_un:                          case PE.OpCode.Bne_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Brne' false' (int)instruction.Value));                              break;                          case PE.OpCode.Leave:                          case PE.OpCode.Leave_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Leave' false' (int)instruction.Value));                              break;                          case PE.OpCode.Blt:                          case PE.OpCode.Blt_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrLt' false' (int)instruction.Value));                              break;                          case PE.OpCode.Blt_un:                          case PE.OpCode.Blt_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrLt' true' (int)instruction.Value));                              break;                          case PE.OpCode.Ble:                          case PE.OpCode.Ble_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrLe' false' (int)instruction.Value));                              break;                          case PE.OpCode.Ble_un:                          case PE.OpCode.Ble_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrLe' true' (int)instruction.Value));                              break;                          case PE.OpCode.Bgt:                          case PE.OpCode.Bgt_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrGt' false' (int)instruction.Value));                              break;                          case PE.OpCode.Bgt_un:                          case PE.OpCode.Bgt_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrGt' true' (int)instruction.Value));                              break;                          case PE.OpCode.Bge:                          case PE.OpCode.Bge_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrGe' false' (int)instruction.Value));                              break;                          case PE.OpCode.Bge_un:                          case PE.OpCode.Bge_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrGe' true' (int)instruction.Value));                              break;                          case PE.OpCode.Switch:                              instructions.Add(new SwitchInstruction(offset' (Seq<int>)instruction.Value));                              break;                          case PE.OpCode.Ceq:                              instructions.Add(new CompareInstruction(offset' CompareOp.Ceq' false));                              break;                          case PE.OpCode.Clt:                              instructions.Add(new CompareInstruction(offset' CompareOp.Clt' false));                              break;                          case PE.OpCode.Clt_un:                              instructions.Add(new CompareInstruction(offset' CompareOp.Clt' true));                              break;                          case PE.OpCode.Cgt:                              instructions.Add(new CompareInstruction(offset' CompareOp.Cgt' false));                              break;                          case PE.OpCode.Cgt_un:                              instructions.Add(new CompareInstruction(offset' CompareOp.Cgt' true));                              break;                          case PE.OpCode.Ldarg_0:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));                              break;                          case PE.OpCode.Ldarg_1:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));                              break;                          case PE.OpCode.Ldarg_2:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));                              break;                          case PE.OpCode.Ldarg_3:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));                              break;                          case PE.OpCode.Ldarg:                          case PE.OpCode.Ldarg_s:                              instructions.Add                                  (new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));                              break;                          case PE.OpCode.Ldarga:                          case PE.OpCode.Ldarga_s:                              instructions.Add                                  (new ArgLocalInstruction(offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));                              break;                          case PE.OpCode.Starg:                          case PE.OpCode.Starg_s:                              instructions.Add                                  (new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));                              break;                          case PE.OpCode.Ldloc_0:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Local' 0));                              break;                          case PE.OpCode.Ldloc_1:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Local' 1));                              break;                          case PE.OpCode.Ldloc_2:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Local' 2));                              break;                          case PE.OpCode.Ldloc_3:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Local' 3));                              break;                          case PE.OpCode.Ldloc:                          case PE.OpCode.Ldloc_s:                              instructions.Add                                  (new ArgLocalInstruction                                       (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));                              break;                          case PE.OpCode.Ldloca:                          case PE.OpCode.Ldloca_s:                              instructions.Add                                  (new ArgLocalInstruction                                       (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));                              break;                          case PE.OpCode.Stloc_0:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Local' 0));                              break;                          case PE.OpCode.Stloc_1:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Local' 1));                              break;                          case PE.OpCode.Stloc_2:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Local' 2));                              break;                          case PE.OpCode.Stloc_3:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Local' 3));                              break;                          case PE.OpCode.Stloc:                          case PE.OpCode.Stloc_s:                              instructions.Add                                  (new ArgLocalInstruction                                       (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));                              break;                          case PE.OpCode.Ldfld:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));                              break;                          case PE.OpCode.Ldsfld:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));                              break;                          case PE.OpCode.Ldflda:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));                              break;                          case PE.OpCode.Ldsflda:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));                              break;                          case PE.OpCode.Stfld:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));                              break;                          case PE.OpCode.Stsfld:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));                              break;                          case PE.OpCode.Ldtoken:                              {                                  if (instruction.Value is FieldRef)                                      instructions.Add                                          (new FieldInstruction                                               (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));                                  else if (instruction.Value is MethodRef)                                      instructions.Add                                          (new MethodInstruction                                               (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));                                  else if (instruction.Value is TypeRef)                                      // NOTE: May be a higher-kinded type                                      instructions.Add                                          (new TypeInstruction(offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));                                  else                                      throw new InvalidOperationException("unexpected ldtoken instruction value");                                  break;                              }                          case PE.OpCode.Constrained:                              {                                  var constrained = (TypeRef)instruction.Value;                                  if (i >= ctxt.Instructions.Length)                                      throw new InvalidOperationException("invalid instructions");                                  instruction = ctxt.Instructions[i++];                                  if (instruction.OpCode != PE.OpCode.Callvirt)                                      throw new InvalidOperationException("invalid instruction");                                  instructions.Add                                      (new MethodInstruction                                           (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));                                  break;                              }                          case PE.OpCode.Call:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Callvirt:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Ldftn:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Ldvirtftn:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Newobj:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Ldind_i1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.Int8Ref));                              break;                          case PE.OpCode.Ldind_u1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.UInt8Ref));                              break;                          case PE.OpCode.Ldind_i2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.Int16Ref));                              break;                          case PE.OpCode.Ldind_u2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.UInt16Ref));                              break;                          case PE.OpCode.Ldind_i4:                          case PE.OpCode.Ldind_u4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.Int32Ref));                              break;                          case PE.OpCode.Ldind_i8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.Int64Ref));                              break;                          case PE.OpCode.Ldind_i:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.IntNativeRef));                              break;                          case PE.OpCode.Ldind_r4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.SingleRef));                              break;                          case PE.OpCode.Ldind_r8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.DoubleRef));                              break;                          case PE.OpCode.Ldobj:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Stind_i1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.Int8Ref));                              break;                          case PE.OpCode.Stind_i2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.Int16Ref));                              break;                          case PE.OpCode.Stind_i4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.Int32Ref));                              break;                          case PE.OpCode.Stind_i8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.Int64Ref));                              break;                          case PE.OpCode.Stind_i:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.IntNativeRef));                              break;                          case PE.OpCode.Stind_r4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.SingleRef));                              break;                          case PE.OpCode.Stind_r8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.DoubleRef));                              break;                          case PE.OpCode.Stobj:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Cpobj:                              instructions.Add(new TypeInstruction(offset' TypeOp.Cpobj' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Newarr:                              instructions.Add(new TypeInstruction(offset' TypeOp.Newarr' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Initobj:                              instructions.Add(new TypeInstruction(offset' TypeOp.Initobj' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Castclass:                              instructions.Add                                  (new TypeInstruction(offset' TypeOp.Castclass' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Isinst:                              instructions.Add(new TypeInstruction(offset' TypeOp.Isinst' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Box:                              instructions.Add(new TypeInstruction(offset' TypeOp.Box' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Unbox:                              instructions.Add(new TypeInstruction(offset' TypeOp.Unbox' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Unbox_any:                              instructions.Add(new TypeInstruction(offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Ldelem_i1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.Int8Ref));                              break;                          case PE.OpCode.Ldelem_u1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.UInt8Ref));                              break;                          case PE.OpCode.Ldelem_i2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.Int16Ref));                              break;                          case PE.OpCode.Ldelem_u2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.UInt16Ref));                              break;                          case PE.OpCode.Ldelem_i4:                          case PE.OpCode.Ldelem_u4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.Int32Ref));                              break;                          case PE.OpCode.Ldelem_i:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.IntNativeRef));                              break;                          case PE.OpCode.Ldelem_i8: // aka ldelem.u8                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.Int64Ref));                              break;                          case PE.OpCode.Ldelem_r4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.SingleRef));                              break;                          case PE.OpCode.Ldelem_r8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.DoubleRef));                              break;                          case PE.OpCode.Ldelem: // aka ldelem.any                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Stelem_i1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.Int8Ref));                              break;                          case PE.OpCode.Stelem_i2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.Int16Ref));                              break;                          case PE.OpCode.Stelem_i4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.Int32Ref));                              break;                          case PE.OpCode.Stelem_i8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.Int64Ref));                              break;                          case PE.OpCode.Stelem_i:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.IntNativeRef));                              break;                          case PE.OpCode.Stelem_r4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.SingleRef));                              break;                          case PE.OpCode.Stelem_r8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.DoubleRef));                              break;                          case PE.OpCode.Stelem: // aka stelem.any                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Readonly:                              if (i >= ctxt.Instructions.Length)                                  throw new InvalidOperationException("invalid instruction");                              instruction = ctxt.Instructions[i++];                              if (instruction.OpCode != PE.OpCode.Ldelema)                                  throw new InvalidOperationException("invalid instruction");                              instructions.Add(new LdElemAddrInstruction(offset' true' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Ldelema:                              instructions.Add(new LdElemAddrInstruction(offset' false' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Ldc_i4_0:                              instructions.Add(new LdInt32Instruction(offset' 0));                              break;                          case PE.OpCode.Ldc_i4_1:                              instructions.Add(new LdInt32Instruction(offset' 1));                              break;                          case PE.OpCode.Ldc_i4_2:                              instructions.Add(new LdInt32Instruction(offset' 2));                              break;                          case PE.OpCode.Ldc_i4_3:                              instructions.Add(new LdInt32Instruction(offset' 3));                              break;                          case PE.OpCode.Ldc_i4_4:                              instructions.Add(new LdInt32Instruction(offset' 4));                              break;                          case PE.OpCode.Ldc_i4_5:                              instructions.Add(new LdInt32Instruction(offset' 5));                              break;                          case PE.OpCode.Ldc_i4_6:                              instructions.Add(new LdInt32Instruction(offset' 6));                              break;                          case PE.OpCode.Ldc_i4_7:                              instructions.Add(new LdInt32Instruction(offset' 7));                              break;                          case PE.OpCode.Ldc_i4_8:                              instructions.Add(new LdInt32Instruction(offset' 8));                              break;                          case PE.OpCode.Ldc_i4_m1:                              instructions.Add(new LdInt32Instruction(offset' -1));                              break;                          case PE.OpCode.Ldc_i4:                          case PE.OpCode.Ldc_i4_s:                              instructions.Add(new LdInt32Instruction(offset' (int)instruction.Value));                              break;                          case PE.OpCode.Ldc_i8:                              instructions.Add(new LdInt64Instruction(offset' (long)instruction.Value));                              break;                          case PE.OpCode.Ldc_r4:                              instructions.Add(new LdSingleInstruction(offset' (float)instruction.Value));                              break;                          case PE.OpCode.Ldc_r8:                              instructions.Add(new LdDoubleInstruction(offset' (double)instruction.Value));                              break;                          case PE.OpCode.Ldstr:                              instructions.Add(new LdStringInstruction(offset' (string)instruction.Value));                              break;                          case PE.OpCode.Add:                              instructions.Add(new ArithInstruction(offset' ArithOp.Add' false' false));                              break;                          case PE.OpCode.Add_ovf:                              instructions.Add(new ArithInstruction(offset' ArithOp.Add' true' false));                              break;                          case PE.OpCode.Add_ovf_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Add' true' true));                              break;                          case PE.OpCode.Sub:                              instructions.Add(new ArithInstruction(offset' ArithOp.Sub' false' false));                              break;                          case PE.OpCode.Sub_ovf:                              instructions.Add(new ArithInstruction(offset' ArithOp.Sub' true' false));                              break;                          case PE.OpCode.Sub_ovf_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Sub' true' true));                              break;                          case PE.OpCode.Mul:                              instructions.Add(new ArithInstruction(offset' ArithOp.Mul' false' false));                              break;                          case PE.OpCode.Mul_ovf:                              instructions.Add(new ArithInstruction(offset' ArithOp.Mul' true' false));                              break;                          case PE.OpCode.Mul_ovf_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Mul' true' true));                              break;                          case PE.OpCode.Div:                              instructions.Add(new ArithInstruction(offset' ArithOp.Div' false' false));                              break;                          case PE.OpCode.Div_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Div' false' true));                              break;                          case PE.OpCode.Rem:                              instructions.Add(new ArithInstruction(offset' ArithOp.Rem' false' false));                              break;                          case PE.OpCode.Rem_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Rem' false' true));                              break;                          case PE.OpCode.Neg:                              instructions.Add(new ArithInstruction(offset' ArithOp.Neg' false' false));                              break;                          case PE.OpCode.And:                              instructions.Add(new ArithInstruction(offset' ArithOp.BitAnd' false' false));                              break;                          case PE.OpCode.Or:                              instructions.Add(new ArithInstruction(offset' ArithOp.BitOr' false' false));                              break;                          case PE.OpCode.Xor:                              instructions.Add(new ArithInstruction(offset' ArithOp.BitXor' false' false));                              break;                          case PE.OpCode.Not:                              instructions.Add(new ArithInstruction(offset' ArithOp.BitNot' false' false));                              break;                          case PE.OpCode.Shl:                              instructions.Add(new ArithInstruction(offset' ArithOp.Shl' false' false));                              break;                          case PE.OpCode.Shr:                              instructions.Add(new ArithInstruction(offset' ArithOp.Shr' false' false));                              break;                          case PE.OpCode.Shr_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Shr' false' true));                              break;                          case PE.OpCode.Conv_i1:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int8' false' false));                              break;                          case PE.OpCode.Conv_u1:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt8' false' false));                              break;                          case PE.OpCode.Conv_i2:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int16' false' false));                              break;                          case PE.OpCode.Conv_u2:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt16' false' false));                              break;                          case PE.OpCode.Conv_i4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int32' false' false));                              break;                          case PE.OpCode.Conv_u4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt32' false' false));                              break;                          case PE.OpCode.Conv_i8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int64' false' false));                              break;                          case PE.OpCode.Conv_u8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt64' false' false));                              break;                          case PE.OpCode.Conv_i:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.IntNative' false' false));                              break;                          case PE.OpCode.Conv_u:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UIntNative' false' false));                              break;                          case PE.OpCode.Conv_r4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Single' false' false));                              break;                          case PE.OpCode.Conv_r8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Double' false' false));                              break;                          case PE.OpCode.Conv_r_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Double' false' true));                              break;                          case PE.OpCode.Conv_ovf_i1:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int8' true' false));                              break;                          case PE.OpCode.Conv_ovf_u1:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt8' true' false));                              break;                          case PE.OpCode.Conv_ovf_i2:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int16' true' false));                              break;                          case PE.OpCode.Conv_ovf_u2:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt16' true' false));                              break;                          case PE.OpCode.Conv_ovf_i4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int32' true' false));                              break;                          case PE.OpCode.Conv_ovf_u4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt32' true' false));                              break;                          case PE.OpCode.Conv_ovf_i8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int64' true' false));                              break;                          case PE.OpCode.Conv_ovf_u8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt64' true' false));                              break;                          case PE.OpCode.Conv_ovf_i:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.IntNative' true' false));                              break;                          case PE.OpCode.Conv_ovf_u:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UIntNative' true' false));                              break;                          case PE.OpCode.Conv_ovf_i1_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int8' true' true));                              break;                          case PE.OpCode.Conv_ovf_u1_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt8' true' true));                              break;                          case PE.OpCode.Conv_ovf_i2_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int16' true' true));                              break;                          case PE.OpCode.Conv_ovf_u2_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt16' true' true));                              break;                          case PE.OpCode.Conv_ovf_i4_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int32' true' true));                              break;                          case PE.OpCode.Conv_ovf_u4_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt32' true' true));                              break;                          case PE.OpCode.Conv_ovf_i8_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int64' true' true));                              break;                          case PE.OpCode.Conv_ovf_u8_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt64' true' true));                              break;                          case PE.OpCode.Conv_ovf_i_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.IntNative' true' true));                              break;                          case PE.OpCode.Conv_ovf_u_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UIntNative' true' true));                              break;                          default:                              throw new InvalidOperationException("invalid instruction");                            }                      }                  }              }
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: while (!ctxt.AtEnd(i))              {                  var j = i > ctxt.Start ? ctxt.JumpOverHandlers(i) : i;                  if (j > i)                      i = j;                  else                  {                      var ehcs = ctxt.OutermostTryBlocks(i);                      if (ehcs != null)                      {                          // A try instruction begins here with given handlers                          var offset = ctxt.Instructions[i].Offset;                          var tryCtxt = new TryTranslationContext(ctxt' i' ehcs);                          var tryBlock = InstructionsFromContext(tryCtxt);                            var handlers = new Seq<TryInstructionHandler>();                          foreach (var ehc in ehcs)                          {                              var handlerCtxt = new HandlerTranslationContext                                  (tryCtxt' ctxt.OffsetToIndex[ehc.HandlerOffset]' ehc);                              var handlerBlock = InstructionsFromContext(handlerCtxt);                              switch (ehc.Flags)                              {                              case PE.CorILExceptionClause.Exception:                                  handlers.Add(new CatchTryInstructionHandler((TypeRef)ehc.Class' handlerBlock));                                  break;                              case PE.CorILExceptionClause.Filter:                                  {                                      var filterCtxt = new FilterTranslationContext                                          (tryCtxt' ctxt.OffsetToIndex[ehc.FilterOffset]' ehc);                                      var filterBlock = InstructionsFromContext(filterCtxt);                                      handlers.Add(new FilterTryInstructionHandler(filterBlock' handlerBlock));                                      break;                                  }                              case PE.CorILExceptionClause.Finally:                                  handlers.Add(new FinallyTryInstructionHandler(handlerBlock));                                  break;                              case PE.CorILExceptionClause.Fault:                                  handlers.Add(new FaultTryInstructionHandler(handlerBlock));                                  break;                              default:                                  throw new ArgumentOutOfRangeException();                              }                          }                          instructions.Add(new TryInstruction(offset' tryBlock' handlers));                            // Jump over try block                          var nextOffset = ehcs[0].TryOffset + ehcs[0].TryLength;                          if (!ctxt.OffsetToIndex.TryGetValue(nextOffset' out i))                              i = ctxt.Instructions.Length;                      }                      else                      {                          var instruction = ctxt.Instructions[i++];                          var offset = instruction.Offset;                            while (instruction.OpCode == PE.OpCode.Unaligned || instruction.OpCode == PE.OpCode.Volatile ||                                 instruction.OpCode == PE.OpCode.Tailcall)                          {                              // Skip over any ignored prefixes' but remember instruction begins at original offset                              // NOTE: What ever happened to the "no." prefix mentioned in the spec?                              if (i >= ctxt.Instructions.Length)                                  throw new InvalidOperationException("invalid instructions");                              instruction = ctxt.Instructions[i++];                          }                          switch (instruction.OpCode)                          {                          case PE.OpCode.Cpblk:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Cpblk));                              break;                          case PE.OpCode.Initblk:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Initblk));                              break;                          case PE.OpCode.Arglist:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Arglist));                              break;                          case PE.OpCode.Localloc:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Localloc));                              break;                          case PE.OpCode.Jmp:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Jmp));                              break;                          case PE.OpCode.Calli:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Calli));                              break;                          case PE.OpCode.Sizeof:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Sizeof));                              break;                          case PE.OpCode.Mkrefany:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Mkrefany));                              break;                          case PE.OpCode.Refanytype:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Refanytype));                              break;                          case PE.OpCode.Refanyval:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Refanyval));                              break;                          case PE.OpCode.Nop:                              instructions.Add(new MiscInstruction(offset' MiscOp.Nop));                              break;                          case PE.OpCode.Break:                              instructions.Add(new MiscInstruction(offset' MiscOp.Break));                              break;                          case PE.OpCode.Dup:                              instructions.Add(new MiscInstruction(offset' MiscOp.Dup));                              break;                          case PE.OpCode.Pop:                              instructions.Add(new MiscInstruction(offset' MiscOp.Pop));                              break;                          case PE.OpCode.Ldnull:                              instructions.Add(new MiscInstruction(offset' MiscOp.Ldnull));                              break;                          case PE.OpCode.Ckfinite:                              instructions.Add(new MiscInstruction(offset' MiscOp.Ckfinite));                              break;                          case PE.OpCode.Throw:                              instructions.Add(new MiscInstruction(offset' MiscOp.Throw));                              break;                          case PE.OpCode.Rethrow:                              instructions.Add(new MiscInstruction(offset' MiscOp.Rethrow));                              break;                          case PE.OpCode.Ldind_ref:                              instructions.Add(new MiscInstruction(offset' MiscOp.LdindRef));                              break;                          case PE.OpCode.Stind_ref:                              instructions.Add(new MiscInstruction(offset' MiscOp.StindRef));                              break;                          case PE.OpCode.Ldelem_ref:                              instructions.Add(new MiscInstruction(offset' MiscOp.LdelemRef));                              break;                          case PE.OpCode.Stelem_ref:                              instructions.Add(new MiscInstruction(offset' MiscOp.StelemRef));                              break;                          case PE.OpCode.Ldlen:                              instructions.Add(new MiscInstruction(offset' MiscOp.Ldlen));                              break;                          case PE.OpCode.Ret:                              if (ctxt.ResultType == null)                                  instructions.Add(new MiscInstruction(offset' MiscOp.Ret));                              else                                  instructions.Add(new MiscInstruction(offset' MiscOp.RetVal));                              break;                          case PE.OpCode.Endfilter:                              instructions.Add(new MiscInstruction(offset' MiscOp.Endfilter));                              break;                          case PE.OpCode.Endfinally: // aka EndFault                              instructions.Add(new MiscInstruction(offset' MiscOp.Endfinally));                              break;                          case PE.OpCode.Br_s:                          case PE.OpCode.Br:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Br' false' (int)instruction.Value));                              break;                          case PE.OpCode.Brtrue_s: // aka brinst.s                          case PE.OpCode.Brtrue: // aka brinst                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Brtrue' false' (int)instruction.Value));                              break;                          case PE.OpCode.Brfalse_s: // aka brzero.s' brnull.s                          case PE.OpCode.Brfalse: // aka brzero' brnull                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Brfalse' false' (int)instruction.Value));                              break;                          case PE.OpCode.Beq:                          case PE.OpCode.Beq_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Breq' false' (int)instruction.Value));                              break;                          case PE.OpCode.Bne_un:                          case PE.OpCode.Bne_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Brne' false' (int)instruction.Value));                              break;                          case PE.OpCode.Leave:                          case PE.OpCode.Leave_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Leave' false' (int)instruction.Value));                              break;                          case PE.OpCode.Blt:                          case PE.OpCode.Blt_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrLt' false' (int)instruction.Value));                              break;                          case PE.OpCode.Blt_un:                          case PE.OpCode.Blt_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrLt' true' (int)instruction.Value));                              break;                          case PE.OpCode.Ble:                          case PE.OpCode.Ble_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrLe' false' (int)instruction.Value));                              break;                          case PE.OpCode.Ble_un:                          case PE.OpCode.Ble_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrLe' true' (int)instruction.Value));                              break;                          case PE.OpCode.Bgt:                          case PE.OpCode.Bgt_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrGt' false' (int)instruction.Value));                              break;                          case PE.OpCode.Bgt_un:                          case PE.OpCode.Bgt_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrGt' true' (int)instruction.Value));                              break;                          case PE.OpCode.Bge:                          case PE.OpCode.Bge_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrGe' false' (int)instruction.Value));                              break;                          case PE.OpCode.Bge_un:                          case PE.OpCode.Bge_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrGe' true' (int)instruction.Value));                              break;                          case PE.OpCode.Switch:                              instructions.Add(new SwitchInstruction(offset' (Seq<int>)instruction.Value));                              break;                          case PE.OpCode.Ceq:                              instructions.Add(new CompareInstruction(offset' CompareOp.Ceq' false));                              break;                          case PE.OpCode.Clt:                              instructions.Add(new CompareInstruction(offset' CompareOp.Clt' false));                              break;                          case PE.OpCode.Clt_un:                              instructions.Add(new CompareInstruction(offset' CompareOp.Clt' true));                              break;                          case PE.OpCode.Cgt:                              instructions.Add(new CompareInstruction(offset' CompareOp.Cgt' false));                              break;                          case PE.OpCode.Cgt_un:                              instructions.Add(new CompareInstruction(offset' CompareOp.Cgt' true));                              break;                          case PE.OpCode.Ldarg_0:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));                              break;                          case PE.OpCode.Ldarg_1:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));                              break;                          case PE.OpCode.Ldarg_2:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));                              break;                          case PE.OpCode.Ldarg_3:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));                              break;                          case PE.OpCode.Ldarg:                          case PE.OpCode.Ldarg_s:                              instructions.Add                                  (new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));                              break;                          case PE.OpCode.Ldarga:                          case PE.OpCode.Ldarga_s:                              instructions.Add                                  (new ArgLocalInstruction(offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));                              break;                          case PE.OpCode.Starg:                          case PE.OpCode.Starg_s:                              instructions.Add                                  (new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));                              break;                          case PE.OpCode.Ldloc_0:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Local' 0));                              break;                          case PE.OpCode.Ldloc_1:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Local' 1));                              break;                          case PE.OpCode.Ldloc_2:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Local' 2));                              break;                          case PE.OpCode.Ldloc_3:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Local' 3));                              break;                          case PE.OpCode.Ldloc:                          case PE.OpCode.Ldloc_s:                              instructions.Add                                  (new ArgLocalInstruction                                       (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));                              break;                          case PE.OpCode.Ldloca:                          case PE.OpCode.Ldloca_s:                              instructions.Add                                  (new ArgLocalInstruction                                       (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));                              break;                          case PE.OpCode.Stloc_0:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Local' 0));                              break;                          case PE.OpCode.Stloc_1:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Local' 1));                              break;                          case PE.OpCode.Stloc_2:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Local' 2));                              break;                          case PE.OpCode.Stloc_3:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Local' 3));                              break;                          case PE.OpCode.Stloc:                          case PE.OpCode.Stloc_s:                              instructions.Add                                  (new ArgLocalInstruction                                       (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));                              break;                          case PE.OpCode.Ldfld:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));                              break;                          case PE.OpCode.Ldsfld:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));                              break;                          case PE.OpCode.Ldflda:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));                              break;                          case PE.OpCode.Ldsflda:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));                              break;                          case PE.OpCode.Stfld:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));                              break;                          case PE.OpCode.Stsfld:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));                              break;                          case PE.OpCode.Ldtoken:                              {                                  if (instruction.Value is FieldRef)                                      instructions.Add                                          (new FieldInstruction                                               (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));                                  else if (instruction.Value is MethodRef)                                      instructions.Add                                          (new MethodInstruction                                               (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));                                  else if (instruction.Value is TypeRef)                                      // NOTE: May be a higher-kinded type                                      instructions.Add                                          (new TypeInstruction(offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));                                  else                                      throw new InvalidOperationException("unexpected ldtoken instruction value");                                  break;                              }                          case PE.OpCode.Constrained:                              {                                  var constrained = (TypeRef)instruction.Value;                                  if (i >= ctxt.Instructions.Length)                                      throw new InvalidOperationException("invalid instructions");                                  instruction = ctxt.Instructions[i++];                                  if (instruction.OpCode != PE.OpCode.Callvirt)                                      throw new InvalidOperationException("invalid instruction");                                  instructions.Add                                      (new MethodInstruction                                           (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));                                  break;                              }                          case PE.OpCode.Call:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Callvirt:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Ldftn:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Ldvirtftn:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Newobj:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Ldind_i1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.Int8Ref));                              break;                          case PE.OpCode.Ldind_u1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.UInt8Ref));                              break;                          case PE.OpCode.Ldind_i2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.Int16Ref));                              break;                          case PE.OpCode.Ldind_u2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.UInt16Ref));                              break;                          case PE.OpCode.Ldind_i4:                          case PE.OpCode.Ldind_u4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.Int32Ref));                              break;                          case PE.OpCode.Ldind_i8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.Int64Ref));                              break;                          case PE.OpCode.Ldind_i:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.IntNativeRef));                              break;                          case PE.OpCode.Ldind_r4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.SingleRef));                              break;                          case PE.OpCode.Ldind_r8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.DoubleRef));                              break;                          case PE.OpCode.Ldobj:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Stind_i1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.Int8Ref));                              break;                          case PE.OpCode.Stind_i2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.Int16Ref));                              break;                          case PE.OpCode.Stind_i4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.Int32Ref));                              break;                          case PE.OpCode.Stind_i8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.Int64Ref));                              break;                          case PE.OpCode.Stind_i:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.IntNativeRef));                              break;                          case PE.OpCode.Stind_r4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.SingleRef));                              break;                          case PE.OpCode.Stind_r8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.DoubleRef));                              break;                          case PE.OpCode.Stobj:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Cpobj:                              instructions.Add(new TypeInstruction(offset' TypeOp.Cpobj' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Newarr:                              instructions.Add(new TypeInstruction(offset' TypeOp.Newarr' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Initobj:                              instructions.Add(new TypeInstruction(offset' TypeOp.Initobj' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Castclass:                              instructions.Add                                  (new TypeInstruction(offset' TypeOp.Castclass' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Isinst:                              instructions.Add(new TypeInstruction(offset' TypeOp.Isinst' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Box:                              instructions.Add(new TypeInstruction(offset' TypeOp.Box' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Unbox:                              instructions.Add(new TypeInstruction(offset' TypeOp.Unbox' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Unbox_any:                              instructions.Add(new TypeInstruction(offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Ldelem_i1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.Int8Ref));                              break;                          case PE.OpCode.Ldelem_u1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.UInt8Ref));                              break;                          case PE.OpCode.Ldelem_i2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.Int16Ref));                              break;                          case PE.OpCode.Ldelem_u2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.UInt16Ref));                              break;                          case PE.OpCode.Ldelem_i4:                          case PE.OpCode.Ldelem_u4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.Int32Ref));                              break;                          case PE.OpCode.Ldelem_i:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.IntNativeRef));                              break;                          case PE.OpCode.Ldelem_i8: // aka ldelem.u8                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.Int64Ref));                              break;                          case PE.OpCode.Ldelem_r4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.SingleRef));                              break;                          case PE.OpCode.Ldelem_r8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.DoubleRef));                              break;                          case PE.OpCode.Ldelem: // aka ldelem.any                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Stelem_i1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.Int8Ref));                              break;                          case PE.OpCode.Stelem_i2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.Int16Ref));                              break;                          case PE.OpCode.Stelem_i4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.Int32Ref));                              break;                          case PE.OpCode.Stelem_i8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.Int64Ref));                              break;                          case PE.OpCode.Stelem_i:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.IntNativeRef));                              break;                          case PE.OpCode.Stelem_r4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.SingleRef));                              break;                          case PE.OpCode.Stelem_r8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.DoubleRef));                              break;                          case PE.OpCode.Stelem: // aka stelem.any                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Readonly:                              if (i >= ctxt.Instructions.Length)                                  throw new InvalidOperationException("invalid instruction");                              instruction = ctxt.Instructions[i++];                              if (instruction.OpCode != PE.OpCode.Ldelema)                                  throw new InvalidOperationException("invalid instruction");                              instructions.Add(new LdElemAddrInstruction(offset' true' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Ldelema:                              instructions.Add(new LdElemAddrInstruction(offset' false' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Ldc_i4_0:                              instructions.Add(new LdInt32Instruction(offset' 0));                              break;                          case PE.OpCode.Ldc_i4_1:                              instructions.Add(new LdInt32Instruction(offset' 1));                              break;                          case PE.OpCode.Ldc_i4_2:                              instructions.Add(new LdInt32Instruction(offset' 2));                              break;                          case PE.OpCode.Ldc_i4_3:                              instructions.Add(new LdInt32Instruction(offset' 3));                              break;                          case PE.OpCode.Ldc_i4_4:                              instructions.Add(new LdInt32Instruction(offset' 4));                              break;                          case PE.OpCode.Ldc_i4_5:                              instructions.Add(new LdInt32Instruction(offset' 5));                              break;                          case PE.OpCode.Ldc_i4_6:                              instructions.Add(new LdInt32Instruction(offset' 6));                              break;                          case PE.OpCode.Ldc_i4_7:                              instructions.Add(new LdInt32Instruction(offset' 7));                              break;                          case PE.OpCode.Ldc_i4_8:                              instructions.Add(new LdInt32Instruction(offset' 8));                              break;                          case PE.OpCode.Ldc_i4_m1:                              instructions.Add(new LdInt32Instruction(offset' -1));                              break;                          case PE.OpCode.Ldc_i4:                          case PE.OpCode.Ldc_i4_s:                              instructions.Add(new LdInt32Instruction(offset' (int)instruction.Value));                              break;                          case PE.OpCode.Ldc_i8:                              instructions.Add(new LdInt64Instruction(offset' (long)instruction.Value));                              break;                          case PE.OpCode.Ldc_r4:                              instructions.Add(new LdSingleInstruction(offset' (float)instruction.Value));                              break;                          case PE.OpCode.Ldc_r8:                              instructions.Add(new LdDoubleInstruction(offset' (double)instruction.Value));                              break;                          case PE.OpCode.Ldstr:                              instructions.Add(new LdStringInstruction(offset' (string)instruction.Value));                              break;                          case PE.OpCode.Add:                              instructions.Add(new ArithInstruction(offset' ArithOp.Add' false' false));                              break;                          case PE.OpCode.Add_ovf:                              instructions.Add(new ArithInstruction(offset' ArithOp.Add' true' false));                              break;                          case PE.OpCode.Add_ovf_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Add' true' true));                              break;                          case PE.OpCode.Sub:                              instructions.Add(new ArithInstruction(offset' ArithOp.Sub' false' false));                              break;                          case PE.OpCode.Sub_ovf:                              instructions.Add(new ArithInstruction(offset' ArithOp.Sub' true' false));                              break;                          case PE.OpCode.Sub_ovf_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Sub' true' true));                              break;                          case PE.OpCode.Mul:                              instructions.Add(new ArithInstruction(offset' ArithOp.Mul' false' false));                              break;                          case PE.OpCode.Mul_ovf:                              instructions.Add(new ArithInstruction(offset' ArithOp.Mul' true' false));                              break;                          case PE.OpCode.Mul_ovf_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Mul' true' true));                              break;                          case PE.OpCode.Div:                              instructions.Add(new ArithInstruction(offset' ArithOp.Div' false' false));                              break;                          case PE.OpCode.Div_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Div' false' true));                              break;                          case PE.OpCode.Rem:                              instructions.Add(new ArithInstruction(offset' ArithOp.Rem' false' false));                              break;                          case PE.OpCode.Rem_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Rem' false' true));                              break;                          case PE.OpCode.Neg:                              instructions.Add(new ArithInstruction(offset' ArithOp.Neg' false' false));                              break;                          case PE.OpCode.And:                              instructions.Add(new ArithInstruction(offset' ArithOp.BitAnd' false' false));                              break;                          case PE.OpCode.Or:                              instructions.Add(new ArithInstruction(offset' ArithOp.BitOr' false' false));                              break;                          case PE.OpCode.Xor:                              instructions.Add(new ArithInstruction(offset' ArithOp.BitXor' false' false));                              break;                          case PE.OpCode.Not:                              instructions.Add(new ArithInstruction(offset' ArithOp.BitNot' false' false));                              break;                          case PE.OpCode.Shl:                              instructions.Add(new ArithInstruction(offset' ArithOp.Shl' false' false));                              break;                          case PE.OpCode.Shr:                              instructions.Add(new ArithInstruction(offset' ArithOp.Shr' false' false));                              break;                          case PE.OpCode.Shr_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Shr' false' true));                              break;                          case PE.OpCode.Conv_i1:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int8' false' false));                              break;                          case PE.OpCode.Conv_u1:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt8' false' false));                              break;                          case PE.OpCode.Conv_i2:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int16' false' false));                              break;                          case PE.OpCode.Conv_u2:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt16' false' false));                              break;                          case PE.OpCode.Conv_i4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int32' false' false));                              break;                          case PE.OpCode.Conv_u4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt32' false' false));                              break;                          case PE.OpCode.Conv_i8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int64' false' false));                              break;                          case PE.OpCode.Conv_u8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt64' false' false));                              break;                          case PE.OpCode.Conv_i:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.IntNative' false' false));                              break;                          case PE.OpCode.Conv_u:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UIntNative' false' false));                              break;                          case PE.OpCode.Conv_r4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Single' false' false));                              break;                          case PE.OpCode.Conv_r8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Double' false' false));                              break;                          case PE.OpCode.Conv_r_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Double' false' true));                              break;                          case PE.OpCode.Conv_ovf_i1:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int8' true' false));                              break;                          case PE.OpCode.Conv_ovf_u1:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt8' true' false));                              break;                          case PE.OpCode.Conv_ovf_i2:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int16' true' false));                              break;                          case PE.OpCode.Conv_ovf_u2:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt16' true' false));                              break;                          case PE.OpCode.Conv_ovf_i4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int32' true' false));                              break;                          case PE.OpCode.Conv_ovf_u4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt32' true' false));                              break;                          case PE.OpCode.Conv_ovf_i8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int64' true' false));                              break;                          case PE.OpCode.Conv_ovf_u8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt64' true' false));                              break;                          case PE.OpCode.Conv_ovf_i:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.IntNative' true' false));                              break;                          case PE.OpCode.Conv_ovf_u:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UIntNative' true' false));                              break;                          case PE.OpCode.Conv_ovf_i1_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int8' true' true));                              break;                          case PE.OpCode.Conv_ovf_u1_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt8' true' true));                              break;                          case PE.OpCode.Conv_ovf_i2_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int16' true' true));                              break;                          case PE.OpCode.Conv_ovf_u2_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt16' true' true));                              break;                          case PE.OpCode.Conv_ovf_i4_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int32' true' true));                              break;                          case PE.OpCode.Conv_ovf_u4_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt32' true' true));                              break;                          case PE.OpCode.Conv_ovf_i8_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int64' true' true));                              break;                          case PE.OpCode.Conv_ovf_u8_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt64' true' true));                              break;                          case PE.OpCode.Conv_ovf_i_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.IntNative' true' true));                              break;                          case PE.OpCode.Conv_ovf_u_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UIntNative' true' true));                              break;                          default:                              throw new InvalidOperationException("invalid instruction");                            }                      }                  }              }
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: while (!ctxt.AtEnd(i))              {                  var j = i > ctxt.Start ? ctxt.JumpOverHandlers(i) : i;                  if (j > i)                      i = j;                  else                  {                      var ehcs = ctxt.OutermostTryBlocks(i);                      if (ehcs != null)                      {                          // A try instruction begins here with given handlers                          var offset = ctxt.Instructions[i].Offset;                          var tryCtxt = new TryTranslationContext(ctxt' i' ehcs);                          var tryBlock = InstructionsFromContext(tryCtxt);                            var handlers = new Seq<TryInstructionHandler>();                          foreach (var ehc in ehcs)                          {                              var handlerCtxt = new HandlerTranslationContext                                  (tryCtxt' ctxt.OffsetToIndex[ehc.HandlerOffset]' ehc);                              var handlerBlock = InstructionsFromContext(handlerCtxt);                              switch (ehc.Flags)                              {                              case PE.CorILExceptionClause.Exception:                                  handlers.Add(new CatchTryInstructionHandler((TypeRef)ehc.Class' handlerBlock));                                  break;                              case PE.CorILExceptionClause.Filter:                                  {                                      var filterCtxt = new FilterTranslationContext                                          (tryCtxt' ctxt.OffsetToIndex[ehc.FilterOffset]' ehc);                                      var filterBlock = InstructionsFromContext(filterCtxt);                                      handlers.Add(new FilterTryInstructionHandler(filterBlock' handlerBlock));                                      break;                                  }                              case PE.CorILExceptionClause.Finally:                                  handlers.Add(new FinallyTryInstructionHandler(handlerBlock));                                  break;                              case PE.CorILExceptionClause.Fault:                                  handlers.Add(new FaultTryInstructionHandler(handlerBlock));                                  break;                              default:                                  throw new ArgumentOutOfRangeException();                              }                          }                          instructions.Add(new TryInstruction(offset' tryBlock' handlers));                            // Jump over try block                          var nextOffset = ehcs[0].TryOffset + ehcs[0].TryLength;                          if (!ctxt.OffsetToIndex.TryGetValue(nextOffset' out i))                              i = ctxt.Instructions.Length;                      }                      else                      {                          var instruction = ctxt.Instructions[i++];                          var offset = instruction.Offset;                            while (instruction.OpCode == PE.OpCode.Unaligned || instruction.OpCode == PE.OpCode.Volatile ||                                 instruction.OpCode == PE.OpCode.Tailcall)                          {                              // Skip over any ignored prefixes' but remember instruction begins at original offset                              // NOTE: What ever happened to the "no." prefix mentioned in the spec?                              if (i >= ctxt.Instructions.Length)                                  throw new InvalidOperationException("invalid instructions");                              instruction = ctxt.Instructions[i++];                          }                          switch (instruction.OpCode)                          {                          case PE.OpCode.Cpblk:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Cpblk));                              break;                          case PE.OpCode.Initblk:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Initblk));                              break;                          case PE.OpCode.Arglist:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Arglist));                              break;                          case PE.OpCode.Localloc:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Localloc));                              break;                          case PE.OpCode.Jmp:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Jmp));                              break;                          case PE.OpCode.Calli:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Calli));                              break;                          case PE.OpCode.Sizeof:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Sizeof));                              break;                          case PE.OpCode.Mkrefany:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Mkrefany));                              break;                          case PE.OpCode.Refanytype:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Refanytype));                              break;                          case PE.OpCode.Refanyval:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Refanyval));                              break;                          case PE.OpCode.Nop:                              instructions.Add(new MiscInstruction(offset' MiscOp.Nop));                              break;                          case PE.OpCode.Break:                              instructions.Add(new MiscInstruction(offset' MiscOp.Break));                              break;                          case PE.OpCode.Dup:                              instructions.Add(new MiscInstruction(offset' MiscOp.Dup));                              break;                          case PE.OpCode.Pop:                              instructions.Add(new MiscInstruction(offset' MiscOp.Pop));                              break;                          case PE.OpCode.Ldnull:                              instructions.Add(new MiscInstruction(offset' MiscOp.Ldnull));                              break;                          case PE.OpCode.Ckfinite:                              instructions.Add(new MiscInstruction(offset' MiscOp.Ckfinite));                              break;                          case PE.OpCode.Throw:                              instructions.Add(new MiscInstruction(offset' MiscOp.Throw));                              break;                          case PE.OpCode.Rethrow:                              instructions.Add(new MiscInstruction(offset' MiscOp.Rethrow));                              break;                          case PE.OpCode.Ldind_ref:                              instructions.Add(new MiscInstruction(offset' MiscOp.LdindRef));                              break;                          case PE.OpCode.Stind_ref:                              instructions.Add(new MiscInstruction(offset' MiscOp.StindRef));                              break;                          case PE.OpCode.Ldelem_ref:                              instructions.Add(new MiscInstruction(offset' MiscOp.LdelemRef));                              break;                          case PE.OpCode.Stelem_ref:                              instructions.Add(new MiscInstruction(offset' MiscOp.StelemRef));                              break;                          case PE.OpCode.Ldlen:                              instructions.Add(new MiscInstruction(offset' MiscOp.Ldlen));                              break;                          case PE.OpCode.Ret:                              if (ctxt.ResultType == null)                                  instructions.Add(new MiscInstruction(offset' MiscOp.Ret));                              else                                  instructions.Add(new MiscInstruction(offset' MiscOp.RetVal));                              break;                          case PE.OpCode.Endfilter:                              instructions.Add(new MiscInstruction(offset' MiscOp.Endfilter));                              break;                          case PE.OpCode.Endfinally: // aka EndFault                              instructions.Add(new MiscInstruction(offset' MiscOp.Endfinally));                              break;                          case PE.OpCode.Br_s:                          case PE.OpCode.Br:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Br' false' (int)instruction.Value));                              break;                          case PE.OpCode.Brtrue_s: // aka brinst.s                          case PE.OpCode.Brtrue: // aka brinst                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Brtrue' false' (int)instruction.Value));                              break;                          case PE.OpCode.Brfalse_s: // aka brzero.s' brnull.s                          case PE.OpCode.Brfalse: // aka brzero' brnull                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Brfalse' false' (int)instruction.Value));                              break;                          case PE.OpCode.Beq:                          case PE.OpCode.Beq_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Breq' false' (int)instruction.Value));                              break;                          case PE.OpCode.Bne_un:                          case PE.OpCode.Bne_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Brne' false' (int)instruction.Value));                              break;                          case PE.OpCode.Leave:                          case PE.OpCode.Leave_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Leave' false' (int)instruction.Value));                              break;                          case PE.OpCode.Blt:                          case PE.OpCode.Blt_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrLt' false' (int)instruction.Value));                              break;                          case PE.OpCode.Blt_un:                          case PE.OpCode.Blt_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrLt' true' (int)instruction.Value));                              break;                          case PE.OpCode.Ble:                          case PE.OpCode.Ble_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrLe' false' (int)instruction.Value));                              break;                          case PE.OpCode.Ble_un:                          case PE.OpCode.Ble_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrLe' true' (int)instruction.Value));                              break;                          case PE.OpCode.Bgt:                          case PE.OpCode.Bgt_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrGt' false' (int)instruction.Value));                              break;                          case PE.OpCode.Bgt_un:                          case PE.OpCode.Bgt_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrGt' true' (int)instruction.Value));                              break;                          case PE.OpCode.Bge:                          case PE.OpCode.Bge_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrGe' false' (int)instruction.Value));                              break;                          case PE.OpCode.Bge_un:                          case PE.OpCode.Bge_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrGe' true' (int)instruction.Value));                              break;                          case PE.OpCode.Switch:                              instructions.Add(new SwitchInstruction(offset' (Seq<int>)instruction.Value));                              break;                          case PE.OpCode.Ceq:                              instructions.Add(new CompareInstruction(offset' CompareOp.Ceq' false));                              break;                          case PE.OpCode.Clt:                              instructions.Add(new CompareInstruction(offset' CompareOp.Clt' false));                              break;                          case PE.OpCode.Clt_un:                              instructions.Add(new CompareInstruction(offset' CompareOp.Clt' true));                              break;                          case PE.OpCode.Cgt:                              instructions.Add(new CompareInstruction(offset' CompareOp.Cgt' false));                              break;                          case PE.OpCode.Cgt_un:                              instructions.Add(new CompareInstruction(offset' CompareOp.Cgt' true));                              break;                          case PE.OpCode.Ldarg_0:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));                              break;                          case PE.OpCode.Ldarg_1:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));                              break;                          case PE.OpCode.Ldarg_2:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));                              break;                          case PE.OpCode.Ldarg_3:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));                              break;                          case PE.OpCode.Ldarg:                          case PE.OpCode.Ldarg_s:                              instructions.Add                                  (new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));                              break;                          case PE.OpCode.Ldarga:                          case PE.OpCode.Ldarga_s:                              instructions.Add                                  (new ArgLocalInstruction(offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));                              break;                          case PE.OpCode.Starg:                          case PE.OpCode.Starg_s:                              instructions.Add                                  (new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));                              break;                          case PE.OpCode.Ldloc_0:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Local' 0));                              break;                          case PE.OpCode.Ldloc_1:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Local' 1));                              break;                          case PE.OpCode.Ldloc_2:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Local' 2));                              break;                          case PE.OpCode.Ldloc_3:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Local' 3));                              break;                          case PE.OpCode.Ldloc:                          case PE.OpCode.Ldloc_s:                              instructions.Add                                  (new ArgLocalInstruction                                       (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));                              break;                          case PE.OpCode.Ldloca:                          case PE.OpCode.Ldloca_s:                              instructions.Add                                  (new ArgLocalInstruction                                       (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));                              break;                          case PE.OpCode.Stloc_0:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Local' 0));                              break;                          case PE.OpCode.Stloc_1:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Local' 1));                              break;                          case PE.OpCode.Stloc_2:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Local' 2));                              break;                          case PE.OpCode.Stloc_3:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Local' 3));                              break;                          case PE.OpCode.Stloc:                          case PE.OpCode.Stloc_s:                              instructions.Add                                  (new ArgLocalInstruction                                       (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));                              break;                          case PE.OpCode.Ldfld:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));                              break;                          case PE.OpCode.Ldsfld:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));                              break;                          case PE.OpCode.Ldflda:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));                              break;                          case PE.OpCode.Ldsflda:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));                              break;                          case PE.OpCode.Stfld:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));                              break;                          case PE.OpCode.Stsfld:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));                              break;                          case PE.OpCode.Ldtoken:                              {                                  if (instruction.Value is FieldRef)                                      instructions.Add                                          (new FieldInstruction                                               (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));                                  else if (instruction.Value is MethodRef)                                      instructions.Add                                          (new MethodInstruction                                               (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));                                  else if (instruction.Value is TypeRef)                                      // NOTE: May be a higher-kinded type                                      instructions.Add                                          (new TypeInstruction(offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));                                  else                                      throw new InvalidOperationException("unexpected ldtoken instruction value");                                  break;                              }                          case PE.OpCode.Constrained:                              {                                  var constrained = (TypeRef)instruction.Value;                                  if (i >= ctxt.Instructions.Length)                                      throw new InvalidOperationException("invalid instructions");                                  instruction = ctxt.Instructions[i++];                                  if (instruction.OpCode != PE.OpCode.Callvirt)                                      throw new InvalidOperationException("invalid instruction");                                  instructions.Add                                      (new MethodInstruction                                           (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));                                  break;                              }                          case PE.OpCode.Call:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Callvirt:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Ldftn:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Ldvirtftn:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Newobj:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Ldind_i1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.Int8Ref));                              break;                          case PE.OpCode.Ldind_u1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.UInt8Ref));                              break;                          case PE.OpCode.Ldind_i2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.Int16Ref));                              break;                          case PE.OpCode.Ldind_u2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.UInt16Ref));                              break;                          case PE.OpCode.Ldind_i4:                          case PE.OpCode.Ldind_u4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.Int32Ref));                              break;                          case PE.OpCode.Ldind_i8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.Int64Ref));                              break;                          case PE.OpCode.Ldind_i:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.IntNativeRef));                              break;                          case PE.OpCode.Ldind_r4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.SingleRef));                              break;                          case PE.OpCode.Ldind_r8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.DoubleRef));                              break;                          case PE.OpCode.Ldobj:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Stind_i1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.Int8Ref));                              break;                          case PE.OpCode.Stind_i2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.Int16Ref));                              break;                          case PE.OpCode.Stind_i4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.Int32Ref));                              break;                          case PE.OpCode.Stind_i8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.Int64Ref));                              break;                          case PE.OpCode.Stind_i:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.IntNativeRef));                              break;                          case PE.OpCode.Stind_r4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.SingleRef));                              break;                          case PE.OpCode.Stind_r8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.DoubleRef));                              break;                          case PE.OpCode.Stobj:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Cpobj:                              instructions.Add(new TypeInstruction(offset' TypeOp.Cpobj' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Newarr:                              instructions.Add(new TypeInstruction(offset' TypeOp.Newarr' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Initobj:                              instructions.Add(new TypeInstruction(offset' TypeOp.Initobj' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Castclass:                              instructions.Add                                  (new TypeInstruction(offset' TypeOp.Castclass' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Isinst:                              instructions.Add(new TypeInstruction(offset' TypeOp.Isinst' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Box:                              instructions.Add(new TypeInstruction(offset' TypeOp.Box' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Unbox:                              instructions.Add(new TypeInstruction(offset' TypeOp.Unbox' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Unbox_any:                              instructions.Add(new TypeInstruction(offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Ldelem_i1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.Int8Ref));                              break;                          case PE.OpCode.Ldelem_u1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.UInt8Ref));                              break;                          case PE.OpCode.Ldelem_i2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.Int16Ref));                              break;                          case PE.OpCode.Ldelem_u2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.UInt16Ref));                              break;                          case PE.OpCode.Ldelem_i4:                          case PE.OpCode.Ldelem_u4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.Int32Ref));                              break;                          case PE.OpCode.Ldelem_i:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.IntNativeRef));                              break;                          case PE.OpCode.Ldelem_i8: // aka ldelem.u8                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.Int64Ref));                              break;                          case PE.OpCode.Ldelem_r4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.SingleRef));                              break;                          case PE.OpCode.Ldelem_r8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.DoubleRef));                              break;                          case PE.OpCode.Ldelem: // aka ldelem.any                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Stelem_i1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.Int8Ref));                              break;                          case PE.OpCode.Stelem_i2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.Int16Ref));                              break;                          case PE.OpCode.Stelem_i4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.Int32Ref));                              break;                          case PE.OpCode.Stelem_i8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.Int64Ref));                              break;                          case PE.OpCode.Stelem_i:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.IntNativeRef));                              break;                          case PE.OpCode.Stelem_r4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.SingleRef));                              break;                          case PE.OpCode.Stelem_r8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.DoubleRef));                              break;                          case PE.OpCode.Stelem: // aka stelem.any                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Readonly:                              if (i >= ctxt.Instructions.Length)                                  throw new InvalidOperationException("invalid instruction");                              instruction = ctxt.Instructions[i++];                              if (instruction.OpCode != PE.OpCode.Ldelema)                                  throw new InvalidOperationException("invalid instruction");                              instructions.Add(new LdElemAddrInstruction(offset' true' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Ldelema:                              instructions.Add(new LdElemAddrInstruction(offset' false' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Ldc_i4_0:                              instructions.Add(new LdInt32Instruction(offset' 0));                              break;                          case PE.OpCode.Ldc_i4_1:                              instructions.Add(new LdInt32Instruction(offset' 1));                              break;                          case PE.OpCode.Ldc_i4_2:                              instructions.Add(new LdInt32Instruction(offset' 2));                              break;                          case PE.OpCode.Ldc_i4_3:                              instructions.Add(new LdInt32Instruction(offset' 3));                              break;                          case PE.OpCode.Ldc_i4_4:                              instructions.Add(new LdInt32Instruction(offset' 4));                              break;                          case PE.OpCode.Ldc_i4_5:                              instructions.Add(new LdInt32Instruction(offset' 5));                              break;                          case PE.OpCode.Ldc_i4_6:                              instructions.Add(new LdInt32Instruction(offset' 6));                              break;                          case PE.OpCode.Ldc_i4_7:                              instructions.Add(new LdInt32Instruction(offset' 7));                              break;                          case PE.OpCode.Ldc_i4_8:                              instructions.Add(new LdInt32Instruction(offset' 8));                              break;                          case PE.OpCode.Ldc_i4_m1:                              instructions.Add(new LdInt32Instruction(offset' -1));                              break;                          case PE.OpCode.Ldc_i4:                          case PE.OpCode.Ldc_i4_s:                              instructions.Add(new LdInt32Instruction(offset' (int)instruction.Value));                              break;                          case PE.OpCode.Ldc_i8:                              instructions.Add(new LdInt64Instruction(offset' (long)instruction.Value));                              break;                          case PE.OpCode.Ldc_r4:                              instructions.Add(new LdSingleInstruction(offset' (float)instruction.Value));                              break;                          case PE.OpCode.Ldc_r8:                              instructions.Add(new LdDoubleInstruction(offset' (double)instruction.Value));                              break;                          case PE.OpCode.Ldstr:                              instructions.Add(new LdStringInstruction(offset' (string)instruction.Value));                              break;                          case PE.OpCode.Add:                              instructions.Add(new ArithInstruction(offset' ArithOp.Add' false' false));                              break;                          case PE.OpCode.Add_ovf:                              instructions.Add(new ArithInstruction(offset' ArithOp.Add' true' false));                              break;                          case PE.OpCode.Add_ovf_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Add' true' true));                              break;                          case PE.OpCode.Sub:                              instructions.Add(new ArithInstruction(offset' ArithOp.Sub' false' false));                              break;                          case PE.OpCode.Sub_ovf:                              instructions.Add(new ArithInstruction(offset' ArithOp.Sub' true' false));                              break;                          case PE.OpCode.Sub_ovf_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Sub' true' true));                              break;                          case PE.OpCode.Mul:                              instructions.Add(new ArithInstruction(offset' ArithOp.Mul' false' false));                              break;                          case PE.OpCode.Mul_ovf:                              instructions.Add(new ArithInstruction(offset' ArithOp.Mul' true' false));                              break;                          case PE.OpCode.Mul_ovf_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Mul' true' true));                              break;                          case PE.OpCode.Div:                              instructions.Add(new ArithInstruction(offset' ArithOp.Div' false' false));                              break;                          case PE.OpCode.Div_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Div' false' true));                              break;                          case PE.OpCode.Rem:                              instructions.Add(new ArithInstruction(offset' ArithOp.Rem' false' false));                              break;                          case PE.OpCode.Rem_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Rem' false' true));                              break;                          case PE.OpCode.Neg:                              instructions.Add(new ArithInstruction(offset' ArithOp.Neg' false' false));                              break;                          case PE.OpCode.And:                              instructions.Add(new ArithInstruction(offset' ArithOp.BitAnd' false' false));                              break;                          case PE.OpCode.Or:                              instructions.Add(new ArithInstruction(offset' ArithOp.BitOr' false' false));                              break;                          case PE.OpCode.Xor:                              instructions.Add(new ArithInstruction(offset' ArithOp.BitXor' false' false));                              break;                          case PE.OpCode.Not:                              instructions.Add(new ArithInstruction(offset' ArithOp.BitNot' false' false));                              break;                          case PE.OpCode.Shl:                              instructions.Add(new ArithInstruction(offset' ArithOp.Shl' false' false));                              break;                          case PE.OpCode.Shr:                              instructions.Add(new ArithInstruction(offset' ArithOp.Shr' false' false));                              break;                          case PE.OpCode.Shr_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Shr' false' true));                              break;                          case PE.OpCode.Conv_i1:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int8' false' false));                              break;                          case PE.OpCode.Conv_u1:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt8' false' false));                              break;                          case PE.OpCode.Conv_i2:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int16' false' false));                              break;                          case PE.OpCode.Conv_u2:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt16' false' false));                              break;                          case PE.OpCode.Conv_i4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int32' false' false));                              break;                          case PE.OpCode.Conv_u4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt32' false' false));                              break;                          case PE.OpCode.Conv_i8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int64' false' false));                              break;                          case PE.OpCode.Conv_u8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt64' false' false));                              break;                          case PE.OpCode.Conv_i:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.IntNative' false' false));                              break;                          case PE.OpCode.Conv_u:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UIntNative' false' false));                              break;                          case PE.OpCode.Conv_r4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Single' false' false));                              break;                          case PE.OpCode.Conv_r8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Double' false' false));                              break;                          case PE.OpCode.Conv_r_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Double' false' true));                              break;                          case PE.OpCode.Conv_ovf_i1:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int8' true' false));                              break;                          case PE.OpCode.Conv_ovf_u1:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt8' true' false));                              break;                          case PE.OpCode.Conv_ovf_i2:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int16' true' false));                              break;                          case PE.OpCode.Conv_ovf_u2:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt16' true' false));                              break;                          case PE.OpCode.Conv_ovf_i4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int32' true' false));                              break;                          case PE.OpCode.Conv_ovf_u4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt32' true' false));                              break;                          case PE.OpCode.Conv_ovf_i8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int64' true' false));                              break;                          case PE.OpCode.Conv_ovf_u8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt64' true' false));                              break;                          case PE.OpCode.Conv_ovf_i:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.IntNative' true' false));                              break;                          case PE.OpCode.Conv_ovf_u:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UIntNative' true' false));                              break;                          case PE.OpCode.Conv_ovf_i1_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int8' true' true));                              break;                          case PE.OpCode.Conv_ovf_u1_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt8' true' true));                              break;                          case PE.OpCode.Conv_ovf_i2_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int16' true' true));                              break;                          case PE.OpCode.Conv_ovf_u2_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt16' true' true));                              break;                          case PE.OpCode.Conv_ovf_i4_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int32' true' true));                              break;                          case PE.OpCode.Conv_ovf_u4_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt32' true' true));                              break;                          case PE.OpCode.Conv_ovf_i8_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int64' true' true));                              break;                          case PE.OpCode.Conv_ovf_u8_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt64' true' true));                              break;                          case PE.OpCode.Conv_ovf_i_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.IntNative' true' true));                              break;                          case PE.OpCode.Conv_ovf_u_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UIntNative' true' true));                              break;                          default:                              throw new InvalidOperationException("invalid instruction");                            }                      }                  }              }
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: while (!ctxt.AtEnd(i))              {                  var j = i > ctxt.Start ? ctxt.JumpOverHandlers(i) : i;                  if (j > i)                      i = j;                  else                  {                      var ehcs = ctxt.OutermostTryBlocks(i);                      if (ehcs != null)                      {                          // A try instruction begins here with given handlers                          var offset = ctxt.Instructions[i].Offset;                          var tryCtxt = new TryTranslationContext(ctxt' i' ehcs);                          var tryBlock = InstructionsFromContext(tryCtxt);                            var handlers = new Seq<TryInstructionHandler>();                          foreach (var ehc in ehcs)                          {                              var handlerCtxt = new HandlerTranslationContext                                  (tryCtxt' ctxt.OffsetToIndex[ehc.HandlerOffset]' ehc);                              var handlerBlock = InstructionsFromContext(handlerCtxt);                              switch (ehc.Flags)                              {                              case PE.CorILExceptionClause.Exception:                                  handlers.Add(new CatchTryInstructionHandler((TypeRef)ehc.Class' handlerBlock));                                  break;                              case PE.CorILExceptionClause.Filter:                                  {                                      var filterCtxt = new FilterTranslationContext                                          (tryCtxt' ctxt.OffsetToIndex[ehc.FilterOffset]' ehc);                                      var filterBlock = InstructionsFromContext(filterCtxt);                                      handlers.Add(new FilterTryInstructionHandler(filterBlock' handlerBlock));                                      break;                                  }                              case PE.CorILExceptionClause.Finally:                                  handlers.Add(new FinallyTryInstructionHandler(handlerBlock));                                  break;                              case PE.CorILExceptionClause.Fault:                                  handlers.Add(new FaultTryInstructionHandler(handlerBlock));                                  break;                              default:                                  throw new ArgumentOutOfRangeException();                              }                          }                          instructions.Add(new TryInstruction(offset' tryBlock' handlers));                            // Jump over try block                          var nextOffset = ehcs[0].TryOffset + ehcs[0].TryLength;                          if (!ctxt.OffsetToIndex.TryGetValue(nextOffset' out i))                              i = ctxt.Instructions.Length;                      }                      else                      {                          var instruction = ctxt.Instructions[i++];                          var offset = instruction.Offset;                            while (instruction.OpCode == PE.OpCode.Unaligned || instruction.OpCode == PE.OpCode.Volatile ||                                 instruction.OpCode == PE.OpCode.Tailcall)                          {                              // Skip over any ignored prefixes' but remember instruction begins at original offset                              // NOTE: What ever happened to the "no." prefix mentioned in the spec?                              if (i >= ctxt.Instructions.Length)                                  throw new InvalidOperationException("invalid instructions");                              instruction = ctxt.Instructions[i++];                          }                          switch (instruction.OpCode)                          {                          case PE.OpCode.Cpblk:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Cpblk));                              break;                          case PE.OpCode.Initblk:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Initblk));                              break;                          case PE.OpCode.Arglist:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Arglist));                              break;                          case PE.OpCode.Localloc:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Localloc));                              break;                          case PE.OpCode.Jmp:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Jmp));                              break;                          case PE.OpCode.Calli:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Calli));                              break;                          case PE.OpCode.Sizeof:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Sizeof));                              break;                          case PE.OpCode.Mkrefany:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Mkrefany));                              break;                          case PE.OpCode.Refanytype:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Refanytype));                              break;                          case PE.OpCode.Refanyval:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Refanyval));                              break;                          case PE.OpCode.Nop:                              instructions.Add(new MiscInstruction(offset' MiscOp.Nop));                              break;                          case PE.OpCode.Break:                              instructions.Add(new MiscInstruction(offset' MiscOp.Break));                              break;                          case PE.OpCode.Dup:                              instructions.Add(new MiscInstruction(offset' MiscOp.Dup));                              break;                          case PE.OpCode.Pop:                              instructions.Add(new MiscInstruction(offset' MiscOp.Pop));                              break;                          case PE.OpCode.Ldnull:                              instructions.Add(new MiscInstruction(offset' MiscOp.Ldnull));                              break;                          case PE.OpCode.Ckfinite:                              instructions.Add(new MiscInstruction(offset' MiscOp.Ckfinite));                              break;                          case PE.OpCode.Throw:                              instructions.Add(new MiscInstruction(offset' MiscOp.Throw));                              break;                          case PE.OpCode.Rethrow:                              instructions.Add(new MiscInstruction(offset' MiscOp.Rethrow));                              break;                          case PE.OpCode.Ldind_ref:                              instructions.Add(new MiscInstruction(offset' MiscOp.LdindRef));                              break;                          case PE.OpCode.Stind_ref:                              instructions.Add(new MiscInstruction(offset' MiscOp.StindRef));                              break;                          case PE.OpCode.Ldelem_ref:                              instructions.Add(new MiscInstruction(offset' MiscOp.LdelemRef));                              break;                          case PE.OpCode.Stelem_ref:                              instructions.Add(new MiscInstruction(offset' MiscOp.StelemRef));                              break;                          case PE.OpCode.Ldlen:                              instructions.Add(new MiscInstruction(offset' MiscOp.Ldlen));                              break;                          case PE.OpCode.Ret:                              if (ctxt.ResultType == null)                                  instructions.Add(new MiscInstruction(offset' MiscOp.Ret));                              else                                  instructions.Add(new MiscInstruction(offset' MiscOp.RetVal));                              break;                          case PE.OpCode.Endfilter:                              instructions.Add(new MiscInstruction(offset' MiscOp.Endfilter));                              break;                          case PE.OpCode.Endfinally: // aka EndFault                              instructions.Add(new MiscInstruction(offset' MiscOp.Endfinally));                              break;                          case PE.OpCode.Br_s:                          case PE.OpCode.Br:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Br' false' (int)instruction.Value));                              break;                          case PE.OpCode.Brtrue_s: // aka brinst.s                          case PE.OpCode.Brtrue: // aka brinst                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Brtrue' false' (int)instruction.Value));                              break;                          case PE.OpCode.Brfalse_s: // aka brzero.s' brnull.s                          case PE.OpCode.Brfalse: // aka brzero' brnull                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Brfalse' false' (int)instruction.Value));                              break;                          case PE.OpCode.Beq:                          case PE.OpCode.Beq_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Breq' false' (int)instruction.Value));                              break;                          case PE.OpCode.Bne_un:                          case PE.OpCode.Bne_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Brne' false' (int)instruction.Value));                              break;                          case PE.OpCode.Leave:                          case PE.OpCode.Leave_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Leave' false' (int)instruction.Value));                              break;                          case PE.OpCode.Blt:                          case PE.OpCode.Blt_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrLt' false' (int)instruction.Value));                              break;                          case PE.OpCode.Blt_un:                          case PE.OpCode.Blt_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrLt' true' (int)instruction.Value));                              break;                          case PE.OpCode.Ble:                          case PE.OpCode.Ble_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrLe' false' (int)instruction.Value));                              break;                          case PE.OpCode.Ble_un:                          case PE.OpCode.Ble_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrLe' true' (int)instruction.Value));                              break;                          case PE.OpCode.Bgt:                          case PE.OpCode.Bgt_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrGt' false' (int)instruction.Value));                              break;                          case PE.OpCode.Bgt_un:                          case PE.OpCode.Bgt_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrGt' true' (int)instruction.Value));                              break;                          case PE.OpCode.Bge:                          case PE.OpCode.Bge_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrGe' false' (int)instruction.Value));                              break;                          case PE.OpCode.Bge_un:                          case PE.OpCode.Bge_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrGe' true' (int)instruction.Value));                              break;                          case PE.OpCode.Switch:                              instructions.Add(new SwitchInstruction(offset' (Seq<int>)instruction.Value));                              break;                          case PE.OpCode.Ceq:                              instructions.Add(new CompareInstruction(offset' CompareOp.Ceq' false));                              break;                          case PE.OpCode.Clt:                              instructions.Add(new CompareInstruction(offset' CompareOp.Clt' false));                              break;                          case PE.OpCode.Clt_un:                              instructions.Add(new CompareInstruction(offset' CompareOp.Clt' true));                              break;                          case PE.OpCode.Cgt:                              instructions.Add(new CompareInstruction(offset' CompareOp.Cgt' false));                              break;                          case PE.OpCode.Cgt_un:                              instructions.Add(new CompareInstruction(offset' CompareOp.Cgt' true));                              break;                          case PE.OpCode.Ldarg_0:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));                              break;                          case PE.OpCode.Ldarg_1:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));                              break;                          case PE.OpCode.Ldarg_2:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));                              break;                          case PE.OpCode.Ldarg_3:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));                              break;                          case PE.OpCode.Ldarg:                          case PE.OpCode.Ldarg_s:                              instructions.Add                                  (new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));                              break;                          case PE.OpCode.Ldarga:                          case PE.OpCode.Ldarga_s:                              instructions.Add                                  (new ArgLocalInstruction(offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));                              break;                          case PE.OpCode.Starg:                          case PE.OpCode.Starg_s:                              instructions.Add                                  (new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));                              break;                          case PE.OpCode.Ldloc_0:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Local' 0));                              break;                          case PE.OpCode.Ldloc_1:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Local' 1));                              break;                          case PE.OpCode.Ldloc_2:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Local' 2));                              break;                          case PE.OpCode.Ldloc_3:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Local' 3));                              break;                          case PE.OpCode.Ldloc:                          case PE.OpCode.Ldloc_s:                              instructions.Add                                  (new ArgLocalInstruction                                       (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));                              break;                          case PE.OpCode.Ldloca:                          case PE.OpCode.Ldloca_s:                              instructions.Add                                  (new ArgLocalInstruction                                       (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));                              break;                          case PE.OpCode.Stloc_0:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Local' 0));                              break;                          case PE.OpCode.Stloc_1:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Local' 1));                              break;                          case PE.OpCode.Stloc_2:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Local' 2));                              break;                          case PE.OpCode.Stloc_3:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Local' 3));                              break;                          case PE.OpCode.Stloc:                          case PE.OpCode.Stloc_s:                              instructions.Add                                  (new ArgLocalInstruction                                       (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));                              break;                          case PE.OpCode.Ldfld:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));                              break;                          case PE.OpCode.Ldsfld:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));                              break;                          case PE.OpCode.Ldflda:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));                              break;                          case PE.OpCode.Ldsflda:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));                              break;                          case PE.OpCode.Stfld:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));                              break;                          case PE.OpCode.Stsfld:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));                              break;                          case PE.OpCode.Ldtoken:                              {                                  if (instruction.Value is FieldRef)                                      instructions.Add                                          (new FieldInstruction                                               (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));                                  else if (instruction.Value is MethodRef)                                      instructions.Add                                          (new MethodInstruction                                               (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));                                  else if (instruction.Value is TypeRef)                                      // NOTE: May be a higher-kinded type                                      instructions.Add                                          (new TypeInstruction(offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));                                  else                                      throw new InvalidOperationException("unexpected ldtoken instruction value");                                  break;                              }                          case PE.OpCode.Constrained:                              {                                  var constrained = (TypeRef)instruction.Value;                                  if (i >= ctxt.Instructions.Length)                                      throw new InvalidOperationException("invalid instructions");                                  instruction = ctxt.Instructions[i++];                                  if (instruction.OpCode != PE.OpCode.Callvirt)                                      throw new InvalidOperationException("invalid instruction");                                  instructions.Add                                      (new MethodInstruction                                           (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));                                  break;                              }                          case PE.OpCode.Call:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Callvirt:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Ldftn:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Ldvirtftn:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Newobj:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Ldind_i1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.Int8Ref));                              break;                          case PE.OpCode.Ldind_u1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.UInt8Ref));                              break;                          case PE.OpCode.Ldind_i2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.Int16Ref));                              break;                          case PE.OpCode.Ldind_u2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.UInt16Ref));                              break;                          case PE.OpCode.Ldind_i4:                          case PE.OpCode.Ldind_u4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.Int32Ref));                              break;                          case PE.OpCode.Ldind_i8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.Int64Ref));                              break;                          case PE.OpCode.Ldind_i:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.IntNativeRef));                              break;                          case PE.OpCode.Ldind_r4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.SingleRef));                              break;                          case PE.OpCode.Ldind_r8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.DoubleRef));                              break;                          case PE.OpCode.Ldobj:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Stind_i1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.Int8Ref));                              break;                          case PE.OpCode.Stind_i2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.Int16Ref));                              break;                          case PE.OpCode.Stind_i4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.Int32Ref));                              break;                          case PE.OpCode.Stind_i8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.Int64Ref));                              break;                          case PE.OpCode.Stind_i:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.IntNativeRef));                              break;                          case PE.OpCode.Stind_r4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.SingleRef));                              break;                          case PE.OpCode.Stind_r8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.DoubleRef));                              break;                          case PE.OpCode.Stobj:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Cpobj:                              instructions.Add(new TypeInstruction(offset' TypeOp.Cpobj' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Newarr:                              instructions.Add(new TypeInstruction(offset' TypeOp.Newarr' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Initobj:                              instructions.Add(new TypeInstruction(offset' TypeOp.Initobj' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Castclass:                              instructions.Add                                  (new TypeInstruction(offset' TypeOp.Castclass' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Isinst:                              instructions.Add(new TypeInstruction(offset' TypeOp.Isinst' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Box:                              instructions.Add(new TypeInstruction(offset' TypeOp.Box' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Unbox:                              instructions.Add(new TypeInstruction(offset' TypeOp.Unbox' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Unbox_any:                              instructions.Add(new TypeInstruction(offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Ldelem_i1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.Int8Ref));                              break;                          case PE.OpCode.Ldelem_u1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.UInt8Ref));                              break;                          case PE.OpCode.Ldelem_i2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.Int16Ref));                              break;                          case PE.OpCode.Ldelem_u2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.UInt16Ref));                              break;                          case PE.OpCode.Ldelem_i4:                          case PE.OpCode.Ldelem_u4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.Int32Ref));                              break;                          case PE.OpCode.Ldelem_i:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.IntNativeRef));                              break;                          case PE.OpCode.Ldelem_i8: // aka ldelem.u8                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.Int64Ref));                              break;                          case PE.OpCode.Ldelem_r4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.SingleRef));                              break;                          case PE.OpCode.Ldelem_r8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.DoubleRef));                              break;                          case PE.OpCode.Ldelem: // aka ldelem.any                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Stelem_i1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.Int8Ref));                              break;                          case PE.OpCode.Stelem_i2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.Int16Ref));                              break;                          case PE.OpCode.Stelem_i4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.Int32Ref));                              break;                          case PE.OpCode.Stelem_i8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.Int64Ref));                              break;                          case PE.OpCode.Stelem_i:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.IntNativeRef));                              break;                          case PE.OpCode.Stelem_r4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.SingleRef));                              break;                          case PE.OpCode.Stelem_r8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.DoubleRef));                              break;                          case PE.OpCode.Stelem: // aka stelem.any                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Readonly:                              if (i >= ctxt.Instructions.Length)                                  throw new InvalidOperationException("invalid instruction");                              instruction = ctxt.Instructions[i++];                              if (instruction.OpCode != PE.OpCode.Ldelema)                                  throw new InvalidOperationException("invalid instruction");                              instructions.Add(new LdElemAddrInstruction(offset' true' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Ldelema:                              instructions.Add(new LdElemAddrInstruction(offset' false' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Ldc_i4_0:                              instructions.Add(new LdInt32Instruction(offset' 0));                              break;                          case PE.OpCode.Ldc_i4_1:                              instructions.Add(new LdInt32Instruction(offset' 1));                              break;                          case PE.OpCode.Ldc_i4_2:                              instructions.Add(new LdInt32Instruction(offset' 2));                              break;                          case PE.OpCode.Ldc_i4_3:                              instructions.Add(new LdInt32Instruction(offset' 3));                              break;                          case PE.OpCode.Ldc_i4_4:                              instructions.Add(new LdInt32Instruction(offset' 4));                              break;                          case PE.OpCode.Ldc_i4_5:                              instructions.Add(new LdInt32Instruction(offset' 5));                              break;                          case PE.OpCode.Ldc_i4_6:                              instructions.Add(new LdInt32Instruction(offset' 6));                              break;                          case PE.OpCode.Ldc_i4_7:                              instructions.Add(new LdInt32Instruction(offset' 7));                              break;                          case PE.OpCode.Ldc_i4_8:                              instructions.Add(new LdInt32Instruction(offset' 8));                              break;                          case PE.OpCode.Ldc_i4_m1:                              instructions.Add(new LdInt32Instruction(offset' -1));                              break;                          case PE.OpCode.Ldc_i4:                          case PE.OpCode.Ldc_i4_s:                              instructions.Add(new LdInt32Instruction(offset' (int)instruction.Value));                              break;                          case PE.OpCode.Ldc_i8:                              instructions.Add(new LdInt64Instruction(offset' (long)instruction.Value));                              break;                          case PE.OpCode.Ldc_r4:                              instructions.Add(new LdSingleInstruction(offset' (float)instruction.Value));                              break;                          case PE.OpCode.Ldc_r8:                              instructions.Add(new LdDoubleInstruction(offset' (double)instruction.Value));                              break;                          case PE.OpCode.Ldstr:                              instructions.Add(new LdStringInstruction(offset' (string)instruction.Value));                              break;                          case PE.OpCode.Add:                              instructions.Add(new ArithInstruction(offset' ArithOp.Add' false' false));                              break;                          case PE.OpCode.Add_ovf:                              instructions.Add(new ArithInstruction(offset' ArithOp.Add' true' false));                              break;                          case PE.OpCode.Add_ovf_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Add' true' true));                              break;                          case PE.OpCode.Sub:                              instructions.Add(new ArithInstruction(offset' ArithOp.Sub' false' false));                              break;                          case PE.OpCode.Sub_ovf:                              instructions.Add(new ArithInstruction(offset' ArithOp.Sub' true' false));                              break;                          case PE.OpCode.Sub_ovf_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Sub' true' true));                              break;                          case PE.OpCode.Mul:                              instructions.Add(new ArithInstruction(offset' ArithOp.Mul' false' false));                              break;                          case PE.OpCode.Mul_ovf:                              instructions.Add(new ArithInstruction(offset' ArithOp.Mul' true' false));                              break;                          case PE.OpCode.Mul_ovf_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Mul' true' true));                              break;                          case PE.OpCode.Div:                              instructions.Add(new ArithInstruction(offset' ArithOp.Div' false' false));                              break;                          case PE.OpCode.Div_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Div' false' true));                              break;                          case PE.OpCode.Rem:                              instructions.Add(new ArithInstruction(offset' ArithOp.Rem' false' false));                              break;                          case PE.OpCode.Rem_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Rem' false' true));                              break;                          case PE.OpCode.Neg:                              instructions.Add(new ArithInstruction(offset' ArithOp.Neg' false' false));                              break;                          case PE.OpCode.And:                              instructions.Add(new ArithInstruction(offset' ArithOp.BitAnd' false' false));                              break;                          case PE.OpCode.Or:                              instructions.Add(new ArithInstruction(offset' ArithOp.BitOr' false' false));                              break;                          case PE.OpCode.Xor:                              instructions.Add(new ArithInstruction(offset' ArithOp.BitXor' false' false));                              break;                          case PE.OpCode.Not:                              instructions.Add(new ArithInstruction(offset' ArithOp.BitNot' false' false));                              break;                          case PE.OpCode.Shl:                              instructions.Add(new ArithInstruction(offset' ArithOp.Shl' false' false));                              break;                          case PE.OpCode.Shr:                              instructions.Add(new ArithInstruction(offset' ArithOp.Shr' false' false));                              break;                          case PE.OpCode.Shr_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Shr' false' true));                              break;                          case PE.OpCode.Conv_i1:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int8' false' false));                              break;                          case PE.OpCode.Conv_u1:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt8' false' false));                              break;                          case PE.OpCode.Conv_i2:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int16' false' false));                              break;                          case PE.OpCode.Conv_u2:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt16' false' false));                              break;                          case PE.OpCode.Conv_i4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int32' false' false));                              break;                          case PE.OpCode.Conv_u4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt32' false' false));                              break;                          case PE.OpCode.Conv_i8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int64' false' false));                              break;                          case PE.OpCode.Conv_u8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt64' false' false));                              break;                          case PE.OpCode.Conv_i:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.IntNative' false' false));                              break;                          case PE.OpCode.Conv_u:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UIntNative' false' false));                              break;                          case PE.OpCode.Conv_r4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Single' false' false));                              break;                          case PE.OpCode.Conv_r8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Double' false' false));                              break;                          case PE.OpCode.Conv_r_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Double' false' true));                              break;                          case PE.OpCode.Conv_ovf_i1:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int8' true' false));                              break;                          case PE.OpCode.Conv_ovf_u1:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt8' true' false));                              break;                          case PE.OpCode.Conv_ovf_i2:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int16' true' false));                              break;                          case PE.OpCode.Conv_ovf_u2:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt16' true' false));                              break;                          case PE.OpCode.Conv_ovf_i4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int32' true' false));                              break;                          case PE.OpCode.Conv_ovf_u4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt32' true' false));                              break;                          case PE.OpCode.Conv_ovf_i8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int64' true' false));                              break;                          case PE.OpCode.Conv_ovf_u8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt64' true' false));                              break;                          case PE.OpCode.Conv_ovf_i:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.IntNative' true' false));                              break;                          case PE.OpCode.Conv_ovf_u:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UIntNative' true' false));                              break;                          case PE.OpCode.Conv_ovf_i1_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int8' true' true));                              break;                          case PE.OpCode.Conv_ovf_u1_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt8' true' true));                              break;                          case PE.OpCode.Conv_ovf_i2_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int16' true' true));                              break;                          case PE.OpCode.Conv_ovf_u2_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt16' true' true));                              break;                          case PE.OpCode.Conv_ovf_i4_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int32' true' true));                              break;                          case PE.OpCode.Conv_ovf_u4_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt32' true' true));                              break;                          case PE.OpCode.Conv_ovf_i8_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int64' true' true));                              break;                          case PE.OpCode.Conv_ovf_u8_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt64' true' true));                              break;                          case PE.OpCode.Conv_ovf_i_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.IntNative' true' true));                              break;                          case PE.OpCode.Conv_ovf_u_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UIntNative' true' true));                              break;                          default:                              throw new InvalidOperationException("invalid instruction");                            }                      }                  }              }
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: while (!ctxt.AtEnd(i))              {                  var j = i > ctxt.Start ? ctxt.JumpOverHandlers(i) : i;                  if (j > i)                      i = j;                  else                  {                      var ehcs = ctxt.OutermostTryBlocks(i);                      if (ehcs != null)                      {                          // A try instruction begins here with given handlers                          var offset = ctxt.Instructions[i].Offset;                          var tryCtxt = new TryTranslationContext(ctxt' i' ehcs);                          var tryBlock = InstructionsFromContext(tryCtxt);                            var handlers = new Seq<TryInstructionHandler>();                          foreach (var ehc in ehcs)                          {                              var handlerCtxt = new HandlerTranslationContext                                  (tryCtxt' ctxt.OffsetToIndex[ehc.HandlerOffset]' ehc);                              var handlerBlock = InstructionsFromContext(handlerCtxt);                              switch (ehc.Flags)                              {                              case PE.CorILExceptionClause.Exception:                                  handlers.Add(new CatchTryInstructionHandler((TypeRef)ehc.Class' handlerBlock));                                  break;                              case PE.CorILExceptionClause.Filter:                                  {                                      var filterCtxt = new FilterTranslationContext                                          (tryCtxt' ctxt.OffsetToIndex[ehc.FilterOffset]' ehc);                                      var filterBlock = InstructionsFromContext(filterCtxt);                                      handlers.Add(new FilterTryInstructionHandler(filterBlock' handlerBlock));                                      break;                                  }                              case PE.CorILExceptionClause.Finally:                                  handlers.Add(new FinallyTryInstructionHandler(handlerBlock));                                  break;                              case PE.CorILExceptionClause.Fault:                                  handlers.Add(new FaultTryInstructionHandler(handlerBlock));                                  break;                              default:                                  throw new ArgumentOutOfRangeException();                              }                          }                          instructions.Add(new TryInstruction(offset' tryBlock' handlers));                            // Jump over try block                          var nextOffset = ehcs[0].TryOffset + ehcs[0].TryLength;                          if (!ctxt.OffsetToIndex.TryGetValue(nextOffset' out i))                              i = ctxt.Instructions.Length;                      }                      else                      {                          var instruction = ctxt.Instructions[i++];                          var offset = instruction.Offset;                            while (instruction.OpCode == PE.OpCode.Unaligned || instruction.OpCode == PE.OpCode.Volatile ||                                 instruction.OpCode == PE.OpCode.Tailcall)                          {                              // Skip over any ignored prefixes' but remember instruction begins at original offset                              // NOTE: What ever happened to the "no." prefix mentioned in the spec?                              if (i >= ctxt.Instructions.Length)                                  throw new InvalidOperationException("invalid instructions");                              instruction = ctxt.Instructions[i++];                          }                          switch (instruction.OpCode)                          {                          case PE.OpCode.Cpblk:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Cpblk));                              break;                          case PE.OpCode.Initblk:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Initblk));                              break;                          case PE.OpCode.Arglist:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Arglist));                              break;                          case PE.OpCode.Localloc:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Localloc));                              break;                          case PE.OpCode.Jmp:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Jmp));                              break;                          case PE.OpCode.Calli:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Calli));                              break;                          case PE.OpCode.Sizeof:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Sizeof));                              break;                          case PE.OpCode.Mkrefany:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Mkrefany));                              break;                          case PE.OpCode.Refanytype:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Refanytype));                              break;                          case PE.OpCode.Refanyval:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Refanyval));                              break;                          case PE.OpCode.Nop:                              instructions.Add(new MiscInstruction(offset' MiscOp.Nop));                              break;                          case PE.OpCode.Break:                              instructions.Add(new MiscInstruction(offset' MiscOp.Break));                              break;                          case PE.OpCode.Dup:                              instructions.Add(new MiscInstruction(offset' MiscOp.Dup));                              break;                          case PE.OpCode.Pop:                              instructions.Add(new MiscInstruction(offset' MiscOp.Pop));                              break;                          case PE.OpCode.Ldnull:                              instructions.Add(new MiscInstruction(offset' MiscOp.Ldnull));                              break;                          case PE.OpCode.Ckfinite:                              instructions.Add(new MiscInstruction(offset' MiscOp.Ckfinite));                              break;                          case PE.OpCode.Throw:                              instructions.Add(new MiscInstruction(offset' MiscOp.Throw));                              break;                          case PE.OpCode.Rethrow:                              instructions.Add(new MiscInstruction(offset' MiscOp.Rethrow));                              break;                          case PE.OpCode.Ldind_ref:                              instructions.Add(new MiscInstruction(offset' MiscOp.LdindRef));                              break;                          case PE.OpCode.Stind_ref:                              instructions.Add(new MiscInstruction(offset' MiscOp.StindRef));                              break;                          case PE.OpCode.Ldelem_ref:                              instructions.Add(new MiscInstruction(offset' MiscOp.LdelemRef));                              break;                          case PE.OpCode.Stelem_ref:                              instructions.Add(new MiscInstruction(offset' MiscOp.StelemRef));                              break;                          case PE.OpCode.Ldlen:                              instructions.Add(new MiscInstruction(offset' MiscOp.Ldlen));                              break;                          case PE.OpCode.Ret:                              if (ctxt.ResultType == null)                                  instructions.Add(new MiscInstruction(offset' MiscOp.Ret));                              else                                  instructions.Add(new MiscInstruction(offset' MiscOp.RetVal));                              break;                          case PE.OpCode.Endfilter:                              instructions.Add(new MiscInstruction(offset' MiscOp.Endfilter));                              break;                          case PE.OpCode.Endfinally: // aka EndFault                              instructions.Add(new MiscInstruction(offset' MiscOp.Endfinally));                              break;                          case PE.OpCode.Br_s:                          case PE.OpCode.Br:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Br' false' (int)instruction.Value));                              break;                          case PE.OpCode.Brtrue_s: // aka brinst.s                          case PE.OpCode.Brtrue: // aka brinst                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Brtrue' false' (int)instruction.Value));                              break;                          case PE.OpCode.Brfalse_s: // aka brzero.s' brnull.s                          case PE.OpCode.Brfalse: // aka brzero' brnull                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Brfalse' false' (int)instruction.Value));                              break;                          case PE.OpCode.Beq:                          case PE.OpCode.Beq_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Breq' false' (int)instruction.Value));                              break;                          case PE.OpCode.Bne_un:                          case PE.OpCode.Bne_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Brne' false' (int)instruction.Value));                              break;                          case PE.OpCode.Leave:                          case PE.OpCode.Leave_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Leave' false' (int)instruction.Value));                              break;                          case PE.OpCode.Blt:                          case PE.OpCode.Blt_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrLt' false' (int)instruction.Value));                              break;                          case PE.OpCode.Blt_un:                          case PE.OpCode.Blt_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrLt' true' (int)instruction.Value));                              break;                          case PE.OpCode.Ble:                          case PE.OpCode.Ble_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrLe' false' (int)instruction.Value));                              break;                          case PE.OpCode.Ble_un:                          case PE.OpCode.Ble_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrLe' true' (int)instruction.Value));                              break;                          case PE.OpCode.Bgt:                          case PE.OpCode.Bgt_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrGt' false' (int)instruction.Value));                              break;                          case PE.OpCode.Bgt_un:                          case PE.OpCode.Bgt_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrGt' true' (int)instruction.Value));                              break;                          case PE.OpCode.Bge:                          case PE.OpCode.Bge_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrGe' false' (int)instruction.Value));                              break;                          case PE.OpCode.Bge_un:                          case PE.OpCode.Bge_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrGe' true' (int)instruction.Value));                              break;                          case PE.OpCode.Switch:                              instructions.Add(new SwitchInstruction(offset' (Seq<int>)instruction.Value));                              break;                          case PE.OpCode.Ceq:                              instructions.Add(new CompareInstruction(offset' CompareOp.Ceq' false));                              break;                          case PE.OpCode.Clt:                              instructions.Add(new CompareInstruction(offset' CompareOp.Clt' false));                              break;                          case PE.OpCode.Clt_un:                              instructions.Add(new CompareInstruction(offset' CompareOp.Clt' true));                              break;                          case PE.OpCode.Cgt:                              instructions.Add(new CompareInstruction(offset' CompareOp.Cgt' false));                              break;                          case PE.OpCode.Cgt_un:                              instructions.Add(new CompareInstruction(offset' CompareOp.Cgt' true));                              break;                          case PE.OpCode.Ldarg_0:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));                              break;                          case PE.OpCode.Ldarg_1:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));                              break;                          case PE.OpCode.Ldarg_2:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));                              break;                          case PE.OpCode.Ldarg_3:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));                              break;                          case PE.OpCode.Ldarg:                          case PE.OpCode.Ldarg_s:                              instructions.Add                                  (new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));                              break;                          case PE.OpCode.Ldarga:                          case PE.OpCode.Ldarga_s:                              instructions.Add                                  (new ArgLocalInstruction(offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));                              break;                          case PE.OpCode.Starg:                          case PE.OpCode.Starg_s:                              instructions.Add                                  (new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));                              break;                          case PE.OpCode.Ldloc_0:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Local' 0));                              break;                          case PE.OpCode.Ldloc_1:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Local' 1));                              break;                          case PE.OpCode.Ldloc_2:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Local' 2));                              break;                          case PE.OpCode.Ldloc_3:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Local' 3));                              break;                          case PE.OpCode.Ldloc:                          case PE.OpCode.Ldloc_s:                              instructions.Add                                  (new ArgLocalInstruction                                       (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));                              break;                          case PE.OpCode.Ldloca:                          case PE.OpCode.Ldloca_s:                              instructions.Add                                  (new ArgLocalInstruction                                       (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));                              break;                          case PE.OpCode.Stloc_0:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Local' 0));                              break;                          case PE.OpCode.Stloc_1:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Local' 1));                              break;                          case PE.OpCode.Stloc_2:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Local' 2));                              break;                          case PE.OpCode.Stloc_3:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Local' 3));                              break;                          case PE.OpCode.Stloc:                          case PE.OpCode.Stloc_s:                              instructions.Add                                  (new ArgLocalInstruction                                       (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));                              break;                          case PE.OpCode.Ldfld:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));                              break;                          case PE.OpCode.Ldsfld:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));                              break;                          case PE.OpCode.Ldflda:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));                              break;                          case PE.OpCode.Ldsflda:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));                              break;                          case PE.OpCode.Stfld:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));                              break;                          case PE.OpCode.Stsfld:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));                              break;                          case PE.OpCode.Ldtoken:                              {                                  if (instruction.Value is FieldRef)                                      instructions.Add                                          (new FieldInstruction                                               (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));                                  else if (instruction.Value is MethodRef)                                      instructions.Add                                          (new MethodInstruction                                               (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));                                  else if (instruction.Value is TypeRef)                                      // NOTE: May be a higher-kinded type                                      instructions.Add                                          (new TypeInstruction(offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));                                  else                                      throw new InvalidOperationException("unexpected ldtoken instruction value");                                  break;                              }                          case PE.OpCode.Constrained:                              {                                  var constrained = (TypeRef)instruction.Value;                                  if (i >= ctxt.Instructions.Length)                                      throw new InvalidOperationException("invalid instructions");                                  instruction = ctxt.Instructions[i++];                                  if (instruction.OpCode != PE.OpCode.Callvirt)                                      throw new InvalidOperationException("invalid instruction");                                  instructions.Add                                      (new MethodInstruction                                           (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));                                  break;                              }                          case PE.OpCode.Call:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Callvirt:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Ldftn:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Ldvirtftn:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Newobj:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Ldind_i1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.Int8Ref));                              break;                          case PE.OpCode.Ldind_u1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.UInt8Ref));                              break;                          case PE.OpCode.Ldind_i2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.Int16Ref));                              break;                          case PE.OpCode.Ldind_u2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.UInt16Ref));                              break;                          case PE.OpCode.Ldind_i4:                          case PE.OpCode.Ldind_u4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.Int32Ref));                              break;                          case PE.OpCode.Ldind_i8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.Int64Ref));                              break;                          case PE.OpCode.Ldind_i:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.IntNativeRef));                              break;                          case PE.OpCode.Ldind_r4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.SingleRef));                              break;                          case PE.OpCode.Ldind_r8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.DoubleRef));                              break;                          case PE.OpCode.Ldobj:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Stind_i1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.Int8Ref));                              break;                          case PE.OpCode.Stind_i2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.Int16Ref));                              break;                          case PE.OpCode.Stind_i4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.Int32Ref));                              break;                          case PE.OpCode.Stind_i8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.Int64Ref));                              break;                          case PE.OpCode.Stind_i:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.IntNativeRef));                              break;                          case PE.OpCode.Stind_r4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.SingleRef));                              break;                          case PE.OpCode.Stind_r8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.DoubleRef));                              break;                          case PE.OpCode.Stobj:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Cpobj:                              instructions.Add(new TypeInstruction(offset' TypeOp.Cpobj' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Newarr:                              instructions.Add(new TypeInstruction(offset' TypeOp.Newarr' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Initobj:                              instructions.Add(new TypeInstruction(offset' TypeOp.Initobj' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Castclass:                              instructions.Add                                  (new TypeInstruction(offset' TypeOp.Castclass' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Isinst:                              instructions.Add(new TypeInstruction(offset' TypeOp.Isinst' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Box:                              instructions.Add(new TypeInstruction(offset' TypeOp.Box' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Unbox:                              instructions.Add(new TypeInstruction(offset' TypeOp.Unbox' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Unbox_any:                              instructions.Add(new TypeInstruction(offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Ldelem_i1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.Int8Ref));                              break;                          case PE.OpCode.Ldelem_u1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.UInt8Ref));                              break;                          case PE.OpCode.Ldelem_i2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.Int16Ref));                              break;                          case PE.OpCode.Ldelem_u2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.UInt16Ref));                              break;                          case PE.OpCode.Ldelem_i4:                          case PE.OpCode.Ldelem_u4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.Int32Ref));                              break;                          case PE.OpCode.Ldelem_i:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.IntNativeRef));                              break;                          case PE.OpCode.Ldelem_i8: // aka ldelem.u8                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.Int64Ref));                              break;                          case PE.OpCode.Ldelem_r4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.SingleRef));                              break;                          case PE.OpCode.Ldelem_r8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.DoubleRef));                              break;                          case PE.OpCode.Ldelem: // aka ldelem.any                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Stelem_i1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.Int8Ref));                              break;                          case PE.OpCode.Stelem_i2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.Int16Ref));                              break;                          case PE.OpCode.Stelem_i4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.Int32Ref));                              break;                          case PE.OpCode.Stelem_i8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.Int64Ref));                              break;                          case PE.OpCode.Stelem_i:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.IntNativeRef));                              break;                          case PE.OpCode.Stelem_r4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.SingleRef));                              break;                          case PE.OpCode.Stelem_r8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.DoubleRef));                              break;                          case PE.OpCode.Stelem: // aka stelem.any                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Readonly:                              if (i >= ctxt.Instructions.Length)                                  throw new InvalidOperationException("invalid instruction");                              instruction = ctxt.Instructions[i++];                              if (instruction.OpCode != PE.OpCode.Ldelema)                                  throw new InvalidOperationException("invalid instruction");                              instructions.Add(new LdElemAddrInstruction(offset' true' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Ldelema:                              instructions.Add(new LdElemAddrInstruction(offset' false' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Ldc_i4_0:                              instructions.Add(new LdInt32Instruction(offset' 0));                              break;                          case PE.OpCode.Ldc_i4_1:                              instructions.Add(new LdInt32Instruction(offset' 1));                              break;                          case PE.OpCode.Ldc_i4_2:                              instructions.Add(new LdInt32Instruction(offset' 2));                              break;                          case PE.OpCode.Ldc_i4_3:                              instructions.Add(new LdInt32Instruction(offset' 3));                              break;                          case PE.OpCode.Ldc_i4_4:                              instructions.Add(new LdInt32Instruction(offset' 4));                              break;                          case PE.OpCode.Ldc_i4_5:                              instructions.Add(new LdInt32Instruction(offset' 5));                              break;                          case PE.OpCode.Ldc_i4_6:                              instructions.Add(new LdInt32Instruction(offset' 6));                              break;                          case PE.OpCode.Ldc_i4_7:                              instructions.Add(new LdInt32Instruction(offset' 7));                              break;                          case PE.OpCode.Ldc_i4_8:                              instructions.Add(new LdInt32Instruction(offset' 8));                              break;                          case PE.OpCode.Ldc_i4_m1:                              instructions.Add(new LdInt32Instruction(offset' -1));                              break;                          case PE.OpCode.Ldc_i4:                          case PE.OpCode.Ldc_i4_s:                              instructions.Add(new LdInt32Instruction(offset' (int)instruction.Value));                              break;                          case PE.OpCode.Ldc_i8:                              instructions.Add(new LdInt64Instruction(offset' (long)instruction.Value));                              break;                          case PE.OpCode.Ldc_r4:                              instructions.Add(new LdSingleInstruction(offset' (float)instruction.Value));                              break;                          case PE.OpCode.Ldc_r8:                              instructions.Add(new LdDoubleInstruction(offset' (double)instruction.Value));                              break;                          case PE.OpCode.Ldstr:                              instructions.Add(new LdStringInstruction(offset' (string)instruction.Value));                              break;                          case PE.OpCode.Add:                              instructions.Add(new ArithInstruction(offset' ArithOp.Add' false' false));                              break;                          case PE.OpCode.Add_ovf:                              instructions.Add(new ArithInstruction(offset' ArithOp.Add' true' false));                              break;                          case PE.OpCode.Add_ovf_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Add' true' true));                              break;                          case PE.OpCode.Sub:                              instructions.Add(new ArithInstruction(offset' ArithOp.Sub' false' false));                              break;                          case PE.OpCode.Sub_ovf:                              instructions.Add(new ArithInstruction(offset' ArithOp.Sub' true' false));                              break;                          case PE.OpCode.Sub_ovf_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Sub' true' true));                              break;                          case PE.OpCode.Mul:                              instructions.Add(new ArithInstruction(offset' ArithOp.Mul' false' false));                              break;                          case PE.OpCode.Mul_ovf:                              instructions.Add(new ArithInstruction(offset' ArithOp.Mul' true' false));                              break;                          case PE.OpCode.Mul_ovf_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Mul' true' true));                              break;                          case PE.OpCode.Div:                              instructions.Add(new ArithInstruction(offset' ArithOp.Div' false' false));                              break;                          case PE.OpCode.Div_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Div' false' true));                              break;                          case PE.OpCode.Rem:                              instructions.Add(new ArithInstruction(offset' ArithOp.Rem' false' false));                              break;                          case PE.OpCode.Rem_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Rem' false' true));                              break;                          case PE.OpCode.Neg:                              instructions.Add(new ArithInstruction(offset' ArithOp.Neg' false' false));                              break;                          case PE.OpCode.And:                              instructions.Add(new ArithInstruction(offset' ArithOp.BitAnd' false' false));                              break;                          case PE.OpCode.Or:                              instructions.Add(new ArithInstruction(offset' ArithOp.BitOr' false' false));                              break;                          case PE.OpCode.Xor:                              instructions.Add(new ArithInstruction(offset' ArithOp.BitXor' false' false));                              break;                          case PE.OpCode.Not:                              instructions.Add(new ArithInstruction(offset' ArithOp.BitNot' false' false));                              break;                          case PE.OpCode.Shl:                              instructions.Add(new ArithInstruction(offset' ArithOp.Shl' false' false));                              break;                          case PE.OpCode.Shr:                              instructions.Add(new ArithInstruction(offset' ArithOp.Shr' false' false));                              break;                          case PE.OpCode.Shr_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Shr' false' true));                              break;                          case PE.OpCode.Conv_i1:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int8' false' false));                              break;                          case PE.OpCode.Conv_u1:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt8' false' false));                              break;                          case PE.OpCode.Conv_i2:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int16' false' false));                              break;                          case PE.OpCode.Conv_u2:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt16' false' false));                              break;                          case PE.OpCode.Conv_i4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int32' false' false));                              break;                          case PE.OpCode.Conv_u4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt32' false' false));                              break;                          case PE.OpCode.Conv_i8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int64' false' false));                              break;                          case PE.OpCode.Conv_u8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt64' false' false));                              break;                          case PE.OpCode.Conv_i:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.IntNative' false' false));                              break;                          case PE.OpCode.Conv_u:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UIntNative' false' false));                              break;                          case PE.OpCode.Conv_r4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Single' false' false));                              break;                          case PE.OpCode.Conv_r8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Double' false' false));                              break;                          case PE.OpCode.Conv_r_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Double' false' true));                              break;                          case PE.OpCode.Conv_ovf_i1:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int8' true' false));                              break;                          case PE.OpCode.Conv_ovf_u1:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt8' true' false));                              break;                          case PE.OpCode.Conv_ovf_i2:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int16' true' false));                              break;                          case PE.OpCode.Conv_ovf_u2:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt16' true' false));                              break;                          case PE.OpCode.Conv_ovf_i4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int32' true' false));                              break;                          case PE.OpCode.Conv_ovf_u4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt32' true' false));                              break;                          case PE.OpCode.Conv_ovf_i8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int64' true' false));                              break;                          case PE.OpCode.Conv_ovf_u8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt64' true' false));                              break;                          case PE.OpCode.Conv_ovf_i:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.IntNative' true' false));                              break;                          case PE.OpCode.Conv_ovf_u:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UIntNative' true' false));                              break;                          case PE.OpCode.Conv_ovf_i1_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int8' true' true));                              break;                          case PE.OpCode.Conv_ovf_u1_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt8' true' true));                              break;                          case PE.OpCode.Conv_ovf_i2_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int16' true' true));                              break;                          case PE.OpCode.Conv_ovf_u2_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt16' true' true));                              break;                          case PE.OpCode.Conv_ovf_i4_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int32' true' true));                              break;                          case PE.OpCode.Conv_ovf_u4_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt32' true' true));                              break;                          case PE.OpCode.Conv_ovf_i8_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int64' true' true));                              break;                          case PE.OpCode.Conv_ovf_u8_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt64' true' true));                              break;                          case PE.OpCode.Conv_ovf_i_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.IntNative' true' true));                              break;                          case PE.OpCode.Conv_ovf_u_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UIntNative' true' true));                              break;                          default:                              throw new InvalidOperationException("invalid instruction");                            }                      }                  }              }
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: while (!ctxt.AtEnd(i))              {                  var j = i > ctxt.Start ? ctxt.JumpOverHandlers(i) : i;                  if (j > i)                      i = j;                  else                  {                      var ehcs = ctxt.OutermostTryBlocks(i);                      if (ehcs != null)                      {                          // A try instruction begins here with given handlers                          var offset = ctxt.Instructions[i].Offset;                          var tryCtxt = new TryTranslationContext(ctxt' i' ehcs);                          var tryBlock = InstructionsFromContext(tryCtxt);                            var handlers = new Seq<TryInstructionHandler>();                          foreach (var ehc in ehcs)                          {                              var handlerCtxt = new HandlerTranslationContext                                  (tryCtxt' ctxt.OffsetToIndex[ehc.HandlerOffset]' ehc);                              var handlerBlock = InstructionsFromContext(handlerCtxt);                              switch (ehc.Flags)                              {                              case PE.CorILExceptionClause.Exception:                                  handlers.Add(new CatchTryInstructionHandler((TypeRef)ehc.Class' handlerBlock));                                  break;                              case PE.CorILExceptionClause.Filter:                                  {                                      var filterCtxt = new FilterTranslationContext                                          (tryCtxt' ctxt.OffsetToIndex[ehc.FilterOffset]' ehc);                                      var filterBlock = InstructionsFromContext(filterCtxt);                                      handlers.Add(new FilterTryInstructionHandler(filterBlock' handlerBlock));                                      break;                                  }                              case PE.CorILExceptionClause.Finally:                                  handlers.Add(new FinallyTryInstructionHandler(handlerBlock));                                  break;                              case PE.CorILExceptionClause.Fault:                                  handlers.Add(new FaultTryInstructionHandler(handlerBlock));                                  break;                              default:                                  throw new ArgumentOutOfRangeException();                              }                          }                          instructions.Add(new TryInstruction(offset' tryBlock' handlers));                            // Jump over try block                          var nextOffset = ehcs[0].TryOffset + ehcs[0].TryLength;                          if (!ctxt.OffsetToIndex.TryGetValue(nextOffset' out i))                              i = ctxt.Instructions.Length;                      }                      else                      {                          var instruction = ctxt.Instructions[i++];                          var offset = instruction.Offset;                            while (instruction.OpCode == PE.OpCode.Unaligned || instruction.OpCode == PE.OpCode.Volatile ||                                 instruction.OpCode == PE.OpCode.Tailcall)                          {                              // Skip over any ignored prefixes' but remember instruction begins at original offset                              // NOTE: What ever happened to the "no." prefix mentioned in the spec?                              if (i >= ctxt.Instructions.Length)                                  throw new InvalidOperationException("invalid instructions");                              instruction = ctxt.Instructions[i++];                          }                          switch (instruction.OpCode)                          {                          case PE.OpCode.Cpblk:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Cpblk));                              break;                          case PE.OpCode.Initblk:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Initblk));                              break;                          case PE.OpCode.Arglist:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Arglist));                              break;                          case PE.OpCode.Localloc:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Localloc));                              break;                          case PE.OpCode.Jmp:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Jmp));                              break;                          case PE.OpCode.Calli:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Calli));                              break;                          case PE.OpCode.Sizeof:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Sizeof));                              break;                          case PE.OpCode.Mkrefany:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Mkrefany));                              break;                          case PE.OpCode.Refanytype:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Refanytype));                              break;                          case PE.OpCode.Refanyval:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Refanyval));                              break;                          case PE.OpCode.Nop:                              instructions.Add(new MiscInstruction(offset' MiscOp.Nop));                              break;                          case PE.OpCode.Break:                              instructions.Add(new MiscInstruction(offset' MiscOp.Break));                              break;                          case PE.OpCode.Dup:                              instructions.Add(new MiscInstruction(offset' MiscOp.Dup));                              break;                          case PE.OpCode.Pop:                              instructions.Add(new MiscInstruction(offset' MiscOp.Pop));                              break;                          case PE.OpCode.Ldnull:                              instructions.Add(new MiscInstruction(offset' MiscOp.Ldnull));                              break;                          case PE.OpCode.Ckfinite:                              instructions.Add(new MiscInstruction(offset' MiscOp.Ckfinite));                              break;                          case PE.OpCode.Throw:                              instructions.Add(new MiscInstruction(offset' MiscOp.Throw));                              break;                          case PE.OpCode.Rethrow:                              instructions.Add(new MiscInstruction(offset' MiscOp.Rethrow));                              break;                          case PE.OpCode.Ldind_ref:                              instructions.Add(new MiscInstruction(offset' MiscOp.LdindRef));                              break;                          case PE.OpCode.Stind_ref:                              instructions.Add(new MiscInstruction(offset' MiscOp.StindRef));                              break;                          case PE.OpCode.Ldelem_ref:                              instructions.Add(new MiscInstruction(offset' MiscOp.LdelemRef));                              break;                          case PE.OpCode.Stelem_ref:                              instructions.Add(new MiscInstruction(offset' MiscOp.StelemRef));                              break;                          case PE.OpCode.Ldlen:                              instructions.Add(new MiscInstruction(offset' MiscOp.Ldlen));                              break;                          case PE.OpCode.Ret:                              if (ctxt.ResultType == null)                                  instructions.Add(new MiscInstruction(offset' MiscOp.Ret));                              else                                  instructions.Add(new MiscInstruction(offset' MiscOp.RetVal));                              break;                          case PE.OpCode.Endfilter:                              instructions.Add(new MiscInstruction(offset' MiscOp.Endfilter));                              break;                          case PE.OpCode.Endfinally: // aka EndFault                              instructions.Add(new MiscInstruction(offset' MiscOp.Endfinally));                              break;                          case PE.OpCode.Br_s:                          case PE.OpCode.Br:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Br' false' (int)instruction.Value));                              break;                          case PE.OpCode.Brtrue_s: // aka brinst.s                          case PE.OpCode.Brtrue: // aka brinst                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Brtrue' false' (int)instruction.Value));                              break;                          case PE.OpCode.Brfalse_s: // aka brzero.s' brnull.s                          case PE.OpCode.Brfalse: // aka brzero' brnull                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Brfalse' false' (int)instruction.Value));                              break;                          case PE.OpCode.Beq:                          case PE.OpCode.Beq_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Breq' false' (int)instruction.Value));                              break;                          case PE.OpCode.Bne_un:                          case PE.OpCode.Bne_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Brne' false' (int)instruction.Value));                              break;                          case PE.OpCode.Leave:                          case PE.OpCode.Leave_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Leave' false' (int)instruction.Value));                              break;                          case PE.OpCode.Blt:                          case PE.OpCode.Blt_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrLt' false' (int)instruction.Value));                              break;                          case PE.OpCode.Blt_un:                          case PE.OpCode.Blt_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrLt' true' (int)instruction.Value));                              break;                          case PE.OpCode.Ble:                          case PE.OpCode.Ble_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrLe' false' (int)instruction.Value));                              break;                          case PE.OpCode.Ble_un:                          case PE.OpCode.Ble_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrLe' true' (int)instruction.Value));                              break;                          case PE.OpCode.Bgt:                          case PE.OpCode.Bgt_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrGt' false' (int)instruction.Value));                              break;                          case PE.OpCode.Bgt_un:                          case PE.OpCode.Bgt_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrGt' true' (int)instruction.Value));                              break;                          case PE.OpCode.Bge:                          case PE.OpCode.Bge_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrGe' false' (int)instruction.Value));                              break;                          case PE.OpCode.Bge_un:                          case PE.OpCode.Bge_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrGe' true' (int)instruction.Value));                              break;                          case PE.OpCode.Switch:                              instructions.Add(new SwitchInstruction(offset' (Seq<int>)instruction.Value));                              break;                          case PE.OpCode.Ceq:                              instructions.Add(new CompareInstruction(offset' CompareOp.Ceq' false));                              break;                          case PE.OpCode.Clt:                              instructions.Add(new CompareInstruction(offset' CompareOp.Clt' false));                              break;                          case PE.OpCode.Clt_un:                              instructions.Add(new CompareInstruction(offset' CompareOp.Clt' true));                              break;                          case PE.OpCode.Cgt:                              instructions.Add(new CompareInstruction(offset' CompareOp.Cgt' false));                              break;                          case PE.OpCode.Cgt_un:                              instructions.Add(new CompareInstruction(offset' CompareOp.Cgt' true));                              break;                          case PE.OpCode.Ldarg_0:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));                              break;                          case PE.OpCode.Ldarg_1:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));                              break;                          case PE.OpCode.Ldarg_2:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));                              break;                          case PE.OpCode.Ldarg_3:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));                              break;                          case PE.OpCode.Ldarg:                          case PE.OpCode.Ldarg_s:                              instructions.Add                                  (new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));                              break;                          case PE.OpCode.Ldarga:                          case PE.OpCode.Ldarga_s:                              instructions.Add                                  (new ArgLocalInstruction(offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));                              break;                          case PE.OpCode.Starg:                          case PE.OpCode.Starg_s:                              instructions.Add                                  (new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));                              break;                          case PE.OpCode.Ldloc_0:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Local' 0));                              break;                          case PE.OpCode.Ldloc_1:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Local' 1));                              break;                          case PE.OpCode.Ldloc_2:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Local' 2));                              break;                          case PE.OpCode.Ldloc_3:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Local' 3));                              break;                          case PE.OpCode.Ldloc:                          case PE.OpCode.Ldloc_s:                              instructions.Add                                  (new ArgLocalInstruction                                       (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));                              break;                          case PE.OpCode.Ldloca:                          case PE.OpCode.Ldloca_s:                              instructions.Add                                  (new ArgLocalInstruction                                       (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));                              break;                          case PE.OpCode.Stloc_0:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Local' 0));                              break;                          case PE.OpCode.Stloc_1:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Local' 1));                              break;                          case PE.OpCode.Stloc_2:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Local' 2));                              break;                          case PE.OpCode.Stloc_3:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Local' 3));                              break;                          case PE.OpCode.Stloc:                          case PE.OpCode.Stloc_s:                              instructions.Add                                  (new ArgLocalInstruction                                       (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));                              break;                          case PE.OpCode.Ldfld:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));                              break;                          case PE.OpCode.Ldsfld:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));                              break;                          case PE.OpCode.Ldflda:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));                              break;                          case PE.OpCode.Ldsflda:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));                              break;                          case PE.OpCode.Stfld:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));                              break;                          case PE.OpCode.Stsfld:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));                              break;                          case PE.OpCode.Ldtoken:                              {                                  if (instruction.Value is FieldRef)                                      instructions.Add                                          (new FieldInstruction                                               (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));                                  else if (instruction.Value is MethodRef)                                      instructions.Add                                          (new MethodInstruction                                               (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));                                  else if (instruction.Value is TypeRef)                                      // NOTE: May be a higher-kinded type                                      instructions.Add                                          (new TypeInstruction(offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));                                  else                                      throw new InvalidOperationException("unexpected ldtoken instruction value");                                  break;                              }                          case PE.OpCode.Constrained:                              {                                  var constrained = (TypeRef)instruction.Value;                                  if (i >= ctxt.Instructions.Length)                                      throw new InvalidOperationException("invalid instructions");                                  instruction = ctxt.Instructions[i++];                                  if (instruction.OpCode != PE.OpCode.Callvirt)                                      throw new InvalidOperationException("invalid instruction");                                  instructions.Add                                      (new MethodInstruction                                           (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));                                  break;                              }                          case PE.OpCode.Call:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Callvirt:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Ldftn:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Ldvirtftn:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Newobj:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Ldind_i1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.Int8Ref));                              break;                          case PE.OpCode.Ldind_u1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.UInt8Ref));                              break;                          case PE.OpCode.Ldind_i2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.Int16Ref));                              break;                          case PE.OpCode.Ldind_u2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.UInt16Ref));                              break;                          case PE.OpCode.Ldind_i4:                          case PE.OpCode.Ldind_u4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.Int32Ref));                              break;                          case PE.OpCode.Ldind_i8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.Int64Ref));                              break;                          case PE.OpCode.Ldind_i:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.IntNativeRef));                              break;                          case PE.OpCode.Ldind_r4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.SingleRef));                              break;                          case PE.OpCode.Ldind_r8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.DoubleRef));                              break;                          case PE.OpCode.Ldobj:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Stind_i1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.Int8Ref));                              break;                          case PE.OpCode.Stind_i2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.Int16Ref));                              break;                          case PE.OpCode.Stind_i4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.Int32Ref));                              break;                          case PE.OpCode.Stind_i8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.Int64Ref));                              break;                          case PE.OpCode.Stind_i:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.IntNativeRef));                              break;                          case PE.OpCode.Stind_r4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.SingleRef));                              break;                          case PE.OpCode.Stind_r8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.DoubleRef));                              break;                          case PE.OpCode.Stobj:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Cpobj:                              instructions.Add(new TypeInstruction(offset' TypeOp.Cpobj' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Newarr:                              instructions.Add(new TypeInstruction(offset' TypeOp.Newarr' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Initobj:                              instructions.Add(new TypeInstruction(offset' TypeOp.Initobj' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Castclass:                              instructions.Add                                  (new TypeInstruction(offset' TypeOp.Castclass' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Isinst:                              instructions.Add(new TypeInstruction(offset' TypeOp.Isinst' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Box:                              instructions.Add(new TypeInstruction(offset' TypeOp.Box' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Unbox:                              instructions.Add(new TypeInstruction(offset' TypeOp.Unbox' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Unbox_any:                              instructions.Add(new TypeInstruction(offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Ldelem_i1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.Int8Ref));                              break;                          case PE.OpCode.Ldelem_u1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.UInt8Ref));                              break;                          case PE.OpCode.Ldelem_i2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.Int16Ref));                              break;                          case PE.OpCode.Ldelem_u2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.UInt16Ref));                              break;                          case PE.OpCode.Ldelem_i4:                          case PE.OpCode.Ldelem_u4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.Int32Ref));                              break;                          case PE.OpCode.Ldelem_i:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.IntNativeRef));                              break;                          case PE.OpCode.Ldelem_i8: // aka ldelem.u8                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.Int64Ref));                              break;                          case PE.OpCode.Ldelem_r4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.SingleRef));                              break;                          case PE.OpCode.Ldelem_r8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.DoubleRef));                              break;                          case PE.OpCode.Ldelem: // aka ldelem.any                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Stelem_i1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.Int8Ref));                              break;                          case PE.OpCode.Stelem_i2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.Int16Ref));                              break;                          case PE.OpCode.Stelem_i4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.Int32Ref));                              break;                          case PE.OpCode.Stelem_i8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.Int64Ref));                              break;                          case PE.OpCode.Stelem_i:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.IntNativeRef));                              break;                          case PE.OpCode.Stelem_r4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.SingleRef));                              break;                          case PE.OpCode.Stelem_r8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.DoubleRef));                              break;                          case PE.OpCode.Stelem: // aka stelem.any                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Readonly:                              if (i >= ctxt.Instructions.Length)                                  throw new InvalidOperationException("invalid instruction");                              instruction = ctxt.Instructions[i++];                              if (instruction.OpCode != PE.OpCode.Ldelema)                                  throw new InvalidOperationException("invalid instruction");                              instructions.Add(new LdElemAddrInstruction(offset' true' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Ldelema:                              instructions.Add(new LdElemAddrInstruction(offset' false' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Ldc_i4_0:                              instructions.Add(new LdInt32Instruction(offset' 0));                              break;                          case PE.OpCode.Ldc_i4_1:                              instructions.Add(new LdInt32Instruction(offset' 1));                              break;                          case PE.OpCode.Ldc_i4_2:                              instructions.Add(new LdInt32Instruction(offset' 2));                              break;                          case PE.OpCode.Ldc_i4_3:                              instructions.Add(new LdInt32Instruction(offset' 3));                              break;                          case PE.OpCode.Ldc_i4_4:                              instructions.Add(new LdInt32Instruction(offset' 4));                              break;                          case PE.OpCode.Ldc_i4_5:                              instructions.Add(new LdInt32Instruction(offset' 5));                              break;                          case PE.OpCode.Ldc_i4_6:                              instructions.Add(new LdInt32Instruction(offset' 6));                              break;                          case PE.OpCode.Ldc_i4_7:                              instructions.Add(new LdInt32Instruction(offset' 7));                              break;                          case PE.OpCode.Ldc_i4_8:                              instructions.Add(new LdInt32Instruction(offset' 8));                              break;                          case PE.OpCode.Ldc_i4_m1:                              instructions.Add(new LdInt32Instruction(offset' -1));                              break;                          case PE.OpCode.Ldc_i4:                          case PE.OpCode.Ldc_i4_s:                              instructions.Add(new LdInt32Instruction(offset' (int)instruction.Value));                              break;                          case PE.OpCode.Ldc_i8:                              instructions.Add(new LdInt64Instruction(offset' (long)instruction.Value));                              break;                          case PE.OpCode.Ldc_r4:                              instructions.Add(new LdSingleInstruction(offset' (float)instruction.Value));                              break;                          case PE.OpCode.Ldc_r8:                              instructions.Add(new LdDoubleInstruction(offset' (double)instruction.Value));                              break;                          case PE.OpCode.Ldstr:                              instructions.Add(new LdStringInstruction(offset' (string)instruction.Value));                              break;                          case PE.OpCode.Add:                              instructions.Add(new ArithInstruction(offset' ArithOp.Add' false' false));                              break;                          case PE.OpCode.Add_ovf:                              instructions.Add(new ArithInstruction(offset' ArithOp.Add' true' false));                              break;                          case PE.OpCode.Add_ovf_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Add' true' true));                              break;                          case PE.OpCode.Sub:                              instructions.Add(new ArithInstruction(offset' ArithOp.Sub' false' false));                              break;                          case PE.OpCode.Sub_ovf:                              instructions.Add(new ArithInstruction(offset' ArithOp.Sub' true' false));                              break;                          case PE.OpCode.Sub_ovf_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Sub' true' true));                              break;                          case PE.OpCode.Mul:                              instructions.Add(new ArithInstruction(offset' ArithOp.Mul' false' false));                              break;                          case PE.OpCode.Mul_ovf:                              instructions.Add(new ArithInstruction(offset' ArithOp.Mul' true' false));                              break;                          case PE.OpCode.Mul_ovf_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Mul' true' true));                              break;                          case PE.OpCode.Div:                              instructions.Add(new ArithInstruction(offset' ArithOp.Div' false' false));                              break;                          case PE.OpCode.Div_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Div' false' true));                              break;                          case PE.OpCode.Rem:                              instructions.Add(new ArithInstruction(offset' ArithOp.Rem' false' false));                              break;                          case PE.OpCode.Rem_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Rem' false' true));                              break;                          case PE.OpCode.Neg:                              instructions.Add(new ArithInstruction(offset' ArithOp.Neg' false' false));                              break;                          case PE.OpCode.And:                              instructions.Add(new ArithInstruction(offset' ArithOp.BitAnd' false' false));                              break;                          case PE.OpCode.Or:                              instructions.Add(new ArithInstruction(offset' ArithOp.BitOr' false' false));                              break;                          case PE.OpCode.Xor:                              instructions.Add(new ArithInstruction(offset' ArithOp.BitXor' false' false));                              break;                          case PE.OpCode.Not:                              instructions.Add(new ArithInstruction(offset' ArithOp.BitNot' false' false));                              break;                          case PE.OpCode.Shl:                              instructions.Add(new ArithInstruction(offset' ArithOp.Shl' false' false));                              break;                          case PE.OpCode.Shr:                              instructions.Add(new ArithInstruction(offset' ArithOp.Shr' false' false));                              break;                          case PE.OpCode.Shr_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Shr' false' true));                              break;                          case PE.OpCode.Conv_i1:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int8' false' false));                              break;                          case PE.OpCode.Conv_u1:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt8' false' false));                              break;                          case PE.OpCode.Conv_i2:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int16' false' false));                              break;                          case PE.OpCode.Conv_u2:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt16' false' false));                              break;                          case PE.OpCode.Conv_i4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int32' false' false));                              break;                          case PE.OpCode.Conv_u4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt32' false' false));                              break;                          case PE.OpCode.Conv_i8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int64' false' false));                              break;                          case PE.OpCode.Conv_u8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt64' false' false));                              break;                          case PE.OpCode.Conv_i:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.IntNative' false' false));                              break;                          case PE.OpCode.Conv_u:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UIntNative' false' false));                              break;                          case PE.OpCode.Conv_r4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Single' false' false));                              break;                          case PE.OpCode.Conv_r8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Double' false' false));                              break;                          case PE.OpCode.Conv_r_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Double' false' true));                              break;                          case PE.OpCode.Conv_ovf_i1:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int8' true' false));                              break;                          case PE.OpCode.Conv_ovf_u1:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt8' true' false));                              break;                          case PE.OpCode.Conv_ovf_i2:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int16' true' false));                              break;                          case PE.OpCode.Conv_ovf_u2:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt16' true' false));                              break;                          case PE.OpCode.Conv_ovf_i4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int32' true' false));                              break;                          case PE.OpCode.Conv_ovf_u4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt32' true' false));                              break;                          case PE.OpCode.Conv_ovf_i8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int64' true' false));                              break;                          case PE.OpCode.Conv_ovf_u8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt64' true' false));                              break;                          case PE.OpCode.Conv_ovf_i:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.IntNative' true' false));                              break;                          case PE.OpCode.Conv_ovf_u:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UIntNative' true' false));                              break;                          case PE.OpCode.Conv_ovf_i1_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int8' true' true));                              break;                          case PE.OpCode.Conv_ovf_u1_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt8' true' true));                              break;                          case PE.OpCode.Conv_ovf_i2_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int16' true' true));                              break;                          case PE.OpCode.Conv_ovf_u2_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt16' true' true));                              break;                          case PE.OpCode.Conv_ovf_i4_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int32' true' true));                              break;                          case PE.OpCode.Conv_ovf_u4_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt32' true' true));                              break;                          case PE.OpCode.Conv_ovf_i8_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int64' true' true));                              break;                          case PE.OpCode.Conv_ovf_u8_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt64' true' true));                              break;                          case PE.OpCode.Conv_ovf_i_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.IntNative' true' true));                              break;                          case PE.OpCode.Conv_ovf_u_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UIntNative' true' true));                              break;                          default:                              throw new InvalidOperationException("invalid instruction");                            }                      }                  }              }
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: while (!ctxt.AtEnd(i))              {                  var j = i > ctxt.Start ? ctxt.JumpOverHandlers(i) : i;                  if (j > i)                      i = j;                  else                  {                      var ehcs = ctxt.OutermostTryBlocks(i);                      if (ehcs != null)                      {                          // A try instruction begins here with given handlers                          var offset = ctxt.Instructions[i].Offset;                          var tryCtxt = new TryTranslationContext(ctxt' i' ehcs);                          var tryBlock = InstructionsFromContext(tryCtxt);                            var handlers = new Seq<TryInstructionHandler>();                          foreach (var ehc in ehcs)                          {                              var handlerCtxt = new HandlerTranslationContext                                  (tryCtxt' ctxt.OffsetToIndex[ehc.HandlerOffset]' ehc);                              var handlerBlock = InstructionsFromContext(handlerCtxt);                              switch (ehc.Flags)                              {                              case PE.CorILExceptionClause.Exception:                                  handlers.Add(new CatchTryInstructionHandler((TypeRef)ehc.Class' handlerBlock));                                  break;                              case PE.CorILExceptionClause.Filter:                                  {                                      var filterCtxt = new FilterTranslationContext                                          (tryCtxt' ctxt.OffsetToIndex[ehc.FilterOffset]' ehc);                                      var filterBlock = InstructionsFromContext(filterCtxt);                                      handlers.Add(new FilterTryInstructionHandler(filterBlock' handlerBlock));                                      break;                                  }                              case PE.CorILExceptionClause.Finally:                                  handlers.Add(new FinallyTryInstructionHandler(handlerBlock));                                  break;                              case PE.CorILExceptionClause.Fault:                                  handlers.Add(new FaultTryInstructionHandler(handlerBlock));                                  break;                              default:                                  throw new ArgumentOutOfRangeException();                              }                          }                          instructions.Add(new TryInstruction(offset' tryBlock' handlers));                            // Jump over try block                          var nextOffset = ehcs[0].TryOffset + ehcs[0].TryLength;                          if (!ctxt.OffsetToIndex.TryGetValue(nextOffset' out i))                              i = ctxt.Instructions.Length;                      }                      else                      {                          var instruction = ctxt.Instructions[i++];                          var offset = instruction.Offset;                            while (instruction.OpCode == PE.OpCode.Unaligned || instruction.OpCode == PE.OpCode.Volatile ||                                 instruction.OpCode == PE.OpCode.Tailcall)                          {                              // Skip over any ignored prefixes' but remember instruction begins at original offset                              // NOTE: What ever happened to the "no." prefix mentioned in the spec?                              if (i >= ctxt.Instructions.Length)                                  throw new InvalidOperationException("invalid instructions");                              instruction = ctxt.Instructions[i++];                          }                          switch (instruction.OpCode)                          {                          case PE.OpCode.Cpblk:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Cpblk));                              break;                          case PE.OpCode.Initblk:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Initblk));                              break;                          case PE.OpCode.Arglist:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Arglist));                              break;                          case PE.OpCode.Localloc:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Localloc));                              break;                          case PE.OpCode.Jmp:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Jmp));                              break;                          case PE.OpCode.Calli:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Calli));                              break;                          case PE.OpCode.Sizeof:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Sizeof));                              break;                          case PE.OpCode.Mkrefany:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Mkrefany));                              break;                          case PE.OpCode.Refanytype:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Refanytype));                              break;                          case PE.OpCode.Refanyval:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Refanyval));                              break;                          case PE.OpCode.Nop:                              instructions.Add(new MiscInstruction(offset' MiscOp.Nop));                              break;                          case PE.OpCode.Break:                              instructions.Add(new MiscInstruction(offset' MiscOp.Break));                              break;                          case PE.OpCode.Dup:                              instructions.Add(new MiscInstruction(offset' MiscOp.Dup));                              break;                          case PE.OpCode.Pop:                              instructions.Add(new MiscInstruction(offset' MiscOp.Pop));                              break;                          case PE.OpCode.Ldnull:                              instructions.Add(new MiscInstruction(offset' MiscOp.Ldnull));                              break;                          case PE.OpCode.Ckfinite:                              instructions.Add(new MiscInstruction(offset' MiscOp.Ckfinite));                              break;                          case PE.OpCode.Throw:                              instructions.Add(new MiscInstruction(offset' MiscOp.Throw));                              break;                          case PE.OpCode.Rethrow:                              instructions.Add(new MiscInstruction(offset' MiscOp.Rethrow));                              break;                          case PE.OpCode.Ldind_ref:                              instructions.Add(new MiscInstruction(offset' MiscOp.LdindRef));                              break;                          case PE.OpCode.Stind_ref:                              instructions.Add(new MiscInstruction(offset' MiscOp.StindRef));                              break;                          case PE.OpCode.Ldelem_ref:                              instructions.Add(new MiscInstruction(offset' MiscOp.LdelemRef));                              break;                          case PE.OpCode.Stelem_ref:                              instructions.Add(new MiscInstruction(offset' MiscOp.StelemRef));                              break;                          case PE.OpCode.Ldlen:                              instructions.Add(new MiscInstruction(offset' MiscOp.Ldlen));                              break;                          case PE.OpCode.Ret:                              if (ctxt.ResultType == null)                                  instructions.Add(new MiscInstruction(offset' MiscOp.Ret));                              else                                  instructions.Add(new MiscInstruction(offset' MiscOp.RetVal));                              break;                          case PE.OpCode.Endfilter:                              instructions.Add(new MiscInstruction(offset' MiscOp.Endfilter));                              break;                          case PE.OpCode.Endfinally: // aka EndFault                              instructions.Add(new MiscInstruction(offset' MiscOp.Endfinally));                              break;                          case PE.OpCode.Br_s:                          case PE.OpCode.Br:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Br' false' (int)instruction.Value));                              break;                          case PE.OpCode.Brtrue_s: // aka brinst.s                          case PE.OpCode.Brtrue: // aka brinst                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Brtrue' false' (int)instruction.Value));                              break;                          case PE.OpCode.Brfalse_s: // aka brzero.s' brnull.s                          case PE.OpCode.Brfalse: // aka brzero' brnull                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Brfalse' false' (int)instruction.Value));                              break;                          case PE.OpCode.Beq:                          case PE.OpCode.Beq_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Breq' false' (int)instruction.Value));                              break;                          case PE.OpCode.Bne_un:                          case PE.OpCode.Bne_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Brne' false' (int)instruction.Value));                              break;                          case PE.OpCode.Leave:                          case PE.OpCode.Leave_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Leave' false' (int)instruction.Value));                              break;                          case PE.OpCode.Blt:                          case PE.OpCode.Blt_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrLt' false' (int)instruction.Value));                              break;                          case PE.OpCode.Blt_un:                          case PE.OpCode.Blt_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrLt' true' (int)instruction.Value));                              break;                          case PE.OpCode.Ble:                          case PE.OpCode.Ble_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrLe' false' (int)instruction.Value));                              break;                          case PE.OpCode.Ble_un:                          case PE.OpCode.Ble_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrLe' true' (int)instruction.Value));                              break;                          case PE.OpCode.Bgt:                          case PE.OpCode.Bgt_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrGt' false' (int)instruction.Value));                              break;                          case PE.OpCode.Bgt_un:                          case PE.OpCode.Bgt_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrGt' true' (int)instruction.Value));                              break;                          case PE.OpCode.Bge:                          case PE.OpCode.Bge_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrGe' false' (int)instruction.Value));                              break;                          case PE.OpCode.Bge_un:                          case PE.OpCode.Bge_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrGe' true' (int)instruction.Value));                              break;                          case PE.OpCode.Switch:                              instructions.Add(new SwitchInstruction(offset' (Seq<int>)instruction.Value));                              break;                          case PE.OpCode.Ceq:                              instructions.Add(new CompareInstruction(offset' CompareOp.Ceq' false));                              break;                          case PE.OpCode.Clt:                              instructions.Add(new CompareInstruction(offset' CompareOp.Clt' false));                              break;                          case PE.OpCode.Clt_un:                              instructions.Add(new CompareInstruction(offset' CompareOp.Clt' true));                              break;                          case PE.OpCode.Cgt:                              instructions.Add(new CompareInstruction(offset' CompareOp.Cgt' false));                              break;                          case PE.OpCode.Cgt_un:                              instructions.Add(new CompareInstruction(offset' CompareOp.Cgt' true));                              break;                          case PE.OpCode.Ldarg_0:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));                              break;                          case PE.OpCode.Ldarg_1:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));                              break;                          case PE.OpCode.Ldarg_2:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));                              break;                          case PE.OpCode.Ldarg_3:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));                              break;                          case PE.OpCode.Ldarg:                          case PE.OpCode.Ldarg_s:                              instructions.Add                                  (new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));                              break;                          case PE.OpCode.Ldarga:                          case PE.OpCode.Ldarga_s:                              instructions.Add                                  (new ArgLocalInstruction(offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));                              break;                          case PE.OpCode.Starg:                          case PE.OpCode.Starg_s:                              instructions.Add                                  (new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));                              break;                          case PE.OpCode.Ldloc_0:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Local' 0));                              break;                          case PE.OpCode.Ldloc_1:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Local' 1));                              break;                          case PE.OpCode.Ldloc_2:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Local' 2));                              break;                          case PE.OpCode.Ldloc_3:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Local' 3));                              break;                          case PE.OpCode.Ldloc:                          case PE.OpCode.Ldloc_s:                              instructions.Add                                  (new ArgLocalInstruction                                       (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));                              break;                          case PE.OpCode.Ldloca:                          case PE.OpCode.Ldloca_s:                              instructions.Add                                  (new ArgLocalInstruction                                       (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));                              break;                          case PE.OpCode.Stloc_0:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Local' 0));                              break;                          case PE.OpCode.Stloc_1:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Local' 1));                              break;                          case PE.OpCode.Stloc_2:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Local' 2));                              break;                          case PE.OpCode.Stloc_3:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Local' 3));                              break;                          case PE.OpCode.Stloc:                          case PE.OpCode.Stloc_s:                              instructions.Add                                  (new ArgLocalInstruction                                       (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));                              break;                          case PE.OpCode.Ldfld:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));                              break;                          case PE.OpCode.Ldsfld:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));                              break;                          case PE.OpCode.Ldflda:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));                              break;                          case PE.OpCode.Ldsflda:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));                              break;                          case PE.OpCode.Stfld:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));                              break;                          case PE.OpCode.Stsfld:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));                              break;                          case PE.OpCode.Ldtoken:                              {                                  if (instruction.Value is FieldRef)                                      instructions.Add                                          (new FieldInstruction                                               (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));                                  else if (instruction.Value is MethodRef)                                      instructions.Add                                          (new MethodInstruction                                               (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));                                  else if (instruction.Value is TypeRef)                                      // NOTE: May be a higher-kinded type                                      instructions.Add                                          (new TypeInstruction(offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));                                  else                                      throw new InvalidOperationException("unexpected ldtoken instruction value");                                  break;                              }                          case PE.OpCode.Constrained:                              {                                  var constrained = (TypeRef)instruction.Value;                                  if (i >= ctxt.Instructions.Length)                                      throw new InvalidOperationException("invalid instructions");                                  instruction = ctxt.Instructions[i++];                                  if (instruction.OpCode != PE.OpCode.Callvirt)                                      throw new InvalidOperationException("invalid instruction");                                  instructions.Add                                      (new MethodInstruction                                           (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));                                  break;                              }                          case PE.OpCode.Call:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Callvirt:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Ldftn:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Ldvirtftn:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Newobj:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Ldind_i1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.Int8Ref));                              break;                          case PE.OpCode.Ldind_u1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.UInt8Ref));                              break;                          case PE.OpCode.Ldind_i2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.Int16Ref));                              break;                          case PE.OpCode.Ldind_u2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.UInt16Ref));                              break;                          case PE.OpCode.Ldind_i4:                          case PE.OpCode.Ldind_u4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.Int32Ref));                              break;                          case PE.OpCode.Ldind_i8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.Int64Ref));                              break;                          case PE.OpCode.Ldind_i:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.IntNativeRef));                              break;                          case PE.OpCode.Ldind_r4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.SingleRef));                              break;                          case PE.OpCode.Ldind_r8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.DoubleRef));                              break;                          case PE.OpCode.Ldobj:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Stind_i1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.Int8Ref));                              break;                          case PE.OpCode.Stind_i2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.Int16Ref));                              break;                          case PE.OpCode.Stind_i4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.Int32Ref));                              break;                          case PE.OpCode.Stind_i8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.Int64Ref));                              break;                          case PE.OpCode.Stind_i:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.IntNativeRef));                              break;                          case PE.OpCode.Stind_r4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.SingleRef));                              break;                          case PE.OpCode.Stind_r8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.DoubleRef));                              break;                          case PE.OpCode.Stobj:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Cpobj:                              instructions.Add(new TypeInstruction(offset' TypeOp.Cpobj' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Newarr:                              instructions.Add(new TypeInstruction(offset' TypeOp.Newarr' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Initobj:                              instructions.Add(new TypeInstruction(offset' TypeOp.Initobj' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Castclass:                              instructions.Add                                  (new TypeInstruction(offset' TypeOp.Castclass' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Isinst:                              instructions.Add(new TypeInstruction(offset' TypeOp.Isinst' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Box:                              instructions.Add(new TypeInstruction(offset' TypeOp.Box' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Unbox:                              instructions.Add(new TypeInstruction(offset' TypeOp.Unbox' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Unbox_any:                              instructions.Add(new TypeInstruction(offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Ldelem_i1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.Int8Ref));                              break;                          case PE.OpCode.Ldelem_u1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.UInt8Ref));                              break;                          case PE.OpCode.Ldelem_i2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.Int16Ref));                              break;                          case PE.OpCode.Ldelem_u2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.UInt16Ref));                              break;                          case PE.OpCode.Ldelem_i4:                          case PE.OpCode.Ldelem_u4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.Int32Ref));                              break;                          case PE.OpCode.Ldelem_i:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.IntNativeRef));                              break;                          case PE.OpCode.Ldelem_i8: // aka ldelem.u8                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.Int64Ref));                              break;                          case PE.OpCode.Ldelem_r4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.SingleRef));                              break;                          case PE.OpCode.Ldelem_r8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.DoubleRef));                              break;                          case PE.OpCode.Ldelem: // aka ldelem.any                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Stelem_i1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.Int8Ref));                              break;                          case PE.OpCode.Stelem_i2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.Int16Ref));                              break;                          case PE.OpCode.Stelem_i4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.Int32Ref));                              break;                          case PE.OpCode.Stelem_i8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.Int64Ref));                              break;                          case PE.OpCode.Stelem_i:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.IntNativeRef));                              break;                          case PE.OpCode.Stelem_r4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.SingleRef));                              break;                          case PE.OpCode.Stelem_r8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.DoubleRef));                              break;                          case PE.OpCode.Stelem: // aka stelem.any                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Readonly:                              if (i >= ctxt.Instructions.Length)                                  throw new InvalidOperationException("invalid instruction");                              instruction = ctxt.Instructions[i++];                              if (instruction.OpCode != PE.OpCode.Ldelema)                                  throw new InvalidOperationException("invalid instruction");                              instructions.Add(new LdElemAddrInstruction(offset' true' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Ldelema:                              instructions.Add(new LdElemAddrInstruction(offset' false' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Ldc_i4_0:                              instructions.Add(new LdInt32Instruction(offset' 0));                              break;                          case PE.OpCode.Ldc_i4_1:                              instructions.Add(new LdInt32Instruction(offset' 1));                              break;                          case PE.OpCode.Ldc_i4_2:                              instructions.Add(new LdInt32Instruction(offset' 2));                              break;                          case PE.OpCode.Ldc_i4_3:                              instructions.Add(new LdInt32Instruction(offset' 3));                              break;                          case PE.OpCode.Ldc_i4_4:                              instructions.Add(new LdInt32Instruction(offset' 4));                              break;                          case PE.OpCode.Ldc_i4_5:                              instructions.Add(new LdInt32Instruction(offset' 5));                              break;                          case PE.OpCode.Ldc_i4_6:                              instructions.Add(new LdInt32Instruction(offset' 6));                              break;                          case PE.OpCode.Ldc_i4_7:                              instructions.Add(new LdInt32Instruction(offset' 7));                              break;                          case PE.OpCode.Ldc_i4_8:                              instructions.Add(new LdInt32Instruction(offset' 8));                              break;                          case PE.OpCode.Ldc_i4_m1:                              instructions.Add(new LdInt32Instruction(offset' -1));                              break;                          case PE.OpCode.Ldc_i4:                          case PE.OpCode.Ldc_i4_s:                              instructions.Add(new LdInt32Instruction(offset' (int)instruction.Value));                              break;                          case PE.OpCode.Ldc_i8:                              instructions.Add(new LdInt64Instruction(offset' (long)instruction.Value));                              break;                          case PE.OpCode.Ldc_r4:                              instructions.Add(new LdSingleInstruction(offset' (float)instruction.Value));                              break;                          case PE.OpCode.Ldc_r8:                              instructions.Add(new LdDoubleInstruction(offset' (double)instruction.Value));                              break;                          case PE.OpCode.Ldstr:                              instructions.Add(new LdStringInstruction(offset' (string)instruction.Value));                              break;                          case PE.OpCode.Add:                              instructions.Add(new ArithInstruction(offset' ArithOp.Add' false' false));                              break;                          case PE.OpCode.Add_ovf:                              instructions.Add(new ArithInstruction(offset' ArithOp.Add' true' false));                              break;                          case PE.OpCode.Add_ovf_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Add' true' true));                              break;                          case PE.OpCode.Sub:                              instructions.Add(new ArithInstruction(offset' ArithOp.Sub' false' false));                              break;                          case PE.OpCode.Sub_ovf:                              instructions.Add(new ArithInstruction(offset' ArithOp.Sub' true' false));                              break;                          case PE.OpCode.Sub_ovf_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Sub' true' true));                              break;                          case PE.OpCode.Mul:                              instructions.Add(new ArithInstruction(offset' ArithOp.Mul' false' false));                              break;                          case PE.OpCode.Mul_ovf:                              instructions.Add(new ArithInstruction(offset' ArithOp.Mul' true' false));                              break;                          case PE.OpCode.Mul_ovf_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Mul' true' true));                              break;                          case PE.OpCode.Div:                              instructions.Add(new ArithInstruction(offset' ArithOp.Div' false' false));                              break;                          case PE.OpCode.Div_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Div' false' true));                              break;                          case PE.OpCode.Rem:                              instructions.Add(new ArithInstruction(offset' ArithOp.Rem' false' false));                              break;                          case PE.OpCode.Rem_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Rem' false' true));                              break;                          case PE.OpCode.Neg:                              instructions.Add(new ArithInstruction(offset' ArithOp.Neg' false' false));                              break;                          case PE.OpCode.And:                              instructions.Add(new ArithInstruction(offset' ArithOp.BitAnd' false' false));                              break;                          case PE.OpCode.Or:                              instructions.Add(new ArithInstruction(offset' ArithOp.BitOr' false' false));                              break;                          case PE.OpCode.Xor:                              instructions.Add(new ArithInstruction(offset' ArithOp.BitXor' false' false));                              break;                          case PE.OpCode.Not:                              instructions.Add(new ArithInstruction(offset' ArithOp.BitNot' false' false));                              break;                          case PE.OpCode.Shl:                              instructions.Add(new ArithInstruction(offset' ArithOp.Shl' false' false));                              break;                          case PE.OpCode.Shr:                              instructions.Add(new ArithInstruction(offset' ArithOp.Shr' false' false));                              break;                          case PE.OpCode.Shr_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Shr' false' true));                              break;                          case PE.OpCode.Conv_i1:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int8' false' false));                              break;                          case PE.OpCode.Conv_u1:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt8' false' false));                              break;                          case PE.OpCode.Conv_i2:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int16' false' false));                              break;                          case PE.OpCode.Conv_u2:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt16' false' false));                              break;                          case PE.OpCode.Conv_i4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int32' false' false));                              break;                          case PE.OpCode.Conv_u4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt32' false' false));                              break;                          case PE.OpCode.Conv_i8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int64' false' false));                              break;                          case PE.OpCode.Conv_u8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt64' false' false));                              break;                          case PE.OpCode.Conv_i:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.IntNative' false' false));                              break;                          case PE.OpCode.Conv_u:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UIntNative' false' false));                              break;                          case PE.OpCode.Conv_r4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Single' false' false));                              break;                          case PE.OpCode.Conv_r8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Double' false' false));                              break;                          case PE.OpCode.Conv_r_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Double' false' true));                              break;                          case PE.OpCode.Conv_ovf_i1:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int8' true' false));                              break;                          case PE.OpCode.Conv_ovf_u1:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt8' true' false));                              break;                          case PE.OpCode.Conv_ovf_i2:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int16' true' false));                              break;                          case PE.OpCode.Conv_ovf_u2:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt16' true' false));                              break;                          case PE.OpCode.Conv_ovf_i4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int32' true' false));                              break;                          case PE.OpCode.Conv_ovf_u4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt32' true' false));                              break;                          case PE.OpCode.Conv_ovf_i8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int64' true' false));                              break;                          case PE.OpCode.Conv_ovf_u8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt64' true' false));                              break;                          case PE.OpCode.Conv_ovf_i:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.IntNative' true' false));                              break;                          case PE.OpCode.Conv_ovf_u:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UIntNative' true' false));                              break;                          case PE.OpCode.Conv_ovf_i1_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int8' true' true));                              break;                          case PE.OpCode.Conv_ovf_u1_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt8' true' true));                              break;                          case PE.OpCode.Conv_ovf_i2_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int16' true' true));                              break;                          case PE.OpCode.Conv_ovf_u2_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt16' true' true));                              break;                          case PE.OpCode.Conv_ovf_i4_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int32' true' true));                              break;                          case PE.OpCode.Conv_ovf_u4_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt32' true' true));                              break;                          case PE.OpCode.Conv_ovf_i8_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int64' true' true));                              break;                          case PE.OpCode.Conv_ovf_u8_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt64' true' true));                              break;                          case PE.OpCode.Conv_ovf_i_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.IntNative' true' true));                              break;                          case PE.OpCode.Conv_ovf_u_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UIntNative' true' true));                              break;                          default:                              throw new InvalidOperationException("invalid instruction");                            }                      }                  }              }
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: while (!ctxt.AtEnd(i))              {                  var j = i > ctxt.Start ? ctxt.JumpOverHandlers(i) : i;                  if (j > i)                      i = j;                  else                  {                      var ehcs = ctxt.OutermostTryBlocks(i);                      if (ehcs != null)                      {                          // A try instruction begins here with given handlers                          var offset = ctxt.Instructions[i].Offset;                          var tryCtxt = new TryTranslationContext(ctxt' i' ehcs);                          var tryBlock = InstructionsFromContext(tryCtxt);                            var handlers = new Seq<TryInstructionHandler>();                          foreach (var ehc in ehcs)                          {                              var handlerCtxt = new HandlerTranslationContext                                  (tryCtxt' ctxt.OffsetToIndex[ehc.HandlerOffset]' ehc);                              var handlerBlock = InstructionsFromContext(handlerCtxt);                              switch (ehc.Flags)                              {                              case PE.CorILExceptionClause.Exception:                                  handlers.Add(new CatchTryInstructionHandler((TypeRef)ehc.Class' handlerBlock));                                  break;                              case PE.CorILExceptionClause.Filter:                                  {                                      var filterCtxt = new FilterTranslationContext                                          (tryCtxt' ctxt.OffsetToIndex[ehc.FilterOffset]' ehc);                                      var filterBlock = InstructionsFromContext(filterCtxt);                                      handlers.Add(new FilterTryInstructionHandler(filterBlock' handlerBlock));                                      break;                                  }                              case PE.CorILExceptionClause.Finally:                                  handlers.Add(new FinallyTryInstructionHandler(handlerBlock));                                  break;                              case PE.CorILExceptionClause.Fault:                                  handlers.Add(new FaultTryInstructionHandler(handlerBlock));                                  break;                              default:                                  throw new ArgumentOutOfRangeException();                              }                          }                          instructions.Add(new TryInstruction(offset' tryBlock' handlers));                            // Jump over try block                          var nextOffset = ehcs[0].TryOffset + ehcs[0].TryLength;                          if (!ctxt.OffsetToIndex.TryGetValue(nextOffset' out i))                              i = ctxt.Instructions.Length;                      }                      else                      {                          var instruction = ctxt.Instructions[i++];                          var offset = instruction.Offset;                            while (instruction.OpCode == PE.OpCode.Unaligned || instruction.OpCode == PE.OpCode.Volatile ||                                 instruction.OpCode == PE.OpCode.Tailcall)                          {                              // Skip over any ignored prefixes' but remember instruction begins at original offset                              // NOTE: What ever happened to the "no." prefix mentioned in the spec?                              if (i >= ctxt.Instructions.Length)                                  throw new InvalidOperationException("invalid instructions");                              instruction = ctxt.Instructions[i++];                          }                          switch (instruction.OpCode)                          {                          case PE.OpCode.Cpblk:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Cpblk));                              break;                          case PE.OpCode.Initblk:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Initblk));                              break;                          case PE.OpCode.Arglist:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Arglist));                              break;                          case PE.OpCode.Localloc:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Localloc));                              break;                          case PE.OpCode.Jmp:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Jmp));                              break;                          case PE.OpCode.Calli:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Calli));                              break;                          case PE.OpCode.Sizeof:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Sizeof));                              break;                          case PE.OpCode.Mkrefany:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Mkrefany));                              break;                          case PE.OpCode.Refanytype:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Refanytype));                              break;                          case PE.OpCode.Refanyval:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Refanyval));                              break;                          case PE.OpCode.Nop:                              instructions.Add(new MiscInstruction(offset' MiscOp.Nop));                              break;                          case PE.OpCode.Break:                              instructions.Add(new MiscInstruction(offset' MiscOp.Break));                              break;                          case PE.OpCode.Dup:                              instructions.Add(new MiscInstruction(offset' MiscOp.Dup));                              break;                          case PE.OpCode.Pop:                              instructions.Add(new MiscInstruction(offset' MiscOp.Pop));                              break;                          case PE.OpCode.Ldnull:                              instructions.Add(new MiscInstruction(offset' MiscOp.Ldnull));                              break;                          case PE.OpCode.Ckfinite:                              instructions.Add(new MiscInstruction(offset' MiscOp.Ckfinite));                              break;                          case PE.OpCode.Throw:                              instructions.Add(new MiscInstruction(offset' MiscOp.Throw));                              break;                          case PE.OpCode.Rethrow:                              instructions.Add(new MiscInstruction(offset' MiscOp.Rethrow));                              break;                          case PE.OpCode.Ldind_ref:                              instructions.Add(new MiscInstruction(offset' MiscOp.LdindRef));                              break;                          case PE.OpCode.Stind_ref:                              instructions.Add(new MiscInstruction(offset' MiscOp.StindRef));                              break;                          case PE.OpCode.Ldelem_ref:                              instructions.Add(new MiscInstruction(offset' MiscOp.LdelemRef));                              break;                          case PE.OpCode.Stelem_ref:                              instructions.Add(new MiscInstruction(offset' MiscOp.StelemRef));                              break;                          case PE.OpCode.Ldlen:                              instructions.Add(new MiscInstruction(offset' MiscOp.Ldlen));                              break;                          case PE.OpCode.Ret:                              if (ctxt.ResultType == null)                                  instructions.Add(new MiscInstruction(offset' MiscOp.Ret));                              else                                  instructions.Add(new MiscInstruction(offset' MiscOp.RetVal));                              break;                          case PE.OpCode.Endfilter:                              instructions.Add(new MiscInstruction(offset' MiscOp.Endfilter));                              break;                          case PE.OpCode.Endfinally: // aka EndFault                              instructions.Add(new MiscInstruction(offset' MiscOp.Endfinally));                              break;                          case PE.OpCode.Br_s:                          case PE.OpCode.Br:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Br' false' (int)instruction.Value));                              break;                          case PE.OpCode.Brtrue_s: // aka brinst.s                          case PE.OpCode.Brtrue: // aka brinst                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Brtrue' false' (int)instruction.Value));                              break;                          case PE.OpCode.Brfalse_s: // aka brzero.s' brnull.s                          case PE.OpCode.Brfalse: // aka brzero' brnull                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Brfalse' false' (int)instruction.Value));                              break;                          case PE.OpCode.Beq:                          case PE.OpCode.Beq_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Breq' false' (int)instruction.Value));                              break;                          case PE.OpCode.Bne_un:                          case PE.OpCode.Bne_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Brne' false' (int)instruction.Value));                              break;                          case PE.OpCode.Leave:                          case PE.OpCode.Leave_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Leave' false' (int)instruction.Value));                              break;                          case PE.OpCode.Blt:                          case PE.OpCode.Blt_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrLt' false' (int)instruction.Value));                              break;                          case PE.OpCode.Blt_un:                          case PE.OpCode.Blt_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrLt' true' (int)instruction.Value));                              break;                          case PE.OpCode.Ble:                          case PE.OpCode.Ble_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrLe' false' (int)instruction.Value));                              break;                          case PE.OpCode.Ble_un:                          case PE.OpCode.Ble_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrLe' true' (int)instruction.Value));                              break;                          case PE.OpCode.Bgt:                          case PE.OpCode.Bgt_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrGt' false' (int)instruction.Value));                              break;                          case PE.OpCode.Bgt_un:                          case PE.OpCode.Bgt_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrGt' true' (int)instruction.Value));                              break;                          case PE.OpCode.Bge:                          case PE.OpCode.Bge_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrGe' false' (int)instruction.Value));                              break;                          case PE.OpCode.Bge_un:                          case PE.OpCode.Bge_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrGe' true' (int)instruction.Value));                              break;                          case PE.OpCode.Switch:                              instructions.Add(new SwitchInstruction(offset' (Seq<int>)instruction.Value));                              break;                          case PE.OpCode.Ceq:                              instructions.Add(new CompareInstruction(offset' CompareOp.Ceq' false));                              break;                          case PE.OpCode.Clt:                              instructions.Add(new CompareInstruction(offset' CompareOp.Clt' false));                              break;                          case PE.OpCode.Clt_un:                              instructions.Add(new CompareInstruction(offset' CompareOp.Clt' true));                              break;                          case PE.OpCode.Cgt:                              instructions.Add(new CompareInstruction(offset' CompareOp.Cgt' false));                              break;                          case PE.OpCode.Cgt_un:                              instructions.Add(new CompareInstruction(offset' CompareOp.Cgt' true));                              break;                          case PE.OpCode.Ldarg_0:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));                              break;                          case PE.OpCode.Ldarg_1:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));                              break;                          case PE.OpCode.Ldarg_2:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));                              break;                          case PE.OpCode.Ldarg_3:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));                              break;                          case PE.OpCode.Ldarg:                          case PE.OpCode.Ldarg_s:                              instructions.Add                                  (new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));                              break;                          case PE.OpCode.Ldarga:                          case PE.OpCode.Ldarga_s:                              instructions.Add                                  (new ArgLocalInstruction(offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));                              break;                          case PE.OpCode.Starg:                          case PE.OpCode.Starg_s:                              instructions.Add                                  (new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));                              break;                          case PE.OpCode.Ldloc_0:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Local' 0));                              break;                          case PE.OpCode.Ldloc_1:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Local' 1));                              break;                          case PE.OpCode.Ldloc_2:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Local' 2));                              break;                          case PE.OpCode.Ldloc_3:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Local' 3));                              break;                          case PE.OpCode.Ldloc:                          case PE.OpCode.Ldloc_s:                              instructions.Add                                  (new ArgLocalInstruction                                       (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));                              break;                          case PE.OpCode.Ldloca:                          case PE.OpCode.Ldloca_s:                              instructions.Add                                  (new ArgLocalInstruction                                       (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));                              break;                          case PE.OpCode.Stloc_0:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Local' 0));                              break;                          case PE.OpCode.Stloc_1:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Local' 1));                              break;                          case PE.OpCode.Stloc_2:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Local' 2));                              break;                          case PE.OpCode.Stloc_3:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Local' 3));                              break;                          case PE.OpCode.Stloc:                          case PE.OpCode.Stloc_s:                              instructions.Add                                  (new ArgLocalInstruction                                       (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));                              break;                          case PE.OpCode.Ldfld:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));                              break;                          case PE.OpCode.Ldsfld:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));                              break;                          case PE.OpCode.Ldflda:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));                              break;                          case PE.OpCode.Ldsflda:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));                              break;                          case PE.OpCode.Stfld:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));                              break;                          case PE.OpCode.Stsfld:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));                              break;                          case PE.OpCode.Ldtoken:                              {                                  if (instruction.Value is FieldRef)                                      instructions.Add                                          (new FieldInstruction                                               (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));                                  else if (instruction.Value is MethodRef)                                      instructions.Add                                          (new MethodInstruction                                               (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));                                  else if (instruction.Value is TypeRef)                                      // NOTE: May be a higher-kinded type                                      instructions.Add                                          (new TypeInstruction(offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));                                  else                                      throw new InvalidOperationException("unexpected ldtoken instruction value");                                  break;                              }                          case PE.OpCode.Constrained:                              {                                  var constrained = (TypeRef)instruction.Value;                                  if (i >= ctxt.Instructions.Length)                                      throw new InvalidOperationException("invalid instructions");                                  instruction = ctxt.Instructions[i++];                                  if (instruction.OpCode != PE.OpCode.Callvirt)                                      throw new InvalidOperationException("invalid instruction");                                  instructions.Add                                      (new MethodInstruction                                           (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));                                  break;                              }                          case PE.OpCode.Call:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Callvirt:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Ldftn:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Ldvirtftn:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Newobj:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Ldind_i1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.Int8Ref));                              break;                          case PE.OpCode.Ldind_u1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.UInt8Ref));                              break;                          case PE.OpCode.Ldind_i2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.Int16Ref));                              break;                          case PE.OpCode.Ldind_u2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.UInt16Ref));                              break;                          case PE.OpCode.Ldind_i4:                          case PE.OpCode.Ldind_u4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.Int32Ref));                              break;                          case PE.OpCode.Ldind_i8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.Int64Ref));                              break;                          case PE.OpCode.Ldind_i:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.IntNativeRef));                              break;                          case PE.OpCode.Ldind_r4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.SingleRef));                              break;                          case PE.OpCode.Ldind_r8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.DoubleRef));                              break;                          case PE.OpCode.Ldobj:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Stind_i1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.Int8Ref));                              break;                          case PE.OpCode.Stind_i2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.Int16Ref));                              break;                          case PE.OpCode.Stind_i4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.Int32Ref));                              break;                          case PE.OpCode.Stind_i8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.Int64Ref));                              break;                          case PE.OpCode.Stind_i:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.IntNativeRef));                              break;                          case PE.OpCode.Stind_r4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.SingleRef));                              break;                          case PE.OpCode.Stind_r8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.DoubleRef));                              break;                          case PE.OpCode.Stobj:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Cpobj:                              instructions.Add(new TypeInstruction(offset' TypeOp.Cpobj' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Newarr:                              instructions.Add(new TypeInstruction(offset' TypeOp.Newarr' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Initobj:                              instructions.Add(new TypeInstruction(offset' TypeOp.Initobj' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Castclass:                              instructions.Add                                  (new TypeInstruction(offset' TypeOp.Castclass' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Isinst:                              instructions.Add(new TypeInstruction(offset' TypeOp.Isinst' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Box:                              instructions.Add(new TypeInstruction(offset' TypeOp.Box' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Unbox:                              instructions.Add(new TypeInstruction(offset' TypeOp.Unbox' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Unbox_any:                              instructions.Add(new TypeInstruction(offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Ldelem_i1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.Int8Ref));                              break;                          case PE.OpCode.Ldelem_u1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.UInt8Ref));                              break;                          case PE.OpCode.Ldelem_i2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.Int16Ref));                              break;                          case PE.OpCode.Ldelem_u2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.UInt16Ref));                              break;                          case PE.OpCode.Ldelem_i4:                          case PE.OpCode.Ldelem_u4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.Int32Ref));                              break;                          case PE.OpCode.Ldelem_i:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.IntNativeRef));                              break;                          case PE.OpCode.Ldelem_i8: // aka ldelem.u8                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.Int64Ref));                              break;                          case PE.OpCode.Ldelem_r4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.SingleRef));                              break;                          case PE.OpCode.Ldelem_r8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.DoubleRef));                              break;                          case PE.OpCode.Ldelem: // aka ldelem.any                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Stelem_i1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.Int8Ref));                              break;                          case PE.OpCode.Stelem_i2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.Int16Ref));                              break;                          case PE.OpCode.Stelem_i4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.Int32Ref));                              break;                          case PE.OpCode.Stelem_i8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.Int64Ref));                              break;                          case PE.OpCode.Stelem_i:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.IntNativeRef));                              break;                          case PE.OpCode.Stelem_r4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.SingleRef));                              break;                          case PE.OpCode.Stelem_r8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.DoubleRef));                              break;                          case PE.OpCode.Stelem: // aka stelem.any                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Readonly:                              if (i >= ctxt.Instructions.Length)                                  throw new InvalidOperationException("invalid instruction");                              instruction = ctxt.Instructions[i++];                              if (instruction.OpCode != PE.OpCode.Ldelema)                                  throw new InvalidOperationException("invalid instruction");                              instructions.Add(new LdElemAddrInstruction(offset' true' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Ldelema:                              instructions.Add(new LdElemAddrInstruction(offset' false' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Ldc_i4_0:                              instructions.Add(new LdInt32Instruction(offset' 0));                              break;                          case PE.OpCode.Ldc_i4_1:                              instructions.Add(new LdInt32Instruction(offset' 1));                              break;                          case PE.OpCode.Ldc_i4_2:                              instructions.Add(new LdInt32Instruction(offset' 2));                              break;                          case PE.OpCode.Ldc_i4_3:                              instructions.Add(new LdInt32Instruction(offset' 3));                              break;                          case PE.OpCode.Ldc_i4_4:                              instructions.Add(new LdInt32Instruction(offset' 4));                              break;                          case PE.OpCode.Ldc_i4_5:                              instructions.Add(new LdInt32Instruction(offset' 5));                              break;                          case PE.OpCode.Ldc_i4_6:                              instructions.Add(new LdInt32Instruction(offset' 6));                              break;                          case PE.OpCode.Ldc_i4_7:                              instructions.Add(new LdInt32Instruction(offset' 7));                              break;                          case PE.OpCode.Ldc_i4_8:                              instructions.Add(new LdInt32Instruction(offset' 8));                              break;                          case PE.OpCode.Ldc_i4_m1:                              instructions.Add(new LdInt32Instruction(offset' -1));                              break;                          case PE.OpCode.Ldc_i4:                          case PE.OpCode.Ldc_i4_s:                              instructions.Add(new LdInt32Instruction(offset' (int)instruction.Value));                              break;                          case PE.OpCode.Ldc_i8:                              instructions.Add(new LdInt64Instruction(offset' (long)instruction.Value));                              break;                          case PE.OpCode.Ldc_r4:                              instructions.Add(new LdSingleInstruction(offset' (float)instruction.Value));                              break;                          case PE.OpCode.Ldc_r8:                              instructions.Add(new LdDoubleInstruction(offset' (double)instruction.Value));                              break;                          case PE.OpCode.Ldstr:                              instructions.Add(new LdStringInstruction(offset' (string)instruction.Value));                              break;                          case PE.OpCode.Add:                              instructions.Add(new ArithInstruction(offset' ArithOp.Add' false' false));                              break;                          case PE.OpCode.Add_ovf:                              instructions.Add(new ArithInstruction(offset' ArithOp.Add' true' false));                              break;                          case PE.OpCode.Add_ovf_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Add' true' true));                              break;                          case PE.OpCode.Sub:                              instructions.Add(new ArithInstruction(offset' ArithOp.Sub' false' false));                              break;                          case PE.OpCode.Sub_ovf:                              instructions.Add(new ArithInstruction(offset' ArithOp.Sub' true' false));                              break;                          case PE.OpCode.Sub_ovf_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Sub' true' true));                              break;                          case PE.OpCode.Mul:                              instructions.Add(new ArithInstruction(offset' ArithOp.Mul' false' false));                              break;                          case PE.OpCode.Mul_ovf:                              instructions.Add(new ArithInstruction(offset' ArithOp.Mul' true' false));                              break;                          case PE.OpCode.Mul_ovf_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Mul' true' true));                              break;                          case PE.OpCode.Div:                              instructions.Add(new ArithInstruction(offset' ArithOp.Div' false' false));                              break;                          case PE.OpCode.Div_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Div' false' true));                              break;                          case PE.OpCode.Rem:                              instructions.Add(new ArithInstruction(offset' ArithOp.Rem' false' false));                              break;                          case PE.OpCode.Rem_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Rem' false' true));                              break;                          case PE.OpCode.Neg:                              instructions.Add(new ArithInstruction(offset' ArithOp.Neg' false' false));                              break;                          case PE.OpCode.And:                              instructions.Add(new ArithInstruction(offset' ArithOp.BitAnd' false' false));                              break;                          case PE.OpCode.Or:                              instructions.Add(new ArithInstruction(offset' ArithOp.BitOr' false' false));                              break;                          case PE.OpCode.Xor:                              instructions.Add(new ArithInstruction(offset' ArithOp.BitXor' false' false));                              break;                          case PE.OpCode.Not:                              instructions.Add(new ArithInstruction(offset' ArithOp.BitNot' false' false));                              break;                          case PE.OpCode.Shl:                              instructions.Add(new ArithInstruction(offset' ArithOp.Shl' false' false));                              break;                          case PE.OpCode.Shr:                              instructions.Add(new ArithInstruction(offset' ArithOp.Shr' false' false));                              break;                          case PE.OpCode.Shr_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Shr' false' true));                              break;                          case PE.OpCode.Conv_i1:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int8' false' false));                              break;                          case PE.OpCode.Conv_u1:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt8' false' false));                              break;                          case PE.OpCode.Conv_i2:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int16' false' false));                              break;                          case PE.OpCode.Conv_u2:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt16' false' false));                              break;                          case PE.OpCode.Conv_i4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int32' false' false));                              break;                          case PE.OpCode.Conv_u4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt32' false' false));                              break;                          case PE.OpCode.Conv_i8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int64' false' false));                              break;                          case PE.OpCode.Conv_u8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt64' false' false));                              break;                          case PE.OpCode.Conv_i:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.IntNative' false' false));                              break;                          case PE.OpCode.Conv_u:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UIntNative' false' false));                              break;                          case PE.OpCode.Conv_r4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Single' false' false));                              break;                          case PE.OpCode.Conv_r8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Double' false' false));                              break;                          case PE.OpCode.Conv_r_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Double' false' true));                              break;                          case PE.OpCode.Conv_ovf_i1:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int8' true' false));                              break;                          case PE.OpCode.Conv_ovf_u1:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt8' true' false));                              break;                          case PE.OpCode.Conv_ovf_i2:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int16' true' false));                              break;                          case PE.OpCode.Conv_ovf_u2:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt16' true' false));                              break;                          case PE.OpCode.Conv_ovf_i4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int32' true' false));                              break;                          case PE.OpCode.Conv_ovf_u4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt32' true' false));                              break;                          case PE.OpCode.Conv_ovf_i8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int64' true' false));                              break;                          case PE.OpCode.Conv_ovf_u8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt64' true' false));                              break;                          case PE.OpCode.Conv_ovf_i:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.IntNative' true' false));                              break;                          case PE.OpCode.Conv_ovf_u:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UIntNative' true' false));                              break;                          case PE.OpCode.Conv_ovf_i1_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int8' true' true));                              break;                          case PE.OpCode.Conv_ovf_u1_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt8' true' true));                              break;                          case PE.OpCode.Conv_ovf_i2_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int16' true' true));                              break;                          case PE.OpCode.Conv_ovf_u2_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt16' true' true));                              break;                          case PE.OpCode.Conv_ovf_i4_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int32' true' true));                              break;                          case PE.OpCode.Conv_ovf_u4_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt32' true' true));                              break;                          case PE.OpCode.Conv_ovf_i8_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int64' true' true));                              break;                          case PE.OpCode.Conv_ovf_u8_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt64' true' true));                              break;                          case PE.OpCode.Conv_ovf_i_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.IntNative' true' true));                              break;                          case PE.OpCode.Conv_ovf_u_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UIntNative' true' true));                              break;                          default:                              throw new InvalidOperationException("invalid instruction");                            }                      }                  }              }
Magic Number,Microsoft.LiveLabs.CST,InstructionLoader,C:\repos\Reactive-Extensions_IL2JS\CST\InstructionLoader.cs,InstructionsFromContext,The following statement contains a magic number: while (!ctxt.AtEnd(i))              {                  var j = i > ctxt.Start ? ctxt.JumpOverHandlers(i) : i;                  if (j > i)                      i = j;                  else                  {                      var ehcs = ctxt.OutermostTryBlocks(i);                      if (ehcs != null)                      {                          // A try instruction begins here with given handlers                          var offset = ctxt.Instructions[i].Offset;                          var tryCtxt = new TryTranslationContext(ctxt' i' ehcs);                          var tryBlock = InstructionsFromContext(tryCtxt);                            var handlers = new Seq<TryInstructionHandler>();                          foreach (var ehc in ehcs)                          {                              var handlerCtxt = new HandlerTranslationContext                                  (tryCtxt' ctxt.OffsetToIndex[ehc.HandlerOffset]' ehc);                              var handlerBlock = InstructionsFromContext(handlerCtxt);                              switch (ehc.Flags)                              {                              case PE.CorILExceptionClause.Exception:                                  handlers.Add(new CatchTryInstructionHandler((TypeRef)ehc.Class' handlerBlock));                                  break;                              case PE.CorILExceptionClause.Filter:                                  {                                      var filterCtxt = new FilterTranslationContext                                          (tryCtxt' ctxt.OffsetToIndex[ehc.FilterOffset]' ehc);                                      var filterBlock = InstructionsFromContext(filterCtxt);                                      handlers.Add(new FilterTryInstructionHandler(filterBlock' handlerBlock));                                      break;                                  }                              case PE.CorILExceptionClause.Finally:                                  handlers.Add(new FinallyTryInstructionHandler(handlerBlock));                                  break;                              case PE.CorILExceptionClause.Fault:                                  handlers.Add(new FaultTryInstructionHandler(handlerBlock));                                  break;                              default:                                  throw new ArgumentOutOfRangeException();                              }                          }                          instructions.Add(new TryInstruction(offset' tryBlock' handlers));                            // Jump over try block                          var nextOffset = ehcs[0].TryOffset + ehcs[0].TryLength;                          if (!ctxt.OffsetToIndex.TryGetValue(nextOffset' out i))                              i = ctxt.Instructions.Length;                      }                      else                      {                          var instruction = ctxt.Instructions[i++];                          var offset = instruction.Offset;                            while (instruction.OpCode == PE.OpCode.Unaligned || instruction.OpCode == PE.OpCode.Volatile ||                                 instruction.OpCode == PE.OpCode.Tailcall)                          {                              // Skip over any ignored prefixes' but remember instruction begins at original offset                              // NOTE: What ever happened to the "no." prefix mentioned in the spec?                              if (i >= ctxt.Instructions.Length)                                  throw new InvalidOperationException("invalid instructions");                              instruction = ctxt.Instructions[i++];                          }                          switch (instruction.OpCode)                          {                          case PE.OpCode.Cpblk:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Cpblk));                              break;                          case PE.OpCode.Initblk:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Initblk));                              break;                          case PE.OpCode.Arglist:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Arglist));                              break;                          case PE.OpCode.Localloc:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Localloc));                              break;                          case PE.OpCode.Jmp:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Jmp));                              break;                          case PE.OpCode.Calli:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Calli));                              break;                          case PE.OpCode.Sizeof:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Sizeof));                              break;                          case PE.OpCode.Mkrefany:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Mkrefany));                              break;                          case PE.OpCode.Refanytype:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Refanytype));                              break;                          case PE.OpCode.Refanyval:                              instructions.Add(new UnsupportedInstruction(offset' UnsupportedOp.Refanyval));                              break;                          case PE.OpCode.Nop:                              instructions.Add(new MiscInstruction(offset' MiscOp.Nop));                              break;                          case PE.OpCode.Break:                              instructions.Add(new MiscInstruction(offset' MiscOp.Break));                              break;                          case PE.OpCode.Dup:                              instructions.Add(new MiscInstruction(offset' MiscOp.Dup));                              break;                          case PE.OpCode.Pop:                              instructions.Add(new MiscInstruction(offset' MiscOp.Pop));                              break;                          case PE.OpCode.Ldnull:                              instructions.Add(new MiscInstruction(offset' MiscOp.Ldnull));                              break;                          case PE.OpCode.Ckfinite:                              instructions.Add(new MiscInstruction(offset' MiscOp.Ckfinite));                              break;                          case PE.OpCode.Throw:                              instructions.Add(new MiscInstruction(offset' MiscOp.Throw));                              break;                          case PE.OpCode.Rethrow:                              instructions.Add(new MiscInstruction(offset' MiscOp.Rethrow));                              break;                          case PE.OpCode.Ldind_ref:                              instructions.Add(new MiscInstruction(offset' MiscOp.LdindRef));                              break;                          case PE.OpCode.Stind_ref:                              instructions.Add(new MiscInstruction(offset' MiscOp.StindRef));                              break;                          case PE.OpCode.Ldelem_ref:                              instructions.Add(new MiscInstruction(offset' MiscOp.LdelemRef));                              break;                          case PE.OpCode.Stelem_ref:                              instructions.Add(new MiscInstruction(offset' MiscOp.StelemRef));                              break;                          case PE.OpCode.Ldlen:                              instructions.Add(new MiscInstruction(offset' MiscOp.Ldlen));                              break;                          case PE.OpCode.Ret:                              if (ctxt.ResultType == null)                                  instructions.Add(new MiscInstruction(offset' MiscOp.Ret));                              else                                  instructions.Add(new MiscInstruction(offset' MiscOp.RetVal));                              break;                          case PE.OpCode.Endfilter:                              instructions.Add(new MiscInstruction(offset' MiscOp.Endfilter));                              break;                          case PE.OpCode.Endfinally: // aka EndFault                              instructions.Add(new MiscInstruction(offset' MiscOp.Endfinally));                              break;                          case PE.OpCode.Br_s:                          case PE.OpCode.Br:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Br' false' (int)instruction.Value));                              break;                          case PE.OpCode.Brtrue_s: // aka brinst.s                          case PE.OpCode.Brtrue: // aka brinst                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Brtrue' false' (int)instruction.Value));                              break;                          case PE.OpCode.Brfalse_s: // aka brzero.s' brnull.s                          case PE.OpCode.Brfalse: // aka brzero' brnull                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Brfalse' false' (int)instruction.Value));                              break;                          case PE.OpCode.Beq:                          case PE.OpCode.Beq_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Breq' false' (int)instruction.Value));                              break;                          case PE.OpCode.Bne_un:                          case PE.OpCode.Bne_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Brne' false' (int)instruction.Value));                              break;                          case PE.OpCode.Leave:                          case PE.OpCode.Leave_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.Leave' false' (int)instruction.Value));                              break;                          case PE.OpCode.Blt:                          case PE.OpCode.Blt_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrLt' false' (int)instruction.Value));                              break;                          case PE.OpCode.Blt_un:                          case PE.OpCode.Blt_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrLt' true' (int)instruction.Value));                              break;                          case PE.OpCode.Ble:                          case PE.OpCode.Ble_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrLe' false' (int)instruction.Value));                              break;                          case PE.OpCode.Ble_un:                          case PE.OpCode.Ble_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrLe' true' (int)instruction.Value));                              break;                          case PE.OpCode.Bgt:                          case PE.OpCode.Bgt_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrGt' false' (int)instruction.Value));                              break;                          case PE.OpCode.Bgt_un:                          case PE.OpCode.Bgt_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrGt' true' (int)instruction.Value));                              break;                          case PE.OpCode.Bge:                          case PE.OpCode.Bge_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrGe' false' (int)instruction.Value));                              break;                          case PE.OpCode.Bge_un:                          case PE.OpCode.Bge_un_s:                              instructions.Add                                  (new BranchInstruction(offset' BranchOp.BrGe' true' (int)instruction.Value));                              break;                          case PE.OpCode.Switch:                              instructions.Add(new SwitchInstruction(offset' (Seq<int>)instruction.Value));                              break;                          case PE.OpCode.Ceq:                              instructions.Add(new CompareInstruction(offset' CompareOp.Ceq' false));                              break;                          case PE.OpCode.Clt:                              instructions.Add(new CompareInstruction(offset' CompareOp.Clt' false));                              break;                          case PE.OpCode.Clt_un:                              instructions.Add(new CompareInstruction(offset' CompareOp.Clt' true));                              break;                          case PE.OpCode.Cgt:                              instructions.Add(new CompareInstruction(offset' CompareOp.Cgt' false));                              break;                          case PE.OpCode.Cgt_un:                              instructions.Add(new CompareInstruction(offset' CompareOp.Cgt' true));                              break;                          case PE.OpCode.Ldarg_0:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' 0));                              break;                          case PE.OpCode.Ldarg_1:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' 1));                              break;                          case PE.OpCode.Ldarg_2:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' 2));                              break;                          case PE.OpCode.Ldarg_3:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' 3));                              break;                          case PE.OpCode.Ldarg:                          case PE.OpCode.Ldarg_s:                              instructions.Add                                  (new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Arg' (int)instruction.Value));                              break;                          case PE.OpCode.Ldarga:                          case PE.OpCode.Ldarga_s:                              instructions.Add                                  (new ArgLocalInstruction(offset' ArgLocalOp.Lda' ArgLocal.Arg' (int)instruction.Value));                              break;                          case PE.OpCode.Starg:                          case PE.OpCode.Starg_s:                              instructions.Add                                  (new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Arg' (int)instruction.Value));                              break;                          case PE.OpCode.Ldloc_0:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Local' 0));                              break;                          case PE.OpCode.Ldloc_1:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Local' 1));                              break;                          case PE.OpCode.Ldloc_2:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Local' 2));                              break;                          case PE.OpCode.Ldloc_3:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.Ld' ArgLocal.Local' 3));                              break;                          case PE.OpCode.Ldloc:                          case PE.OpCode.Ldloc_s:                              instructions.Add                                  (new ArgLocalInstruction                                       (offset' ArgLocalOp.Ld' ArgLocal.Local' (int)instruction.Value));                              break;                          case PE.OpCode.Ldloca:                          case PE.OpCode.Ldloca_s:                              instructions.Add                                  (new ArgLocalInstruction                                       (offset' ArgLocalOp.Lda' ArgLocal.Local' (int)instruction.Value));                              break;                          case PE.OpCode.Stloc_0:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Local' 0));                              break;                          case PE.OpCode.Stloc_1:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Local' 1));                              break;                          case PE.OpCode.Stloc_2:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Local' 2));                              break;                          case PE.OpCode.Stloc_3:                              instructions.Add(new ArgLocalInstruction(offset' ArgLocalOp.St' ArgLocal.Local' 3));                              break;                          case PE.OpCode.Stloc:                          case PE.OpCode.Stloc_s:                              instructions.Add                                  (new ArgLocalInstruction                                       (offset' ArgLocalOp.St' ArgLocal.Local' (int)instruction.Value));                              break;                          case PE.OpCode.Ldfld:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Ldfld' (FieldRef)instruction.Value' false));                              break;                          case PE.OpCode.Ldsfld:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Ldfld' (FieldRef)instruction.Value' true));                              break;                          case PE.OpCode.Ldflda:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Ldflda' (FieldRef)instruction.Value' false));                              break;                          case PE.OpCode.Ldsflda:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Ldflda' (FieldRef)instruction.Value' true));                              break;                          case PE.OpCode.Stfld:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Stfld' (FieldRef)instruction.Value' false));                              break;                          case PE.OpCode.Stsfld:                              instructions.Add                                  (new FieldInstruction(offset' FieldOp.Stfld' (FieldRef)instruction.Value' true));                              break;                          case PE.OpCode.Ldtoken:                              {                                  if (instruction.Value is FieldRef)                                      instructions.Add                                          (new FieldInstruction                                               (offset' FieldOp.Ldtoken' (FieldRef)instruction.Value' default(bool)));                                  else if (instruction.Value is MethodRef)                                      instructions.Add                                          (new MethodInstruction                                               (offset' MethodOp.Ldtoken' null' false' (MethodRef)instruction.Value));                                  else if (instruction.Value is TypeRef)                                      // NOTE: May be a higher-kinded type                                      instructions.Add                                          (new TypeInstruction(offset' TypeOp.Ldtoken' (TypeRef)instruction.Value));                                  else                                      throw new InvalidOperationException("unexpected ldtoken instruction value");                                  break;                              }                          case PE.OpCode.Constrained:                              {                                  var constrained = (TypeRef)instruction.Value;                                  if (i >= ctxt.Instructions.Length)                                      throw new InvalidOperationException("invalid instructions");                                  instruction = ctxt.Instructions[i++];                                  if (instruction.OpCode != PE.OpCode.Callvirt)                                      throw new InvalidOperationException("invalid instruction");                                  instructions.Add                                      (new MethodInstruction                                           (offset' MethodOp.Call' constrained' true' (MethodRef)instruction.Value));                                  break;                              }                          case PE.OpCode.Call:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Call' null' false' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Callvirt:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Call' null' true' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Ldftn:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Ldftn' null' false' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Ldvirtftn:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Ldftn' null' true' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Newobj:                              instructions.Add                                  (new MethodInstruction                                       (offset' MethodOp.Newobj' null' false' (MethodRef)instruction.Value));                              break;                          case PE.OpCode.Ldind_i1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.Int8Ref));                              break;                          case PE.OpCode.Ldind_u1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.UInt8Ref));                              break;                          case PE.OpCode.Ldind_i2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.Int16Ref));                              break;                          case PE.OpCode.Ldind_u2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.UInt16Ref));                              break;                          case PE.OpCode.Ldind_i4:                          case PE.OpCode.Ldind_u4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.Int32Ref));                              break;                          case PE.OpCode.Ldind_i8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.Int64Ref));                              break;                          case PE.OpCode.Ldind_i:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.IntNativeRef));                              break;                          case PE.OpCode.Ldind_r4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.SingleRef));                              break;                          case PE.OpCode.Ldind_r8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' global.DoubleRef));                              break;                          case PE.OpCode.Ldobj:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldobj' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Stind_i1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.Int8Ref));                              break;                          case PE.OpCode.Stind_i2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.Int16Ref));                              break;                          case PE.OpCode.Stind_i4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.Int32Ref));                              break;                          case PE.OpCode.Stind_i8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.Int64Ref));                              break;                          case PE.OpCode.Stind_i:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.IntNativeRef));                              break;                          case PE.OpCode.Stind_r4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.SingleRef));                              break;                          case PE.OpCode.Stind_r8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' global.DoubleRef));                              break;                          case PE.OpCode.Stobj:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stobj' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Cpobj:                              instructions.Add(new TypeInstruction(offset' TypeOp.Cpobj' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Newarr:                              instructions.Add(new TypeInstruction(offset' TypeOp.Newarr' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Initobj:                              instructions.Add(new TypeInstruction(offset' TypeOp.Initobj' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Castclass:                              instructions.Add                                  (new TypeInstruction(offset' TypeOp.Castclass' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Isinst:                              instructions.Add(new TypeInstruction(offset' TypeOp.Isinst' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Box:                              instructions.Add(new TypeInstruction(offset' TypeOp.Box' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Unbox:                              instructions.Add(new TypeInstruction(offset' TypeOp.Unbox' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Unbox_any:                              instructions.Add(new TypeInstruction(offset' TypeOp.UnboxAny' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Ldelem_i1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.Int8Ref));                              break;                          case PE.OpCode.Ldelem_u1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.UInt8Ref));                              break;                          case PE.OpCode.Ldelem_i2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.Int16Ref));                              break;                          case PE.OpCode.Ldelem_u2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.UInt16Ref));                              break;                          case PE.OpCode.Ldelem_i4:                          case PE.OpCode.Ldelem_u4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.Int32Ref));                              break;                          case PE.OpCode.Ldelem_i:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.IntNativeRef));                              break;                          case PE.OpCode.Ldelem_i8: // aka ldelem.u8                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.Int64Ref));                              break;                          case PE.OpCode.Ldelem_r4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.SingleRef));                              break;                          case PE.OpCode.Ldelem_r8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' global.DoubleRef));                              break;                          case PE.OpCode.Ldelem: // aka ldelem.any                              instructions.Add(new TypeInstruction(offset' TypeOp.Ldelem' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Stelem_i1:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.Int8Ref));                              break;                          case PE.OpCode.Stelem_i2:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.Int16Ref));                              break;                          case PE.OpCode.Stelem_i4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.Int32Ref));                              break;                          case PE.OpCode.Stelem_i8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.Int64Ref));                              break;                          case PE.OpCode.Stelem_i:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.IntNativeRef));                              break;                          case PE.OpCode.Stelem_r4:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.SingleRef));                              break;                          case PE.OpCode.Stelem_r8:                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' global.DoubleRef));                              break;                          case PE.OpCode.Stelem: // aka stelem.any                              instructions.Add(new TypeInstruction(offset' TypeOp.Stelem' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Readonly:                              if (i >= ctxt.Instructions.Length)                                  throw new InvalidOperationException("invalid instruction");                              instruction = ctxt.Instructions[i++];                              if (instruction.OpCode != PE.OpCode.Ldelema)                                  throw new InvalidOperationException("invalid instruction");                              instructions.Add(new LdElemAddrInstruction(offset' true' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Ldelema:                              instructions.Add(new LdElemAddrInstruction(offset' false' (TypeRef)instruction.Value));                              break;                          case PE.OpCode.Ldc_i4_0:                              instructions.Add(new LdInt32Instruction(offset' 0));                              break;                          case PE.OpCode.Ldc_i4_1:                              instructions.Add(new LdInt32Instruction(offset' 1));                              break;                          case PE.OpCode.Ldc_i4_2:                              instructions.Add(new LdInt32Instruction(offset' 2));                              break;                          case PE.OpCode.Ldc_i4_3:                              instructions.Add(new LdInt32Instruction(offset' 3));                              break;                          case PE.OpCode.Ldc_i4_4:                              instructions.Add(new LdInt32Instruction(offset' 4));                              break;                          case PE.OpCode.Ldc_i4_5:                              instructions.Add(new LdInt32Instruction(offset' 5));                              break;                          case PE.OpCode.Ldc_i4_6:                              instructions.Add(new LdInt32Instruction(offset' 6));                              break;                          case PE.OpCode.Ldc_i4_7:                              instructions.Add(new LdInt32Instruction(offset' 7));                              break;                          case PE.OpCode.Ldc_i4_8:                              instructions.Add(new LdInt32Instruction(offset' 8));                              break;                          case PE.OpCode.Ldc_i4_m1:                              instructions.Add(new LdInt32Instruction(offset' -1));                              break;                          case PE.OpCode.Ldc_i4:                          case PE.OpCode.Ldc_i4_s:                              instructions.Add(new LdInt32Instruction(offset' (int)instruction.Value));                              break;                          case PE.OpCode.Ldc_i8:                              instructions.Add(new LdInt64Instruction(offset' (long)instruction.Value));                              break;                          case PE.OpCode.Ldc_r4:                              instructions.Add(new LdSingleInstruction(offset' (float)instruction.Value));                              break;                          case PE.OpCode.Ldc_r8:                              instructions.Add(new LdDoubleInstruction(offset' (double)instruction.Value));                              break;                          case PE.OpCode.Ldstr:                              instructions.Add(new LdStringInstruction(offset' (string)instruction.Value));                              break;                          case PE.OpCode.Add:                              instructions.Add(new ArithInstruction(offset' ArithOp.Add' false' false));                              break;                          case PE.OpCode.Add_ovf:                              instructions.Add(new ArithInstruction(offset' ArithOp.Add' true' false));                              break;                          case PE.OpCode.Add_ovf_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Add' true' true));                              break;                          case PE.OpCode.Sub:                              instructions.Add(new ArithInstruction(offset' ArithOp.Sub' false' false));                              break;                          case PE.OpCode.Sub_ovf:                              instructions.Add(new ArithInstruction(offset' ArithOp.Sub' true' false));                              break;                          case PE.OpCode.Sub_ovf_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Sub' true' true));                              break;                          case PE.OpCode.Mul:                              instructions.Add(new ArithInstruction(offset' ArithOp.Mul' false' false));                              break;                          case PE.OpCode.Mul_ovf:                              instructions.Add(new ArithInstruction(offset' ArithOp.Mul' true' false));                              break;                          case PE.OpCode.Mul_ovf_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Mul' true' true));                              break;                          case PE.OpCode.Div:                              instructions.Add(new ArithInstruction(offset' ArithOp.Div' false' false));                              break;                          case PE.OpCode.Div_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Div' false' true));                              break;                          case PE.OpCode.Rem:                              instructions.Add(new ArithInstruction(offset' ArithOp.Rem' false' false));                              break;                          case PE.OpCode.Rem_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Rem' false' true));                              break;                          case PE.OpCode.Neg:                              instructions.Add(new ArithInstruction(offset' ArithOp.Neg' false' false));                              break;                          case PE.OpCode.And:                              instructions.Add(new ArithInstruction(offset' ArithOp.BitAnd' false' false));                              break;                          case PE.OpCode.Or:                              instructions.Add(new ArithInstruction(offset' ArithOp.BitOr' false' false));                              break;                          case PE.OpCode.Xor:                              instructions.Add(new ArithInstruction(offset' ArithOp.BitXor' false' false));                              break;                          case PE.OpCode.Not:                              instructions.Add(new ArithInstruction(offset' ArithOp.BitNot' false' false));                              break;                          case PE.OpCode.Shl:                              instructions.Add(new ArithInstruction(offset' ArithOp.Shl' false' false));                              break;                          case PE.OpCode.Shr:                              instructions.Add(new ArithInstruction(offset' ArithOp.Shr' false' false));                              break;                          case PE.OpCode.Shr_un:                              instructions.Add(new ArithInstruction(offset' ArithOp.Shr' false' true));                              break;                          case PE.OpCode.Conv_i1:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int8' false' false));                              break;                          case PE.OpCode.Conv_u1:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt8' false' false));                              break;                          case PE.OpCode.Conv_i2:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int16' false' false));                              break;                          case PE.OpCode.Conv_u2:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt16' false' false));                              break;                          case PE.OpCode.Conv_i4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int32' false' false));                              break;                          case PE.OpCode.Conv_u4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt32' false' false));                              break;                          case PE.OpCode.Conv_i8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int64' false' false));                              break;                          case PE.OpCode.Conv_u8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt64' false' false));                              break;                          case PE.OpCode.Conv_i:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.IntNative' false' false));                              break;                          case PE.OpCode.Conv_u:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UIntNative' false' false));                              break;                          case PE.OpCode.Conv_r4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Single' false' false));                              break;                          case PE.OpCode.Conv_r8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Double' false' false));                              break;                          case PE.OpCode.Conv_r_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Double' false' true));                              break;                          case PE.OpCode.Conv_ovf_i1:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int8' true' false));                              break;                          case PE.OpCode.Conv_ovf_u1:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt8' true' false));                              break;                          case PE.OpCode.Conv_ovf_i2:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int16' true' false));                              break;                          case PE.OpCode.Conv_ovf_u2:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt16' true' false));                              break;                          case PE.OpCode.Conv_ovf_i4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int32' true' false));                              break;                          case PE.OpCode.Conv_ovf_u4:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt32' true' false));                              break;                          case PE.OpCode.Conv_ovf_i8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int64' true' false));                              break;                          case PE.OpCode.Conv_ovf_u8:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt64' true' false));                              break;                          case PE.OpCode.Conv_ovf_i:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.IntNative' true' false));                              break;                          case PE.OpCode.Conv_ovf_u:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UIntNative' true' false));                              break;                          case PE.OpCode.Conv_ovf_i1_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int8' true' true));                              break;                          case PE.OpCode.Conv_ovf_u1_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt8' true' true));                              break;                          case PE.OpCode.Conv_ovf_i2_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int16' true' true));                              break;                          case PE.OpCode.Conv_ovf_u2_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt16' true' true));                              break;                          case PE.OpCode.Conv_ovf_i4_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int32' true' true));                              break;                          case PE.OpCode.Conv_ovf_u4_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt32' true' true));                              break;                          case PE.OpCode.Conv_ovf_i8_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.Int64' true' true));                              break;                          case PE.OpCode.Conv_ovf_u8_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UInt64' true' true));                              break;                          case PE.OpCode.Conv_ovf_i_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.IntNative' true' true));                              break;                          case PE.OpCode.Conv_ovf_u_un:                              instructions.Add(new ConvInstruction(offset' NumberFlavor.UIntNative' true' true));                              break;                          default:                              throw new InvalidOperationException("invalid instruction");                            }                      }                  }              }
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return state;                      case MiscOp.Dup:                          return state.Push(state.Peek(0));                      case MiscOp.Pop:                          return state.Pop(1);                      case MiscOp.Ldnull:                          return state.PushType(global.NullRef' BottomPT);                      case MiscOp.Ckfinite:                          state.PeekExpectedType(0' global.DoubleRef' changed);                          // Assume the instruction can "peek" at top of stack' thus no need for pop/push.                          return state;                      case MiscOp.Throw:                          state.PeekReferenceType(0);                          return state.DiscardStack();                      case MiscOp.Rethrow:                          return state.DiscardStack();                      case MiscOp.LdindRef:                          {                              var elemType = state.PeekPointerToReferenceType(0);                              return state.PopPushType(1' elemType' BottomPT);                          }                      case MiscOp.StindRef:                          {                              var expElemType = state.PeekPointerToReferenceType(1);                              state.PeekExpectedType(0' expElemType' changed);                              return state.Pop(2);                          }                      case MiscOp.LdelemRef:                          {                              state.PeekIndexType(0);                              // WARNING: Type may not be final                              var elemType = state.PeekArrayOfReferenceType(1);                              return state.PopPushType(2' elemType' BottomPT);                          }                      case MiscOp.StelemRef:                          state.PeekReferenceType(0);                          state.PeekIndexType(1);                          state.PeekArrayOfReferenceType(2);                          // Since the value type and array element type may be independently generalized'                          // it is pointless to check that the first is assignable to the second.                          // Instead this check is done at runtime.                          return state.Pop(3);                      case MiscOp.Ldlen:                          state.PeekArrayOfAnyType(0);                          return state.PopPushType(1' global.IntNativeRef' BottomPT);                      case MiscOp.Ret:                          {                              if (state.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return state; // empty                          }                      case MiscOp.RetVal:                          {                              state.PeekExpectedType(0' method.Result.Type' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfilter:                          {                              state.PeekExpectedType(0' global.Int32Ref' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfinally:                          {                              // Control could transfer to an outer finally/fault block' or to the target                              // of a leave instruction. However these transitions are delt with separately.                              return state.DiscardStack();                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:                  {                      var bri = (BranchInstruction)instruction;                      switch (bri.Op)                      {                      case BranchOp.Br:                          UnifyBeforeState(state' bri.Target' changed);                          return state;                      case BranchOp.Brtrue:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' false);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Brfalse:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Breq:                      case BranchOp.Brne:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' true);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Leave:                          {                              // Control could transfer via finally blocks instead of directly to the leave target.                              // Propogate only that the stack must be empty at target. Remaining machine state                              // is dealt with separately.                              UnifyBeforeState                                  (new MachineState(methEnv' method.ValueParameters.Count' method.Locals.Count)'                                   bri.Target'                                   changed);                              return state.DiscardStack();                          }                      case BranchOp.BrLt:                      case BranchOp.BrLe:                      case BranchOp.BrGt:                      case BranchOp.BrGe:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' false);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Switch:                  {                      var switchi = (SwitchInstruction)instruction;                      state.PeekExpectedType(0' global.Int32Ref' changed);                      var newState = state.Pop(1);                      for (var i = 0; i < switchi.CaseTargets.Count; i++)                          UnifyBeforeState(newState' switchi.CaseTargets[i]' changed);                      return newState;                  }              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      // WARNING: Capured type may not be final                      // NOTE: May capture skolemized types                      switch (cmpi.Op)                      {                      case CompareOp.Ceq:                      case CompareOp.CnePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' true);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.Clt:                      case CompareOp.Cgt:                      case CompareOp.CgePseudo:                      case CompareOp.ClePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' false);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.CtruePseudo:                      case CompareOp.CfalsePseudo:                          cmpi.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                          return state.PopPushType(1' global.Int32Ref' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var argi = (ArgLocalInstruction)instruction;                      var type = method.ArgLocalType(argi.ArgLocal' argi.Index);                      switch (argi.Op)                      {                      case ArgLocalOp.Ld:                          return state.PushType(type' state.ArgLocalPointsTo(argi.ArgLocal' argi.Index));                      case ArgLocalOp.Lda:                          return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(type)' ArgLocalPT(argi.ArgLocal' argi.Index));                      case ArgLocalOp.St:                          {                              state.PeekExpectedType(0' type' changed);                              var pointsTo = state.PeekPointsTo(0);                              if (!pointsTo.IsBottom)                              {                                  if (!(type.Style(methEnv) is ManagedPointerTypeStyle))                                      throw new InvalidOperationException                                          ("stack indicates pointer' but parameter or local type does not");                                  if (pointsTo.PointsOutsideOfHeap)                                      throw new InvalidOperationException("arguments cannot point outside of the heap");                              }                              return state.PopAddArgLocalPointsTo(1' argi.ArgLocal' argi.Index' pointsTo);                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      var fieldEnv = fieldi.Field.Enter(methEnv);                      var fieldType = fieldEnv.SubstituteType(fieldEnv.Field.FieldType);                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                              return state.PushType(fieldType' BottomPT);                          else                          {                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' true' changed);                              return state.PopPushType(1' fieldType' BottomPT);                          }                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                              return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          else                          {                              // Underlying type cannot be a struct' otherwise would have a pointer into                              // the stack                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' false' changed);                              return state.PopPushType                                  (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          }                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                          {                              state.PeekExpectedType(0' fieldType' changed);                              return state.Pop(1);                          }                          else                          {                              state.PeekExpectedType(0' fieldType' changed);                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (1' fieldi.Field.DefiningType' false' changed);                              return state.Pop(2);                          }                      case FieldOp.Ldtoken:                          return state.PushType(global.RuntimeFieldHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methi = (MethodInstruction)instruction;                      var sig = (CST.MethodSignature)methi.Method.ExternalSignature;                      switch (methi.Op)                      {                      case MethodOp.Call:                          {                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              if (methi.Constrained != null)                              {                                  if (!methi.IsVirtual || methi.Method.IsStatic)                                      throw new InvalidOperationException                                          ("constrained only valid on virtual calls to instance methods");                                  var thisType = sig.Parameters[0];                                  var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(methi.Constrained);                                  var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo(methi.Constrained);                                  var cs = methi.Constrained.Style(methEnv);                                  if (cs is ValueTypeStyle)                                  {                                      if (thisType.Style(methEnv) is ManagedPointerTypeStyle)                                      {                                          // We pass the argument pointer as is                                          if (!methi.Constrained.IsAssignableTo(methEnv' thisType.Arguments[0]))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                      else                                      {                                          // *Case 1* Morally we deref the argument pointer and box the contents'                                          // but since no supertype of a value type may mutate the underlying value'                                          // we don't need to take a copy of the value when boxing' so in practice                                          // this is a no-op                                          if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                  }                                  else if (cs is ReferenceTypeStyle)                                  {                                      // *Case 2* We dereference the pointer and pass the object reference                                      if (!methi.Constrained.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else if (cs is ParameterTypeStyle)                                  {                                      // Since we are calling an instance method' we know the first argument cannot be                                      // a "naked" type parameter' but is either a class or an interface.                                      // We must decide between cases 1 and 2 above at runtime' but checking as                                      // per case 1 is sufficient now.                                      // NOTE: As for box/classcast/isinst below' if the parameter is                                      // instantiated to a reference type then the type box type is considered                                      // equivalent to the underyling reference type.                                      if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else                                      throw new InvalidOperationException                                          ("constrained must be value' reference or parameter type");                                    state.PeekExpectedType(sig.Parameters.Count - 1' constrainedPtr' changed);                              }                              else if (sig.Parameters.Count > 0)                                  state.PeekExpectedType(sig.Parameters.Count - 1' sig.Parameters[0]' changed);                              if (sig.Result == null)                                  return state.Pop(sig.Parameters.Count);                              else                                  return state.PopPushType(sig.Parameters.Count' sig.Result' BottomPT);                          }                      case MethodOp.Ldftn:                          {                              // NOTE: Verified CLR allows only the two "blessed" sequences:                              //   dup; ldvirtftn; newobj <delegate ctor>                              //   ldftn; newobj <delegate ctor>                              // It is thus possible to check the delegate will capture an instance which                              // implements the loaded method. However' we don't check that here.                              if (methi.IsVirtual)                              {                                  if (methi.Method.IsStatic)                                      throw new InvalidOperationException("cannot ldvirtftn of a static method");                                  var objectType = default(TypeRef);                                  if (sig.Parameters[0].Style(methEnv) is ManagedPointerTypeStyle)                                      // Object should be a box                                      objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(sig.Parameters[0].Arguments[0]);                                  else                                      // Object should match parameter                                      objectType = sig.Parameters[0];                                  state.PeekExpectedType(0' objectType' changed);                                  return state.PopPushType(1' sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                              else                              {                                  if (methi.Method.IsStatic)                                      return state.PushType(sig.ToCodePointer(methEnv.Global)' BottomPT);                                  else                                      return state.PushType(sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                          }                      case MethodOp.Newobj:                          {                              if (methi.Method.IsStatic || sig.Result != null)                                  throw new InvalidOperationException("not a constructor");                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              // First argument to constructor is created by runtime. If definining type is                              // a value type' first argument will be a pointer' but result left on stack                              // will be the value itself.                              return state.PopPushType(sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);                          }                      case MethodOp.Ldtoken:                          return state.PushType(global.RuntimeMethodHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          state.PeekReadPointerType(0' typei.Type);                          return state.PopPushType(1' typei.Type' BottomPT);                      case TypeOp.Stobj:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Cpobj:                          state.PeekReadPointerType(0' typei.Type);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Newarr:                          state.PeekIndexType(0);                          return state.PopPushType(1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo(typei.Type)' BottomPT);                      case TypeOp.Initobj:                          state.PeekWritePointerType(0' typei.Type);                          return state.Pop(1);                      case TypeOp.Castclass:                      case TypeOp.Isinst:                      case TypeOp.Box:                          {                              var resultType = default(TypeRef);                              var s = typei.Type.Style(methEnv);                              if (s is NullableTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type.Arguments[0]);                              else if (s is ValueTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else if (s is ReferenceTypeStyle)                                  resultType = typei.Type;                              else if (s is ParameterTypeStyle)                                  // NOTE: As for constrained call above' if type parameter is instantitated to                                  // a ref type' then this box type is considered equivalent to the                                  // underlying reference type.                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else                                  throw new InvalidOperationException                                      ("can only box/cast to reference' value or parameter type");                              if (typei.Op == TypeOp.Box)                                  state.PeekExpectedType(0' typei.Type' changed);                              else                                  state.PeekReferenceType(0);                              return state.PopPushType(1' resultType' BottomPT);                          }                      case TypeOp.Unbox:                          if (!(typei.Type.Style(methEnv) is ValueTypeStyle))                              // Parameter types are not allowed                              throw new InvalidOperationException("type must be a value type");                          state.PeekBoxedType(0' typei.Type' changed);                          return state.PopPushType(1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(typei.Type)' HeapPT);                      case TypeOp.UnboxAny:                          {                              var s = typei.Type.Style(methEnv);                              if (s is ValueTypeStyle)                                  state.PeekBoxedType(0' typei.Type' changed);                              else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))                                  throw new InvalidOperationException("type must be value' reference or parameter type");                              return state.PopPushType(1' typei.Type' BottomPT);                          }                      case TypeOp.Ldtoken:                          return state.PushType(global.RuntimeTypeHandleRef' BottomPT);                      case TypeOp.Ldelem:                          state.PeekIndexType(0);                          state.PeekReadArrayType(1' typei.Type' false);                          return state.PopPushType(2' typei.Type' BottomPT);                      case TypeOp.Stelem:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekIndexType(1);                          state.PeekWriteArrayType(2' typei.Type);                          return state.Pop(3);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  {                      var ldelemai = (LdElemAddrInstruction)instruction;                      state.PeekIndexType(0);                      // WARNING: May prematurely fail for non-readonly loads                      state.PeekReadArrayType(1' ldelemai.Type' !ldelemai.IsReadonly);                      return state.PopPushType(2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(ldelemai.Type)' HeapPT);                  }              case InstructionFlavor.LdInt32:                  return state.PushType(global.Int32Ref' BottomPT);              case InstructionFlavor.LdInt64:                  return state.PushType(global.Int64Ref' BottomPT);              case InstructionFlavor.LdSingle:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdDouble:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdString:                  return state.PushType(global.StringRef' BottomPT);              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.Div:                      case ArithOp.Rem:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' true);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.Neg:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' true);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' false);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.BitNot:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.Shl:                      case ArithOp.Shr:                          state.PeekExpectedType(0' global.Int32Ref' changed);                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(1' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(2' arithi.Type' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned &&                                           convi.TargetNumberFlavor == NumberFlavor.Double);                      // NOTE: May capture skolemized types                      convi.SourceType = state.PeekNumberType(0' !mustBeInteger);                      return state.PopPushType(1' TypeRef.NumberFrom(methEnv.Global' convi.TargetNumberFlavor)' BottomPT);                  }              case InstructionFlavor.Try:                  {                      var tryi = (TryInstruction)instruction;                      // Isolation:                      //  - There is no way for the current stack shape to influence or be influenced by                      //    inference of the try' since the current stack shape must be empty.                      //  - There is no way for the try to influence the result stack shape' since it must be                      //    empty.                      //  - However pointers in arguments and locals may propogate into and out of try body                      //    via exceptional transitions. The latter are delt with separately.                      if (state.Depth != 0)                          throw new InvalidOperationException("stack should be empty");                      var newState = ForwardBlock                          (new TryBodyInstructionContext(context' index' tryi.Body)' state' changed);                      for (var j = 0; j < tryi.Handlers.Count; j++)                      {                          var h = tryi.Handlers[j];                          var handlerContext = new TryHandlerInstructionContext(context' index' h.Body' j);                          var initHandlerState = new MachineState                              (methEnv' method.ValueParameters.Count' method.Locals.Count);                          switch (h.Flavor)                          {                          case HandlerFlavor.Catch:                              {                                  var catchh = (CatchTryInstructionHandler)h;                                  ForwardBlock(handlerContext' initHandlerState.PushType(catchh.Type' BottomPT)' changed);                                  break;                              }                          case HandlerFlavor.Filter:                              throw new NotSupportedException("filter handler blocks");                          case HandlerFlavor.Fault:                          case HandlerFlavor.Finally:                              ForwardBlock(handlerContext' initHandlerState' changed);                              break;                          default:                              throw new ArgumentOutOfRangeException();                          }                      }                      return newState;                  }              case InstructionFlavor.IfThenElsePseudo:              case InstructionFlavor.ShortCircuitingPseudo:              case InstructionFlavor.StructuralSwitchPseudo:              case InstructionFlavor.LoopPseudo:              case InstructionFlavor.WhileDoPseudo:              case InstructionFlavor.DoWhilePseudo:              case InstructionFlavor.LoopControlPseudo:                  throw new InvalidOperationException("no machine state inference for psuedo-instructions");              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return state;                      case MiscOp.Dup:                          return state.Push(state.Peek(0));                      case MiscOp.Pop:                          return state.Pop(1);                      case MiscOp.Ldnull:                          return state.PushType(global.NullRef' BottomPT);                      case MiscOp.Ckfinite:                          state.PeekExpectedType(0' global.DoubleRef' changed);                          // Assume the instruction can "peek" at top of stack' thus no need for pop/push.                          return state;                      case MiscOp.Throw:                          state.PeekReferenceType(0);                          return state.DiscardStack();                      case MiscOp.Rethrow:                          return state.DiscardStack();                      case MiscOp.LdindRef:                          {                              var elemType = state.PeekPointerToReferenceType(0);                              return state.PopPushType(1' elemType' BottomPT);                          }                      case MiscOp.StindRef:                          {                              var expElemType = state.PeekPointerToReferenceType(1);                              state.PeekExpectedType(0' expElemType' changed);                              return state.Pop(2);                          }                      case MiscOp.LdelemRef:                          {                              state.PeekIndexType(0);                              // WARNING: Type may not be final                              var elemType = state.PeekArrayOfReferenceType(1);                              return state.PopPushType(2' elemType' BottomPT);                          }                      case MiscOp.StelemRef:                          state.PeekReferenceType(0);                          state.PeekIndexType(1);                          state.PeekArrayOfReferenceType(2);                          // Since the value type and array element type may be independently generalized'                          // it is pointless to check that the first is assignable to the second.                          // Instead this check is done at runtime.                          return state.Pop(3);                      case MiscOp.Ldlen:                          state.PeekArrayOfAnyType(0);                          return state.PopPushType(1' global.IntNativeRef' BottomPT);                      case MiscOp.Ret:                          {                              if (state.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return state; // empty                          }                      case MiscOp.RetVal:                          {                              state.PeekExpectedType(0' method.Result.Type' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfilter:                          {                              state.PeekExpectedType(0' global.Int32Ref' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfinally:                          {                              // Control could transfer to an outer finally/fault block' or to the target                              // of a leave instruction. However these transitions are delt with separately.                              return state.DiscardStack();                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:                  {                      var bri = (BranchInstruction)instruction;                      switch (bri.Op)                      {                      case BranchOp.Br:                          UnifyBeforeState(state' bri.Target' changed);                          return state;                      case BranchOp.Brtrue:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' false);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Brfalse:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Breq:                      case BranchOp.Brne:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' true);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Leave:                          {                              // Control could transfer via finally blocks instead of directly to the leave target.                              // Propogate only that the stack must be empty at target. Remaining machine state                              // is dealt with separately.                              UnifyBeforeState                                  (new MachineState(methEnv' method.ValueParameters.Count' method.Locals.Count)'                                   bri.Target'                                   changed);                              return state.DiscardStack();                          }                      case BranchOp.BrLt:                      case BranchOp.BrLe:                      case BranchOp.BrGt:                      case BranchOp.BrGe:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' false);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Switch:                  {                      var switchi = (SwitchInstruction)instruction;                      state.PeekExpectedType(0' global.Int32Ref' changed);                      var newState = state.Pop(1);                      for (var i = 0; i < switchi.CaseTargets.Count; i++)                          UnifyBeforeState(newState' switchi.CaseTargets[i]' changed);                      return newState;                  }              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      // WARNING: Capured type may not be final                      // NOTE: May capture skolemized types                      switch (cmpi.Op)                      {                      case CompareOp.Ceq:                      case CompareOp.CnePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' true);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.Clt:                      case CompareOp.Cgt:                      case CompareOp.CgePseudo:                      case CompareOp.ClePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' false);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.CtruePseudo:                      case CompareOp.CfalsePseudo:                          cmpi.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                          return state.PopPushType(1' global.Int32Ref' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var argi = (ArgLocalInstruction)instruction;                      var type = method.ArgLocalType(argi.ArgLocal' argi.Index);                      switch (argi.Op)                      {                      case ArgLocalOp.Ld:                          return state.PushType(type' state.ArgLocalPointsTo(argi.ArgLocal' argi.Index));                      case ArgLocalOp.Lda:                          return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(type)' ArgLocalPT(argi.ArgLocal' argi.Index));                      case ArgLocalOp.St:                          {                              state.PeekExpectedType(0' type' changed);                              var pointsTo = state.PeekPointsTo(0);                              if (!pointsTo.IsBottom)                              {                                  if (!(type.Style(methEnv) is ManagedPointerTypeStyle))                                      throw new InvalidOperationException                                          ("stack indicates pointer' but parameter or local type does not");                                  if (pointsTo.PointsOutsideOfHeap)                                      throw new InvalidOperationException("arguments cannot point outside of the heap");                              }                              return state.PopAddArgLocalPointsTo(1' argi.ArgLocal' argi.Index' pointsTo);                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      var fieldEnv = fieldi.Field.Enter(methEnv);                      var fieldType = fieldEnv.SubstituteType(fieldEnv.Field.FieldType);                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                              return state.PushType(fieldType' BottomPT);                          else                          {                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' true' changed);                              return state.PopPushType(1' fieldType' BottomPT);                          }                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                              return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          else                          {                              // Underlying type cannot be a struct' otherwise would have a pointer into                              // the stack                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' false' changed);                              return state.PopPushType                                  (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          }                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                          {                              state.PeekExpectedType(0' fieldType' changed);                              return state.Pop(1);                          }                          else                          {                              state.PeekExpectedType(0' fieldType' changed);                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (1' fieldi.Field.DefiningType' false' changed);                              return state.Pop(2);                          }                      case FieldOp.Ldtoken:                          return state.PushType(global.RuntimeFieldHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methi = (MethodInstruction)instruction;                      var sig = (CST.MethodSignature)methi.Method.ExternalSignature;                      switch (methi.Op)                      {                      case MethodOp.Call:                          {                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              if (methi.Constrained != null)                              {                                  if (!methi.IsVirtual || methi.Method.IsStatic)                                      throw new InvalidOperationException                                          ("constrained only valid on virtual calls to instance methods");                                  var thisType = sig.Parameters[0];                                  var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(methi.Constrained);                                  var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo(methi.Constrained);                                  var cs = methi.Constrained.Style(methEnv);                                  if (cs is ValueTypeStyle)                                  {                                      if (thisType.Style(methEnv) is ManagedPointerTypeStyle)                                      {                                          // We pass the argument pointer as is                                          if (!methi.Constrained.IsAssignableTo(methEnv' thisType.Arguments[0]))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                      else                                      {                                          // *Case 1* Morally we deref the argument pointer and box the contents'                                          // but since no supertype of a value type may mutate the underlying value'                                          // we don't need to take a copy of the value when boxing' so in practice                                          // this is a no-op                                          if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                  }                                  else if (cs is ReferenceTypeStyle)                                  {                                      // *Case 2* We dereference the pointer and pass the object reference                                      if (!methi.Constrained.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else if (cs is ParameterTypeStyle)                                  {                                      // Since we are calling an instance method' we know the first argument cannot be                                      // a "naked" type parameter' but is either a class or an interface.                                      // We must decide between cases 1 and 2 above at runtime' but checking as                                      // per case 1 is sufficient now.                                      // NOTE: As for box/classcast/isinst below' if the parameter is                                      // instantiated to a reference type then the type box type is considered                                      // equivalent to the underyling reference type.                                      if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else                                      throw new InvalidOperationException                                          ("constrained must be value' reference or parameter type");                                    state.PeekExpectedType(sig.Parameters.Count - 1' constrainedPtr' changed);                              }                              else if (sig.Parameters.Count > 0)                                  state.PeekExpectedType(sig.Parameters.Count - 1' sig.Parameters[0]' changed);                              if (sig.Result == null)                                  return state.Pop(sig.Parameters.Count);                              else                                  return state.PopPushType(sig.Parameters.Count' sig.Result' BottomPT);                          }                      case MethodOp.Ldftn:                          {                              // NOTE: Verified CLR allows only the two "blessed" sequences:                              //   dup; ldvirtftn; newobj <delegate ctor>                              //   ldftn; newobj <delegate ctor>                              // It is thus possible to check the delegate will capture an instance which                              // implements the loaded method. However' we don't check that here.                              if (methi.IsVirtual)                              {                                  if (methi.Method.IsStatic)                                      throw new InvalidOperationException("cannot ldvirtftn of a static method");                                  var objectType = default(TypeRef);                                  if (sig.Parameters[0].Style(methEnv) is ManagedPointerTypeStyle)                                      // Object should be a box                                      objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(sig.Parameters[0].Arguments[0]);                                  else                                      // Object should match parameter                                      objectType = sig.Parameters[0];                                  state.PeekExpectedType(0' objectType' changed);                                  return state.PopPushType(1' sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                              else                              {                                  if (methi.Method.IsStatic)                                      return state.PushType(sig.ToCodePointer(methEnv.Global)' BottomPT);                                  else                                      return state.PushType(sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                          }                      case MethodOp.Newobj:                          {                              if (methi.Method.IsStatic || sig.Result != null)                                  throw new InvalidOperationException("not a constructor");                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              // First argument to constructor is created by runtime. If definining type is                              // a value type' first argument will be a pointer' but result left on stack                              // will be the value itself.                              return state.PopPushType(sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);                          }                      case MethodOp.Ldtoken:                          return state.PushType(global.RuntimeMethodHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          state.PeekReadPointerType(0' typei.Type);                          return state.PopPushType(1' typei.Type' BottomPT);                      case TypeOp.Stobj:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Cpobj:                          state.PeekReadPointerType(0' typei.Type);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Newarr:                          state.PeekIndexType(0);                          return state.PopPushType(1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo(typei.Type)' BottomPT);                      case TypeOp.Initobj:                          state.PeekWritePointerType(0' typei.Type);                          return state.Pop(1);                      case TypeOp.Castclass:                      case TypeOp.Isinst:                      case TypeOp.Box:                          {                              var resultType = default(TypeRef);                              var s = typei.Type.Style(methEnv);                              if (s is NullableTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type.Arguments[0]);                              else if (s is ValueTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else if (s is ReferenceTypeStyle)                                  resultType = typei.Type;                              else if (s is ParameterTypeStyle)                                  // NOTE: As for constrained call above' if type parameter is instantitated to                                  // a ref type' then this box type is considered equivalent to the                                  // underlying reference type.                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else                                  throw new InvalidOperationException                                      ("can only box/cast to reference' value or parameter type");                              if (typei.Op == TypeOp.Box)                                  state.PeekExpectedType(0' typei.Type' changed);                              else                                  state.PeekReferenceType(0);                              return state.PopPushType(1' resultType' BottomPT);                          }                      case TypeOp.Unbox:                          if (!(typei.Type.Style(methEnv) is ValueTypeStyle))                              // Parameter types are not allowed                              throw new InvalidOperationException("type must be a value type");                          state.PeekBoxedType(0' typei.Type' changed);                          return state.PopPushType(1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(typei.Type)' HeapPT);                      case TypeOp.UnboxAny:                          {                              var s = typei.Type.Style(methEnv);                              if (s is ValueTypeStyle)                                  state.PeekBoxedType(0' typei.Type' changed);                              else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))                                  throw new InvalidOperationException("type must be value' reference or parameter type");                              return state.PopPushType(1' typei.Type' BottomPT);                          }                      case TypeOp.Ldtoken:                          return state.PushType(global.RuntimeTypeHandleRef' BottomPT);                      case TypeOp.Ldelem:                          state.PeekIndexType(0);                          state.PeekReadArrayType(1' typei.Type' false);                          return state.PopPushType(2' typei.Type' BottomPT);                      case TypeOp.Stelem:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekIndexType(1);                          state.PeekWriteArrayType(2' typei.Type);                          return state.Pop(3);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  {                      var ldelemai = (LdElemAddrInstruction)instruction;                      state.PeekIndexType(0);                      // WARNING: May prematurely fail for non-readonly loads                      state.PeekReadArrayType(1' ldelemai.Type' !ldelemai.IsReadonly);                      return state.PopPushType(2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(ldelemai.Type)' HeapPT);                  }              case InstructionFlavor.LdInt32:                  return state.PushType(global.Int32Ref' BottomPT);              case InstructionFlavor.LdInt64:                  return state.PushType(global.Int64Ref' BottomPT);              case InstructionFlavor.LdSingle:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdDouble:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdString:                  return state.PushType(global.StringRef' BottomPT);              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.Div:                      case ArithOp.Rem:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' true);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.Neg:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' true);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' false);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.BitNot:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.Shl:                      case ArithOp.Shr:                          state.PeekExpectedType(0' global.Int32Ref' changed);                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(1' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(2' arithi.Type' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned &&                                           convi.TargetNumberFlavor == NumberFlavor.Double);                      // NOTE: May capture skolemized types                      convi.SourceType = state.PeekNumberType(0' !mustBeInteger);                      return state.PopPushType(1' TypeRef.NumberFrom(methEnv.Global' convi.TargetNumberFlavor)' BottomPT);                  }              case InstructionFlavor.Try:                  {                      var tryi = (TryInstruction)instruction;                      // Isolation:                      //  - There is no way for the current stack shape to influence or be influenced by                      //    inference of the try' since the current stack shape must be empty.                      //  - There is no way for the try to influence the result stack shape' since it must be                      //    empty.                      //  - However pointers in arguments and locals may propogate into and out of try body                      //    via exceptional transitions. The latter are delt with separately.                      if (state.Depth != 0)                          throw new InvalidOperationException("stack should be empty");                      var newState = ForwardBlock                          (new TryBodyInstructionContext(context' index' tryi.Body)' state' changed);                      for (var j = 0; j < tryi.Handlers.Count; j++)                      {                          var h = tryi.Handlers[j];                          var handlerContext = new TryHandlerInstructionContext(context' index' h.Body' j);                          var initHandlerState = new MachineState                              (methEnv' method.ValueParameters.Count' method.Locals.Count);                          switch (h.Flavor)                          {                          case HandlerFlavor.Catch:                              {                                  var catchh = (CatchTryInstructionHandler)h;                                  ForwardBlock(handlerContext' initHandlerState.PushType(catchh.Type' BottomPT)' changed);                                  break;                              }                          case HandlerFlavor.Filter:                              throw new NotSupportedException("filter handler blocks");                          case HandlerFlavor.Fault:                          case HandlerFlavor.Finally:                              ForwardBlock(handlerContext' initHandlerState' changed);                              break;                          default:                              throw new ArgumentOutOfRangeException();                          }                      }                      return newState;                  }              case InstructionFlavor.IfThenElsePseudo:              case InstructionFlavor.ShortCircuitingPseudo:              case InstructionFlavor.StructuralSwitchPseudo:              case InstructionFlavor.LoopPseudo:              case InstructionFlavor.WhileDoPseudo:              case InstructionFlavor.DoWhilePseudo:              case InstructionFlavor.LoopControlPseudo:                  throw new InvalidOperationException("no machine state inference for psuedo-instructions");              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return state;                      case MiscOp.Dup:                          return state.Push(state.Peek(0));                      case MiscOp.Pop:                          return state.Pop(1);                      case MiscOp.Ldnull:                          return state.PushType(global.NullRef' BottomPT);                      case MiscOp.Ckfinite:                          state.PeekExpectedType(0' global.DoubleRef' changed);                          // Assume the instruction can "peek" at top of stack' thus no need for pop/push.                          return state;                      case MiscOp.Throw:                          state.PeekReferenceType(0);                          return state.DiscardStack();                      case MiscOp.Rethrow:                          return state.DiscardStack();                      case MiscOp.LdindRef:                          {                              var elemType = state.PeekPointerToReferenceType(0);                              return state.PopPushType(1' elemType' BottomPT);                          }                      case MiscOp.StindRef:                          {                              var expElemType = state.PeekPointerToReferenceType(1);                              state.PeekExpectedType(0' expElemType' changed);                              return state.Pop(2);                          }                      case MiscOp.LdelemRef:                          {                              state.PeekIndexType(0);                              // WARNING: Type may not be final                              var elemType = state.PeekArrayOfReferenceType(1);                              return state.PopPushType(2' elemType' BottomPT);                          }                      case MiscOp.StelemRef:                          state.PeekReferenceType(0);                          state.PeekIndexType(1);                          state.PeekArrayOfReferenceType(2);                          // Since the value type and array element type may be independently generalized'                          // it is pointless to check that the first is assignable to the second.                          // Instead this check is done at runtime.                          return state.Pop(3);                      case MiscOp.Ldlen:                          state.PeekArrayOfAnyType(0);                          return state.PopPushType(1' global.IntNativeRef' BottomPT);                      case MiscOp.Ret:                          {                              if (state.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return state; // empty                          }                      case MiscOp.RetVal:                          {                              state.PeekExpectedType(0' method.Result.Type' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfilter:                          {                              state.PeekExpectedType(0' global.Int32Ref' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfinally:                          {                              // Control could transfer to an outer finally/fault block' or to the target                              // of a leave instruction. However these transitions are delt with separately.                              return state.DiscardStack();                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:                  {                      var bri = (BranchInstruction)instruction;                      switch (bri.Op)                      {                      case BranchOp.Br:                          UnifyBeforeState(state' bri.Target' changed);                          return state;                      case BranchOp.Brtrue:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' false);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Brfalse:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Breq:                      case BranchOp.Brne:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' true);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Leave:                          {                              // Control could transfer via finally blocks instead of directly to the leave target.                              // Propogate only that the stack must be empty at target. Remaining machine state                              // is dealt with separately.                              UnifyBeforeState                                  (new MachineState(methEnv' method.ValueParameters.Count' method.Locals.Count)'                                   bri.Target'                                   changed);                              return state.DiscardStack();                          }                      case BranchOp.BrLt:                      case BranchOp.BrLe:                      case BranchOp.BrGt:                      case BranchOp.BrGe:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' false);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Switch:                  {                      var switchi = (SwitchInstruction)instruction;                      state.PeekExpectedType(0' global.Int32Ref' changed);                      var newState = state.Pop(1);                      for (var i = 0; i < switchi.CaseTargets.Count; i++)                          UnifyBeforeState(newState' switchi.CaseTargets[i]' changed);                      return newState;                  }              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      // WARNING: Capured type may not be final                      // NOTE: May capture skolemized types                      switch (cmpi.Op)                      {                      case CompareOp.Ceq:                      case CompareOp.CnePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' true);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.Clt:                      case CompareOp.Cgt:                      case CompareOp.CgePseudo:                      case CompareOp.ClePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' false);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.CtruePseudo:                      case CompareOp.CfalsePseudo:                          cmpi.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                          return state.PopPushType(1' global.Int32Ref' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var argi = (ArgLocalInstruction)instruction;                      var type = method.ArgLocalType(argi.ArgLocal' argi.Index);                      switch (argi.Op)                      {                      case ArgLocalOp.Ld:                          return state.PushType(type' state.ArgLocalPointsTo(argi.ArgLocal' argi.Index));                      case ArgLocalOp.Lda:                          return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(type)' ArgLocalPT(argi.ArgLocal' argi.Index));                      case ArgLocalOp.St:                          {                              state.PeekExpectedType(0' type' changed);                              var pointsTo = state.PeekPointsTo(0);                              if (!pointsTo.IsBottom)                              {                                  if (!(type.Style(methEnv) is ManagedPointerTypeStyle))                                      throw new InvalidOperationException                                          ("stack indicates pointer' but parameter or local type does not");                                  if (pointsTo.PointsOutsideOfHeap)                                      throw new InvalidOperationException("arguments cannot point outside of the heap");                              }                              return state.PopAddArgLocalPointsTo(1' argi.ArgLocal' argi.Index' pointsTo);                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      var fieldEnv = fieldi.Field.Enter(methEnv);                      var fieldType = fieldEnv.SubstituteType(fieldEnv.Field.FieldType);                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                              return state.PushType(fieldType' BottomPT);                          else                          {                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' true' changed);                              return state.PopPushType(1' fieldType' BottomPT);                          }                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                              return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          else                          {                              // Underlying type cannot be a struct' otherwise would have a pointer into                              // the stack                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' false' changed);                              return state.PopPushType                                  (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          }                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                          {                              state.PeekExpectedType(0' fieldType' changed);                              return state.Pop(1);                          }                          else                          {                              state.PeekExpectedType(0' fieldType' changed);                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (1' fieldi.Field.DefiningType' false' changed);                              return state.Pop(2);                          }                      case FieldOp.Ldtoken:                          return state.PushType(global.RuntimeFieldHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methi = (MethodInstruction)instruction;                      var sig = (CST.MethodSignature)methi.Method.ExternalSignature;                      switch (methi.Op)                      {                      case MethodOp.Call:                          {                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              if (methi.Constrained != null)                              {                                  if (!methi.IsVirtual || methi.Method.IsStatic)                                      throw new InvalidOperationException                                          ("constrained only valid on virtual calls to instance methods");                                  var thisType = sig.Parameters[0];                                  var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(methi.Constrained);                                  var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo(methi.Constrained);                                  var cs = methi.Constrained.Style(methEnv);                                  if (cs is ValueTypeStyle)                                  {                                      if (thisType.Style(methEnv) is ManagedPointerTypeStyle)                                      {                                          // We pass the argument pointer as is                                          if (!methi.Constrained.IsAssignableTo(methEnv' thisType.Arguments[0]))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                      else                                      {                                          // *Case 1* Morally we deref the argument pointer and box the contents'                                          // but since no supertype of a value type may mutate the underlying value'                                          // we don't need to take a copy of the value when boxing' so in practice                                          // this is a no-op                                          if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                  }                                  else if (cs is ReferenceTypeStyle)                                  {                                      // *Case 2* We dereference the pointer and pass the object reference                                      if (!methi.Constrained.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else if (cs is ParameterTypeStyle)                                  {                                      // Since we are calling an instance method' we know the first argument cannot be                                      // a "naked" type parameter' but is either a class or an interface.                                      // We must decide between cases 1 and 2 above at runtime' but checking as                                      // per case 1 is sufficient now.                                      // NOTE: As for box/classcast/isinst below' if the parameter is                                      // instantiated to a reference type then the type box type is considered                                      // equivalent to the underyling reference type.                                      if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else                                      throw new InvalidOperationException                                          ("constrained must be value' reference or parameter type");                                    state.PeekExpectedType(sig.Parameters.Count - 1' constrainedPtr' changed);                              }                              else if (sig.Parameters.Count > 0)                                  state.PeekExpectedType(sig.Parameters.Count - 1' sig.Parameters[0]' changed);                              if (sig.Result == null)                                  return state.Pop(sig.Parameters.Count);                              else                                  return state.PopPushType(sig.Parameters.Count' sig.Result' BottomPT);                          }                      case MethodOp.Ldftn:                          {                              // NOTE: Verified CLR allows only the two "blessed" sequences:                              //   dup; ldvirtftn; newobj <delegate ctor>                              //   ldftn; newobj <delegate ctor>                              // It is thus possible to check the delegate will capture an instance which                              // implements the loaded method. However' we don't check that here.                              if (methi.IsVirtual)                              {                                  if (methi.Method.IsStatic)                                      throw new InvalidOperationException("cannot ldvirtftn of a static method");                                  var objectType = default(TypeRef);                                  if (sig.Parameters[0].Style(methEnv) is ManagedPointerTypeStyle)                                      // Object should be a box                                      objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(sig.Parameters[0].Arguments[0]);                                  else                                      // Object should match parameter                                      objectType = sig.Parameters[0];                                  state.PeekExpectedType(0' objectType' changed);                                  return state.PopPushType(1' sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                              else                              {                                  if (methi.Method.IsStatic)                                      return state.PushType(sig.ToCodePointer(methEnv.Global)' BottomPT);                                  else                                      return state.PushType(sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                          }                      case MethodOp.Newobj:                          {                              if (methi.Method.IsStatic || sig.Result != null)                                  throw new InvalidOperationException("not a constructor");                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              // First argument to constructor is created by runtime. If definining type is                              // a value type' first argument will be a pointer' but result left on stack                              // will be the value itself.                              return state.PopPushType(sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);                          }                      case MethodOp.Ldtoken:                          return state.PushType(global.RuntimeMethodHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          state.PeekReadPointerType(0' typei.Type);                          return state.PopPushType(1' typei.Type' BottomPT);                      case TypeOp.Stobj:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Cpobj:                          state.PeekReadPointerType(0' typei.Type);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Newarr:                          state.PeekIndexType(0);                          return state.PopPushType(1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo(typei.Type)' BottomPT);                      case TypeOp.Initobj:                          state.PeekWritePointerType(0' typei.Type);                          return state.Pop(1);                      case TypeOp.Castclass:                      case TypeOp.Isinst:                      case TypeOp.Box:                          {                              var resultType = default(TypeRef);                              var s = typei.Type.Style(methEnv);                              if (s is NullableTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type.Arguments[0]);                              else if (s is ValueTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else if (s is ReferenceTypeStyle)                                  resultType = typei.Type;                              else if (s is ParameterTypeStyle)                                  // NOTE: As for constrained call above' if type parameter is instantitated to                                  // a ref type' then this box type is considered equivalent to the                                  // underlying reference type.                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else                                  throw new InvalidOperationException                                      ("can only box/cast to reference' value or parameter type");                              if (typei.Op == TypeOp.Box)                                  state.PeekExpectedType(0' typei.Type' changed);                              else                                  state.PeekReferenceType(0);                              return state.PopPushType(1' resultType' BottomPT);                          }                      case TypeOp.Unbox:                          if (!(typei.Type.Style(methEnv) is ValueTypeStyle))                              // Parameter types are not allowed                              throw new InvalidOperationException("type must be a value type");                          state.PeekBoxedType(0' typei.Type' changed);                          return state.PopPushType(1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(typei.Type)' HeapPT);                      case TypeOp.UnboxAny:                          {                              var s = typei.Type.Style(methEnv);                              if (s is ValueTypeStyle)                                  state.PeekBoxedType(0' typei.Type' changed);                              else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))                                  throw new InvalidOperationException("type must be value' reference or parameter type");                              return state.PopPushType(1' typei.Type' BottomPT);                          }                      case TypeOp.Ldtoken:                          return state.PushType(global.RuntimeTypeHandleRef' BottomPT);                      case TypeOp.Ldelem:                          state.PeekIndexType(0);                          state.PeekReadArrayType(1' typei.Type' false);                          return state.PopPushType(2' typei.Type' BottomPT);                      case TypeOp.Stelem:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekIndexType(1);                          state.PeekWriteArrayType(2' typei.Type);                          return state.Pop(3);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  {                      var ldelemai = (LdElemAddrInstruction)instruction;                      state.PeekIndexType(0);                      // WARNING: May prematurely fail for non-readonly loads                      state.PeekReadArrayType(1' ldelemai.Type' !ldelemai.IsReadonly);                      return state.PopPushType(2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(ldelemai.Type)' HeapPT);                  }              case InstructionFlavor.LdInt32:                  return state.PushType(global.Int32Ref' BottomPT);              case InstructionFlavor.LdInt64:                  return state.PushType(global.Int64Ref' BottomPT);              case InstructionFlavor.LdSingle:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdDouble:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdString:                  return state.PushType(global.StringRef' BottomPT);              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.Div:                      case ArithOp.Rem:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' true);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.Neg:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' true);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' false);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.BitNot:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.Shl:                      case ArithOp.Shr:                          state.PeekExpectedType(0' global.Int32Ref' changed);                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(1' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(2' arithi.Type' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned &&                                           convi.TargetNumberFlavor == NumberFlavor.Double);                      // NOTE: May capture skolemized types                      convi.SourceType = state.PeekNumberType(0' !mustBeInteger);                      return state.PopPushType(1' TypeRef.NumberFrom(methEnv.Global' convi.TargetNumberFlavor)' BottomPT);                  }              case InstructionFlavor.Try:                  {                      var tryi = (TryInstruction)instruction;                      // Isolation:                      //  - There is no way for the current stack shape to influence or be influenced by                      //    inference of the try' since the current stack shape must be empty.                      //  - There is no way for the try to influence the result stack shape' since it must be                      //    empty.                      //  - However pointers in arguments and locals may propogate into and out of try body                      //    via exceptional transitions. The latter are delt with separately.                      if (state.Depth != 0)                          throw new InvalidOperationException("stack should be empty");                      var newState = ForwardBlock                          (new TryBodyInstructionContext(context' index' tryi.Body)' state' changed);                      for (var j = 0; j < tryi.Handlers.Count; j++)                      {                          var h = tryi.Handlers[j];                          var handlerContext = new TryHandlerInstructionContext(context' index' h.Body' j);                          var initHandlerState = new MachineState                              (methEnv' method.ValueParameters.Count' method.Locals.Count);                          switch (h.Flavor)                          {                          case HandlerFlavor.Catch:                              {                                  var catchh = (CatchTryInstructionHandler)h;                                  ForwardBlock(handlerContext' initHandlerState.PushType(catchh.Type' BottomPT)' changed);                                  break;                              }                          case HandlerFlavor.Filter:                              throw new NotSupportedException("filter handler blocks");                          case HandlerFlavor.Fault:                          case HandlerFlavor.Finally:                              ForwardBlock(handlerContext' initHandlerState' changed);                              break;                          default:                              throw new ArgumentOutOfRangeException();                          }                      }                      return newState;                  }              case InstructionFlavor.IfThenElsePseudo:              case InstructionFlavor.ShortCircuitingPseudo:              case InstructionFlavor.StructuralSwitchPseudo:              case InstructionFlavor.LoopPseudo:              case InstructionFlavor.WhileDoPseudo:              case InstructionFlavor.DoWhilePseudo:              case InstructionFlavor.LoopControlPseudo:                  throw new InvalidOperationException("no machine state inference for psuedo-instructions");              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return state;                      case MiscOp.Dup:                          return state.Push(state.Peek(0));                      case MiscOp.Pop:                          return state.Pop(1);                      case MiscOp.Ldnull:                          return state.PushType(global.NullRef' BottomPT);                      case MiscOp.Ckfinite:                          state.PeekExpectedType(0' global.DoubleRef' changed);                          // Assume the instruction can "peek" at top of stack' thus no need for pop/push.                          return state;                      case MiscOp.Throw:                          state.PeekReferenceType(0);                          return state.DiscardStack();                      case MiscOp.Rethrow:                          return state.DiscardStack();                      case MiscOp.LdindRef:                          {                              var elemType = state.PeekPointerToReferenceType(0);                              return state.PopPushType(1' elemType' BottomPT);                          }                      case MiscOp.StindRef:                          {                              var expElemType = state.PeekPointerToReferenceType(1);                              state.PeekExpectedType(0' expElemType' changed);                              return state.Pop(2);                          }                      case MiscOp.LdelemRef:                          {                              state.PeekIndexType(0);                              // WARNING: Type may not be final                              var elemType = state.PeekArrayOfReferenceType(1);                              return state.PopPushType(2' elemType' BottomPT);                          }                      case MiscOp.StelemRef:                          state.PeekReferenceType(0);                          state.PeekIndexType(1);                          state.PeekArrayOfReferenceType(2);                          // Since the value type and array element type may be independently generalized'                          // it is pointless to check that the first is assignable to the second.                          // Instead this check is done at runtime.                          return state.Pop(3);                      case MiscOp.Ldlen:                          state.PeekArrayOfAnyType(0);                          return state.PopPushType(1' global.IntNativeRef' BottomPT);                      case MiscOp.Ret:                          {                              if (state.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return state; // empty                          }                      case MiscOp.RetVal:                          {                              state.PeekExpectedType(0' method.Result.Type' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfilter:                          {                              state.PeekExpectedType(0' global.Int32Ref' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfinally:                          {                              // Control could transfer to an outer finally/fault block' or to the target                              // of a leave instruction. However these transitions are delt with separately.                              return state.DiscardStack();                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:                  {                      var bri = (BranchInstruction)instruction;                      switch (bri.Op)                      {                      case BranchOp.Br:                          UnifyBeforeState(state' bri.Target' changed);                          return state;                      case BranchOp.Brtrue:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' false);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Brfalse:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Breq:                      case BranchOp.Brne:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' true);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Leave:                          {                              // Control could transfer via finally blocks instead of directly to the leave target.                              // Propogate only that the stack must be empty at target. Remaining machine state                              // is dealt with separately.                              UnifyBeforeState                                  (new MachineState(methEnv' method.ValueParameters.Count' method.Locals.Count)'                                   bri.Target'                                   changed);                              return state.DiscardStack();                          }                      case BranchOp.BrLt:                      case BranchOp.BrLe:                      case BranchOp.BrGt:                      case BranchOp.BrGe:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' false);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Switch:                  {                      var switchi = (SwitchInstruction)instruction;                      state.PeekExpectedType(0' global.Int32Ref' changed);                      var newState = state.Pop(1);                      for (var i = 0; i < switchi.CaseTargets.Count; i++)                          UnifyBeforeState(newState' switchi.CaseTargets[i]' changed);                      return newState;                  }              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      // WARNING: Capured type may not be final                      // NOTE: May capture skolemized types                      switch (cmpi.Op)                      {                      case CompareOp.Ceq:                      case CompareOp.CnePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' true);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.Clt:                      case CompareOp.Cgt:                      case CompareOp.CgePseudo:                      case CompareOp.ClePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' false);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.CtruePseudo:                      case CompareOp.CfalsePseudo:                          cmpi.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                          return state.PopPushType(1' global.Int32Ref' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var argi = (ArgLocalInstruction)instruction;                      var type = method.ArgLocalType(argi.ArgLocal' argi.Index);                      switch (argi.Op)                      {                      case ArgLocalOp.Ld:                          return state.PushType(type' state.ArgLocalPointsTo(argi.ArgLocal' argi.Index));                      case ArgLocalOp.Lda:                          return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(type)' ArgLocalPT(argi.ArgLocal' argi.Index));                      case ArgLocalOp.St:                          {                              state.PeekExpectedType(0' type' changed);                              var pointsTo = state.PeekPointsTo(0);                              if (!pointsTo.IsBottom)                              {                                  if (!(type.Style(methEnv) is ManagedPointerTypeStyle))                                      throw new InvalidOperationException                                          ("stack indicates pointer' but parameter or local type does not");                                  if (pointsTo.PointsOutsideOfHeap)                                      throw new InvalidOperationException("arguments cannot point outside of the heap");                              }                              return state.PopAddArgLocalPointsTo(1' argi.ArgLocal' argi.Index' pointsTo);                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      var fieldEnv = fieldi.Field.Enter(methEnv);                      var fieldType = fieldEnv.SubstituteType(fieldEnv.Field.FieldType);                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                              return state.PushType(fieldType' BottomPT);                          else                          {                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' true' changed);                              return state.PopPushType(1' fieldType' BottomPT);                          }                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                              return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          else                          {                              // Underlying type cannot be a struct' otherwise would have a pointer into                              // the stack                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' false' changed);                              return state.PopPushType                                  (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          }                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                          {                              state.PeekExpectedType(0' fieldType' changed);                              return state.Pop(1);                          }                          else                          {                              state.PeekExpectedType(0' fieldType' changed);                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (1' fieldi.Field.DefiningType' false' changed);                              return state.Pop(2);                          }                      case FieldOp.Ldtoken:                          return state.PushType(global.RuntimeFieldHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methi = (MethodInstruction)instruction;                      var sig = (CST.MethodSignature)methi.Method.ExternalSignature;                      switch (methi.Op)                      {                      case MethodOp.Call:                          {                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              if (methi.Constrained != null)                              {                                  if (!methi.IsVirtual || methi.Method.IsStatic)                                      throw new InvalidOperationException                                          ("constrained only valid on virtual calls to instance methods");                                  var thisType = sig.Parameters[0];                                  var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(methi.Constrained);                                  var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo(methi.Constrained);                                  var cs = methi.Constrained.Style(methEnv);                                  if (cs is ValueTypeStyle)                                  {                                      if (thisType.Style(methEnv) is ManagedPointerTypeStyle)                                      {                                          // We pass the argument pointer as is                                          if (!methi.Constrained.IsAssignableTo(methEnv' thisType.Arguments[0]))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                      else                                      {                                          // *Case 1* Morally we deref the argument pointer and box the contents'                                          // but since no supertype of a value type may mutate the underlying value'                                          // we don't need to take a copy of the value when boxing' so in practice                                          // this is a no-op                                          if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                  }                                  else if (cs is ReferenceTypeStyle)                                  {                                      // *Case 2* We dereference the pointer and pass the object reference                                      if (!methi.Constrained.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else if (cs is ParameterTypeStyle)                                  {                                      // Since we are calling an instance method' we know the first argument cannot be                                      // a "naked" type parameter' but is either a class or an interface.                                      // We must decide between cases 1 and 2 above at runtime' but checking as                                      // per case 1 is sufficient now.                                      // NOTE: As for box/classcast/isinst below' if the parameter is                                      // instantiated to a reference type then the type box type is considered                                      // equivalent to the underyling reference type.                                      if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else                                      throw new InvalidOperationException                                          ("constrained must be value' reference or parameter type");                                    state.PeekExpectedType(sig.Parameters.Count - 1' constrainedPtr' changed);                              }                              else if (sig.Parameters.Count > 0)                                  state.PeekExpectedType(sig.Parameters.Count - 1' sig.Parameters[0]' changed);                              if (sig.Result == null)                                  return state.Pop(sig.Parameters.Count);                              else                                  return state.PopPushType(sig.Parameters.Count' sig.Result' BottomPT);                          }                      case MethodOp.Ldftn:                          {                              // NOTE: Verified CLR allows only the two "blessed" sequences:                              //   dup; ldvirtftn; newobj <delegate ctor>                              //   ldftn; newobj <delegate ctor>                              // It is thus possible to check the delegate will capture an instance which                              // implements the loaded method. However' we don't check that here.                              if (methi.IsVirtual)                              {                                  if (methi.Method.IsStatic)                                      throw new InvalidOperationException("cannot ldvirtftn of a static method");                                  var objectType = default(TypeRef);                                  if (sig.Parameters[0].Style(methEnv) is ManagedPointerTypeStyle)                                      // Object should be a box                                      objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(sig.Parameters[0].Arguments[0]);                                  else                                      // Object should match parameter                                      objectType = sig.Parameters[0];                                  state.PeekExpectedType(0' objectType' changed);                                  return state.PopPushType(1' sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                              else                              {                                  if (methi.Method.IsStatic)                                      return state.PushType(sig.ToCodePointer(methEnv.Global)' BottomPT);                                  else                                      return state.PushType(sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                          }                      case MethodOp.Newobj:                          {                              if (methi.Method.IsStatic || sig.Result != null)                                  throw new InvalidOperationException("not a constructor");                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              // First argument to constructor is created by runtime. If definining type is                              // a value type' first argument will be a pointer' but result left on stack                              // will be the value itself.                              return state.PopPushType(sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);                          }                      case MethodOp.Ldtoken:                          return state.PushType(global.RuntimeMethodHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          state.PeekReadPointerType(0' typei.Type);                          return state.PopPushType(1' typei.Type' BottomPT);                      case TypeOp.Stobj:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Cpobj:                          state.PeekReadPointerType(0' typei.Type);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Newarr:                          state.PeekIndexType(0);                          return state.PopPushType(1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo(typei.Type)' BottomPT);                      case TypeOp.Initobj:                          state.PeekWritePointerType(0' typei.Type);                          return state.Pop(1);                      case TypeOp.Castclass:                      case TypeOp.Isinst:                      case TypeOp.Box:                          {                              var resultType = default(TypeRef);                              var s = typei.Type.Style(methEnv);                              if (s is NullableTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type.Arguments[0]);                              else if (s is ValueTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else if (s is ReferenceTypeStyle)                                  resultType = typei.Type;                              else if (s is ParameterTypeStyle)                                  // NOTE: As for constrained call above' if type parameter is instantitated to                                  // a ref type' then this box type is considered equivalent to the                                  // underlying reference type.                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else                                  throw new InvalidOperationException                                      ("can only box/cast to reference' value or parameter type");                              if (typei.Op == TypeOp.Box)                                  state.PeekExpectedType(0' typei.Type' changed);                              else                                  state.PeekReferenceType(0);                              return state.PopPushType(1' resultType' BottomPT);                          }                      case TypeOp.Unbox:                          if (!(typei.Type.Style(methEnv) is ValueTypeStyle))                              // Parameter types are not allowed                              throw new InvalidOperationException("type must be a value type");                          state.PeekBoxedType(0' typei.Type' changed);                          return state.PopPushType(1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(typei.Type)' HeapPT);                      case TypeOp.UnboxAny:                          {                              var s = typei.Type.Style(methEnv);                              if (s is ValueTypeStyle)                                  state.PeekBoxedType(0' typei.Type' changed);                              else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))                                  throw new InvalidOperationException("type must be value' reference or parameter type");                              return state.PopPushType(1' typei.Type' BottomPT);                          }                      case TypeOp.Ldtoken:                          return state.PushType(global.RuntimeTypeHandleRef' BottomPT);                      case TypeOp.Ldelem:                          state.PeekIndexType(0);                          state.PeekReadArrayType(1' typei.Type' false);                          return state.PopPushType(2' typei.Type' BottomPT);                      case TypeOp.Stelem:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekIndexType(1);                          state.PeekWriteArrayType(2' typei.Type);                          return state.Pop(3);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  {                      var ldelemai = (LdElemAddrInstruction)instruction;                      state.PeekIndexType(0);                      // WARNING: May prematurely fail for non-readonly loads                      state.PeekReadArrayType(1' ldelemai.Type' !ldelemai.IsReadonly);                      return state.PopPushType(2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(ldelemai.Type)' HeapPT);                  }              case InstructionFlavor.LdInt32:                  return state.PushType(global.Int32Ref' BottomPT);              case InstructionFlavor.LdInt64:                  return state.PushType(global.Int64Ref' BottomPT);              case InstructionFlavor.LdSingle:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdDouble:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdString:                  return state.PushType(global.StringRef' BottomPT);              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.Div:                      case ArithOp.Rem:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' true);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.Neg:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' true);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' false);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.BitNot:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.Shl:                      case ArithOp.Shr:                          state.PeekExpectedType(0' global.Int32Ref' changed);                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(1' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(2' arithi.Type' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned &&                                           convi.TargetNumberFlavor == NumberFlavor.Double);                      // NOTE: May capture skolemized types                      convi.SourceType = state.PeekNumberType(0' !mustBeInteger);                      return state.PopPushType(1' TypeRef.NumberFrom(methEnv.Global' convi.TargetNumberFlavor)' BottomPT);                  }              case InstructionFlavor.Try:                  {                      var tryi = (TryInstruction)instruction;                      // Isolation:                      //  - There is no way for the current stack shape to influence or be influenced by                      //    inference of the try' since the current stack shape must be empty.                      //  - There is no way for the try to influence the result stack shape' since it must be                      //    empty.                      //  - However pointers in arguments and locals may propogate into and out of try body                      //    via exceptional transitions. The latter are delt with separately.                      if (state.Depth != 0)                          throw new InvalidOperationException("stack should be empty");                      var newState = ForwardBlock                          (new TryBodyInstructionContext(context' index' tryi.Body)' state' changed);                      for (var j = 0; j < tryi.Handlers.Count; j++)                      {                          var h = tryi.Handlers[j];                          var handlerContext = new TryHandlerInstructionContext(context' index' h.Body' j);                          var initHandlerState = new MachineState                              (methEnv' method.ValueParameters.Count' method.Locals.Count);                          switch (h.Flavor)                          {                          case HandlerFlavor.Catch:                              {                                  var catchh = (CatchTryInstructionHandler)h;                                  ForwardBlock(handlerContext' initHandlerState.PushType(catchh.Type' BottomPT)' changed);                                  break;                              }                          case HandlerFlavor.Filter:                              throw new NotSupportedException("filter handler blocks");                          case HandlerFlavor.Fault:                          case HandlerFlavor.Finally:                              ForwardBlock(handlerContext' initHandlerState' changed);                              break;                          default:                              throw new ArgumentOutOfRangeException();                          }                      }                      return newState;                  }              case InstructionFlavor.IfThenElsePseudo:              case InstructionFlavor.ShortCircuitingPseudo:              case InstructionFlavor.StructuralSwitchPseudo:              case InstructionFlavor.LoopPseudo:              case InstructionFlavor.WhileDoPseudo:              case InstructionFlavor.DoWhilePseudo:              case InstructionFlavor.LoopControlPseudo:                  throw new InvalidOperationException("no machine state inference for psuedo-instructions");              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return state;                      case MiscOp.Dup:                          return state.Push(state.Peek(0));                      case MiscOp.Pop:                          return state.Pop(1);                      case MiscOp.Ldnull:                          return state.PushType(global.NullRef' BottomPT);                      case MiscOp.Ckfinite:                          state.PeekExpectedType(0' global.DoubleRef' changed);                          // Assume the instruction can "peek" at top of stack' thus no need for pop/push.                          return state;                      case MiscOp.Throw:                          state.PeekReferenceType(0);                          return state.DiscardStack();                      case MiscOp.Rethrow:                          return state.DiscardStack();                      case MiscOp.LdindRef:                          {                              var elemType = state.PeekPointerToReferenceType(0);                              return state.PopPushType(1' elemType' BottomPT);                          }                      case MiscOp.StindRef:                          {                              var expElemType = state.PeekPointerToReferenceType(1);                              state.PeekExpectedType(0' expElemType' changed);                              return state.Pop(2);                          }                      case MiscOp.LdelemRef:                          {                              state.PeekIndexType(0);                              // WARNING: Type may not be final                              var elemType = state.PeekArrayOfReferenceType(1);                              return state.PopPushType(2' elemType' BottomPT);                          }                      case MiscOp.StelemRef:                          state.PeekReferenceType(0);                          state.PeekIndexType(1);                          state.PeekArrayOfReferenceType(2);                          // Since the value type and array element type may be independently generalized'                          // it is pointless to check that the first is assignable to the second.                          // Instead this check is done at runtime.                          return state.Pop(3);                      case MiscOp.Ldlen:                          state.PeekArrayOfAnyType(0);                          return state.PopPushType(1' global.IntNativeRef' BottomPT);                      case MiscOp.Ret:                          {                              if (state.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return state; // empty                          }                      case MiscOp.RetVal:                          {                              state.PeekExpectedType(0' method.Result.Type' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfilter:                          {                              state.PeekExpectedType(0' global.Int32Ref' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfinally:                          {                              // Control could transfer to an outer finally/fault block' or to the target                              // of a leave instruction. However these transitions are delt with separately.                              return state.DiscardStack();                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:                  {                      var bri = (BranchInstruction)instruction;                      switch (bri.Op)                      {                      case BranchOp.Br:                          UnifyBeforeState(state' bri.Target' changed);                          return state;                      case BranchOp.Brtrue:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' false);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Brfalse:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Breq:                      case BranchOp.Brne:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' true);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Leave:                          {                              // Control could transfer via finally blocks instead of directly to the leave target.                              // Propogate only that the stack must be empty at target. Remaining machine state                              // is dealt with separately.                              UnifyBeforeState                                  (new MachineState(methEnv' method.ValueParameters.Count' method.Locals.Count)'                                   bri.Target'                                   changed);                              return state.DiscardStack();                          }                      case BranchOp.BrLt:                      case BranchOp.BrLe:                      case BranchOp.BrGt:                      case BranchOp.BrGe:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' false);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Switch:                  {                      var switchi = (SwitchInstruction)instruction;                      state.PeekExpectedType(0' global.Int32Ref' changed);                      var newState = state.Pop(1);                      for (var i = 0; i < switchi.CaseTargets.Count; i++)                          UnifyBeforeState(newState' switchi.CaseTargets[i]' changed);                      return newState;                  }              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      // WARNING: Capured type may not be final                      // NOTE: May capture skolemized types                      switch (cmpi.Op)                      {                      case CompareOp.Ceq:                      case CompareOp.CnePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' true);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.Clt:                      case CompareOp.Cgt:                      case CompareOp.CgePseudo:                      case CompareOp.ClePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' false);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.CtruePseudo:                      case CompareOp.CfalsePseudo:                          cmpi.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                          return state.PopPushType(1' global.Int32Ref' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var argi = (ArgLocalInstruction)instruction;                      var type = method.ArgLocalType(argi.ArgLocal' argi.Index);                      switch (argi.Op)                      {                      case ArgLocalOp.Ld:                          return state.PushType(type' state.ArgLocalPointsTo(argi.ArgLocal' argi.Index));                      case ArgLocalOp.Lda:                          return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(type)' ArgLocalPT(argi.ArgLocal' argi.Index));                      case ArgLocalOp.St:                          {                              state.PeekExpectedType(0' type' changed);                              var pointsTo = state.PeekPointsTo(0);                              if (!pointsTo.IsBottom)                              {                                  if (!(type.Style(methEnv) is ManagedPointerTypeStyle))                                      throw new InvalidOperationException                                          ("stack indicates pointer' but parameter or local type does not");                                  if (pointsTo.PointsOutsideOfHeap)                                      throw new InvalidOperationException("arguments cannot point outside of the heap");                              }                              return state.PopAddArgLocalPointsTo(1' argi.ArgLocal' argi.Index' pointsTo);                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      var fieldEnv = fieldi.Field.Enter(methEnv);                      var fieldType = fieldEnv.SubstituteType(fieldEnv.Field.FieldType);                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                              return state.PushType(fieldType' BottomPT);                          else                          {                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' true' changed);                              return state.PopPushType(1' fieldType' BottomPT);                          }                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                              return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          else                          {                              // Underlying type cannot be a struct' otherwise would have a pointer into                              // the stack                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' false' changed);                              return state.PopPushType                                  (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          }                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                          {                              state.PeekExpectedType(0' fieldType' changed);                              return state.Pop(1);                          }                          else                          {                              state.PeekExpectedType(0' fieldType' changed);                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (1' fieldi.Field.DefiningType' false' changed);                              return state.Pop(2);                          }                      case FieldOp.Ldtoken:                          return state.PushType(global.RuntimeFieldHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methi = (MethodInstruction)instruction;                      var sig = (CST.MethodSignature)methi.Method.ExternalSignature;                      switch (methi.Op)                      {                      case MethodOp.Call:                          {                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              if (methi.Constrained != null)                              {                                  if (!methi.IsVirtual || methi.Method.IsStatic)                                      throw new InvalidOperationException                                          ("constrained only valid on virtual calls to instance methods");                                  var thisType = sig.Parameters[0];                                  var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(methi.Constrained);                                  var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo(methi.Constrained);                                  var cs = methi.Constrained.Style(methEnv);                                  if (cs is ValueTypeStyle)                                  {                                      if (thisType.Style(methEnv) is ManagedPointerTypeStyle)                                      {                                          // We pass the argument pointer as is                                          if (!methi.Constrained.IsAssignableTo(methEnv' thisType.Arguments[0]))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                      else                                      {                                          // *Case 1* Morally we deref the argument pointer and box the contents'                                          // but since no supertype of a value type may mutate the underlying value'                                          // we don't need to take a copy of the value when boxing' so in practice                                          // this is a no-op                                          if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                  }                                  else if (cs is ReferenceTypeStyle)                                  {                                      // *Case 2* We dereference the pointer and pass the object reference                                      if (!methi.Constrained.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else if (cs is ParameterTypeStyle)                                  {                                      // Since we are calling an instance method' we know the first argument cannot be                                      // a "naked" type parameter' but is either a class or an interface.                                      // We must decide between cases 1 and 2 above at runtime' but checking as                                      // per case 1 is sufficient now.                                      // NOTE: As for box/classcast/isinst below' if the parameter is                                      // instantiated to a reference type then the type box type is considered                                      // equivalent to the underyling reference type.                                      if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else                                      throw new InvalidOperationException                                          ("constrained must be value' reference or parameter type");                                    state.PeekExpectedType(sig.Parameters.Count - 1' constrainedPtr' changed);                              }                              else if (sig.Parameters.Count > 0)                                  state.PeekExpectedType(sig.Parameters.Count - 1' sig.Parameters[0]' changed);                              if (sig.Result == null)                                  return state.Pop(sig.Parameters.Count);                              else                                  return state.PopPushType(sig.Parameters.Count' sig.Result' BottomPT);                          }                      case MethodOp.Ldftn:                          {                              // NOTE: Verified CLR allows only the two "blessed" sequences:                              //   dup; ldvirtftn; newobj <delegate ctor>                              //   ldftn; newobj <delegate ctor>                              // It is thus possible to check the delegate will capture an instance which                              // implements the loaded method. However' we don't check that here.                              if (methi.IsVirtual)                              {                                  if (methi.Method.IsStatic)                                      throw new InvalidOperationException("cannot ldvirtftn of a static method");                                  var objectType = default(TypeRef);                                  if (sig.Parameters[0].Style(methEnv) is ManagedPointerTypeStyle)                                      // Object should be a box                                      objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(sig.Parameters[0].Arguments[0]);                                  else                                      // Object should match parameter                                      objectType = sig.Parameters[0];                                  state.PeekExpectedType(0' objectType' changed);                                  return state.PopPushType(1' sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                              else                              {                                  if (methi.Method.IsStatic)                                      return state.PushType(sig.ToCodePointer(methEnv.Global)' BottomPT);                                  else                                      return state.PushType(sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                          }                      case MethodOp.Newobj:                          {                              if (methi.Method.IsStatic || sig.Result != null)                                  throw new InvalidOperationException("not a constructor");                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              // First argument to constructor is created by runtime. If definining type is                              // a value type' first argument will be a pointer' but result left on stack                              // will be the value itself.                              return state.PopPushType(sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);                          }                      case MethodOp.Ldtoken:                          return state.PushType(global.RuntimeMethodHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          state.PeekReadPointerType(0' typei.Type);                          return state.PopPushType(1' typei.Type' BottomPT);                      case TypeOp.Stobj:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Cpobj:                          state.PeekReadPointerType(0' typei.Type);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Newarr:                          state.PeekIndexType(0);                          return state.PopPushType(1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo(typei.Type)' BottomPT);                      case TypeOp.Initobj:                          state.PeekWritePointerType(0' typei.Type);                          return state.Pop(1);                      case TypeOp.Castclass:                      case TypeOp.Isinst:                      case TypeOp.Box:                          {                              var resultType = default(TypeRef);                              var s = typei.Type.Style(methEnv);                              if (s is NullableTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type.Arguments[0]);                              else if (s is ValueTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else if (s is ReferenceTypeStyle)                                  resultType = typei.Type;                              else if (s is ParameterTypeStyle)                                  // NOTE: As for constrained call above' if type parameter is instantitated to                                  // a ref type' then this box type is considered equivalent to the                                  // underlying reference type.                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else                                  throw new InvalidOperationException                                      ("can only box/cast to reference' value or parameter type");                              if (typei.Op == TypeOp.Box)                                  state.PeekExpectedType(0' typei.Type' changed);                              else                                  state.PeekReferenceType(0);                              return state.PopPushType(1' resultType' BottomPT);                          }                      case TypeOp.Unbox:                          if (!(typei.Type.Style(methEnv) is ValueTypeStyle))                              // Parameter types are not allowed                              throw new InvalidOperationException("type must be a value type");                          state.PeekBoxedType(0' typei.Type' changed);                          return state.PopPushType(1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(typei.Type)' HeapPT);                      case TypeOp.UnboxAny:                          {                              var s = typei.Type.Style(methEnv);                              if (s is ValueTypeStyle)                                  state.PeekBoxedType(0' typei.Type' changed);                              else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))                                  throw new InvalidOperationException("type must be value' reference or parameter type");                              return state.PopPushType(1' typei.Type' BottomPT);                          }                      case TypeOp.Ldtoken:                          return state.PushType(global.RuntimeTypeHandleRef' BottomPT);                      case TypeOp.Ldelem:                          state.PeekIndexType(0);                          state.PeekReadArrayType(1' typei.Type' false);                          return state.PopPushType(2' typei.Type' BottomPT);                      case TypeOp.Stelem:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekIndexType(1);                          state.PeekWriteArrayType(2' typei.Type);                          return state.Pop(3);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  {                      var ldelemai = (LdElemAddrInstruction)instruction;                      state.PeekIndexType(0);                      // WARNING: May prematurely fail for non-readonly loads                      state.PeekReadArrayType(1' ldelemai.Type' !ldelemai.IsReadonly);                      return state.PopPushType(2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(ldelemai.Type)' HeapPT);                  }              case InstructionFlavor.LdInt32:                  return state.PushType(global.Int32Ref' BottomPT);              case InstructionFlavor.LdInt64:                  return state.PushType(global.Int64Ref' BottomPT);              case InstructionFlavor.LdSingle:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdDouble:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdString:                  return state.PushType(global.StringRef' BottomPT);              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.Div:                      case ArithOp.Rem:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' true);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.Neg:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' true);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' false);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.BitNot:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.Shl:                      case ArithOp.Shr:                          state.PeekExpectedType(0' global.Int32Ref' changed);                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(1' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(2' arithi.Type' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned &&                                           convi.TargetNumberFlavor == NumberFlavor.Double);                      // NOTE: May capture skolemized types                      convi.SourceType = state.PeekNumberType(0' !mustBeInteger);                      return state.PopPushType(1' TypeRef.NumberFrom(methEnv.Global' convi.TargetNumberFlavor)' BottomPT);                  }              case InstructionFlavor.Try:                  {                      var tryi = (TryInstruction)instruction;                      // Isolation:                      //  - There is no way for the current stack shape to influence or be influenced by                      //    inference of the try' since the current stack shape must be empty.                      //  - There is no way for the try to influence the result stack shape' since it must be                      //    empty.                      //  - However pointers in arguments and locals may propogate into and out of try body                      //    via exceptional transitions. The latter are delt with separately.                      if (state.Depth != 0)                          throw new InvalidOperationException("stack should be empty");                      var newState = ForwardBlock                          (new TryBodyInstructionContext(context' index' tryi.Body)' state' changed);                      for (var j = 0; j < tryi.Handlers.Count; j++)                      {                          var h = tryi.Handlers[j];                          var handlerContext = new TryHandlerInstructionContext(context' index' h.Body' j);                          var initHandlerState = new MachineState                              (methEnv' method.ValueParameters.Count' method.Locals.Count);                          switch (h.Flavor)                          {                          case HandlerFlavor.Catch:                              {                                  var catchh = (CatchTryInstructionHandler)h;                                  ForwardBlock(handlerContext' initHandlerState.PushType(catchh.Type' BottomPT)' changed);                                  break;                              }                          case HandlerFlavor.Filter:                              throw new NotSupportedException("filter handler blocks");                          case HandlerFlavor.Fault:                          case HandlerFlavor.Finally:                              ForwardBlock(handlerContext' initHandlerState' changed);                              break;                          default:                              throw new ArgumentOutOfRangeException();                          }                      }                      return newState;                  }              case InstructionFlavor.IfThenElsePseudo:              case InstructionFlavor.ShortCircuitingPseudo:              case InstructionFlavor.StructuralSwitchPseudo:              case InstructionFlavor.LoopPseudo:              case InstructionFlavor.WhileDoPseudo:              case InstructionFlavor.DoWhilePseudo:              case InstructionFlavor.LoopControlPseudo:                  throw new InvalidOperationException("no machine state inference for psuedo-instructions");              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return state;                      case MiscOp.Dup:                          return state.Push(state.Peek(0));                      case MiscOp.Pop:                          return state.Pop(1);                      case MiscOp.Ldnull:                          return state.PushType(global.NullRef' BottomPT);                      case MiscOp.Ckfinite:                          state.PeekExpectedType(0' global.DoubleRef' changed);                          // Assume the instruction can "peek" at top of stack' thus no need for pop/push.                          return state;                      case MiscOp.Throw:                          state.PeekReferenceType(0);                          return state.DiscardStack();                      case MiscOp.Rethrow:                          return state.DiscardStack();                      case MiscOp.LdindRef:                          {                              var elemType = state.PeekPointerToReferenceType(0);                              return state.PopPushType(1' elemType' BottomPT);                          }                      case MiscOp.StindRef:                          {                              var expElemType = state.PeekPointerToReferenceType(1);                              state.PeekExpectedType(0' expElemType' changed);                              return state.Pop(2);                          }                      case MiscOp.LdelemRef:                          {                              state.PeekIndexType(0);                              // WARNING: Type may not be final                              var elemType = state.PeekArrayOfReferenceType(1);                              return state.PopPushType(2' elemType' BottomPT);                          }                      case MiscOp.StelemRef:                          state.PeekReferenceType(0);                          state.PeekIndexType(1);                          state.PeekArrayOfReferenceType(2);                          // Since the value type and array element type may be independently generalized'                          // it is pointless to check that the first is assignable to the second.                          // Instead this check is done at runtime.                          return state.Pop(3);                      case MiscOp.Ldlen:                          state.PeekArrayOfAnyType(0);                          return state.PopPushType(1' global.IntNativeRef' BottomPT);                      case MiscOp.Ret:                          {                              if (state.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return state; // empty                          }                      case MiscOp.RetVal:                          {                              state.PeekExpectedType(0' method.Result.Type' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfilter:                          {                              state.PeekExpectedType(0' global.Int32Ref' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfinally:                          {                              // Control could transfer to an outer finally/fault block' or to the target                              // of a leave instruction. However these transitions are delt with separately.                              return state.DiscardStack();                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:                  {                      var bri = (BranchInstruction)instruction;                      switch (bri.Op)                      {                      case BranchOp.Br:                          UnifyBeforeState(state' bri.Target' changed);                          return state;                      case BranchOp.Brtrue:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' false);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Brfalse:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Breq:                      case BranchOp.Brne:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' true);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Leave:                          {                              // Control could transfer via finally blocks instead of directly to the leave target.                              // Propogate only that the stack must be empty at target. Remaining machine state                              // is dealt with separately.                              UnifyBeforeState                                  (new MachineState(methEnv' method.ValueParameters.Count' method.Locals.Count)'                                   bri.Target'                                   changed);                              return state.DiscardStack();                          }                      case BranchOp.BrLt:                      case BranchOp.BrLe:                      case BranchOp.BrGt:                      case BranchOp.BrGe:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' false);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Switch:                  {                      var switchi = (SwitchInstruction)instruction;                      state.PeekExpectedType(0' global.Int32Ref' changed);                      var newState = state.Pop(1);                      for (var i = 0; i < switchi.CaseTargets.Count; i++)                          UnifyBeforeState(newState' switchi.CaseTargets[i]' changed);                      return newState;                  }              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      // WARNING: Capured type may not be final                      // NOTE: May capture skolemized types                      switch (cmpi.Op)                      {                      case CompareOp.Ceq:                      case CompareOp.CnePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' true);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.Clt:                      case CompareOp.Cgt:                      case CompareOp.CgePseudo:                      case CompareOp.ClePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' false);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.CtruePseudo:                      case CompareOp.CfalsePseudo:                          cmpi.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                          return state.PopPushType(1' global.Int32Ref' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var argi = (ArgLocalInstruction)instruction;                      var type = method.ArgLocalType(argi.ArgLocal' argi.Index);                      switch (argi.Op)                      {                      case ArgLocalOp.Ld:                          return state.PushType(type' state.ArgLocalPointsTo(argi.ArgLocal' argi.Index));                      case ArgLocalOp.Lda:                          return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(type)' ArgLocalPT(argi.ArgLocal' argi.Index));                      case ArgLocalOp.St:                          {                              state.PeekExpectedType(0' type' changed);                              var pointsTo = state.PeekPointsTo(0);                              if (!pointsTo.IsBottom)                              {                                  if (!(type.Style(methEnv) is ManagedPointerTypeStyle))                                      throw new InvalidOperationException                                          ("stack indicates pointer' but parameter or local type does not");                                  if (pointsTo.PointsOutsideOfHeap)                                      throw new InvalidOperationException("arguments cannot point outside of the heap");                              }                              return state.PopAddArgLocalPointsTo(1' argi.ArgLocal' argi.Index' pointsTo);                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      var fieldEnv = fieldi.Field.Enter(methEnv);                      var fieldType = fieldEnv.SubstituteType(fieldEnv.Field.FieldType);                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                              return state.PushType(fieldType' BottomPT);                          else                          {                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' true' changed);                              return state.PopPushType(1' fieldType' BottomPT);                          }                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                              return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          else                          {                              // Underlying type cannot be a struct' otherwise would have a pointer into                              // the stack                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' false' changed);                              return state.PopPushType                                  (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          }                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                          {                              state.PeekExpectedType(0' fieldType' changed);                              return state.Pop(1);                          }                          else                          {                              state.PeekExpectedType(0' fieldType' changed);                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (1' fieldi.Field.DefiningType' false' changed);                              return state.Pop(2);                          }                      case FieldOp.Ldtoken:                          return state.PushType(global.RuntimeFieldHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methi = (MethodInstruction)instruction;                      var sig = (CST.MethodSignature)methi.Method.ExternalSignature;                      switch (methi.Op)                      {                      case MethodOp.Call:                          {                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              if (methi.Constrained != null)                              {                                  if (!methi.IsVirtual || methi.Method.IsStatic)                                      throw new InvalidOperationException                                          ("constrained only valid on virtual calls to instance methods");                                  var thisType = sig.Parameters[0];                                  var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(methi.Constrained);                                  var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo(methi.Constrained);                                  var cs = methi.Constrained.Style(methEnv);                                  if (cs is ValueTypeStyle)                                  {                                      if (thisType.Style(methEnv) is ManagedPointerTypeStyle)                                      {                                          // We pass the argument pointer as is                                          if (!methi.Constrained.IsAssignableTo(methEnv' thisType.Arguments[0]))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                      else                                      {                                          // *Case 1* Morally we deref the argument pointer and box the contents'                                          // but since no supertype of a value type may mutate the underlying value'                                          // we don't need to take a copy of the value when boxing' so in practice                                          // this is a no-op                                          if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                  }                                  else if (cs is ReferenceTypeStyle)                                  {                                      // *Case 2* We dereference the pointer and pass the object reference                                      if (!methi.Constrained.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else if (cs is ParameterTypeStyle)                                  {                                      // Since we are calling an instance method' we know the first argument cannot be                                      // a "naked" type parameter' but is either a class or an interface.                                      // We must decide between cases 1 and 2 above at runtime' but checking as                                      // per case 1 is sufficient now.                                      // NOTE: As for box/classcast/isinst below' if the parameter is                                      // instantiated to a reference type then the type box type is considered                                      // equivalent to the underyling reference type.                                      if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else                                      throw new InvalidOperationException                                          ("constrained must be value' reference or parameter type");                                    state.PeekExpectedType(sig.Parameters.Count - 1' constrainedPtr' changed);                              }                              else if (sig.Parameters.Count > 0)                                  state.PeekExpectedType(sig.Parameters.Count - 1' sig.Parameters[0]' changed);                              if (sig.Result == null)                                  return state.Pop(sig.Parameters.Count);                              else                                  return state.PopPushType(sig.Parameters.Count' sig.Result' BottomPT);                          }                      case MethodOp.Ldftn:                          {                              // NOTE: Verified CLR allows only the two "blessed" sequences:                              //   dup; ldvirtftn; newobj <delegate ctor>                              //   ldftn; newobj <delegate ctor>                              // It is thus possible to check the delegate will capture an instance which                              // implements the loaded method. However' we don't check that here.                              if (methi.IsVirtual)                              {                                  if (methi.Method.IsStatic)                                      throw new InvalidOperationException("cannot ldvirtftn of a static method");                                  var objectType = default(TypeRef);                                  if (sig.Parameters[0].Style(methEnv) is ManagedPointerTypeStyle)                                      // Object should be a box                                      objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(sig.Parameters[0].Arguments[0]);                                  else                                      // Object should match parameter                                      objectType = sig.Parameters[0];                                  state.PeekExpectedType(0' objectType' changed);                                  return state.PopPushType(1' sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                              else                              {                                  if (methi.Method.IsStatic)                                      return state.PushType(sig.ToCodePointer(methEnv.Global)' BottomPT);                                  else                                      return state.PushType(sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                          }                      case MethodOp.Newobj:                          {                              if (methi.Method.IsStatic || sig.Result != null)                                  throw new InvalidOperationException("not a constructor");                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              // First argument to constructor is created by runtime. If definining type is                              // a value type' first argument will be a pointer' but result left on stack                              // will be the value itself.                              return state.PopPushType(sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);                          }                      case MethodOp.Ldtoken:                          return state.PushType(global.RuntimeMethodHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          state.PeekReadPointerType(0' typei.Type);                          return state.PopPushType(1' typei.Type' BottomPT);                      case TypeOp.Stobj:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Cpobj:                          state.PeekReadPointerType(0' typei.Type);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Newarr:                          state.PeekIndexType(0);                          return state.PopPushType(1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo(typei.Type)' BottomPT);                      case TypeOp.Initobj:                          state.PeekWritePointerType(0' typei.Type);                          return state.Pop(1);                      case TypeOp.Castclass:                      case TypeOp.Isinst:                      case TypeOp.Box:                          {                              var resultType = default(TypeRef);                              var s = typei.Type.Style(methEnv);                              if (s is NullableTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type.Arguments[0]);                              else if (s is ValueTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else if (s is ReferenceTypeStyle)                                  resultType = typei.Type;                              else if (s is ParameterTypeStyle)                                  // NOTE: As for constrained call above' if type parameter is instantitated to                                  // a ref type' then this box type is considered equivalent to the                                  // underlying reference type.                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else                                  throw new InvalidOperationException                                      ("can only box/cast to reference' value or parameter type");                              if (typei.Op == TypeOp.Box)                                  state.PeekExpectedType(0' typei.Type' changed);                              else                                  state.PeekReferenceType(0);                              return state.PopPushType(1' resultType' BottomPT);                          }                      case TypeOp.Unbox:                          if (!(typei.Type.Style(methEnv) is ValueTypeStyle))                              // Parameter types are not allowed                              throw new InvalidOperationException("type must be a value type");                          state.PeekBoxedType(0' typei.Type' changed);                          return state.PopPushType(1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(typei.Type)' HeapPT);                      case TypeOp.UnboxAny:                          {                              var s = typei.Type.Style(methEnv);                              if (s is ValueTypeStyle)                                  state.PeekBoxedType(0' typei.Type' changed);                              else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))                                  throw new InvalidOperationException("type must be value' reference or parameter type");                              return state.PopPushType(1' typei.Type' BottomPT);                          }                      case TypeOp.Ldtoken:                          return state.PushType(global.RuntimeTypeHandleRef' BottomPT);                      case TypeOp.Ldelem:                          state.PeekIndexType(0);                          state.PeekReadArrayType(1' typei.Type' false);                          return state.PopPushType(2' typei.Type' BottomPT);                      case TypeOp.Stelem:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekIndexType(1);                          state.PeekWriteArrayType(2' typei.Type);                          return state.Pop(3);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  {                      var ldelemai = (LdElemAddrInstruction)instruction;                      state.PeekIndexType(0);                      // WARNING: May prematurely fail for non-readonly loads                      state.PeekReadArrayType(1' ldelemai.Type' !ldelemai.IsReadonly);                      return state.PopPushType(2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(ldelemai.Type)' HeapPT);                  }              case InstructionFlavor.LdInt32:                  return state.PushType(global.Int32Ref' BottomPT);              case InstructionFlavor.LdInt64:                  return state.PushType(global.Int64Ref' BottomPT);              case InstructionFlavor.LdSingle:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdDouble:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdString:                  return state.PushType(global.StringRef' BottomPT);              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.Div:                      case ArithOp.Rem:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' true);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.Neg:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' true);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' false);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.BitNot:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.Shl:                      case ArithOp.Shr:                          state.PeekExpectedType(0' global.Int32Ref' changed);                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(1' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(2' arithi.Type' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned &&                                           convi.TargetNumberFlavor == NumberFlavor.Double);                      // NOTE: May capture skolemized types                      convi.SourceType = state.PeekNumberType(0' !mustBeInteger);                      return state.PopPushType(1' TypeRef.NumberFrom(methEnv.Global' convi.TargetNumberFlavor)' BottomPT);                  }              case InstructionFlavor.Try:                  {                      var tryi = (TryInstruction)instruction;                      // Isolation:                      //  - There is no way for the current stack shape to influence or be influenced by                      //    inference of the try' since the current stack shape must be empty.                      //  - There is no way for the try to influence the result stack shape' since it must be                      //    empty.                      //  - However pointers in arguments and locals may propogate into and out of try body                      //    via exceptional transitions. The latter are delt with separately.                      if (state.Depth != 0)                          throw new InvalidOperationException("stack should be empty");                      var newState = ForwardBlock                          (new TryBodyInstructionContext(context' index' tryi.Body)' state' changed);                      for (var j = 0; j < tryi.Handlers.Count; j++)                      {                          var h = tryi.Handlers[j];                          var handlerContext = new TryHandlerInstructionContext(context' index' h.Body' j);                          var initHandlerState = new MachineState                              (methEnv' method.ValueParameters.Count' method.Locals.Count);                          switch (h.Flavor)                          {                          case HandlerFlavor.Catch:                              {                                  var catchh = (CatchTryInstructionHandler)h;                                  ForwardBlock(handlerContext' initHandlerState.PushType(catchh.Type' BottomPT)' changed);                                  break;                              }                          case HandlerFlavor.Filter:                              throw new NotSupportedException("filter handler blocks");                          case HandlerFlavor.Fault:                          case HandlerFlavor.Finally:                              ForwardBlock(handlerContext' initHandlerState' changed);                              break;                          default:                              throw new ArgumentOutOfRangeException();                          }                      }                      return newState;                  }              case InstructionFlavor.IfThenElsePseudo:              case InstructionFlavor.ShortCircuitingPseudo:              case InstructionFlavor.StructuralSwitchPseudo:              case InstructionFlavor.LoopPseudo:              case InstructionFlavor.WhileDoPseudo:              case InstructionFlavor.DoWhilePseudo:              case InstructionFlavor.LoopControlPseudo:                  throw new InvalidOperationException("no machine state inference for psuedo-instructions");              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return state;                      case MiscOp.Dup:                          return state.Push(state.Peek(0));                      case MiscOp.Pop:                          return state.Pop(1);                      case MiscOp.Ldnull:                          return state.PushType(global.NullRef' BottomPT);                      case MiscOp.Ckfinite:                          state.PeekExpectedType(0' global.DoubleRef' changed);                          // Assume the instruction can "peek" at top of stack' thus no need for pop/push.                          return state;                      case MiscOp.Throw:                          state.PeekReferenceType(0);                          return state.DiscardStack();                      case MiscOp.Rethrow:                          return state.DiscardStack();                      case MiscOp.LdindRef:                          {                              var elemType = state.PeekPointerToReferenceType(0);                              return state.PopPushType(1' elemType' BottomPT);                          }                      case MiscOp.StindRef:                          {                              var expElemType = state.PeekPointerToReferenceType(1);                              state.PeekExpectedType(0' expElemType' changed);                              return state.Pop(2);                          }                      case MiscOp.LdelemRef:                          {                              state.PeekIndexType(0);                              // WARNING: Type may not be final                              var elemType = state.PeekArrayOfReferenceType(1);                              return state.PopPushType(2' elemType' BottomPT);                          }                      case MiscOp.StelemRef:                          state.PeekReferenceType(0);                          state.PeekIndexType(1);                          state.PeekArrayOfReferenceType(2);                          // Since the value type and array element type may be independently generalized'                          // it is pointless to check that the first is assignable to the second.                          // Instead this check is done at runtime.                          return state.Pop(3);                      case MiscOp.Ldlen:                          state.PeekArrayOfAnyType(0);                          return state.PopPushType(1' global.IntNativeRef' BottomPT);                      case MiscOp.Ret:                          {                              if (state.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return state; // empty                          }                      case MiscOp.RetVal:                          {                              state.PeekExpectedType(0' method.Result.Type' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfilter:                          {                              state.PeekExpectedType(0' global.Int32Ref' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfinally:                          {                              // Control could transfer to an outer finally/fault block' or to the target                              // of a leave instruction. However these transitions are delt with separately.                              return state.DiscardStack();                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:                  {                      var bri = (BranchInstruction)instruction;                      switch (bri.Op)                      {                      case BranchOp.Br:                          UnifyBeforeState(state' bri.Target' changed);                          return state;                      case BranchOp.Brtrue:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' false);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Brfalse:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Breq:                      case BranchOp.Brne:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' true);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Leave:                          {                              // Control could transfer via finally blocks instead of directly to the leave target.                              // Propogate only that the stack must be empty at target. Remaining machine state                              // is dealt with separately.                              UnifyBeforeState                                  (new MachineState(methEnv' method.ValueParameters.Count' method.Locals.Count)'                                   bri.Target'                                   changed);                              return state.DiscardStack();                          }                      case BranchOp.BrLt:                      case BranchOp.BrLe:                      case BranchOp.BrGt:                      case BranchOp.BrGe:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' false);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Switch:                  {                      var switchi = (SwitchInstruction)instruction;                      state.PeekExpectedType(0' global.Int32Ref' changed);                      var newState = state.Pop(1);                      for (var i = 0; i < switchi.CaseTargets.Count; i++)                          UnifyBeforeState(newState' switchi.CaseTargets[i]' changed);                      return newState;                  }              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      // WARNING: Capured type may not be final                      // NOTE: May capture skolemized types                      switch (cmpi.Op)                      {                      case CompareOp.Ceq:                      case CompareOp.CnePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' true);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.Clt:                      case CompareOp.Cgt:                      case CompareOp.CgePseudo:                      case CompareOp.ClePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' false);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.CtruePseudo:                      case CompareOp.CfalsePseudo:                          cmpi.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                          return state.PopPushType(1' global.Int32Ref' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var argi = (ArgLocalInstruction)instruction;                      var type = method.ArgLocalType(argi.ArgLocal' argi.Index);                      switch (argi.Op)                      {                      case ArgLocalOp.Ld:                          return state.PushType(type' state.ArgLocalPointsTo(argi.ArgLocal' argi.Index));                      case ArgLocalOp.Lda:                          return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(type)' ArgLocalPT(argi.ArgLocal' argi.Index));                      case ArgLocalOp.St:                          {                              state.PeekExpectedType(0' type' changed);                              var pointsTo = state.PeekPointsTo(0);                              if (!pointsTo.IsBottom)                              {                                  if (!(type.Style(methEnv) is ManagedPointerTypeStyle))                                      throw new InvalidOperationException                                          ("stack indicates pointer' but parameter or local type does not");                                  if (pointsTo.PointsOutsideOfHeap)                                      throw new InvalidOperationException("arguments cannot point outside of the heap");                              }                              return state.PopAddArgLocalPointsTo(1' argi.ArgLocal' argi.Index' pointsTo);                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      var fieldEnv = fieldi.Field.Enter(methEnv);                      var fieldType = fieldEnv.SubstituteType(fieldEnv.Field.FieldType);                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                              return state.PushType(fieldType' BottomPT);                          else                          {                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' true' changed);                              return state.PopPushType(1' fieldType' BottomPT);                          }                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                              return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          else                          {                              // Underlying type cannot be a struct' otherwise would have a pointer into                              // the stack                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' false' changed);                              return state.PopPushType                                  (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          }                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                          {                              state.PeekExpectedType(0' fieldType' changed);                              return state.Pop(1);                          }                          else                          {                              state.PeekExpectedType(0' fieldType' changed);                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (1' fieldi.Field.DefiningType' false' changed);                              return state.Pop(2);                          }                      case FieldOp.Ldtoken:                          return state.PushType(global.RuntimeFieldHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methi = (MethodInstruction)instruction;                      var sig = (CST.MethodSignature)methi.Method.ExternalSignature;                      switch (methi.Op)                      {                      case MethodOp.Call:                          {                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              if (methi.Constrained != null)                              {                                  if (!methi.IsVirtual || methi.Method.IsStatic)                                      throw new InvalidOperationException                                          ("constrained only valid on virtual calls to instance methods");                                  var thisType = sig.Parameters[0];                                  var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(methi.Constrained);                                  var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo(methi.Constrained);                                  var cs = methi.Constrained.Style(methEnv);                                  if (cs is ValueTypeStyle)                                  {                                      if (thisType.Style(methEnv) is ManagedPointerTypeStyle)                                      {                                          // We pass the argument pointer as is                                          if (!methi.Constrained.IsAssignableTo(methEnv' thisType.Arguments[0]))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                      else                                      {                                          // *Case 1* Morally we deref the argument pointer and box the contents'                                          // but since no supertype of a value type may mutate the underlying value'                                          // we don't need to take a copy of the value when boxing' so in practice                                          // this is a no-op                                          if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                  }                                  else if (cs is ReferenceTypeStyle)                                  {                                      // *Case 2* We dereference the pointer and pass the object reference                                      if (!methi.Constrained.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else if (cs is ParameterTypeStyle)                                  {                                      // Since we are calling an instance method' we know the first argument cannot be                                      // a "naked" type parameter' but is either a class or an interface.                                      // We must decide between cases 1 and 2 above at runtime' but checking as                                      // per case 1 is sufficient now.                                      // NOTE: As for box/classcast/isinst below' if the parameter is                                      // instantiated to a reference type then the type box type is considered                                      // equivalent to the underyling reference type.                                      if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else                                      throw new InvalidOperationException                                          ("constrained must be value' reference or parameter type");                                    state.PeekExpectedType(sig.Parameters.Count - 1' constrainedPtr' changed);                              }                              else if (sig.Parameters.Count > 0)                                  state.PeekExpectedType(sig.Parameters.Count - 1' sig.Parameters[0]' changed);                              if (sig.Result == null)                                  return state.Pop(sig.Parameters.Count);                              else                                  return state.PopPushType(sig.Parameters.Count' sig.Result' BottomPT);                          }                      case MethodOp.Ldftn:                          {                              // NOTE: Verified CLR allows only the two "blessed" sequences:                              //   dup; ldvirtftn; newobj <delegate ctor>                              //   ldftn; newobj <delegate ctor>                              // It is thus possible to check the delegate will capture an instance which                              // implements the loaded method. However' we don't check that here.                              if (methi.IsVirtual)                              {                                  if (methi.Method.IsStatic)                                      throw new InvalidOperationException("cannot ldvirtftn of a static method");                                  var objectType = default(TypeRef);                                  if (sig.Parameters[0].Style(methEnv) is ManagedPointerTypeStyle)                                      // Object should be a box                                      objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(sig.Parameters[0].Arguments[0]);                                  else                                      // Object should match parameter                                      objectType = sig.Parameters[0];                                  state.PeekExpectedType(0' objectType' changed);                                  return state.PopPushType(1' sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                              else                              {                                  if (methi.Method.IsStatic)                                      return state.PushType(sig.ToCodePointer(methEnv.Global)' BottomPT);                                  else                                      return state.PushType(sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                          }                      case MethodOp.Newobj:                          {                              if (methi.Method.IsStatic || sig.Result != null)                                  throw new InvalidOperationException("not a constructor");                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              // First argument to constructor is created by runtime. If definining type is                              // a value type' first argument will be a pointer' but result left on stack                              // will be the value itself.                              return state.PopPushType(sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);                          }                      case MethodOp.Ldtoken:                          return state.PushType(global.RuntimeMethodHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          state.PeekReadPointerType(0' typei.Type);                          return state.PopPushType(1' typei.Type' BottomPT);                      case TypeOp.Stobj:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Cpobj:                          state.PeekReadPointerType(0' typei.Type);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Newarr:                          state.PeekIndexType(0);                          return state.PopPushType(1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo(typei.Type)' BottomPT);                      case TypeOp.Initobj:                          state.PeekWritePointerType(0' typei.Type);                          return state.Pop(1);                      case TypeOp.Castclass:                      case TypeOp.Isinst:                      case TypeOp.Box:                          {                              var resultType = default(TypeRef);                              var s = typei.Type.Style(methEnv);                              if (s is NullableTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type.Arguments[0]);                              else if (s is ValueTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else if (s is ReferenceTypeStyle)                                  resultType = typei.Type;                              else if (s is ParameterTypeStyle)                                  // NOTE: As for constrained call above' if type parameter is instantitated to                                  // a ref type' then this box type is considered equivalent to the                                  // underlying reference type.                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else                                  throw new InvalidOperationException                                      ("can only box/cast to reference' value or parameter type");                              if (typei.Op == TypeOp.Box)                                  state.PeekExpectedType(0' typei.Type' changed);                              else                                  state.PeekReferenceType(0);                              return state.PopPushType(1' resultType' BottomPT);                          }                      case TypeOp.Unbox:                          if (!(typei.Type.Style(methEnv) is ValueTypeStyle))                              // Parameter types are not allowed                              throw new InvalidOperationException("type must be a value type");                          state.PeekBoxedType(0' typei.Type' changed);                          return state.PopPushType(1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(typei.Type)' HeapPT);                      case TypeOp.UnboxAny:                          {                              var s = typei.Type.Style(methEnv);                              if (s is ValueTypeStyle)                                  state.PeekBoxedType(0' typei.Type' changed);                              else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))                                  throw new InvalidOperationException("type must be value' reference or parameter type");                              return state.PopPushType(1' typei.Type' BottomPT);                          }                      case TypeOp.Ldtoken:                          return state.PushType(global.RuntimeTypeHandleRef' BottomPT);                      case TypeOp.Ldelem:                          state.PeekIndexType(0);                          state.PeekReadArrayType(1' typei.Type' false);                          return state.PopPushType(2' typei.Type' BottomPT);                      case TypeOp.Stelem:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekIndexType(1);                          state.PeekWriteArrayType(2' typei.Type);                          return state.Pop(3);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  {                      var ldelemai = (LdElemAddrInstruction)instruction;                      state.PeekIndexType(0);                      // WARNING: May prematurely fail for non-readonly loads                      state.PeekReadArrayType(1' ldelemai.Type' !ldelemai.IsReadonly);                      return state.PopPushType(2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(ldelemai.Type)' HeapPT);                  }              case InstructionFlavor.LdInt32:                  return state.PushType(global.Int32Ref' BottomPT);              case InstructionFlavor.LdInt64:                  return state.PushType(global.Int64Ref' BottomPT);              case InstructionFlavor.LdSingle:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdDouble:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdString:                  return state.PushType(global.StringRef' BottomPT);              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.Div:                      case ArithOp.Rem:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' true);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.Neg:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' true);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' false);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.BitNot:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.Shl:                      case ArithOp.Shr:                          state.PeekExpectedType(0' global.Int32Ref' changed);                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(1' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(2' arithi.Type' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned &&                                           convi.TargetNumberFlavor == NumberFlavor.Double);                      // NOTE: May capture skolemized types                      convi.SourceType = state.PeekNumberType(0' !mustBeInteger);                      return state.PopPushType(1' TypeRef.NumberFrom(methEnv.Global' convi.TargetNumberFlavor)' BottomPT);                  }              case InstructionFlavor.Try:                  {                      var tryi = (TryInstruction)instruction;                      // Isolation:                      //  - There is no way for the current stack shape to influence or be influenced by                      //    inference of the try' since the current stack shape must be empty.                      //  - There is no way for the try to influence the result stack shape' since it must be                      //    empty.                      //  - However pointers in arguments and locals may propogate into and out of try body                      //    via exceptional transitions. The latter are delt with separately.                      if (state.Depth != 0)                          throw new InvalidOperationException("stack should be empty");                      var newState = ForwardBlock                          (new TryBodyInstructionContext(context' index' tryi.Body)' state' changed);                      for (var j = 0; j < tryi.Handlers.Count; j++)                      {                          var h = tryi.Handlers[j];                          var handlerContext = new TryHandlerInstructionContext(context' index' h.Body' j);                          var initHandlerState = new MachineState                              (methEnv' method.ValueParameters.Count' method.Locals.Count);                          switch (h.Flavor)                          {                          case HandlerFlavor.Catch:                              {                                  var catchh = (CatchTryInstructionHandler)h;                                  ForwardBlock(handlerContext' initHandlerState.PushType(catchh.Type' BottomPT)' changed);                                  break;                              }                          case HandlerFlavor.Filter:                              throw new NotSupportedException("filter handler blocks");                          case HandlerFlavor.Fault:                          case HandlerFlavor.Finally:                              ForwardBlock(handlerContext' initHandlerState' changed);                              break;                          default:                              throw new ArgumentOutOfRangeException();                          }                      }                      return newState;                  }              case InstructionFlavor.IfThenElsePseudo:              case InstructionFlavor.ShortCircuitingPseudo:              case InstructionFlavor.StructuralSwitchPseudo:              case InstructionFlavor.LoopPseudo:              case InstructionFlavor.WhileDoPseudo:              case InstructionFlavor.DoWhilePseudo:              case InstructionFlavor.LoopControlPseudo:                  throw new InvalidOperationException("no machine state inference for psuedo-instructions");              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return state;                      case MiscOp.Dup:                          return state.Push(state.Peek(0));                      case MiscOp.Pop:                          return state.Pop(1);                      case MiscOp.Ldnull:                          return state.PushType(global.NullRef' BottomPT);                      case MiscOp.Ckfinite:                          state.PeekExpectedType(0' global.DoubleRef' changed);                          // Assume the instruction can "peek" at top of stack' thus no need for pop/push.                          return state;                      case MiscOp.Throw:                          state.PeekReferenceType(0);                          return state.DiscardStack();                      case MiscOp.Rethrow:                          return state.DiscardStack();                      case MiscOp.LdindRef:                          {                              var elemType = state.PeekPointerToReferenceType(0);                              return state.PopPushType(1' elemType' BottomPT);                          }                      case MiscOp.StindRef:                          {                              var expElemType = state.PeekPointerToReferenceType(1);                              state.PeekExpectedType(0' expElemType' changed);                              return state.Pop(2);                          }                      case MiscOp.LdelemRef:                          {                              state.PeekIndexType(0);                              // WARNING: Type may not be final                              var elemType = state.PeekArrayOfReferenceType(1);                              return state.PopPushType(2' elemType' BottomPT);                          }                      case MiscOp.StelemRef:                          state.PeekReferenceType(0);                          state.PeekIndexType(1);                          state.PeekArrayOfReferenceType(2);                          // Since the value type and array element type may be independently generalized'                          // it is pointless to check that the first is assignable to the second.                          // Instead this check is done at runtime.                          return state.Pop(3);                      case MiscOp.Ldlen:                          state.PeekArrayOfAnyType(0);                          return state.PopPushType(1' global.IntNativeRef' BottomPT);                      case MiscOp.Ret:                          {                              if (state.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return state; // empty                          }                      case MiscOp.RetVal:                          {                              state.PeekExpectedType(0' method.Result.Type' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfilter:                          {                              state.PeekExpectedType(0' global.Int32Ref' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfinally:                          {                              // Control could transfer to an outer finally/fault block' or to the target                              // of a leave instruction. However these transitions are delt with separately.                              return state.DiscardStack();                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:                  {                      var bri = (BranchInstruction)instruction;                      switch (bri.Op)                      {                      case BranchOp.Br:                          UnifyBeforeState(state' bri.Target' changed);                          return state;                      case BranchOp.Brtrue:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' false);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Brfalse:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Breq:                      case BranchOp.Brne:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' true);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Leave:                          {                              // Control could transfer via finally blocks instead of directly to the leave target.                              // Propogate only that the stack must be empty at target. Remaining machine state                              // is dealt with separately.                              UnifyBeforeState                                  (new MachineState(methEnv' method.ValueParameters.Count' method.Locals.Count)'                                   bri.Target'                                   changed);                              return state.DiscardStack();                          }                      case BranchOp.BrLt:                      case BranchOp.BrLe:                      case BranchOp.BrGt:                      case BranchOp.BrGe:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' false);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Switch:                  {                      var switchi = (SwitchInstruction)instruction;                      state.PeekExpectedType(0' global.Int32Ref' changed);                      var newState = state.Pop(1);                      for (var i = 0; i < switchi.CaseTargets.Count; i++)                          UnifyBeforeState(newState' switchi.CaseTargets[i]' changed);                      return newState;                  }              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      // WARNING: Capured type may not be final                      // NOTE: May capture skolemized types                      switch (cmpi.Op)                      {                      case CompareOp.Ceq:                      case CompareOp.CnePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' true);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.Clt:                      case CompareOp.Cgt:                      case CompareOp.CgePseudo:                      case CompareOp.ClePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' false);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.CtruePseudo:                      case CompareOp.CfalsePseudo:                          cmpi.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                          return state.PopPushType(1' global.Int32Ref' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var argi = (ArgLocalInstruction)instruction;                      var type = method.ArgLocalType(argi.ArgLocal' argi.Index);                      switch (argi.Op)                      {                      case ArgLocalOp.Ld:                          return state.PushType(type' state.ArgLocalPointsTo(argi.ArgLocal' argi.Index));                      case ArgLocalOp.Lda:                          return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(type)' ArgLocalPT(argi.ArgLocal' argi.Index));                      case ArgLocalOp.St:                          {                              state.PeekExpectedType(0' type' changed);                              var pointsTo = state.PeekPointsTo(0);                              if (!pointsTo.IsBottom)                              {                                  if (!(type.Style(methEnv) is ManagedPointerTypeStyle))                                      throw new InvalidOperationException                                          ("stack indicates pointer' but parameter or local type does not");                                  if (pointsTo.PointsOutsideOfHeap)                                      throw new InvalidOperationException("arguments cannot point outside of the heap");                              }                              return state.PopAddArgLocalPointsTo(1' argi.ArgLocal' argi.Index' pointsTo);                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      var fieldEnv = fieldi.Field.Enter(methEnv);                      var fieldType = fieldEnv.SubstituteType(fieldEnv.Field.FieldType);                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                              return state.PushType(fieldType' BottomPT);                          else                          {                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' true' changed);                              return state.PopPushType(1' fieldType' BottomPT);                          }                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                              return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          else                          {                              // Underlying type cannot be a struct' otherwise would have a pointer into                              // the stack                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' false' changed);                              return state.PopPushType                                  (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          }                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                          {                              state.PeekExpectedType(0' fieldType' changed);                              return state.Pop(1);                          }                          else                          {                              state.PeekExpectedType(0' fieldType' changed);                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (1' fieldi.Field.DefiningType' false' changed);                              return state.Pop(2);                          }                      case FieldOp.Ldtoken:                          return state.PushType(global.RuntimeFieldHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methi = (MethodInstruction)instruction;                      var sig = (CST.MethodSignature)methi.Method.ExternalSignature;                      switch (methi.Op)                      {                      case MethodOp.Call:                          {                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              if (methi.Constrained != null)                              {                                  if (!methi.IsVirtual || methi.Method.IsStatic)                                      throw new InvalidOperationException                                          ("constrained only valid on virtual calls to instance methods");                                  var thisType = sig.Parameters[0];                                  var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(methi.Constrained);                                  var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo(methi.Constrained);                                  var cs = methi.Constrained.Style(methEnv);                                  if (cs is ValueTypeStyle)                                  {                                      if (thisType.Style(methEnv) is ManagedPointerTypeStyle)                                      {                                          // We pass the argument pointer as is                                          if (!methi.Constrained.IsAssignableTo(methEnv' thisType.Arguments[0]))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                      else                                      {                                          // *Case 1* Morally we deref the argument pointer and box the contents'                                          // but since no supertype of a value type may mutate the underlying value'                                          // we don't need to take a copy of the value when boxing' so in practice                                          // this is a no-op                                          if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                  }                                  else if (cs is ReferenceTypeStyle)                                  {                                      // *Case 2* We dereference the pointer and pass the object reference                                      if (!methi.Constrained.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else if (cs is ParameterTypeStyle)                                  {                                      // Since we are calling an instance method' we know the first argument cannot be                                      // a "naked" type parameter' but is either a class or an interface.                                      // We must decide between cases 1 and 2 above at runtime' but checking as                                      // per case 1 is sufficient now.                                      // NOTE: As for box/classcast/isinst below' if the parameter is                                      // instantiated to a reference type then the type box type is considered                                      // equivalent to the underyling reference type.                                      if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else                                      throw new InvalidOperationException                                          ("constrained must be value' reference or parameter type");                                    state.PeekExpectedType(sig.Parameters.Count - 1' constrainedPtr' changed);                              }                              else if (sig.Parameters.Count > 0)                                  state.PeekExpectedType(sig.Parameters.Count - 1' sig.Parameters[0]' changed);                              if (sig.Result == null)                                  return state.Pop(sig.Parameters.Count);                              else                                  return state.PopPushType(sig.Parameters.Count' sig.Result' BottomPT);                          }                      case MethodOp.Ldftn:                          {                              // NOTE: Verified CLR allows only the two "blessed" sequences:                              //   dup; ldvirtftn; newobj <delegate ctor>                              //   ldftn; newobj <delegate ctor>                              // It is thus possible to check the delegate will capture an instance which                              // implements the loaded method. However' we don't check that here.                              if (methi.IsVirtual)                              {                                  if (methi.Method.IsStatic)                                      throw new InvalidOperationException("cannot ldvirtftn of a static method");                                  var objectType = default(TypeRef);                                  if (sig.Parameters[0].Style(methEnv) is ManagedPointerTypeStyle)                                      // Object should be a box                                      objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(sig.Parameters[0].Arguments[0]);                                  else                                      // Object should match parameter                                      objectType = sig.Parameters[0];                                  state.PeekExpectedType(0' objectType' changed);                                  return state.PopPushType(1' sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                              else                              {                                  if (methi.Method.IsStatic)                                      return state.PushType(sig.ToCodePointer(methEnv.Global)' BottomPT);                                  else                                      return state.PushType(sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                          }                      case MethodOp.Newobj:                          {                              if (methi.Method.IsStatic || sig.Result != null)                                  throw new InvalidOperationException("not a constructor");                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              // First argument to constructor is created by runtime. If definining type is                              // a value type' first argument will be a pointer' but result left on stack                              // will be the value itself.                              return state.PopPushType(sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);                          }                      case MethodOp.Ldtoken:                          return state.PushType(global.RuntimeMethodHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          state.PeekReadPointerType(0' typei.Type);                          return state.PopPushType(1' typei.Type' BottomPT);                      case TypeOp.Stobj:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Cpobj:                          state.PeekReadPointerType(0' typei.Type);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Newarr:                          state.PeekIndexType(0);                          return state.PopPushType(1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo(typei.Type)' BottomPT);                      case TypeOp.Initobj:                          state.PeekWritePointerType(0' typei.Type);                          return state.Pop(1);                      case TypeOp.Castclass:                      case TypeOp.Isinst:                      case TypeOp.Box:                          {                              var resultType = default(TypeRef);                              var s = typei.Type.Style(methEnv);                              if (s is NullableTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type.Arguments[0]);                              else if (s is ValueTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else if (s is ReferenceTypeStyle)                                  resultType = typei.Type;                              else if (s is ParameterTypeStyle)                                  // NOTE: As for constrained call above' if type parameter is instantitated to                                  // a ref type' then this box type is considered equivalent to the                                  // underlying reference type.                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else                                  throw new InvalidOperationException                                      ("can only box/cast to reference' value or parameter type");                              if (typei.Op == TypeOp.Box)                                  state.PeekExpectedType(0' typei.Type' changed);                              else                                  state.PeekReferenceType(0);                              return state.PopPushType(1' resultType' BottomPT);                          }                      case TypeOp.Unbox:                          if (!(typei.Type.Style(methEnv) is ValueTypeStyle))                              // Parameter types are not allowed                              throw new InvalidOperationException("type must be a value type");                          state.PeekBoxedType(0' typei.Type' changed);                          return state.PopPushType(1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(typei.Type)' HeapPT);                      case TypeOp.UnboxAny:                          {                              var s = typei.Type.Style(methEnv);                              if (s is ValueTypeStyle)                                  state.PeekBoxedType(0' typei.Type' changed);                              else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))                                  throw new InvalidOperationException("type must be value' reference or parameter type");                              return state.PopPushType(1' typei.Type' BottomPT);                          }                      case TypeOp.Ldtoken:                          return state.PushType(global.RuntimeTypeHandleRef' BottomPT);                      case TypeOp.Ldelem:                          state.PeekIndexType(0);                          state.PeekReadArrayType(1' typei.Type' false);                          return state.PopPushType(2' typei.Type' BottomPT);                      case TypeOp.Stelem:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekIndexType(1);                          state.PeekWriteArrayType(2' typei.Type);                          return state.Pop(3);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  {                      var ldelemai = (LdElemAddrInstruction)instruction;                      state.PeekIndexType(0);                      // WARNING: May prematurely fail for non-readonly loads                      state.PeekReadArrayType(1' ldelemai.Type' !ldelemai.IsReadonly);                      return state.PopPushType(2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(ldelemai.Type)' HeapPT);                  }              case InstructionFlavor.LdInt32:                  return state.PushType(global.Int32Ref' BottomPT);              case InstructionFlavor.LdInt64:                  return state.PushType(global.Int64Ref' BottomPT);              case InstructionFlavor.LdSingle:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdDouble:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdString:                  return state.PushType(global.StringRef' BottomPT);              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.Div:                      case ArithOp.Rem:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' true);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.Neg:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' true);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' false);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.BitNot:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.Shl:                      case ArithOp.Shr:                          state.PeekExpectedType(0' global.Int32Ref' changed);                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(1' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(2' arithi.Type' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned &&                                           convi.TargetNumberFlavor == NumberFlavor.Double);                      // NOTE: May capture skolemized types                      convi.SourceType = state.PeekNumberType(0' !mustBeInteger);                      return state.PopPushType(1' TypeRef.NumberFrom(methEnv.Global' convi.TargetNumberFlavor)' BottomPT);                  }              case InstructionFlavor.Try:                  {                      var tryi = (TryInstruction)instruction;                      // Isolation:                      //  - There is no way for the current stack shape to influence or be influenced by                      //    inference of the try' since the current stack shape must be empty.                      //  - There is no way for the try to influence the result stack shape' since it must be                      //    empty.                      //  - However pointers in arguments and locals may propogate into and out of try body                      //    via exceptional transitions. The latter are delt with separately.                      if (state.Depth != 0)                          throw new InvalidOperationException("stack should be empty");                      var newState = ForwardBlock                          (new TryBodyInstructionContext(context' index' tryi.Body)' state' changed);                      for (var j = 0; j < tryi.Handlers.Count; j++)                      {                          var h = tryi.Handlers[j];                          var handlerContext = new TryHandlerInstructionContext(context' index' h.Body' j);                          var initHandlerState = new MachineState                              (methEnv' method.ValueParameters.Count' method.Locals.Count);                          switch (h.Flavor)                          {                          case HandlerFlavor.Catch:                              {                                  var catchh = (CatchTryInstructionHandler)h;                                  ForwardBlock(handlerContext' initHandlerState.PushType(catchh.Type' BottomPT)' changed);                                  break;                              }                          case HandlerFlavor.Filter:                              throw new NotSupportedException("filter handler blocks");                          case HandlerFlavor.Fault:                          case HandlerFlavor.Finally:                              ForwardBlock(handlerContext' initHandlerState' changed);                              break;                          default:                              throw new ArgumentOutOfRangeException();                          }                      }                      return newState;                  }              case InstructionFlavor.IfThenElsePseudo:              case InstructionFlavor.ShortCircuitingPseudo:              case InstructionFlavor.StructuralSwitchPseudo:              case InstructionFlavor.LoopPseudo:              case InstructionFlavor.WhileDoPseudo:              case InstructionFlavor.DoWhilePseudo:              case InstructionFlavor.LoopControlPseudo:                  throw new InvalidOperationException("no machine state inference for psuedo-instructions");              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return state;                      case MiscOp.Dup:                          return state.Push(state.Peek(0));                      case MiscOp.Pop:                          return state.Pop(1);                      case MiscOp.Ldnull:                          return state.PushType(global.NullRef' BottomPT);                      case MiscOp.Ckfinite:                          state.PeekExpectedType(0' global.DoubleRef' changed);                          // Assume the instruction can "peek" at top of stack' thus no need for pop/push.                          return state;                      case MiscOp.Throw:                          state.PeekReferenceType(0);                          return state.DiscardStack();                      case MiscOp.Rethrow:                          return state.DiscardStack();                      case MiscOp.LdindRef:                          {                              var elemType = state.PeekPointerToReferenceType(0);                              return state.PopPushType(1' elemType' BottomPT);                          }                      case MiscOp.StindRef:                          {                              var expElemType = state.PeekPointerToReferenceType(1);                              state.PeekExpectedType(0' expElemType' changed);                              return state.Pop(2);                          }                      case MiscOp.LdelemRef:                          {                              state.PeekIndexType(0);                              // WARNING: Type may not be final                              var elemType = state.PeekArrayOfReferenceType(1);                              return state.PopPushType(2' elemType' BottomPT);                          }                      case MiscOp.StelemRef:                          state.PeekReferenceType(0);                          state.PeekIndexType(1);                          state.PeekArrayOfReferenceType(2);                          // Since the value type and array element type may be independently generalized'                          // it is pointless to check that the first is assignable to the second.                          // Instead this check is done at runtime.                          return state.Pop(3);                      case MiscOp.Ldlen:                          state.PeekArrayOfAnyType(0);                          return state.PopPushType(1' global.IntNativeRef' BottomPT);                      case MiscOp.Ret:                          {                              if (state.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return state; // empty                          }                      case MiscOp.RetVal:                          {                              state.PeekExpectedType(0' method.Result.Type' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfilter:                          {                              state.PeekExpectedType(0' global.Int32Ref' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfinally:                          {                              // Control could transfer to an outer finally/fault block' or to the target                              // of a leave instruction. However these transitions are delt with separately.                              return state.DiscardStack();                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:                  {                      var bri = (BranchInstruction)instruction;                      switch (bri.Op)                      {                      case BranchOp.Br:                          UnifyBeforeState(state' bri.Target' changed);                          return state;                      case BranchOp.Brtrue:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' false);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Brfalse:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Breq:                      case BranchOp.Brne:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' true);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Leave:                          {                              // Control could transfer via finally blocks instead of directly to the leave target.                              // Propogate only that the stack must be empty at target. Remaining machine state                              // is dealt with separately.                              UnifyBeforeState                                  (new MachineState(methEnv' method.ValueParameters.Count' method.Locals.Count)'                                   bri.Target'                                   changed);                              return state.DiscardStack();                          }                      case BranchOp.BrLt:                      case BranchOp.BrLe:                      case BranchOp.BrGt:                      case BranchOp.BrGe:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' false);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Switch:                  {                      var switchi = (SwitchInstruction)instruction;                      state.PeekExpectedType(0' global.Int32Ref' changed);                      var newState = state.Pop(1);                      for (var i = 0; i < switchi.CaseTargets.Count; i++)                          UnifyBeforeState(newState' switchi.CaseTargets[i]' changed);                      return newState;                  }              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      // WARNING: Capured type may not be final                      // NOTE: May capture skolemized types                      switch (cmpi.Op)                      {                      case CompareOp.Ceq:                      case CompareOp.CnePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' true);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.Clt:                      case CompareOp.Cgt:                      case CompareOp.CgePseudo:                      case CompareOp.ClePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' false);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.CtruePseudo:                      case CompareOp.CfalsePseudo:                          cmpi.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                          return state.PopPushType(1' global.Int32Ref' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var argi = (ArgLocalInstruction)instruction;                      var type = method.ArgLocalType(argi.ArgLocal' argi.Index);                      switch (argi.Op)                      {                      case ArgLocalOp.Ld:                          return state.PushType(type' state.ArgLocalPointsTo(argi.ArgLocal' argi.Index));                      case ArgLocalOp.Lda:                          return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(type)' ArgLocalPT(argi.ArgLocal' argi.Index));                      case ArgLocalOp.St:                          {                              state.PeekExpectedType(0' type' changed);                              var pointsTo = state.PeekPointsTo(0);                              if (!pointsTo.IsBottom)                              {                                  if (!(type.Style(methEnv) is ManagedPointerTypeStyle))                                      throw new InvalidOperationException                                          ("stack indicates pointer' but parameter or local type does not");                                  if (pointsTo.PointsOutsideOfHeap)                                      throw new InvalidOperationException("arguments cannot point outside of the heap");                              }                              return state.PopAddArgLocalPointsTo(1' argi.ArgLocal' argi.Index' pointsTo);                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      var fieldEnv = fieldi.Field.Enter(methEnv);                      var fieldType = fieldEnv.SubstituteType(fieldEnv.Field.FieldType);                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                              return state.PushType(fieldType' BottomPT);                          else                          {                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' true' changed);                              return state.PopPushType(1' fieldType' BottomPT);                          }                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                              return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          else                          {                              // Underlying type cannot be a struct' otherwise would have a pointer into                              // the stack                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' false' changed);                              return state.PopPushType                                  (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          }                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                          {                              state.PeekExpectedType(0' fieldType' changed);                              return state.Pop(1);                          }                          else                          {                              state.PeekExpectedType(0' fieldType' changed);                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (1' fieldi.Field.DefiningType' false' changed);                              return state.Pop(2);                          }                      case FieldOp.Ldtoken:                          return state.PushType(global.RuntimeFieldHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methi = (MethodInstruction)instruction;                      var sig = (CST.MethodSignature)methi.Method.ExternalSignature;                      switch (methi.Op)                      {                      case MethodOp.Call:                          {                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              if (methi.Constrained != null)                              {                                  if (!methi.IsVirtual || methi.Method.IsStatic)                                      throw new InvalidOperationException                                          ("constrained only valid on virtual calls to instance methods");                                  var thisType = sig.Parameters[0];                                  var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(methi.Constrained);                                  var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo(methi.Constrained);                                  var cs = methi.Constrained.Style(methEnv);                                  if (cs is ValueTypeStyle)                                  {                                      if (thisType.Style(methEnv) is ManagedPointerTypeStyle)                                      {                                          // We pass the argument pointer as is                                          if (!methi.Constrained.IsAssignableTo(methEnv' thisType.Arguments[0]))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                      else                                      {                                          // *Case 1* Morally we deref the argument pointer and box the contents'                                          // but since no supertype of a value type may mutate the underlying value'                                          // we don't need to take a copy of the value when boxing' so in practice                                          // this is a no-op                                          if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                  }                                  else if (cs is ReferenceTypeStyle)                                  {                                      // *Case 2* We dereference the pointer and pass the object reference                                      if (!methi.Constrained.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else if (cs is ParameterTypeStyle)                                  {                                      // Since we are calling an instance method' we know the first argument cannot be                                      // a "naked" type parameter' but is either a class or an interface.                                      // We must decide between cases 1 and 2 above at runtime' but checking as                                      // per case 1 is sufficient now.                                      // NOTE: As for box/classcast/isinst below' if the parameter is                                      // instantiated to a reference type then the type box type is considered                                      // equivalent to the underyling reference type.                                      if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else                                      throw new InvalidOperationException                                          ("constrained must be value' reference or parameter type");                                    state.PeekExpectedType(sig.Parameters.Count - 1' constrainedPtr' changed);                              }                              else if (sig.Parameters.Count > 0)                                  state.PeekExpectedType(sig.Parameters.Count - 1' sig.Parameters[0]' changed);                              if (sig.Result == null)                                  return state.Pop(sig.Parameters.Count);                              else                                  return state.PopPushType(sig.Parameters.Count' sig.Result' BottomPT);                          }                      case MethodOp.Ldftn:                          {                              // NOTE: Verified CLR allows only the two "blessed" sequences:                              //   dup; ldvirtftn; newobj <delegate ctor>                              //   ldftn; newobj <delegate ctor>                              // It is thus possible to check the delegate will capture an instance which                              // implements the loaded method. However' we don't check that here.                              if (methi.IsVirtual)                              {                                  if (methi.Method.IsStatic)                                      throw new InvalidOperationException("cannot ldvirtftn of a static method");                                  var objectType = default(TypeRef);                                  if (sig.Parameters[0].Style(methEnv) is ManagedPointerTypeStyle)                                      // Object should be a box                                      objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(sig.Parameters[0].Arguments[0]);                                  else                                      // Object should match parameter                                      objectType = sig.Parameters[0];                                  state.PeekExpectedType(0' objectType' changed);                                  return state.PopPushType(1' sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                              else                              {                                  if (methi.Method.IsStatic)                                      return state.PushType(sig.ToCodePointer(methEnv.Global)' BottomPT);                                  else                                      return state.PushType(sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                          }                      case MethodOp.Newobj:                          {                              if (methi.Method.IsStatic || sig.Result != null)                                  throw new InvalidOperationException("not a constructor");                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              // First argument to constructor is created by runtime. If definining type is                              // a value type' first argument will be a pointer' but result left on stack                              // will be the value itself.                              return state.PopPushType(sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);                          }                      case MethodOp.Ldtoken:                          return state.PushType(global.RuntimeMethodHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          state.PeekReadPointerType(0' typei.Type);                          return state.PopPushType(1' typei.Type' BottomPT);                      case TypeOp.Stobj:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Cpobj:                          state.PeekReadPointerType(0' typei.Type);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Newarr:                          state.PeekIndexType(0);                          return state.PopPushType(1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo(typei.Type)' BottomPT);                      case TypeOp.Initobj:                          state.PeekWritePointerType(0' typei.Type);                          return state.Pop(1);                      case TypeOp.Castclass:                      case TypeOp.Isinst:                      case TypeOp.Box:                          {                              var resultType = default(TypeRef);                              var s = typei.Type.Style(methEnv);                              if (s is NullableTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type.Arguments[0]);                              else if (s is ValueTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else if (s is ReferenceTypeStyle)                                  resultType = typei.Type;                              else if (s is ParameterTypeStyle)                                  // NOTE: As for constrained call above' if type parameter is instantitated to                                  // a ref type' then this box type is considered equivalent to the                                  // underlying reference type.                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else                                  throw new InvalidOperationException                                      ("can only box/cast to reference' value or parameter type");                              if (typei.Op == TypeOp.Box)                                  state.PeekExpectedType(0' typei.Type' changed);                              else                                  state.PeekReferenceType(0);                              return state.PopPushType(1' resultType' BottomPT);                          }                      case TypeOp.Unbox:                          if (!(typei.Type.Style(methEnv) is ValueTypeStyle))                              // Parameter types are not allowed                              throw new InvalidOperationException("type must be a value type");                          state.PeekBoxedType(0' typei.Type' changed);                          return state.PopPushType(1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(typei.Type)' HeapPT);                      case TypeOp.UnboxAny:                          {                              var s = typei.Type.Style(methEnv);                              if (s is ValueTypeStyle)                                  state.PeekBoxedType(0' typei.Type' changed);                              else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))                                  throw new InvalidOperationException("type must be value' reference or parameter type");                              return state.PopPushType(1' typei.Type' BottomPT);                          }                      case TypeOp.Ldtoken:                          return state.PushType(global.RuntimeTypeHandleRef' BottomPT);                      case TypeOp.Ldelem:                          state.PeekIndexType(0);                          state.PeekReadArrayType(1' typei.Type' false);                          return state.PopPushType(2' typei.Type' BottomPT);                      case TypeOp.Stelem:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekIndexType(1);                          state.PeekWriteArrayType(2' typei.Type);                          return state.Pop(3);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  {                      var ldelemai = (LdElemAddrInstruction)instruction;                      state.PeekIndexType(0);                      // WARNING: May prematurely fail for non-readonly loads                      state.PeekReadArrayType(1' ldelemai.Type' !ldelemai.IsReadonly);                      return state.PopPushType(2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(ldelemai.Type)' HeapPT);                  }              case InstructionFlavor.LdInt32:                  return state.PushType(global.Int32Ref' BottomPT);              case InstructionFlavor.LdInt64:                  return state.PushType(global.Int64Ref' BottomPT);              case InstructionFlavor.LdSingle:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdDouble:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdString:                  return state.PushType(global.StringRef' BottomPT);              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.Div:                      case ArithOp.Rem:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' true);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.Neg:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' true);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' false);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.BitNot:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.Shl:                      case ArithOp.Shr:                          state.PeekExpectedType(0' global.Int32Ref' changed);                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(1' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(2' arithi.Type' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned &&                                           convi.TargetNumberFlavor == NumberFlavor.Double);                      // NOTE: May capture skolemized types                      convi.SourceType = state.PeekNumberType(0' !mustBeInteger);                      return state.PopPushType(1' TypeRef.NumberFrom(methEnv.Global' convi.TargetNumberFlavor)' BottomPT);                  }              case InstructionFlavor.Try:                  {                      var tryi = (TryInstruction)instruction;                      // Isolation:                      //  - There is no way for the current stack shape to influence or be influenced by                      //    inference of the try' since the current stack shape must be empty.                      //  - There is no way for the try to influence the result stack shape' since it must be                      //    empty.                      //  - However pointers in arguments and locals may propogate into and out of try body                      //    via exceptional transitions. The latter are delt with separately.                      if (state.Depth != 0)                          throw new InvalidOperationException("stack should be empty");                      var newState = ForwardBlock                          (new TryBodyInstructionContext(context' index' tryi.Body)' state' changed);                      for (var j = 0; j < tryi.Handlers.Count; j++)                      {                          var h = tryi.Handlers[j];                          var handlerContext = new TryHandlerInstructionContext(context' index' h.Body' j);                          var initHandlerState = new MachineState                              (methEnv' method.ValueParameters.Count' method.Locals.Count);                          switch (h.Flavor)                          {                          case HandlerFlavor.Catch:                              {                                  var catchh = (CatchTryInstructionHandler)h;                                  ForwardBlock(handlerContext' initHandlerState.PushType(catchh.Type' BottomPT)' changed);                                  break;                              }                          case HandlerFlavor.Filter:                              throw new NotSupportedException("filter handler blocks");                          case HandlerFlavor.Fault:                          case HandlerFlavor.Finally:                              ForwardBlock(handlerContext' initHandlerState' changed);                              break;                          default:                              throw new ArgumentOutOfRangeException();                          }                      }                      return newState;                  }              case InstructionFlavor.IfThenElsePseudo:              case InstructionFlavor.ShortCircuitingPseudo:              case InstructionFlavor.StructuralSwitchPseudo:              case InstructionFlavor.LoopPseudo:              case InstructionFlavor.WhileDoPseudo:              case InstructionFlavor.DoWhilePseudo:              case InstructionFlavor.LoopControlPseudo:                  throw new InvalidOperationException("no machine state inference for psuedo-instructions");              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return state;                      case MiscOp.Dup:                          return state.Push(state.Peek(0));                      case MiscOp.Pop:                          return state.Pop(1);                      case MiscOp.Ldnull:                          return state.PushType(global.NullRef' BottomPT);                      case MiscOp.Ckfinite:                          state.PeekExpectedType(0' global.DoubleRef' changed);                          // Assume the instruction can "peek" at top of stack' thus no need for pop/push.                          return state;                      case MiscOp.Throw:                          state.PeekReferenceType(0);                          return state.DiscardStack();                      case MiscOp.Rethrow:                          return state.DiscardStack();                      case MiscOp.LdindRef:                          {                              var elemType = state.PeekPointerToReferenceType(0);                              return state.PopPushType(1' elemType' BottomPT);                          }                      case MiscOp.StindRef:                          {                              var expElemType = state.PeekPointerToReferenceType(1);                              state.PeekExpectedType(0' expElemType' changed);                              return state.Pop(2);                          }                      case MiscOp.LdelemRef:                          {                              state.PeekIndexType(0);                              // WARNING: Type may not be final                              var elemType = state.PeekArrayOfReferenceType(1);                              return state.PopPushType(2' elemType' BottomPT);                          }                      case MiscOp.StelemRef:                          state.PeekReferenceType(0);                          state.PeekIndexType(1);                          state.PeekArrayOfReferenceType(2);                          // Since the value type and array element type may be independently generalized'                          // it is pointless to check that the first is assignable to the second.                          // Instead this check is done at runtime.                          return state.Pop(3);                      case MiscOp.Ldlen:                          state.PeekArrayOfAnyType(0);                          return state.PopPushType(1' global.IntNativeRef' BottomPT);                      case MiscOp.Ret:                          {                              if (state.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return state; // empty                          }                      case MiscOp.RetVal:                          {                              state.PeekExpectedType(0' method.Result.Type' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfilter:                          {                              state.PeekExpectedType(0' global.Int32Ref' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfinally:                          {                              // Control could transfer to an outer finally/fault block' or to the target                              // of a leave instruction. However these transitions are delt with separately.                              return state.DiscardStack();                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:                  {                      var bri = (BranchInstruction)instruction;                      switch (bri.Op)                      {                      case BranchOp.Br:                          UnifyBeforeState(state' bri.Target' changed);                          return state;                      case BranchOp.Brtrue:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' false);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Brfalse:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Breq:                      case BranchOp.Brne:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' true);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Leave:                          {                              // Control could transfer via finally blocks instead of directly to the leave target.                              // Propogate only that the stack must be empty at target. Remaining machine state                              // is dealt with separately.                              UnifyBeforeState                                  (new MachineState(methEnv' method.ValueParameters.Count' method.Locals.Count)'                                   bri.Target'                                   changed);                              return state.DiscardStack();                          }                      case BranchOp.BrLt:                      case BranchOp.BrLe:                      case BranchOp.BrGt:                      case BranchOp.BrGe:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' false);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Switch:                  {                      var switchi = (SwitchInstruction)instruction;                      state.PeekExpectedType(0' global.Int32Ref' changed);                      var newState = state.Pop(1);                      for (var i = 0; i < switchi.CaseTargets.Count; i++)                          UnifyBeforeState(newState' switchi.CaseTargets[i]' changed);                      return newState;                  }              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      // WARNING: Capured type may not be final                      // NOTE: May capture skolemized types                      switch (cmpi.Op)                      {                      case CompareOp.Ceq:                      case CompareOp.CnePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' true);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.Clt:                      case CompareOp.Cgt:                      case CompareOp.CgePseudo:                      case CompareOp.ClePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' false);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.CtruePseudo:                      case CompareOp.CfalsePseudo:                          cmpi.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                          return state.PopPushType(1' global.Int32Ref' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var argi = (ArgLocalInstruction)instruction;                      var type = method.ArgLocalType(argi.ArgLocal' argi.Index);                      switch (argi.Op)                      {                      case ArgLocalOp.Ld:                          return state.PushType(type' state.ArgLocalPointsTo(argi.ArgLocal' argi.Index));                      case ArgLocalOp.Lda:                          return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(type)' ArgLocalPT(argi.ArgLocal' argi.Index));                      case ArgLocalOp.St:                          {                              state.PeekExpectedType(0' type' changed);                              var pointsTo = state.PeekPointsTo(0);                              if (!pointsTo.IsBottom)                              {                                  if (!(type.Style(methEnv) is ManagedPointerTypeStyle))                                      throw new InvalidOperationException                                          ("stack indicates pointer' but parameter or local type does not");                                  if (pointsTo.PointsOutsideOfHeap)                                      throw new InvalidOperationException("arguments cannot point outside of the heap");                              }                              return state.PopAddArgLocalPointsTo(1' argi.ArgLocal' argi.Index' pointsTo);                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      var fieldEnv = fieldi.Field.Enter(methEnv);                      var fieldType = fieldEnv.SubstituteType(fieldEnv.Field.FieldType);                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                              return state.PushType(fieldType' BottomPT);                          else                          {                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' true' changed);                              return state.PopPushType(1' fieldType' BottomPT);                          }                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                              return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          else                          {                              // Underlying type cannot be a struct' otherwise would have a pointer into                              // the stack                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' false' changed);                              return state.PopPushType                                  (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          }                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                          {                              state.PeekExpectedType(0' fieldType' changed);                              return state.Pop(1);                          }                          else                          {                              state.PeekExpectedType(0' fieldType' changed);                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (1' fieldi.Field.DefiningType' false' changed);                              return state.Pop(2);                          }                      case FieldOp.Ldtoken:                          return state.PushType(global.RuntimeFieldHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methi = (MethodInstruction)instruction;                      var sig = (CST.MethodSignature)methi.Method.ExternalSignature;                      switch (methi.Op)                      {                      case MethodOp.Call:                          {                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              if (methi.Constrained != null)                              {                                  if (!methi.IsVirtual || methi.Method.IsStatic)                                      throw new InvalidOperationException                                          ("constrained only valid on virtual calls to instance methods");                                  var thisType = sig.Parameters[0];                                  var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(methi.Constrained);                                  var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo(methi.Constrained);                                  var cs = methi.Constrained.Style(methEnv);                                  if (cs is ValueTypeStyle)                                  {                                      if (thisType.Style(methEnv) is ManagedPointerTypeStyle)                                      {                                          // We pass the argument pointer as is                                          if (!methi.Constrained.IsAssignableTo(methEnv' thisType.Arguments[0]))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                      else                                      {                                          // *Case 1* Morally we deref the argument pointer and box the contents'                                          // but since no supertype of a value type may mutate the underlying value'                                          // we don't need to take a copy of the value when boxing' so in practice                                          // this is a no-op                                          if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                  }                                  else if (cs is ReferenceTypeStyle)                                  {                                      // *Case 2* We dereference the pointer and pass the object reference                                      if (!methi.Constrained.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else if (cs is ParameterTypeStyle)                                  {                                      // Since we are calling an instance method' we know the first argument cannot be                                      // a "naked" type parameter' but is either a class or an interface.                                      // We must decide between cases 1 and 2 above at runtime' but checking as                                      // per case 1 is sufficient now.                                      // NOTE: As for box/classcast/isinst below' if the parameter is                                      // instantiated to a reference type then the type box type is considered                                      // equivalent to the underyling reference type.                                      if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else                                      throw new InvalidOperationException                                          ("constrained must be value' reference or parameter type");                                    state.PeekExpectedType(sig.Parameters.Count - 1' constrainedPtr' changed);                              }                              else if (sig.Parameters.Count > 0)                                  state.PeekExpectedType(sig.Parameters.Count - 1' sig.Parameters[0]' changed);                              if (sig.Result == null)                                  return state.Pop(sig.Parameters.Count);                              else                                  return state.PopPushType(sig.Parameters.Count' sig.Result' BottomPT);                          }                      case MethodOp.Ldftn:                          {                              // NOTE: Verified CLR allows only the two "blessed" sequences:                              //   dup; ldvirtftn; newobj <delegate ctor>                              //   ldftn; newobj <delegate ctor>                              // It is thus possible to check the delegate will capture an instance which                              // implements the loaded method. However' we don't check that here.                              if (methi.IsVirtual)                              {                                  if (methi.Method.IsStatic)                                      throw new InvalidOperationException("cannot ldvirtftn of a static method");                                  var objectType = default(TypeRef);                                  if (sig.Parameters[0].Style(methEnv) is ManagedPointerTypeStyle)                                      // Object should be a box                                      objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(sig.Parameters[0].Arguments[0]);                                  else                                      // Object should match parameter                                      objectType = sig.Parameters[0];                                  state.PeekExpectedType(0' objectType' changed);                                  return state.PopPushType(1' sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                              else                              {                                  if (methi.Method.IsStatic)                                      return state.PushType(sig.ToCodePointer(methEnv.Global)' BottomPT);                                  else                                      return state.PushType(sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                          }                      case MethodOp.Newobj:                          {                              if (methi.Method.IsStatic || sig.Result != null)                                  throw new InvalidOperationException("not a constructor");                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              // First argument to constructor is created by runtime. If definining type is                              // a value type' first argument will be a pointer' but result left on stack                              // will be the value itself.                              return state.PopPushType(sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);                          }                      case MethodOp.Ldtoken:                          return state.PushType(global.RuntimeMethodHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          state.PeekReadPointerType(0' typei.Type);                          return state.PopPushType(1' typei.Type' BottomPT);                      case TypeOp.Stobj:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Cpobj:                          state.PeekReadPointerType(0' typei.Type);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Newarr:                          state.PeekIndexType(0);                          return state.PopPushType(1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo(typei.Type)' BottomPT);                      case TypeOp.Initobj:                          state.PeekWritePointerType(0' typei.Type);                          return state.Pop(1);                      case TypeOp.Castclass:                      case TypeOp.Isinst:                      case TypeOp.Box:                          {                              var resultType = default(TypeRef);                              var s = typei.Type.Style(methEnv);                              if (s is NullableTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type.Arguments[0]);                              else if (s is ValueTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else if (s is ReferenceTypeStyle)                                  resultType = typei.Type;                              else if (s is ParameterTypeStyle)                                  // NOTE: As for constrained call above' if type parameter is instantitated to                                  // a ref type' then this box type is considered equivalent to the                                  // underlying reference type.                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else                                  throw new InvalidOperationException                                      ("can only box/cast to reference' value or parameter type");                              if (typei.Op == TypeOp.Box)                                  state.PeekExpectedType(0' typei.Type' changed);                              else                                  state.PeekReferenceType(0);                              return state.PopPushType(1' resultType' BottomPT);                          }                      case TypeOp.Unbox:                          if (!(typei.Type.Style(methEnv) is ValueTypeStyle))                              // Parameter types are not allowed                              throw new InvalidOperationException("type must be a value type");                          state.PeekBoxedType(0' typei.Type' changed);                          return state.PopPushType(1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(typei.Type)' HeapPT);                      case TypeOp.UnboxAny:                          {                              var s = typei.Type.Style(methEnv);                              if (s is ValueTypeStyle)                                  state.PeekBoxedType(0' typei.Type' changed);                              else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))                                  throw new InvalidOperationException("type must be value' reference or parameter type");                              return state.PopPushType(1' typei.Type' BottomPT);                          }                      case TypeOp.Ldtoken:                          return state.PushType(global.RuntimeTypeHandleRef' BottomPT);                      case TypeOp.Ldelem:                          state.PeekIndexType(0);                          state.PeekReadArrayType(1' typei.Type' false);                          return state.PopPushType(2' typei.Type' BottomPT);                      case TypeOp.Stelem:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekIndexType(1);                          state.PeekWriteArrayType(2' typei.Type);                          return state.Pop(3);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  {                      var ldelemai = (LdElemAddrInstruction)instruction;                      state.PeekIndexType(0);                      // WARNING: May prematurely fail for non-readonly loads                      state.PeekReadArrayType(1' ldelemai.Type' !ldelemai.IsReadonly);                      return state.PopPushType(2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(ldelemai.Type)' HeapPT);                  }              case InstructionFlavor.LdInt32:                  return state.PushType(global.Int32Ref' BottomPT);              case InstructionFlavor.LdInt64:                  return state.PushType(global.Int64Ref' BottomPT);              case InstructionFlavor.LdSingle:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdDouble:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdString:                  return state.PushType(global.StringRef' BottomPT);              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.Div:                      case ArithOp.Rem:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' true);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.Neg:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' true);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' false);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.BitNot:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.Shl:                      case ArithOp.Shr:                          state.PeekExpectedType(0' global.Int32Ref' changed);                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(1' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(2' arithi.Type' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned &&                                           convi.TargetNumberFlavor == NumberFlavor.Double);                      // NOTE: May capture skolemized types                      convi.SourceType = state.PeekNumberType(0' !mustBeInteger);                      return state.PopPushType(1' TypeRef.NumberFrom(methEnv.Global' convi.TargetNumberFlavor)' BottomPT);                  }              case InstructionFlavor.Try:                  {                      var tryi = (TryInstruction)instruction;                      // Isolation:                      //  - There is no way for the current stack shape to influence or be influenced by                      //    inference of the try' since the current stack shape must be empty.                      //  - There is no way for the try to influence the result stack shape' since it must be                      //    empty.                      //  - However pointers in arguments and locals may propogate into and out of try body                      //    via exceptional transitions. The latter are delt with separately.                      if (state.Depth != 0)                          throw new InvalidOperationException("stack should be empty");                      var newState = ForwardBlock                          (new TryBodyInstructionContext(context' index' tryi.Body)' state' changed);                      for (var j = 0; j < tryi.Handlers.Count; j++)                      {                          var h = tryi.Handlers[j];                          var handlerContext = new TryHandlerInstructionContext(context' index' h.Body' j);                          var initHandlerState = new MachineState                              (methEnv' method.ValueParameters.Count' method.Locals.Count);                          switch (h.Flavor)                          {                          case HandlerFlavor.Catch:                              {                                  var catchh = (CatchTryInstructionHandler)h;                                  ForwardBlock(handlerContext' initHandlerState.PushType(catchh.Type' BottomPT)' changed);                                  break;                              }                          case HandlerFlavor.Filter:                              throw new NotSupportedException("filter handler blocks");                          case HandlerFlavor.Fault:                          case HandlerFlavor.Finally:                              ForwardBlock(handlerContext' initHandlerState' changed);                              break;                          default:                              throw new ArgumentOutOfRangeException();                          }                      }                      return newState;                  }              case InstructionFlavor.IfThenElsePseudo:              case InstructionFlavor.ShortCircuitingPseudo:              case InstructionFlavor.StructuralSwitchPseudo:              case InstructionFlavor.LoopPseudo:              case InstructionFlavor.WhileDoPseudo:              case InstructionFlavor.DoWhilePseudo:              case InstructionFlavor.LoopControlPseudo:                  throw new InvalidOperationException("no machine state inference for psuedo-instructions");              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return state;                      case MiscOp.Dup:                          return state.Push(state.Peek(0));                      case MiscOp.Pop:                          return state.Pop(1);                      case MiscOp.Ldnull:                          return state.PushType(global.NullRef' BottomPT);                      case MiscOp.Ckfinite:                          state.PeekExpectedType(0' global.DoubleRef' changed);                          // Assume the instruction can "peek" at top of stack' thus no need for pop/push.                          return state;                      case MiscOp.Throw:                          state.PeekReferenceType(0);                          return state.DiscardStack();                      case MiscOp.Rethrow:                          return state.DiscardStack();                      case MiscOp.LdindRef:                          {                              var elemType = state.PeekPointerToReferenceType(0);                              return state.PopPushType(1' elemType' BottomPT);                          }                      case MiscOp.StindRef:                          {                              var expElemType = state.PeekPointerToReferenceType(1);                              state.PeekExpectedType(0' expElemType' changed);                              return state.Pop(2);                          }                      case MiscOp.LdelemRef:                          {                              state.PeekIndexType(0);                              // WARNING: Type may not be final                              var elemType = state.PeekArrayOfReferenceType(1);                              return state.PopPushType(2' elemType' BottomPT);                          }                      case MiscOp.StelemRef:                          state.PeekReferenceType(0);                          state.PeekIndexType(1);                          state.PeekArrayOfReferenceType(2);                          // Since the value type and array element type may be independently generalized'                          // it is pointless to check that the first is assignable to the second.                          // Instead this check is done at runtime.                          return state.Pop(3);                      case MiscOp.Ldlen:                          state.PeekArrayOfAnyType(0);                          return state.PopPushType(1' global.IntNativeRef' BottomPT);                      case MiscOp.Ret:                          {                              if (state.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return state; // empty                          }                      case MiscOp.RetVal:                          {                              state.PeekExpectedType(0' method.Result.Type' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfilter:                          {                              state.PeekExpectedType(0' global.Int32Ref' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfinally:                          {                              // Control could transfer to an outer finally/fault block' or to the target                              // of a leave instruction. However these transitions are delt with separately.                              return state.DiscardStack();                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:                  {                      var bri = (BranchInstruction)instruction;                      switch (bri.Op)                      {                      case BranchOp.Br:                          UnifyBeforeState(state' bri.Target' changed);                          return state;                      case BranchOp.Brtrue:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' false);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Brfalse:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Breq:                      case BranchOp.Brne:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' true);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Leave:                          {                              // Control could transfer via finally blocks instead of directly to the leave target.                              // Propogate only that the stack must be empty at target. Remaining machine state                              // is dealt with separately.                              UnifyBeforeState                                  (new MachineState(methEnv' method.ValueParameters.Count' method.Locals.Count)'                                   bri.Target'                                   changed);                              return state.DiscardStack();                          }                      case BranchOp.BrLt:                      case BranchOp.BrLe:                      case BranchOp.BrGt:                      case BranchOp.BrGe:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' false);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Switch:                  {                      var switchi = (SwitchInstruction)instruction;                      state.PeekExpectedType(0' global.Int32Ref' changed);                      var newState = state.Pop(1);                      for (var i = 0; i < switchi.CaseTargets.Count; i++)                          UnifyBeforeState(newState' switchi.CaseTargets[i]' changed);                      return newState;                  }              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      // WARNING: Capured type may not be final                      // NOTE: May capture skolemized types                      switch (cmpi.Op)                      {                      case CompareOp.Ceq:                      case CompareOp.CnePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' true);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.Clt:                      case CompareOp.Cgt:                      case CompareOp.CgePseudo:                      case CompareOp.ClePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' false);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.CtruePseudo:                      case CompareOp.CfalsePseudo:                          cmpi.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                          return state.PopPushType(1' global.Int32Ref' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var argi = (ArgLocalInstruction)instruction;                      var type = method.ArgLocalType(argi.ArgLocal' argi.Index);                      switch (argi.Op)                      {                      case ArgLocalOp.Ld:                          return state.PushType(type' state.ArgLocalPointsTo(argi.ArgLocal' argi.Index));                      case ArgLocalOp.Lda:                          return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(type)' ArgLocalPT(argi.ArgLocal' argi.Index));                      case ArgLocalOp.St:                          {                              state.PeekExpectedType(0' type' changed);                              var pointsTo = state.PeekPointsTo(0);                              if (!pointsTo.IsBottom)                              {                                  if (!(type.Style(methEnv) is ManagedPointerTypeStyle))                                      throw new InvalidOperationException                                          ("stack indicates pointer' but parameter or local type does not");                                  if (pointsTo.PointsOutsideOfHeap)                                      throw new InvalidOperationException("arguments cannot point outside of the heap");                              }                              return state.PopAddArgLocalPointsTo(1' argi.ArgLocal' argi.Index' pointsTo);                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      var fieldEnv = fieldi.Field.Enter(methEnv);                      var fieldType = fieldEnv.SubstituteType(fieldEnv.Field.FieldType);                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                              return state.PushType(fieldType' BottomPT);                          else                          {                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' true' changed);                              return state.PopPushType(1' fieldType' BottomPT);                          }                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                              return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          else                          {                              // Underlying type cannot be a struct' otherwise would have a pointer into                              // the stack                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' false' changed);                              return state.PopPushType                                  (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          }                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                          {                              state.PeekExpectedType(0' fieldType' changed);                              return state.Pop(1);                          }                          else                          {                              state.PeekExpectedType(0' fieldType' changed);                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (1' fieldi.Field.DefiningType' false' changed);                              return state.Pop(2);                          }                      case FieldOp.Ldtoken:                          return state.PushType(global.RuntimeFieldHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methi = (MethodInstruction)instruction;                      var sig = (CST.MethodSignature)methi.Method.ExternalSignature;                      switch (methi.Op)                      {                      case MethodOp.Call:                          {                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              if (methi.Constrained != null)                              {                                  if (!methi.IsVirtual || methi.Method.IsStatic)                                      throw new InvalidOperationException                                          ("constrained only valid on virtual calls to instance methods");                                  var thisType = sig.Parameters[0];                                  var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(methi.Constrained);                                  var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo(methi.Constrained);                                  var cs = methi.Constrained.Style(methEnv);                                  if (cs is ValueTypeStyle)                                  {                                      if (thisType.Style(methEnv) is ManagedPointerTypeStyle)                                      {                                          // We pass the argument pointer as is                                          if (!methi.Constrained.IsAssignableTo(methEnv' thisType.Arguments[0]))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                      else                                      {                                          // *Case 1* Morally we deref the argument pointer and box the contents'                                          // but since no supertype of a value type may mutate the underlying value'                                          // we don't need to take a copy of the value when boxing' so in practice                                          // this is a no-op                                          if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                  }                                  else if (cs is ReferenceTypeStyle)                                  {                                      // *Case 2* We dereference the pointer and pass the object reference                                      if (!methi.Constrained.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else if (cs is ParameterTypeStyle)                                  {                                      // Since we are calling an instance method' we know the first argument cannot be                                      // a "naked" type parameter' but is either a class or an interface.                                      // We must decide between cases 1 and 2 above at runtime' but checking as                                      // per case 1 is sufficient now.                                      // NOTE: As for box/classcast/isinst below' if the parameter is                                      // instantiated to a reference type then the type box type is considered                                      // equivalent to the underyling reference type.                                      if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else                                      throw new InvalidOperationException                                          ("constrained must be value' reference or parameter type");                                    state.PeekExpectedType(sig.Parameters.Count - 1' constrainedPtr' changed);                              }                              else if (sig.Parameters.Count > 0)                                  state.PeekExpectedType(sig.Parameters.Count - 1' sig.Parameters[0]' changed);                              if (sig.Result == null)                                  return state.Pop(sig.Parameters.Count);                              else                                  return state.PopPushType(sig.Parameters.Count' sig.Result' BottomPT);                          }                      case MethodOp.Ldftn:                          {                              // NOTE: Verified CLR allows only the two "blessed" sequences:                              //   dup; ldvirtftn; newobj <delegate ctor>                              //   ldftn; newobj <delegate ctor>                              // It is thus possible to check the delegate will capture an instance which                              // implements the loaded method. However' we don't check that here.                              if (methi.IsVirtual)                              {                                  if (methi.Method.IsStatic)                                      throw new InvalidOperationException("cannot ldvirtftn of a static method");                                  var objectType = default(TypeRef);                                  if (sig.Parameters[0].Style(methEnv) is ManagedPointerTypeStyle)                                      // Object should be a box                                      objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(sig.Parameters[0].Arguments[0]);                                  else                                      // Object should match parameter                                      objectType = sig.Parameters[0];                                  state.PeekExpectedType(0' objectType' changed);                                  return state.PopPushType(1' sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                              else                              {                                  if (methi.Method.IsStatic)                                      return state.PushType(sig.ToCodePointer(methEnv.Global)' BottomPT);                                  else                                      return state.PushType(sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                          }                      case MethodOp.Newobj:                          {                              if (methi.Method.IsStatic || sig.Result != null)                                  throw new InvalidOperationException("not a constructor");                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              // First argument to constructor is created by runtime. If definining type is                              // a value type' first argument will be a pointer' but result left on stack                              // will be the value itself.                              return state.PopPushType(sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);                          }                      case MethodOp.Ldtoken:                          return state.PushType(global.RuntimeMethodHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          state.PeekReadPointerType(0' typei.Type);                          return state.PopPushType(1' typei.Type' BottomPT);                      case TypeOp.Stobj:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Cpobj:                          state.PeekReadPointerType(0' typei.Type);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Newarr:                          state.PeekIndexType(0);                          return state.PopPushType(1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo(typei.Type)' BottomPT);                      case TypeOp.Initobj:                          state.PeekWritePointerType(0' typei.Type);                          return state.Pop(1);                      case TypeOp.Castclass:                      case TypeOp.Isinst:                      case TypeOp.Box:                          {                              var resultType = default(TypeRef);                              var s = typei.Type.Style(methEnv);                              if (s is NullableTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type.Arguments[0]);                              else if (s is ValueTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else if (s is ReferenceTypeStyle)                                  resultType = typei.Type;                              else if (s is ParameterTypeStyle)                                  // NOTE: As for constrained call above' if type parameter is instantitated to                                  // a ref type' then this box type is considered equivalent to the                                  // underlying reference type.                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else                                  throw new InvalidOperationException                                      ("can only box/cast to reference' value or parameter type");                              if (typei.Op == TypeOp.Box)                                  state.PeekExpectedType(0' typei.Type' changed);                              else                                  state.PeekReferenceType(0);                              return state.PopPushType(1' resultType' BottomPT);                          }                      case TypeOp.Unbox:                          if (!(typei.Type.Style(methEnv) is ValueTypeStyle))                              // Parameter types are not allowed                              throw new InvalidOperationException("type must be a value type");                          state.PeekBoxedType(0' typei.Type' changed);                          return state.PopPushType(1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(typei.Type)' HeapPT);                      case TypeOp.UnboxAny:                          {                              var s = typei.Type.Style(methEnv);                              if (s is ValueTypeStyle)                                  state.PeekBoxedType(0' typei.Type' changed);                              else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))                                  throw new InvalidOperationException("type must be value' reference or parameter type");                              return state.PopPushType(1' typei.Type' BottomPT);                          }                      case TypeOp.Ldtoken:                          return state.PushType(global.RuntimeTypeHandleRef' BottomPT);                      case TypeOp.Ldelem:                          state.PeekIndexType(0);                          state.PeekReadArrayType(1' typei.Type' false);                          return state.PopPushType(2' typei.Type' BottomPT);                      case TypeOp.Stelem:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekIndexType(1);                          state.PeekWriteArrayType(2' typei.Type);                          return state.Pop(3);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  {                      var ldelemai = (LdElemAddrInstruction)instruction;                      state.PeekIndexType(0);                      // WARNING: May prematurely fail for non-readonly loads                      state.PeekReadArrayType(1' ldelemai.Type' !ldelemai.IsReadonly);                      return state.PopPushType(2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(ldelemai.Type)' HeapPT);                  }              case InstructionFlavor.LdInt32:                  return state.PushType(global.Int32Ref' BottomPT);              case InstructionFlavor.LdInt64:                  return state.PushType(global.Int64Ref' BottomPT);              case InstructionFlavor.LdSingle:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdDouble:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdString:                  return state.PushType(global.StringRef' BottomPT);              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.Div:                      case ArithOp.Rem:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' true);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.Neg:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' true);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' false);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.BitNot:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.Shl:                      case ArithOp.Shr:                          state.PeekExpectedType(0' global.Int32Ref' changed);                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(1' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(2' arithi.Type' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned &&                                           convi.TargetNumberFlavor == NumberFlavor.Double);                      // NOTE: May capture skolemized types                      convi.SourceType = state.PeekNumberType(0' !mustBeInteger);                      return state.PopPushType(1' TypeRef.NumberFrom(methEnv.Global' convi.TargetNumberFlavor)' BottomPT);                  }              case InstructionFlavor.Try:                  {                      var tryi = (TryInstruction)instruction;                      // Isolation:                      //  - There is no way for the current stack shape to influence or be influenced by                      //    inference of the try' since the current stack shape must be empty.                      //  - There is no way for the try to influence the result stack shape' since it must be                      //    empty.                      //  - However pointers in arguments and locals may propogate into and out of try body                      //    via exceptional transitions. The latter are delt with separately.                      if (state.Depth != 0)                          throw new InvalidOperationException("stack should be empty");                      var newState = ForwardBlock                          (new TryBodyInstructionContext(context' index' tryi.Body)' state' changed);                      for (var j = 0; j < tryi.Handlers.Count; j++)                      {                          var h = tryi.Handlers[j];                          var handlerContext = new TryHandlerInstructionContext(context' index' h.Body' j);                          var initHandlerState = new MachineState                              (methEnv' method.ValueParameters.Count' method.Locals.Count);                          switch (h.Flavor)                          {                          case HandlerFlavor.Catch:                              {                                  var catchh = (CatchTryInstructionHandler)h;                                  ForwardBlock(handlerContext' initHandlerState.PushType(catchh.Type' BottomPT)' changed);                                  break;                              }                          case HandlerFlavor.Filter:                              throw new NotSupportedException("filter handler blocks");                          case HandlerFlavor.Fault:                          case HandlerFlavor.Finally:                              ForwardBlock(handlerContext' initHandlerState' changed);                              break;                          default:                              throw new ArgumentOutOfRangeException();                          }                      }                      return newState;                  }              case InstructionFlavor.IfThenElsePseudo:              case InstructionFlavor.ShortCircuitingPseudo:              case InstructionFlavor.StructuralSwitchPseudo:              case InstructionFlavor.LoopPseudo:              case InstructionFlavor.WhileDoPseudo:              case InstructionFlavor.DoWhilePseudo:              case InstructionFlavor.LoopControlPseudo:                  throw new InvalidOperationException("no machine state inference for psuedo-instructions");              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return state;                      case MiscOp.Dup:                          return state.Push(state.Peek(0));                      case MiscOp.Pop:                          return state.Pop(1);                      case MiscOp.Ldnull:                          return state.PushType(global.NullRef' BottomPT);                      case MiscOp.Ckfinite:                          state.PeekExpectedType(0' global.DoubleRef' changed);                          // Assume the instruction can "peek" at top of stack' thus no need for pop/push.                          return state;                      case MiscOp.Throw:                          state.PeekReferenceType(0);                          return state.DiscardStack();                      case MiscOp.Rethrow:                          return state.DiscardStack();                      case MiscOp.LdindRef:                          {                              var elemType = state.PeekPointerToReferenceType(0);                              return state.PopPushType(1' elemType' BottomPT);                          }                      case MiscOp.StindRef:                          {                              var expElemType = state.PeekPointerToReferenceType(1);                              state.PeekExpectedType(0' expElemType' changed);                              return state.Pop(2);                          }                      case MiscOp.LdelemRef:                          {                              state.PeekIndexType(0);                              // WARNING: Type may not be final                              var elemType = state.PeekArrayOfReferenceType(1);                              return state.PopPushType(2' elemType' BottomPT);                          }                      case MiscOp.StelemRef:                          state.PeekReferenceType(0);                          state.PeekIndexType(1);                          state.PeekArrayOfReferenceType(2);                          // Since the value type and array element type may be independently generalized'                          // it is pointless to check that the first is assignable to the second.                          // Instead this check is done at runtime.                          return state.Pop(3);                      case MiscOp.Ldlen:                          state.PeekArrayOfAnyType(0);                          return state.PopPushType(1' global.IntNativeRef' BottomPT);                      case MiscOp.Ret:                          {                              if (state.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return state; // empty                          }                      case MiscOp.RetVal:                          {                              state.PeekExpectedType(0' method.Result.Type' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfilter:                          {                              state.PeekExpectedType(0' global.Int32Ref' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfinally:                          {                              // Control could transfer to an outer finally/fault block' or to the target                              // of a leave instruction. However these transitions are delt with separately.                              return state.DiscardStack();                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:                  {                      var bri = (BranchInstruction)instruction;                      switch (bri.Op)                      {                      case BranchOp.Br:                          UnifyBeforeState(state' bri.Target' changed);                          return state;                      case BranchOp.Brtrue:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' false);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Brfalse:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Breq:                      case BranchOp.Brne:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' true);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Leave:                          {                              // Control could transfer via finally blocks instead of directly to the leave target.                              // Propogate only that the stack must be empty at target. Remaining machine state                              // is dealt with separately.                              UnifyBeforeState                                  (new MachineState(methEnv' method.ValueParameters.Count' method.Locals.Count)'                                   bri.Target'                                   changed);                              return state.DiscardStack();                          }                      case BranchOp.BrLt:                      case BranchOp.BrLe:                      case BranchOp.BrGt:                      case BranchOp.BrGe:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' false);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Switch:                  {                      var switchi = (SwitchInstruction)instruction;                      state.PeekExpectedType(0' global.Int32Ref' changed);                      var newState = state.Pop(1);                      for (var i = 0; i < switchi.CaseTargets.Count; i++)                          UnifyBeforeState(newState' switchi.CaseTargets[i]' changed);                      return newState;                  }              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      // WARNING: Capured type may not be final                      // NOTE: May capture skolemized types                      switch (cmpi.Op)                      {                      case CompareOp.Ceq:                      case CompareOp.CnePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' true);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.Clt:                      case CompareOp.Cgt:                      case CompareOp.CgePseudo:                      case CompareOp.ClePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' false);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.CtruePseudo:                      case CompareOp.CfalsePseudo:                          cmpi.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                          return state.PopPushType(1' global.Int32Ref' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var argi = (ArgLocalInstruction)instruction;                      var type = method.ArgLocalType(argi.ArgLocal' argi.Index);                      switch (argi.Op)                      {                      case ArgLocalOp.Ld:                          return state.PushType(type' state.ArgLocalPointsTo(argi.ArgLocal' argi.Index));                      case ArgLocalOp.Lda:                          return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(type)' ArgLocalPT(argi.ArgLocal' argi.Index));                      case ArgLocalOp.St:                          {                              state.PeekExpectedType(0' type' changed);                              var pointsTo = state.PeekPointsTo(0);                              if (!pointsTo.IsBottom)                              {                                  if (!(type.Style(methEnv) is ManagedPointerTypeStyle))                                      throw new InvalidOperationException                                          ("stack indicates pointer' but parameter or local type does not");                                  if (pointsTo.PointsOutsideOfHeap)                                      throw new InvalidOperationException("arguments cannot point outside of the heap");                              }                              return state.PopAddArgLocalPointsTo(1' argi.ArgLocal' argi.Index' pointsTo);                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      var fieldEnv = fieldi.Field.Enter(methEnv);                      var fieldType = fieldEnv.SubstituteType(fieldEnv.Field.FieldType);                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                              return state.PushType(fieldType' BottomPT);                          else                          {                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' true' changed);                              return state.PopPushType(1' fieldType' BottomPT);                          }                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                              return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          else                          {                              // Underlying type cannot be a struct' otherwise would have a pointer into                              // the stack                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' false' changed);                              return state.PopPushType                                  (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          }                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                          {                              state.PeekExpectedType(0' fieldType' changed);                              return state.Pop(1);                          }                          else                          {                              state.PeekExpectedType(0' fieldType' changed);                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (1' fieldi.Field.DefiningType' false' changed);                              return state.Pop(2);                          }                      case FieldOp.Ldtoken:                          return state.PushType(global.RuntimeFieldHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methi = (MethodInstruction)instruction;                      var sig = (CST.MethodSignature)methi.Method.ExternalSignature;                      switch (methi.Op)                      {                      case MethodOp.Call:                          {                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              if (methi.Constrained != null)                              {                                  if (!methi.IsVirtual || methi.Method.IsStatic)                                      throw new InvalidOperationException                                          ("constrained only valid on virtual calls to instance methods");                                  var thisType = sig.Parameters[0];                                  var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(methi.Constrained);                                  var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo(methi.Constrained);                                  var cs = methi.Constrained.Style(methEnv);                                  if (cs is ValueTypeStyle)                                  {                                      if (thisType.Style(methEnv) is ManagedPointerTypeStyle)                                      {                                          // We pass the argument pointer as is                                          if (!methi.Constrained.IsAssignableTo(methEnv' thisType.Arguments[0]))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                      else                                      {                                          // *Case 1* Morally we deref the argument pointer and box the contents'                                          // but since no supertype of a value type may mutate the underlying value'                                          // we don't need to take a copy of the value when boxing' so in practice                                          // this is a no-op                                          if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                  }                                  else if (cs is ReferenceTypeStyle)                                  {                                      // *Case 2* We dereference the pointer and pass the object reference                                      if (!methi.Constrained.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else if (cs is ParameterTypeStyle)                                  {                                      // Since we are calling an instance method' we know the first argument cannot be                                      // a "naked" type parameter' but is either a class or an interface.                                      // We must decide between cases 1 and 2 above at runtime' but checking as                                      // per case 1 is sufficient now.                                      // NOTE: As for box/classcast/isinst below' if the parameter is                                      // instantiated to a reference type then the type box type is considered                                      // equivalent to the underyling reference type.                                      if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else                                      throw new InvalidOperationException                                          ("constrained must be value' reference or parameter type");                                    state.PeekExpectedType(sig.Parameters.Count - 1' constrainedPtr' changed);                              }                              else if (sig.Parameters.Count > 0)                                  state.PeekExpectedType(sig.Parameters.Count - 1' sig.Parameters[0]' changed);                              if (sig.Result == null)                                  return state.Pop(sig.Parameters.Count);                              else                                  return state.PopPushType(sig.Parameters.Count' sig.Result' BottomPT);                          }                      case MethodOp.Ldftn:                          {                              // NOTE: Verified CLR allows only the two "blessed" sequences:                              //   dup; ldvirtftn; newobj <delegate ctor>                              //   ldftn; newobj <delegate ctor>                              // It is thus possible to check the delegate will capture an instance which                              // implements the loaded method. However' we don't check that here.                              if (methi.IsVirtual)                              {                                  if (methi.Method.IsStatic)                                      throw new InvalidOperationException("cannot ldvirtftn of a static method");                                  var objectType = default(TypeRef);                                  if (sig.Parameters[0].Style(methEnv) is ManagedPointerTypeStyle)                                      // Object should be a box                                      objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(sig.Parameters[0].Arguments[0]);                                  else                                      // Object should match parameter                                      objectType = sig.Parameters[0];                                  state.PeekExpectedType(0' objectType' changed);                                  return state.PopPushType(1' sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                              else                              {                                  if (methi.Method.IsStatic)                                      return state.PushType(sig.ToCodePointer(methEnv.Global)' BottomPT);                                  else                                      return state.PushType(sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                          }                      case MethodOp.Newobj:                          {                              if (methi.Method.IsStatic || sig.Result != null)                                  throw new InvalidOperationException("not a constructor");                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              // First argument to constructor is created by runtime. If definining type is                              // a value type' first argument will be a pointer' but result left on stack                              // will be the value itself.                              return state.PopPushType(sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);                          }                      case MethodOp.Ldtoken:                          return state.PushType(global.RuntimeMethodHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          state.PeekReadPointerType(0' typei.Type);                          return state.PopPushType(1' typei.Type' BottomPT);                      case TypeOp.Stobj:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Cpobj:                          state.PeekReadPointerType(0' typei.Type);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Newarr:                          state.PeekIndexType(0);                          return state.PopPushType(1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo(typei.Type)' BottomPT);                      case TypeOp.Initobj:                          state.PeekWritePointerType(0' typei.Type);                          return state.Pop(1);                      case TypeOp.Castclass:                      case TypeOp.Isinst:                      case TypeOp.Box:                          {                              var resultType = default(TypeRef);                              var s = typei.Type.Style(methEnv);                              if (s is NullableTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type.Arguments[0]);                              else if (s is ValueTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else if (s is ReferenceTypeStyle)                                  resultType = typei.Type;                              else if (s is ParameterTypeStyle)                                  // NOTE: As for constrained call above' if type parameter is instantitated to                                  // a ref type' then this box type is considered equivalent to the                                  // underlying reference type.                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else                                  throw new InvalidOperationException                                      ("can only box/cast to reference' value or parameter type");                              if (typei.Op == TypeOp.Box)                                  state.PeekExpectedType(0' typei.Type' changed);                              else                                  state.PeekReferenceType(0);                              return state.PopPushType(1' resultType' BottomPT);                          }                      case TypeOp.Unbox:                          if (!(typei.Type.Style(methEnv) is ValueTypeStyle))                              // Parameter types are not allowed                              throw new InvalidOperationException("type must be a value type");                          state.PeekBoxedType(0' typei.Type' changed);                          return state.PopPushType(1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(typei.Type)' HeapPT);                      case TypeOp.UnboxAny:                          {                              var s = typei.Type.Style(methEnv);                              if (s is ValueTypeStyle)                                  state.PeekBoxedType(0' typei.Type' changed);                              else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))                                  throw new InvalidOperationException("type must be value' reference or parameter type");                              return state.PopPushType(1' typei.Type' BottomPT);                          }                      case TypeOp.Ldtoken:                          return state.PushType(global.RuntimeTypeHandleRef' BottomPT);                      case TypeOp.Ldelem:                          state.PeekIndexType(0);                          state.PeekReadArrayType(1' typei.Type' false);                          return state.PopPushType(2' typei.Type' BottomPT);                      case TypeOp.Stelem:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekIndexType(1);                          state.PeekWriteArrayType(2' typei.Type);                          return state.Pop(3);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  {                      var ldelemai = (LdElemAddrInstruction)instruction;                      state.PeekIndexType(0);                      // WARNING: May prematurely fail for non-readonly loads                      state.PeekReadArrayType(1' ldelemai.Type' !ldelemai.IsReadonly);                      return state.PopPushType(2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(ldelemai.Type)' HeapPT);                  }              case InstructionFlavor.LdInt32:                  return state.PushType(global.Int32Ref' BottomPT);              case InstructionFlavor.LdInt64:                  return state.PushType(global.Int64Ref' BottomPT);              case InstructionFlavor.LdSingle:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdDouble:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdString:                  return state.PushType(global.StringRef' BottomPT);              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.Div:                      case ArithOp.Rem:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' true);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.Neg:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' true);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' false);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.BitNot:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.Shl:                      case ArithOp.Shr:                          state.PeekExpectedType(0' global.Int32Ref' changed);                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(1' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(2' arithi.Type' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned &&                                           convi.TargetNumberFlavor == NumberFlavor.Double);                      // NOTE: May capture skolemized types                      convi.SourceType = state.PeekNumberType(0' !mustBeInteger);                      return state.PopPushType(1' TypeRef.NumberFrom(methEnv.Global' convi.TargetNumberFlavor)' BottomPT);                  }              case InstructionFlavor.Try:                  {                      var tryi = (TryInstruction)instruction;                      // Isolation:                      //  - There is no way for the current stack shape to influence or be influenced by                      //    inference of the try' since the current stack shape must be empty.                      //  - There is no way for the try to influence the result stack shape' since it must be                      //    empty.                      //  - However pointers in arguments and locals may propogate into and out of try body                      //    via exceptional transitions. The latter are delt with separately.                      if (state.Depth != 0)                          throw new InvalidOperationException("stack should be empty");                      var newState = ForwardBlock                          (new TryBodyInstructionContext(context' index' tryi.Body)' state' changed);                      for (var j = 0; j < tryi.Handlers.Count; j++)                      {                          var h = tryi.Handlers[j];                          var handlerContext = new TryHandlerInstructionContext(context' index' h.Body' j);                          var initHandlerState = new MachineState                              (methEnv' method.ValueParameters.Count' method.Locals.Count);                          switch (h.Flavor)                          {                          case HandlerFlavor.Catch:                              {                                  var catchh = (CatchTryInstructionHandler)h;                                  ForwardBlock(handlerContext' initHandlerState.PushType(catchh.Type' BottomPT)' changed);                                  break;                              }                          case HandlerFlavor.Filter:                              throw new NotSupportedException("filter handler blocks");                          case HandlerFlavor.Fault:                          case HandlerFlavor.Finally:                              ForwardBlock(handlerContext' initHandlerState' changed);                              break;                          default:                              throw new ArgumentOutOfRangeException();                          }                      }                      return newState;                  }              case InstructionFlavor.IfThenElsePseudo:              case InstructionFlavor.ShortCircuitingPseudo:              case InstructionFlavor.StructuralSwitchPseudo:              case InstructionFlavor.LoopPseudo:              case InstructionFlavor.WhileDoPseudo:              case InstructionFlavor.DoWhilePseudo:              case InstructionFlavor.LoopControlPseudo:                  throw new InvalidOperationException("no machine state inference for psuedo-instructions");              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return state;                      case MiscOp.Dup:                          return state.Push(state.Peek(0));                      case MiscOp.Pop:                          return state.Pop(1);                      case MiscOp.Ldnull:                          return state.PushType(global.NullRef' BottomPT);                      case MiscOp.Ckfinite:                          state.PeekExpectedType(0' global.DoubleRef' changed);                          // Assume the instruction can "peek" at top of stack' thus no need for pop/push.                          return state;                      case MiscOp.Throw:                          state.PeekReferenceType(0);                          return state.DiscardStack();                      case MiscOp.Rethrow:                          return state.DiscardStack();                      case MiscOp.LdindRef:                          {                              var elemType = state.PeekPointerToReferenceType(0);                              return state.PopPushType(1' elemType' BottomPT);                          }                      case MiscOp.StindRef:                          {                              var expElemType = state.PeekPointerToReferenceType(1);                              state.PeekExpectedType(0' expElemType' changed);                              return state.Pop(2);                          }                      case MiscOp.LdelemRef:                          {                              state.PeekIndexType(0);                              // WARNING: Type may not be final                              var elemType = state.PeekArrayOfReferenceType(1);                              return state.PopPushType(2' elemType' BottomPT);                          }                      case MiscOp.StelemRef:                          state.PeekReferenceType(0);                          state.PeekIndexType(1);                          state.PeekArrayOfReferenceType(2);                          // Since the value type and array element type may be independently generalized'                          // it is pointless to check that the first is assignable to the second.                          // Instead this check is done at runtime.                          return state.Pop(3);                      case MiscOp.Ldlen:                          state.PeekArrayOfAnyType(0);                          return state.PopPushType(1' global.IntNativeRef' BottomPT);                      case MiscOp.Ret:                          {                              if (state.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return state; // empty                          }                      case MiscOp.RetVal:                          {                              state.PeekExpectedType(0' method.Result.Type' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfilter:                          {                              state.PeekExpectedType(0' global.Int32Ref' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfinally:                          {                              // Control could transfer to an outer finally/fault block' or to the target                              // of a leave instruction. However these transitions are delt with separately.                              return state.DiscardStack();                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:                  {                      var bri = (BranchInstruction)instruction;                      switch (bri.Op)                      {                      case BranchOp.Br:                          UnifyBeforeState(state' bri.Target' changed);                          return state;                      case BranchOp.Brtrue:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' false);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Brfalse:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Breq:                      case BranchOp.Brne:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' true);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Leave:                          {                              // Control could transfer via finally blocks instead of directly to the leave target.                              // Propogate only that the stack must be empty at target. Remaining machine state                              // is dealt with separately.                              UnifyBeforeState                                  (new MachineState(methEnv' method.ValueParameters.Count' method.Locals.Count)'                                   bri.Target'                                   changed);                              return state.DiscardStack();                          }                      case BranchOp.BrLt:                      case BranchOp.BrLe:                      case BranchOp.BrGt:                      case BranchOp.BrGe:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' false);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Switch:                  {                      var switchi = (SwitchInstruction)instruction;                      state.PeekExpectedType(0' global.Int32Ref' changed);                      var newState = state.Pop(1);                      for (var i = 0; i < switchi.CaseTargets.Count; i++)                          UnifyBeforeState(newState' switchi.CaseTargets[i]' changed);                      return newState;                  }              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      // WARNING: Capured type may not be final                      // NOTE: May capture skolemized types                      switch (cmpi.Op)                      {                      case CompareOp.Ceq:                      case CompareOp.CnePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' true);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.Clt:                      case CompareOp.Cgt:                      case CompareOp.CgePseudo:                      case CompareOp.ClePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' false);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.CtruePseudo:                      case CompareOp.CfalsePseudo:                          cmpi.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                          return state.PopPushType(1' global.Int32Ref' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var argi = (ArgLocalInstruction)instruction;                      var type = method.ArgLocalType(argi.ArgLocal' argi.Index);                      switch (argi.Op)                      {                      case ArgLocalOp.Ld:                          return state.PushType(type' state.ArgLocalPointsTo(argi.ArgLocal' argi.Index));                      case ArgLocalOp.Lda:                          return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(type)' ArgLocalPT(argi.ArgLocal' argi.Index));                      case ArgLocalOp.St:                          {                              state.PeekExpectedType(0' type' changed);                              var pointsTo = state.PeekPointsTo(0);                              if (!pointsTo.IsBottom)                              {                                  if (!(type.Style(methEnv) is ManagedPointerTypeStyle))                                      throw new InvalidOperationException                                          ("stack indicates pointer' but parameter or local type does not");                                  if (pointsTo.PointsOutsideOfHeap)                                      throw new InvalidOperationException("arguments cannot point outside of the heap");                              }                              return state.PopAddArgLocalPointsTo(1' argi.ArgLocal' argi.Index' pointsTo);                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      var fieldEnv = fieldi.Field.Enter(methEnv);                      var fieldType = fieldEnv.SubstituteType(fieldEnv.Field.FieldType);                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                              return state.PushType(fieldType' BottomPT);                          else                          {                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' true' changed);                              return state.PopPushType(1' fieldType' BottomPT);                          }                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                              return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          else                          {                              // Underlying type cannot be a struct' otherwise would have a pointer into                              // the stack                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' false' changed);                              return state.PopPushType                                  (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          }                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                          {                              state.PeekExpectedType(0' fieldType' changed);                              return state.Pop(1);                          }                          else                          {                              state.PeekExpectedType(0' fieldType' changed);                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (1' fieldi.Field.DefiningType' false' changed);                              return state.Pop(2);                          }                      case FieldOp.Ldtoken:                          return state.PushType(global.RuntimeFieldHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methi = (MethodInstruction)instruction;                      var sig = (CST.MethodSignature)methi.Method.ExternalSignature;                      switch (methi.Op)                      {                      case MethodOp.Call:                          {                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              if (methi.Constrained != null)                              {                                  if (!methi.IsVirtual || methi.Method.IsStatic)                                      throw new InvalidOperationException                                          ("constrained only valid on virtual calls to instance methods");                                  var thisType = sig.Parameters[0];                                  var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(methi.Constrained);                                  var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo(methi.Constrained);                                  var cs = methi.Constrained.Style(methEnv);                                  if (cs is ValueTypeStyle)                                  {                                      if (thisType.Style(methEnv) is ManagedPointerTypeStyle)                                      {                                          // We pass the argument pointer as is                                          if (!methi.Constrained.IsAssignableTo(methEnv' thisType.Arguments[0]))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                      else                                      {                                          // *Case 1* Morally we deref the argument pointer and box the contents'                                          // but since no supertype of a value type may mutate the underlying value'                                          // we don't need to take a copy of the value when boxing' so in practice                                          // this is a no-op                                          if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                  }                                  else if (cs is ReferenceTypeStyle)                                  {                                      // *Case 2* We dereference the pointer and pass the object reference                                      if (!methi.Constrained.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else if (cs is ParameterTypeStyle)                                  {                                      // Since we are calling an instance method' we know the first argument cannot be                                      // a "naked" type parameter' but is either a class or an interface.                                      // We must decide between cases 1 and 2 above at runtime' but checking as                                      // per case 1 is sufficient now.                                      // NOTE: As for box/classcast/isinst below' if the parameter is                                      // instantiated to a reference type then the type box type is considered                                      // equivalent to the underyling reference type.                                      if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else                                      throw new InvalidOperationException                                          ("constrained must be value' reference or parameter type");                                    state.PeekExpectedType(sig.Parameters.Count - 1' constrainedPtr' changed);                              }                              else if (sig.Parameters.Count > 0)                                  state.PeekExpectedType(sig.Parameters.Count - 1' sig.Parameters[0]' changed);                              if (sig.Result == null)                                  return state.Pop(sig.Parameters.Count);                              else                                  return state.PopPushType(sig.Parameters.Count' sig.Result' BottomPT);                          }                      case MethodOp.Ldftn:                          {                              // NOTE: Verified CLR allows only the two "blessed" sequences:                              //   dup; ldvirtftn; newobj <delegate ctor>                              //   ldftn; newobj <delegate ctor>                              // It is thus possible to check the delegate will capture an instance which                              // implements the loaded method. However' we don't check that here.                              if (methi.IsVirtual)                              {                                  if (methi.Method.IsStatic)                                      throw new InvalidOperationException("cannot ldvirtftn of a static method");                                  var objectType = default(TypeRef);                                  if (sig.Parameters[0].Style(methEnv) is ManagedPointerTypeStyle)                                      // Object should be a box                                      objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(sig.Parameters[0].Arguments[0]);                                  else                                      // Object should match parameter                                      objectType = sig.Parameters[0];                                  state.PeekExpectedType(0' objectType' changed);                                  return state.PopPushType(1' sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                              else                              {                                  if (methi.Method.IsStatic)                                      return state.PushType(sig.ToCodePointer(methEnv.Global)' BottomPT);                                  else                                      return state.PushType(sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                          }                      case MethodOp.Newobj:                          {                              if (methi.Method.IsStatic || sig.Result != null)                                  throw new InvalidOperationException("not a constructor");                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              // First argument to constructor is created by runtime. If definining type is                              // a value type' first argument will be a pointer' but result left on stack                              // will be the value itself.                              return state.PopPushType(sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);                          }                      case MethodOp.Ldtoken:                          return state.PushType(global.RuntimeMethodHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          state.PeekReadPointerType(0' typei.Type);                          return state.PopPushType(1' typei.Type' BottomPT);                      case TypeOp.Stobj:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Cpobj:                          state.PeekReadPointerType(0' typei.Type);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Newarr:                          state.PeekIndexType(0);                          return state.PopPushType(1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo(typei.Type)' BottomPT);                      case TypeOp.Initobj:                          state.PeekWritePointerType(0' typei.Type);                          return state.Pop(1);                      case TypeOp.Castclass:                      case TypeOp.Isinst:                      case TypeOp.Box:                          {                              var resultType = default(TypeRef);                              var s = typei.Type.Style(methEnv);                              if (s is NullableTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type.Arguments[0]);                              else if (s is ValueTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else if (s is ReferenceTypeStyle)                                  resultType = typei.Type;                              else if (s is ParameterTypeStyle)                                  // NOTE: As for constrained call above' if type parameter is instantitated to                                  // a ref type' then this box type is considered equivalent to the                                  // underlying reference type.                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else                                  throw new InvalidOperationException                                      ("can only box/cast to reference' value or parameter type");                              if (typei.Op == TypeOp.Box)                                  state.PeekExpectedType(0' typei.Type' changed);                              else                                  state.PeekReferenceType(0);                              return state.PopPushType(1' resultType' BottomPT);                          }                      case TypeOp.Unbox:                          if (!(typei.Type.Style(methEnv) is ValueTypeStyle))                              // Parameter types are not allowed                              throw new InvalidOperationException("type must be a value type");                          state.PeekBoxedType(0' typei.Type' changed);                          return state.PopPushType(1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(typei.Type)' HeapPT);                      case TypeOp.UnboxAny:                          {                              var s = typei.Type.Style(methEnv);                              if (s is ValueTypeStyle)                                  state.PeekBoxedType(0' typei.Type' changed);                              else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))                                  throw new InvalidOperationException("type must be value' reference or parameter type");                              return state.PopPushType(1' typei.Type' BottomPT);                          }                      case TypeOp.Ldtoken:                          return state.PushType(global.RuntimeTypeHandleRef' BottomPT);                      case TypeOp.Ldelem:                          state.PeekIndexType(0);                          state.PeekReadArrayType(1' typei.Type' false);                          return state.PopPushType(2' typei.Type' BottomPT);                      case TypeOp.Stelem:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekIndexType(1);                          state.PeekWriteArrayType(2' typei.Type);                          return state.Pop(3);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  {                      var ldelemai = (LdElemAddrInstruction)instruction;                      state.PeekIndexType(0);                      // WARNING: May prematurely fail for non-readonly loads                      state.PeekReadArrayType(1' ldelemai.Type' !ldelemai.IsReadonly);                      return state.PopPushType(2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(ldelemai.Type)' HeapPT);                  }              case InstructionFlavor.LdInt32:                  return state.PushType(global.Int32Ref' BottomPT);              case InstructionFlavor.LdInt64:                  return state.PushType(global.Int64Ref' BottomPT);              case InstructionFlavor.LdSingle:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdDouble:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdString:                  return state.PushType(global.StringRef' BottomPT);              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.Div:                      case ArithOp.Rem:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' true);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.Neg:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' true);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' false);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.BitNot:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.Shl:                      case ArithOp.Shr:                          state.PeekExpectedType(0' global.Int32Ref' changed);                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(1' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(2' arithi.Type' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned &&                                           convi.TargetNumberFlavor == NumberFlavor.Double);                      // NOTE: May capture skolemized types                      convi.SourceType = state.PeekNumberType(0' !mustBeInteger);                      return state.PopPushType(1' TypeRef.NumberFrom(methEnv.Global' convi.TargetNumberFlavor)' BottomPT);                  }              case InstructionFlavor.Try:                  {                      var tryi = (TryInstruction)instruction;                      // Isolation:                      //  - There is no way for the current stack shape to influence or be influenced by                      //    inference of the try' since the current stack shape must be empty.                      //  - There is no way for the try to influence the result stack shape' since it must be                      //    empty.                      //  - However pointers in arguments and locals may propogate into and out of try body                      //    via exceptional transitions. The latter are delt with separately.                      if (state.Depth != 0)                          throw new InvalidOperationException("stack should be empty");                      var newState = ForwardBlock                          (new TryBodyInstructionContext(context' index' tryi.Body)' state' changed);                      for (var j = 0; j < tryi.Handlers.Count; j++)                      {                          var h = tryi.Handlers[j];                          var handlerContext = new TryHandlerInstructionContext(context' index' h.Body' j);                          var initHandlerState = new MachineState                              (methEnv' method.ValueParameters.Count' method.Locals.Count);                          switch (h.Flavor)                          {                          case HandlerFlavor.Catch:                              {                                  var catchh = (CatchTryInstructionHandler)h;                                  ForwardBlock(handlerContext' initHandlerState.PushType(catchh.Type' BottomPT)' changed);                                  break;                              }                          case HandlerFlavor.Filter:                              throw new NotSupportedException("filter handler blocks");                          case HandlerFlavor.Fault:                          case HandlerFlavor.Finally:                              ForwardBlock(handlerContext' initHandlerState' changed);                              break;                          default:                              throw new ArgumentOutOfRangeException();                          }                      }                      return newState;                  }              case InstructionFlavor.IfThenElsePseudo:              case InstructionFlavor.ShortCircuitingPseudo:              case InstructionFlavor.StructuralSwitchPseudo:              case InstructionFlavor.LoopPseudo:              case InstructionFlavor.WhileDoPseudo:              case InstructionFlavor.DoWhilePseudo:              case InstructionFlavor.LoopControlPseudo:                  throw new InvalidOperationException("no machine state inference for psuedo-instructions");              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return state;                      case MiscOp.Dup:                          return state.Push(state.Peek(0));                      case MiscOp.Pop:                          return state.Pop(1);                      case MiscOp.Ldnull:                          return state.PushType(global.NullRef' BottomPT);                      case MiscOp.Ckfinite:                          state.PeekExpectedType(0' global.DoubleRef' changed);                          // Assume the instruction can "peek" at top of stack' thus no need for pop/push.                          return state;                      case MiscOp.Throw:                          state.PeekReferenceType(0);                          return state.DiscardStack();                      case MiscOp.Rethrow:                          return state.DiscardStack();                      case MiscOp.LdindRef:                          {                              var elemType = state.PeekPointerToReferenceType(0);                              return state.PopPushType(1' elemType' BottomPT);                          }                      case MiscOp.StindRef:                          {                              var expElemType = state.PeekPointerToReferenceType(1);                              state.PeekExpectedType(0' expElemType' changed);                              return state.Pop(2);                          }                      case MiscOp.LdelemRef:                          {                              state.PeekIndexType(0);                              // WARNING: Type may not be final                              var elemType = state.PeekArrayOfReferenceType(1);                              return state.PopPushType(2' elemType' BottomPT);                          }                      case MiscOp.StelemRef:                          state.PeekReferenceType(0);                          state.PeekIndexType(1);                          state.PeekArrayOfReferenceType(2);                          // Since the value type and array element type may be independently generalized'                          // it is pointless to check that the first is assignable to the second.                          // Instead this check is done at runtime.                          return state.Pop(3);                      case MiscOp.Ldlen:                          state.PeekArrayOfAnyType(0);                          return state.PopPushType(1' global.IntNativeRef' BottomPT);                      case MiscOp.Ret:                          {                              if (state.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return state; // empty                          }                      case MiscOp.RetVal:                          {                              state.PeekExpectedType(0' method.Result.Type' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfilter:                          {                              state.PeekExpectedType(0' global.Int32Ref' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfinally:                          {                              // Control could transfer to an outer finally/fault block' or to the target                              // of a leave instruction. However these transitions are delt with separately.                              return state.DiscardStack();                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:                  {                      var bri = (BranchInstruction)instruction;                      switch (bri.Op)                      {                      case BranchOp.Br:                          UnifyBeforeState(state' bri.Target' changed);                          return state;                      case BranchOp.Brtrue:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' false);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Brfalse:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Breq:                      case BranchOp.Brne:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' true);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Leave:                          {                              // Control could transfer via finally blocks instead of directly to the leave target.                              // Propogate only that the stack must be empty at target. Remaining machine state                              // is dealt with separately.                              UnifyBeforeState                                  (new MachineState(methEnv' method.ValueParameters.Count' method.Locals.Count)'                                   bri.Target'                                   changed);                              return state.DiscardStack();                          }                      case BranchOp.BrLt:                      case BranchOp.BrLe:                      case BranchOp.BrGt:                      case BranchOp.BrGe:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' false);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Switch:                  {                      var switchi = (SwitchInstruction)instruction;                      state.PeekExpectedType(0' global.Int32Ref' changed);                      var newState = state.Pop(1);                      for (var i = 0; i < switchi.CaseTargets.Count; i++)                          UnifyBeforeState(newState' switchi.CaseTargets[i]' changed);                      return newState;                  }              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      // WARNING: Capured type may not be final                      // NOTE: May capture skolemized types                      switch (cmpi.Op)                      {                      case CompareOp.Ceq:                      case CompareOp.CnePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' true);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.Clt:                      case CompareOp.Cgt:                      case CompareOp.CgePseudo:                      case CompareOp.ClePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' false);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.CtruePseudo:                      case CompareOp.CfalsePseudo:                          cmpi.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                          return state.PopPushType(1' global.Int32Ref' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var argi = (ArgLocalInstruction)instruction;                      var type = method.ArgLocalType(argi.ArgLocal' argi.Index);                      switch (argi.Op)                      {                      case ArgLocalOp.Ld:                          return state.PushType(type' state.ArgLocalPointsTo(argi.ArgLocal' argi.Index));                      case ArgLocalOp.Lda:                          return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(type)' ArgLocalPT(argi.ArgLocal' argi.Index));                      case ArgLocalOp.St:                          {                              state.PeekExpectedType(0' type' changed);                              var pointsTo = state.PeekPointsTo(0);                              if (!pointsTo.IsBottom)                              {                                  if (!(type.Style(methEnv) is ManagedPointerTypeStyle))                                      throw new InvalidOperationException                                          ("stack indicates pointer' but parameter or local type does not");                                  if (pointsTo.PointsOutsideOfHeap)                                      throw new InvalidOperationException("arguments cannot point outside of the heap");                              }                              return state.PopAddArgLocalPointsTo(1' argi.ArgLocal' argi.Index' pointsTo);                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      var fieldEnv = fieldi.Field.Enter(methEnv);                      var fieldType = fieldEnv.SubstituteType(fieldEnv.Field.FieldType);                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                              return state.PushType(fieldType' BottomPT);                          else                          {                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' true' changed);                              return state.PopPushType(1' fieldType' BottomPT);                          }                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                              return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          else                          {                              // Underlying type cannot be a struct' otherwise would have a pointer into                              // the stack                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' false' changed);                              return state.PopPushType                                  (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          }                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                          {                              state.PeekExpectedType(0' fieldType' changed);                              return state.Pop(1);                          }                          else                          {                              state.PeekExpectedType(0' fieldType' changed);                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (1' fieldi.Field.DefiningType' false' changed);                              return state.Pop(2);                          }                      case FieldOp.Ldtoken:                          return state.PushType(global.RuntimeFieldHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methi = (MethodInstruction)instruction;                      var sig = (CST.MethodSignature)methi.Method.ExternalSignature;                      switch (methi.Op)                      {                      case MethodOp.Call:                          {                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              if (methi.Constrained != null)                              {                                  if (!methi.IsVirtual || methi.Method.IsStatic)                                      throw new InvalidOperationException                                          ("constrained only valid on virtual calls to instance methods");                                  var thisType = sig.Parameters[0];                                  var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(methi.Constrained);                                  var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo(methi.Constrained);                                  var cs = methi.Constrained.Style(methEnv);                                  if (cs is ValueTypeStyle)                                  {                                      if (thisType.Style(methEnv) is ManagedPointerTypeStyle)                                      {                                          // We pass the argument pointer as is                                          if (!methi.Constrained.IsAssignableTo(methEnv' thisType.Arguments[0]))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                      else                                      {                                          // *Case 1* Morally we deref the argument pointer and box the contents'                                          // but since no supertype of a value type may mutate the underlying value'                                          // we don't need to take a copy of the value when boxing' so in practice                                          // this is a no-op                                          if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                  }                                  else if (cs is ReferenceTypeStyle)                                  {                                      // *Case 2* We dereference the pointer and pass the object reference                                      if (!methi.Constrained.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else if (cs is ParameterTypeStyle)                                  {                                      // Since we are calling an instance method' we know the first argument cannot be                                      // a "naked" type parameter' but is either a class or an interface.                                      // We must decide between cases 1 and 2 above at runtime' but checking as                                      // per case 1 is sufficient now.                                      // NOTE: As for box/classcast/isinst below' if the parameter is                                      // instantiated to a reference type then the type box type is considered                                      // equivalent to the underyling reference type.                                      if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else                                      throw new InvalidOperationException                                          ("constrained must be value' reference or parameter type");                                    state.PeekExpectedType(sig.Parameters.Count - 1' constrainedPtr' changed);                              }                              else if (sig.Parameters.Count > 0)                                  state.PeekExpectedType(sig.Parameters.Count - 1' sig.Parameters[0]' changed);                              if (sig.Result == null)                                  return state.Pop(sig.Parameters.Count);                              else                                  return state.PopPushType(sig.Parameters.Count' sig.Result' BottomPT);                          }                      case MethodOp.Ldftn:                          {                              // NOTE: Verified CLR allows only the two "blessed" sequences:                              //   dup; ldvirtftn; newobj <delegate ctor>                              //   ldftn; newobj <delegate ctor>                              // It is thus possible to check the delegate will capture an instance which                              // implements the loaded method. However' we don't check that here.                              if (methi.IsVirtual)                              {                                  if (methi.Method.IsStatic)                                      throw new InvalidOperationException("cannot ldvirtftn of a static method");                                  var objectType = default(TypeRef);                                  if (sig.Parameters[0].Style(methEnv) is ManagedPointerTypeStyle)                                      // Object should be a box                                      objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(sig.Parameters[0].Arguments[0]);                                  else                                      // Object should match parameter                                      objectType = sig.Parameters[0];                                  state.PeekExpectedType(0' objectType' changed);                                  return state.PopPushType(1' sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                              else                              {                                  if (methi.Method.IsStatic)                                      return state.PushType(sig.ToCodePointer(methEnv.Global)' BottomPT);                                  else                                      return state.PushType(sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                          }                      case MethodOp.Newobj:                          {                              if (methi.Method.IsStatic || sig.Result != null)                                  throw new InvalidOperationException("not a constructor");                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              // First argument to constructor is created by runtime. If definining type is                              // a value type' first argument will be a pointer' but result left on stack                              // will be the value itself.                              return state.PopPushType(sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);                          }                      case MethodOp.Ldtoken:                          return state.PushType(global.RuntimeMethodHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          state.PeekReadPointerType(0' typei.Type);                          return state.PopPushType(1' typei.Type' BottomPT);                      case TypeOp.Stobj:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Cpobj:                          state.PeekReadPointerType(0' typei.Type);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Newarr:                          state.PeekIndexType(0);                          return state.PopPushType(1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo(typei.Type)' BottomPT);                      case TypeOp.Initobj:                          state.PeekWritePointerType(0' typei.Type);                          return state.Pop(1);                      case TypeOp.Castclass:                      case TypeOp.Isinst:                      case TypeOp.Box:                          {                              var resultType = default(TypeRef);                              var s = typei.Type.Style(methEnv);                              if (s is NullableTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type.Arguments[0]);                              else if (s is ValueTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else if (s is ReferenceTypeStyle)                                  resultType = typei.Type;                              else if (s is ParameterTypeStyle)                                  // NOTE: As for constrained call above' if type parameter is instantitated to                                  // a ref type' then this box type is considered equivalent to the                                  // underlying reference type.                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else                                  throw new InvalidOperationException                                      ("can only box/cast to reference' value or parameter type");                              if (typei.Op == TypeOp.Box)                                  state.PeekExpectedType(0' typei.Type' changed);                              else                                  state.PeekReferenceType(0);                              return state.PopPushType(1' resultType' BottomPT);                          }                      case TypeOp.Unbox:                          if (!(typei.Type.Style(methEnv) is ValueTypeStyle))                              // Parameter types are not allowed                              throw new InvalidOperationException("type must be a value type");                          state.PeekBoxedType(0' typei.Type' changed);                          return state.PopPushType(1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(typei.Type)' HeapPT);                      case TypeOp.UnboxAny:                          {                              var s = typei.Type.Style(methEnv);                              if (s is ValueTypeStyle)                                  state.PeekBoxedType(0' typei.Type' changed);                              else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))                                  throw new InvalidOperationException("type must be value' reference or parameter type");                              return state.PopPushType(1' typei.Type' BottomPT);                          }                      case TypeOp.Ldtoken:                          return state.PushType(global.RuntimeTypeHandleRef' BottomPT);                      case TypeOp.Ldelem:                          state.PeekIndexType(0);                          state.PeekReadArrayType(1' typei.Type' false);                          return state.PopPushType(2' typei.Type' BottomPT);                      case TypeOp.Stelem:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekIndexType(1);                          state.PeekWriteArrayType(2' typei.Type);                          return state.Pop(3);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  {                      var ldelemai = (LdElemAddrInstruction)instruction;                      state.PeekIndexType(0);                      // WARNING: May prematurely fail for non-readonly loads                      state.PeekReadArrayType(1' ldelemai.Type' !ldelemai.IsReadonly);                      return state.PopPushType(2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(ldelemai.Type)' HeapPT);                  }              case InstructionFlavor.LdInt32:                  return state.PushType(global.Int32Ref' BottomPT);              case InstructionFlavor.LdInt64:                  return state.PushType(global.Int64Ref' BottomPT);              case InstructionFlavor.LdSingle:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdDouble:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdString:                  return state.PushType(global.StringRef' BottomPT);              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.Div:                      case ArithOp.Rem:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' true);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.Neg:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' true);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' false);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.BitNot:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.Shl:                      case ArithOp.Shr:                          state.PeekExpectedType(0' global.Int32Ref' changed);                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(1' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(2' arithi.Type' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned &&                                           convi.TargetNumberFlavor == NumberFlavor.Double);                      // NOTE: May capture skolemized types                      convi.SourceType = state.PeekNumberType(0' !mustBeInteger);                      return state.PopPushType(1' TypeRef.NumberFrom(methEnv.Global' convi.TargetNumberFlavor)' BottomPT);                  }              case InstructionFlavor.Try:                  {                      var tryi = (TryInstruction)instruction;                      // Isolation:                      //  - There is no way for the current stack shape to influence or be influenced by                      //    inference of the try' since the current stack shape must be empty.                      //  - There is no way for the try to influence the result stack shape' since it must be                      //    empty.                      //  - However pointers in arguments and locals may propogate into and out of try body                      //    via exceptional transitions. The latter are delt with separately.                      if (state.Depth != 0)                          throw new InvalidOperationException("stack should be empty");                      var newState = ForwardBlock                          (new TryBodyInstructionContext(context' index' tryi.Body)' state' changed);                      for (var j = 0; j < tryi.Handlers.Count; j++)                      {                          var h = tryi.Handlers[j];                          var handlerContext = new TryHandlerInstructionContext(context' index' h.Body' j);                          var initHandlerState = new MachineState                              (methEnv' method.ValueParameters.Count' method.Locals.Count);                          switch (h.Flavor)                          {                          case HandlerFlavor.Catch:                              {                                  var catchh = (CatchTryInstructionHandler)h;                                  ForwardBlock(handlerContext' initHandlerState.PushType(catchh.Type' BottomPT)' changed);                                  break;                              }                          case HandlerFlavor.Filter:                              throw new NotSupportedException("filter handler blocks");                          case HandlerFlavor.Fault:                          case HandlerFlavor.Finally:                              ForwardBlock(handlerContext' initHandlerState' changed);                              break;                          default:                              throw new ArgumentOutOfRangeException();                          }                      }                      return newState;                  }              case InstructionFlavor.IfThenElsePseudo:              case InstructionFlavor.ShortCircuitingPseudo:              case InstructionFlavor.StructuralSwitchPseudo:              case InstructionFlavor.LoopPseudo:              case InstructionFlavor.WhileDoPseudo:              case InstructionFlavor.DoWhilePseudo:              case InstructionFlavor.LoopControlPseudo:                  throw new InvalidOperationException("no machine state inference for psuedo-instructions");              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return state;                      case MiscOp.Dup:                          return state.Push(state.Peek(0));                      case MiscOp.Pop:                          return state.Pop(1);                      case MiscOp.Ldnull:                          return state.PushType(global.NullRef' BottomPT);                      case MiscOp.Ckfinite:                          state.PeekExpectedType(0' global.DoubleRef' changed);                          // Assume the instruction can "peek" at top of stack' thus no need for pop/push.                          return state;                      case MiscOp.Throw:                          state.PeekReferenceType(0);                          return state.DiscardStack();                      case MiscOp.Rethrow:                          return state.DiscardStack();                      case MiscOp.LdindRef:                          {                              var elemType = state.PeekPointerToReferenceType(0);                              return state.PopPushType(1' elemType' BottomPT);                          }                      case MiscOp.StindRef:                          {                              var expElemType = state.PeekPointerToReferenceType(1);                              state.PeekExpectedType(0' expElemType' changed);                              return state.Pop(2);                          }                      case MiscOp.LdelemRef:                          {                              state.PeekIndexType(0);                              // WARNING: Type may not be final                              var elemType = state.PeekArrayOfReferenceType(1);                              return state.PopPushType(2' elemType' BottomPT);                          }                      case MiscOp.StelemRef:                          state.PeekReferenceType(0);                          state.PeekIndexType(1);                          state.PeekArrayOfReferenceType(2);                          // Since the value type and array element type may be independently generalized'                          // it is pointless to check that the first is assignable to the second.                          // Instead this check is done at runtime.                          return state.Pop(3);                      case MiscOp.Ldlen:                          state.PeekArrayOfAnyType(0);                          return state.PopPushType(1' global.IntNativeRef' BottomPT);                      case MiscOp.Ret:                          {                              if (state.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return state; // empty                          }                      case MiscOp.RetVal:                          {                              state.PeekExpectedType(0' method.Result.Type' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfilter:                          {                              state.PeekExpectedType(0' global.Int32Ref' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfinally:                          {                              // Control could transfer to an outer finally/fault block' or to the target                              // of a leave instruction. However these transitions are delt with separately.                              return state.DiscardStack();                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:                  {                      var bri = (BranchInstruction)instruction;                      switch (bri.Op)                      {                      case BranchOp.Br:                          UnifyBeforeState(state' bri.Target' changed);                          return state;                      case BranchOp.Brtrue:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' false);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Brfalse:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Breq:                      case BranchOp.Brne:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' true);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Leave:                          {                              // Control could transfer via finally blocks instead of directly to the leave target.                              // Propogate only that the stack must be empty at target. Remaining machine state                              // is dealt with separately.                              UnifyBeforeState                                  (new MachineState(methEnv' method.ValueParameters.Count' method.Locals.Count)'                                   bri.Target'                                   changed);                              return state.DiscardStack();                          }                      case BranchOp.BrLt:                      case BranchOp.BrLe:                      case BranchOp.BrGt:                      case BranchOp.BrGe:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' false);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Switch:                  {                      var switchi = (SwitchInstruction)instruction;                      state.PeekExpectedType(0' global.Int32Ref' changed);                      var newState = state.Pop(1);                      for (var i = 0; i < switchi.CaseTargets.Count; i++)                          UnifyBeforeState(newState' switchi.CaseTargets[i]' changed);                      return newState;                  }              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      // WARNING: Capured type may not be final                      // NOTE: May capture skolemized types                      switch (cmpi.Op)                      {                      case CompareOp.Ceq:                      case CompareOp.CnePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' true);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.Clt:                      case CompareOp.Cgt:                      case CompareOp.CgePseudo:                      case CompareOp.ClePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' false);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.CtruePseudo:                      case CompareOp.CfalsePseudo:                          cmpi.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                          return state.PopPushType(1' global.Int32Ref' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var argi = (ArgLocalInstruction)instruction;                      var type = method.ArgLocalType(argi.ArgLocal' argi.Index);                      switch (argi.Op)                      {                      case ArgLocalOp.Ld:                          return state.PushType(type' state.ArgLocalPointsTo(argi.ArgLocal' argi.Index));                      case ArgLocalOp.Lda:                          return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(type)' ArgLocalPT(argi.ArgLocal' argi.Index));                      case ArgLocalOp.St:                          {                              state.PeekExpectedType(0' type' changed);                              var pointsTo = state.PeekPointsTo(0);                              if (!pointsTo.IsBottom)                              {                                  if (!(type.Style(methEnv) is ManagedPointerTypeStyle))                                      throw new InvalidOperationException                                          ("stack indicates pointer' but parameter or local type does not");                                  if (pointsTo.PointsOutsideOfHeap)                                      throw new InvalidOperationException("arguments cannot point outside of the heap");                              }                              return state.PopAddArgLocalPointsTo(1' argi.ArgLocal' argi.Index' pointsTo);                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      var fieldEnv = fieldi.Field.Enter(methEnv);                      var fieldType = fieldEnv.SubstituteType(fieldEnv.Field.FieldType);                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                              return state.PushType(fieldType' BottomPT);                          else                          {                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' true' changed);                              return state.PopPushType(1' fieldType' BottomPT);                          }                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                              return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          else                          {                              // Underlying type cannot be a struct' otherwise would have a pointer into                              // the stack                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' false' changed);                              return state.PopPushType                                  (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          }                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                          {                              state.PeekExpectedType(0' fieldType' changed);                              return state.Pop(1);                          }                          else                          {                              state.PeekExpectedType(0' fieldType' changed);                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (1' fieldi.Field.DefiningType' false' changed);                              return state.Pop(2);                          }                      case FieldOp.Ldtoken:                          return state.PushType(global.RuntimeFieldHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methi = (MethodInstruction)instruction;                      var sig = (CST.MethodSignature)methi.Method.ExternalSignature;                      switch (methi.Op)                      {                      case MethodOp.Call:                          {                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              if (methi.Constrained != null)                              {                                  if (!methi.IsVirtual || methi.Method.IsStatic)                                      throw new InvalidOperationException                                          ("constrained only valid on virtual calls to instance methods");                                  var thisType = sig.Parameters[0];                                  var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(methi.Constrained);                                  var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo(methi.Constrained);                                  var cs = methi.Constrained.Style(methEnv);                                  if (cs is ValueTypeStyle)                                  {                                      if (thisType.Style(methEnv) is ManagedPointerTypeStyle)                                      {                                          // We pass the argument pointer as is                                          if (!methi.Constrained.IsAssignableTo(methEnv' thisType.Arguments[0]))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                      else                                      {                                          // *Case 1* Morally we deref the argument pointer and box the contents'                                          // but since no supertype of a value type may mutate the underlying value'                                          // we don't need to take a copy of the value when boxing' so in practice                                          // this is a no-op                                          if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                  }                                  else if (cs is ReferenceTypeStyle)                                  {                                      // *Case 2* We dereference the pointer and pass the object reference                                      if (!methi.Constrained.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else if (cs is ParameterTypeStyle)                                  {                                      // Since we are calling an instance method' we know the first argument cannot be                                      // a "naked" type parameter' but is either a class or an interface.                                      // We must decide between cases 1 and 2 above at runtime' but checking as                                      // per case 1 is sufficient now.                                      // NOTE: As for box/classcast/isinst below' if the parameter is                                      // instantiated to a reference type then the type box type is considered                                      // equivalent to the underyling reference type.                                      if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else                                      throw new InvalidOperationException                                          ("constrained must be value' reference or parameter type");                                    state.PeekExpectedType(sig.Parameters.Count - 1' constrainedPtr' changed);                              }                              else if (sig.Parameters.Count > 0)                                  state.PeekExpectedType(sig.Parameters.Count - 1' sig.Parameters[0]' changed);                              if (sig.Result == null)                                  return state.Pop(sig.Parameters.Count);                              else                                  return state.PopPushType(sig.Parameters.Count' sig.Result' BottomPT);                          }                      case MethodOp.Ldftn:                          {                              // NOTE: Verified CLR allows only the two "blessed" sequences:                              //   dup; ldvirtftn; newobj <delegate ctor>                              //   ldftn; newobj <delegate ctor>                              // It is thus possible to check the delegate will capture an instance which                              // implements the loaded method. However' we don't check that here.                              if (methi.IsVirtual)                              {                                  if (methi.Method.IsStatic)                                      throw new InvalidOperationException("cannot ldvirtftn of a static method");                                  var objectType = default(TypeRef);                                  if (sig.Parameters[0].Style(methEnv) is ManagedPointerTypeStyle)                                      // Object should be a box                                      objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(sig.Parameters[0].Arguments[0]);                                  else                                      // Object should match parameter                                      objectType = sig.Parameters[0];                                  state.PeekExpectedType(0' objectType' changed);                                  return state.PopPushType(1' sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                              else                              {                                  if (methi.Method.IsStatic)                                      return state.PushType(sig.ToCodePointer(methEnv.Global)' BottomPT);                                  else                                      return state.PushType(sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                          }                      case MethodOp.Newobj:                          {                              if (methi.Method.IsStatic || sig.Result != null)                                  throw new InvalidOperationException("not a constructor");                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              // First argument to constructor is created by runtime. If definining type is                              // a value type' first argument will be a pointer' but result left on stack                              // will be the value itself.                              return state.PopPushType(sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);                          }                      case MethodOp.Ldtoken:                          return state.PushType(global.RuntimeMethodHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          state.PeekReadPointerType(0' typei.Type);                          return state.PopPushType(1' typei.Type' BottomPT);                      case TypeOp.Stobj:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Cpobj:                          state.PeekReadPointerType(0' typei.Type);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Newarr:                          state.PeekIndexType(0);                          return state.PopPushType(1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo(typei.Type)' BottomPT);                      case TypeOp.Initobj:                          state.PeekWritePointerType(0' typei.Type);                          return state.Pop(1);                      case TypeOp.Castclass:                      case TypeOp.Isinst:                      case TypeOp.Box:                          {                              var resultType = default(TypeRef);                              var s = typei.Type.Style(methEnv);                              if (s is NullableTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type.Arguments[0]);                              else if (s is ValueTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else if (s is ReferenceTypeStyle)                                  resultType = typei.Type;                              else if (s is ParameterTypeStyle)                                  // NOTE: As for constrained call above' if type parameter is instantitated to                                  // a ref type' then this box type is considered equivalent to the                                  // underlying reference type.                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else                                  throw new InvalidOperationException                                      ("can only box/cast to reference' value or parameter type");                              if (typei.Op == TypeOp.Box)                                  state.PeekExpectedType(0' typei.Type' changed);                              else                                  state.PeekReferenceType(0);                              return state.PopPushType(1' resultType' BottomPT);                          }                      case TypeOp.Unbox:                          if (!(typei.Type.Style(methEnv) is ValueTypeStyle))                              // Parameter types are not allowed                              throw new InvalidOperationException("type must be a value type");                          state.PeekBoxedType(0' typei.Type' changed);                          return state.PopPushType(1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(typei.Type)' HeapPT);                      case TypeOp.UnboxAny:                          {                              var s = typei.Type.Style(methEnv);                              if (s is ValueTypeStyle)                                  state.PeekBoxedType(0' typei.Type' changed);                              else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))                                  throw new InvalidOperationException("type must be value' reference or parameter type");                              return state.PopPushType(1' typei.Type' BottomPT);                          }                      case TypeOp.Ldtoken:                          return state.PushType(global.RuntimeTypeHandleRef' BottomPT);                      case TypeOp.Ldelem:                          state.PeekIndexType(0);                          state.PeekReadArrayType(1' typei.Type' false);                          return state.PopPushType(2' typei.Type' BottomPT);                      case TypeOp.Stelem:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekIndexType(1);                          state.PeekWriteArrayType(2' typei.Type);                          return state.Pop(3);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  {                      var ldelemai = (LdElemAddrInstruction)instruction;                      state.PeekIndexType(0);                      // WARNING: May prematurely fail for non-readonly loads                      state.PeekReadArrayType(1' ldelemai.Type' !ldelemai.IsReadonly);                      return state.PopPushType(2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(ldelemai.Type)' HeapPT);                  }              case InstructionFlavor.LdInt32:                  return state.PushType(global.Int32Ref' BottomPT);              case InstructionFlavor.LdInt64:                  return state.PushType(global.Int64Ref' BottomPT);              case InstructionFlavor.LdSingle:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdDouble:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdString:                  return state.PushType(global.StringRef' BottomPT);              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.Div:                      case ArithOp.Rem:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' true);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.Neg:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' true);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' false);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.BitNot:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.Shl:                      case ArithOp.Shr:                          state.PeekExpectedType(0' global.Int32Ref' changed);                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(1' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(2' arithi.Type' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned &&                                           convi.TargetNumberFlavor == NumberFlavor.Double);                      // NOTE: May capture skolemized types                      convi.SourceType = state.PeekNumberType(0' !mustBeInteger);                      return state.PopPushType(1' TypeRef.NumberFrom(methEnv.Global' convi.TargetNumberFlavor)' BottomPT);                  }              case InstructionFlavor.Try:                  {                      var tryi = (TryInstruction)instruction;                      // Isolation:                      //  - There is no way for the current stack shape to influence or be influenced by                      //    inference of the try' since the current stack shape must be empty.                      //  - There is no way for the try to influence the result stack shape' since it must be                      //    empty.                      //  - However pointers in arguments and locals may propogate into and out of try body                      //    via exceptional transitions. The latter are delt with separately.                      if (state.Depth != 0)                          throw new InvalidOperationException("stack should be empty");                      var newState = ForwardBlock                          (new TryBodyInstructionContext(context' index' tryi.Body)' state' changed);                      for (var j = 0; j < tryi.Handlers.Count; j++)                      {                          var h = tryi.Handlers[j];                          var handlerContext = new TryHandlerInstructionContext(context' index' h.Body' j);                          var initHandlerState = new MachineState                              (methEnv' method.ValueParameters.Count' method.Locals.Count);                          switch (h.Flavor)                          {                          case HandlerFlavor.Catch:                              {                                  var catchh = (CatchTryInstructionHandler)h;                                  ForwardBlock(handlerContext' initHandlerState.PushType(catchh.Type' BottomPT)' changed);                                  break;                              }                          case HandlerFlavor.Filter:                              throw new NotSupportedException("filter handler blocks");                          case HandlerFlavor.Fault:                          case HandlerFlavor.Finally:                              ForwardBlock(handlerContext' initHandlerState' changed);                              break;                          default:                              throw new ArgumentOutOfRangeException();                          }                      }                      return newState;                  }              case InstructionFlavor.IfThenElsePseudo:              case InstructionFlavor.ShortCircuitingPseudo:              case InstructionFlavor.StructuralSwitchPseudo:              case InstructionFlavor.LoopPseudo:              case InstructionFlavor.WhileDoPseudo:              case InstructionFlavor.DoWhilePseudo:              case InstructionFlavor.LoopControlPseudo:                  throw new InvalidOperationException("no machine state inference for psuedo-instructions");              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return state;                      case MiscOp.Dup:                          return state.Push(state.Peek(0));                      case MiscOp.Pop:                          return state.Pop(1);                      case MiscOp.Ldnull:                          return state.PushType(global.NullRef' BottomPT);                      case MiscOp.Ckfinite:                          state.PeekExpectedType(0' global.DoubleRef' changed);                          // Assume the instruction can "peek" at top of stack' thus no need for pop/push.                          return state;                      case MiscOp.Throw:                          state.PeekReferenceType(0);                          return state.DiscardStack();                      case MiscOp.Rethrow:                          return state.DiscardStack();                      case MiscOp.LdindRef:                          {                              var elemType = state.PeekPointerToReferenceType(0);                              return state.PopPushType(1' elemType' BottomPT);                          }                      case MiscOp.StindRef:                          {                              var expElemType = state.PeekPointerToReferenceType(1);                              state.PeekExpectedType(0' expElemType' changed);                              return state.Pop(2);                          }                      case MiscOp.LdelemRef:                          {                              state.PeekIndexType(0);                              // WARNING: Type may not be final                              var elemType = state.PeekArrayOfReferenceType(1);                              return state.PopPushType(2' elemType' BottomPT);                          }                      case MiscOp.StelemRef:                          state.PeekReferenceType(0);                          state.PeekIndexType(1);                          state.PeekArrayOfReferenceType(2);                          // Since the value type and array element type may be independently generalized'                          // it is pointless to check that the first is assignable to the second.                          // Instead this check is done at runtime.                          return state.Pop(3);                      case MiscOp.Ldlen:                          state.PeekArrayOfAnyType(0);                          return state.PopPushType(1' global.IntNativeRef' BottomPT);                      case MiscOp.Ret:                          {                              if (state.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return state; // empty                          }                      case MiscOp.RetVal:                          {                              state.PeekExpectedType(0' method.Result.Type' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfilter:                          {                              state.PeekExpectedType(0' global.Int32Ref' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfinally:                          {                              // Control could transfer to an outer finally/fault block' or to the target                              // of a leave instruction. However these transitions are delt with separately.                              return state.DiscardStack();                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:                  {                      var bri = (BranchInstruction)instruction;                      switch (bri.Op)                      {                      case BranchOp.Br:                          UnifyBeforeState(state' bri.Target' changed);                          return state;                      case BranchOp.Brtrue:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' false);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Brfalse:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Breq:                      case BranchOp.Brne:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' true);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Leave:                          {                              // Control could transfer via finally blocks instead of directly to the leave target.                              // Propogate only that the stack must be empty at target. Remaining machine state                              // is dealt with separately.                              UnifyBeforeState                                  (new MachineState(methEnv' method.ValueParameters.Count' method.Locals.Count)'                                   bri.Target'                                   changed);                              return state.DiscardStack();                          }                      case BranchOp.BrLt:                      case BranchOp.BrLe:                      case BranchOp.BrGt:                      case BranchOp.BrGe:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' false);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Switch:                  {                      var switchi = (SwitchInstruction)instruction;                      state.PeekExpectedType(0' global.Int32Ref' changed);                      var newState = state.Pop(1);                      for (var i = 0; i < switchi.CaseTargets.Count; i++)                          UnifyBeforeState(newState' switchi.CaseTargets[i]' changed);                      return newState;                  }              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      // WARNING: Capured type may not be final                      // NOTE: May capture skolemized types                      switch (cmpi.Op)                      {                      case CompareOp.Ceq:                      case CompareOp.CnePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' true);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.Clt:                      case CompareOp.Cgt:                      case CompareOp.CgePseudo:                      case CompareOp.ClePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' false);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.CtruePseudo:                      case CompareOp.CfalsePseudo:                          cmpi.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                          return state.PopPushType(1' global.Int32Ref' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var argi = (ArgLocalInstruction)instruction;                      var type = method.ArgLocalType(argi.ArgLocal' argi.Index);                      switch (argi.Op)                      {                      case ArgLocalOp.Ld:                          return state.PushType(type' state.ArgLocalPointsTo(argi.ArgLocal' argi.Index));                      case ArgLocalOp.Lda:                          return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(type)' ArgLocalPT(argi.ArgLocal' argi.Index));                      case ArgLocalOp.St:                          {                              state.PeekExpectedType(0' type' changed);                              var pointsTo = state.PeekPointsTo(0);                              if (!pointsTo.IsBottom)                              {                                  if (!(type.Style(methEnv) is ManagedPointerTypeStyle))                                      throw new InvalidOperationException                                          ("stack indicates pointer' but parameter or local type does not");                                  if (pointsTo.PointsOutsideOfHeap)                                      throw new InvalidOperationException("arguments cannot point outside of the heap");                              }                              return state.PopAddArgLocalPointsTo(1' argi.ArgLocal' argi.Index' pointsTo);                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      var fieldEnv = fieldi.Field.Enter(methEnv);                      var fieldType = fieldEnv.SubstituteType(fieldEnv.Field.FieldType);                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                              return state.PushType(fieldType' BottomPT);                          else                          {                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' true' changed);                              return state.PopPushType(1' fieldType' BottomPT);                          }                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                              return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          else                          {                              // Underlying type cannot be a struct' otherwise would have a pointer into                              // the stack                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' false' changed);                              return state.PopPushType                                  (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          }                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                          {                              state.PeekExpectedType(0' fieldType' changed);                              return state.Pop(1);                          }                          else                          {                              state.PeekExpectedType(0' fieldType' changed);                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (1' fieldi.Field.DefiningType' false' changed);                              return state.Pop(2);                          }                      case FieldOp.Ldtoken:                          return state.PushType(global.RuntimeFieldHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methi = (MethodInstruction)instruction;                      var sig = (CST.MethodSignature)methi.Method.ExternalSignature;                      switch (methi.Op)                      {                      case MethodOp.Call:                          {                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              if (methi.Constrained != null)                              {                                  if (!methi.IsVirtual || methi.Method.IsStatic)                                      throw new InvalidOperationException                                          ("constrained only valid on virtual calls to instance methods");                                  var thisType = sig.Parameters[0];                                  var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(methi.Constrained);                                  var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo(methi.Constrained);                                  var cs = methi.Constrained.Style(methEnv);                                  if (cs is ValueTypeStyle)                                  {                                      if (thisType.Style(methEnv) is ManagedPointerTypeStyle)                                      {                                          // We pass the argument pointer as is                                          if (!methi.Constrained.IsAssignableTo(methEnv' thisType.Arguments[0]))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                      else                                      {                                          // *Case 1* Morally we deref the argument pointer and box the contents'                                          // but since no supertype of a value type may mutate the underlying value'                                          // we don't need to take a copy of the value when boxing' so in practice                                          // this is a no-op                                          if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                  }                                  else if (cs is ReferenceTypeStyle)                                  {                                      // *Case 2* We dereference the pointer and pass the object reference                                      if (!methi.Constrained.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else if (cs is ParameterTypeStyle)                                  {                                      // Since we are calling an instance method' we know the first argument cannot be                                      // a "naked" type parameter' but is either a class or an interface.                                      // We must decide between cases 1 and 2 above at runtime' but checking as                                      // per case 1 is sufficient now.                                      // NOTE: As for box/classcast/isinst below' if the parameter is                                      // instantiated to a reference type then the type box type is considered                                      // equivalent to the underyling reference type.                                      if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else                                      throw new InvalidOperationException                                          ("constrained must be value' reference or parameter type");                                    state.PeekExpectedType(sig.Parameters.Count - 1' constrainedPtr' changed);                              }                              else if (sig.Parameters.Count > 0)                                  state.PeekExpectedType(sig.Parameters.Count - 1' sig.Parameters[0]' changed);                              if (sig.Result == null)                                  return state.Pop(sig.Parameters.Count);                              else                                  return state.PopPushType(sig.Parameters.Count' sig.Result' BottomPT);                          }                      case MethodOp.Ldftn:                          {                              // NOTE: Verified CLR allows only the two "blessed" sequences:                              //   dup; ldvirtftn; newobj <delegate ctor>                              //   ldftn; newobj <delegate ctor>                              // It is thus possible to check the delegate will capture an instance which                              // implements the loaded method. However' we don't check that here.                              if (methi.IsVirtual)                              {                                  if (methi.Method.IsStatic)                                      throw new InvalidOperationException("cannot ldvirtftn of a static method");                                  var objectType = default(TypeRef);                                  if (sig.Parameters[0].Style(methEnv) is ManagedPointerTypeStyle)                                      // Object should be a box                                      objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(sig.Parameters[0].Arguments[0]);                                  else                                      // Object should match parameter                                      objectType = sig.Parameters[0];                                  state.PeekExpectedType(0' objectType' changed);                                  return state.PopPushType(1' sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                              else                              {                                  if (methi.Method.IsStatic)                                      return state.PushType(sig.ToCodePointer(methEnv.Global)' BottomPT);                                  else                                      return state.PushType(sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                          }                      case MethodOp.Newobj:                          {                              if (methi.Method.IsStatic || sig.Result != null)                                  throw new InvalidOperationException("not a constructor");                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              // First argument to constructor is created by runtime. If definining type is                              // a value type' first argument will be a pointer' but result left on stack                              // will be the value itself.                              return state.PopPushType(sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);                          }                      case MethodOp.Ldtoken:                          return state.PushType(global.RuntimeMethodHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          state.PeekReadPointerType(0' typei.Type);                          return state.PopPushType(1' typei.Type' BottomPT);                      case TypeOp.Stobj:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Cpobj:                          state.PeekReadPointerType(0' typei.Type);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Newarr:                          state.PeekIndexType(0);                          return state.PopPushType(1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo(typei.Type)' BottomPT);                      case TypeOp.Initobj:                          state.PeekWritePointerType(0' typei.Type);                          return state.Pop(1);                      case TypeOp.Castclass:                      case TypeOp.Isinst:                      case TypeOp.Box:                          {                              var resultType = default(TypeRef);                              var s = typei.Type.Style(methEnv);                              if (s is NullableTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type.Arguments[0]);                              else if (s is ValueTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else if (s is ReferenceTypeStyle)                                  resultType = typei.Type;                              else if (s is ParameterTypeStyle)                                  // NOTE: As for constrained call above' if type parameter is instantitated to                                  // a ref type' then this box type is considered equivalent to the                                  // underlying reference type.                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else                                  throw new InvalidOperationException                                      ("can only box/cast to reference' value or parameter type");                              if (typei.Op == TypeOp.Box)                                  state.PeekExpectedType(0' typei.Type' changed);                              else                                  state.PeekReferenceType(0);                              return state.PopPushType(1' resultType' BottomPT);                          }                      case TypeOp.Unbox:                          if (!(typei.Type.Style(methEnv) is ValueTypeStyle))                              // Parameter types are not allowed                              throw new InvalidOperationException("type must be a value type");                          state.PeekBoxedType(0' typei.Type' changed);                          return state.PopPushType(1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(typei.Type)' HeapPT);                      case TypeOp.UnboxAny:                          {                              var s = typei.Type.Style(methEnv);                              if (s is ValueTypeStyle)                                  state.PeekBoxedType(0' typei.Type' changed);                              else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))                                  throw new InvalidOperationException("type must be value' reference or parameter type");                              return state.PopPushType(1' typei.Type' BottomPT);                          }                      case TypeOp.Ldtoken:                          return state.PushType(global.RuntimeTypeHandleRef' BottomPT);                      case TypeOp.Ldelem:                          state.PeekIndexType(0);                          state.PeekReadArrayType(1' typei.Type' false);                          return state.PopPushType(2' typei.Type' BottomPT);                      case TypeOp.Stelem:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekIndexType(1);                          state.PeekWriteArrayType(2' typei.Type);                          return state.Pop(3);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  {                      var ldelemai = (LdElemAddrInstruction)instruction;                      state.PeekIndexType(0);                      // WARNING: May prematurely fail for non-readonly loads                      state.PeekReadArrayType(1' ldelemai.Type' !ldelemai.IsReadonly);                      return state.PopPushType(2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(ldelemai.Type)' HeapPT);                  }              case InstructionFlavor.LdInt32:                  return state.PushType(global.Int32Ref' BottomPT);              case InstructionFlavor.LdInt64:                  return state.PushType(global.Int64Ref' BottomPT);              case InstructionFlavor.LdSingle:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdDouble:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdString:                  return state.PushType(global.StringRef' BottomPT);              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.Div:                      case ArithOp.Rem:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' true);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.Neg:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' true);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' false);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.BitNot:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.Shl:                      case ArithOp.Shr:                          state.PeekExpectedType(0' global.Int32Ref' changed);                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(1' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(2' arithi.Type' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned &&                                           convi.TargetNumberFlavor == NumberFlavor.Double);                      // NOTE: May capture skolemized types                      convi.SourceType = state.PeekNumberType(0' !mustBeInteger);                      return state.PopPushType(1' TypeRef.NumberFrom(methEnv.Global' convi.TargetNumberFlavor)' BottomPT);                  }              case InstructionFlavor.Try:                  {                      var tryi = (TryInstruction)instruction;                      // Isolation:                      //  - There is no way for the current stack shape to influence or be influenced by                      //    inference of the try' since the current stack shape must be empty.                      //  - There is no way for the try to influence the result stack shape' since it must be                      //    empty.                      //  - However pointers in arguments and locals may propogate into and out of try body                      //    via exceptional transitions. The latter are delt with separately.                      if (state.Depth != 0)                          throw new InvalidOperationException("stack should be empty");                      var newState = ForwardBlock                          (new TryBodyInstructionContext(context' index' tryi.Body)' state' changed);                      for (var j = 0; j < tryi.Handlers.Count; j++)                      {                          var h = tryi.Handlers[j];                          var handlerContext = new TryHandlerInstructionContext(context' index' h.Body' j);                          var initHandlerState = new MachineState                              (methEnv' method.ValueParameters.Count' method.Locals.Count);                          switch (h.Flavor)                          {                          case HandlerFlavor.Catch:                              {                                  var catchh = (CatchTryInstructionHandler)h;                                  ForwardBlock(handlerContext' initHandlerState.PushType(catchh.Type' BottomPT)' changed);                                  break;                              }                          case HandlerFlavor.Filter:                              throw new NotSupportedException("filter handler blocks");                          case HandlerFlavor.Fault:                          case HandlerFlavor.Finally:                              ForwardBlock(handlerContext' initHandlerState' changed);                              break;                          default:                              throw new ArgumentOutOfRangeException();                          }                      }                      return newState;                  }              case InstructionFlavor.IfThenElsePseudo:              case InstructionFlavor.ShortCircuitingPseudo:              case InstructionFlavor.StructuralSwitchPseudo:              case InstructionFlavor.LoopPseudo:              case InstructionFlavor.WhileDoPseudo:              case InstructionFlavor.DoWhilePseudo:              case InstructionFlavor.LoopControlPseudo:                  throw new InvalidOperationException("no machine state inference for psuedo-instructions");              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return state;                      case MiscOp.Dup:                          return state.Push(state.Peek(0));                      case MiscOp.Pop:                          return state.Pop(1);                      case MiscOp.Ldnull:                          return state.PushType(global.NullRef' BottomPT);                      case MiscOp.Ckfinite:                          state.PeekExpectedType(0' global.DoubleRef' changed);                          // Assume the instruction can "peek" at top of stack' thus no need for pop/push.                          return state;                      case MiscOp.Throw:                          state.PeekReferenceType(0);                          return state.DiscardStack();                      case MiscOp.Rethrow:                          return state.DiscardStack();                      case MiscOp.LdindRef:                          {                              var elemType = state.PeekPointerToReferenceType(0);                              return state.PopPushType(1' elemType' BottomPT);                          }                      case MiscOp.StindRef:                          {                              var expElemType = state.PeekPointerToReferenceType(1);                              state.PeekExpectedType(0' expElemType' changed);                              return state.Pop(2);                          }                      case MiscOp.LdelemRef:                          {                              state.PeekIndexType(0);                              // WARNING: Type may not be final                              var elemType = state.PeekArrayOfReferenceType(1);                              return state.PopPushType(2' elemType' BottomPT);                          }                      case MiscOp.StelemRef:                          state.PeekReferenceType(0);                          state.PeekIndexType(1);                          state.PeekArrayOfReferenceType(2);                          // Since the value type and array element type may be independently generalized'                          // it is pointless to check that the first is assignable to the second.                          // Instead this check is done at runtime.                          return state.Pop(3);                      case MiscOp.Ldlen:                          state.PeekArrayOfAnyType(0);                          return state.PopPushType(1' global.IntNativeRef' BottomPT);                      case MiscOp.Ret:                          {                              if (state.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return state; // empty                          }                      case MiscOp.RetVal:                          {                              state.PeekExpectedType(0' method.Result.Type' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfilter:                          {                              state.PeekExpectedType(0' global.Int32Ref' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfinally:                          {                              // Control could transfer to an outer finally/fault block' or to the target                              // of a leave instruction. However these transitions are delt with separately.                              return state.DiscardStack();                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:                  {                      var bri = (BranchInstruction)instruction;                      switch (bri.Op)                      {                      case BranchOp.Br:                          UnifyBeforeState(state' bri.Target' changed);                          return state;                      case BranchOp.Brtrue:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' false);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Brfalse:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Breq:                      case BranchOp.Brne:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' true);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Leave:                          {                              // Control could transfer via finally blocks instead of directly to the leave target.                              // Propogate only that the stack must be empty at target. Remaining machine state                              // is dealt with separately.                              UnifyBeforeState                                  (new MachineState(methEnv' method.ValueParameters.Count' method.Locals.Count)'                                   bri.Target'                                   changed);                              return state.DiscardStack();                          }                      case BranchOp.BrLt:                      case BranchOp.BrLe:                      case BranchOp.BrGt:                      case BranchOp.BrGe:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' false);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Switch:                  {                      var switchi = (SwitchInstruction)instruction;                      state.PeekExpectedType(0' global.Int32Ref' changed);                      var newState = state.Pop(1);                      for (var i = 0; i < switchi.CaseTargets.Count; i++)                          UnifyBeforeState(newState' switchi.CaseTargets[i]' changed);                      return newState;                  }              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      // WARNING: Capured type may not be final                      // NOTE: May capture skolemized types                      switch (cmpi.Op)                      {                      case CompareOp.Ceq:                      case CompareOp.CnePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' true);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.Clt:                      case CompareOp.Cgt:                      case CompareOp.CgePseudo:                      case CompareOp.ClePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' false);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.CtruePseudo:                      case CompareOp.CfalsePseudo:                          cmpi.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                          return state.PopPushType(1' global.Int32Ref' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var argi = (ArgLocalInstruction)instruction;                      var type = method.ArgLocalType(argi.ArgLocal' argi.Index);                      switch (argi.Op)                      {                      case ArgLocalOp.Ld:                          return state.PushType(type' state.ArgLocalPointsTo(argi.ArgLocal' argi.Index));                      case ArgLocalOp.Lda:                          return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(type)' ArgLocalPT(argi.ArgLocal' argi.Index));                      case ArgLocalOp.St:                          {                              state.PeekExpectedType(0' type' changed);                              var pointsTo = state.PeekPointsTo(0);                              if (!pointsTo.IsBottom)                              {                                  if (!(type.Style(methEnv) is ManagedPointerTypeStyle))                                      throw new InvalidOperationException                                          ("stack indicates pointer' but parameter or local type does not");                                  if (pointsTo.PointsOutsideOfHeap)                                      throw new InvalidOperationException("arguments cannot point outside of the heap");                              }                              return state.PopAddArgLocalPointsTo(1' argi.ArgLocal' argi.Index' pointsTo);                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      var fieldEnv = fieldi.Field.Enter(methEnv);                      var fieldType = fieldEnv.SubstituteType(fieldEnv.Field.FieldType);                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                              return state.PushType(fieldType' BottomPT);                          else                          {                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' true' changed);                              return state.PopPushType(1' fieldType' BottomPT);                          }                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                              return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          else                          {                              // Underlying type cannot be a struct' otherwise would have a pointer into                              // the stack                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' false' changed);                              return state.PopPushType                                  (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          }                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                          {                              state.PeekExpectedType(0' fieldType' changed);                              return state.Pop(1);                          }                          else                          {                              state.PeekExpectedType(0' fieldType' changed);                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (1' fieldi.Field.DefiningType' false' changed);                              return state.Pop(2);                          }                      case FieldOp.Ldtoken:                          return state.PushType(global.RuntimeFieldHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methi = (MethodInstruction)instruction;                      var sig = (CST.MethodSignature)methi.Method.ExternalSignature;                      switch (methi.Op)                      {                      case MethodOp.Call:                          {                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              if (methi.Constrained != null)                              {                                  if (!methi.IsVirtual || methi.Method.IsStatic)                                      throw new InvalidOperationException                                          ("constrained only valid on virtual calls to instance methods");                                  var thisType = sig.Parameters[0];                                  var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(methi.Constrained);                                  var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo(methi.Constrained);                                  var cs = methi.Constrained.Style(methEnv);                                  if (cs is ValueTypeStyle)                                  {                                      if (thisType.Style(methEnv) is ManagedPointerTypeStyle)                                      {                                          // We pass the argument pointer as is                                          if (!methi.Constrained.IsAssignableTo(methEnv' thisType.Arguments[0]))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                      else                                      {                                          // *Case 1* Morally we deref the argument pointer and box the contents'                                          // but since no supertype of a value type may mutate the underlying value'                                          // we don't need to take a copy of the value when boxing' so in practice                                          // this is a no-op                                          if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                  }                                  else if (cs is ReferenceTypeStyle)                                  {                                      // *Case 2* We dereference the pointer and pass the object reference                                      if (!methi.Constrained.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else if (cs is ParameterTypeStyle)                                  {                                      // Since we are calling an instance method' we know the first argument cannot be                                      // a "naked" type parameter' but is either a class or an interface.                                      // We must decide between cases 1 and 2 above at runtime' but checking as                                      // per case 1 is sufficient now.                                      // NOTE: As for box/classcast/isinst below' if the parameter is                                      // instantiated to a reference type then the type box type is considered                                      // equivalent to the underyling reference type.                                      if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else                                      throw new InvalidOperationException                                          ("constrained must be value' reference or parameter type");                                    state.PeekExpectedType(sig.Parameters.Count - 1' constrainedPtr' changed);                              }                              else if (sig.Parameters.Count > 0)                                  state.PeekExpectedType(sig.Parameters.Count - 1' sig.Parameters[0]' changed);                              if (sig.Result == null)                                  return state.Pop(sig.Parameters.Count);                              else                                  return state.PopPushType(sig.Parameters.Count' sig.Result' BottomPT);                          }                      case MethodOp.Ldftn:                          {                              // NOTE: Verified CLR allows only the two "blessed" sequences:                              //   dup; ldvirtftn; newobj <delegate ctor>                              //   ldftn; newobj <delegate ctor>                              // It is thus possible to check the delegate will capture an instance which                              // implements the loaded method. However' we don't check that here.                              if (methi.IsVirtual)                              {                                  if (methi.Method.IsStatic)                                      throw new InvalidOperationException("cannot ldvirtftn of a static method");                                  var objectType = default(TypeRef);                                  if (sig.Parameters[0].Style(methEnv) is ManagedPointerTypeStyle)                                      // Object should be a box                                      objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(sig.Parameters[0].Arguments[0]);                                  else                                      // Object should match parameter                                      objectType = sig.Parameters[0];                                  state.PeekExpectedType(0' objectType' changed);                                  return state.PopPushType(1' sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                              else                              {                                  if (methi.Method.IsStatic)                                      return state.PushType(sig.ToCodePointer(methEnv.Global)' BottomPT);                                  else                                      return state.PushType(sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                          }                      case MethodOp.Newobj:                          {                              if (methi.Method.IsStatic || sig.Result != null)                                  throw new InvalidOperationException("not a constructor");                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              // First argument to constructor is created by runtime. If definining type is                              // a value type' first argument will be a pointer' but result left on stack                              // will be the value itself.                              return state.PopPushType(sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);                          }                      case MethodOp.Ldtoken:                          return state.PushType(global.RuntimeMethodHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          state.PeekReadPointerType(0' typei.Type);                          return state.PopPushType(1' typei.Type' BottomPT);                      case TypeOp.Stobj:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Cpobj:                          state.PeekReadPointerType(0' typei.Type);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Newarr:                          state.PeekIndexType(0);                          return state.PopPushType(1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo(typei.Type)' BottomPT);                      case TypeOp.Initobj:                          state.PeekWritePointerType(0' typei.Type);                          return state.Pop(1);                      case TypeOp.Castclass:                      case TypeOp.Isinst:                      case TypeOp.Box:                          {                              var resultType = default(TypeRef);                              var s = typei.Type.Style(methEnv);                              if (s is NullableTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type.Arguments[0]);                              else if (s is ValueTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else if (s is ReferenceTypeStyle)                                  resultType = typei.Type;                              else if (s is ParameterTypeStyle)                                  // NOTE: As for constrained call above' if type parameter is instantitated to                                  // a ref type' then this box type is considered equivalent to the                                  // underlying reference type.                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else                                  throw new InvalidOperationException                                      ("can only box/cast to reference' value or parameter type");                              if (typei.Op == TypeOp.Box)                                  state.PeekExpectedType(0' typei.Type' changed);                              else                                  state.PeekReferenceType(0);                              return state.PopPushType(1' resultType' BottomPT);                          }                      case TypeOp.Unbox:                          if (!(typei.Type.Style(methEnv) is ValueTypeStyle))                              // Parameter types are not allowed                              throw new InvalidOperationException("type must be a value type");                          state.PeekBoxedType(0' typei.Type' changed);                          return state.PopPushType(1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(typei.Type)' HeapPT);                      case TypeOp.UnboxAny:                          {                              var s = typei.Type.Style(methEnv);                              if (s is ValueTypeStyle)                                  state.PeekBoxedType(0' typei.Type' changed);                              else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))                                  throw new InvalidOperationException("type must be value' reference or parameter type");                              return state.PopPushType(1' typei.Type' BottomPT);                          }                      case TypeOp.Ldtoken:                          return state.PushType(global.RuntimeTypeHandleRef' BottomPT);                      case TypeOp.Ldelem:                          state.PeekIndexType(0);                          state.PeekReadArrayType(1' typei.Type' false);                          return state.PopPushType(2' typei.Type' BottomPT);                      case TypeOp.Stelem:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekIndexType(1);                          state.PeekWriteArrayType(2' typei.Type);                          return state.Pop(3);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  {                      var ldelemai = (LdElemAddrInstruction)instruction;                      state.PeekIndexType(0);                      // WARNING: May prematurely fail for non-readonly loads                      state.PeekReadArrayType(1' ldelemai.Type' !ldelemai.IsReadonly);                      return state.PopPushType(2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(ldelemai.Type)' HeapPT);                  }              case InstructionFlavor.LdInt32:                  return state.PushType(global.Int32Ref' BottomPT);              case InstructionFlavor.LdInt64:                  return state.PushType(global.Int64Ref' BottomPT);              case InstructionFlavor.LdSingle:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdDouble:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdString:                  return state.PushType(global.StringRef' BottomPT);              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.Div:                      case ArithOp.Rem:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' true);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.Neg:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' true);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' false);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.BitNot:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.Shl:                      case ArithOp.Shr:                          state.PeekExpectedType(0' global.Int32Ref' changed);                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(1' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(2' arithi.Type' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned &&                                           convi.TargetNumberFlavor == NumberFlavor.Double);                      // NOTE: May capture skolemized types                      convi.SourceType = state.PeekNumberType(0' !mustBeInteger);                      return state.PopPushType(1' TypeRef.NumberFrom(methEnv.Global' convi.TargetNumberFlavor)' BottomPT);                  }              case InstructionFlavor.Try:                  {                      var tryi = (TryInstruction)instruction;                      // Isolation:                      //  - There is no way for the current stack shape to influence or be influenced by                      //    inference of the try' since the current stack shape must be empty.                      //  - There is no way for the try to influence the result stack shape' since it must be                      //    empty.                      //  - However pointers in arguments and locals may propogate into and out of try body                      //    via exceptional transitions. The latter are delt with separately.                      if (state.Depth != 0)                          throw new InvalidOperationException("stack should be empty");                      var newState = ForwardBlock                          (new TryBodyInstructionContext(context' index' tryi.Body)' state' changed);                      for (var j = 0; j < tryi.Handlers.Count; j++)                      {                          var h = tryi.Handlers[j];                          var handlerContext = new TryHandlerInstructionContext(context' index' h.Body' j);                          var initHandlerState = new MachineState                              (methEnv' method.ValueParameters.Count' method.Locals.Count);                          switch (h.Flavor)                          {                          case HandlerFlavor.Catch:                              {                                  var catchh = (CatchTryInstructionHandler)h;                                  ForwardBlock(handlerContext' initHandlerState.PushType(catchh.Type' BottomPT)' changed);                                  break;                              }                          case HandlerFlavor.Filter:                              throw new NotSupportedException("filter handler blocks");                          case HandlerFlavor.Fault:                          case HandlerFlavor.Finally:                              ForwardBlock(handlerContext' initHandlerState' changed);                              break;                          default:                              throw new ArgumentOutOfRangeException();                          }                      }                      return newState;                  }              case InstructionFlavor.IfThenElsePseudo:              case InstructionFlavor.ShortCircuitingPseudo:              case InstructionFlavor.StructuralSwitchPseudo:              case InstructionFlavor.LoopPseudo:              case InstructionFlavor.WhileDoPseudo:              case InstructionFlavor.DoWhilePseudo:              case InstructionFlavor.LoopControlPseudo:                  throw new InvalidOperationException("no machine state inference for psuedo-instructions");              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,MachineStateInference,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,ForwardInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return state;                      case MiscOp.Dup:                          return state.Push(state.Peek(0));                      case MiscOp.Pop:                          return state.Pop(1);                      case MiscOp.Ldnull:                          return state.PushType(global.NullRef' BottomPT);                      case MiscOp.Ckfinite:                          state.PeekExpectedType(0' global.DoubleRef' changed);                          // Assume the instruction can "peek" at top of stack' thus no need for pop/push.                          return state;                      case MiscOp.Throw:                          state.PeekReferenceType(0);                          return state.DiscardStack();                      case MiscOp.Rethrow:                          return state.DiscardStack();                      case MiscOp.LdindRef:                          {                              var elemType = state.PeekPointerToReferenceType(0);                              return state.PopPushType(1' elemType' BottomPT);                          }                      case MiscOp.StindRef:                          {                              var expElemType = state.PeekPointerToReferenceType(1);                              state.PeekExpectedType(0' expElemType' changed);                              return state.Pop(2);                          }                      case MiscOp.LdelemRef:                          {                              state.PeekIndexType(0);                              // WARNING: Type may not be final                              var elemType = state.PeekArrayOfReferenceType(1);                              return state.PopPushType(2' elemType' BottomPT);                          }                      case MiscOp.StelemRef:                          state.PeekReferenceType(0);                          state.PeekIndexType(1);                          state.PeekArrayOfReferenceType(2);                          // Since the value type and array element type may be independently generalized'                          // it is pointless to check that the first is assignable to the second.                          // Instead this check is done at runtime.                          return state.Pop(3);                      case MiscOp.Ldlen:                          state.PeekArrayOfAnyType(0);                          return state.PopPushType(1' global.IntNativeRef' BottomPT);                      case MiscOp.Ret:                          {                              if (state.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return state; // empty                          }                      case MiscOp.RetVal:                          {                              state.PeekExpectedType(0' method.Result.Type' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfilter:                          {                              state.PeekExpectedType(0' global.Int32Ref' changed);                              var newState = state.Pop(1);                              if (newState.Depth != 0)                                  throw new InvalidOperationException("stack should be empty");                              return newState; // empty                          }                      case MiscOp.Endfinally:                          {                              // Control could transfer to an outer finally/fault block' or to the target                              // of a leave instruction. However these transitions are delt with separately.                              return state.DiscardStack();                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:                  {                      var bri = (BranchInstruction)instruction;                      switch (bri.Op)                      {                      case BranchOp.Br:                          UnifyBeforeState(state' bri.Target' changed);                          return state;                      case BranchOp.Brtrue:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' false);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Brfalse:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                              var newState = state.Pop(1);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Breq:                      case BranchOp.Brne:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' true);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      case BranchOp.Leave:                          {                              // Control could transfer via finally blocks instead of directly to the leave target.                              // Propogate only that the stack must be empty at target. Remaining machine state                              // is dealt with separately.                              UnifyBeforeState                                  (new MachineState(methEnv' method.ValueParameters.Count' method.Locals.Count)'                                   bri.Target'                                   changed);                              return state.DiscardStack();                          }                      case BranchOp.BrLt:                      case BranchOp.BrLe:                      case BranchOp.BrGt:                      case BranchOp.BrGe:                          {                              // WARNING: Type may not be final                              // NOTE: May capture skolemized types                              bri.Type = state.Peek2ComparableTypes(0' false);                              var newState = state.Pop(2);                              UnifyBeforeState(newState' bri.Target' changed);                              return newState;                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Switch:                  {                      var switchi = (SwitchInstruction)instruction;                      state.PeekExpectedType(0' global.Int32Ref' changed);                      var newState = state.Pop(1);                      for (var i = 0; i < switchi.CaseTargets.Count; i++)                          UnifyBeforeState(newState' switchi.CaseTargets[i]' changed);                      return newState;                  }              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      // WARNING: Capured type may not be final                      // NOTE: May capture skolemized types                      switch (cmpi.Op)                      {                      case CompareOp.Ceq:                      case CompareOp.CnePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' true);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.Clt:                      case CompareOp.Cgt:                      case CompareOp.CgePseudo:                      case CompareOp.ClePseudo:                          cmpi.Type = state.Peek2ComparableTypes(0' false);                          return state.PopPushType(2' global.Int32Ref' BottomPT);                      case CompareOp.CtruePseudo:                      case CompareOp.CfalsePseudo:                          cmpi.Type = state.PeekIntegerOrObjectOrPointerType(0' true);                          return state.PopPushType(1' global.Int32Ref' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var argi = (ArgLocalInstruction)instruction;                      var type = method.ArgLocalType(argi.ArgLocal' argi.Index);                      switch (argi.Op)                      {                      case ArgLocalOp.Ld:                          return state.PushType(type' state.ArgLocalPointsTo(argi.ArgLocal' argi.Index));                      case ArgLocalOp.Lda:                          return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(type)' ArgLocalPT(argi.ArgLocal' argi.Index));                      case ArgLocalOp.St:                          {                              state.PeekExpectedType(0' type' changed);                              var pointsTo = state.PeekPointsTo(0);                              if (!pointsTo.IsBottom)                              {                                  if (!(type.Style(methEnv) is ManagedPointerTypeStyle))                                      throw new InvalidOperationException                                          ("stack indicates pointer' but parameter or local type does not");                                  if (pointsTo.PointsOutsideOfHeap)                                      throw new InvalidOperationException("arguments cannot point outside of the heap");                              }                              return state.PopAddArgLocalPointsTo(1' argi.ArgLocal' argi.Index' pointsTo);                          }                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      var fieldEnv = fieldi.Field.Enter(methEnv);                      var fieldType = fieldEnv.SubstituteType(fieldEnv.Field.FieldType);                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                              return state.PushType(fieldType' BottomPT);                          else                          {                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' true' changed);                              return state.PopPushType(1' fieldType' BottomPT);                          }                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                              return state.PushType(methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          else                          {                              // Underlying type cannot be a struct' otherwise would have a pointer into                              // the stack                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (0' fieldi.Field.DefiningType' false' changed);                              return state.PopPushType                                  (1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(fieldType)' HeapPT);                          }                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                          {                              state.PeekExpectedType(0' fieldType' changed);                              return state.Pop(1);                          }                          else                          {                              state.PeekExpectedType(0' fieldType' changed);                              fieldi.IsViaPointer = state.PeekDereferencableExpectedType                                  (1' fieldi.Field.DefiningType' false' changed);                              return state.Pop(2);                          }                      case FieldOp.Ldtoken:                          return state.PushType(global.RuntimeFieldHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methi = (MethodInstruction)instruction;                      var sig = (CST.MethodSignature)methi.Method.ExternalSignature;                      switch (methi.Op)                      {                      case MethodOp.Call:                          {                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              if (methi.Constrained != null)                              {                                  if (!methi.IsVirtual || methi.Method.IsStatic)                                      throw new InvalidOperationException                                          ("constrained only valid on virtual calls to instance methods");                                  var thisType = sig.Parameters[0];                                  var constrainedPtr = methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(methi.Constrained);                                  var constrainedBox = methEnv.Global.BoxTypeConstructorRef.ApplyTo(methi.Constrained);                                  var cs = methi.Constrained.Style(methEnv);                                  if (cs is ValueTypeStyle)                                  {                                      if (thisType.Style(methEnv) is ManagedPointerTypeStyle)                                      {                                          // We pass the argument pointer as is                                          if (!methi.Constrained.IsAssignableTo(methEnv' thisType.Arguments[0]))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                      else                                      {                                          // *Case 1* Morally we deref the argument pointer and box the contents'                                          // but since no supertype of a value type may mutate the underlying value'                                          // we don't need to take a copy of the value when boxing' so in practice                                          // this is a no-op                                          if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                              throw new InvalidOperationException                                                  ("constrained type is not assignable to method's first argument type");                                      }                                  }                                  else if (cs is ReferenceTypeStyle)                                  {                                      // *Case 2* We dereference the pointer and pass the object reference                                      if (!methi.Constrained.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else if (cs is ParameterTypeStyle)                                  {                                      // Since we are calling an instance method' we know the first argument cannot be                                      // a "naked" type parameter' but is either a class or an interface.                                      // We must decide between cases 1 and 2 above at runtime' but checking as                                      // per case 1 is sufficient now.                                      // NOTE: As for box/classcast/isinst below' if the parameter is                                      // instantiated to a reference type then the type box type is considered                                      // equivalent to the underyling reference type.                                      if (!constrainedBox.IsAssignableTo(methEnv' thisType))                                          throw new InvalidOperationException                                              ("constrained type is not assignable to method's first argument type");                                  }                                  else                                      throw new InvalidOperationException                                          ("constrained must be value' reference or parameter type");                                    state.PeekExpectedType(sig.Parameters.Count - 1' constrainedPtr' changed);                              }                              else if (sig.Parameters.Count > 0)                                  state.PeekExpectedType(sig.Parameters.Count - 1' sig.Parameters[0]' changed);                              if (sig.Result == null)                                  return state.Pop(sig.Parameters.Count);                              else                                  return state.PopPushType(sig.Parameters.Count' sig.Result' BottomPT);                          }                      case MethodOp.Ldftn:                          {                              // NOTE: Verified CLR allows only the two "blessed" sequences:                              //   dup; ldvirtftn; newobj <delegate ctor>                              //   ldftn; newobj <delegate ctor>                              // It is thus possible to check the delegate will capture an instance which                              // implements the loaded method. However' we don't check that here.                              if (methi.IsVirtual)                              {                                  if (methi.Method.IsStatic)                                      throw new InvalidOperationException("cannot ldvirtftn of a static method");                                  var objectType = default(TypeRef);                                  if (sig.Parameters[0].Style(methEnv) is ManagedPointerTypeStyle)                                      // Object should be a box                                      objectType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(sig.Parameters[0].Arguments[0]);                                  else                                      // Object should match parameter                                      objectType = sig.Parameters[0];                                  state.PeekExpectedType(0' objectType' changed);                                  return state.PopPushType(1' sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                              else                              {                                  if (methi.Method.IsStatic)                                      return state.PushType(sig.ToCodePointer(methEnv.Global)' BottomPT);                                  else                                      return state.PushType(sig.WithoutThis().ToCodePointer(methEnv.Global)' BottomPT);                              }                          }                      case MethodOp.Newobj:                          {                              if (methi.Method.IsStatic || sig.Result != null)                                  throw new InvalidOperationException("not a constructor");                              for (var i = sig.Parameters.Count - 1; i >= 1; i--)                                  state.PeekExpectedType(sig.Parameters.Count - 1 - i' sig.Parameters[i]' changed);                              // First argument to constructor is created by runtime. If definining type is                              // a value type' first argument will be a pointer' but result left on stack                              // will be the value itself.                              return state.PopPushType(sig.Parameters.Count - 1' methi.Method.DefiningType' BottomPT);                          }                      case MethodOp.Ldtoken:                          return state.PushType(global.RuntimeMethodHandleRef' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          state.PeekReadPointerType(0' typei.Type);                          return state.PopPushType(1' typei.Type' BottomPT);                      case TypeOp.Stobj:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Cpobj:                          state.PeekReadPointerType(0' typei.Type);                          state.PeekWritePointerType(1' typei.Type);                          return state.Pop(2);                      case TypeOp.Newarr:                          state.PeekIndexType(0);                          return state.PopPushType(1' methEnv.Global.ArrayTypeConstructorRef.ApplyTo(typei.Type)' BottomPT);                      case TypeOp.Initobj:                          state.PeekWritePointerType(0' typei.Type);                          return state.Pop(1);                      case TypeOp.Castclass:                      case TypeOp.Isinst:                      case TypeOp.Box:                          {                              var resultType = default(TypeRef);                              var s = typei.Type.Style(methEnv);                              if (s is NullableTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type.Arguments[0]);                              else if (s is ValueTypeStyle)                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else if (s is ReferenceTypeStyle)                                  resultType = typei.Type;                              else if (s is ParameterTypeStyle)                                  // NOTE: As for constrained call above' if type parameter is instantitated to                                  // a ref type' then this box type is considered equivalent to the                                  // underlying reference type.                                  resultType = methEnv.Global.BoxTypeConstructorRef.ApplyTo(typei.Type);                              else                                  throw new InvalidOperationException                                      ("can only box/cast to reference' value or parameter type");                              if (typei.Op == TypeOp.Box)                                  state.PeekExpectedType(0' typei.Type' changed);                              else                                  state.PeekReferenceType(0);                              return state.PopPushType(1' resultType' BottomPT);                          }                      case TypeOp.Unbox:                          if (!(typei.Type.Style(methEnv) is ValueTypeStyle))                              // Parameter types are not allowed                              throw new InvalidOperationException("type must be a value type");                          state.PeekBoxedType(0' typei.Type' changed);                          return state.PopPushType(1' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(typei.Type)' HeapPT);                      case TypeOp.UnboxAny:                          {                              var s = typei.Type.Style(methEnv);                              if (s is ValueTypeStyle)                                  state.PeekBoxedType(0' typei.Type' changed);                              else if (!(s is ReferenceTypeStyle) && !(s is ParameterTypeStyle))                                  throw new InvalidOperationException("type must be value' reference or parameter type");                              return state.PopPushType(1' typei.Type' BottomPT);                          }                      case TypeOp.Ldtoken:                          return state.PushType(global.RuntimeTypeHandleRef' BottomPT);                      case TypeOp.Ldelem:                          state.PeekIndexType(0);                          state.PeekReadArrayType(1' typei.Type' false);                          return state.PopPushType(2' typei.Type' BottomPT);                      case TypeOp.Stelem:                          state.PeekExpectedType(0' typei.Type' changed);                          state.PeekIndexType(1);                          state.PeekWriteArrayType(2' typei.Type);                          return state.Pop(3);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  {                      var ldelemai = (LdElemAddrInstruction)instruction;                      state.PeekIndexType(0);                      // WARNING: May prematurely fail for non-readonly loads                      state.PeekReadArrayType(1' ldelemai.Type' !ldelemai.IsReadonly);                      return state.PopPushType(2' methEnv.Global.ManagedPointerTypeConstructorRef.ApplyTo(ldelemai.Type)' HeapPT);                  }              case InstructionFlavor.LdInt32:                  return state.PushType(global.Int32Ref' BottomPT);              case InstructionFlavor.LdInt64:                  return state.PushType(global.Int64Ref' BottomPT);              case InstructionFlavor.LdSingle:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdDouble:                  return state.PushType(global.DoubleRef' BottomPT);              case InstructionFlavor.LdString:                  return state.PushType(global.StringRef' BottomPT);              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.Div:                      case ArithOp.Rem:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' true);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.Neg:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' true);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                          // NOTE: May capture skolemized types                          arithi.Type = state.Peek2NumberTypes(0' false);                          return state.PopPushType(2' arithi.Type' BottomPT);                      case ArithOp.BitNot:                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(0' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(1' arithi.Type' BottomPT);                      case ArithOp.Shl:                      case ArithOp.Shr:                          state.PeekExpectedType(0' global.Int32Ref' changed);                          // NOTE: May capture skolemized types                          arithi.Type = state.PeekNumberType(1' false);                          // Changing underlying value' so pop/push explicitly                          return state.PopPushType(2' arithi.Type' BottomPT);                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      var mustBeInteger = (!convi.WithOverflow && convi.IsSourceUnsigned &&                                           convi.TargetNumberFlavor == NumberFlavor.Double);                      // NOTE: May capture skolemized types                      convi.SourceType = state.PeekNumberType(0' !mustBeInteger);                      return state.PopPushType(1' TypeRef.NumberFrom(methEnv.Global' convi.TargetNumberFlavor)' BottomPT);                  }              case InstructionFlavor.Try:                  {                      var tryi = (TryInstruction)instruction;                      // Isolation:                      //  - There is no way for the current stack shape to influence or be influenced by                      //    inference of the try' since the current stack shape must be empty.                      //  - There is no way for the try to influence the result stack shape' since it must be                      //    empty.                      //  - However pointers in arguments and locals may propogate into and out of try body                      //    via exceptional transitions. The latter are delt with separately.                      if (state.Depth != 0)                          throw new InvalidOperationException("stack should be empty");                      var newState = ForwardBlock                          (new TryBodyInstructionContext(context' index' tryi.Body)' state' changed);                      for (var j = 0; j < tryi.Handlers.Count; j++)                      {                          var h = tryi.Handlers[j];                          var handlerContext = new TryHandlerInstructionContext(context' index' h.Body' j);                          var initHandlerState = new MachineState                              (methEnv' method.ValueParameters.Count' method.Locals.Count);                          switch (h.Flavor)                          {                          case HandlerFlavor.Catch:                              {                                  var catchh = (CatchTryInstructionHandler)h;                                  ForwardBlock(handlerContext' initHandlerState.PushType(catchh.Type' BottomPT)' changed);                                  break;                              }                          case HandlerFlavor.Filter:                              throw new NotSupportedException("filter handler blocks");                          case HandlerFlavor.Fault:                          case HandlerFlavor.Finally:                              ForwardBlock(handlerContext' initHandlerState' changed);                              break;                          default:                              throw new ArgumentOutOfRangeException();                          }                      }                      return newState;                  }              case InstructionFlavor.IfThenElsePseudo:              case InstructionFlavor.ShortCircuitingPseudo:              case InstructionFlavor.StructuralSwitchPseudo:              case InstructionFlavor.LoopPseudo:              case InstructionFlavor.WhileDoPseudo:              case InstructionFlavor.DoWhilePseudo:              case InstructionFlavor.LoopControlPseudo:                  throw new InvalidOperationException("no machine state inference for psuedo-instructions");              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,SourceTarget,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,GetHashCode,The following statement contains a magic number: return (int)((x << 7) | (x >> 25) ^ y);
Magic Number,Microsoft.LiveLabs.CST,SourceTarget,C:\repos\Reactive-Extensions_IL2JS\CST\MachineStateInference.cs,GetHashCode,The following statement contains a magic number: return (int)((x << 7) | (x >> 25) ^ y);
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,AssemblyName,The following statement contains a magic number: if (resolution == AssemblyNameResolution.Full)              {                  if (publicKeyToken != null && publicKeyToken.Length != 0)                  {                      if (publicKeyToken.Length > 8)                      {                          var sha1 = new System.Security.Cryptography.SHA1CryptoServiceProvider();                          var hash = sha1.ComputeHash(publicKeyToken);                          publicKeyToken = new byte[8];                          for (var i = 0; i < 8; i++)                              publicKeyToken[i] = hash[hash.Length - 1 - i];                      }                      PublicKeyToken = publicKeyToken;                  }              }
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,AssemblyName,The following statement contains a magic number: if (resolution == AssemblyNameResolution.Full)              {                  if (publicKeyToken != null && publicKeyToken.Length != 0)                  {                      if (publicKeyToken.Length > 8)                      {                          var sha1 = new System.Security.Cryptography.SHA1CryptoServiceProvider();                          var hash = sha1.ComputeHash(publicKeyToken);                          publicKeyToken = new byte[8];                          for (var i = 0; i < 8; i++)                              publicKeyToken[i] = hash[hash.Length - 1 - i];                      }                      PublicKeyToken = publicKeyToken;                  }              }
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,AssemblyName,The following statement contains a magic number: if (resolution == AssemblyNameResolution.Full)              {                  if (publicKeyToken != null && publicKeyToken.Length != 0)                  {                      if (publicKeyToken.Length > 8)                      {                          var sha1 = new System.Security.Cryptography.SHA1CryptoServiceProvider();                          var hash = sha1.ComputeHash(publicKeyToken);                          publicKeyToken = new byte[8];                          for (var i = 0; i < 8; i++)                              publicKeyToken[i] = hash[hash.Length - 1 - i];                      }                      PublicKeyToken = publicKeyToken;                  }              }
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,Append,The following statement contains a magic number: if (w.Global.AssemblyNameResolution == AssemblyNameResolution.Full)              {                  w.Append("' PublicKeyToken=");                  if (PublicKeyToken == null)                      w.Append(defaultPublicKeyToken);                  else                  {                      for (var i = 0; i < PublicKeyToken.Length; i++)                      {                          var v = PublicKeyToken[i];                          for (var j = 0; j < 2; j++)                          {                              var d = v >> 4;                              w.Append(d < 10 ? '0' + d : 'a' + (d - 10));                              v <<= 4;                          }                      }                  }              }
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,Append,The following statement contains a magic number: if (w.Global.AssemblyNameResolution == AssemblyNameResolution.Full)              {                  w.Append("' PublicKeyToken=");                  if (PublicKeyToken == null)                      w.Append(defaultPublicKeyToken);                  else                  {                      for (var i = 0; i < PublicKeyToken.Length; i++)                      {                          var v = PublicKeyToken[i];                          for (var j = 0; j < 2; j++)                          {                              var d = v >> 4;                              w.Append(d < 10 ? '0' + d : 'a' + (d - 10));                              v <<= 4;                          }                      }                  }              }
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,Append,The following statement contains a magic number: if (w.Global.AssemblyNameResolution == AssemblyNameResolution.Full)              {                  w.Append("' PublicKeyToken=");                  if (PublicKeyToken == null)                      w.Append(defaultPublicKeyToken);                  else                  {                      for (var i = 0; i < PublicKeyToken.Length; i++)                      {                          var v = PublicKeyToken[i];                          for (var j = 0; j < 2; j++)                          {                              var d = v >> 4;                              w.Append(d < 10 ? '0' + d : 'a' + (d - 10));                              v <<= 4;                          }                      }                  }              }
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,Append,The following statement contains a magic number: if (w.Global.AssemblyNameResolution == AssemblyNameResolution.Full)              {                  w.Append("' PublicKeyToken=");                  if (PublicKeyToken == null)                      w.Append(defaultPublicKeyToken);                  else                  {                      for (var i = 0; i < PublicKeyToken.Length; i++)                      {                          var v = PublicKeyToken[i];                          for (var j = 0; j < 2; j++)                          {                              var d = v >> 4;                              w.Append(d < 10 ? '0' + d : 'a' + (d - 10));                              v <<= 4;                          }                      }                  }              }
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,Append,The following statement contains a magic number: if (w.Global.AssemblyNameResolution == AssemblyNameResolution.Full)              {                  w.Append("' PublicKeyToken=");                  if (PublicKeyToken == null)                      w.Append(defaultPublicKeyToken);                  else                  {                      for (var i = 0; i < PublicKeyToken.Length; i++)                      {                          var v = PublicKeyToken[i];                          for (var j = 0; j < 2; j++)                          {                              var d = v >> 4;                              w.Append(d < 10 ? '0' + d : 'a' + (d - 10));                              v <<= 4;                          }                      }                  }              }
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,GetNum,The following statement contains a magic number: while (i < str.Length && str[i] >= '0' && str[i] <= '9')              {                  v = v * 10 + (str[i++] - '0');                  any = true;              }
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,GetByte,The following statement contains a magic number: while (i < str.Length && n < 2)              {                  if (str[i] >= '0' && str[i] <= '9')                      v = v * 16 + (str[i] - '0');                  else if (str[i] >= 'a' && str[i] <= 'f')                      v = v * 16 + 10 + (str[i] - 'a');                  else if (str[i] >= 'A' && str[i] <= 'F')                      v = v * 16 + 10 + (str[i] - 'a');                  else                      return -1;                  n++;                  i++;              }
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,GetByte,The following statement contains a magic number: while (i < str.Length && n < 2)              {                  if (str[i] >= '0' && str[i] <= '9')                      v = v * 16 + (str[i] - '0');                  else if (str[i] >= 'a' && str[i] <= 'f')                      v = v * 16 + 10 + (str[i] - 'a');                  else if (str[i] >= 'A' && str[i] <= 'F')                      v = v * 16 + 10 + (str[i] - 'a');                  else                      return -1;                  n++;                  i++;              }
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,GetByte,The following statement contains a magic number: while (i < str.Length && n < 2)              {                  if (str[i] >= '0' && str[i] <= '9')                      v = v * 16 + (str[i] - '0');                  else if (str[i] >= 'a' && str[i] <= 'f')                      v = v * 16 + 10 + (str[i] - 'a');                  else if (str[i] >= 'A' && str[i] <= 'F')                      v = v * 16 + 10 + (str[i] - 'a');                  else                      return -1;                  n++;                  i++;              }
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,GetByte,The following statement contains a magic number: while (i < str.Length && n < 2)              {                  if (str[i] >= '0' && str[i] <= '9')                      v = v * 16 + (str[i] - '0');                  else if (str[i] >= 'a' && str[i] <= 'f')                      v = v * 16 + 10 + (str[i] - 'a');                  else if (str[i] >= 'A' && str[i] <= 'F')                      v = v * 16 + 10 + (str[i] - 'a');                  else                      return -1;                  n++;                  i++;              }
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,GetByte,The following statement contains a magic number: while (i < str.Length && n < 2)              {                  if (str[i] >= '0' && str[i] <= '9')                      v = v * 16 + (str[i] - '0');                  else if (str[i] >= 'a' && str[i] <= 'f')                      v = v * 16 + 10 + (str[i] - 'a');                  else if (str[i] >= 'A' && str[i] <= 'F')                      v = v * 16 + 10 + (str[i] - 'a');                  else                      return -1;                  n++;                  i++;              }
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,GetByte,The following statement contains a magic number: while (i < str.Length && n < 2)              {                  if (str[i] >= '0' && str[i] <= '9')                      v = v * 16 + (str[i] - '0');                  else if (str[i] >= 'a' && str[i] <= 'f')                      v = v * 16 + 10 + (str[i] - 'a');                  else if (str[i] >= 'A' && str[i] <= 'F')                      v = v * 16 + 10 + (str[i] - 'a');                  else                      return -1;                  n++;                  i++;              }
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,GetByte,The following statement contains a magic number: return n == 2 ? v : -1;
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,FromReflectionName,The following statement contains a magic number: if (i < 0)                  name = strongName;              else              {                  name = strongName.Substring(0' i);                  i++;                  SkipWS(strongName' ref i);                  while (i < strongName.Length)                  {                      var kwd = GetKeyword(strongName' ref i);                      if (string.Equals(kwd' versionKeyword' StringComparison.OrdinalIgnoreCase))                      {                          var version = GetValue(strongName' ref i);                          if (version == null)                              return null;                          var j = 0;                          majorVersion = GetNum(version' ref j);                          if (majorVersion < 0)                              return null;                          if (!SkipDot(version' ref j))                              return null;                          minorVersion = GetNum(version' ref j);                          if (minorVersion < 0)                              return null;                          if (!SkipDot(version' ref j))                              return null;                          buildNumber = GetNum(version' ref j);                          if (buildNumber < 0)                              return null;                          if (!SkipDot(version' ref j))                              return null;                          revisionNumber = GetNum(version' ref j);                          if (revisionNumber < 0)                              return null;                      }                      else if (string.Equals(kwd' cultureKeyword' StringComparison.OrdinalIgnoreCase))                      {                          culture = GetValue(strongName' ref i);                          if (culture == null)                              return null;                      }                      else if (string.Equals(kwd' publicKeyTokenKeyword' StringComparison.OrdinalIgnoreCase))                      {                          var hex = GetValue(strongName' ref i);                          if (hex == null)                              return null;                          if (!hex.Equals(defaultPublicKeyToken' StringComparison.OrdinalIgnoreCase))                          {                              if (hex.Length%2 != 0)                                  return null;                              var j = 0;                              publicKeyToken = new byte[hex.Length/2];                              for (var k = 0; k < publicKeyToken.Length; k++)                              {                                  var v = GetByte(hex' ref j);                                  if (v < 0)                                      return null;                                  publicKeyToken[k] = (byte)v;                              }                          }                      }                      else                          return null;                  }              }
Magic Number,Microsoft.LiveLabs.CST,AssemblyName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,FromReflectionName,The following statement contains a magic number: if (i < 0)                  name = strongName;              else              {                  name = strongName.Substring(0' i);                  i++;                  SkipWS(strongName' ref i);                  while (i < strongName.Length)                  {                      var kwd = GetKeyword(strongName' ref i);                      if (string.Equals(kwd' versionKeyword' StringComparison.OrdinalIgnoreCase))                      {                          var version = GetValue(strongName' ref i);                          if (version == null)                              return null;                          var j = 0;                          majorVersion = GetNum(version' ref j);                          if (majorVersion < 0)                              return null;                          if (!SkipDot(version' ref j))                              return null;                          minorVersion = GetNum(version' ref j);                          if (minorVersion < 0)                              return null;                          if (!SkipDot(version' ref j))                              return null;                          buildNumber = GetNum(version' ref j);                          if (buildNumber < 0)                              return null;                          if (!SkipDot(version' ref j))                              return null;                          revisionNumber = GetNum(version' ref j);                          if (revisionNumber < 0)                              return null;                      }                      else if (string.Equals(kwd' cultureKeyword' StringComparison.OrdinalIgnoreCase))                      {                          culture = GetValue(strongName' ref i);                          if (culture == null)                              return null;                      }                      else if (string.Equals(kwd' publicKeyTokenKeyword' StringComparison.OrdinalIgnoreCase))                      {                          var hex = GetValue(strongName' ref i);                          if (hex == null)                              return null;                          if (!hex.Equals(defaultPublicKeyToken' StringComparison.OrdinalIgnoreCase))                          {                              if (hex.Length%2 != 0)                                  return null;                              var j = 0;                              publicKeyToken = new byte[hex.Length/2];                              for (var k = 0; k < publicKeyToken.Length; k++)                              {                                  var v = GetByte(hex' ref j);                                  if (v < 0)                                      return null;                                  publicKeyToken[k] = (byte)v;                              }                          }                      }                      else                          return null;                  }              }
Magic Number,Microsoft.LiveLabs.CST,Peephole,C:\repos\Reactive-Extensions_IL2JS\CST\Peephole.cs,MoveNext,The following statement contains a magic number: do              {                  rewritten = false;                  if (EnsureLookahead(1))                  {                      var i = lookahead[0];                      if (i.Flavor == InstructionFlavor.ArgLocal)                      {                          var argloci = (ArgLocalInstruction)i;                          if (argloci.Op == ArgLocalOp.St)                          {                              if (!argloci.AfterState.ArgLocalIsAlive(argloci.ArgLocal' argloci.Index))                              {                                  // starg.n (where arg n is dead) ==> pop                                  // stloc.n (where local n is dead) ==> pop                                  lookahead[0] = new MiscInstruction(argloci.Offset' MiscOp.Pop)                                                     { BeforeState = argloci.BeforeState' AfterState = argloci.AfterState };                                  Trace(1' argloci);                                  rewritten = true;                              }                              else if (EnsureLookahead(2))                              {                                  var j = lookahead[1];                                  if (j.Flavor == InstructionFlavor.ArgLocal)                                  {                                      var arglocj = (ArgLocalInstruction)j;                                      if (arglocj.Op == ArgLocalOp.Ld && argloci.ArgLocal == arglocj.ArgLocal && argloci.Index == arglocj.Index)                                      {                                          if (!arglocj.AfterState.ArgLocalIsAlive(arglocj.ArgLocal' arglocj.Index))                                          {                                              // stloc.n; ldloc.n (where local n is dead) ==> <empty>                                              // starg.n; ldarg.n (where arg n is dead) ==> <empty>                                               lookahead.RemoveAt(0);                                              lookahead.RemoveAt(0);                                              Trace(0' argloci' arglocj);                                              rewritten = true;                                          }                                      }                                  }                              }                          }                      }                      else if (i.Flavor == InstructionFlavor.LdInt32)                      {                          var ldinti = (LdInt32Instruction)i;                          if (ldinti.Value == 0)                          {                              if (EnsureLookahead(2))                              {                                  var j = lookahead[1];                                  if (j.Flavor == InstructionFlavor.Compare)                                  {                                      var compj = (CompareInstruction)j;                                      if (compj.Op == CompareOp.Cgt && compj.IsUnsigned)                                      {                                          // ldc.i4 0; cgt.u => ctrue                                          lookahead.RemoveAt(0);                                          lookahead[0] = new CompareInstruction(compj.Offset' CompareOp.CtruePseudo' false) { Type = compj.Type' BeforeState = ldinti.BeforeState' AfterState = compj.AfterState };                                          Trace(1' ldinti' compj);                                          rewritten = true;                                          }                                      else if (compj.Op == CompareOp.Ceq)                                      {                                          // ldc.i4 0; ceq => cfalse                                          lookahead.RemoveAt(0);                                          lookahead[0] = new CompareInstruction(compj.Offset' CompareOp.CfalsePseudo' false) { Type = compj.Type' BeforeState = ldinti.BeforeState' AfterState = compj.AfterState };                                          Trace(1' ldinti' compj);                                          rewritten = true;                                      }                                  }                              }                          }                      }                      else if (i.Flavor == InstructionFlavor.Misc)                      {                          var misci = (MiscInstruction)i;                          if (misci.Op == MiscOp.Nop)                          {                              // nop ==> <empty>                              lookahead.RemoveAt(0);                              Trace(0' misci);                              rewritten = true;                          }                          else if (misci.Op == MiscOp.Ldnull)                          {                              if (EnsureLookahead(2))                              {                                  var j = lookahead[1];                                  if (j.Flavor == InstructionFlavor.Compare)                                  {                                      var compj = (CompareInstruction)j;                                      if (compj.Op == CompareOp.Cgt)                                      {                                          // ldnull; cgt => ctrue                                          lookahead.RemoveAt(0);                                          lookahead[0] = new CompareInstruction(compj.Offset' CompareOp.CtruePseudo' false) { Type = compj.Type' BeforeState = misci.BeforeState' AfterState = compj.AfterState };                                          Trace(1' misci' compj);                                          rewritten = true;                                      }                                      else if (compj.Op == CompareOp.Ceq)                                      {                                          // ldnull; ceq => cfalse                                          lookahead.RemoveAt(0);                                          lookahead[0] = new CompareInstruction(compj.Offset' CompareOp.CfalsePseudo' false) { Type = compj.Type' BeforeState = misci.BeforeState' AfterState = compj.AfterState };                                          Trace(1' misci' compj);                                          rewritten = true;                                      }                                  }                              }                          }                          else if (misci.Op == MiscOp.Dup)                          {                              if (EnsureLookahead(2))                              {                                  var j = lookahead[1];                                  if (j.Flavor == InstructionFlavor.Misc)                                  {                                      var miscj = (MiscInstruction)j;                                      if (miscj.Op == MiscOp.Pop)                                      {                                          // dup; pop ==> <empty>                                          lookahead.RemoveAt(0);                                          lookahead.RemoveAt(0);                                          Trace(0' misci' miscj);                                          rewritten = true;                                      }                                  }                              }                          }                      }                  }              }              while (rewritten);
Magic Number,Microsoft.LiveLabs.CST,Peephole,C:\repos\Reactive-Extensions_IL2JS\CST\Peephole.cs,MoveNext,The following statement contains a magic number: do              {                  rewritten = false;                  if (EnsureLookahead(1))                  {                      var i = lookahead[0];                      if (i.Flavor == InstructionFlavor.ArgLocal)                      {                          var argloci = (ArgLocalInstruction)i;                          if (argloci.Op == ArgLocalOp.St)                          {                              if (!argloci.AfterState.ArgLocalIsAlive(argloci.ArgLocal' argloci.Index))                              {                                  // starg.n (where arg n is dead) ==> pop                                  // stloc.n (where local n is dead) ==> pop                                  lookahead[0] = new MiscInstruction(argloci.Offset' MiscOp.Pop)                                                     { BeforeState = argloci.BeforeState' AfterState = argloci.AfterState };                                  Trace(1' argloci);                                  rewritten = true;                              }                              else if (EnsureLookahead(2))                              {                                  var j = lookahead[1];                                  if (j.Flavor == InstructionFlavor.ArgLocal)                                  {                                      var arglocj = (ArgLocalInstruction)j;                                      if (arglocj.Op == ArgLocalOp.Ld && argloci.ArgLocal == arglocj.ArgLocal && argloci.Index == arglocj.Index)                                      {                                          if (!arglocj.AfterState.ArgLocalIsAlive(arglocj.ArgLocal' arglocj.Index))                                          {                                              // stloc.n; ldloc.n (where local n is dead) ==> <empty>                                              // starg.n; ldarg.n (where arg n is dead) ==> <empty>                                               lookahead.RemoveAt(0);                                              lookahead.RemoveAt(0);                                              Trace(0' argloci' arglocj);                                              rewritten = true;                                          }                                      }                                  }                              }                          }                      }                      else if (i.Flavor == InstructionFlavor.LdInt32)                      {                          var ldinti = (LdInt32Instruction)i;                          if (ldinti.Value == 0)                          {                              if (EnsureLookahead(2))                              {                                  var j = lookahead[1];                                  if (j.Flavor == InstructionFlavor.Compare)                                  {                                      var compj = (CompareInstruction)j;                                      if (compj.Op == CompareOp.Cgt && compj.IsUnsigned)                                      {                                          // ldc.i4 0; cgt.u => ctrue                                          lookahead.RemoveAt(0);                                          lookahead[0] = new CompareInstruction(compj.Offset' CompareOp.CtruePseudo' false) { Type = compj.Type' BeforeState = ldinti.BeforeState' AfterState = compj.AfterState };                                          Trace(1' ldinti' compj);                                          rewritten = true;                                          }                                      else if (compj.Op == CompareOp.Ceq)                                      {                                          // ldc.i4 0; ceq => cfalse                                          lookahead.RemoveAt(0);                                          lookahead[0] = new CompareInstruction(compj.Offset' CompareOp.CfalsePseudo' false) { Type = compj.Type' BeforeState = ldinti.BeforeState' AfterState = compj.AfterState };                                          Trace(1' ldinti' compj);                                          rewritten = true;                                      }                                  }                              }                          }                      }                      else if (i.Flavor == InstructionFlavor.Misc)                      {                          var misci = (MiscInstruction)i;                          if (misci.Op == MiscOp.Nop)                          {                              // nop ==> <empty>                              lookahead.RemoveAt(0);                              Trace(0' misci);                              rewritten = true;                          }                          else if (misci.Op == MiscOp.Ldnull)                          {                              if (EnsureLookahead(2))                              {                                  var j = lookahead[1];                                  if (j.Flavor == InstructionFlavor.Compare)                                  {                                      var compj = (CompareInstruction)j;                                      if (compj.Op == CompareOp.Cgt)                                      {                                          // ldnull; cgt => ctrue                                          lookahead.RemoveAt(0);                                          lookahead[0] = new CompareInstruction(compj.Offset' CompareOp.CtruePseudo' false) { Type = compj.Type' BeforeState = misci.BeforeState' AfterState = compj.AfterState };                                          Trace(1' misci' compj);                                          rewritten = true;                                      }                                      else if (compj.Op == CompareOp.Ceq)                                      {                                          // ldnull; ceq => cfalse                                          lookahead.RemoveAt(0);                                          lookahead[0] = new CompareInstruction(compj.Offset' CompareOp.CfalsePseudo' false) { Type = compj.Type' BeforeState = misci.BeforeState' AfterState = compj.AfterState };                                          Trace(1' misci' compj);                                          rewritten = true;                                      }                                  }                              }                          }                          else if (misci.Op == MiscOp.Dup)                          {                              if (EnsureLookahead(2))                              {                                  var j = lookahead[1];                                  if (j.Flavor == InstructionFlavor.Misc)                                  {                                      var miscj = (MiscInstruction)j;                                      if (miscj.Op == MiscOp.Pop)                                      {                                          // dup; pop ==> <empty>                                          lookahead.RemoveAt(0);                                          lookahead.RemoveAt(0);                                          Trace(0' misci' miscj);                                          rewritten = true;                                      }                                  }                              }                          }                      }                  }              }              while (rewritten);
Magic Number,Microsoft.LiveLabs.CST,Peephole,C:\repos\Reactive-Extensions_IL2JS\CST\Peephole.cs,MoveNext,The following statement contains a magic number: do              {                  rewritten = false;                  if (EnsureLookahead(1))                  {                      var i = lookahead[0];                      if (i.Flavor == InstructionFlavor.ArgLocal)                      {                          var argloci = (ArgLocalInstruction)i;                          if (argloci.Op == ArgLocalOp.St)                          {                              if (!argloci.AfterState.ArgLocalIsAlive(argloci.ArgLocal' argloci.Index))                              {                                  // starg.n (where arg n is dead) ==> pop                                  // stloc.n (where local n is dead) ==> pop                                  lookahead[0] = new MiscInstruction(argloci.Offset' MiscOp.Pop)                                                     { BeforeState = argloci.BeforeState' AfterState = argloci.AfterState };                                  Trace(1' argloci);                                  rewritten = true;                              }                              else if (EnsureLookahead(2))                              {                                  var j = lookahead[1];                                  if (j.Flavor == InstructionFlavor.ArgLocal)                                  {                                      var arglocj = (ArgLocalInstruction)j;                                      if (arglocj.Op == ArgLocalOp.Ld && argloci.ArgLocal == arglocj.ArgLocal && argloci.Index == arglocj.Index)                                      {                                          if (!arglocj.AfterState.ArgLocalIsAlive(arglocj.ArgLocal' arglocj.Index))                                          {                                              // stloc.n; ldloc.n (where local n is dead) ==> <empty>                                              // starg.n; ldarg.n (where arg n is dead) ==> <empty>                                               lookahead.RemoveAt(0);                                              lookahead.RemoveAt(0);                                              Trace(0' argloci' arglocj);                                              rewritten = true;                                          }                                      }                                  }                              }                          }                      }                      else if (i.Flavor == InstructionFlavor.LdInt32)                      {                          var ldinti = (LdInt32Instruction)i;                          if (ldinti.Value == 0)                          {                              if (EnsureLookahead(2))                              {                                  var j = lookahead[1];                                  if (j.Flavor == InstructionFlavor.Compare)                                  {                                      var compj = (CompareInstruction)j;                                      if (compj.Op == CompareOp.Cgt && compj.IsUnsigned)                                      {                                          // ldc.i4 0; cgt.u => ctrue                                          lookahead.RemoveAt(0);                                          lookahead[0] = new CompareInstruction(compj.Offset' CompareOp.CtruePseudo' false) { Type = compj.Type' BeforeState = ldinti.BeforeState' AfterState = compj.AfterState };                                          Trace(1' ldinti' compj);                                          rewritten = true;                                          }                                      else if (compj.Op == CompareOp.Ceq)                                      {                                          // ldc.i4 0; ceq => cfalse                                          lookahead.RemoveAt(0);                                          lookahead[0] = new CompareInstruction(compj.Offset' CompareOp.CfalsePseudo' false) { Type = compj.Type' BeforeState = ldinti.BeforeState' AfterState = compj.AfterState };                                          Trace(1' ldinti' compj);                                          rewritten = true;                                      }                                  }                              }                          }                      }                      else if (i.Flavor == InstructionFlavor.Misc)                      {                          var misci = (MiscInstruction)i;                          if (misci.Op == MiscOp.Nop)                          {                              // nop ==> <empty>                              lookahead.RemoveAt(0);                              Trace(0' misci);                              rewritten = true;                          }                          else if (misci.Op == MiscOp.Ldnull)                          {                              if (EnsureLookahead(2))                              {                                  var j = lookahead[1];                                  if (j.Flavor == InstructionFlavor.Compare)                                  {                                      var compj = (CompareInstruction)j;                                      if (compj.Op == CompareOp.Cgt)                                      {                                          // ldnull; cgt => ctrue                                          lookahead.RemoveAt(0);                                          lookahead[0] = new CompareInstruction(compj.Offset' CompareOp.CtruePseudo' false) { Type = compj.Type' BeforeState = misci.BeforeState' AfterState = compj.AfterState };                                          Trace(1' misci' compj);                                          rewritten = true;                                      }                                      else if (compj.Op == CompareOp.Ceq)                                      {                                          // ldnull; ceq => cfalse                                          lookahead.RemoveAt(0);                                          lookahead[0] = new CompareInstruction(compj.Offset' CompareOp.CfalsePseudo' false) { Type = compj.Type' BeforeState = misci.BeforeState' AfterState = compj.AfterState };                                          Trace(1' misci' compj);                                          rewritten = true;                                      }                                  }                              }                          }                          else if (misci.Op == MiscOp.Dup)                          {                              if (EnsureLookahead(2))                              {                                  var j = lookahead[1];                                  if (j.Flavor == InstructionFlavor.Misc)                                  {                                      var miscj = (MiscInstruction)j;                                      if (miscj.Op == MiscOp.Pop)                                      {                                          // dup; pop ==> <empty>                                          lookahead.RemoveAt(0);                                          lookahead.RemoveAt(0);                                          Trace(0' misci' miscj);                                          rewritten = true;                                      }                                  }                              }                          }                      }                  }              }              while (rewritten);
Magic Number,Microsoft.LiveLabs.CST,Peephole,C:\repos\Reactive-Extensions_IL2JS\CST\Peephole.cs,MoveNext,The following statement contains a magic number: do              {                  rewritten = false;                  if (EnsureLookahead(1))                  {                      var i = lookahead[0];                      if (i.Flavor == InstructionFlavor.ArgLocal)                      {                          var argloci = (ArgLocalInstruction)i;                          if (argloci.Op == ArgLocalOp.St)                          {                              if (!argloci.AfterState.ArgLocalIsAlive(argloci.ArgLocal' argloci.Index))                              {                                  // starg.n (where arg n is dead) ==> pop                                  // stloc.n (where local n is dead) ==> pop                                  lookahead[0] = new MiscInstruction(argloci.Offset' MiscOp.Pop)                                                     { BeforeState = argloci.BeforeState' AfterState = argloci.AfterState };                                  Trace(1' argloci);                                  rewritten = true;                              }                              else if (EnsureLookahead(2))                              {                                  var j = lookahead[1];                                  if (j.Flavor == InstructionFlavor.ArgLocal)                                  {                                      var arglocj = (ArgLocalInstruction)j;                                      if (arglocj.Op == ArgLocalOp.Ld && argloci.ArgLocal == arglocj.ArgLocal && argloci.Index == arglocj.Index)                                      {                                          if (!arglocj.AfterState.ArgLocalIsAlive(arglocj.ArgLocal' arglocj.Index))                                          {                                              // stloc.n; ldloc.n (where local n is dead) ==> <empty>                                              // starg.n; ldarg.n (where arg n is dead) ==> <empty>                                               lookahead.RemoveAt(0);                                              lookahead.RemoveAt(0);                                              Trace(0' argloci' arglocj);                                              rewritten = true;                                          }                                      }                                  }                              }                          }                      }                      else if (i.Flavor == InstructionFlavor.LdInt32)                      {                          var ldinti = (LdInt32Instruction)i;                          if (ldinti.Value == 0)                          {                              if (EnsureLookahead(2))                              {                                  var j = lookahead[1];                                  if (j.Flavor == InstructionFlavor.Compare)                                  {                                      var compj = (CompareInstruction)j;                                      if (compj.Op == CompareOp.Cgt && compj.IsUnsigned)                                      {                                          // ldc.i4 0; cgt.u => ctrue                                          lookahead.RemoveAt(0);                                          lookahead[0] = new CompareInstruction(compj.Offset' CompareOp.CtruePseudo' false) { Type = compj.Type' BeforeState = ldinti.BeforeState' AfterState = compj.AfterState };                                          Trace(1' ldinti' compj);                                          rewritten = true;                                          }                                      else if (compj.Op == CompareOp.Ceq)                                      {                                          // ldc.i4 0; ceq => cfalse                                          lookahead.RemoveAt(0);                                          lookahead[0] = new CompareInstruction(compj.Offset' CompareOp.CfalsePseudo' false) { Type = compj.Type' BeforeState = ldinti.BeforeState' AfterState = compj.AfterState };                                          Trace(1' ldinti' compj);                                          rewritten = true;                                      }                                  }                              }                          }                      }                      else if (i.Flavor == InstructionFlavor.Misc)                      {                          var misci = (MiscInstruction)i;                          if (misci.Op == MiscOp.Nop)                          {                              // nop ==> <empty>                              lookahead.RemoveAt(0);                              Trace(0' misci);                              rewritten = true;                          }                          else if (misci.Op == MiscOp.Ldnull)                          {                              if (EnsureLookahead(2))                              {                                  var j = lookahead[1];                                  if (j.Flavor == InstructionFlavor.Compare)                                  {                                      var compj = (CompareInstruction)j;                                      if (compj.Op == CompareOp.Cgt)                                      {                                          // ldnull; cgt => ctrue                                          lookahead.RemoveAt(0);                                          lookahead[0] = new CompareInstruction(compj.Offset' CompareOp.CtruePseudo' false) { Type = compj.Type' BeforeState = misci.BeforeState' AfterState = compj.AfterState };                                          Trace(1' misci' compj);                                          rewritten = true;                                      }                                      else if (compj.Op == CompareOp.Ceq)                                      {                                          // ldnull; ceq => cfalse                                          lookahead.RemoveAt(0);                                          lookahead[0] = new CompareInstruction(compj.Offset' CompareOp.CfalsePseudo' false) { Type = compj.Type' BeforeState = misci.BeforeState' AfterState = compj.AfterState };                                          Trace(1' misci' compj);                                          rewritten = true;                                      }                                  }                              }                          }                          else if (misci.Op == MiscOp.Dup)                          {                              if (EnsureLookahead(2))                              {                                  var j = lookahead[1];                                  if (j.Flavor == InstructionFlavor.Misc)                                  {                                      var miscj = (MiscInstruction)j;                                      if (miscj.Op == MiscOp.Pop)                                      {                                          // dup; pop ==> <empty>                                          lookahead.RemoveAt(0);                                          lookahead.RemoveAt(0);                                          Trace(0' misci' miscj);                                          rewritten = true;                                      }                                  }                              }                          }                      }                  }              }              while (rewritten);
Magic Number,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,ArgsAndResultFromMethodSig,The following statement contains a magic number: if (definingTypeRef.Arguments.Count == 1 && !isStatic && (name.Equals("Set"' StringComparison.Ordinal) || name.Equals("Get"' StringComparison.Ordinal)) &&                  valParams != null)              {                  var bounds = global.GetMultiDimArrayTypeConstructorDetails(definingTypeRef.QualifiedTypeName);                  if (bounds != null)                  {                      if (name.Equals("Set"' StringComparison.Ordinal) && valParams.Count == 2 + bounds.Rank &&                          valParams[valParams.Count - 1].Equals(definingTypeRef.Arguments[0]))                      {                          var paramRef = new ParameterTypeRef(ParameterFlavor.Type' 0);                          valParams[valParams.Count - 1] = paramRef;                      }                      else if (name.Equals("Get"' StringComparison.Ordinal) && valParams.Count == 1 + bounds.Rank &&                               result != null && result.Equals(definingTypeRef.Arguments[0]))                      {                          result = new ParameterTypeRef(ParameterFlavor.Type' 0);                      }                  }              }
Magic Number,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The following statement contains a magic number: if (isInterface)              {                  if (extends != null)                      throw new InvalidOperationException("invalid interface type definition");                  if (qtn.Equals(global.IEnumerableTypeConstructorRef.QualifiedTypeName))                      res = new GenericIEnumerableTypeDef(annotations' null' implements' parameters' typeName' members);                  else                      res = new InterfaceTypeDef(annotations' null' implements' parameters' typeName' members);              }              else              {                  if (global.QualifiedTypeNameToAbbreviation.ContainsKey(qtn))                  {                      var numberFlavor = default(NumberFlavor);                      var handleFlavor = default(HandleFlavor);                      if (global.QualifiedTypeNameToNumberFlavor.TryGetValue(qtn' out numberFlavor))                          res = new NumberTypeDef                              (annotations'                               null'                               extends'                               implements'                               parameters'                               qtn.Type'                               members'                               numberFlavor'                               explicitInterfaceImplementations'                               isCallStaticConstructorEarly);                      else if (global.QualifiedTypeNameToHandleFlavor.TryGetValue(qtn' out handleFlavor))                          res = new HandleTypeDef                              (annotations'                               null'                               extends'                               implements'                               parameters'                               qtn.Type'                               members'                               handleFlavor'                               explicitInterfaceImplementations'                               isCallStaticConstructorEarly);                      else if (qtn.Equals(global.VoidRef.QualifiedTypeName))                          res = new VoidTypeDef                              (annotations'                               null'                               extends'                               implements'                               parameters'                               qtn.Type'                               members'                               explicitInterfaceImplementations'                               isCallStaticConstructorEarly);                      else if (qtn.Equals(global.ObjectRef.QualifiedTypeName))                          res = new ObjectTypeDef                              (annotations'                               null'                               extends'                               implements'                               parameters'                               qtn.Type'                               members'                               explicitInterfaceImplementations'                               isCallStaticConstructorEarly);                      else if (qtn.Equals(global.StringRef.QualifiedTypeName))                          res = new StringTypeDef                              (annotations'                               null'                               extends'                               implements'                               parameters'                               qtn.Type'                               members'                               explicitInterfaceImplementations'                               isCallStaticConstructorEarly);                      else                          throw new InvalidOperationException("unrecognised special type");                  }                  else if (qtn.Equals(global.EnumRef.QualifiedTypeName) || qtn.Equals(global.ValueTypeRef.QualifiedTypeName) ||                           qtn.Equals(global.DelegateRef.QualifiedTypeName) || qtn.Equals(global.MulticastDelegateRef.QualifiedTypeName) ||                           qtn.Equals(global.ObjectRef.QualifiedTypeName))                      res = new ClassTypeDef                          (annotations'                           null'                           extends'                           implements'                           parameters'                           qtn.Type'                           members'                           explicitInterfaceImplementations'                           isSealed'                           isAbstract'                           isCallStaticConstructorEarly);                  else if (qtn.Equals(global.NullableTypeConstructorRef.QualifiedTypeName))                      res = new NullableTypeDef                          (annotations'                           null'                           extends'                           implements'                           parameters'                           qtn.Type'                           members'                           explicitInterfaceImplementations'                           isCallStaticConstructorEarly);                  else if (extends != null)                  {                      // Look at extends type to decide if delegate' value type or ordinary class.                      // (Can get aways with this because delegates and value types are sealed.)                      if (extends.Equals(global.DelegateRef) || extends.Equals(global.MulticastDelegateRef))                      {                          // Is a user-defined delegate type.                           // Fixup the constructor to take a properly typed function pointer as third argument                          // instead of just IntPtr.                          var invokeDef =                              members.OfType<MethodDef>().Where                                  (m => !m.IsStatic && m.Name.Equals("Invoke"' StringComparison.Ordinal)).FirstOrDefault                                  ();                          if (invokeDef == null)                              throw new InvalidOperationException("delegate does not have Invoke method");                          var codePointer = ((MethodSignature)invokeDef.Signature).WithoutThis().ToCodePointer(global);                          var ctorDef =                              members.OfType<MethodDef>().Where(m => !m.IsStatic && m.IsConstructor && m.Arity == 3).                                  FirstOrDefault();                          if (ctorDef == null)                              throw new InvalidOperationException("delegate does not have expected constructor");                          var newCtorParams = new Seq<ParameterOrLocalOrResult>                                                  {                                                      ctorDef.ValueParameters[0]'                                                      ctorDef.ValueParameters[1]'                                                      new ParameterOrLocalOrResult                                                          (ctorDef.ValueParameters[2].Annotations'                                                           ctorDef.ValueParameters[2].CustomAttributes'                                                           codePointer)                                                  };                          var newCtorDef = new MethodDef                              (ctorDef.Annotations'                               ctorDef.CustomAttributes'                               ctorDef.Name'                               ctorDef.IsStatic'                               ctorDef.TypeParameters'                               newCtorParams'                               ctorDef.Result'                               ctorDef.MethodStyle'                               ctorDef.HasNewSlot'                               ctorDef.CodeFlavor'                               ctorDef.IsSyncronized'                               ctorDef.NoInlining'                               ctorDef.IsInitLocals'                               ctorDef.Locals'                               ctorDef.MethodBody);                          var newMembers = new Seq<MemberDef>();                          foreach (var member in members)                              newMembers.Add(member == ctorDef ? newCtorDef : member);                          res = new DelegateTypeDef                              (annotations'                               null'                               extends'                               implements'                               parameters'                               qtn.Type'                               newMembers'                               explicitInterfaceImplementations'                               isCallStaticConstructorEarly);                      }                      else if (extends.Equals(global.EnumRef))                          // Is a user-defined enumeration                          res = new EnumTypeDef                              (annotations'                               null'                               extends'                               implements'                               qtn.Type'                               members'                               explicitInterfaceImplementations'                               isCallStaticConstructorEarly);                      else if (extends.Equals(global.ValueTypeRef))                          // Is a user-defined struct                          res = new StructTypeDef                              (annotations'                               null'                               extends'                               implements'                               parameters'                               qtn.Type'                               members'                               explicitInterfaceImplementations'                               isCallStaticConstructorEarly);                      else                          res = new ClassTypeDef                              (annotations'                               null'                               extends'                               implements'                               parameters'                               qtn.Type'                               members'                               explicitInterfaceImplementations'                               isSealed'                               isAbstract'                               isCallStaticConstructorEarly);                  }                  else                      // Probably the <Module> type                      res = new ClassTypeDef                          (annotations'                           null'                           extends'                           implements'                           parameters'                           qtn.Type'                           members'                           explicitInterfaceImplementations'                           isSealed'                           isAbstract'                           isCallStaticConstructorEarly);              }
Magic Number,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The following statement contains a magic number: if (isInterface)              {                  if (extends != null)                      throw new InvalidOperationException("invalid interface type definition");                  if (qtn.Equals(global.IEnumerableTypeConstructorRef.QualifiedTypeName))                      res = new GenericIEnumerableTypeDef(annotations' null' implements' parameters' typeName' members);                  else                      res = new InterfaceTypeDef(annotations' null' implements' parameters' typeName' members);              }              else              {                  if (global.QualifiedTypeNameToAbbreviation.ContainsKey(qtn))                  {                      var numberFlavor = default(NumberFlavor);                      var handleFlavor = default(HandleFlavor);                      if (global.QualifiedTypeNameToNumberFlavor.TryGetValue(qtn' out numberFlavor))                          res = new NumberTypeDef                              (annotations'                               null'                               extends'                               implements'                               parameters'                               qtn.Type'                               members'                               numberFlavor'                               explicitInterfaceImplementations'                               isCallStaticConstructorEarly);                      else if (global.QualifiedTypeNameToHandleFlavor.TryGetValue(qtn' out handleFlavor))                          res = new HandleTypeDef                              (annotations'                               null'                               extends'                               implements'                               parameters'                               qtn.Type'                               members'                               handleFlavor'                               explicitInterfaceImplementations'                               isCallStaticConstructorEarly);                      else if (qtn.Equals(global.VoidRef.QualifiedTypeName))                          res = new VoidTypeDef                              (annotations'                               null'                               extends'                               implements'                               parameters'                               qtn.Type'                               members'                               explicitInterfaceImplementations'                               isCallStaticConstructorEarly);                      else if (qtn.Equals(global.ObjectRef.QualifiedTypeName))                          res = new ObjectTypeDef                              (annotations'                               null'                               extends'                               implements'                               parameters'                               qtn.Type'                               members'                               explicitInterfaceImplementations'                               isCallStaticConstructorEarly);                      else if (qtn.Equals(global.StringRef.QualifiedTypeName))                          res = new StringTypeDef                              (annotations'                               null'                               extends'                               implements'                               parameters'                               qtn.Type'                               members'                               explicitInterfaceImplementations'                               isCallStaticConstructorEarly);                      else                          throw new InvalidOperationException("unrecognised special type");                  }                  else if (qtn.Equals(global.EnumRef.QualifiedTypeName) || qtn.Equals(global.ValueTypeRef.QualifiedTypeName) ||                           qtn.Equals(global.DelegateRef.QualifiedTypeName) || qtn.Equals(global.MulticastDelegateRef.QualifiedTypeName) ||                           qtn.Equals(global.ObjectRef.QualifiedTypeName))                      res = new ClassTypeDef                          (annotations'                           null'                           extends'                           implements'                           parameters'                           qtn.Type'                           members'                           explicitInterfaceImplementations'                           isSealed'                           isAbstract'                           isCallStaticConstructorEarly);                  else if (qtn.Equals(global.NullableTypeConstructorRef.QualifiedTypeName))                      res = new NullableTypeDef                          (annotations'                           null'                           extends'                           implements'                           parameters'                           qtn.Type'                           members'                           explicitInterfaceImplementations'                           isCallStaticConstructorEarly);                  else if (extends != null)                  {                      // Look at extends type to decide if delegate' value type or ordinary class.                      // (Can get aways with this because delegates and value types are sealed.)                      if (extends.Equals(global.DelegateRef) || extends.Equals(global.MulticastDelegateRef))                      {                          // Is a user-defined delegate type.                           // Fixup the constructor to take a properly typed function pointer as third argument                          // instead of just IntPtr.                          var invokeDef =                              members.OfType<MethodDef>().Where                                  (m => !m.IsStatic && m.Name.Equals("Invoke"' StringComparison.Ordinal)).FirstOrDefault                                  ();                          if (invokeDef == null)                              throw new InvalidOperationException("delegate does not have Invoke method");                          var codePointer = ((MethodSignature)invokeDef.Signature).WithoutThis().ToCodePointer(global);                          var ctorDef =                              members.OfType<MethodDef>().Where(m => !m.IsStatic && m.IsConstructor && m.Arity == 3).                                  FirstOrDefault();                          if (ctorDef == null)                              throw new InvalidOperationException("delegate does not have expected constructor");                          var newCtorParams = new Seq<ParameterOrLocalOrResult>                                                  {                                                      ctorDef.ValueParameters[0]'                                                      ctorDef.ValueParameters[1]'                                                      new ParameterOrLocalOrResult                                                          (ctorDef.ValueParameters[2].Annotations'                                                           ctorDef.ValueParameters[2].CustomAttributes'                                                           codePointer)                                                  };                          var newCtorDef = new MethodDef                              (ctorDef.Annotations'                               ctorDef.CustomAttributes'                               ctorDef.Name'                               ctorDef.IsStatic'                               ctorDef.TypeParameters'                               newCtorParams'                               ctorDef.Result'                               ctorDef.MethodStyle'                               ctorDef.HasNewSlot'                               ctorDef.CodeFlavor'                               ctorDef.IsSyncronized'                               ctorDef.NoInlining'                               ctorDef.IsInitLocals'                               ctorDef.Locals'                               ctorDef.MethodBody);                          var newMembers = new Seq<MemberDef>();                          foreach (var member in members)                              newMembers.Add(member == ctorDef ? newCtorDef : member);                          res = new DelegateTypeDef                              (annotations'                               null'                               extends'                               implements'                               parameters'                               qtn.Type'                               newMembers'                               explicitInterfaceImplementations'                               isCallStaticConstructorEarly);                      }                      else if (extends.Equals(global.EnumRef))                          // Is a user-defined enumeration                          res = new EnumTypeDef                              (annotations'                               null'                               extends'                               implements'                               qtn.Type'                               members'                               explicitInterfaceImplementations'                               isCallStaticConstructorEarly);                      else if (extends.Equals(global.ValueTypeRef))                          // Is a user-defined struct                          res = new StructTypeDef                              (annotations'                               null'                               extends'                               implements'                               parameters'                               qtn.Type'                               members'                               explicitInterfaceImplementations'                               isCallStaticConstructorEarly);                      else                          res = new ClassTypeDef                              (annotations'                               null'                               extends'                               implements'                               parameters'                               qtn.Type'                               members'                               explicitInterfaceImplementations'                               isSealed'                               isAbstract'                               isCallStaticConstructorEarly);                  }                  else                      // Probably the <Module> type                      res = new ClassTypeDef                          (annotations'                           null'                           extends'                           implements'                           parameters'                           qtn.Type'                           members'                           explicitInterfaceImplementations'                           isSealed'                           isAbstract'                           isCallStaticConstructorEarly);              }
Magic Number,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The following statement contains a magic number: if (isInterface)              {                  if (extends != null)                      throw new InvalidOperationException("invalid interface type definition");                  if (qtn.Equals(global.IEnumerableTypeConstructorRef.QualifiedTypeName))                      res = new GenericIEnumerableTypeDef(annotations' null' implements' parameters' typeName' members);                  else                      res = new InterfaceTypeDef(annotations' null' implements' parameters' typeName' members);              }              else              {                  if (global.QualifiedTypeNameToAbbreviation.ContainsKey(qtn))                  {                      var numberFlavor = default(NumberFlavor);                      var handleFlavor = default(HandleFlavor);                      if (global.QualifiedTypeNameToNumberFlavor.TryGetValue(qtn' out numberFlavor))                          res = new NumberTypeDef                              (annotations'                               null'                               extends'                               implements'                               parameters'                               qtn.Type'                               members'                               numberFlavor'                               explicitInterfaceImplementations'                               isCallStaticConstructorEarly);                      else if (global.QualifiedTypeNameToHandleFlavor.TryGetValue(qtn' out handleFlavor))                          res = new HandleTypeDef                              (annotations'                               null'                               extends'                               implements'                               parameters'                               qtn.Type'                               members'                               handleFlavor'                               explicitInterfaceImplementations'                               isCallStaticConstructorEarly);                      else if (qtn.Equals(global.VoidRef.QualifiedTypeName))                          res = new VoidTypeDef                              (annotations'                               null'                               extends'                               implements'                               parameters'                               qtn.Type'                               members'                               explicitInterfaceImplementations'                               isCallStaticConstructorEarly);                      else if (qtn.Equals(global.ObjectRef.QualifiedTypeName))                          res = new ObjectTypeDef                              (annotations'                               null'                               extends'                               implements'                               parameters'                               qtn.Type'                               members'                               explicitInterfaceImplementations'                               isCallStaticConstructorEarly);                      else if (qtn.Equals(global.StringRef.QualifiedTypeName))                          res = new StringTypeDef                              (annotations'                               null'                               extends'                               implements'                               parameters'                               qtn.Type'                               members'                               explicitInterfaceImplementations'                               isCallStaticConstructorEarly);                      else                          throw new InvalidOperationException("unrecognised special type");                  }                  else if (qtn.Equals(global.EnumRef.QualifiedTypeName) || qtn.Equals(global.ValueTypeRef.QualifiedTypeName) ||                           qtn.Equals(global.DelegateRef.QualifiedTypeName) || qtn.Equals(global.MulticastDelegateRef.QualifiedTypeName) ||                           qtn.Equals(global.ObjectRef.QualifiedTypeName))                      res = new ClassTypeDef                          (annotations'                           null'                           extends'                           implements'                           parameters'                           qtn.Type'                           members'                           explicitInterfaceImplementations'                           isSealed'                           isAbstract'                           isCallStaticConstructorEarly);                  else if (qtn.Equals(global.NullableTypeConstructorRef.QualifiedTypeName))                      res = new NullableTypeDef                          (annotations'                           null'                           extends'                           implements'                           parameters'                           qtn.Type'                           members'                           explicitInterfaceImplementations'                           isCallStaticConstructorEarly);                  else if (extends != null)                  {                      // Look at extends type to decide if delegate' value type or ordinary class.                      // (Can get aways with this because delegates and value types are sealed.)                      if (extends.Equals(global.DelegateRef) || extends.Equals(global.MulticastDelegateRef))                      {                          // Is a user-defined delegate type.                           // Fixup the constructor to take a properly typed function pointer as third argument                          // instead of just IntPtr.                          var invokeDef =                              members.OfType<MethodDef>().Where                                  (m => !m.IsStatic && m.Name.Equals("Invoke"' StringComparison.Ordinal)).FirstOrDefault                                  ();                          if (invokeDef == null)                              throw new InvalidOperationException("delegate does not have Invoke method");                          var codePointer = ((MethodSignature)invokeDef.Signature).WithoutThis().ToCodePointer(global);                          var ctorDef =                              members.OfType<MethodDef>().Where(m => !m.IsStatic && m.IsConstructor && m.Arity == 3).                                  FirstOrDefault();                          if (ctorDef == null)                              throw new InvalidOperationException("delegate does not have expected constructor");                          var newCtorParams = new Seq<ParameterOrLocalOrResult>                                                  {                                                      ctorDef.ValueParameters[0]'                                                      ctorDef.ValueParameters[1]'                                                      new ParameterOrLocalOrResult                                                          (ctorDef.ValueParameters[2].Annotations'                                                           ctorDef.ValueParameters[2].CustomAttributes'                                                           codePointer)                                                  };                          var newCtorDef = new MethodDef                              (ctorDef.Annotations'                               ctorDef.CustomAttributes'                               ctorDef.Name'                               ctorDef.IsStatic'                               ctorDef.TypeParameters'                               newCtorParams'                               ctorDef.Result'                               ctorDef.MethodStyle'                               ctorDef.HasNewSlot'                               ctorDef.CodeFlavor'                               ctorDef.IsSyncronized'                               ctorDef.NoInlining'                               ctorDef.IsInitLocals'                               ctorDef.Locals'                               ctorDef.MethodBody);                          var newMembers = new Seq<MemberDef>();                          foreach (var member in members)                              newMembers.Add(member == ctorDef ? newCtorDef : member);                          res = new DelegateTypeDef                              (annotations'                               null'                               extends'                               implements'                               parameters'                               qtn.Type'                               newMembers'                               explicitInterfaceImplementations'                               isCallStaticConstructorEarly);                      }                      else if (extends.Equals(global.EnumRef))                          // Is a user-defined enumeration                          res = new EnumTypeDef                              (annotations'                               null'                               extends'                               implements'                               qtn.Type'                               members'                               explicitInterfaceImplementations'                               isCallStaticConstructorEarly);                      else if (extends.Equals(global.ValueTypeRef))                          // Is a user-defined struct                          res = new StructTypeDef                              (annotations'                               null'                               extends'                               implements'                               parameters'                               qtn.Type'                               members'                               explicitInterfaceImplementations'                               isCallStaticConstructorEarly);                      else                          res = new ClassTypeDef                              (annotations'                               null'                               extends'                               implements'                               parameters'                               qtn.Type'                               members'                               explicitInterfaceImplementations'                               isSealed'                               isAbstract'                               isCallStaticConstructorEarly);                  }                  else                      // Probably the <Module> type                      res = new ClassTypeDef                          (annotations'                           null'                           extends'                           implements'                           parameters'                           qtn.Type'                           members'                           explicitInterfaceImplementations'                           isSealed'                           isAbstract'                           isCallStaticConstructorEarly);              }
Magic Number,Microsoft.LiveLabs.CST,MethodSignature,C:\repos\Reactive-Extensions_IL2JS\CST\Signature.cs,Fixup,The following statement contains a magic number: if (Parameters.Count > 0 && !IsStatic)              {                  var paramAssemblyDef = default(AssemblyDef);                  var paramTypeDef = default(TypeDef);                  if (Parameters[0].PrimTryResolve(global' out paramAssemblyDef' out paramTypeDef))                  {                      var s = paramTypeDef.Style;                      if (s is ValueTypeStyle)                      {                          var newValueParameters = new Seq<TypeRef>(Parameters.Count);                          newValueParameters.Add(global.ManagedPointerTypeConstructorRef.ApplyTo(Parameters[0]));                          for (var i = 1; i < Parameters.Count; i++)                              newValueParameters.Add(Parameters[i]);                          Parameters = newValueParameters;                      }                      else if (Parameters.Count == 3 && Name.Equals(".ctor"' StringComparison.Ordinal) &&                               s is DelegateTypeStyle)                      {                          var delTypeDef = (DelegateTypeDef)paramTypeDef;                          var newValueParameters = new Seq<TypeRef>(Parameters.Count);                          for (var i = 0; i < 2; i++)                              newValueParameters.Add(Parameters[i]);                          newValueParameters.Add                              (TypeRef.CodePointerFrom                                   (global'                                    delTypeDef.ValueParameters.Select(p => p.Type).ToSeq()'                                    delTypeDef.Result == null ? null : delTypeDef.Result.Type));                          Parameters = newValueParameters;                      }                  }              }
Magic Number,Microsoft.LiveLabs.CST,MethodSignature,C:\repos\Reactive-Extensions_IL2JS\CST\Signature.cs,Fixup,The following statement contains a magic number: if (Parameters.Count > 0 && !IsStatic)              {                  var paramAssemblyDef = default(AssemblyDef);                  var paramTypeDef = default(TypeDef);                  if (Parameters[0].PrimTryResolve(global' out paramAssemblyDef' out paramTypeDef))                  {                      var s = paramTypeDef.Style;                      if (s is ValueTypeStyle)                      {                          var newValueParameters = new Seq<TypeRef>(Parameters.Count);                          newValueParameters.Add(global.ManagedPointerTypeConstructorRef.ApplyTo(Parameters[0]));                          for (var i = 1; i < Parameters.Count; i++)                              newValueParameters.Add(Parameters[i]);                          Parameters = newValueParameters;                      }                      else if (Parameters.Count == 3 && Name.Equals(".ctor"' StringComparison.Ordinal) &&                               s is DelegateTypeStyle)                      {                          var delTypeDef = (DelegateTypeDef)paramTypeDef;                          var newValueParameters = new Seq<TypeRef>(Parameters.Count);                          for (var i = 0; i < 2; i++)                              newValueParameters.Add(Parameters[i]);                          newValueParameters.Add                              (TypeRef.CodePointerFrom                                   (global'                                    delTypeDef.ValueParameters.Select(p => p.Type).ToSeq()'                                    delTypeDef.Result == null ? null : delTypeDef.Result.Type));                          Parameters = newValueParameters;                      }                  }              }
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return true;                      case MiscOp.Dup:                          return stack.Dup(statements);                      case MiscOp.Pop:                          return stack.PopAndDiscard(statements);                      case MiscOp.Ldnull:                          stack.Push(new ExpressionStackEntry(new NullConstantExpression()' BottomE));                          return true;                      case MiscOp.Ckfinite:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.CheckFinite' false' false)' e.Lub(ThrowsE)));                      case MiscOp.Throw:                          if (!stack.DiscardAll(statements' 1))                              return false;                          if (!stack.PopEvalSE(statements' 1' true' ThrowsE' (s' a) => s.Add(new ThrowStatement(a[0]))))                              return false;                          return true;                      case MiscOp.Rethrow:                          if (!stack.DiscardAll(statements' 0))                              return false;                          if (statements == null)                              return Failed(false' "rethrow");                          if (exid == null)                              throw new InvalidOperationException("rethrow outside of catch");                          statements.Add(new RethrowStatement(new VariableCell(exid).Read()));                          return true;                      case MiscOp.LdindRef:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case MiscOp.LdelemRef:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.Ldlen:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.Length' false' false)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.StindRef:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case MiscOp.StelemRef:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add                                   (new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      case MiscOp.Ret:                          if (statements == null)                              return Failed(false' "return");                          statements.Add(new ReturnStatement(null));                          return true;                      case MiscOp.RetVal:                          return stack.PopEvalSE                              (statements' 1' true' BottomE' (s' a) => s.Add(new ReturnStatement(a[0])));                      case MiscOp.Endfilter:                      case MiscOp.Endfinally:                          throw new InvalidOperationException                              ("endfilter/endfinally instructions should have been removed");                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:              case InstructionFlavor.Switch:                  throw new InvalidOperationException("branch/switch instructions should have been removed");              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      if (cmpi.Op == CompareOp.CtruePseudo || cmpi.Op == CompareOp.CfalsePseudo)                      {                          var s = cmpi.Type.Style(compEnv);                          var unop = default(UnaryOp);                          if (s is NumberTypeStyle)                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonZero : UnaryOp.IsZero;                          else                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonNull : UnaryOp.IsNull;                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new UnaryExpression(a[0]' unop' false' cmpi.IsUnsigned)' e));                      }                      else                      {                          var binop = default(BinaryOp);                          switch (cmpi.Op)                          {                          case CompareOp.Ceq:                              binop = BinaryOp.Eq;                              break;                          case CompareOp.Clt:                              binop = BinaryOp.Lt;                              break;                          case CompareOp.Cgt:                              binop = BinaryOp.Gt;                              break;                          case CompareOp.CgePseudo:                              binop = BinaryOp.Ge;                              break;                          case CompareOp.ClePseudo:                              binop = BinaryOp.Le;                              break;                          case CompareOp.CnePseudo:                              binop = BinaryOp.Ne;                              break;                          case CompareOp.CtruePseudo:                          case CompareOp.CfalsePseudo:                              // handled above                              throw new InvalidOperationException();                          default:                              throw new ArgumentOutOfRangeException();                          }                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression(a[0]' binop' a[1]' false' cmpi.IsUnsigned)' e));                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var sli = (ArgLocalInstruction)instruction;                      var id = default(JST.Identifier);                      switch (sli.ArgLocal)                      {                      case ArgLocal.Arg:                          id = compEnv.ValueParameterIds[sli.Index];                          break;                      case ArgLocal.Local:                          id = compEnv.LocalIds[sli.Index];                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      var cell = new VariableCell(id);                      switch (sli.Op)                      {                      case ArgLocalOp.Ld:                          stack.Push                              (new ExpressionStackEntry                                   (cell.Read().CloneIfStruct(compEnv)' ReadArgLocalE(sli.ArgLocal' sli.Index)));                          return true;                      case ArgLocalOp.Lda:                          // Effect will be accounted for on reads/writes                          stack.Push(new ExpressionStackEntry(cell.AddressOf()' BottomE));                          return true;                      case ArgLocalOp.St:                          return stack.PopEvalSE                              (statements'                               1'                               true'                               WriteArgLocalE(sli.ArgLocal' sli.Index)'                               (s' a) => s.Add(new ExpressionStatement(cell.Write(a[0]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                          {                              stack.Push                                  (new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' ReadHeapE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                       {                                           var readEffect = default(Effects);                                           var obj = default(Expression);                                           if (fieldi.IsViaPointer.Value)                                           {                                               readEffect = e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect());                                               obj = new ReadExpression(a[0]); // no need for clone                                           }                                           else if (fieldi.Field.DefiningType.Style(compEnv) is ValueTypeStyle)                                           {                                               readEffect = e;                                               obj = a[0];                                           }                                           else                                           {                                               // Object could be null                                               readEffect = e.Lub(ReadHeapOrThrowE);                                               obj = a[0];                                           }                                           return new ExpressionStackEntry(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' readEffect);                                       });                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                          {                              // Effect will be accounted for on reads/writes                              stack.Push(new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' BottomE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   {                                       if (fieldi.IsViaPointer.Value)                                           // We're just adding an offset to a pointer' so effect will                                           // be accounted for when the final pointer is read/written                                           return new ExpressionStackEntry(new FieldCell(new ReadExpression(a[0])' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e);                                       else                                           // Must be a reference type' and ref could be null                                           return new ExpressionStackEntry(new FieldCell(a[0]' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e.Lub(ThrowsE));                                   });                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                              return stack.PopEvalSE                                  (statements'                                   1'                                   true'                                   WriteHeapE'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Write(a[0]))));                          else                          {                              var writeEffect = fieldi.IsViaPointer.Value                                                    ? instruction.BeforeState.PeekPointsTo(1).WriteEffect()                                                    : WriteHeapOrThrowE;                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   writeEffect'                                   (s' a) =>                                       {                                           var obj = fieldi.IsViaPointer.Value ? new ReadExpression(a[0]) : a[0];                                           s.Add(new ExpressionStatement(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Write(a[1])));                                       });                          }                      case FieldOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new FieldHandleConstantExpression(compEnv.SubstituteMember(fieldi.Field))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methodi = (MethodInstruction)instruction;                      var arity = methodi.Method.ValueParameters.Count;                      switch (methodi.Op)                      {                      case MethodOp.Ldftn:                          if (methodi.IsVirtual)                              // Object could be null                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CodePointerExpression(a[0]' compEnv.SubstituteMember(methodi.Method))' e.Lub(ReadHeapOrThrowE)));                          else                          {                              stack.Push                                  (new ExpressionStackEntry(new CodePointerExpression(null' compEnv.SubstituteMember(methodi.Method))' BottomE));                              return true;                          }                      case MethodOp.Call:                          if (methodi.Method.Result == null)                              return stack.PopEvalSE                                  (statements'                                   arity'                                   true'                                   CalleeEffects(methodi.BeforeState' arity)'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new CallExpression                                                 (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal'                                                  compEnv.SubstituteMember(methodi.Method)'                                                  CallerArguments(methodi.Constrained' methodi.Method' a)))));                          else                              return stack.PopEvalPush                                  (statements'                                   arity'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CallExpression                                            (methodi.IsVirtual? CallFlavor.Virtual : CallFlavor.Normal'                                             compEnv.SubstituteMember(methodi.Method)'                                             CallerArguments(methodi.Constrained' methodi.Method' a))'                                        e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Newobj:                          arity--;                          return stack.PopEvalPush                              (statements'                               arity'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new NewObjectExpression(compEnv.SubstituteMember(methodi.Method)' CallerArguments(null' methodi.Method' a))'                                    e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Ldtoken:                          stack.Push                              (new ExpressionStackEntry(new MethodHandleConstantExpression(compEnv.SubstituteMember(methodi.Method))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case TypeOp.Stobj:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case TypeOp.Cpobj:                          {                              var copyEffect = instruction.BeforeState.PeekPointsTo(0).ReadEffect().Lub                                  (instruction.BeforeState.PeekPointsTo(1).WriteEffect());                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   copyEffect'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new WriteExpression(a[0]' new ReadExpression(a[1]).CloneIfStruct(compEnv)))));                          }                      case TypeOp.Newarr:                          // Growing the heap is not considered an observable change. But will throw if                          // length < 0                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new NewArrayExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Initobj:                          return stack.PopEvalSE                              (statements' 1' true' WriteHeapE' (s' a) => s.Add(new InitializeObjectStatement(a[0])));                      case TypeOp.Castclass:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new CastExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Isinst:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new IsInstExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Box:                          // Growing the heap is not considered an observable change                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new NewBoxExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Unbox:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).AddressOf()' e.Lub(ThrowsE)));                      case TypeOp.UnboxAny:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).Read().CloneIfStruct(compEnv)' e.Lub(ThrowsE)));                      case TypeOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new TypeHandleConstantExpression(compEnv.SubstituteType(typei.Type))' BottomE));                          return true;                      case TypeOp.Ldelem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case TypeOp.Stelem:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add(new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  // Calculating the pointer may throw if index is out of range.                  // Remaining effect will be accounted for when pointer is read/written.                  return stack.PopEvalPush                      (statements'                       2'                       true'                       (a' e) =>                       new ExpressionStackEntry(new ElementCell(a[0]' a[1]' false).AddressOf()' e.Lub(ThrowsE)));              case InstructionFlavor.LdInt32:                  {                      var int32i = (LdInt32Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int32ConstantExpression(int32i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdInt64:                  {                      var int64i = (LdInt64Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int64ConstantExpression(int64i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdSingle:                  {                      var singlei = (LdSingleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new SingleConstantExpression(singlei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdDouble:                  {                      var doublei = (LdDoubleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new DoubleConstantExpression(doublei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdString:                  {                      var stringi = (LdStringInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new StringConstantExpression(stringi.Value)' BottomE));                      return true;                  }              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Div:                      case ArithOp.Rem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(ThrowsE)));                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                      case ArithOp.Shl:                      case ArithOp.Shr:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(arithi.WithOverflow ? ThrowsE : BottomE)));                      case ArithOp.Neg:                      case ArithOp.BitNot:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression                                        (a[0]' ArithOpToUnaryOp(arithi.Op)' arithi.WithOverflow' arithi.IsUnsigned)'                                    e));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      return stack.PopEvalPush                          (statements'                           1'                           true'                           (a' e) =>                           new ExpressionStackEntry                               (new ConvertExpression                                    (a[0]'                                     new NamedTypeRef                                         (compEnv.Global.NumberFlavorToQualifiedTypeName[convi.TargetNumberFlavor])'                                     convi.WithOverflow'                                     convi.IsSourceUnsigned)'                                e.Lub(convi.WithOverflow ? ThrowsE : BottomE)));                  }              case InstructionFlavor.Try:                  {                      if (stack.Depth > 0)                          throw new InvalidOperationException("stack must be empty on entry to try block");                      var tryi = (TryInstruction)instruction;                      var tryStatements = BlockToTryFaultFinallyStatements(tryi.Body);                      if (tryStatements == null)                          return false;                      var handlers = TranslateHandlers(tryi.Handlers);                      if (handlers == null)                          return false;                      if (statements == null)                          return Failed(false' "try");                      statements.Add(new TryStatement(tryStatements' handlers));                      return true;                  }              case InstructionFlavor.IfThenElsePseudo:                  {                      var itei = (IfThenElseInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(itei.Offset' out isExpr) ||                                              isExpr;                        if (!TranslateBlock(statements' itei.Condition' stack' exid))                          return false;                      if (couldBeExpression && itei.Else != null)                      {                          // Pass 1: Try to tranlate to an if-then-else expression. Will only work if Then and Else don't                          //         reach into current stack' push exactly one value' and don't need to emit any                          //         statements along the way.                          var thenEntry = BlockToExpression(itei.Then' exid);                          if (thenEntry != null)                          {                              var elseEntry = BlockToExpression(itei.Else' exid);                              if (elseEntry != null)                              {                                  if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                                      instructionTranslationStyleCache.Add(itei.Offset' true);                                  return stack.PopEvalPush                                      (statements'                                       1'                                       true'                                       (a' e) =>                                       new ExpressionStackEntry                                           (new IfThenElseExpression(a[0]' thenEntry.Expression' elseEntry.Expression)'                                            e.Lub(thenEntry.Effects.Lub(elseEntry.Effects))));                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      var noStackChange = itei.Then.NoStackChange && (itei.Else == null || itei.Else.NoStackChange);                      var condEntry = noStackChange                                          ? stack.Pop()                                          : stack.FlushAndPopPostState(statements' itei.Then.BeforeState);                      if (condEntry == null)                          return false;                      var thenStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Then' exid)                                           : BlockToStatements(itei.Then' exid);                      if (thenStmnts == null)                          return false;                      var elseStmnts = default(Seq<Statement>);                      if (itei.Else != null)                      {                          elseStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Else' exid)                                           : BlockToStatements(itei.Else' exid);                          if (elseStmnts == null)                              return false;                      }                      if (statements == null)                          return Failed(false' "if-then-else");                      statements.Add                          (new IfThenElseStatement(condEntry.Expression' new Statements(thenStmnts)' elseStmnts == null ? null : new Statements(elseStmnts)));                      if (!noStackChange && !stack.Restore(itei.AfterState' 0))                          return false;                      if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                          instructionTranslationStyleCache.Add(itei.Offset' false);                      return true;                  }              case InstructionFlavor.ShortCircuitingPseudo:                  {                      var sci = (ShortCircuitingInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(sci.Offset' out isExpr) ||                                              isExpr;                      if (couldBeExpression)                      {                          // Pass 1: Try to translate to an expression.                          var leftEntry = BlockToExpression(sci.Left' exid);                          if (leftEntry != null)                          {                              var rightEntry = BlockToExpression(sci.Right' exid);                              if (rightEntry != null)                              {                                  stack.Push                                      (new ExpressionStackEntry                                           (new BinaryExpression                                                (leftEntry.Expression'                                                 ShortCircuitingOpToBinaryOp(sci.Op)'                                                 rightEntry.Expression'                                                 false'                                                 false)'                                            leftEntry.Effects.Lub(rightEntry.Effects)));                                  if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                                      instructionTranslationStyleCache.Add(sci.Offset' true);                                  return true;                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      if (!TranslateBlock(statements' sci.Left' stack' exid))                          return false;                      var leftEntry2 = stack.FlushAndPopPostState(statements' sci.Right.BeforeState);                      if (leftEntry2 == null)                          return false;                      var rightStatements = BlockToStatements(sci.Right' exid);                      if (rightStatements == null)                          return false;                      var id = sci.Right.AfterState.PeekId(0' nameSupply.GenSym);                      var cell = new VariableCell(id);                      compEnv.AddVariable(id' ArgLocal.Local' false' true' compEnv.SubstituteType(sci.Right.AfterState.PeekType(0)));                      if (statements == null)                          return Failed(false' "short-circuit");                      switch (sci.Op)                      {                      case ShortCircuitingOp.And:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements(rightStatements)'                                    new Statements                                        (new ExpressionStatement(cell.Write(new Int32ConstantExpression(0))))));                          break;                      case ShortCircuitingOp.Or:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements                                        (new ExpressionStatement                                             (cell.Write(new Int32ConstantExpression(1))))'                                    new Statements(rightStatements)));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      if (!stack.Restore(sci.AfterState' 1))                          return false;                      stack.Push(new ExpressionStackEntry(cell.Read()' BottomE));                      if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                          instructionTranslationStyleCache.Add(sci.Offset' false);                      return true;                  }              case InstructionFlavor.StructuralSwitchPseudo:                  {                      var ssi = (StructuralSwitchInstruction)instruction;                      if (!TranslateBlock(statements' ssi.Body' stack' exid))                          return false;                      var valueEntry = stack.FlushAndPopPreState(statements' ssi.Body.AfterState);                      if (valueEntry == null)                          return false;                      var cases = new Seq<SwitchStatementCase>();                      foreach (var c in ssi.Cases)                      {                          var caseStatements = BlockToStatements(c.Body' exid);                          if (caseStatements == null)                              return false;                          cases.Add(new SwitchStatementCase(c.Values' new Statements(caseStatements)));                      }                      if (statements == null)                          return Failed(false' "structural switch");                      statements.Add(new SwitchStatement(valueEntry.Expression' cases));                      if (!stack.Restore(ssi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopPseudo:                  {                      var li = (LoopInstruction)instruction;                      if (!stack.Flush(statements' li.Body.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop");                      var whileStatements = BlockToStatements(li.Body' exid);                      statements.Add                          (new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(whileStatements)));                      if (!stack.Restore(li.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.WhileDoPseudo:                  {                      var wdi = (WhileDoInstruction)instruction;                      if (!stack.Flush(statements' wdi.Condition.BeforeState))                          return false;                      var condEntry = BlockToExpression(wdi.Condition' exid);                      if (condEntry == null)                      {                          var stack1 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Condition.BeforeState' trace);                          var preCondStatements = new Seq<Statement>();                          if (!TranslateBlock(preCondStatements' wdi.Condition' stack1' exid))                              return false;                          condEntry = stack1.FlushAndPopPostState(preCondStatements' wdi.Body.BeforeState);                          if (condEntry == null)                              return false;                          var stack2 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Body.BeforeState' trace);                          var postCondStatements = new Seq<Statement>();                          if (!TranslateBlock(postCondStatements' wdi.Body' stack2' exid))                              return false;                          if (!stack2.Flush(postCondStatements' wdi.Body.AfterState))                              return false;                          preCondStatements.Add                              (new IfThenElseStatement                                   (condEntry.Expression'                                    new Statements(postCondStatements)'                                    new Statements(new BreakStatement())));                          statements.Add(new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(preCondStatements)));                      }                      else                      {                          var loopStatements = BlockToStatements(wdi.Body' exid);                          if (loopStatements == null)                              return false;                          if (statements == null)                              return Failed(false' "while-do");                          statements.Add(new WhileDoStatement(condEntry.Expression' new Statements(loopStatements)));                      }                      if (!stack.Restore(wdi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.DoWhilePseudo:                  {                      var dwi = (DoWhileInstruction)instruction;                      if (!stack.Flush(statements' dwi.Body.BeforeState))                          return false;                      var combined = new Seq<Instruction>();                      foreach (var i in dwi.Body.Body)                          combined.Add(i);                      foreach (var i in dwi.Condition.Body)                          combined.Add(i);                      var condEntry = default(ExpressionStackEntry);                      var loopStatements = BlockToConditionStatements                          (new Instructions(null' combined)' dwi.Body.BeforeState' exid' out condEntry);                      if (loopStatements == null)                          return false;                      if (statements == null)                          return Failed(false' "do-while");                      statements.Add(new DoWhileStatement(new Statements(loopStatements)' condEntry.Expression));                      if (!stack.Restore(dwi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopControlPseudo:                  {                      var lci = (BreakContinueInstruction)instruction;                      if (!stack.Flush(statements' lci.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop-control");                      var targetState = default(int);                      switch (lci.Op)                      {                      case BreakContinueOp.Break:                          if (labelToLoopCandidateBreakState != null &&                              labelToLoopCandidateBreakState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new BreakStatement(lci.Label));                          break;                      case BreakContinueOp.Continue:                          if (labelToLoopCandidateContinueState != null &&                              labelToLoopCandidateContinueState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new ContinueStatement(lci.Label));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      return true;                  }              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return true;                      case MiscOp.Dup:                          return stack.Dup(statements);                      case MiscOp.Pop:                          return stack.PopAndDiscard(statements);                      case MiscOp.Ldnull:                          stack.Push(new ExpressionStackEntry(new NullConstantExpression()' BottomE));                          return true;                      case MiscOp.Ckfinite:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.CheckFinite' false' false)' e.Lub(ThrowsE)));                      case MiscOp.Throw:                          if (!stack.DiscardAll(statements' 1))                              return false;                          if (!stack.PopEvalSE(statements' 1' true' ThrowsE' (s' a) => s.Add(new ThrowStatement(a[0]))))                              return false;                          return true;                      case MiscOp.Rethrow:                          if (!stack.DiscardAll(statements' 0))                              return false;                          if (statements == null)                              return Failed(false' "rethrow");                          if (exid == null)                              throw new InvalidOperationException("rethrow outside of catch");                          statements.Add(new RethrowStatement(new VariableCell(exid).Read()));                          return true;                      case MiscOp.LdindRef:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case MiscOp.LdelemRef:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.Ldlen:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.Length' false' false)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.StindRef:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case MiscOp.StelemRef:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add                                   (new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      case MiscOp.Ret:                          if (statements == null)                              return Failed(false' "return");                          statements.Add(new ReturnStatement(null));                          return true;                      case MiscOp.RetVal:                          return stack.PopEvalSE                              (statements' 1' true' BottomE' (s' a) => s.Add(new ReturnStatement(a[0])));                      case MiscOp.Endfilter:                      case MiscOp.Endfinally:                          throw new InvalidOperationException                              ("endfilter/endfinally instructions should have been removed");                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:              case InstructionFlavor.Switch:                  throw new InvalidOperationException("branch/switch instructions should have been removed");              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      if (cmpi.Op == CompareOp.CtruePseudo || cmpi.Op == CompareOp.CfalsePseudo)                      {                          var s = cmpi.Type.Style(compEnv);                          var unop = default(UnaryOp);                          if (s is NumberTypeStyle)                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonZero : UnaryOp.IsZero;                          else                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonNull : UnaryOp.IsNull;                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new UnaryExpression(a[0]' unop' false' cmpi.IsUnsigned)' e));                      }                      else                      {                          var binop = default(BinaryOp);                          switch (cmpi.Op)                          {                          case CompareOp.Ceq:                              binop = BinaryOp.Eq;                              break;                          case CompareOp.Clt:                              binop = BinaryOp.Lt;                              break;                          case CompareOp.Cgt:                              binop = BinaryOp.Gt;                              break;                          case CompareOp.CgePseudo:                              binop = BinaryOp.Ge;                              break;                          case CompareOp.ClePseudo:                              binop = BinaryOp.Le;                              break;                          case CompareOp.CnePseudo:                              binop = BinaryOp.Ne;                              break;                          case CompareOp.CtruePseudo:                          case CompareOp.CfalsePseudo:                              // handled above                              throw new InvalidOperationException();                          default:                              throw new ArgumentOutOfRangeException();                          }                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression(a[0]' binop' a[1]' false' cmpi.IsUnsigned)' e));                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var sli = (ArgLocalInstruction)instruction;                      var id = default(JST.Identifier);                      switch (sli.ArgLocal)                      {                      case ArgLocal.Arg:                          id = compEnv.ValueParameterIds[sli.Index];                          break;                      case ArgLocal.Local:                          id = compEnv.LocalIds[sli.Index];                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      var cell = new VariableCell(id);                      switch (sli.Op)                      {                      case ArgLocalOp.Ld:                          stack.Push                              (new ExpressionStackEntry                                   (cell.Read().CloneIfStruct(compEnv)' ReadArgLocalE(sli.ArgLocal' sli.Index)));                          return true;                      case ArgLocalOp.Lda:                          // Effect will be accounted for on reads/writes                          stack.Push(new ExpressionStackEntry(cell.AddressOf()' BottomE));                          return true;                      case ArgLocalOp.St:                          return stack.PopEvalSE                              (statements'                               1'                               true'                               WriteArgLocalE(sli.ArgLocal' sli.Index)'                               (s' a) => s.Add(new ExpressionStatement(cell.Write(a[0]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                          {                              stack.Push                                  (new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' ReadHeapE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                       {                                           var readEffect = default(Effects);                                           var obj = default(Expression);                                           if (fieldi.IsViaPointer.Value)                                           {                                               readEffect = e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect());                                               obj = new ReadExpression(a[0]); // no need for clone                                           }                                           else if (fieldi.Field.DefiningType.Style(compEnv) is ValueTypeStyle)                                           {                                               readEffect = e;                                               obj = a[0];                                           }                                           else                                           {                                               // Object could be null                                               readEffect = e.Lub(ReadHeapOrThrowE);                                               obj = a[0];                                           }                                           return new ExpressionStackEntry(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' readEffect);                                       });                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                          {                              // Effect will be accounted for on reads/writes                              stack.Push(new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' BottomE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   {                                       if (fieldi.IsViaPointer.Value)                                           // We're just adding an offset to a pointer' so effect will                                           // be accounted for when the final pointer is read/written                                           return new ExpressionStackEntry(new FieldCell(new ReadExpression(a[0])' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e);                                       else                                           // Must be a reference type' and ref could be null                                           return new ExpressionStackEntry(new FieldCell(a[0]' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e.Lub(ThrowsE));                                   });                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                              return stack.PopEvalSE                                  (statements'                                   1'                                   true'                                   WriteHeapE'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Write(a[0]))));                          else                          {                              var writeEffect = fieldi.IsViaPointer.Value                                                    ? instruction.BeforeState.PeekPointsTo(1).WriteEffect()                                                    : WriteHeapOrThrowE;                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   writeEffect'                                   (s' a) =>                                       {                                           var obj = fieldi.IsViaPointer.Value ? new ReadExpression(a[0]) : a[0];                                           s.Add(new ExpressionStatement(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Write(a[1])));                                       });                          }                      case FieldOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new FieldHandleConstantExpression(compEnv.SubstituteMember(fieldi.Field))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methodi = (MethodInstruction)instruction;                      var arity = methodi.Method.ValueParameters.Count;                      switch (methodi.Op)                      {                      case MethodOp.Ldftn:                          if (methodi.IsVirtual)                              // Object could be null                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CodePointerExpression(a[0]' compEnv.SubstituteMember(methodi.Method))' e.Lub(ReadHeapOrThrowE)));                          else                          {                              stack.Push                                  (new ExpressionStackEntry(new CodePointerExpression(null' compEnv.SubstituteMember(methodi.Method))' BottomE));                              return true;                          }                      case MethodOp.Call:                          if (methodi.Method.Result == null)                              return stack.PopEvalSE                                  (statements'                                   arity'                                   true'                                   CalleeEffects(methodi.BeforeState' arity)'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new CallExpression                                                 (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal'                                                  compEnv.SubstituteMember(methodi.Method)'                                                  CallerArguments(methodi.Constrained' methodi.Method' a)))));                          else                              return stack.PopEvalPush                                  (statements'                                   arity'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CallExpression                                            (methodi.IsVirtual? CallFlavor.Virtual : CallFlavor.Normal'                                             compEnv.SubstituteMember(methodi.Method)'                                             CallerArguments(methodi.Constrained' methodi.Method' a))'                                        e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Newobj:                          arity--;                          return stack.PopEvalPush                              (statements'                               arity'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new NewObjectExpression(compEnv.SubstituteMember(methodi.Method)' CallerArguments(null' methodi.Method' a))'                                    e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Ldtoken:                          stack.Push                              (new ExpressionStackEntry(new MethodHandleConstantExpression(compEnv.SubstituteMember(methodi.Method))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case TypeOp.Stobj:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case TypeOp.Cpobj:                          {                              var copyEffect = instruction.BeforeState.PeekPointsTo(0).ReadEffect().Lub                                  (instruction.BeforeState.PeekPointsTo(1).WriteEffect());                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   copyEffect'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new WriteExpression(a[0]' new ReadExpression(a[1]).CloneIfStruct(compEnv)))));                          }                      case TypeOp.Newarr:                          // Growing the heap is not considered an observable change. But will throw if                          // length < 0                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new NewArrayExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Initobj:                          return stack.PopEvalSE                              (statements' 1' true' WriteHeapE' (s' a) => s.Add(new InitializeObjectStatement(a[0])));                      case TypeOp.Castclass:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new CastExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Isinst:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new IsInstExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Box:                          // Growing the heap is not considered an observable change                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new NewBoxExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Unbox:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).AddressOf()' e.Lub(ThrowsE)));                      case TypeOp.UnboxAny:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).Read().CloneIfStruct(compEnv)' e.Lub(ThrowsE)));                      case TypeOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new TypeHandleConstantExpression(compEnv.SubstituteType(typei.Type))' BottomE));                          return true;                      case TypeOp.Ldelem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case TypeOp.Stelem:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add(new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  // Calculating the pointer may throw if index is out of range.                  // Remaining effect will be accounted for when pointer is read/written.                  return stack.PopEvalPush                      (statements'                       2'                       true'                       (a' e) =>                       new ExpressionStackEntry(new ElementCell(a[0]' a[1]' false).AddressOf()' e.Lub(ThrowsE)));              case InstructionFlavor.LdInt32:                  {                      var int32i = (LdInt32Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int32ConstantExpression(int32i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdInt64:                  {                      var int64i = (LdInt64Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int64ConstantExpression(int64i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdSingle:                  {                      var singlei = (LdSingleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new SingleConstantExpression(singlei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdDouble:                  {                      var doublei = (LdDoubleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new DoubleConstantExpression(doublei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdString:                  {                      var stringi = (LdStringInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new StringConstantExpression(stringi.Value)' BottomE));                      return true;                  }              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Div:                      case ArithOp.Rem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(ThrowsE)));                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                      case ArithOp.Shl:                      case ArithOp.Shr:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(arithi.WithOverflow ? ThrowsE : BottomE)));                      case ArithOp.Neg:                      case ArithOp.BitNot:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression                                        (a[0]' ArithOpToUnaryOp(arithi.Op)' arithi.WithOverflow' arithi.IsUnsigned)'                                    e));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      return stack.PopEvalPush                          (statements'                           1'                           true'                           (a' e) =>                           new ExpressionStackEntry                               (new ConvertExpression                                    (a[0]'                                     new NamedTypeRef                                         (compEnv.Global.NumberFlavorToQualifiedTypeName[convi.TargetNumberFlavor])'                                     convi.WithOverflow'                                     convi.IsSourceUnsigned)'                                e.Lub(convi.WithOverflow ? ThrowsE : BottomE)));                  }              case InstructionFlavor.Try:                  {                      if (stack.Depth > 0)                          throw new InvalidOperationException("stack must be empty on entry to try block");                      var tryi = (TryInstruction)instruction;                      var tryStatements = BlockToTryFaultFinallyStatements(tryi.Body);                      if (tryStatements == null)                          return false;                      var handlers = TranslateHandlers(tryi.Handlers);                      if (handlers == null)                          return false;                      if (statements == null)                          return Failed(false' "try");                      statements.Add(new TryStatement(tryStatements' handlers));                      return true;                  }              case InstructionFlavor.IfThenElsePseudo:                  {                      var itei = (IfThenElseInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(itei.Offset' out isExpr) ||                                              isExpr;                        if (!TranslateBlock(statements' itei.Condition' stack' exid))                          return false;                      if (couldBeExpression && itei.Else != null)                      {                          // Pass 1: Try to tranlate to an if-then-else expression. Will only work if Then and Else don't                          //         reach into current stack' push exactly one value' and don't need to emit any                          //         statements along the way.                          var thenEntry = BlockToExpression(itei.Then' exid);                          if (thenEntry != null)                          {                              var elseEntry = BlockToExpression(itei.Else' exid);                              if (elseEntry != null)                              {                                  if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                                      instructionTranslationStyleCache.Add(itei.Offset' true);                                  return stack.PopEvalPush                                      (statements'                                       1'                                       true'                                       (a' e) =>                                       new ExpressionStackEntry                                           (new IfThenElseExpression(a[0]' thenEntry.Expression' elseEntry.Expression)'                                            e.Lub(thenEntry.Effects.Lub(elseEntry.Effects))));                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      var noStackChange = itei.Then.NoStackChange && (itei.Else == null || itei.Else.NoStackChange);                      var condEntry = noStackChange                                          ? stack.Pop()                                          : stack.FlushAndPopPostState(statements' itei.Then.BeforeState);                      if (condEntry == null)                          return false;                      var thenStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Then' exid)                                           : BlockToStatements(itei.Then' exid);                      if (thenStmnts == null)                          return false;                      var elseStmnts = default(Seq<Statement>);                      if (itei.Else != null)                      {                          elseStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Else' exid)                                           : BlockToStatements(itei.Else' exid);                          if (elseStmnts == null)                              return false;                      }                      if (statements == null)                          return Failed(false' "if-then-else");                      statements.Add                          (new IfThenElseStatement(condEntry.Expression' new Statements(thenStmnts)' elseStmnts == null ? null : new Statements(elseStmnts)));                      if (!noStackChange && !stack.Restore(itei.AfterState' 0))                          return false;                      if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                          instructionTranslationStyleCache.Add(itei.Offset' false);                      return true;                  }              case InstructionFlavor.ShortCircuitingPseudo:                  {                      var sci = (ShortCircuitingInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(sci.Offset' out isExpr) ||                                              isExpr;                      if (couldBeExpression)                      {                          // Pass 1: Try to translate to an expression.                          var leftEntry = BlockToExpression(sci.Left' exid);                          if (leftEntry != null)                          {                              var rightEntry = BlockToExpression(sci.Right' exid);                              if (rightEntry != null)                              {                                  stack.Push                                      (new ExpressionStackEntry                                           (new BinaryExpression                                                (leftEntry.Expression'                                                 ShortCircuitingOpToBinaryOp(sci.Op)'                                                 rightEntry.Expression'                                                 false'                                                 false)'                                            leftEntry.Effects.Lub(rightEntry.Effects)));                                  if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                                      instructionTranslationStyleCache.Add(sci.Offset' true);                                  return true;                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      if (!TranslateBlock(statements' sci.Left' stack' exid))                          return false;                      var leftEntry2 = stack.FlushAndPopPostState(statements' sci.Right.BeforeState);                      if (leftEntry2 == null)                          return false;                      var rightStatements = BlockToStatements(sci.Right' exid);                      if (rightStatements == null)                          return false;                      var id = sci.Right.AfterState.PeekId(0' nameSupply.GenSym);                      var cell = new VariableCell(id);                      compEnv.AddVariable(id' ArgLocal.Local' false' true' compEnv.SubstituteType(sci.Right.AfterState.PeekType(0)));                      if (statements == null)                          return Failed(false' "short-circuit");                      switch (sci.Op)                      {                      case ShortCircuitingOp.And:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements(rightStatements)'                                    new Statements                                        (new ExpressionStatement(cell.Write(new Int32ConstantExpression(0))))));                          break;                      case ShortCircuitingOp.Or:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements                                        (new ExpressionStatement                                             (cell.Write(new Int32ConstantExpression(1))))'                                    new Statements(rightStatements)));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      if (!stack.Restore(sci.AfterState' 1))                          return false;                      stack.Push(new ExpressionStackEntry(cell.Read()' BottomE));                      if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                          instructionTranslationStyleCache.Add(sci.Offset' false);                      return true;                  }              case InstructionFlavor.StructuralSwitchPseudo:                  {                      var ssi = (StructuralSwitchInstruction)instruction;                      if (!TranslateBlock(statements' ssi.Body' stack' exid))                          return false;                      var valueEntry = stack.FlushAndPopPreState(statements' ssi.Body.AfterState);                      if (valueEntry == null)                          return false;                      var cases = new Seq<SwitchStatementCase>();                      foreach (var c in ssi.Cases)                      {                          var caseStatements = BlockToStatements(c.Body' exid);                          if (caseStatements == null)                              return false;                          cases.Add(new SwitchStatementCase(c.Values' new Statements(caseStatements)));                      }                      if (statements == null)                          return Failed(false' "structural switch");                      statements.Add(new SwitchStatement(valueEntry.Expression' cases));                      if (!stack.Restore(ssi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopPseudo:                  {                      var li = (LoopInstruction)instruction;                      if (!stack.Flush(statements' li.Body.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop");                      var whileStatements = BlockToStatements(li.Body' exid);                      statements.Add                          (new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(whileStatements)));                      if (!stack.Restore(li.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.WhileDoPseudo:                  {                      var wdi = (WhileDoInstruction)instruction;                      if (!stack.Flush(statements' wdi.Condition.BeforeState))                          return false;                      var condEntry = BlockToExpression(wdi.Condition' exid);                      if (condEntry == null)                      {                          var stack1 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Condition.BeforeState' trace);                          var preCondStatements = new Seq<Statement>();                          if (!TranslateBlock(preCondStatements' wdi.Condition' stack1' exid))                              return false;                          condEntry = stack1.FlushAndPopPostState(preCondStatements' wdi.Body.BeforeState);                          if (condEntry == null)                              return false;                          var stack2 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Body.BeforeState' trace);                          var postCondStatements = new Seq<Statement>();                          if (!TranslateBlock(postCondStatements' wdi.Body' stack2' exid))                              return false;                          if (!stack2.Flush(postCondStatements' wdi.Body.AfterState))                              return false;                          preCondStatements.Add                              (new IfThenElseStatement                                   (condEntry.Expression'                                    new Statements(postCondStatements)'                                    new Statements(new BreakStatement())));                          statements.Add(new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(preCondStatements)));                      }                      else                      {                          var loopStatements = BlockToStatements(wdi.Body' exid);                          if (loopStatements == null)                              return false;                          if (statements == null)                              return Failed(false' "while-do");                          statements.Add(new WhileDoStatement(condEntry.Expression' new Statements(loopStatements)));                      }                      if (!stack.Restore(wdi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.DoWhilePseudo:                  {                      var dwi = (DoWhileInstruction)instruction;                      if (!stack.Flush(statements' dwi.Body.BeforeState))                          return false;                      var combined = new Seq<Instruction>();                      foreach (var i in dwi.Body.Body)                          combined.Add(i);                      foreach (var i in dwi.Condition.Body)                          combined.Add(i);                      var condEntry = default(ExpressionStackEntry);                      var loopStatements = BlockToConditionStatements                          (new Instructions(null' combined)' dwi.Body.BeforeState' exid' out condEntry);                      if (loopStatements == null)                          return false;                      if (statements == null)                          return Failed(false' "do-while");                      statements.Add(new DoWhileStatement(new Statements(loopStatements)' condEntry.Expression));                      if (!stack.Restore(dwi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopControlPseudo:                  {                      var lci = (BreakContinueInstruction)instruction;                      if (!stack.Flush(statements' lci.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop-control");                      var targetState = default(int);                      switch (lci.Op)                      {                      case BreakContinueOp.Break:                          if (labelToLoopCandidateBreakState != null &&                              labelToLoopCandidateBreakState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new BreakStatement(lci.Label));                          break;                      case BreakContinueOp.Continue:                          if (labelToLoopCandidateContinueState != null &&                              labelToLoopCandidateContinueState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new ContinueStatement(lci.Label));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      return true;                  }              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return true;                      case MiscOp.Dup:                          return stack.Dup(statements);                      case MiscOp.Pop:                          return stack.PopAndDiscard(statements);                      case MiscOp.Ldnull:                          stack.Push(new ExpressionStackEntry(new NullConstantExpression()' BottomE));                          return true;                      case MiscOp.Ckfinite:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.CheckFinite' false' false)' e.Lub(ThrowsE)));                      case MiscOp.Throw:                          if (!stack.DiscardAll(statements' 1))                              return false;                          if (!stack.PopEvalSE(statements' 1' true' ThrowsE' (s' a) => s.Add(new ThrowStatement(a[0]))))                              return false;                          return true;                      case MiscOp.Rethrow:                          if (!stack.DiscardAll(statements' 0))                              return false;                          if (statements == null)                              return Failed(false' "rethrow");                          if (exid == null)                              throw new InvalidOperationException("rethrow outside of catch");                          statements.Add(new RethrowStatement(new VariableCell(exid).Read()));                          return true;                      case MiscOp.LdindRef:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case MiscOp.LdelemRef:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.Ldlen:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.Length' false' false)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.StindRef:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case MiscOp.StelemRef:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add                                   (new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      case MiscOp.Ret:                          if (statements == null)                              return Failed(false' "return");                          statements.Add(new ReturnStatement(null));                          return true;                      case MiscOp.RetVal:                          return stack.PopEvalSE                              (statements' 1' true' BottomE' (s' a) => s.Add(new ReturnStatement(a[0])));                      case MiscOp.Endfilter:                      case MiscOp.Endfinally:                          throw new InvalidOperationException                              ("endfilter/endfinally instructions should have been removed");                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:              case InstructionFlavor.Switch:                  throw new InvalidOperationException("branch/switch instructions should have been removed");              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      if (cmpi.Op == CompareOp.CtruePseudo || cmpi.Op == CompareOp.CfalsePseudo)                      {                          var s = cmpi.Type.Style(compEnv);                          var unop = default(UnaryOp);                          if (s is NumberTypeStyle)                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonZero : UnaryOp.IsZero;                          else                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonNull : UnaryOp.IsNull;                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new UnaryExpression(a[0]' unop' false' cmpi.IsUnsigned)' e));                      }                      else                      {                          var binop = default(BinaryOp);                          switch (cmpi.Op)                          {                          case CompareOp.Ceq:                              binop = BinaryOp.Eq;                              break;                          case CompareOp.Clt:                              binop = BinaryOp.Lt;                              break;                          case CompareOp.Cgt:                              binop = BinaryOp.Gt;                              break;                          case CompareOp.CgePseudo:                              binop = BinaryOp.Ge;                              break;                          case CompareOp.ClePseudo:                              binop = BinaryOp.Le;                              break;                          case CompareOp.CnePseudo:                              binop = BinaryOp.Ne;                              break;                          case CompareOp.CtruePseudo:                          case CompareOp.CfalsePseudo:                              // handled above                              throw new InvalidOperationException();                          default:                              throw new ArgumentOutOfRangeException();                          }                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression(a[0]' binop' a[1]' false' cmpi.IsUnsigned)' e));                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var sli = (ArgLocalInstruction)instruction;                      var id = default(JST.Identifier);                      switch (sli.ArgLocal)                      {                      case ArgLocal.Arg:                          id = compEnv.ValueParameterIds[sli.Index];                          break;                      case ArgLocal.Local:                          id = compEnv.LocalIds[sli.Index];                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      var cell = new VariableCell(id);                      switch (sli.Op)                      {                      case ArgLocalOp.Ld:                          stack.Push                              (new ExpressionStackEntry                                   (cell.Read().CloneIfStruct(compEnv)' ReadArgLocalE(sli.ArgLocal' sli.Index)));                          return true;                      case ArgLocalOp.Lda:                          // Effect will be accounted for on reads/writes                          stack.Push(new ExpressionStackEntry(cell.AddressOf()' BottomE));                          return true;                      case ArgLocalOp.St:                          return stack.PopEvalSE                              (statements'                               1'                               true'                               WriteArgLocalE(sli.ArgLocal' sli.Index)'                               (s' a) => s.Add(new ExpressionStatement(cell.Write(a[0]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                          {                              stack.Push                                  (new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' ReadHeapE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                       {                                           var readEffect = default(Effects);                                           var obj = default(Expression);                                           if (fieldi.IsViaPointer.Value)                                           {                                               readEffect = e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect());                                               obj = new ReadExpression(a[0]); // no need for clone                                           }                                           else if (fieldi.Field.DefiningType.Style(compEnv) is ValueTypeStyle)                                           {                                               readEffect = e;                                               obj = a[0];                                           }                                           else                                           {                                               // Object could be null                                               readEffect = e.Lub(ReadHeapOrThrowE);                                               obj = a[0];                                           }                                           return new ExpressionStackEntry(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' readEffect);                                       });                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                          {                              // Effect will be accounted for on reads/writes                              stack.Push(new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' BottomE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   {                                       if (fieldi.IsViaPointer.Value)                                           // We're just adding an offset to a pointer' so effect will                                           // be accounted for when the final pointer is read/written                                           return new ExpressionStackEntry(new FieldCell(new ReadExpression(a[0])' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e);                                       else                                           // Must be a reference type' and ref could be null                                           return new ExpressionStackEntry(new FieldCell(a[0]' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e.Lub(ThrowsE));                                   });                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                              return stack.PopEvalSE                                  (statements'                                   1'                                   true'                                   WriteHeapE'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Write(a[0]))));                          else                          {                              var writeEffect = fieldi.IsViaPointer.Value                                                    ? instruction.BeforeState.PeekPointsTo(1).WriteEffect()                                                    : WriteHeapOrThrowE;                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   writeEffect'                                   (s' a) =>                                       {                                           var obj = fieldi.IsViaPointer.Value ? new ReadExpression(a[0]) : a[0];                                           s.Add(new ExpressionStatement(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Write(a[1])));                                       });                          }                      case FieldOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new FieldHandleConstantExpression(compEnv.SubstituteMember(fieldi.Field))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methodi = (MethodInstruction)instruction;                      var arity = methodi.Method.ValueParameters.Count;                      switch (methodi.Op)                      {                      case MethodOp.Ldftn:                          if (methodi.IsVirtual)                              // Object could be null                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CodePointerExpression(a[0]' compEnv.SubstituteMember(methodi.Method))' e.Lub(ReadHeapOrThrowE)));                          else                          {                              stack.Push                                  (new ExpressionStackEntry(new CodePointerExpression(null' compEnv.SubstituteMember(methodi.Method))' BottomE));                              return true;                          }                      case MethodOp.Call:                          if (methodi.Method.Result == null)                              return stack.PopEvalSE                                  (statements'                                   arity'                                   true'                                   CalleeEffects(methodi.BeforeState' arity)'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new CallExpression                                                 (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal'                                                  compEnv.SubstituteMember(methodi.Method)'                                                  CallerArguments(methodi.Constrained' methodi.Method' a)))));                          else                              return stack.PopEvalPush                                  (statements'                                   arity'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CallExpression                                            (methodi.IsVirtual? CallFlavor.Virtual : CallFlavor.Normal'                                             compEnv.SubstituteMember(methodi.Method)'                                             CallerArguments(methodi.Constrained' methodi.Method' a))'                                        e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Newobj:                          arity--;                          return stack.PopEvalPush                              (statements'                               arity'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new NewObjectExpression(compEnv.SubstituteMember(methodi.Method)' CallerArguments(null' methodi.Method' a))'                                    e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Ldtoken:                          stack.Push                              (new ExpressionStackEntry(new MethodHandleConstantExpression(compEnv.SubstituteMember(methodi.Method))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case TypeOp.Stobj:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case TypeOp.Cpobj:                          {                              var copyEffect = instruction.BeforeState.PeekPointsTo(0).ReadEffect().Lub                                  (instruction.BeforeState.PeekPointsTo(1).WriteEffect());                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   copyEffect'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new WriteExpression(a[0]' new ReadExpression(a[1]).CloneIfStruct(compEnv)))));                          }                      case TypeOp.Newarr:                          // Growing the heap is not considered an observable change. But will throw if                          // length < 0                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new NewArrayExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Initobj:                          return stack.PopEvalSE                              (statements' 1' true' WriteHeapE' (s' a) => s.Add(new InitializeObjectStatement(a[0])));                      case TypeOp.Castclass:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new CastExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Isinst:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new IsInstExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Box:                          // Growing the heap is not considered an observable change                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new NewBoxExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Unbox:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).AddressOf()' e.Lub(ThrowsE)));                      case TypeOp.UnboxAny:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).Read().CloneIfStruct(compEnv)' e.Lub(ThrowsE)));                      case TypeOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new TypeHandleConstantExpression(compEnv.SubstituteType(typei.Type))' BottomE));                          return true;                      case TypeOp.Ldelem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case TypeOp.Stelem:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add(new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  // Calculating the pointer may throw if index is out of range.                  // Remaining effect will be accounted for when pointer is read/written.                  return stack.PopEvalPush                      (statements'                       2'                       true'                       (a' e) =>                       new ExpressionStackEntry(new ElementCell(a[0]' a[1]' false).AddressOf()' e.Lub(ThrowsE)));              case InstructionFlavor.LdInt32:                  {                      var int32i = (LdInt32Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int32ConstantExpression(int32i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdInt64:                  {                      var int64i = (LdInt64Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int64ConstantExpression(int64i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdSingle:                  {                      var singlei = (LdSingleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new SingleConstantExpression(singlei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdDouble:                  {                      var doublei = (LdDoubleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new DoubleConstantExpression(doublei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdString:                  {                      var stringi = (LdStringInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new StringConstantExpression(stringi.Value)' BottomE));                      return true;                  }              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Div:                      case ArithOp.Rem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(ThrowsE)));                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                      case ArithOp.Shl:                      case ArithOp.Shr:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(arithi.WithOverflow ? ThrowsE : BottomE)));                      case ArithOp.Neg:                      case ArithOp.BitNot:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression                                        (a[0]' ArithOpToUnaryOp(arithi.Op)' arithi.WithOverflow' arithi.IsUnsigned)'                                    e));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      return stack.PopEvalPush                          (statements'                           1'                           true'                           (a' e) =>                           new ExpressionStackEntry                               (new ConvertExpression                                    (a[0]'                                     new NamedTypeRef                                         (compEnv.Global.NumberFlavorToQualifiedTypeName[convi.TargetNumberFlavor])'                                     convi.WithOverflow'                                     convi.IsSourceUnsigned)'                                e.Lub(convi.WithOverflow ? ThrowsE : BottomE)));                  }              case InstructionFlavor.Try:                  {                      if (stack.Depth > 0)                          throw new InvalidOperationException("stack must be empty on entry to try block");                      var tryi = (TryInstruction)instruction;                      var tryStatements = BlockToTryFaultFinallyStatements(tryi.Body);                      if (tryStatements == null)                          return false;                      var handlers = TranslateHandlers(tryi.Handlers);                      if (handlers == null)                          return false;                      if (statements == null)                          return Failed(false' "try");                      statements.Add(new TryStatement(tryStatements' handlers));                      return true;                  }              case InstructionFlavor.IfThenElsePseudo:                  {                      var itei = (IfThenElseInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(itei.Offset' out isExpr) ||                                              isExpr;                        if (!TranslateBlock(statements' itei.Condition' stack' exid))                          return false;                      if (couldBeExpression && itei.Else != null)                      {                          // Pass 1: Try to tranlate to an if-then-else expression. Will only work if Then and Else don't                          //         reach into current stack' push exactly one value' and don't need to emit any                          //         statements along the way.                          var thenEntry = BlockToExpression(itei.Then' exid);                          if (thenEntry != null)                          {                              var elseEntry = BlockToExpression(itei.Else' exid);                              if (elseEntry != null)                              {                                  if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                                      instructionTranslationStyleCache.Add(itei.Offset' true);                                  return stack.PopEvalPush                                      (statements'                                       1'                                       true'                                       (a' e) =>                                       new ExpressionStackEntry                                           (new IfThenElseExpression(a[0]' thenEntry.Expression' elseEntry.Expression)'                                            e.Lub(thenEntry.Effects.Lub(elseEntry.Effects))));                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      var noStackChange = itei.Then.NoStackChange && (itei.Else == null || itei.Else.NoStackChange);                      var condEntry = noStackChange                                          ? stack.Pop()                                          : stack.FlushAndPopPostState(statements' itei.Then.BeforeState);                      if (condEntry == null)                          return false;                      var thenStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Then' exid)                                           : BlockToStatements(itei.Then' exid);                      if (thenStmnts == null)                          return false;                      var elseStmnts = default(Seq<Statement>);                      if (itei.Else != null)                      {                          elseStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Else' exid)                                           : BlockToStatements(itei.Else' exid);                          if (elseStmnts == null)                              return false;                      }                      if (statements == null)                          return Failed(false' "if-then-else");                      statements.Add                          (new IfThenElseStatement(condEntry.Expression' new Statements(thenStmnts)' elseStmnts == null ? null : new Statements(elseStmnts)));                      if (!noStackChange && !stack.Restore(itei.AfterState' 0))                          return false;                      if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                          instructionTranslationStyleCache.Add(itei.Offset' false);                      return true;                  }              case InstructionFlavor.ShortCircuitingPseudo:                  {                      var sci = (ShortCircuitingInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(sci.Offset' out isExpr) ||                                              isExpr;                      if (couldBeExpression)                      {                          // Pass 1: Try to translate to an expression.                          var leftEntry = BlockToExpression(sci.Left' exid);                          if (leftEntry != null)                          {                              var rightEntry = BlockToExpression(sci.Right' exid);                              if (rightEntry != null)                              {                                  stack.Push                                      (new ExpressionStackEntry                                           (new BinaryExpression                                                (leftEntry.Expression'                                                 ShortCircuitingOpToBinaryOp(sci.Op)'                                                 rightEntry.Expression'                                                 false'                                                 false)'                                            leftEntry.Effects.Lub(rightEntry.Effects)));                                  if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                                      instructionTranslationStyleCache.Add(sci.Offset' true);                                  return true;                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      if (!TranslateBlock(statements' sci.Left' stack' exid))                          return false;                      var leftEntry2 = stack.FlushAndPopPostState(statements' sci.Right.BeforeState);                      if (leftEntry2 == null)                          return false;                      var rightStatements = BlockToStatements(sci.Right' exid);                      if (rightStatements == null)                          return false;                      var id = sci.Right.AfterState.PeekId(0' nameSupply.GenSym);                      var cell = new VariableCell(id);                      compEnv.AddVariable(id' ArgLocal.Local' false' true' compEnv.SubstituteType(sci.Right.AfterState.PeekType(0)));                      if (statements == null)                          return Failed(false' "short-circuit");                      switch (sci.Op)                      {                      case ShortCircuitingOp.And:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements(rightStatements)'                                    new Statements                                        (new ExpressionStatement(cell.Write(new Int32ConstantExpression(0))))));                          break;                      case ShortCircuitingOp.Or:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements                                        (new ExpressionStatement                                             (cell.Write(new Int32ConstantExpression(1))))'                                    new Statements(rightStatements)));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      if (!stack.Restore(sci.AfterState' 1))                          return false;                      stack.Push(new ExpressionStackEntry(cell.Read()' BottomE));                      if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                          instructionTranslationStyleCache.Add(sci.Offset' false);                      return true;                  }              case InstructionFlavor.StructuralSwitchPseudo:                  {                      var ssi = (StructuralSwitchInstruction)instruction;                      if (!TranslateBlock(statements' ssi.Body' stack' exid))                          return false;                      var valueEntry = stack.FlushAndPopPreState(statements' ssi.Body.AfterState);                      if (valueEntry == null)                          return false;                      var cases = new Seq<SwitchStatementCase>();                      foreach (var c in ssi.Cases)                      {                          var caseStatements = BlockToStatements(c.Body' exid);                          if (caseStatements == null)                              return false;                          cases.Add(new SwitchStatementCase(c.Values' new Statements(caseStatements)));                      }                      if (statements == null)                          return Failed(false' "structural switch");                      statements.Add(new SwitchStatement(valueEntry.Expression' cases));                      if (!stack.Restore(ssi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopPseudo:                  {                      var li = (LoopInstruction)instruction;                      if (!stack.Flush(statements' li.Body.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop");                      var whileStatements = BlockToStatements(li.Body' exid);                      statements.Add                          (new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(whileStatements)));                      if (!stack.Restore(li.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.WhileDoPseudo:                  {                      var wdi = (WhileDoInstruction)instruction;                      if (!stack.Flush(statements' wdi.Condition.BeforeState))                          return false;                      var condEntry = BlockToExpression(wdi.Condition' exid);                      if (condEntry == null)                      {                          var stack1 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Condition.BeforeState' trace);                          var preCondStatements = new Seq<Statement>();                          if (!TranslateBlock(preCondStatements' wdi.Condition' stack1' exid))                              return false;                          condEntry = stack1.FlushAndPopPostState(preCondStatements' wdi.Body.BeforeState);                          if (condEntry == null)                              return false;                          var stack2 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Body.BeforeState' trace);                          var postCondStatements = new Seq<Statement>();                          if (!TranslateBlock(postCondStatements' wdi.Body' stack2' exid))                              return false;                          if (!stack2.Flush(postCondStatements' wdi.Body.AfterState))                              return false;                          preCondStatements.Add                              (new IfThenElseStatement                                   (condEntry.Expression'                                    new Statements(postCondStatements)'                                    new Statements(new BreakStatement())));                          statements.Add(new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(preCondStatements)));                      }                      else                      {                          var loopStatements = BlockToStatements(wdi.Body' exid);                          if (loopStatements == null)                              return false;                          if (statements == null)                              return Failed(false' "while-do");                          statements.Add(new WhileDoStatement(condEntry.Expression' new Statements(loopStatements)));                      }                      if (!stack.Restore(wdi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.DoWhilePseudo:                  {                      var dwi = (DoWhileInstruction)instruction;                      if (!stack.Flush(statements' dwi.Body.BeforeState))                          return false;                      var combined = new Seq<Instruction>();                      foreach (var i in dwi.Body.Body)                          combined.Add(i);                      foreach (var i in dwi.Condition.Body)                          combined.Add(i);                      var condEntry = default(ExpressionStackEntry);                      var loopStatements = BlockToConditionStatements                          (new Instructions(null' combined)' dwi.Body.BeforeState' exid' out condEntry);                      if (loopStatements == null)                          return false;                      if (statements == null)                          return Failed(false' "do-while");                      statements.Add(new DoWhileStatement(new Statements(loopStatements)' condEntry.Expression));                      if (!stack.Restore(dwi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopControlPseudo:                  {                      var lci = (BreakContinueInstruction)instruction;                      if (!stack.Flush(statements' lci.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop-control");                      var targetState = default(int);                      switch (lci.Op)                      {                      case BreakContinueOp.Break:                          if (labelToLoopCandidateBreakState != null &&                              labelToLoopCandidateBreakState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new BreakStatement(lci.Label));                          break;                      case BreakContinueOp.Continue:                          if (labelToLoopCandidateContinueState != null &&                              labelToLoopCandidateContinueState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new ContinueStatement(lci.Label));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      return true;                  }              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return true;                      case MiscOp.Dup:                          return stack.Dup(statements);                      case MiscOp.Pop:                          return stack.PopAndDiscard(statements);                      case MiscOp.Ldnull:                          stack.Push(new ExpressionStackEntry(new NullConstantExpression()' BottomE));                          return true;                      case MiscOp.Ckfinite:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.CheckFinite' false' false)' e.Lub(ThrowsE)));                      case MiscOp.Throw:                          if (!stack.DiscardAll(statements' 1))                              return false;                          if (!stack.PopEvalSE(statements' 1' true' ThrowsE' (s' a) => s.Add(new ThrowStatement(a[0]))))                              return false;                          return true;                      case MiscOp.Rethrow:                          if (!stack.DiscardAll(statements' 0))                              return false;                          if (statements == null)                              return Failed(false' "rethrow");                          if (exid == null)                              throw new InvalidOperationException("rethrow outside of catch");                          statements.Add(new RethrowStatement(new VariableCell(exid).Read()));                          return true;                      case MiscOp.LdindRef:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case MiscOp.LdelemRef:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.Ldlen:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.Length' false' false)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.StindRef:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case MiscOp.StelemRef:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add                                   (new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      case MiscOp.Ret:                          if (statements == null)                              return Failed(false' "return");                          statements.Add(new ReturnStatement(null));                          return true;                      case MiscOp.RetVal:                          return stack.PopEvalSE                              (statements' 1' true' BottomE' (s' a) => s.Add(new ReturnStatement(a[0])));                      case MiscOp.Endfilter:                      case MiscOp.Endfinally:                          throw new InvalidOperationException                              ("endfilter/endfinally instructions should have been removed");                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:              case InstructionFlavor.Switch:                  throw new InvalidOperationException("branch/switch instructions should have been removed");              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      if (cmpi.Op == CompareOp.CtruePseudo || cmpi.Op == CompareOp.CfalsePseudo)                      {                          var s = cmpi.Type.Style(compEnv);                          var unop = default(UnaryOp);                          if (s is NumberTypeStyle)                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonZero : UnaryOp.IsZero;                          else                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonNull : UnaryOp.IsNull;                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new UnaryExpression(a[0]' unop' false' cmpi.IsUnsigned)' e));                      }                      else                      {                          var binop = default(BinaryOp);                          switch (cmpi.Op)                          {                          case CompareOp.Ceq:                              binop = BinaryOp.Eq;                              break;                          case CompareOp.Clt:                              binop = BinaryOp.Lt;                              break;                          case CompareOp.Cgt:                              binop = BinaryOp.Gt;                              break;                          case CompareOp.CgePseudo:                              binop = BinaryOp.Ge;                              break;                          case CompareOp.ClePseudo:                              binop = BinaryOp.Le;                              break;                          case CompareOp.CnePseudo:                              binop = BinaryOp.Ne;                              break;                          case CompareOp.CtruePseudo:                          case CompareOp.CfalsePseudo:                              // handled above                              throw new InvalidOperationException();                          default:                              throw new ArgumentOutOfRangeException();                          }                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression(a[0]' binop' a[1]' false' cmpi.IsUnsigned)' e));                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var sli = (ArgLocalInstruction)instruction;                      var id = default(JST.Identifier);                      switch (sli.ArgLocal)                      {                      case ArgLocal.Arg:                          id = compEnv.ValueParameterIds[sli.Index];                          break;                      case ArgLocal.Local:                          id = compEnv.LocalIds[sli.Index];                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      var cell = new VariableCell(id);                      switch (sli.Op)                      {                      case ArgLocalOp.Ld:                          stack.Push                              (new ExpressionStackEntry                                   (cell.Read().CloneIfStruct(compEnv)' ReadArgLocalE(sli.ArgLocal' sli.Index)));                          return true;                      case ArgLocalOp.Lda:                          // Effect will be accounted for on reads/writes                          stack.Push(new ExpressionStackEntry(cell.AddressOf()' BottomE));                          return true;                      case ArgLocalOp.St:                          return stack.PopEvalSE                              (statements'                               1'                               true'                               WriteArgLocalE(sli.ArgLocal' sli.Index)'                               (s' a) => s.Add(new ExpressionStatement(cell.Write(a[0]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                          {                              stack.Push                                  (new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' ReadHeapE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                       {                                           var readEffect = default(Effects);                                           var obj = default(Expression);                                           if (fieldi.IsViaPointer.Value)                                           {                                               readEffect = e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect());                                               obj = new ReadExpression(a[0]); // no need for clone                                           }                                           else if (fieldi.Field.DefiningType.Style(compEnv) is ValueTypeStyle)                                           {                                               readEffect = e;                                               obj = a[0];                                           }                                           else                                           {                                               // Object could be null                                               readEffect = e.Lub(ReadHeapOrThrowE);                                               obj = a[0];                                           }                                           return new ExpressionStackEntry(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' readEffect);                                       });                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                          {                              // Effect will be accounted for on reads/writes                              stack.Push(new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' BottomE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   {                                       if (fieldi.IsViaPointer.Value)                                           // We're just adding an offset to a pointer' so effect will                                           // be accounted for when the final pointer is read/written                                           return new ExpressionStackEntry(new FieldCell(new ReadExpression(a[0])' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e);                                       else                                           // Must be a reference type' and ref could be null                                           return new ExpressionStackEntry(new FieldCell(a[0]' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e.Lub(ThrowsE));                                   });                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                              return stack.PopEvalSE                                  (statements'                                   1'                                   true'                                   WriteHeapE'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Write(a[0]))));                          else                          {                              var writeEffect = fieldi.IsViaPointer.Value                                                    ? instruction.BeforeState.PeekPointsTo(1).WriteEffect()                                                    : WriteHeapOrThrowE;                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   writeEffect'                                   (s' a) =>                                       {                                           var obj = fieldi.IsViaPointer.Value ? new ReadExpression(a[0]) : a[0];                                           s.Add(new ExpressionStatement(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Write(a[1])));                                       });                          }                      case FieldOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new FieldHandleConstantExpression(compEnv.SubstituteMember(fieldi.Field))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methodi = (MethodInstruction)instruction;                      var arity = methodi.Method.ValueParameters.Count;                      switch (methodi.Op)                      {                      case MethodOp.Ldftn:                          if (methodi.IsVirtual)                              // Object could be null                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CodePointerExpression(a[0]' compEnv.SubstituteMember(methodi.Method))' e.Lub(ReadHeapOrThrowE)));                          else                          {                              stack.Push                                  (new ExpressionStackEntry(new CodePointerExpression(null' compEnv.SubstituteMember(methodi.Method))' BottomE));                              return true;                          }                      case MethodOp.Call:                          if (methodi.Method.Result == null)                              return stack.PopEvalSE                                  (statements'                                   arity'                                   true'                                   CalleeEffects(methodi.BeforeState' arity)'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new CallExpression                                                 (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal'                                                  compEnv.SubstituteMember(methodi.Method)'                                                  CallerArguments(methodi.Constrained' methodi.Method' a)))));                          else                              return stack.PopEvalPush                                  (statements'                                   arity'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CallExpression                                            (methodi.IsVirtual? CallFlavor.Virtual : CallFlavor.Normal'                                             compEnv.SubstituteMember(methodi.Method)'                                             CallerArguments(methodi.Constrained' methodi.Method' a))'                                        e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Newobj:                          arity--;                          return stack.PopEvalPush                              (statements'                               arity'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new NewObjectExpression(compEnv.SubstituteMember(methodi.Method)' CallerArguments(null' methodi.Method' a))'                                    e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Ldtoken:                          stack.Push                              (new ExpressionStackEntry(new MethodHandleConstantExpression(compEnv.SubstituteMember(methodi.Method))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case TypeOp.Stobj:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case TypeOp.Cpobj:                          {                              var copyEffect = instruction.BeforeState.PeekPointsTo(0).ReadEffect().Lub                                  (instruction.BeforeState.PeekPointsTo(1).WriteEffect());                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   copyEffect'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new WriteExpression(a[0]' new ReadExpression(a[1]).CloneIfStruct(compEnv)))));                          }                      case TypeOp.Newarr:                          // Growing the heap is not considered an observable change. But will throw if                          // length < 0                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new NewArrayExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Initobj:                          return stack.PopEvalSE                              (statements' 1' true' WriteHeapE' (s' a) => s.Add(new InitializeObjectStatement(a[0])));                      case TypeOp.Castclass:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new CastExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Isinst:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new IsInstExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Box:                          // Growing the heap is not considered an observable change                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new NewBoxExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Unbox:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).AddressOf()' e.Lub(ThrowsE)));                      case TypeOp.UnboxAny:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).Read().CloneIfStruct(compEnv)' e.Lub(ThrowsE)));                      case TypeOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new TypeHandleConstantExpression(compEnv.SubstituteType(typei.Type))' BottomE));                          return true;                      case TypeOp.Ldelem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case TypeOp.Stelem:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add(new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  // Calculating the pointer may throw if index is out of range.                  // Remaining effect will be accounted for when pointer is read/written.                  return stack.PopEvalPush                      (statements'                       2'                       true'                       (a' e) =>                       new ExpressionStackEntry(new ElementCell(a[0]' a[1]' false).AddressOf()' e.Lub(ThrowsE)));              case InstructionFlavor.LdInt32:                  {                      var int32i = (LdInt32Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int32ConstantExpression(int32i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdInt64:                  {                      var int64i = (LdInt64Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int64ConstantExpression(int64i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdSingle:                  {                      var singlei = (LdSingleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new SingleConstantExpression(singlei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdDouble:                  {                      var doublei = (LdDoubleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new DoubleConstantExpression(doublei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdString:                  {                      var stringi = (LdStringInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new StringConstantExpression(stringi.Value)' BottomE));                      return true;                  }              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Div:                      case ArithOp.Rem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(ThrowsE)));                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                      case ArithOp.Shl:                      case ArithOp.Shr:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(arithi.WithOverflow ? ThrowsE : BottomE)));                      case ArithOp.Neg:                      case ArithOp.BitNot:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression                                        (a[0]' ArithOpToUnaryOp(arithi.Op)' arithi.WithOverflow' arithi.IsUnsigned)'                                    e));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      return stack.PopEvalPush                          (statements'                           1'                           true'                           (a' e) =>                           new ExpressionStackEntry                               (new ConvertExpression                                    (a[0]'                                     new NamedTypeRef                                         (compEnv.Global.NumberFlavorToQualifiedTypeName[convi.TargetNumberFlavor])'                                     convi.WithOverflow'                                     convi.IsSourceUnsigned)'                                e.Lub(convi.WithOverflow ? ThrowsE : BottomE)));                  }              case InstructionFlavor.Try:                  {                      if (stack.Depth > 0)                          throw new InvalidOperationException("stack must be empty on entry to try block");                      var tryi = (TryInstruction)instruction;                      var tryStatements = BlockToTryFaultFinallyStatements(tryi.Body);                      if (tryStatements == null)                          return false;                      var handlers = TranslateHandlers(tryi.Handlers);                      if (handlers == null)                          return false;                      if (statements == null)                          return Failed(false' "try");                      statements.Add(new TryStatement(tryStatements' handlers));                      return true;                  }              case InstructionFlavor.IfThenElsePseudo:                  {                      var itei = (IfThenElseInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(itei.Offset' out isExpr) ||                                              isExpr;                        if (!TranslateBlock(statements' itei.Condition' stack' exid))                          return false;                      if (couldBeExpression && itei.Else != null)                      {                          // Pass 1: Try to tranlate to an if-then-else expression. Will only work if Then and Else don't                          //         reach into current stack' push exactly one value' and don't need to emit any                          //         statements along the way.                          var thenEntry = BlockToExpression(itei.Then' exid);                          if (thenEntry != null)                          {                              var elseEntry = BlockToExpression(itei.Else' exid);                              if (elseEntry != null)                              {                                  if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                                      instructionTranslationStyleCache.Add(itei.Offset' true);                                  return stack.PopEvalPush                                      (statements'                                       1'                                       true'                                       (a' e) =>                                       new ExpressionStackEntry                                           (new IfThenElseExpression(a[0]' thenEntry.Expression' elseEntry.Expression)'                                            e.Lub(thenEntry.Effects.Lub(elseEntry.Effects))));                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      var noStackChange = itei.Then.NoStackChange && (itei.Else == null || itei.Else.NoStackChange);                      var condEntry = noStackChange                                          ? stack.Pop()                                          : stack.FlushAndPopPostState(statements' itei.Then.BeforeState);                      if (condEntry == null)                          return false;                      var thenStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Then' exid)                                           : BlockToStatements(itei.Then' exid);                      if (thenStmnts == null)                          return false;                      var elseStmnts = default(Seq<Statement>);                      if (itei.Else != null)                      {                          elseStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Else' exid)                                           : BlockToStatements(itei.Else' exid);                          if (elseStmnts == null)                              return false;                      }                      if (statements == null)                          return Failed(false' "if-then-else");                      statements.Add                          (new IfThenElseStatement(condEntry.Expression' new Statements(thenStmnts)' elseStmnts == null ? null : new Statements(elseStmnts)));                      if (!noStackChange && !stack.Restore(itei.AfterState' 0))                          return false;                      if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                          instructionTranslationStyleCache.Add(itei.Offset' false);                      return true;                  }              case InstructionFlavor.ShortCircuitingPseudo:                  {                      var sci = (ShortCircuitingInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(sci.Offset' out isExpr) ||                                              isExpr;                      if (couldBeExpression)                      {                          // Pass 1: Try to translate to an expression.                          var leftEntry = BlockToExpression(sci.Left' exid);                          if (leftEntry != null)                          {                              var rightEntry = BlockToExpression(sci.Right' exid);                              if (rightEntry != null)                              {                                  stack.Push                                      (new ExpressionStackEntry                                           (new BinaryExpression                                                (leftEntry.Expression'                                                 ShortCircuitingOpToBinaryOp(sci.Op)'                                                 rightEntry.Expression'                                                 false'                                                 false)'                                            leftEntry.Effects.Lub(rightEntry.Effects)));                                  if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                                      instructionTranslationStyleCache.Add(sci.Offset' true);                                  return true;                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      if (!TranslateBlock(statements' sci.Left' stack' exid))                          return false;                      var leftEntry2 = stack.FlushAndPopPostState(statements' sci.Right.BeforeState);                      if (leftEntry2 == null)                          return false;                      var rightStatements = BlockToStatements(sci.Right' exid);                      if (rightStatements == null)                          return false;                      var id = sci.Right.AfterState.PeekId(0' nameSupply.GenSym);                      var cell = new VariableCell(id);                      compEnv.AddVariable(id' ArgLocal.Local' false' true' compEnv.SubstituteType(sci.Right.AfterState.PeekType(0)));                      if (statements == null)                          return Failed(false' "short-circuit");                      switch (sci.Op)                      {                      case ShortCircuitingOp.And:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements(rightStatements)'                                    new Statements                                        (new ExpressionStatement(cell.Write(new Int32ConstantExpression(0))))));                          break;                      case ShortCircuitingOp.Or:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements                                        (new ExpressionStatement                                             (cell.Write(new Int32ConstantExpression(1))))'                                    new Statements(rightStatements)));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      if (!stack.Restore(sci.AfterState' 1))                          return false;                      stack.Push(new ExpressionStackEntry(cell.Read()' BottomE));                      if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                          instructionTranslationStyleCache.Add(sci.Offset' false);                      return true;                  }              case InstructionFlavor.StructuralSwitchPseudo:                  {                      var ssi = (StructuralSwitchInstruction)instruction;                      if (!TranslateBlock(statements' ssi.Body' stack' exid))                          return false;                      var valueEntry = stack.FlushAndPopPreState(statements' ssi.Body.AfterState);                      if (valueEntry == null)                          return false;                      var cases = new Seq<SwitchStatementCase>();                      foreach (var c in ssi.Cases)                      {                          var caseStatements = BlockToStatements(c.Body' exid);                          if (caseStatements == null)                              return false;                          cases.Add(new SwitchStatementCase(c.Values' new Statements(caseStatements)));                      }                      if (statements == null)                          return Failed(false' "structural switch");                      statements.Add(new SwitchStatement(valueEntry.Expression' cases));                      if (!stack.Restore(ssi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopPseudo:                  {                      var li = (LoopInstruction)instruction;                      if (!stack.Flush(statements' li.Body.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop");                      var whileStatements = BlockToStatements(li.Body' exid);                      statements.Add                          (new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(whileStatements)));                      if (!stack.Restore(li.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.WhileDoPseudo:                  {                      var wdi = (WhileDoInstruction)instruction;                      if (!stack.Flush(statements' wdi.Condition.BeforeState))                          return false;                      var condEntry = BlockToExpression(wdi.Condition' exid);                      if (condEntry == null)                      {                          var stack1 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Condition.BeforeState' trace);                          var preCondStatements = new Seq<Statement>();                          if (!TranslateBlock(preCondStatements' wdi.Condition' stack1' exid))                              return false;                          condEntry = stack1.FlushAndPopPostState(preCondStatements' wdi.Body.BeforeState);                          if (condEntry == null)                              return false;                          var stack2 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Body.BeforeState' trace);                          var postCondStatements = new Seq<Statement>();                          if (!TranslateBlock(postCondStatements' wdi.Body' stack2' exid))                              return false;                          if (!stack2.Flush(postCondStatements' wdi.Body.AfterState))                              return false;                          preCondStatements.Add                              (new IfThenElseStatement                                   (condEntry.Expression'                                    new Statements(postCondStatements)'                                    new Statements(new BreakStatement())));                          statements.Add(new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(preCondStatements)));                      }                      else                      {                          var loopStatements = BlockToStatements(wdi.Body' exid);                          if (loopStatements == null)                              return false;                          if (statements == null)                              return Failed(false' "while-do");                          statements.Add(new WhileDoStatement(condEntry.Expression' new Statements(loopStatements)));                      }                      if (!stack.Restore(wdi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.DoWhilePseudo:                  {                      var dwi = (DoWhileInstruction)instruction;                      if (!stack.Flush(statements' dwi.Body.BeforeState))                          return false;                      var combined = new Seq<Instruction>();                      foreach (var i in dwi.Body.Body)                          combined.Add(i);                      foreach (var i in dwi.Condition.Body)                          combined.Add(i);                      var condEntry = default(ExpressionStackEntry);                      var loopStatements = BlockToConditionStatements                          (new Instructions(null' combined)' dwi.Body.BeforeState' exid' out condEntry);                      if (loopStatements == null)                          return false;                      if (statements == null)                          return Failed(false' "do-while");                      statements.Add(new DoWhileStatement(new Statements(loopStatements)' condEntry.Expression));                      if (!stack.Restore(dwi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopControlPseudo:                  {                      var lci = (BreakContinueInstruction)instruction;                      if (!stack.Flush(statements' lci.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop-control");                      var targetState = default(int);                      switch (lci.Op)                      {                      case BreakContinueOp.Break:                          if (labelToLoopCandidateBreakState != null &&                              labelToLoopCandidateBreakState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new BreakStatement(lci.Label));                          break;                      case BreakContinueOp.Continue:                          if (labelToLoopCandidateContinueState != null &&                              labelToLoopCandidateContinueState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new ContinueStatement(lci.Label));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      return true;                  }              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return true;                      case MiscOp.Dup:                          return stack.Dup(statements);                      case MiscOp.Pop:                          return stack.PopAndDiscard(statements);                      case MiscOp.Ldnull:                          stack.Push(new ExpressionStackEntry(new NullConstantExpression()' BottomE));                          return true;                      case MiscOp.Ckfinite:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.CheckFinite' false' false)' e.Lub(ThrowsE)));                      case MiscOp.Throw:                          if (!stack.DiscardAll(statements' 1))                              return false;                          if (!stack.PopEvalSE(statements' 1' true' ThrowsE' (s' a) => s.Add(new ThrowStatement(a[0]))))                              return false;                          return true;                      case MiscOp.Rethrow:                          if (!stack.DiscardAll(statements' 0))                              return false;                          if (statements == null)                              return Failed(false' "rethrow");                          if (exid == null)                              throw new InvalidOperationException("rethrow outside of catch");                          statements.Add(new RethrowStatement(new VariableCell(exid).Read()));                          return true;                      case MiscOp.LdindRef:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case MiscOp.LdelemRef:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.Ldlen:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.Length' false' false)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.StindRef:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case MiscOp.StelemRef:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add                                   (new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      case MiscOp.Ret:                          if (statements == null)                              return Failed(false' "return");                          statements.Add(new ReturnStatement(null));                          return true;                      case MiscOp.RetVal:                          return stack.PopEvalSE                              (statements' 1' true' BottomE' (s' a) => s.Add(new ReturnStatement(a[0])));                      case MiscOp.Endfilter:                      case MiscOp.Endfinally:                          throw new InvalidOperationException                              ("endfilter/endfinally instructions should have been removed");                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:              case InstructionFlavor.Switch:                  throw new InvalidOperationException("branch/switch instructions should have been removed");              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      if (cmpi.Op == CompareOp.CtruePseudo || cmpi.Op == CompareOp.CfalsePseudo)                      {                          var s = cmpi.Type.Style(compEnv);                          var unop = default(UnaryOp);                          if (s is NumberTypeStyle)                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonZero : UnaryOp.IsZero;                          else                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonNull : UnaryOp.IsNull;                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new UnaryExpression(a[0]' unop' false' cmpi.IsUnsigned)' e));                      }                      else                      {                          var binop = default(BinaryOp);                          switch (cmpi.Op)                          {                          case CompareOp.Ceq:                              binop = BinaryOp.Eq;                              break;                          case CompareOp.Clt:                              binop = BinaryOp.Lt;                              break;                          case CompareOp.Cgt:                              binop = BinaryOp.Gt;                              break;                          case CompareOp.CgePseudo:                              binop = BinaryOp.Ge;                              break;                          case CompareOp.ClePseudo:                              binop = BinaryOp.Le;                              break;                          case CompareOp.CnePseudo:                              binop = BinaryOp.Ne;                              break;                          case CompareOp.CtruePseudo:                          case CompareOp.CfalsePseudo:                              // handled above                              throw new InvalidOperationException();                          default:                              throw new ArgumentOutOfRangeException();                          }                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression(a[0]' binop' a[1]' false' cmpi.IsUnsigned)' e));                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var sli = (ArgLocalInstruction)instruction;                      var id = default(JST.Identifier);                      switch (sli.ArgLocal)                      {                      case ArgLocal.Arg:                          id = compEnv.ValueParameterIds[sli.Index];                          break;                      case ArgLocal.Local:                          id = compEnv.LocalIds[sli.Index];                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      var cell = new VariableCell(id);                      switch (sli.Op)                      {                      case ArgLocalOp.Ld:                          stack.Push                              (new ExpressionStackEntry                                   (cell.Read().CloneIfStruct(compEnv)' ReadArgLocalE(sli.ArgLocal' sli.Index)));                          return true;                      case ArgLocalOp.Lda:                          // Effect will be accounted for on reads/writes                          stack.Push(new ExpressionStackEntry(cell.AddressOf()' BottomE));                          return true;                      case ArgLocalOp.St:                          return stack.PopEvalSE                              (statements'                               1'                               true'                               WriteArgLocalE(sli.ArgLocal' sli.Index)'                               (s' a) => s.Add(new ExpressionStatement(cell.Write(a[0]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                          {                              stack.Push                                  (new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' ReadHeapE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                       {                                           var readEffect = default(Effects);                                           var obj = default(Expression);                                           if (fieldi.IsViaPointer.Value)                                           {                                               readEffect = e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect());                                               obj = new ReadExpression(a[0]); // no need for clone                                           }                                           else if (fieldi.Field.DefiningType.Style(compEnv) is ValueTypeStyle)                                           {                                               readEffect = e;                                               obj = a[0];                                           }                                           else                                           {                                               // Object could be null                                               readEffect = e.Lub(ReadHeapOrThrowE);                                               obj = a[0];                                           }                                           return new ExpressionStackEntry(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' readEffect);                                       });                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                          {                              // Effect will be accounted for on reads/writes                              stack.Push(new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' BottomE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   {                                       if (fieldi.IsViaPointer.Value)                                           // We're just adding an offset to a pointer' so effect will                                           // be accounted for when the final pointer is read/written                                           return new ExpressionStackEntry(new FieldCell(new ReadExpression(a[0])' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e);                                       else                                           // Must be a reference type' and ref could be null                                           return new ExpressionStackEntry(new FieldCell(a[0]' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e.Lub(ThrowsE));                                   });                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                              return stack.PopEvalSE                                  (statements'                                   1'                                   true'                                   WriteHeapE'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Write(a[0]))));                          else                          {                              var writeEffect = fieldi.IsViaPointer.Value                                                    ? instruction.BeforeState.PeekPointsTo(1).WriteEffect()                                                    : WriteHeapOrThrowE;                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   writeEffect'                                   (s' a) =>                                       {                                           var obj = fieldi.IsViaPointer.Value ? new ReadExpression(a[0]) : a[0];                                           s.Add(new ExpressionStatement(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Write(a[1])));                                       });                          }                      case FieldOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new FieldHandleConstantExpression(compEnv.SubstituteMember(fieldi.Field))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methodi = (MethodInstruction)instruction;                      var arity = methodi.Method.ValueParameters.Count;                      switch (methodi.Op)                      {                      case MethodOp.Ldftn:                          if (methodi.IsVirtual)                              // Object could be null                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CodePointerExpression(a[0]' compEnv.SubstituteMember(methodi.Method))' e.Lub(ReadHeapOrThrowE)));                          else                          {                              stack.Push                                  (new ExpressionStackEntry(new CodePointerExpression(null' compEnv.SubstituteMember(methodi.Method))' BottomE));                              return true;                          }                      case MethodOp.Call:                          if (methodi.Method.Result == null)                              return stack.PopEvalSE                                  (statements'                                   arity'                                   true'                                   CalleeEffects(methodi.BeforeState' arity)'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new CallExpression                                                 (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal'                                                  compEnv.SubstituteMember(methodi.Method)'                                                  CallerArguments(methodi.Constrained' methodi.Method' a)))));                          else                              return stack.PopEvalPush                                  (statements'                                   arity'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CallExpression                                            (methodi.IsVirtual? CallFlavor.Virtual : CallFlavor.Normal'                                             compEnv.SubstituteMember(methodi.Method)'                                             CallerArguments(methodi.Constrained' methodi.Method' a))'                                        e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Newobj:                          arity--;                          return stack.PopEvalPush                              (statements'                               arity'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new NewObjectExpression(compEnv.SubstituteMember(methodi.Method)' CallerArguments(null' methodi.Method' a))'                                    e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Ldtoken:                          stack.Push                              (new ExpressionStackEntry(new MethodHandleConstantExpression(compEnv.SubstituteMember(methodi.Method))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case TypeOp.Stobj:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case TypeOp.Cpobj:                          {                              var copyEffect = instruction.BeforeState.PeekPointsTo(0).ReadEffect().Lub                                  (instruction.BeforeState.PeekPointsTo(1).WriteEffect());                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   copyEffect'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new WriteExpression(a[0]' new ReadExpression(a[1]).CloneIfStruct(compEnv)))));                          }                      case TypeOp.Newarr:                          // Growing the heap is not considered an observable change. But will throw if                          // length < 0                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new NewArrayExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Initobj:                          return stack.PopEvalSE                              (statements' 1' true' WriteHeapE' (s' a) => s.Add(new InitializeObjectStatement(a[0])));                      case TypeOp.Castclass:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new CastExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Isinst:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new IsInstExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Box:                          // Growing the heap is not considered an observable change                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new NewBoxExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Unbox:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).AddressOf()' e.Lub(ThrowsE)));                      case TypeOp.UnboxAny:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).Read().CloneIfStruct(compEnv)' e.Lub(ThrowsE)));                      case TypeOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new TypeHandleConstantExpression(compEnv.SubstituteType(typei.Type))' BottomE));                          return true;                      case TypeOp.Ldelem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case TypeOp.Stelem:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add(new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  // Calculating the pointer may throw if index is out of range.                  // Remaining effect will be accounted for when pointer is read/written.                  return stack.PopEvalPush                      (statements'                       2'                       true'                       (a' e) =>                       new ExpressionStackEntry(new ElementCell(a[0]' a[1]' false).AddressOf()' e.Lub(ThrowsE)));              case InstructionFlavor.LdInt32:                  {                      var int32i = (LdInt32Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int32ConstantExpression(int32i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdInt64:                  {                      var int64i = (LdInt64Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int64ConstantExpression(int64i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdSingle:                  {                      var singlei = (LdSingleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new SingleConstantExpression(singlei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdDouble:                  {                      var doublei = (LdDoubleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new DoubleConstantExpression(doublei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdString:                  {                      var stringi = (LdStringInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new StringConstantExpression(stringi.Value)' BottomE));                      return true;                  }              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Div:                      case ArithOp.Rem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(ThrowsE)));                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                      case ArithOp.Shl:                      case ArithOp.Shr:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(arithi.WithOverflow ? ThrowsE : BottomE)));                      case ArithOp.Neg:                      case ArithOp.BitNot:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression                                        (a[0]' ArithOpToUnaryOp(arithi.Op)' arithi.WithOverflow' arithi.IsUnsigned)'                                    e));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      return stack.PopEvalPush                          (statements'                           1'                           true'                           (a' e) =>                           new ExpressionStackEntry                               (new ConvertExpression                                    (a[0]'                                     new NamedTypeRef                                         (compEnv.Global.NumberFlavorToQualifiedTypeName[convi.TargetNumberFlavor])'                                     convi.WithOverflow'                                     convi.IsSourceUnsigned)'                                e.Lub(convi.WithOverflow ? ThrowsE : BottomE)));                  }              case InstructionFlavor.Try:                  {                      if (stack.Depth > 0)                          throw new InvalidOperationException("stack must be empty on entry to try block");                      var tryi = (TryInstruction)instruction;                      var tryStatements = BlockToTryFaultFinallyStatements(tryi.Body);                      if (tryStatements == null)                          return false;                      var handlers = TranslateHandlers(tryi.Handlers);                      if (handlers == null)                          return false;                      if (statements == null)                          return Failed(false' "try");                      statements.Add(new TryStatement(tryStatements' handlers));                      return true;                  }              case InstructionFlavor.IfThenElsePseudo:                  {                      var itei = (IfThenElseInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(itei.Offset' out isExpr) ||                                              isExpr;                        if (!TranslateBlock(statements' itei.Condition' stack' exid))                          return false;                      if (couldBeExpression && itei.Else != null)                      {                          // Pass 1: Try to tranlate to an if-then-else expression. Will only work if Then and Else don't                          //         reach into current stack' push exactly one value' and don't need to emit any                          //         statements along the way.                          var thenEntry = BlockToExpression(itei.Then' exid);                          if (thenEntry != null)                          {                              var elseEntry = BlockToExpression(itei.Else' exid);                              if (elseEntry != null)                              {                                  if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                                      instructionTranslationStyleCache.Add(itei.Offset' true);                                  return stack.PopEvalPush                                      (statements'                                       1'                                       true'                                       (a' e) =>                                       new ExpressionStackEntry                                           (new IfThenElseExpression(a[0]' thenEntry.Expression' elseEntry.Expression)'                                            e.Lub(thenEntry.Effects.Lub(elseEntry.Effects))));                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      var noStackChange = itei.Then.NoStackChange && (itei.Else == null || itei.Else.NoStackChange);                      var condEntry = noStackChange                                          ? stack.Pop()                                          : stack.FlushAndPopPostState(statements' itei.Then.BeforeState);                      if (condEntry == null)                          return false;                      var thenStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Then' exid)                                           : BlockToStatements(itei.Then' exid);                      if (thenStmnts == null)                          return false;                      var elseStmnts = default(Seq<Statement>);                      if (itei.Else != null)                      {                          elseStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Else' exid)                                           : BlockToStatements(itei.Else' exid);                          if (elseStmnts == null)                              return false;                      }                      if (statements == null)                          return Failed(false' "if-then-else");                      statements.Add                          (new IfThenElseStatement(condEntry.Expression' new Statements(thenStmnts)' elseStmnts == null ? null : new Statements(elseStmnts)));                      if (!noStackChange && !stack.Restore(itei.AfterState' 0))                          return false;                      if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                          instructionTranslationStyleCache.Add(itei.Offset' false);                      return true;                  }              case InstructionFlavor.ShortCircuitingPseudo:                  {                      var sci = (ShortCircuitingInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(sci.Offset' out isExpr) ||                                              isExpr;                      if (couldBeExpression)                      {                          // Pass 1: Try to translate to an expression.                          var leftEntry = BlockToExpression(sci.Left' exid);                          if (leftEntry != null)                          {                              var rightEntry = BlockToExpression(sci.Right' exid);                              if (rightEntry != null)                              {                                  stack.Push                                      (new ExpressionStackEntry                                           (new BinaryExpression                                                (leftEntry.Expression'                                                 ShortCircuitingOpToBinaryOp(sci.Op)'                                                 rightEntry.Expression'                                                 false'                                                 false)'                                            leftEntry.Effects.Lub(rightEntry.Effects)));                                  if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                                      instructionTranslationStyleCache.Add(sci.Offset' true);                                  return true;                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      if (!TranslateBlock(statements' sci.Left' stack' exid))                          return false;                      var leftEntry2 = stack.FlushAndPopPostState(statements' sci.Right.BeforeState);                      if (leftEntry2 == null)                          return false;                      var rightStatements = BlockToStatements(sci.Right' exid);                      if (rightStatements == null)                          return false;                      var id = sci.Right.AfterState.PeekId(0' nameSupply.GenSym);                      var cell = new VariableCell(id);                      compEnv.AddVariable(id' ArgLocal.Local' false' true' compEnv.SubstituteType(sci.Right.AfterState.PeekType(0)));                      if (statements == null)                          return Failed(false' "short-circuit");                      switch (sci.Op)                      {                      case ShortCircuitingOp.And:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements(rightStatements)'                                    new Statements                                        (new ExpressionStatement(cell.Write(new Int32ConstantExpression(0))))));                          break;                      case ShortCircuitingOp.Or:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements                                        (new ExpressionStatement                                             (cell.Write(new Int32ConstantExpression(1))))'                                    new Statements(rightStatements)));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      if (!stack.Restore(sci.AfterState' 1))                          return false;                      stack.Push(new ExpressionStackEntry(cell.Read()' BottomE));                      if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                          instructionTranslationStyleCache.Add(sci.Offset' false);                      return true;                  }              case InstructionFlavor.StructuralSwitchPseudo:                  {                      var ssi = (StructuralSwitchInstruction)instruction;                      if (!TranslateBlock(statements' ssi.Body' stack' exid))                          return false;                      var valueEntry = stack.FlushAndPopPreState(statements' ssi.Body.AfterState);                      if (valueEntry == null)                          return false;                      var cases = new Seq<SwitchStatementCase>();                      foreach (var c in ssi.Cases)                      {                          var caseStatements = BlockToStatements(c.Body' exid);                          if (caseStatements == null)                              return false;                          cases.Add(new SwitchStatementCase(c.Values' new Statements(caseStatements)));                      }                      if (statements == null)                          return Failed(false' "structural switch");                      statements.Add(new SwitchStatement(valueEntry.Expression' cases));                      if (!stack.Restore(ssi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopPseudo:                  {                      var li = (LoopInstruction)instruction;                      if (!stack.Flush(statements' li.Body.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop");                      var whileStatements = BlockToStatements(li.Body' exid);                      statements.Add                          (new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(whileStatements)));                      if (!stack.Restore(li.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.WhileDoPseudo:                  {                      var wdi = (WhileDoInstruction)instruction;                      if (!stack.Flush(statements' wdi.Condition.BeforeState))                          return false;                      var condEntry = BlockToExpression(wdi.Condition' exid);                      if (condEntry == null)                      {                          var stack1 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Condition.BeforeState' trace);                          var preCondStatements = new Seq<Statement>();                          if (!TranslateBlock(preCondStatements' wdi.Condition' stack1' exid))                              return false;                          condEntry = stack1.FlushAndPopPostState(preCondStatements' wdi.Body.BeforeState);                          if (condEntry == null)                              return false;                          var stack2 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Body.BeforeState' trace);                          var postCondStatements = new Seq<Statement>();                          if (!TranslateBlock(postCondStatements' wdi.Body' stack2' exid))                              return false;                          if (!stack2.Flush(postCondStatements' wdi.Body.AfterState))                              return false;                          preCondStatements.Add                              (new IfThenElseStatement                                   (condEntry.Expression'                                    new Statements(postCondStatements)'                                    new Statements(new BreakStatement())));                          statements.Add(new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(preCondStatements)));                      }                      else                      {                          var loopStatements = BlockToStatements(wdi.Body' exid);                          if (loopStatements == null)                              return false;                          if (statements == null)                              return Failed(false' "while-do");                          statements.Add(new WhileDoStatement(condEntry.Expression' new Statements(loopStatements)));                      }                      if (!stack.Restore(wdi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.DoWhilePseudo:                  {                      var dwi = (DoWhileInstruction)instruction;                      if (!stack.Flush(statements' dwi.Body.BeforeState))                          return false;                      var combined = new Seq<Instruction>();                      foreach (var i in dwi.Body.Body)                          combined.Add(i);                      foreach (var i in dwi.Condition.Body)                          combined.Add(i);                      var condEntry = default(ExpressionStackEntry);                      var loopStatements = BlockToConditionStatements                          (new Instructions(null' combined)' dwi.Body.BeforeState' exid' out condEntry);                      if (loopStatements == null)                          return false;                      if (statements == null)                          return Failed(false' "do-while");                      statements.Add(new DoWhileStatement(new Statements(loopStatements)' condEntry.Expression));                      if (!stack.Restore(dwi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopControlPseudo:                  {                      var lci = (BreakContinueInstruction)instruction;                      if (!stack.Flush(statements' lci.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop-control");                      var targetState = default(int);                      switch (lci.Op)                      {                      case BreakContinueOp.Break:                          if (labelToLoopCandidateBreakState != null &&                              labelToLoopCandidateBreakState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new BreakStatement(lci.Label));                          break;                      case BreakContinueOp.Continue:                          if (labelToLoopCandidateContinueState != null &&                              labelToLoopCandidateContinueState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new ContinueStatement(lci.Label));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      return true;                  }              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return true;                      case MiscOp.Dup:                          return stack.Dup(statements);                      case MiscOp.Pop:                          return stack.PopAndDiscard(statements);                      case MiscOp.Ldnull:                          stack.Push(new ExpressionStackEntry(new NullConstantExpression()' BottomE));                          return true;                      case MiscOp.Ckfinite:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.CheckFinite' false' false)' e.Lub(ThrowsE)));                      case MiscOp.Throw:                          if (!stack.DiscardAll(statements' 1))                              return false;                          if (!stack.PopEvalSE(statements' 1' true' ThrowsE' (s' a) => s.Add(new ThrowStatement(a[0]))))                              return false;                          return true;                      case MiscOp.Rethrow:                          if (!stack.DiscardAll(statements' 0))                              return false;                          if (statements == null)                              return Failed(false' "rethrow");                          if (exid == null)                              throw new InvalidOperationException("rethrow outside of catch");                          statements.Add(new RethrowStatement(new VariableCell(exid).Read()));                          return true;                      case MiscOp.LdindRef:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case MiscOp.LdelemRef:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.Ldlen:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.Length' false' false)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.StindRef:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case MiscOp.StelemRef:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add                                   (new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      case MiscOp.Ret:                          if (statements == null)                              return Failed(false' "return");                          statements.Add(new ReturnStatement(null));                          return true;                      case MiscOp.RetVal:                          return stack.PopEvalSE                              (statements' 1' true' BottomE' (s' a) => s.Add(new ReturnStatement(a[0])));                      case MiscOp.Endfilter:                      case MiscOp.Endfinally:                          throw new InvalidOperationException                              ("endfilter/endfinally instructions should have been removed");                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:              case InstructionFlavor.Switch:                  throw new InvalidOperationException("branch/switch instructions should have been removed");              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      if (cmpi.Op == CompareOp.CtruePseudo || cmpi.Op == CompareOp.CfalsePseudo)                      {                          var s = cmpi.Type.Style(compEnv);                          var unop = default(UnaryOp);                          if (s is NumberTypeStyle)                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonZero : UnaryOp.IsZero;                          else                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonNull : UnaryOp.IsNull;                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new UnaryExpression(a[0]' unop' false' cmpi.IsUnsigned)' e));                      }                      else                      {                          var binop = default(BinaryOp);                          switch (cmpi.Op)                          {                          case CompareOp.Ceq:                              binop = BinaryOp.Eq;                              break;                          case CompareOp.Clt:                              binop = BinaryOp.Lt;                              break;                          case CompareOp.Cgt:                              binop = BinaryOp.Gt;                              break;                          case CompareOp.CgePseudo:                              binop = BinaryOp.Ge;                              break;                          case CompareOp.ClePseudo:                              binop = BinaryOp.Le;                              break;                          case CompareOp.CnePseudo:                              binop = BinaryOp.Ne;                              break;                          case CompareOp.CtruePseudo:                          case CompareOp.CfalsePseudo:                              // handled above                              throw new InvalidOperationException();                          default:                              throw new ArgumentOutOfRangeException();                          }                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression(a[0]' binop' a[1]' false' cmpi.IsUnsigned)' e));                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var sli = (ArgLocalInstruction)instruction;                      var id = default(JST.Identifier);                      switch (sli.ArgLocal)                      {                      case ArgLocal.Arg:                          id = compEnv.ValueParameterIds[sli.Index];                          break;                      case ArgLocal.Local:                          id = compEnv.LocalIds[sli.Index];                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      var cell = new VariableCell(id);                      switch (sli.Op)                      {                      case ArgLocalOp.Ld:                          stack.Push                              (new ExpressionStackEntry                                   (cell.Read().CloneIfStruct(compEnv)' ReadArgLocalE(sli.ArgLocal' sli.Index)));                          return true;                      case ArgLocalOp.Lda:                          // Effect will be accounted for on reads/writes                          stack.Push(new ExpressionStackEntry(cell.AddressOf()' BottomE));                          return true;                      case ArgLocalOp.St:                          return stack.PopEvalSE                              (statements'                               1'                               true'                               WriteArgLocalE(sli.ArgLocal' sli.Index)'                               (s' a) => s.Add(new ExpressionStatement(cell.Write(a[0]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                          {                              stack.Push                                  (new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' ReadHeapE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                       {                                           var readEffect = default(Effects);                                           var obj = default(Expression);                                           if (fieldi.IsViaPointer.Value)                                           {                                               readEffect = e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect());                                               obj = new ReadExpression(a[0]); // no need for clone                                           }                                           else if (fieldi.Field.DefiningType.Style(compEnv) is ValueTypeStyle)                                           {                                               readEffect = e;                                               obj = a[0];                                           }                                           else                                           {                                               // Object could be null                                               readEffect = e.Lub(ReadHeapOrThrowE);                                               obj = a[0];                                           }                                           return new ExpressionStackEntry(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' readEffect);                                       });                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                          {                              // Effect will be accounted for on reads/writes                              stack.Push(new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' BottomE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   {                                       if (fieldi.IsViaPointer.Value)                                           // We're just adding an offset to a pointer' so effect will                                           // be accounted for when the final pointer is read/written                                           return new ExpressionStackEntry(new FieldCell(new ReadExpression(a[0])' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e);                                       else                                           // Must be a reference type' and ref could be null                                           return new ExpressionStackEntry(new FieldCell(a[0]' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e.Lub(ThrowsE));                                   });                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                              return stack.PopEvalSE                                  (statements'                                   1'                                   true'                                   WriteHeapE'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Write(a[0]))));                          else                          {                              var writeEffect = fieldi.IsViaPointer.Value                                                    ? instruction.BeforeState.PeekPointsTo(1).WriteEffect()                                                    : WriteHeapOrThrowE;                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   writeEffect'                                   (s' a) =>                                       {                                           var obj = fieldi.IsViaPointer.Value ? new ReadExpression(a[0]) : a[0];                                           s.Add(new ExpressionStatement(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Write(a[1])));                                       });                          }                      case FieldOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new FieldHandleConstantExpression(compEnv.SubstituteMember(fieldi.Field))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methodi = (MethodInstruction)instruction;                      var arity = methodi.Method.ValueParameters.Count;                      switch (methodi.Op)                      {                      case MethodOp.Ldftn:                          if (methodi.IsVirtual)                              // Object could be null                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CodePointerExpression(a[0]' compEnv.SubstituteMember(methodi.Method))' e.Lub(ReadHeapOrThrowE)));                          else                          {                              stack.Push                                  (new ExpressionStackEntry(new CodePointerExpression(null' compEnv.SubstituteMember(methodi.Method))' BottomE));                              return true;                          }                      case MethodOp.Call:                          if (methodi.Method.Result == null)                              return stack.PopEvalSE                                  (statements'                                   arity'                                   true'                                   CalleeEffects(methodi.BeforeState' arity)'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new CallExpression                                                 (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal'                                                  compEnv.SubstituteMember(methodi.Method)'                                                  CallerArguments(methodi.Constrained' methodi.Method' a)))));                          else                              return stack.PopEvalPush                                  (statements'                                   arity'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CallExpression                                            (methodi.IsVirtual? CallFlavor.Virtual : CallFlavor.Normal'                                             compEnv.SubstituteMember(methodi.Method)'                                             CallerArguments(methodi.Constrained' methodi.Method' a))'                                        e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Newobj:                          arity--;                          return stack.PopEvalPush                              (statements'                               arity'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new NewObjectExpression(compEnv.SubstituteMember(methodi.Method)' CallerArguments(null' methodi.Method' a))'                                    e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Ldtoken:                          stack.Push                              (new ExpressionStackEntry(new MethodHandleConstantExpression(compEnv.SubstituteMember(methodi.Method))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case TypeOp.Stobj:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case TypeOp.Cpobj:                          {                              var copyEffect = instruction.BeforeState.PeekPointsTo(0).ReadEffect().Lub                                  (instruction.BeforeState.PeekPointsTo(1).WriteEffect());                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   copyEffect'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new WriteExpression(a[0]' new ReadExpression(a[1]).CloneIfStruct(compEnv)))));                          }                      case TypeOp.Newarr:                          // Growing the heap is not considered an observable change. But will throw if                          // length < 0                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new NewArrayExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Initobj:                          return stack.PopEvalSE                              (statements' 1' true' WriteHeapE' (s' a) => s.Add(new InitializeObjectStatement(a[0])));                      case TypeOp.Castclass:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new CastExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Isinst:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new IsInstExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Box:                          // Growing the heap is not considered an observable change                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new NewBoxExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Unbox:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).AddressOf()' e.Lub(ThrowsE)));                      case TypeOp.UnboxAny:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).Read().CloneIfStruct(compEnv)' e.Lub(ThrowsE)));                      case TypeOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new TypeHandleConstantExpression(compEnv.SubstituteType(typei.Type))' BottomE));                          return true;                      case TypeOp.Ldelem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case TypeOp.Stelem:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add(new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  // Calculating the pointer may throw if index is out of range.                  // Remaining effect will be accounted for when pointer is read/written.                  return stack.PopEvalPush                      (statements'                       2'                       true'                       (a' e) =>                       new ExpressionStackEntry(new ElementCell(a[0]' a[1]' false).AddressOf()' e.Lub(ThrowsE)));              case InstructionFlavor.LdInt32:                  {                      var int32i = (LdInt32Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int32ConstantExpression(int32i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdInt64:                  {                      var int64i = (LdInt64Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int64ConstantExpression(int64i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdSingle:                  {                      var singlei = (LdSingleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new SingleConstantExpression(singlei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdDouble:                  {                      var doublei = (LdDoubleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new DoubleConstantExpression(doublei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdString:                  {                      var stringi = (LdStringInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new StringConstantExpression(stringi.Value)' BottomE));                      return true;                  }              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Div:                      case ArithOp.Rem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(ThrowsE)));                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                      case ArithOp.Shl:                      case ArithOp.Shr:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(arithi.WithOverflow ? ThrowsE : BottomE)));                      case ArithOp.Neg:                      case ArithOp.BitNot:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression                                        (a[0]' ArithOpToUnaryOp(arithi.Op)' arithi.WithOverflow' arithi.IsUnsigned)'                                    e));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      return stack.PopEvalPush                          (statements'                           1'                           true'                           (a' e) =>                           new ExpressionStackEntry                               (new ConvertExpression                                    (a[0]'                                     new NamedTypeRef                                         (compEnv.Global.NumberFlavorToQualifiedTypeName[convi.TargetNumberFlavor])'                                     convi.WithOverflow'                                     convi.IsSourceUnsigned)'                                e.Lub(convi.WithOverflow ? ThrowsE : BottomE)));                  }              case InstructionFlavor.Try:                  {                      if (stack.Depth > 0)                          throw new InvalidOperationException("stack must be empty on entry to try block");                      var tryi = (TryInstruction)instruction;                      var tryStatements = BlockToTryFaultFinallyStatements(tryi.Body);                      if (tryStatements == null)                          return false;                      var handlers = TranslateHandlers(tryi.Handlers);                      if (handlers == null)                          return false;                      if (statements == null)                          return Failed(false' "try");                      statements.Add(new TryStatement(tryStatements' handlers));                      return true;                  }              case InstructionFlavor.IfThenElsePseudo:                  {                      var itei = (IfThenElseInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(itei.Offset' out isExpr) ||                                              isExpr;                        if (!TranslateBlock(statements' itei.Condition' stack' exid))                          return false;                      if (couldBeExpression && itei.Else != null)                      {                          // Pass 1: Try to tranlate to an if-then-else expression. Will only work if Then and Else don't                          //         reach into current stack' push exactly one value' and don't need to emit any                          //         statements along the way.                          var thenEntry = BlockToExpression(itei.Then' exid);                          if (thenEntry != null)                          {                              var elseEntry = BlockToExpression(itei.Else' exid);                              if (elseEntry != null)                              {                                  if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                                      instructionTranslationStyleCache.Add(itei.Offset' true);                                  return stack.PopEvalPush                                      (statements'                                       1'                                       true'                                       (a' e) =>                                       new ExpressionStackEntry                                           (new IfThenElseExpression(a[0]' thenEntry.Expression' elseEntry.Expression)'                                            e.Lub(thenEntry.Effects.Lub(elseEntry.Effects))));                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      var noStackChange = itei.Then.NoStackChange && (itei.Else == null || itei.Else.NoStackChange);                      var condEntry = noStackChange                                          ? stack.Pop()                                          : stack.FlushAndPopPostState(statements' itei.Then.BeforeState);                      if (condEntry == null)                          return false;                      var thenStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Then' exid)                                           : BlockToStatements(itei.Then' exid);                      if (thenStmnts == null)                          return false;                      var elseStmnts = default(Seq<Statement>);                      if (itei.Else != null)                      {                          elseStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Else' exid)                                           : BlockToStatements(itei.Else' exid);                          if (elseStmnts == null)                              return false;                      }                      if (statements == null)                          return Failed(false' "if-then-else");                      statements.Add                          (new IfThenElseStatement(condEntry.Expression' new Statements(thenStmnts)' elseStmnts == null ? null : new Statements(elseStmnts)));                      if (!noStackChange && !stack.Restore(itei.AfterState' 0))                          return false;                      if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                          instructionTranslationStyleCache.Add(itei.Offset' false);                      return true;                  }              case InstructionFlavor.ShortCircuitingPseudo:                  {                      var sci = (ShortCircuitingInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(sci.Offset' out isExpr) ||                                              isExpr;                      if (couldBeExpression)                      {                          // Pass 1: Try to translate to an expression.                          var leftEntry = BlockToExpression(sci.Left' exid);                          if (leftEntry != null)                          {                              var rightEntry = BlockToExpression(sci.Right' exid);                              if (rightEntry != null)                              {                                  stack.Push                                      (new ExpressionStackEntry                                           (new BinaryExpression                                                (leftEntry.Expression'                                                 ShortCircuitingOpToBinaryOp(sci.Op)'                                                 rightEntry.Expression'                                                 false'                                                 false)'                                            leftEntry.Effects.Lub(rightEntry.Effects)));                                  if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                                      instructionTranslationStyleCache.Add(sci.Offset' true);                                  return true;                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      if (!TranslateBlock(statements' sci.Left' stack' exid))                          return false;                      var leftEntry2 = stack.FlushAndPopPostState(statements' sci.Right.BeforeState);                      if (leftEntry2 == null)                          return false;                      var rightStatements = BlockToStatements(sci.Right' exid);                      if (rightStatements == null)                          return false;                      var id = sci.Right.AfterState.PeekId(0' nameSupply.GenSym);                      var cell = new VariableCell(id);                      compEnv.AddVariable(id' ArgLocal.Local' false' true' compEnv.SubstituteType(sci.Right.AfterState.PeekType(0)));                      if (statements == null)                          return Failed(false' "short-circuit");                      switch (sci.Op)                      {                      case ShortCircuitingOp.And:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements(rightStatements)'                                    new Statements                                        (new ExpressionStatement(cell.Write(new Int32ConstantExpression(0))))));                          break;                      case ShortCircuitingOp.Or:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements                                        (new ExpressionStatement                                             (cell.Write(new Int32ConstantExpression(1))))'                                    new Statements(rightStatements)));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      if (!stack.Restore(sci.AfterState' 1))                          return false;                      stack.Push(new ExpressionStackEntry(cell.Read()' BottomE));                      if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                          instructionTranslationStyleCache.Add(sci.Offset' false);                      return true;                  }              case InstructionFlavor.StructuralSwitchPseudo:                  {                      var ssi = (StructuralSwitchInstruction)instruction;                      if (!TranslateBlock(statements' ssi.Body' stack' exid))                          return false;                      var valueEntry = stack.FlushAndPopPreState(statements' ssi.Body.AfterState);                      if (valueEntry == null)                          return false;                      var cases = new Seq<SwitchStatementCase>();                      foreach (var c in ssi.Cases)                      {                          var caseStatements = BlockToStatements(c.Body' exid);                          if (caseStatements == null)                              return false;                          cases.Add(new SwitchStatementCase(c.Values' new Statements(caseStatements)));                      }                      if (statements == null)                          return Failed(false' "structural switch");                      statements.Add(new SwitchStatement(valueEntry.Expression' cases));                      if (!stack.Restore(ssi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopPseudo:                  {                      var li = (LoopInstruction)instruction;                      if (!stack.Flush(statements' li.Body.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop");                      var whileStatements = BlockToStatements(li.Body' exid);                      statements.Add                          (new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(whileStatements)));                      if (!stack.Restore(li.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.WhileDoPseudo:                  {                      var wdi = (WhileDoInstruction)instruction;                      if (!stack.Flush(statements' wdi.Condition.BeforeState))                          return false;                      var condEntry = BlockToExpression(wdi.Condition' exid);                      if (condEntry == null)                      {                          var stack1 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Condition.BeforeState' trace);                          var preCondStatements = new Seq<Statement>();                          if (!TranslateBlock(preCondStatements' wdi.Condition' stack1' exid))                              return false;                          condEntry = stack1.FlushAndPopPostState(preCondStatements' wdi.Body.BeforeState);                          if (condEntry == null)                              return false;                          var stack2 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Body.BeforeState' trace);                          var postCondStatements = new Seq<Statement>();                          if (!TranslateBlock(postCondStatements' wdi.Body' stack2' exid))                              return false;                          if (!stack2.Flush(postCondStatements' wdi.Body.AfterState))                              return false;                          preCondStatements.Add                              (new IfThenElseStatement                                   (condEntry.Expression'                                    new Statements(postCondStatements)'                                    new Statements(new BreakStatement())));                          statements.Add(new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(preCondStatements)));                      }                      else                      {                          var loopStatements = BlockToStatements(wdi.Body' exid);                          if (loopStatements == null)                              return false;                          if (statements == null)                              return Failed(false' "while-do");                          statements.Add(new WhileDoStatement(condEntry.Expression' new Statements(loopStatements)));                      }                      if (!stack.Restore(wdi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.DoWhilePseudo:                  {                      var dwi = (DoWhileInstruction)instruction;                      if (!stack.Flush(statements' dwi.Body.BeforeState))                          return false;                      var combined = new Seq<Instruction>();                      foreach (var i in dwi.Body.Body)                          combined.Add(i);                      foreach (var i in dwi.Condition.Body)                          combined.Add(i);                      var condEntry = default(ExpressionStackEntry);                      var loopStatements = BlockToConditionStatements                          (new Instructions(null' combined)' dwi.Body.BeforeState' exid' out condEntry);                      if (loopStatements == null)                          return false;                      if (statements == null)                          return Failed(false' "do-while");                      statements.Add(new DoWhileStatement(new Statements(loopStatements)' condEntry.Expression));                      if (!stack.Restore(dwi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopControlPseudo:                  {                      var lci = (BreakContinueInstruction)instruction;                      if (!stack.Flush(statements' lci.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop-control");                      var targetState = default(int);                      switch (lci.Op)                      {                      case BreakContinueOp.Break:                          if (labelToLoopCandidateBreakState != null &&                              labelToLoopCandidateBreakState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new BreakStatement(lci.Label));                          break;                      case BreakContinueOp.Continue:                          if (labelToLoopCandidateContinueState != null &&                              labelToLoopCandidateContinueState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new ContinueStatement(lci.Label));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      return true;                  }              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return true;                      case MiscOp.Dup:                          return stack.Dup(statements);                      case MiscOp.Pop:                          return stack.PopAndDiscard(statements);                      case MiscOp.Ldnull:                          stack.Push(new ExpressionStackEntry(new NullConstantExpression()' BottomE));                          return true;                      case MiscOp.Ckfinite:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.CheckFinite' false' false)' e.Lub(ThrowsE)));                      case MiscOp.Throw:                          if (!stack.DiscardAll(statements' 1))                              return false;                          if (!stack.PopEvalSE(statements' 1' true' ThrowsE' (s' a) => s.Add(new ThrowStatement(a[0]))))                              return false;                          return true;                      case MiscOp.Rethrow:                          if (!stack.DiscardAll(statements' 0))                              return false;                          if (statements == null)                              return Failed(false' "rethrow");                          if (exid == null)                              throw new InvalidOperationException("rethrow outside of catch");                          statements.Add(new RethrowStatement(new VariableCell(exid).Read()));                          return true;                      case MiscOp.LdindRef:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case MiscOp.LdelemRef:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.Ldlen:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.Length' false' false)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.StindRef:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case MiscOp.StelemRef:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add                                   (new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      case MiscOp.Ret:                          if (statements == null)                              return Failed(false' "return");                          statements.Add(new ReturnStatement(null));                          return true;                      case MiscOp.RetVal:                          return stack.PopEvalSE                              (statements' 1' true' BottomE' (s' a) => s.Add(new ReturnStatement(a[0])));                      case MiscOp.Endfilter:                      case MiscOp.Endfinally:                          throw new InvalidOperationException                              ("endfilter/endfinally instructions should have been removed");                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:              case InstructionFlavor.Switch:                  throw new InvalidOperationException("branch/switch instructions should have been removed");              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      if (cmpi.Op == CompareOp.CtruePseudo || cmpi.Op == CompareOp.CfalsePseudo)                      {                          var s = cmpi.Type.Style(compEnv);                          var unop = default(UnaryOp);                          if (s is NumberTypeStyle)                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonZero : UnaryOp.IsZero;                          else                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonNull : UnaryOp.IsNull;                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new UnaryExpression(a[0]' unop' false' cmpi.IsUnsigned)' e));                      }                      else                      {                          var binop = default(BinaryOp);                          switch (cmpi.Op)                          {                          case CompareOp.Ceq:                              binop = BinaryOp.Eq;                              break;                          case CompareOp.Clt:                              binop = BinaryOp.Lt;                              break;                          case CompareOp.Cgt:                              binop = BinaryOp.Gt;                              break;                          case CompareOp.CgePseudo:                              binop = BinaryOp.Ge;                              break;                          case CompareOp.ClePseudo:                              binop = BinaryOp.Le;                              break;                          case CompareOp.CnePseudo:                              binop = BinaryOp.Ne;                              break;                          case CompareOp.CtruePseudo:                          case CompareOp.CfalsePseudo:                              // handled above                              throw new InvalidOperationException();                          default:                              throw new ArgumentOutOfRangeException();                          }                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression(a[0]' binop' a[1]' false' cmpi.IsUnsigned)' e));                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var sli = (ArgLocalInstruction)instruction;                      var id = default(JST.Identifier);                      switch (sli.ArgLocal)                      {                      case ArgLocal.Arg:                          id = compEnv.ValueParameterIds[sli.Index];                          break;                      case ArgLocal.Local:                          id = compEnv.LocalIds[sli.Index];                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      var cell = new VariableCell(id);                      switch (sli.Op)                      {                      case ArgLocalOp.Ld:                          stack.Push                              (new ExpressionStackEntry                                   (cell.Read().CloneIfStruct(compEnv)' ReadArgLocalE(sli.ArgLocal' sli.Index)));                          return true;                      case ArgLocalOp.Lda:                          // Effect will be accounted for on reads/writes                          stack.Push(new ExpressionStackEntry(cell.AddressOf()' BottomE));                          return true;                      case ArgLocalOp.St:                          return stack.PopEvalSE                              (statements'                               1'                               true'                               WriteArgLocalE(sli.ArgLocal' sli.Index)'                               (s' a) => s.Add(new ExpressionStatement(cell.Write(a[0]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                          {                              stack.Push                                  (new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' ReadHeapE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                       {                                           var readEffect = default(Effects);                                           var obj = default(Expression);                                           if (fieldi.IsViaPointer.Value)                                           {                                               readEffect = e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect());                                               obj = new ReadExpression(a[0]); // no need for clone                                           }                                           else if (fieldi.Field.DefiningType.Style(compEnv) is ValueTypeStyle)                                           {                                               readEffect = e;                                               obj = a[0];                                           }                                           else                                           {                                               // Object could be null                                               readEffect = e.Lub(ReadHeapOrThrowE);                                               obj = a[0];                                           }                                           return new ExpressionStackEntry(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' readEffect);                                       });                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                          {                              // Effect will be accounted for on reads/writes                              stack.Push(new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' BottomE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   {                                       if (fieldi.IsViaPointer.Value)                                           // We're just adding an offset to a pointer' so effect will                                           // be accounted for when the final pointer is read/written                                           return new ExpressionStackEntry(new FieldCell(new ReadExpression(a[0])' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e);                                       else                                           // Must be a reference type' and ref could be null                                           return new ExpressionStackEntry(new FieldCell(a[0]' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e.Lub(ThrowsE));                                   });                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                              return stack.PopEvalSE                                  (statements'                                   1'                                   true'                                   WriteHeapE'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Write(a[0]))));                          else                          {                              var writeEffect = fieldi.IsViaPointer.Value                                                    ? instruction.BeforeState.PeekPointsTo(1).WriteEffect()                                                    : WriteHeapOrThrowE;                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   writeEffect'                                   (s' a) =>                                       {                                           var obj = fieldi.IsViaPointer.Value ? new ReadExpression(a[0]) : a[0];                                           s.Add(new ExpressionStatement(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Write(a[1])));                                       });                          }                      case FieldOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new FieldHandleConstantExpression(compEnv.SubstituteMember(fieldi.Field))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methodi = (MethodInstruction)instruction;                      var arity = methodi.Method.ValueParameters.Count;                      switch (methodi.Op)                      {                      case MethodOp.Ldftn:                          if (methodi.IsVirtual)                              // Object could be null                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CodePointerExpression(a[0]' compEnv.SubstituteMember(methodi.Method))' e.Lub(ReadHeapOrThrowE)));                          else                          {                              stack.Push                                  (new ExpressionStackEntry(new CodePointerExpression(null' compEnv.SubstituteMember(methodi.Method))' BottomE));                              return true;                          }                      case MethodOp.Call:                          if (methodi.Method.Result == null)                              return stack.PopEvalSE                                  (statements'                                   arity'                                   true'                                   CalleeEffects(methodi.BeforeState' arity)'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new CallExpression                                                 (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal'                                                  compEnv.SubstituteMember(methodi.Method)'                                                  CallerArguments(methodi.Constrained' methodi.Method' a)))));                          else                              return stack.PopEvalPush                                  (statements'                                   arity'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CallExpression                                            (methodi.IsVirtual? CallFlavor.Virtual : CallFlavor.Normal'                                             compEnv.SubstituteMember(methodi.Method)'                                             CallerArguments(methodi.Constrained' methodi.Method' a))'                                        e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Newobj:                          arity--;                          return stack.PopEvalPush                              (statements'                               arity'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new NewObjectExpression(compEnv.SubstituteMember(methodi.Method)' CallerArguments(null' methodi.Method' a))'                                    e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Ldtoken:                          stack.Push                              (new ExpressionStackEntry(new MethodHandleConstantExpression(compEnv.SubstituteMember(methodi.Method))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case TypeOp.Stobj:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case TypeOp.Cpobj:                          {                              var copyEffect = instruction.BeforeState.PeekPointsTo(0).ReadEffect().Lub                                  (instruction.BeforeState.PeekPointsTo(1).WriteEffect());                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   copyEffect'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new WriteExpression(a[0]' new ReadExpression(a[1]).CloneIfStruct(compEnv)))));                          }                      case TypeOp.Newarr:                          // Growing the heap is not considered an observable change. But will throw if                          // length < 0                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new NewArrayExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Initobj:                          return stack.PopEvalSE                              (statements' 1' true' WriteHeapE' (s' a) => s.Add(new InitializeObjectStatement(a[0])));                      case TypeOp.Castclass:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new CastExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Isinst:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new IsInstExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Box:                          // Growing the heap is not considered an observable change                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new NewBoxExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Unbox:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).AddressOf()' e.Lub(ThrowsE)));                      case TypeOp.UnboxAny:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).Read().CloneIfStruct(compEnv)' e.Lub(ThrowsE)));                      case TypeOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new TypeHandleConstantExpression(compEnv.SubstituteType(typei.Type))' BottomE));                          return true;                      case TypeOp.Ldelem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case TypeOp.Stelem:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add(new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  // Calculating the pointer may throw if index is out of range.                  // Remaining effect will be accounted for when pointer is read/written.                  return stack.PopEvalPush                      (statements'                       2'                       true'                       (a' e) =>                       new ExpressionStackEntry(new ElementCell(a[0]' a[1]' false).AddressOf()' e.Lub(ThrowsE)));              case InstructionFlavor.LdInt32:                  {                      var int32i = (LdInt32Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int32ConstantExpression(int32i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdInt64:                  {                      var int64i = (LdInt64Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int64ConstantExpression(int64i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdSingle:                  {                      var singlei = (LdSingleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new SingleConstantExpression(singlei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdDouble:                  {                      var doublei = (LdDoubleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new DoubleConstantExpression(doublei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdString:                  {                      var stringi = (LdStringInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new StringConstantExpression(stringi.Value)' BottomE));                      return true;                  }              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Div:                      case ArithOp.Rem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(ThrowsE)));                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                      case ArithOp.Shl:                      case ArithOp.Shr:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(arithi.WithOverflow ? ThrowsE : BottomE)));                      case ArithOp.Neg:                      case ArithOp.BitNot:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression                                        (a[0]' ArithOpToUnaryOp(arithi.Op)' arithi.WithOverflow' arithi.IsUnsigned)'                                    e));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      return stack.PopEvalPush                          (statements'                           1'                           true'                           (a' e) =>                           new ExpressionStackEntry                               (new ConvertExpression                                    (a[0]'                                     new NamedTypeRef                                         (compEnv.Global.NumberFlavorToQualifiedTypeName[convi.TargetNumberFlavor])'                                     convi.WithOverflow'                                     convi.IsSourceUnsigned)'                                e.Lub(convi.WithOverflow ? ThrowsE : BottomE)));                  }              case InstructionFlavor.Try:                  {                      if (stack.Depth > 0)                          throw new InvalidOperationException("stack must be empty on entry to try block");                      var tryi = (TryInstruction)instruction;                      var tryStatements = BlockToTryFaultFinallyStatements(tryi.Body);                      if (tryStatements == null)                          return false;                      var handlers = TranslateHandlers(tryi.Handlers);                      if (handlers == null)                          return false;                      if (statements == null)                          return Failed(false' "try");                      statements.Add(new TryStatement(tryStatements' handlers));                      return true;                  }              case InstructionFlavor.IfThenElsePseudo:                  {                      var itei = (IfThenElseInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(itei.Offset' out isExpr) ||                                              isExpr;                        if (!TranslateBlock(statements' itei.Condition' stack' exid))                          return false;                      if (couldBeExpression && itei.Else != null)                      {                          // Pass 1: Try to tranlate to an if-then-else expression. Will only work if Then and Else don't                          //         reach into current stack' push exactly one value' and don't need to emit any                          //         statements along the way.                          var thenEntry = BlockToExpression(itei.Then' exid);                          if (thenEntry != null)                          {                              var elseEntry = BlockToExpression(itei.Else' exid);                              if (elseEntry != null)                              {                                  if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                                      instructionTranslationStyleCache.Add(itei.Offset' true);                                  return stack.PopEvalPush                                      (statements'                                       1'                                       true'                                       (a' e) =>                                       new ExpressionStackEntry                                           (new IfThenElseExpression(a[0]' thenEntry.Expression' elseEntry.Expression)'                                            e.Lub(thenEntry.Effects.Lub(elseEntry.Effects))));                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      var noStackChange = itei.Then.NoStackChange && (itei.Else == null || itei.Else.NoStackChange);                      var condEntry = noStackChange                                          ? stack.Pop()                                          : stack.FlushAndPopPostState(statements' itei.Then.BeforeState);                      if (condEntry == null)                          return false;                      var thenStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Then' exid)                                           : BlockToStatements(itei.Then' exid);                      if (thenStmnts == null)                          return false;                      var elseStmnts = default(Seq<Statement>);                      if (itei.Else != null)                      {                          elseStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Else' exid)                                           : BlockToStatements(itei.Else' exid);                          if (elseStmnts == null)                              return false;                      }                      if (statements == null)                          return Failed(false' "if-then-else");                      statements.Add                          (new IfThenElseStatement(condEntry.Expression' new Statements(thenStmnts)' elseStmnts == null ? null : new Statements(elseStmnts)));                      if (!noStackChange && !stack.Restore(itei.AfterState' 0))                          return false;                      if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                          instructionTranslationStyleCache.Add(itei.Offset' false);                      return true;                  }              case InstructionFlavor.ShortCircuitingPseudo:                  {                      var sci = (ShortCircuitingInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(sci.Offset' out isExpr) ||                                              isExpr;                      if (couldBeExpression)                      {                          // Pass 1: Try to translate to an expression.                          var leftEntry = BlockToExpression(sci.Left' exid);                          if (leftEntry != null)                          {                              var rightEntry = BlockToExpression(sci.Right' exid);                              if (rightEntry != null)                              {                                  stack.Push                                      (new ExpressionStackEntry                                           (new BinaryExpression                                                (leftEntry.Expression'                                                 ShortCircuitingOpToBinaryOp(sci.Op)'                                                 rightEntry.Expression'                                                 false'                                                 false)'                                            leftEntry.Effects.Lub(rightEntry.Effects)));                                  if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                                      instructionTranslationStyleCache.Add(sci.Offset' true);                                  return true;                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      if (!TranslateBlock(statements' sci.Left' stack' exid))                          return false;                      var leftEntry2 = stack.FlushAndPopPostState(statements' sci.Right.BeforeState);                      if (leftEntry2 == null)                          return false;                      var rightStatements = BlockToStatements(sci.Right' exid);                      if (rightStatements == null)                          return false;                      var id = sci.Right.AfterState.PeekId(0' nameSupply.GenSym);                      var cell = new VariableCell(id);                      compEnv.AddVariable(id' ArgLocal.Local' false' true' compEnv.SubstituteType(sci.Right.AfterState.PeekType(0)));                      if (statements == null)                          return Failed(false' "short-circuit");                      switch (sci.Op)                      {                      case ShortCircuitingOp.And:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements(rightStatements)'                                    new Statements                                        (new ExpressionStatement(cell.Write(new Int32ConstantExpression(0))))));                          break;                      case ShortCircuitingOp.Or:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements                                        (new ExpressionStatement                                             (cell.Write(new Int32ConstantExpression(1))))'                                    new Statements(rightStatements)));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      if (!stack.Restore(sci.AfterState' 1))                          return false;                      stack.Push(new ExpressionStackEntry(cell.Read()' BottomE));                      if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                          instructionTranslationStyleCache.Add(sci.Offset' false);                      return true;                  }              case InstructionFlavor.StructuralSwitchPseudo:                  {                      var ssi = (StructuralSwitchInstruction)instruction;                      if (!TranslateBlock(statements' ssi.Body' stack' exid))                          return false;                      var valueEntry = stack.FlushAndPopPreState(statements' ssi.Body.AfterState);                      if (valueEntry == null)                          return false;                      var cases = new Seq<SwitchStatementCase>();                      foreach (var c in ssi.Cases)                      {                          var caseStatements = BlockToStatements(c.Body' exid);                          if (caseStatements == null)                              return false;                          cases.Add(new SwitchStatementCase(c.Values' new Statements(caseStatements)));                      }                      if (statements == null)                          return Failed(false' "structural switch");                      statements.Add(new SwitchStatement(valueEntry.Expression' cases));                      if (!stack.Restore(ssi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopPseudo:                  {                      var li = (LoopInstruction)instruction;                      if (!stack.Flush(statements' li.Body.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop");                      var whileStatements = BlockToStatements(li.Body' exid);                      statements.Add                          (new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(whileStatements)));                      if (!stack.Restore(li.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.WhileDoPseudo:                  {                      var wdi = (WhileDoInstruction)instruction;                      if (!stack.Flush(statements' wdi.Condition.BeforeState))                          return false;                      var condEntry = BlockToExpression(wdi.Condition' exid);                      if (condEntry == null)                      {                          var stack1 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Condition.BeforeState' trace);                          var preCondStatements = new Seq<Statement>();                          if (!TranslateBlock(preCondStatements' wdi.Condition' stack1' exid))                              return false;                          condEntry = stack1.FlushAndPopPostState(preCondStatements' wdi.Body.BeforeState);                          if (condEntry == null)                              return false;                          var stack2 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Body.BeforeState' trace);                          var postCondStatements = new Seq<Statement>();                          if (!TranslateBlock(postCondStatements' wdi.Body' stack2' exid))                              return false;                          if (!stack2.Flush(postCondStatements' wdi.Body.AfterState))                              return false;                          preCondStatements.Add                              (new IfThenElseStatement                                   (condEntry.Expression'                                    new Statements(postCondStatements)'                                    new Statements(new BreakStatement())));                          statements.Add(new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(preCondStatements)));                      }                      else                      {                          var loopStatements = BlockToStatements(wdi.Body' exid);                          if (loopStatements == null)                              return false;                          if (statements == null)                              return Failed(false' "while-do");                          statements.Add(new WhileDoStatement(condEntry.Expression' new Statements(loopStatements)));                      }                      if (!stack.Restore(wdi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.DoWhilePseudo:                  {                      var dwi = (DoWhileInstruction)instruction;                      if (!stack.Flush(statements' dwi.Body.BeforeState))                          return false;                      var combined = new Seq<Instruction>();                      foreach (var i in dwi.Body.Body)                          combined.Add(i);                      foreach (var i in dwi.Condition.Body)                          combined.Add(i);                      var condEntry = default(ExpressionStackEntry);                      var loopStatements = BlockToConditionStatements                          (new Instructions(null' combined)' dwi.Body.BeforeState' exid' out condEntry);                      if (loopStatements == null)                          return false;                      if (statements == null)                          return Failed(false' "do-while");                      statements.Add(new DoWhileStatement(new Statements(loopStatements)' condEntry.Expression));                      if (!stack.Restore(dwi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopControlPseudo:                  {                      var lci = (BreakContinueInstruction)instruction;                      if (!stack.Flush(statements' lci.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop-control");                      var targetState = default(int);                      switch (lci.Op)                      {                      case BreakContinueOp.Break:                          if (labelToLoopCandidateBreakState != null &&                              labelToLoopCandidateBreakState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new BreakStatement(lci.Label));                          break;                      case BreakContinueOp.Continue:                          if (labelToLoopCandidateContinueState != null &&                              labelToLoopCandidateContinueState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new ContinueStatement(lci.Label));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      return true;                  }              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return true;                      case MiscOp.Dup:                          return stack.Dup(statements);                      case MiscOp.Pop:                          return stack.PopAndDiscard(statements);                      case MiscOp.Ldnull:                          stack.Push(new ExpressionStackEntry(new NullConstantExpression()' BottomE));                          return true;                      case MiscOp.Ckfinite:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.CheckFinite' false' false)' e.Lub(ThrowsE)));                      case MiscOp.Throw:                          if (!stack.DiscardAll(statements' 1))                              return false;                          if (!stack.PopEvalSE(statements' 1' true' ThrowsE' (s' a) => s.Add(new ThrowStatement(a[0]))))                              return false;                          return true;                      case MiscOp.Rethrow:                          if (!stack.DiscardAll(statements' 0))                              return false;                          if (statements == null)                              return Failed(false' "rethrow");                          if (exid == null)                              throw new InvalidOperationException("rethrow outside of catch");                          statements.Add(new RethrowStatement(new VariableCell(exid).Read()));                          return true;                      case MiscOp.LdindRef:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case MiscOp.LdelemRef:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.Ldlen:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.Length' false' false)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.StindRef:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case MiscOp.StelemRef:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add                                   (new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      case MiscOp.Ret:                          if (statements == null)                              return Failed(false' "return");                          statements.Add(new ReturnStatement(null));                          return true;                      case MiscOp.RetVal:                          return stack.PopEvalSE                              (statements' 1' true' BottomE' (s' a) => s.Add(new ReturnStatement(a[0])));                      case MiscOp.Endfilter:                      case MiscOp.Endfinally:                          throw new InvalidOperationException                              ("endfilter/endfinally instructions should have been removed");                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:              case InstructionFlavor.Switch:                  throw new InvalidOperationException("branch/switch instructions should have been removed");              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      if (cmpi.Op == CompareOp.CtruePseudo || cmpi.Op == CompareOp.CfalsePseudo)                      {                          var s = cmpi.Type.Style(compEnv);                          var unop = default(UnaryOp);                          if (s is NumberTypeStyle)                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonZero : UnaryOp.IsZero;                          else                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonNull : UnaryOp.IsNull;                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new UnaryExpression(a[0]' unop' false' cmpi.IsUnsigned)' e));                      }                      else                      {                          var binop = default(BinaryOp);                          switch (cmpi.Op)                          {                          case CompareOp.Ceq:                              binop = BinaryOp.Eq;                              break;                          case CompareOp.Clt:                              binop = BinaryOp.Lt;                              break;                          case CompareOp.Cgt:                              binop = BinaryOp.Gt;                              break;                          case CompareOp.CgePseudo:                              binop = BinaryOp.Ge;                              break;                          case CompareOp.ClePseudo:                              binop = BinaryOp.Le;                              break;                          case CompareOp.CnePseudo:                              binop = BinaryOp.Ne;                              break;                          case CompareOp.CtruePseudo:                          case CompareOp.CfalsePseudo:                              // handled above                              throw new InvalidOperationException();                          default:                              throw new ArgumentOutOfRangeException();                          }                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression(a[0]' binop' a[1]' false' cmpi.IsUnsigned)' e));                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var sli = (ArgLocalInstruction)instruction;                      var id = default(JST.Identifier);                      switch (sli.ArgLocal)                      {                      case ArgLocal.Arg:                          id = compEnv.ValueParameterIds[sli.Index];                          break;                      case ArgLocal.Local:                          id = compEnv.LocalIds[sli.Index];                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      var cell = new VariableCell(id);                      switch (sli.Op)                      {                      case ArgLocalOp.Ld:                          stack.Push                              (new ExpressionStackEntry                                   (cell.Read().CloneIfStruct(compEnv)' ReadArgLocalE(sli.ArgLocal' sli.Index)));                          return true;                      case ArgLocalOp.Lda:                          // Effect will be accounted for on reads/writes                          stack.Push(new ExpressionStackEntry(cell.AddressOf()' BottomE));                          return true;                      case ArgLocalOp.St:                          return stack.PopEvalSE                              (statements'                               1'                               true'                               WriteArgLocalE(sli.ArgLocal' sli.Index)'                               (s' a) => s.Add(new ExpressionStatement(cell.Write(a[0]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                          {                              stack.Push                                  (new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' ReadHeapE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                       {                                           var readEffect = default(Effects);                                           var obj = default(Expression);                                           if (fieldi.IsViaPointer.Value)                                           {                                               readEffect = e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect());                                               obj = new ReadExpression(a[0]); // no need for clone                                           }                                           else if (fieldi.Field.DefiningType.Style(compEnv) is ValueTypeStyle)                                           {                                               readEffect = e;                                               obj = a[0];                                           }                                           else                                           {                                               // Object could be null                                               readEffect = e.Lub(ReadHeapOrThrowE);                                               obj = a[0];                                           }                                           return new ExpressionStackEntry(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' readEffect);                                       });                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                          {                              // Effect will be accounted for on reads/writes                              stack.Push(new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' BottomE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   {                                       if (fieldi.IsViaPointer.Value)                                           // We're just adding an offset to a pointer' so effect will                                           // be accounted for when the final pointer is read/written                                           return new ExpressionStackEntry(new FieldCell(new ReadExpression(a[0])' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e);                                       else                                           // Must be a reference type' and ref could be null                                           return new ExpressionStackEntry(new FieldCell(a[0]' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e.Lub(ThrowsE));                                   });                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                              return stack.PopEvalSE                                  (statements'                                   1'                                   true'                                   WriteHeapE'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Write(a[0]))));                          else                          {                              var writeEffect = fieldi.IsViaPointer.Value                                                    ? instruction.BeforeState.PeekPointsTo(1).WriteEffect()                                                    : WriteHeapOrThrowE;                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   writeEffect'                                   (s' a) =>                                       {                                           var obj = fieldi.IsViaPointer.Value ? new ReadExpression(a[0]) : a[0];                                           s.Add(new ExpressionStatement(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Write(a[1])));                                       });                          }                      case FieldOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new FieldHandleConstantExpression(compEnv.SubstituteMember(fieldi.Field))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methodi = (MethodInstruction)instruction;                      var arity = methodi.Method.ValueParameters.Count;                      switch (methodi.Op)                      {                      case MethodOp.Ldftn:                          if (methodi.IsVirtual)                              // Object could be null                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CodePointerExpression(a[0]' compEnv.SubstituteMember(methodi.Method))' e.Lub(ReadHeapOrThrowE)));                          else                          {                              stack.Push                                  (new ExpressionStackEntry(new CodePointerExpression(null' compEnv.SubstituteMember(methodi.Method))' BottomE));                              return true;                          }                      case MethodOp.Call:                          if (methodi.Method.Result == null)                              return stack.PopEvalSE                                  (statements'                                   arity'                                   true'                                   CalleeEffects(methodi.BeforeState' arity)'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new CallExpression                                                 (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal'                                                  compEnv.SubstituteMember(methodi.Method)'                                                  CallerArguments(methodi.Constrained' methodi.Method' a)))));                          else                              return stack.PopEvalPush                                  (statements'                                   arity'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CallExpression                                            (methodi.IsVirtual? CallFlavor.Virtual : CallFlavor.Normal'                                             compEnv.SubstituteMember(methodi.Method)'                                             CallerArguments(methodi.Constrained' methodi.Method' a))'                                        e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Newobj:                          arity--;                          return stack.PopEvalPush                              (statements'                               arity'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new NewObjectExpression(compEnv.SubstituteMember(methodi.Method)' CallerArguments(null' methodi.Method' a))'                                    e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Ldtoken:                          stack.Push                              (new ExpressionStackEntry(new MethodHandleConstantExpression(compEnv.SubstituteMember(methodi.Method))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case TypeOp.Stobj:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case TypeOp.Cpobj:                          {                              var copyEffect = instruction.BeforeState.PeekPointsTo(0).ReadEffect().Lub                                  (instruction.BeforeState.PeekPointsTo(1).WriteEffect());                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   copyEffect'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new WriteExpression(a[0]' new ReadExpression(a[1]).CloneIfStruct(compEnv)))));                          }                      case TypeOp.Newarr:                          // Growing the heap is not considered an observable change. But will throw if                          // length < 0                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new NewArrayExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Initobj:                          return stack.PopEvalSE                              (statements' 1' true' WriteHeapE' (s' a) => s.Add(new InitializeObjectStatement(a[0])));                      case TypeOp.Castclass:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new CastExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Isinst:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new IsInstExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Box:                          // Growing the heap is not considered an observable change                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new NewBoxExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Unbox:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).AddressOf()' e.Lub(ThrowsE)));                      case TypeOp.UnboxAny:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).Read().CloneIfStruct(compEnv)' e.Lub(ThrowsE)));                      case TypeOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new TypeHandleConstantExpression(compEnv.SubstituteType(typei.Type))' BottomE));                          return true;                      case TypeOp.Ldelem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case TypeOp.Stelem:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add(new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  // Calculating the pointer may throw if index is out of range.                  // Remaining effect will be accounted for when pointer is read/written.                  return stack.PopEvalPush                      (statements'                       2'                       true'                       (a' e) =>                       new ExpressionStackEntry(new ElementCell(a[0]' a[1]' false).AddressOf()' e.Lub(ThrowsE)));              case InstructionFlavor.LdInt32:                  {                      var int32i = (LdInt32Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int32ConstantExpression(int32i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdInt64:                  {                      var int64i = (LdInt64Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int64ConstantExpression(int64i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdSingle:                  {                      var singlei = (LdSingleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new SingleConstantExpression(singlei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdDouble:                  {                      var doublei = (LdDoubleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new DoubleConstantExpression(doublei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdString:                  {                      var stringi = (LdStringInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new StringConstantExpression(stringi.Value)' BottomE));                      return true;                  }              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Div:                      case ArithOp.Rem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(ThrowsE)));                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                      case ArithOp.Shl:                      case ArithOp.Shr:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(arithi.WithOverflow ? ThrowsE : BottomE)));                      case ArithOp.Neg:                      case ArithOp.BitNot:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression                                        (a[0]' ArithOpToUnaryOp(arithi.Op)' arithi.WithOverflow' arithi.IsUnsigned)'                                    e));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      return stack.PopEvalPush                          (statements'                           1'                           true'                           (a' e) =>                           new ExpressionStackEntry                               (new ConvertExpression                                    (a[0]'                                     new NamedTypeRef                                         (compEnv.Global.NumberFlavorToQualifiedTypeName[convi.TargetNumberFlavor])'                                     convi.WithOverflow'                                     convi.IsSourceUnsigned)'                                e.Lub(convi.WithOverflow ? ThrowsE : BottomE)));                  }              case InstructionFlavor.Try:                  {                      if (stack.Depth > 0)                          throw new InvalidOperationException("stack must be empty on entry to try block");                      var tryi = (TryInstruction)instruction;                      var tryStatements = BlockToTryFaultFinallyStatements(tryi.Body);                      if (tryStatements == null)                          return false;                      var handlers = TranslateHandlers(tryi.Handlers);                      if (handlers == null)                          return false;                      if (statements == null)                          return Failed(false' "try");                      statements.Add(new TryStatement(tryStatements' handlers));                      return true;                  }              case InstructionFlavor.IfThenElsePseudo:                  {                      var itei = (IfThenElseInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(itei.Offset' out isExpr) ||                                              isExpr;                        if (!TranslateBlock(statements' itei.Condition' stack' exid))                          return false;                      if (couldBeExpression && itei.Else != null)                      {                          // Pass 1: Try to tranlate to an if-then-else expression. Will only work if Then and Else don't                          //         reach into current stack' push exactly one value' and don't need to emit any                          //         statements along the way.                          var thenEntry = BlockToExpression(itei.Then' exid);                          if (thenEntry != null)                          {                              var elseEntry = BlockToExpression(itei.Else' exid);                              if (elseEntry != null)                              {                                  if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                                      instructionTranslationStyleCache.Add(itei.Offset' true);                                  return stack.PopEvalPush                                      (statements'                                       1'                                       true'                                       (a' e) =>                                       new ExpressionStackEntry                                           (new IfThenElseExpression(a[0]' thenEntry.Expression' elseEntry.Expression)'                                            e.Lub(thenEntry.Effects.Lub(elseEntry.Effects))));                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      var noStackChange = itei.Then.NoStackChange && (itei.Else == null || itei.Else.NoStackChange);                      var condEntry = noStackChange                                          ? stack.Pop()                                          : stack.FlushAndPopPostState(statements' itei.Then.BeforeState);                      if (condEntry == null)                          return false;                      var thenStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Then' exid)                                           : BlockToStatements(itei.Then' exid);                      if (thenStmnts == null)                          return false;                      var elseStmnts = default(Seq<Statement>);                      if (itei.Else != null)                      {                          elseStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Else' exid)                                           : BlockToStatements(itei.Else' exid);                          if (elseStmnts == null)                              return false;                      }                      if (statements == null)                          return Failed(false' "if-then-else");                      statements.Add                          (new IfThenElseStatement(condEntry.Expression' new Statements(thenStmnts)' elseStmnts == null ? null : new Statements(elseStmnts)));                      if (!noStackChange && !stack.Restore(itei.AfterState' 0))                          return false;                      if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                          instructionTranslationStyleCache.Add(itei.Offset' false);                      return true;                  }              case InstructionFlavor.ShortCircuitingPseudo:                  {                      var sci = (ShortCircuitingInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(sci.Offset' out isExpr) ||                                              isExpr;                      if (couldBeExpression)                      {                          // Pass 1: Try to translate to an expression.                          var leftEntry = BlockToExpression(sci.Left' exid);                          if (leftEntry != null)                          {                              var rightEntry = BlockToExpression(sci.Right' exid);                              if (rightEntry != null)                              {                                  stack.Push                                      (new ExpressionStackEntry                                           (new BinaryExpression                                                (leftEntry.Expression'                                                 ShortCircuitingOpToBinaryOp(sci.Op)'                                                 rightEntry.Expression'                                                 false'                                                 false)'                                            leftEntry.Effects.Lub(rightEntry.Effects)));                                  if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                                      instructionTranslationStyleCache.Add(sci.Offset' true);                                  return true;                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      if (!TranslateBlock(statements' sci.Left' stack' exid))                          return false;                      var leftEntry2 = stack.FlushAndPopPostState(statements' sci.Right.BeforeState);                      if (leftEntry2 == null)                          return false;                      var rightStatements = BlockToStatements(sci.Right' exid);                      if (rightStatements == null)                          return false;                      var id = sci.Right.AfterState.PeekId(0' nameSupply.GenSym);                      var cell = new VariableCell(id);                      compEnv.AddVariable(id' ArgLocal.Local' false' true' compEnv.SubstituteType(sci.Right.AfterState.PeekType(0)));                      if (statements == null)                          return Failed(false' "short-circuit");                      switch (sci.Op)                      {                      case ShortCircuitingOp.And:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements(rightStatements)'                                    new Statements                                        (new ExpressionStatement(cell.Write(new Int32ConstantExpression(0))))));                          break;                      case ShortCircuitingOp.Or:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements                                        (new ExpressionStatement                                             (cell.Write(new Int32ConstantExpression(1))))'                                    new Statements(rightStatements)));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      if (!stack.Restore(sci.AfterState' 1))                          return false;                      stack.Push(new ExpressionStackEntry(cell.Read()' BottomE));                      if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                          instructionTranslationStyleCache.Add(sci.Offset' false);                      return true;                  }              case InstructionFlavor.StructuralSwitchPseudo:                  {                      var ssi = (StructuralSwitchInstruction)instruction;                      if (!TranslateBlock(statements' ssi.Body' stack' exid))                          return false;                      var valueEntry = stack.FlushAndPopPreState(statements' ssi.Body.AfterState);                      if (valueEntry == null)                          return false;                      var cases = new Seq<SwitchStatementCase>();                      foreach (var c in ssi.Cases)                      {                          var caseStatements = BlockToStatements(c.Body' exid);                          if (caseStatements == null)                              return false;                          cases.Add(new SwitchStatementCase(c.Values' new Statements(caseStatements)));                      }                      if (statements == null)                          return Failed(false' "structural switch");                      statements.Add(new SwitchStatement(valueEntry.Expression' cases));                      if (!stack.Restore(ssi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopPseudo:                  {                      var li = (LoopInstruction)instruction;                      if (!stack.Flush(statements' li.Body.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop");                      var whileStatements = BlockToStatements(li.Body' exid);                      statements.Add                          (new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(whileStatements)));                      if (!stack.Restore(li.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.WhileDoPseudo:                  {                      var wdi = (WhileDoInstruction)instruction;                      if (!stack.Flush(statements' wdi.Condition.BeforeState))                          return false;                      var condEntry = BlockToExpression(wdi.Condition' exid);                      if (condEntry == null)                      {                          var stack1 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Condition.BeforeState' trace);                          var preCondStatements = new Seq<Statement>();                          if (!TranslateBlock(preCondStatements' wdi.Condition' stack1' exid))                              return false;                          condEntry = stack1.FlushAndPopPostState(preCondStatements' wdi.Body.BeforeState);                          if (condEntry == null)                              return false;                          var stack2 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Body.BeforeState' trace);                          var postCondStatements = new Seq<Statement>();                          if (!TranslateBlock(postCondStatements' wdi.Body' stack2' exid))                              return false;                          if (!stack2.Flush(postCondStatements' wdi.Body.AfterState))                              return false;                          preCondStatements.Add                              (new IfThenElseStatement                                   (condEntry.Expression'                                    new Statements(postCondStatements)'                                    new Statements(new BreakStatement())));                          statements.Add(new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(preCondStatements)));                      }                      else                      {                          var loopStatements = BlockToStatements(wdi.Body' exid);                          if (loopStatements == null)                              return false;                          if (statements == null)                              return Failed(false' "while-do");                          statements.Add(new WhileDoStatement(condEntry.Expression' new Statements(loopStatements)));                      }                      if (!stack.Restore(wdi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.DoWhilePseudo:                  {                      var dwi = (DoWhileInstruction)instruction;                      if (!stack.Flush(statements' dwi.Body.BeforeState))                          return false;                      var combined = new Seq<Instruction>();                      foreach (var i in dwi.Body.Body)                          combined.Add(i);                      foreach (var i in dwi.Condition.Body)                          combined.Add(i);                      var condEntry = default(ExpressionStackEntry);                      var loopStatements = BlockToConditionStatements                          (new Instructions(null' combined)' dwi.Body.BeforeState' exid' out condEntry);                      if (loopStatements == null)                          return false;                      if (statements == null)                          return Failed(false' "do-while");                      statements.Add(new DoWhileStatement(new Statements(loopStatements)' condEntry.Expression));                      if (!stack.Restore(dwi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopControlPseudo:                  {                      var lci = (BreakContinueInstruction)instruction;                      if (!stack.Flush(statements' lci.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop-control");                      var targetState = default(int);                      switch (lci.Op)                      {                      case BreakContinueOp.Break:                          if (labelToLoopCandidateBreakState != null &&                              labelToLoopCandidateBreakState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new BreakStatement(lci.Label));                          break;                      case BreakContinueOp.Continue:                          if (labelToLoopCandidateContinueState != null &&                              labelToLoopCandidateContinueState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new ContinueStatement(lci.Label));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      return true;                  }              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return true;                      case MiscOp.Dup:                          return stack.Dup(statements);                      case MiscOp.Pop:                          return stack.PopAndDiscard(statements);                      case MiscOp.Ldnull:                          stack.Push(new ExpressionStackEntry(new NullConstantExpression()' BottomE));                          return true;                      case MiscOp.Ckfinite:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.CheckFinite' false' false)' e.Lub(ThrowsE)));                      case MiscOp.Throw:                          if (!stack.DiscardAll(statements' 1))                              return false;                          if (!stack.PopEvalSE(statements' 1' true' ThrowsE' (s' a) => s.Add(new ThrowStatement(a[0]))))                              return false;                          return true;                      case MiscOp.Rethrow:                          if (!stack.DiscardAll(statements' 0))                              return false;                          if (statements == null)                              return Failed(false' "rethrow");                          if (exid == null)                              throw new InvalidOperationException("rethrow outside of catch");                          statements.Add(new RethrowStatement(new VariableCell(exid).Read()));                          return true;                      case MiscOp.LdindRef:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case MiscOp.LdelemRef:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.Ldlen:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.Length' false' false)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.StindRef:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case MiscOp.StelemRef:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add                                   (new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      case MiscOp.Ret:                          if (statements == null)                              return Failed(false' "return");                          statements.Add(new ReturnStatement(null));                          return true;                      case MiscOp.RetVal:                          return stack.PopEvalSE                              (statements' 1' true' BottomE' (s' a) => s.Add(new ReturnStatement(a[0])));                      case MiscOp.Endfilter:                      case MiscOp.Endfinally:                          throw new InvalidOperationException                              ("endfilter/endfinally instructions should have been removed");                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:              case InstructionFlavor.Switch:                  throw new InvalidOperationException("branch/switch instructions should have been removed");              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      if (cmpi.Op == CompareOp.CtruePseudo || cmpi.Op == CompareOp.CfalsePseudo)                      {                          var s = cmpi.Type.Style(compEnv);                          var unop = default(UnaryOp);                          if (s is NumberTypeStyle)                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonZero : UnaryOp.IsZero;                          else                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonNull : UnaryOp.IsNull;                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new UnaryExpression(a[0]' unop' false' cmpi.IsUnsigned)' e));                      }                      else                      {                          var binop = default(BinaryOp);                          switch (cmpi.Op)                          {                          case CompareOp.Ceq:                              binop = BinaryOp.Eq;                              break;                          case CompareOp.Clt:                              binop = BinaryOp.Lt;                              break;                          case CompareOp.Cgt:                              binop = BinaryOp.Gt;                              break;                          case CompareOp.CgePseudo:                              binop = BinaryOp.Ge;                              break;                          case CompareOp.ClePseudo:                              binop = BinaryOp.Le;                              break;                          case CompareOp.CnePseudo:                              binop = BinaryOp.Ne;                              break;                          case CompareOp.CtruePseudo:                          case CompareOp.CfalsePseudo:                              // handled above                              throw new InvalidOperationException();                          default:                              throw new ArgumentOutOfRangeException();                          }                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression(a[0]' binop' a[1]' false' cmpi.IsUnsigned)' e));                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var sli = (ArgLocalInstruction)instruction;                      var id = default(JST.Identifier);                      switch (sli.ArgLocal)                      {                      case ArgLocal.Arg:                          id = compEnv.ValueParameterIds[sli.Index];                          break;                      case ArgLocal.Local:                          id = compEnv.LocalIds[sli.Index];                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      var cell = new VariableCell(id);                      switch (sli.Op)                      {                      case ArgLocalOp.Ld:                          stack.Push                              (new ExpressionStackEntry                                   (cell.Read().CloneIfStruct(compEnv)' ReadArgLocalE(sli.ArgLocal' sli.Index)));                          return true;                      case ArgLocalOp.Lda:                          // Effect will be accounted for on reads/writes                          stack.Push(new ExpressionStackEntry(cell.AddressOf()' BottomE));                          return true;                      case ArgLocalOp.St:                          return stack.PopEvalSE                              (statements'                               1'                               true'                               WriteArgLocalE(sli.ArgLocal' sli.Index)'                               (s' a) => s.Add(new ExpressionStatement(cell.Write(a[0]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                          {                              stack.Push                                  (new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' ReadHeapE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                       {                                           var readEffect = default(Effects);                                           var obj = default(Expression);                                           if (fieldi.IsViaPointer.Value)                                           {                                               readEffect = e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect());                                               obj = new ReadExpression(a[0]); // no need for clone                                           }                                           else if (fieldi.Field.DefiningType.Style(compEnv) is ValueTypeStyle)                                           {                                               readEffect = e;                                               obj = a[0];                                           }                                           else                                           {                                               // Object could be null                                               readEffect = e.Lub(ReadHeapOrThrowE);                                               obj = a[0];                                           }                                           return new ExpressionStackEntry(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' readEffect);                                       });                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                          {                              // Effect will be accounted for on reads/writes                              stack.Push(new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' BottomE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   {                                       if (fieldi.IsViaPointer.Value)                                           // We're just adding an offset to a pointer' so effect will                                           // be accounted for when the final pointer is read/written                                           return new ExpressionStackEntry(new FieldCell(new ReadExpression(a[0])' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e);                                       else                                           // Must be a reference type' and ref could be null                                           return new ExpressionStackEntry(new FieldCell(a[0]' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e.Lub(ThrowsE));                                   });                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                              return stack.PopEvalSE                                  (statements'                                   1'                                   true'                                   WriteHeapE'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Write(a[0]))));                          else                          {                              var writeEffect = fieldi.IsViaPointer.Value                                                    ? instruction.BeforeState.PeekPointsTo(1).WriteEffect()                                                    : WriteHeapOrThrowE;                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   writeEffect'                                   (s' a) =>                                       {                                           var obj = fieldi.IsViaPointer.Value ? new ReadExpression(a[0]) : a[0];                                           s.Add(new ExpressionStatement(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Write(a[1])));                                       });                          }                      case FieldOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new FieldHandleConstantExpression(compEnv.SubstituteMember(fieldi.Field))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methodi = (MethodInstruction)instruction;                      var arity = methodi.Method.ValueParameters.Count;                      switch (methodi.Op)                      {                      case MethodOp.Ldftn:                          if (methodi.IsVirtual)                              // Object could be null                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CodePointerExpression(a[0]' compEnv.SubstituteMember(methodi.Method))' e.Lub(ReadHeapOrThrowE)));                          else                          {                              stack.Push                                  (new ExpressionStackEntry(new CodePointerExpression(null' compEnv.SubstituteMember(methodi.Method))' BottomE));                              return true;                          }                      case MethodOp.Call:                          if (methodi.Method.Result == null)                              return stack.PopEvalSE                                  (statements'                                   arity'                                   true'                                   CalleeEffects(methodi.BeforeState' arity)'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new CallExpression                                                 (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal'                                                  compEnv.SubstituteMember(methodi.Method)'                                                  CallerArguments(methodi.Constrained' methodi.Method' a)))));                          else                              return stack.PopEvalPush                                  (statements'                                   arity'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CallExpression                                            (methodi.IsVirtual? CallFlavor.Virtual : CallFlavor.Normal'                                             compEnv.SubstituteMember(methodi.Method)'                                             CallerArguments(methodi.Constrained' methodi.Method' a))'                                        e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Newobj:                          arity--;                          return stack.PopEvalPush                              (statements'                               arity'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new NewObjectExpression(compEnv.SubstituteMember(methodi.Method)' CallerArguments(null' methodi.Method' a))'                                    e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Ldtoken:                          stack.Push                              (new ExpressionStackEntry(new MethodHandleConstantExpression(compEnv.SubstituteMember(methodi.Method))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case TypeOp.Stobj:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case TypeOp.Cpobj:                          {                              var copyEffect = instruction.BeforeState.PeekPointsTo(0).ReadEffect().Lub                                  (instruction.BeforeState.PeekPointsTo(1).WriteEffect());                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   copyEffect'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new WriteExpression(a[0]' new ReadExpression(a[1]).CloneIfStruct(compEnv)))));                          }                      case TypeOp.Newarr:                          // Growing the heap is not considered an observable change. But will throw if                          // length < 0                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new NewArrayExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Initobj:                          return stack.PopEvalSE                              (statements' 1' true' WriteHeapE' (s' a) => s.Add(new InitializeObjectStatement(a[0])));                      case TypeOp.Castclass:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new CastExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Isinst:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new IsInstExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Box:                          // Growing the heap is not considered an observable change                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new NewBoxExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Unbox:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).AddressOf()' e.Lub(ThrowsE)));                      case TypeOp.UnboxAny:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).Read().CloneIfStruct(compEnv)' e.Lub(ThrowsE)));                      case TypeOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new TypeHandleConstantExpression(compEnv.SubstituteType(typei.Type))' BottomE));                          return true;                      case TypeOp.Ldelem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case TypeOp.Stelem:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add(new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  // Calculating the pointer may throw if index is out of range.                  // Remaining effect will be accounted for when pointer is read/written.                  return stack.PopEvalPush                      (statements'                       2'                       true'                       (a' e) =>                       new ExpressionStackEntry(new ElementCell(a[0]' a[1]' false).AddressOf()' e.Lub(ThrowsE)));              case InstructionFlavor.LdInt32:                  {                      var int32i = (LdInt32Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int32ConstantExpression(int32i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdInt64:                  {                      var int64i = (LdInt64Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int64ConstantExpression(int64i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdSingle:                  {                      var singlei = (LdSingleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new SingleConstantExpression(singlei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdDouble:                  {                      var doublei = (LdDoubleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new DoubleConstantExpression(doublei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdString:                  {                      var stringi = (LdStringInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new StringConstantExpression(stringi.Value)' BottomE));                      return true;                  }              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Div:                      case ArithOp.Rem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(ThrowsE)));                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                      case ArithOp.Shl:                      case ArithOp.Shr:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(arithi.WithOverflow ? ThrowsE : BottomE)));                      case ArithOp.Neg:                      case ArithOp.BitNot:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression                                        (a[0]' ArithOpToUnaryOp(arithi.Op)' arithi.WithOverflow' arithi.IsUnsigned)'                                    e));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      return stack.PopEvalPush                          (statements'                           1'                           true'                           (a' e) =>                           new ExpressionStackEntry                               (new ConvertExpression                                    (a[0]'                                     new NamedTypeRef                                         (compEnv.Global.NumberFlavorToQualifiedTypeName[convi.TargetNumberFlavor])'                                     convi.WithOverflow'                                     convi.IsSourceUnsigned)'                                e.Lub(convi.WithOverflow ? ThrowsE : BottomE)));                  }              case InstructionFlavor.Try:                  {                      if (stack.Depth > 0)                          throw new InvalidOperationException("stack must be empty on entry to try block");                      var tryi = (TryInstruction)instruction;                      var tryStatements = BlockToTryFaultFinallyStatements(tryi.Body);                      if (tryStatements == null)                          return false;                      var handlers = TranslateHandlers(tryi.Handlers);                      if (handlers == null)                          return false;                      if (statements == null)                          return Failed(false' "try");                      statements.Add(new TryStatement(tryStatements' handlers));                      return true;                  }              case InstructionFlavor.IfThenElsePseudo:                  {                      var itei = (IfThenElseInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(itei.Offset' out isExpr) ||                                              isExpr;                        if (!TranslateBlock(statements' itei.Condition' stack' exid))                          return false;                      if (couldBeExpression && itei.Else != null)                      {                          // Pass 1: Try to tranlate to an if-then-else expression. Will only work if Then and Else don't                          //         reach into current stack' push exactly one value' and don't need to emit any                          //         statements along the way.                          var thenEntry = BlockToExpression(itei.Then' exid);                          if (thenEntry != null)                          {                              var elseEntry = BlockToExpression(itei.Else' exid);                              if (elseEntry != null)                              {                                  if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                                      instructionTranslationStyleCache.Add(itei.Offset' true);                                  return stack.PopEvalPush                                      (statements'                                       1'                                       true'                                       (a' e) =>                                       new ExpressionStackEntry                                           (new IfThenElseExpression(a[0]' thenEntry.Expression' elseEntry.Expression)'                                            e.Lub(thenEntry.Effects.Lub(elseEntry.Effects))));                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      var noStackChange = itei.Then.NoStackChange && (itei.Else == null || itei.Else.NoStackChange);                      var condEntry = noStackChange                                          ? stack.Pop()                                          : stack.FlushAndPopPostState(statements' itei.Then.BeforeState);                      if (condEntry == null)                          return false;                      var thenStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Then' exid)                                           : BlockToStatements(itei.Then' exid);                      if (thenStmnts == null)                          return false;                      var elseStmnts = default(Seq<Statement>);                      if (itei.Else != null)                      {                          elseStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Else' exid)                                           : BlockToStatements(itei.Else' exid);                          if (elseStmnts == null)                              return false;                      }                      if (statements == null)                          return Failed(false' "if-then-else");                      statements.Add                          (new IfThenElseStatement(condEntry.Expression' new Statements(thenStmnts)' elseStmnts == null ? null : new Statements(elseStmnts)));                      if (!noStackChange && !stack.Restore(itei.AfterState' 0))                          return false;                      if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                          instructionTranslationStyleCache.Add(itei.Offset' false);                      return true;                  }              case InstructionFlavor.ShortCircuitingPseudo:                  {                      var sci = (ShortCircuitingInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(sci.Offset' out isExpr) ||                                              isExpr;                      if (couldBeExpression)                      {                          // Pass 1: Try to translate to an expression.                          var leftEntry = BlockToExpression(sci.Left' exid);                          if (leftEntry != null)                          {                              var rightEntry = BlockToExpression(sci.Right' exid);                              if (rightEntry != null)                              {                                  stack.Push                                      (new ExpressionStackEntry                                           (new BinaryExpression                                                (leftEntry.Expression'                                                 ShortCircuitingOpToBinaryOp(sci.Op)'                                                 rightEntry.Expression'                                                 false'                                                 false)'                                            leftEntry.Effects.Lub(rightEntry.Effects)));                                  if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                                      instructionTranslationStyleCache.Add(sci.Offset' true);                                  return true;                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      if (!TranslateBlock(statements' sci.Left' stack' exid))                          return false;                      var leftEntry2 = stack.FlushAndPopPostState(statements' sci.Right.BeforeState);                      if (leftEntry2 == null)                          return false;                      var rightStatements = BlockToStatements(sci.Right' exid);                      if (rightStatements == null)                          return false;                      var id = sci.Right.AfterState.PeekId(0' nameSupply.GenSym);                      var cell = new VariableCell(id);                      compEnv.AddVariable(id' ArgLocal.Local' false' true' compEnv.SubstituteType(sci.Right.AfterState.PeekType(0)));                      if (statements == null)                          return Failed(false' "short-circuit");                      switch (sci.Op)                      {                      case ShortCircuitingOp.And:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements(rightStatements)'                                    new Statements                                        (new ExpressionStatement(cell.Write(new Int32ConstantExpression(0))))));                          break;                      case ShortCircuitingOp.Or:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements                                        (new ExpressionStatement                                             (cell.Write(new Int32ConstantExpression(1))))'                                    new Statements(rightStatements)));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      if (!stack.Restore(sci.AfterState' 1))                          return false;                      stack.Push(new ExpressionStackEntry(cell.Read()' BottomE));                      if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                          instructionTranslationStyleCache.Add(sci.Offset' false);                      return true;                  }              case InstructionFlavor.StructuralSwitchPseudo:                  {                      var ssi = (StructuralSwitchInstruction)instruction;                      if (!TranslateBlock(statements' ssi.Body' stack' exid))                          return false;                      var valueEntry = stack.FlushAndPopPreState(statements' ssi.Body.AfterState);                      if (valueEntry == null)                          return false;                      var cases = new Seq<SwitchStatementCase>();                      foreach (var c in ssi.Cases)                      {                          var caseStatements = BlockToStatements(c.Body' exid);                          if (caseStatements == null)                              return false;                          cases.Add(new SwitchStatementCase(c.Values' new Statements(caseStatements)));                      }                      if (statements == null)                          return Failed(false' "structural switch");                      statements.Add(new SwitchStatement(valueEntry.Expression' cases));                      if (!stack.Restore(ssi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopPseudo:                  {                      var li = (LoopInstruction)instruction;                      if (!stack.Flush(statements' li.Body.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop");                      var whileStatements = BlockToStatements(li.Body' exid);                      statements.Add                          (new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(whileStatements)));                      if (!stack.Restore(li.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.WhileDoPseudo:                  {                      var wdi = (WhileDoInstruction)instruction;                      if (!stack.Flush(statements' wdi.Condition.BeforeState))                          return false;                      var condEntry = BlockToExpression(wdi.Condition' exid);                      if (condEntry == null)                      {                          var stack1 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Condition.BeforeState' trace);                          var preCondStatements = new Seq<Statement>();                          if (!TranslateBlock(preCondStatements' wdi.Condition' stack1' exid))                              return false;                          condEntry = stack1.FlushAndPopPostState(preCondStatements' wdi.Body.BeforeState);                          if (condEntry == null)                              return false;                          var stack2 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Body.BeforeState' trace);                          var postCondStatements = new Seq<Statement>();                          if (!TranslateBlock(postCondStatements' wdi.Body' stack2' exid))                              return false;                          if (!stack2.Flush(postCondStatements' wdi.Body.AfterState))                              return false;                          preCondStatements.Add                              (new IfThenElseStatement                                   (condEntry.Expression'                                    new Statements(postCondStatements)'                                    new Statements(new BreakStatement())));                          statements.Add(new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(preCondStatements)));                      }                      else                      {                          var loopStatements = BlockToStatements(wdi.Body' exid);                          if (loopStatements == null)                              return false;                          if (statements == null)                              return Failed(false' "while-do");                          statements.Add(new WhileDoStatement(condEntry.Expression' new Statements(loopStatements)));                      }                      if (!stack.Restore(wdi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.DoWhilePseudo:                  {                      var dwi = (DoWhileInstruction)instruction;                      if (!stack.Flush(statements' dwi.Body.BeforeState))                          return false;                      var combined = new Seq<Instruction>();                      foreach (var i in dwi.Body.Body)                          combined.Add(i);                      foreach (var i in dwi.Condition.Body)                          combined.Add(i);                      var condEntry = default(ExpressionStackEntry);                      var loopStatements = BlockToConditionStatements                          (new Instructions(null' combined)' dwi.Body.BeforeState' exid' out condEntry);                      if (loopStatements == null)                          return false;                      if (statements == null)                          return Failed(false' "do-while");                      statements.Add(new DoWhileStatement(new Statements(loopStatements)' condEntry.Expression));                      if (!stack.Restore(dwi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopControlPseudo:                  {                      var lci = (BreakContinueInstruction)instruction;                      if (!stack.Flush(statements' lci.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop-control");                      var targetState = default(int);                      switch (lci.Op)                      {                      case BreakContinueOp.Break:                          if (labelToLoopCandidateBreakState != null &&                              labelToLoopCandidateBreakState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new BreakStatement(lci.Label));                          break;                      case BreakContinueOp.Continue:                          if (labelToLoopCandidateContinueState != null &&                              labelToLoopCandidateContinueState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new ContinueStatement(lci.Label));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      return true;                  }              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return true;                      case MiscOp.Dup:                          return stack.Dup(statements);                      case MiscOp.Pop:                          return stack.PopAndDiscard(statements);                      case MiscOp.Ldnull:                          stack.Push(new ExpressionStackEntry(new NullConstantExpression()' BottomE));                          return true;                      case MiscOp.Ckfinite:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.CheckFinite' false' false)' e.Lub(ThrowsE)));                      case MiscOp.Throw:                          if (!stack.DiscardAll(statements' 1))                              return false;                          if (!stack.PopEvalSE(statements' 1' true' ThrowsE' (s' a) => s.Add(new ThrowStatement(a[0]))))                              return false;                          return true;                      case MiscOp.Rethrow:                          if (!stack.DiscardAll(statements' 0))                              return false;                          if (statements == null)                              return Failed(false' "rethrow");                          if (exid == null)                              throw new InvalidOperationException("rethrow outside of catch");                          statements.Add(new RethrowStatement(new VariableCell(exid).Read()));                          return true;                      case MiscOp.LdindRef:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case MiscOp.LdelemRef:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.Ldlen:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.Length' false' false)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.StindRef:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case MiscOp.StelemRef:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add                                   (new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      case MiscOp.Ret:                          if (statements == null)                              return Failed(false' "return");                          statements.Add(new ReturnStatement(null));                          return true;                      case MiscOp.RetVal:                          return stack.PopEvalSE                              (statements' 1' true' BottomE' (s' a) => s.Add(new ReturnStatement(a[0])));                      case MiscOp.Endfilter:                      case MiscOp.Endfinally:                          throw new InvalidOperationException                              ("endfilter/endfinally instructions should have been removed");                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:              case InstructionFlavor.Switch:                  throw new InvalidOperationException("branch/switch instructions should have been removed");              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      if (cmpi.Op == CompareOp.CtruePseudo || cmpi.Op == CompareOp.CfalsePseudo)                      {                          var s = cmpi.Type.Style(compEnv);                          var unop = default(UnaryOp);                          if (s is NumberTypeStyle)                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonZero : UnaryOp.IsZero;                          else                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonNull : UnaryOp.IsNull;                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new UnaryExpression(a[0]' unop' false' cmpi.IsUnsigned)' e));                      }                      else                      {                          var binop = default(BinaryOp);                          switch (cmpi.Op)                          {                          case CompareOp.Ceq:                              binop = BinaryOp.Eq;                              break;                          case CompareOp.Clt:                              binop = BinaryOp.Lt;                              break;                          case CompareOp.Cgt:                              binop = BinaryOp.Gt;                              break;                          case CompareOp.CgePseudo:                              binop = BinaryOp.Ge;                              break;                          case CompareOp.ClePseudo:                              binop = BinaryOp.Le;                              break;                          case CompareOp.CnePseudo:                              binop = BinaryOp.Ne;                              break;                          case CompareOp.CtruePseudo:                          case CompareOp.CfalsePseudo:                              // handled above                              throw new InvalidOperationException();                          default:                              throw new ArgumentOutOfRangeException();                          }                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression(a[0]' binop' a[1]' false' cmpi.IsUnsigned)' e));                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var sli = (ArgLocalInstruction)instruction;                      var id = default(JST.Identifier);                      switch (sli.ArgLocal)                      {                      case ArgLocal.Arg:                          id = compEnv.ValueParameterIds[sli.Index];                          break;                      case ArgLocal.Local:                          id = compEnv.LocalIds[sli.Index];                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      var cell = new VariableCell(id);                      switch (sli.Op)                      {                      case ArgLocalOp.Ld:                          stack.Push                              (new ExpressionStackEntry                                   (cell.Read().CloneIfStruct(compEnv)' ReadArgLocalE(sli.ArgLocal' sli.Index)));                          return true;                      case ArgLocalOp.Lda:                          // Effect will be accounted for on reads/writes                          stack.Push(new ExpressionStackEntry(cell.AddressOf()' BottomE));                          return true;                      case ArgLocalOp.St:                          return stack.PopEvalSE                              (statements'                               1'                               true'                               WriteArgLocalE(sli.ArgLocal' sli.Index)'                               (s' a) => s.Add(new ExpressionStatement(cell.Write(a[0]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                          {                              stack.Push                                  (new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' ReadHeapE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                       {                                           var readEffect = default(Effects);                                           var obj = default(Expression);                                           if (fieldi.IsViaPointer.Value)                                           {                                               readEffect = e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect());                                               obj = new ReadExpression(a[0]); // no need for clone                                           }                                           else if (fieldi.Field.DefiningType.Style(compEnv) is ValueTypeStyle)                                           {                                               readEffect = e;                                               obj = a[0];                                           }                                           else                                           {                                               // Object could be null                                               readEffect = e.Lub(ReadHeapOrThrowE);                                               obj = a[0];                                           }                                           return new ExpressionStackEntry(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' readEffect);                                       });                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                          {                              // Effect will be accounted for on reads/writes                              stack.Push(new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' BottomE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   {                                       if (fieldi.IsViaPointer.Value)                                           // We're just adding an offset to a pointer' so effect will                                           // be accounted for when the final pointer is read/written                                           return new ExpressionStackEntry(new FieldCell(new ReadExpression(a[0])' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e);                                       else                                           // Must be a reference type' and ref could be null                                           return new ExpressionStackEntry(new FieldCell(a[0]' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e.Lub(ThrowsE));                                   });                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                              return stack.PopEvalSE                                  (statements'                                   1'                                   true'                                   WriteHeapE'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Write(a[0]))));                          else                          {                              var writeEffect = fieldi.IsViaPointer.Value                                                    ? instruction.BeforeState.PeekPointsTo(1).WriteEffect()                                                    : WriteHeapOrThrowE;                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   writeEffect'                                   (s' a) =>                                       {                                           var obj = fieldi.IsViaPointer.Value ? new ReadExpression(a[0]) : a[0];                                           s.Add(new ExpressionStatement(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Write(a[1])));                                       });                          }                      case FieldOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new FieldHandleConstantExpression(compEnv.SubstituteMember(fieldi.Field))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methodi = (MethodInstruction)instruction;                      var arity = methodi.Method.ValueParameters.Count;                      switch (methodi.Op)                      {                      case MethodOp.Ldftn:                          if (methodi.IsVirtual)                              // Object could be null                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CodePointerExpression(a[0]' compEnv.SubstituteMember(methodi.Method))' e.Lub(ReadHeapOrThrowE)));                          else                          {                              stack.Push                                  (new ExpressionStackEntry(new CodePointerExpression(null' compEnv.SubstituteMember(methodi.Method))' BottomE));                              return true;                          }                      case MethodOp.Call:                          if (methodi.Method.Result == null)                              return stack.PopEvalSE                                  (statements'                                   arity'                                   true'                                   CalleeEffects(methodi.BeforeState' arity)'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new CallExpression                                                 (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal'                                                  compEnv.SubstituteMember(methodi.Method)'                                                  CallerArguments(methodi.Constrained' methodi.Method' a)))));                          else                              return stack.PopEvalPush                                  (statements'                                   arity'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CallExpression                                            (methodi.IsVirtual? CallFlavor.Virtual : CallFlavor.Normal'                                             compEnv.SubstituteMember(methodi.Method)'                                             CallerArguments(methodi.Constrained' methodi.Method' a))'                                        e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Newobj:                          arity--;                          return stack.PopEvalPush                              (statements'                               arity'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new NewObjectExpression(compEnv.SubstituteMember(methodi.Method)' CallerArguments(null' methodi.Method' a))'                                    e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Ldtoken:                          stack.Push                              (new ExpressionStackEntry(new MethodHandleConstantExpression(compEnv.SubstituteMember(methodi.Method))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case TypeOp.Stobj:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case TypeOp.Cpobj:                          {                              var copyEffect = instruction.BeforeState.PeekPointsTo(0).ReadEffect().Lub                                  (instruction.BeforeState.PeekPointsTo(1).WriteEffect());                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   copyEffect'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new WriteExpression(a[0]' new ReadExpression(a[1]).CloneIfStruct(compEnv)))));                          }                      case TypeOp.Newarr:                          // Growing the heap is not considered an observable change. But will throw if                          // length < 0                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new NewArrayExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Initobj:                          return stack.PopEvalSE                              (statements' 1' true' WriteHeapE' (s' a) => s.Add(new InitializeObjectStatement(a[0])));                      case TypeOp.Castclass:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new CastExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Isinst:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new IsInstExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Box:                          // Growing the heap is not considered an observable change                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new NewBoxExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Unbox:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).AddressOf()' e.Lub(ThrowsE)));                      case TypeOp.UnboxAny:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).Read().CloneIfStruct(compEnv)' e.Lub(ThrowsE)));                      case TypeOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new TypeHandleConstantExpression(compEnv.SubstituteType(typei.Type))' BottomE));                          return true;                      case TypeOp.Ldelem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case TypeOp.Stelem:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add(new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  // Calculating the pointer may throw if index is out of range.                  // Remaining effect will be accounted for when pointer is read/written.                  return stack.PopEvalPush                      (statements'                       2'                       true'                       (a' e) =>                       new ExpressionStackEntry(new ElementCell(a[0]' a[1]' false).AddressOf()' e.Lub(ThrowsE)));              case InstructionFlavor.LdInt32:                  {                      var int32i = (LdInt32Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int32ConstantExpression(int32i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdInt64:                  {                      var int64i = (LdInt64Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int64ConstantExpression(int64i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdSingle:                  {                      var singlei = (LdSingleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new SingleConstantExpression(singlei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdDouble:                  {                      var doublei = (LdDoubleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new DoubleConstantExpression(doublei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdString:                  {                      var stringi = (LdStringInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new StringConstantExpression(stringi.Value)' BottomE));                      return true;                  }              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Div:                      case ArithOp.Rem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(ThrowsE)));                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                      case ArithOp.Shl:                      case ArithOp.Shr:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(arithi.WithOverflow ? ThrowsE : BottomE)));                      case ArithOp.Neg:                      case ArithOp.BitNot:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression                                        (a[0]' ArithOpToUnaryOp(arithi.Op)' arithi.WithOverflow' arithi.IsUnsigned)'                                    e));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      return stack.PopEvalPush                          (statements'                           1'                           true'                           (a' e) =>                           new ExpressionStackEntry                               (new ConvertExpression                                    (a[0]'                                     new NamedTypeRef                                         (compEnv.Global.NumberFlavorToQualifiedTypeName[convi.TargetNumberFlavor])'                                     convi.WithOverflow'                                     convi.IsSourceUnsigned)'                                e.Lub(convi.WithOverflow ? ThrowsE : BottomE)));                  }              case InstructionFlavor.Try:                  {                      if (stack.Depth > 0)                          throw new InvalidOperationException("stack must be empty on entry to try block");                      var tryi = (TryInstruction)instruction;                      var tryStatements = BlockToTryFaultFinallyStatements(tryi.Body);                      if (tryStatements == null)                          return false;                      var handlers = TranslateHandlers(tryi.Handlers);                      if (handlers == null)                          return false;                      if (statements == null)                          return Failed(false' "try");                      statements.Add(new TryStatement(tryStatements' handlers));                      return true;                  }              case InstructionFlavor.IfThenElsePseudo:                  {                      var itei = (IfThenElseInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(itei.Offset' out isExpr) ||                                              isExpr;                        if (!TranslateBlock(statements' itei.Condition' stack' exid))                          return false;                      if (couldBeExpression && itei.Else != null)                      {                          // Pass 1: Try to tranlate to an if-then-else expression. Will only work if Then and Else don't                          //         reach into current stack' push exactly one value' and don't need to emit any                          //         statements along the way.                          var thenEntry = BlockToExpression(itei.Then' exid);                          if (thenEntry != null)                          {                              var elseEntry = BlockToExpression(itei.Else' exid);                              if (elseEntry != null)                              {                                  if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                                      instructionTranslationStyleCache.Add(itei.Offset' true);                                  return stack.PopEvalPush                                      (statements'                                       1'                                       true'                                       (a' e) =>                                       new ExpressionStackEntry                                           (new IfThenElseExpression(a[0]' thenEntry.Expression' elseEntry.Expression)'                                            e.Lub(thenEntry.Effects.Lub(elseEntry.Effects))));                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      var noStackChange = itei.Then.NoStackChange && (itei.Else == null || itei.Else.NoStackChange);                      var condEntry = noStackChange                                          ? stack.Pop()                                          : stack.FlushAndPopPostState(statements' itei.Then.BeforeState);                      if (condEntry == null)                          return false;                      var thenStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Then' exid)                                           : BlockToStatements(itei.Then' exid);                      if (thenStmnts == null)                          return false;                      var elseStmnts = default(Seq<Statement>);                      if (itei.Else != null)                      {                          elseStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Else' exid)                                           : BlockToStatements(itei.Else' exid);                          if (elseStmnts == null)                              return false;                      }                      if (statements == null)                          return Failed(false' "if-then-else");                      statements.Add                          (new IfThenElseStatement(condEntry.Expression' new Statements(thenStmnts)' elseStmnts == null ? null : new Statements(elseStmnts)));                      if (!noStackChange && !stack.Restore(itei.AfterState' 0))                          return false;                      if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                          instructionTranslationStyleCache.Add(itei.Offset' false);                      return true;                  }              case InstructionFlavor.ShortCircuitingPseudo:                  {                      var sci = (ShortCircuitingInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(sci.Offset' out isExpr) ||                                              isExpr;                      if (couldBeExpression)                      {                          // Pass 1: Try to translate to an expression.                          var leftEntry = BlockToExpression(sci.Left' exid);                          if (leftEntry != null)                          {                              var rightEntry = BlockToExpression(sci.Right' exid);                              if (rightEntry != null)                              {                                  stack.Push                                      (new ExpressionStackEntry                                           (new BinaryExpression                                                (leftEntry.Expression'                                                 ShortCircuitingOpToBinaryOp(sci.Op)'                                                 rightEntry.Expression'                                                 false'                                                 false)'                                            leftEntry.Effects.Lub(rightEntry.Effects)));                                  if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                                      instructionTranslationStyleCache.Add(sci.Offset' true);                                  return true;                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      if (!TranslateBlock(statements' sci.Left' stack' exid))                          return false;                      var leftEntry2 = stack.FlushAndPopPostState(statements' sci.Right.BeforeState);                      if (leftEntry2 == null)                          return false;                      var rightStatements = BlockToStatements(sci.Right' exid);                      if (rightStatements == null)                          return false;                      var id = sci.Right.AfterState.PeekId(0' nameSupply.GenSym);                      var cell = new VariableCell(id);                      compEnv.AddVariable(id' ArgLocal.Local' false' true' compEnv.SubstituteType(sci.Right.AfterState.PeekType(0)));                      if (statements == null)                          return Failed(false' "short-circuit");                      switch (sci.Op)                      {                      case ShortCircuitingOp.And:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements(rightStatements)'                                    new Statements                                        (new ExpressionStatement(cell.Write(new Int32ConstantExpression(0))))));                          break;                      case ShortCircuitingOp.Or:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements                                        (new ExpressionStatement                                             (cell.Write(new Int32ConstantExpression(1))))'                                    new Statements(rightStatements)));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      if (!stack.Restore(sci.AfterState' 1))                          return false;                      stack.Push(new ExpressionStackEntry(cell.Read()' BottomE));                      if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                          instructionTranslationStyleCache.Add(sci.Offset' false);                      return true;                  }              case InstructionFlavor.StructuralSwitchPseudo:                  {                      var ssi = (StructuralSwitchInstruction)instruction;                      if (!TranslateBlock(statements' ssi.Body' stack' exid))                          return false;                      var valueEntry = stack.FlushAndPopPreState(statements' ssi.Body.AfterState);                      if (valueEntry == null)                          return false;                      var cases = new Seq<SwitchStatementCase>();                      foreach (var c in ssi.Cases)                      {                          var caseStatements = BlockToStatements(c.Body' exid);                          if (caseStatements == null)                              return false;                          cases.Add(new SwitchStatementCase(c.Values' new Statements(caseStatements)));                      }                      if (statements == null)                          return Failed(false' "structural switch");                      statements.Add(new SwitchStatement(valueEntry.Expression' cases));                      if (!stack.Restore(ssi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopPseudo:                  {                      var li = (LoopInstruction)instruction;                      if (!stack.Flush(statements' li.Body.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop");                      var whileStatements = BlockToStatements(li.Body' exid);                      statements.Add                          (new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(whileStatements)));                      if (!stack.Restore(li.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.WhileDoPseudo:                  {                      var wdi = (WhileDoInstruction)instruction;                      if (!stack.Flush(statements' wdi.Condition.BeforeState))                          return false;                      var condEntry = BlockToExpression(wdi.Condition' exid);                      if (condEntry == null)                      {                          var stack1 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Condition.BeforeState' trace);                          var preCondStatements = new Seq<Statement>();                          if (!TranslateBlock(preCondStatements' wdi.Condition' stack1' exid))                              return false;                          condEntry = stack1.FlushAndPopPostState(preCondStatements' wdi.Body.BeforeState);                          if (condEntry == null)                              return false;                          var stack2 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Body.BeforeState' trace);                          var postCondStatements = new Seq<Statement>();                          if (!TranslateBlock(postCondStatements' wdi.Body' stack2' exid))                              return false;                          if (!stack2.Flush(postCondStatements' wdi.Body.AfterState))                              return false;                          preCondStatements.Add                              (new IfThenElseStatement                                   (condEntry.Expression'                                    new Statements(postCondStatements)'                                    new Statements(new BreakStatement())));                          statements.Add(new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(preCondStatements)));                      }                      else                      {                          var loopStatements = BlockToStatements(wdi.Body' exid);                          if (loopStatements == null)                              return false;                          if (statements == null)                              return Failed(false' "while-do");                          statements.Add(new WhileDoStatement(condEntry.Expression' new Statements(loopStatements)));                      }                      if (!stack.Restore(wdi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.DoWhilePseudo:                  {                      var dwi = (DoWhileInstruction)instruction;                      if (!stack.Flush(statements' dwi.Body.BeforeState))                          return false;                      var combined = new Seq<Instruction>();                      foreach (var i in dwi.Body.Body)                          combined.Add(i);                      foreach (var i in dwi.Condition.Body)                          combined.Add(i);                      var condEntry = default(ExpressionStackEntry);                      var loopStatements = BlockToConditionStatements                          (new Instructions(null' combined)' dwi.Body.BeforeState' exid' out condEntry);                      if (loopStatements == null)                          return false;                      if (statements == null)                          return Failed(false' "do-while");                      statements.Add(new DoWhileStatement(new Statements(loopStatements)' condEntry.Expression));                      if (!stack.Restore(dwi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopControlPseudo:                  {                      var lci = (BreakContinueInstruction)instruction;                      if (!stack.Flush(statements' lci.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop-control");                      var targetState = default(int);                      switch (lci.Op)                      {                      case BreakContinueOp.Break:                          if (labelToLoopCandidateBreakState != null &&                              labelToLoopCandidateBreakState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new BreakStatement(lci.Label));                          break;                      case BreakContinueOp.Continue:                          if (labelToLoopCandidateContinueState != null &&                              labelToLoopCandidateContinueState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new ContinueStatement(lci.Label));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      return true;                  }              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return true;                      case MiscOp.Dup:                          return stack.Dup(statements);                      case MiscOp.Pop:                          return stack.PopAndDiscard(statements);                      case MiscOp.Ldnull:                          stack.Push(new ExpressionStackEntry(new NullConstantExpression()' BottomE));                          return true;                      case MiscOp.Ckfinite:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.CheckFinite' false' false)' e.Lub(ThrowsE)));                      case MiscOp.Throw:                          if (!stack.DiscardAll(statements' 1))                              return false;                          if (!stack.PopEvalSE(statements' 1' true' ThrowsE' (s' a) => s.Add(new ThrowStatement(a[0]))))                              return false;                          return true;                      case MiscOp.Rethrow:                          if (!stack.DiscardAll(statements' 0))                              return false;                          if (statements == null)                              return Failed(false' "rethrow");                          if (exid == null)                              throw new InvalidOperationException("rethrow outside of catch");                          statements.Add(new RethrowStatement(new VariableCell(exid).Read()));                          return true;                      case MiscOp.LdindRef:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case MiscOp.LdelemRef:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.Ldlen:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.Length' false' false)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.StindRef:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case MiscOp.StelemRef:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add                                   (new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      case MiscOp.Ret:                          if (statements == null)                              return Failed(false' "return");                          statements.Add(new ReturnStatement(null));                          return true;                      case MiscOp.RetVal:                          return stack.PopEvalSE                              (statements' 1' true' BottomE' (s' a) => s.Add(new ReturnStatement(a[0])));                      case MiscOp.Endfilter:                      case MiscOp.Endfinally:                          throw new InvalidOperationException                              ("endfilter/endfinally instructions should have been removed");                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:              case InstructionFlavor.Switch:                  throw new InvalidOperationException("branch/switch instructions should have been removed");              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      if (cmpi.Op == CompareOp.CtruePseudo || cmpi.Op == CompareOp.CfalsePseudo)                      {                          var s = cmpi.Type.Style(compEnv);                          var unop = default(UnaryOp);                          if (s is NumberTypeStyle)                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonZero : UnaryOp.IsZero;                          else                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonNull : UnaryOp.IsNull;                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new UnaryExpression(a[0]' unop' false' cmpi.IsUnsigned)' e));                      }                      else                      {                          var binop = default(BinaryOp);                          switch (cmpi.Op)                          {                          case CompareOp.Ceq:                              binop = BinaryOp.Eq;                              break;                          case CompareOp.Clt:                              binop = BinaryOp.Lt;                              break;                          case CompareOp.Cgt:                              binop = BinaryOp.Gt;                              break;                          case CompareOp.CgePseudo:                              binop = BinaryOp.Ge;                              break;                          case CompareOp.ClePseudo:                              binop = BinaryOp.Le;                              break;                          case CompareOp.CnePseudo:                              binop = BinaryOp.Ne;                              break;                          case CompareOp.CtruePseudo:                          case CompareOp.CfalsePseudo:                              // handled above                              throw new InvalidOperationException();                          default:                              throw new ArgumentOutOfRangeException();                          }                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression(a[0]' binop' a[1]' false' cmpi.IsUnsigned)' e));                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var sli = (ArgLocalInstruction)instruction;                      var id = default(JST.Identifier);                      switch (sli.ArgLocal)                      {                      case ArgLocal.Arg:                          id = compEnv.ValueParameterIds[sli.Index];                          break;                      case ArgLocal.Local:                          id = compEnv.LocalIds[sli.Index];                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      var cell = new VariableCell(id);                      switch (sli.Op)                      {                      case ArgLocalOp.Ld:                          stack.Push                              (new ExpressionStackEntry                                   (cell.Read().CloneIfStruct(compEnv)' ReadArgLocalE(sli.ArgLocal' sli.Index)));                          return true;                      case ArgLocalOp.Lda:                          // Effect will be accounted for on reads/writes                          stack.Push(new ExpressionStackEntry(cell.AddressOf()' BottomE));                          return true;                      case ArgLocalOp.St:                          return stack.PopEvalSE                              (statements'                               1'                               true'                               WriteArgLocalE(sli.ArgLocal' sli.Index)'                               (s' a) => s.Add(new ExpressionStatement(cell.Write(a[0]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                          {                              stack.Push                                  (new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' ReadHeapE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                       {                                           var readEffect = default(Effects);                                           var obj = default(Expression);                                           if (fieldi.IsViaPointer.Value)                                           {                                               readEffect = e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect());                                               obj = new ReadExpression(a[0]); // no need for clone                                           }                                           else if (fieldi.Field.DefiningType.Style(compEnv) is ValueTypeStyle)                                           {                                               readEffect = e;                                               obj = a[0];                                           }                                           else                                           {                                               // Object could be null                                               readEffect = e.Lub(ReadHeapOrThrowE);                                               obj = a[0];                                           }                                           return new ExpressionStackEntry(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' readEffect);                                       });                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                          {                              // Effect will be accounted for on reads/writes                              stack.Push(new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' BottomE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   {                                       if (fieldi.IsViaPointer.Value)                                           // We're just adding an offset to a pointer' so effect will                                           // be accounted for when the final pointer is read/written                                           return new ExpressionStackEntry(new FieldCell(new ReadExpression(a[0])' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e);                                       else                                           // Must be a reference type' and ref could be null                                           return new ExpressionStackEntry(new FieldCell(a[0]' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e.Lub(ThrowsE));                                   });                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                              return stack.PopEvalSE                                  (statements'                                   1'                                   true'                                   WriteHeapE'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Write(a[0]))));                          else                          {                              var writeEffect = fieldi.IsViaPointer.Value                                                    ? instruction.BeforeState.PeekPointsTo(1).WriteEffect()                                                    : WriteHeapOrThrowE;                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   writeEffect'                                   (s' a) =>                                       {                                           var obj = fieldi.IsViaPointer.Value ? new ReadExpression(a[0]) : a[0];                                           s.Add(new ExpressionStatement(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Write(a[1])));                                       });                          }                      case FieldOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new FieldHandleConstantExpression(compEnv.SubstituteMember(fieldi.Field))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methodi = (MethodInstruction)instruction;                      var arity = methodi.Method.ValueParameters.Count;                      switch (methodi.Op)                      {                      case MethodOp.Ldftn:                          if (methodi.IsVirtual)                              // Object could be null                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CodePointerExpression(a[0]' compEnv.SubstituteMember(methodi.Method))' e.Lub(ReadHeapOrThrowE)));                          else                          {                              stack.Push                                  (new ExpressionStackEntry(new CodePointerExpression(null' compEnv.SubstituteMember(methodi.Method))' BottomE));                              return true;                          }                      case MethodOp.Call:                          if (methodi.Method.Result == null)                              return stack.PopEvalSE                                  (statements'                                   arity'                                   true'                                   CalleeEffects(methodi.BeforeState' arity)'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new CallExpression                                                 (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal'                                                  compEnv.SubstituteMember(methodi.Method)'                                                  CallerArguments(methodi.Constrained' methodi.Method' a)))));                          else                              return stack.PopEvalPush                                  (statements'                                   arity'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CallExpression                                            (methodi.IsVirtual? CallFlavor.Virtual : CallFlavor.Normal'                                             compEnv.SubstituteMember(methodi.Method)'                                             CallerArguments(methodi.Constrained' methodi.Method' a))'                                        e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Newobj:                          arity--;                          return stack.PopEvalPush                              (statements'                               arity'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new NewObjectExpression(compEnv.SubstituteMember(methodi.Method)' CallerArguments(null' methodi.Method' a))'                                    e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Ldtoken:                          stack.Push                              (new ExpressionStackEntry(new MethodHandleConstantExpression(compEnv.SubstituteMember(methodi.Method))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case TypeOp.Stobj:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case TypeOp.Cpobj:                          {                              var copyEffect = instruction.BeforeState.PeekPointsTo(0).ReadEffect().Lub                                  (instruction.BeforeState.PeekPointsTo(1).WriteEffect());                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   copyEffect'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new WriteExpression(a[0]' new ReadExpression(a[1]).CloneIfStruct(compEnv)))));                          }                      case TypeOp.Newarr:                          // Growing the heap is not considered an observable change. But will throw if                          // length < 0                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new NewArrayExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Initobj:                          return stack.PopEvalSE                              (statements' 1' true' WriteHeapE' (s' a) => s.Add(new InitializeObjectStatement(a[0])));                      case TypeOp.Castclass:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new CastExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Isinst:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new IsInstExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Box:                          // Growing the heap is not considered an observable change                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new NewBoxExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Unbox:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).AddressOf()' e.Lub(ThrowsE)));                      case TypeOp.UnboxAny:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).Read().CloneIfStruct(compEnv)' e.Lub(ThrowsE)));                      case TypeOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new TypeHandleConstantExpression(compEnv.SubstituteType(typei.Type))' BottomE));                          return true;                      case TypeOp.Ldelem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case TypeOp.Stelem:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add(new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  // Calculating the pointer may throw if index is out of range.                  // Remaining effect will be accounted for when pointer is read/written.                  return stack.PopEvalPush                      (statements'                       2'                       true'                       (a' e) =>                       new ExpressionStackEntry(new ElementCell(a[0]' a[1]' false).AddressOf()' e.Lub(ThrowsE)));              case InstructionFlavor.LdInt32:                  {                      var int32i = (LdInt32Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int32ConstantExpression(int32i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdInt64:                  {                      var int64i = (LdInt64Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int64ConstantExpression(int64i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdSingle:                  {                      var singlei = (LdSingleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new SingleConstantExpression(singlei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdDouble:                  {                      var doublei = (LdDoubleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new DoubleConstantExpression(doublei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdString:                  {                      var stringi = (LdStringInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new StringConstantExpression(stringi.Value)' BottomE));                      return true;                  }              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Div:                      case ArithOp.Rem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(ThrowsE)));                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                      case ArithOp.Shl:                      case ArithOp.Shr:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(arithi.WithOverflow ? ThrowsE : BottomE)));                      case ArithOp.Neg:                      case ArithOp.BitNot:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression                                        (a[0]' ArithOpToUnaryOp(arithi.Op)' arithi.WithOverflow' arithi.IsUnsigned)'                                    e));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      return stack.PopEvalPush                          (statements'                           1'                           true'                           (a' e) =>                           new ExpressionStackEntry                               (new ConvertExpression                                    (a[0]'                                     new NamedTypeRef                                         (compEnv.Global.NumberFlavorToQualifiedTypeName[convi.TargetNumberFlavor])'                                     convi.WithOverflow'                                     convi.IsSourceUnsigned)'                                e.Lub(convi.WithOverflow ? ThrowsE : BottomE)));                  }              case InstructionFlavor.Try:                  {                      if (stack.Depth > 0)                          throw new InvalidOperationException("stack must be empty on entry to try block");                      var tryi = (TryInstruction)instruction;                      var tryStatements = BlockToTryFaultFinallyStatements(tryi.Body);                      if (tryStatements == null)                          return false;                      var handlers = TranslateHandlers(tryi.Handlers);                      if (handlers == null)                          return false;                      if (statements == null)                          return Failed(false' "try");                      statements.Add(new TryStatement(tryStatements' handlers));                      return true;                  }              case InstructionFlavor.IfThenElsePseudo:                  {                      var itei = (IfThenElseInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(itei.Offset' out isExpr) ||                                              isExpr;                        if (!TranslateBlock(statements' itei.Condition' stack' exid))                          return false;                      if (couldBeExpression && itei.Else != null)                      {                          // Pass 1: Try to tranlate to an if-then-else expression. Will only work if Then and Else don't                          //         reach into current stack' push exactly one value' and don't need to emit any                          //         statements along the way.                          var thenEntry = BlockToExpression(itei.Then' exid);                          if (thenEntry != null)                          {                              var elseEntry = BlockToExpression(itei.Else' exid);                              if (elseEntry != null)                              {                                  if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                                      instructionTranslationStyleCache.Add(itei.Offset' true);                                  return stack.PopEvalPush                                      (statements'                                       1'                                       true'                                       (a' e) =>                                       new ExpressionStackEntry                                           (new IfThenElseExpression(a[0]' thenEntry.Expression' elseEntry.Expression)'                                            e.Lub(thenEntry.Effects.Lub(elseEntry.Effects))));                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      var noStackChange = itei.Then.NoStackChange && (itei.Else == null || itei.Else.NoStackChange);                      var condEntry = noStackChange                                          ? stack.Pop()                                          : stack.FlushAndPopPostState(statements' itei.Then.BeforeState);                      if (condEntry == null)                          return false;                      var thenStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Then' exid)                                           : BlockToStatements(itei.Then' exid);                      if (thenStmnts == null)                          return false;                      var elseStmnts = default(Seq<Statement>);                      if (itei.Else != null)                      {                          elseStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Else' exid)                                           : BlockToStatements(itei.Else' exid);                          if (elseStmnts == null)                              return false;                      }                      if (statements == null)                          return Failed(false' "if-then-else");                      statements.Add                          (new IfThenElseStatement(condEntry.Expression' new Statements(thenStmnts)' elseStmnts == null ? null : new Statements(elseStmnts)));                      if (!noStackChange && !stack.Restore(itei.AfterState' 0))                          return false;                      if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                          instructionTranslationStyleCache.Add(itei.Offset' false);                      return true;                  }              case InstructionFlavor.ShortCircuitingPseudo:                  {                      var sci = (ShortCircuitingInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(sci.Offset' out isExpr) ||                                              isExpr;                      if (couldBeExpression)                      {                          // Pass 1: Try to translate to an expression.                          var leftEntry = BlockToExpression(sci.Left' exid);                          if (leftEntry != null)                          {                              var rightEntry = BlockToExpression(sci.Right' exid);                              if (rightEntry != null)                              {                                  stack.Push                                      (new ExpressionStackEntry                                           (new BinaryExpression                                                (leftEntry.Expression'                                                 ShortCircuitingOpToBinaryOp(sci.Op)'                                                 rightEntry.Expression'                                                 false'                                                 false)'                                            leftEntry.Effects.Lub(rightEntry.Effects)));                                  if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                                      instructionTranslationStyleCache.Add(sci.Offset' true);                                  return true;                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      if (!TranslateBlock(statements' sci.Left' stack' exid))                          return false;                      var leftEntry2 = stack.FlushAndPopPostState(statements' sci.Right.BeforeState);                      if (leftEntry2 == null)                          return false;                      var rightStatements = BlockToStatements(sci.Right' exid);                      if (rightStatements == null)                          return false;                      var id = sci.Right.AfterState.PeekId(0' nameSupply.GenSym);                      var cell = new VariableCell(id);                      compEnv.AddVariable(id' ArgLocal.Local' false' true' compEnv.SubstituteType(sci.Right.AfterState.PeekType(0)));                      if (statements == null)                          return Failed(false' "short-circuit");                      switch (sci.Op)                      {                      case ShortCircuitingOp.And:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements(rightStatements)'                                    new Statements                                        (new ExpressionStatement(cell.Write(new Int32ConstantExpression(0))))));                          break;                      case ShortCircuitingOp.Or:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements                                        (new ExpressionStatement                                             (cell.Write(new Int32ConstantExpression(1))))'                                    new Statements(rightStatements)));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      if (!stack.Restore(sci.AfterState' 1))                          return false;                      stack.Push(new ExpressionStackEntry(cell.Read()' BottomE));                      if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                          instructionTranslationStyleCache.Add(sci.Offset' false);                      return true;                  }              case InstructionFlavor.StructuralSwitchPseudo:                  {                      var ssi = (StructuralSwitchInstruction)instruction;                      if (!TranslateBlock(statements' ssi.Body' stack' exid))                          return false;                      var valueEntry = stack.FlushAndPopPreState(statements' ssi.Body.AfterState);                      if (valueEntry == null)                          return false;                      var cases = new Seq<SwitchStatementCase>();                      foreach (var c in ssi.Cases)                      {                          var caseStatements = BlockToStatements(c.Body' exid);                          if (caseStatements == null)                              return false;                          cases.Add(new SwitchStatementCase(c.Values' new Statements(caseStatements)));                      }                      if (statements == null)                          return Failed(false' "structural switch");                      statements.Add(new SwitchStatement(valueEntry.Expression' cases));                      if (!stack.Restore(ssi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopPseudo:                  {                      var li = (LoopInstruction)instruction;                      if (!stack.Flush(statements' li.Body.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop");                      var whileStatements = BlockToStatements(li.Body' exid);                      statements.Add                          (new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(whileStatements)));                      if (!stack.Restore(li.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.WhileDoPseudo:                  {                      var wdi = (WhileDoInstruction)instruction;                      if (!stack.Flush(statements' wdi.Condition.BeforeState))                          return false;                      var condEntry = BlockToExpression(wdi.Condition' exid);                      if (condEntry == null)                      {                          var stack1 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Condition.BeforeState' trace);                          var preCondStatements = new Seq<Statement>();                          if (!TranslateBlock(preCondStatements' wdi.Condition' stack1' exid))                              return false;                          condEntry = stack1.FlushAndPopPostState(preCondStatements' wdi.Body.BeforeState);                          if (condEntry == null)                              return false;                          var stack2 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Body.BeforeState' trace);                          var postCondStatements = new Seq<Statement>();                          if (!TranslateBlock(postCondStatements' wdi.Body' stack2' exid))                              return false;                          if (!stack2.Flush(postCondStatements' wdi.Body.AfterState))                              return false;                          preCondStatements.Add                              (new IfThenElseStatement                                   (condEntry.Expression'                                    new Statements(postCondStatements)'                                    new Statements(new BreakStatement())));                          statements.Add(new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(preCondStatements)));                      }                      else                      {                          var loopStatements = BlockToStatements(wdi.Body' exid);                          if (loopStatements == null)                              return false;                          if (statements == null)                              return Failed(false' "while-do");                          statements.Add(new WhileDoStatement(condEntry.Expression' new Statements(loopStatements)));                      }                      if (!stack.Restore(wdi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.DoWhilePseudo:                  {                      var dwi = (DoWhileInstruction)instruction;                      if (!stack.Flush(statements' dwi.Body.BeforeState))                          return false;                      var combined = new Seq<Instruction>();                      foreach (var i in dwi.Body.Body)                          combined.Add(i);                      foreach (var i in dwi.Condition.Body)                          combined.Add(i);                      var condEntry = default(ExpressionStackEntry);                      var loopStatements = BlockToConditionStatements                          (new Instructions(null' combined)' dwi.Body.BeforeState' exid' out condEntry);                      if (loopStatements == null)                          return false;                      if (statements == null)                          return Failed(false' "do-while");                      statements.Add(new DoWhileStatement(new Statements(loopStatements)' condEntry.Expression));                      if (!stack.Restore(dwi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopControlPseudo:                  {                      var lci = (BreakContinueInstruction)instruction;                      if (!stack.Flush(statements' lci.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop-control");                      var targetState = default(int);                      switch (lci.Op)                      {                      case BreakContinueOp.Break:                          if (labelToLoopCandidateBreakState != null &&                              labelToLoopCandidateBreakState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new BreakStatement(lci.Label));                          break;                      case BreakContinueOp.Continue:                          if (labelToLoopCandidateContinueState != null &&                              labelToLoopCandidateContinueState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new ContinueStatement(lci.Label));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      return true;                  }              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return true;                      case MiscOp.Dup:                          return stack.Dup(statements);                      case MiscOp.Pop:                          return stack.PopAndDiscard(statements);                      case MiscOp.Ldnull:                          stack.Push(new ExpressionStackEntry(new NullConstantExpression()' BottomE));                          return true;                      case MiscOp.Ckfinite:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.CheckFinite' false' false)' e.Lub(ThrowsE)));                      case MiscOp.Throw:                          if (!stack.DiscardAll(statements' 1))                              return false;                          if (!stack.PopEvalSE(statements' 1' true' ThrowsE' (s' a) => s.Add(new ThrowStatement(a[0]))))                              return false;                          return true;                      case MiscOp.Rethrow:                          if (!stack.DiscardAll(statements' 0))                              return false;                          if (statements == null)                              return Failed(false' "rethrow");                          if (exid == null)                              throw new InvalidOperationException("rethrow outside of catch");                          statements.Add(new RethrowStatement(new VariableCell(exid).Read()));                          return true;                      case MiscOp.LdindRef:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case MiscOp.LdelemRef:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.Ldlen:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.Length' false' false)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.StindRef:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case MiscOp.StelemRef:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add                                   (new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      case MiscOp.Ret:                          if (statements == null)                              return Failed(false' "return");                          statements.Add(new ReturnStatement(null));                          return true;                      case MiscOp.RetVal:                          return stack.PopEvalSE                              (statements' 1' true' BottomE' (s' a) => s.Add(new ReturnStatement(a[0])));                      case MiscOp.Endfilter:                      case MiscOp.Endfinally:                          throw new InvalidOperationException                              ("endfilter/endfinally instructions should have been removed");                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:              case InstructionFlavor.Switch:                  throw new InvalidOperationException("branch/switch instructions should have been removed");              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      if (cmpi.Op == CompareOp.CtruePseudo || cmpi.Op == CompareOp.CfalsePseudo)                      {                          var s = cmpi.Type.Style(compEnv);                          var unop = default(UnaryOp);                          if (s is NumberTypeStyle)                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonZero : UnaryOp.IsZero;                          else                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonNull : UnaryOp.IsNull;                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new UnaryExpression(a[0]' unop' false' cmpi.IsUnsigned)' e));                      }                      else                      {                          var binop = default(BinaryOp);                          switch (cmpi.Op)                          {                          case CompareOp.Ceq:                              binop = BinaryOp.Eq;                              break;                          case CompareOp.Clt:                              binop = BinaryOp.Lt;                              break;                          case CompareOp.Cgt:                              binop = BinaryOp.Gt;                              break;                          case CompareOp.CgePseudo:                              binop = BinaryOp.Ge;                              break;                          case CompareOp.ClePseudo:                              binop = BinaryOp.Le;                              break;                          case CompareOp.CnePseudo:                              binop = BinaryOp.Ne;                              break;                          case CompareOp.CtruePseudo:                          case CompareOp.CfalsePseudo:                              // handled above                              throw new InvalidOperationException();                          default:                              throw new ArgumentOutOfRangeException();                          }                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression(a[0]' binop' a[1]' false' cmpi.IsUnsigned)' e));                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var sli = (ArgLocalInstruction)instruction;                      var id = default(JST.Identifier);                      switch (sli.ArgLocal)                      {                      case ArgLocal.Arg:                          id = compEnv.ValueParameterIds[sli.Index];                          break;                      case ArgLocal.Local:                          id = compEnv.LocalIds[sli.Index];                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      var cell = new VariableCell(id);                      switch (sli.Op)                      {                      case ArgLocalOp.Ld:                          stack.Push                              (new ExpressionStackEntry                                   (cell.Read().CloneIfStruct(compEnv)' ReadArgLocalE(sli.ArgLocal' sli.Index)));                          return true;                      case ArgLocalOp.Lda:                          // Effect will be accounted for on reads/writes                          stack.Push(new ExpressionStackEntry(cell.AddressOf()' BottomE));                          return true;                      case ArgLocalOp.St:                          return stack.PopEvalSE                              (statements'                               1'                               true'                               WriteArgLocalE(sli.ArgLocal' sli.Index)'                               (s' a) => s.Add(new ExpressionStatement(cell.Write(a[0]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                          {                              stack.Push                                  (new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' ReadHeapE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                       {                                           var readEffect = default(Effects);                                           var obj = default(Expression);                                           if (fieldi.IsViaPointer.Value)                                           {                                               readEffect = e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect());                                               obj = new ReadExpression(a[0]); // no need for clone                                           }                                           else if (fieldi.Field.DefiningType.Style(compEnv) is ValueTypeStyle)                                           {                                               readEffect = e;                                               obj = a[0];                                           }                                           else                                           {                                               // Object could be null                                               readEffect = e.Lub(ReadHeapOrThrowE);                                               obj = a[0];                                           }                                           return new ExpressionStackEntry(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' readEffect);                                       });                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                          {                              // Effect will be accounted for on reads/writes                              stack.Push(new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' BottomE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   {                                       if (fieldi.IsViaPointer.Value)                                           // We're just adding an offset to a pointer' so effect will                                           // be accounted for when the final pointer is read/written                                           return new ExpressionStackEntry(new FieldCell(new ReadExpression(a[0])' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e);                                       else                                           // Must be a reference type' and ref could be null                                           return new ExpressionStackEntry(new FieldCell(a[0]' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e.Lub(ThrowsE));                                   });                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                              return stack.PopEvalSE                                  (statements'                                   1'                                   true'                                   WriteHeapE'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Write(a[0]))));                          else                          {                              var writeEffect = fieldi.IsViaPointer.Value                                                    ? instruction.BeforeState.PeekPointsTo(1).WriteEffect()                                                    : WriteHeapOrThrowE;                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   writeEffect'                                   (s' a) =>                                       {                                           var obj = fieldi.IsViaPointer.Value ? new ReadExpression(a[0]) : a[0];                                           s.Add(new ExpressionStatement(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Write(a[1])));                                       });                          }                      case FieldOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new FieldHandleConstantExpression(compEnv.SubstituteMember(fieldi.Field))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methodi = (MethodInstruction)instruction;                      var arity = methodi.Method.ValueParameters.Count;                      switch (methodi.Op)                      {                      case MethodOp.Ldftn:                          if (methodi.IsVirtual)                              // Object could be null                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CodePointerExpression(a[0]' compEnv.SubstituteMember(methodi.Method))' e.Lub(ReadHeapOrThrowE)));                          else                          {                              stack.Push                                  (new ExpressionStackEntry(new CodePointerExpression(null' compEnv.SubstituteMember(methodi.Method))' BottomE));                              return true;                          }                      case MethodOp.Call:                          if (methodi.Method.Result == null)                              return stack.PopEvalSE                                  (statements'                                   arity'                                   true'                                   CalleeEffects(methodi.BeforeState' arity)'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new CallExpression                                                 (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal'                                                  compEnv.SubstituteMember(methodi.Method)'                                                  CallerArguments(methodi.Constrained' methodi.Method' a)))));                          else                              return stack.PopEvalPush                                  (statements'                                   arity'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CallExpression                                            (methodi.IsVirtual? CallFlavor.Virtual : CallFlavor.Normal'                                             compEnv.SubstituteMember(methodi.Method)'                                             CallerArguments(methodi.Constrained' methodi.Method' a))'                                        e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Newobj:                          arity--;                          return stack.PopEvalPush                              (statements'                               arity'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new NewObjectExpression(compEnv.SubstituteMember(methodi.Method)' CallerArguments(null' methodi.Method' a))'                                    e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Ldtoken:                          stack.Push                              (new ExpressionStackEntry(new MethodHandleConstantExpression(compEnv.SubstituteMember(methodi.Method))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case TypeOp.Stobj:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case TypeOp.Cpobj:                          {                              var copyEffect = instruction.BeforeState.PeekPointsTo(0).ReadEffect().Lub                                  (instruction.BeforeState.PeekPointsTo(1).WriteEffect());                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   copyEffect'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new WriteExpression(a[0]' new ReadExpression(a[1]).CloneIfStruct(compEnv)))));                          }                      case TypeOp.Newarr:                          // Growing the heap is not considered an observable change. But will throw if                          // length < 0                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new NewArrayExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Initobj:                          return stack.PopEvalSE                              (statements' 1' true' WriteHeapE' (s' a) => s.Add(new InitializeObjectStatement(a[0])));                      case TypeOp.Castclass:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new CastExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Isinst:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new IsInstExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Box:                          // Growing the heap is not considered an observable change                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new NewBoxExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Unbox:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).AddressOf()' e.Lub(ThrowsE)));                      case TypeOp.UnboxAny:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).Read().CloneIfStruct(compEnv)' e.Lub(ThrowsE)));                      case TypeOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new TypeHandleConstantExpression(compEnv.SubstituteType(typei.Type))' BottomE));                          return true;                      case TypeOp.Ldelem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case TypeOp.Stelem:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add(new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  // Calculating the pointer may throw if index is out of range.                  // Remaining effect will be accounted for when pointer is read/written.                  return stack.PopEvalPush                      (statements'                       2'                       true'                       (a' e) =>                       new ExpressionStackEntry(new ElementCell(a[0]' a[1]' false).AddressOf()' e.Lub(ThrowsE)));              case InstructionFlavor.LdInt32:                  {                      var int32i = (LdInt32Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int32ConstantExpression(int32i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdInt64:                  {                      var int64i = (LdInt64Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int64ConstantExpression(int64i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdSingle:                  {                      var singlei = (LdSingleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new SingleConstantExpression(singlei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdDouble:                  {                      var doublei = (LdDoubleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new DoubleConstantExpression(doublei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdString:                  {                      var stringi = (LdStringInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new StringConstantExpression(stringi.Value)' BottomE));                      return true;                  }              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Div:                      case ArithOp.Rem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(ThrowsE)));                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                      case ArithOp.Shl:                      case ArithOp.Shr:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(arithi.WithOverflow ? ThrowsE : BottomE)));                      case ArithOp.Neg:                      case ArithOp.BitNot:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression                                        (a[0]' ArithOpToUnaryOp(arithi.Op)' arithi.WithOverflow' arithi.IsUnsigned)'                                    e));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      return stack.PopEvalPush                          (statements'                           1'                           true'                           (a' e) =>                           new ExpressionStackEntry                               (new ConvertExpression                                    (a[0]'                                     new NamedTypeRef                                         (compEnv.Global.NumberFlavorToQualifiedTypeName[convi.TargetNumberFlavor])'                                     convi.WithOverflow'                                     convi.IsSourceUnsigned)'                                e.Lub(convi.WithOverflow ? ThrowsE : BottomE)));                  }              case InstructionFlavor.Try:                  {                      if (stack.Depth > 0)                          throw new InvalidOperationException("stack must be empty on entry to try block");                      var tryi = (TryInstruction)instruction;                      var tryStatements = BlockToTryFaultFinallyStatements(tryi.Body);                      if (tryStatements == null)                          return false;                      var handlers = TranslateHandlers(tryi.Handlers);                      if (handlers == null)                          return false;                      if (statements == null)                          return Failed(false' "try");                      statements.Add(new TryStatement(tryStatements' handlers));                      return true;                  }              case InstructionFlavor.IfThenElsePseudo:                  {                      var itei = (IfThenElseInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(itei.Offset' out isExpr) ||                                              isExpr;                        if (!TranslateBlock(statements' itei.Condition' stack' exid))                          return false;                      if (couldBeExpression && itei.Else != null)                      {                          // Pass 1: Try to tranlate to an if-then-else expression. Will only work if Then and Else don't                          //         reach into current stack' push exactly one value' and don't need to emit any                          //         statements along the way.                          var thenEntry = BlockToExpression(itei.Then' exid);                          if (thenEntry != null)                          {                              var elseEntry = BlockToExpression(itei.Else' exid);                              if (elseEntry != null)                              {                                  if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                                      instructionTranslationStyleCache.Add(itei.Offset' true);                                  return stack.PopEvalPush                                      (statements'                                       1'                                       true'                                       (a' e) =>                                       new ExpressionStackEntry                                           (new IfThenElseExpression(a[0]' thenEntry.Expression' elseEntry.Expression)'                                            e.Lub(thenEntry.Effects.Lub(elseEntry.Effects))));                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      var noStackChange = itei.Then.NoStackChange && (itei.Else == null || itei.Else.NoStackChange);                      var condEntry = noStackChange                                          ? stack.Pop()                                          : stack.FlushAndPopPostState(statements' itei.Then.BeforeState);                      if (condEntry == null)                          return false;                      var thenStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Then' exid)                                           : BlockToStatements(itei.Then' exid);                      if (thenStmnts == null)                          return false;                      var elseStmnts = default(Seq<Statement>);                      if (itei.Else != null)                      {                          elseStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Else' exid)                                           : BlockToStatements(itei.Else' exid);                          if (elseStmnts == null)                              return false;                      }                      if (statements == null)                          return Failed(false' "if-then-else");                      statements.Add                          (new IfThenElseStatement(condEntry.Expression' new Statements(thenStmnts)' elseStmnts == null ? null : new Statements(elseStmnts)));                      if (!noStackChange && !stack.Restore(itei.AfterState' 0))                          return false;                      if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                          instructionTranslationStyleCache.Add(itei.Offset' false);                      return true;                  }              case InstructionFlavor.ShortCircuitingPseudo:                  {                      var sci = (ShortCircuitingInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(sci.Offset' out isExpr) ||                                              isExpr;                      if (couldBeExpression)                      {                          // Pass 1: Try to translate to an expression.                          var leftEntry = BlockToExpression(sci.Left' exid);                          if (leftEntry != null)                          {                              var rightEntry = BlockToExpression(sci.Right' exid);                              if (rightEntry != null)                              {                                  stack.Push                                      (new ExpressionStackEntry                                           (new BinaryExpression                                                (leftEntry.Expression'                                                 ShortCircuitingOpToBinaryOp(sci.Op)'                                                 rightEntry.Expression'                                                 false'                                                 false)'                                            leftEntry.Effects.Lub(rightEntry.Effects)));                                  if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                                      instructionTranslationStyleCache.Add(sci.Offset' true);                                  return true;                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      if (!TranslateBlock(statements' sci.Left' stack' exid))                          return false;                      var leftEntry2 = stack.FlushAndPopPostState(statements' sci.Right.BeforeState);                      if (leftEntry2 == null)                          return false;                      var rightStatements = BlockToStatements(sci.Right' exid);                      if (rightStatements == null)                          return false;                      var id = sci.Right.AfterState.PeekId(0' nameSupply.GenSym);                      var cell = new VariableCell(id);                      compEnv.AddVariable(id' ArgLocal.Local' false' true' compEnv.SubstituteType(sci.Right.AfterState.PeekType(0)));                      if (statements == null)                          return Failed(false' "short-circuit");                      switch (sci.Op)                      {                      case ShortCircuitingOp.And:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements(rightStatements)'                                    new Statements                                        (new ExpressionStatement(cell.Write(new Int32ConstantExpression(0))))));                          break;                      case ShortCircuitingOp.Or:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements                                        (new ExpressionStatement                                             (cell.Write(new Int32ConstantExpression(1))))'                                    new Statements(rightStatements)));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      if (!stack.Restore(sci.AfterState' 1))                          return false;                      stack.Push(new ExpressionStackEntry(cell.Read()' BottomE));                      if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                          instructionTranslationStyleCache.Add(sci.Offset' false);                      return true;                  }              case InstructionFlavor.StructuralSwitchPseudo:                  {                      var ssi = (StructuralSwitchInstruction)instruction;                      if (!TranslateBlock(statements' ssi.Body' stack' exid))                          return false;                      var valueEntry = stack.FlushAndPopPreState(statements' ssi.Body.AfterState);                      if (valueEntry == null)                          return false;                      var cases = new Seq<SwitchStatementCase>();                      foreach (var c in ssi.Cases)                      {                          var caseStatements = BlockToStatements(c.Body' exid);                          if (caseStatements == null)                              return false;                          cases.Add(new SwitchStatementCase(c.Values' new Statements(caseStatements)));                      }                      if (statements == null)                          return Failed(false' "structural switch");                      statements.Add(new SwitchStatement(valueEntry.Expression' cases));                      if (!stack.Restore(ssi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopPseudo:                  {                      var li = (LoopInstruction)instruction;                      if (!stack.Flush(statements' li.Body.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop");                      var whileStatements = BlockToStatements(li.Body' exid);                      statements.Add                          (new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(whileStatements)));                      if (!stack.Restore(li.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.WhileDoPseudo:                  {                      var wdi = (WhileDoInstruction)instruction;                      if (!stack.Flush(statements' wdi.Condition.BeforeState))                          return false;                      var condEntry = BlockToExpression(wdi.Condition' exid);                      if (condEntry == null)                      {                          var stack1 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Condition.BeforeState' trace);                          var preCondStatements = new Seq<Statement>();                          if (!TranslateBlock(preCondStatements' wdi.Condition' stack1' exid))                              return false;                          condEntry = stack1.FlushAndPopPostState(preCondStatements' wdi.Body.BeforeState);                          if (condEntry == null)                              return false;                          var stack2 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Body.BeforeState' trace);                          var postCondStatements = new Seq<Statement>();                          if (!TranslateBlock(postCondStatements' wdi.Body' stack2' exid))                              return false;                          if (!stack2.Flush(postCondStatements' wdi.Body.AfterState))                              return false;                          preCondStatements.Add                              (new IfThenElseStatement                                   (condEntry.Expression'                                    new Statements(postCondStatements)'                                    new Statements(new BreakStatement())));                          statements.Add(new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(preCondStatements)));                      }                      else                      {                          var loopStatements = BlockToStatements(wdi.Body' exid);                          if (loopStatements == null)                              return false;                          if (statements == null)                              return Failed(false' "while-do");                          statements.Add(new WhileDoStatement(condEntry.Expression' new Statements(loopStatements)));                      }                      if (!stack.Restore(wdi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.DoWhilePseudo:                  {                      var dwi = (DoWhileInstruction)instruction;                      if (!stack.Flush(statements' dwi.Body.BeforeState))                          return false;                      var combined = new Seq<Instruction>();                      foreach (var i in dwi.Body.Body)                          combined.Add(i);                      foreach (var i in dwi.Condition.Body)                          combined.Add(i);                      var condEntry = default(ExpressionStackEntry);                      var loopStatements = BlockToConditionStatements                          (new Instructions(null' combined)' dwi.Body.BeforeState' exid' out condEntry);                      if (loopStatements == null)                          return false;                      if (statements == null)                          return Failed(false' "do-while");                      statements.Add(new DoWhileStatement(new Statements(loopStatements)' condEntry.Expression));                      if (!stack.Restore(dwi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopControlPseudo:                  {                      var lci = (BreakContinueInstruction)instruction;                      if (!stack.Flush(statements' lci.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop-control");                      var targetState = default(int);                      switch (lci.Op)                      {                      case BreakContinueOp.Break:                          if (labelToLoopCandidateBreakState != null &&                              labelToLoopCandidateBreakState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new BreakStatement(lci.Label));                          break;                      case BreakContinueOp.Continue:                          if (labelToLoopCandidateContinueState != null &&                              labelToLoopCandidateContinueState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new ContinueStatement(lci.Label));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      return true;                  }              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return true;                      case MiscOp.Dup:                          return stack.Dup(statements);                      case MiscOp.Pop:                          return stack.PopAndDiscard(statements);                      case MiscOp.Ldnull:                          stack.Push(new ExpressionStackEntry(new NullConstantExpression()' BottomE));                          return true;                      case MiscOp.Ckfinite:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.CheckFinite' false' false)' e.Lub(ThrowsE)));                      case MiscOp.Throw:                          if (!stack.DiscardAll(statements' 1))                              return false;                          if (!stack.PopEvalSE(statements' 1' true' ThrowsE' (s' a) => s.Add(new ThrowStatement(a[0]))))                              return false;                          return true;                      case MiscOp.Rethrow:                          if (!stack.DiscardAll(statements' 0))                              return false;                          if (statements == null)                              return Failed(false' "rethrow");                          if (exid == null)                              throw new InvalidOperationException("rethrow outside of catch");                          statements.Add(new RethrowStatement(new VariableCell(exid).Read()));                          return true;                      case MiscOp.LdindRef:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case MiscOp.LdelemRef:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.Ldlen:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.Length' false' false)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.StindRef:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case MiscOp.StelemRef:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add                                   (new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      case MiscOp.Ret:                          if (statements == null)                              return Failed(false' "return");                          statements.Add(new ReturnStatement(null));                          return true;                      case MiscOp.RetVal:                          return stack.PopEvalSE                              (statements' 1' true' BottomE' (s' a) => s.Add(new ReturnStatement(a[0])));                      case MiscOp.Endfilter:                      case MiscOp.Endfinally:                          throw new InvalidOperationException                              ("endfilter/endfinally instructions should have been removed");                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:              case InstructionFlavor.Switch:                  throw new InvalidOperationException("branch/switch instructions should have been removed");              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      if (cmpi.Op == CompareOp.CtruePseudo || cmpi.Op == CompareOp.CfalsePseudo)                      {                          var s = cmpi.Type.Style(compEnv);                          var unop = default(UnaryOp);                          if (s is NumberTypeStyle)                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonZero : UnaryOp.IsZero;                          else                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonNull : UnaryOp.IsNull;                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new UnaryExpression(a[0]' unop' false' cmpi.IsUnsigned)' e));                      }                      else                      {                          var binop = default(BinaryOp);                          switch (cmpi.Op)                          {                          case CompareOp.Ceq:                              binop = BinaryOp.Eq;                              break;                          case CompareOp.Clt:                              binop = BinaryOp.Lt;                              break;                          case CompareOp.Cgt:                              binop = BinaryOp.Gt;                              break;                          case CompareOp.CgePseudo:                              binop = BinaryOp.Ge;                              break;                          case CompareOp.ClePseudo:                              binop = BinaryOp.Le;                              break;                          case CompareOp.CnePseudo:                              binop = BinaryOp.Ne;                              break;                          case CompareOp.CtruePseudo:                          case CompareOp.CfalsePseudo:                              // handled above                              throw new InvalidOperationException();                          default:                              throw new ArgumentOutOfRangeException();                          }                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression(a[0]' binop' a[1]' false' cmpi.IsUnsigned)' e));                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var sli = (ArgLocalInstruction)instruction;                      var id = default(JST.Identifier);                      switch (sli.ArgLocal)                      {                      case ArgLocal.Arg:                          id = compEnv.ValueParameterIds[sli.Index];                          break;                      case ArgLocal.Local:                          id = compEnv.LocalIds[sli.Index];                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      var cell = new VariableCell(id);                      switch (sli.Op)                      {                      case ArgLocalOp.Ld:                          stack.Push                              (new ExpressionStackEntry                                   (cell.Read().CloneIfStruct(compEnv)' ReadArgLocalE(sli.ArgLocal' sli.Index)));                          return true;                      case ArgLocalOp.Lda:                          // Effect will be accounted for on reads/writes                          stack.Push(new ExpressionStackEntry(cell.AddressOf()' BottomE));                          return true;                      case ArgLocalOp.St:                          return stack.PopEvalSE                              (statements'                               1'                               true'                               WriteArgLocalE(sli.ArgLocal' sli.Index)'                               (s' a) => s.Add(new ExpressionStatement(cell.Write(a[0]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                          {                              stack.Push                                  (new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' ReadHeapE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                       {                                           var readEffect = default(Effects);                                           var obj = default(Expression);                                           if (fieldi.IsViaPointer.Value)                                           {                                               readEffect = e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect());                                               obj = new ReadExpression(a[0]); // no need for clone                                           }                                           else if (fieldi.Field.DefiningType.Style(compEnv) is ValueTypeStyle)                                           {                                               readEffect = e;                                               obj = a[0];                                           }                                           else                                           {                                               // Object could be null                                               readEffect = e.Lub(ReadHeapOrThrowE);                                               obj = a[0];                                           }                                           return new ExpressionStackEntry(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' readEffect);                                       });                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                          {                              // Effect will be accounted for on reads/writes                              stack.Push(new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' BottomE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   {                                       if (fieldi.IsViaPointer.Value)                                           // We're just adding an offset to a pointer' so effect will                                           // be accounted for when the final pointer is read/written                                           return new ExpressionStackEntry(new FieldCell(new ReadExpression(a[0])' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e);                                       else                                           // Must be a reference type' and ref could be null                                           return new ExpressionStackEntry(new FieldCell(a[0]' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e.Lub(ThrowsE));                                   });                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                              return stack.PopEvalSE                                  (statements'                                   1'                                   true'                                   WriteHeapE'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Write(a[0]))));                          else                          {                              var writeEffect = fieldi.IsViaPointer.Value                                                    ? instruction.BeforeState.PeekPointsTo(1).WriteEffect()                                                    : WriteHeapOrThrowE;                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   writeEffect'                                   (s' a) =>                                       {                                           var obj = fieldi.IsViaPointer.Value ? new ReadExpression(a[0]) : a[0];                                           s.Add(new ExpressionStatement(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Write(a[1])));                                       });                          }                      case FieldOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new FieldHandleConstantExpression(compEnv.SubstituteMember(fieldi.Field))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methodi = (MethodInstruction)instruction;                      var arity = methodi.Method.ValueParameters.Count;                      switch (methodi.Op)                      {                      case MethodOp.Ldftn:                          if (methodi.IsVirtual)                              // Object could be null                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CodePointerExpression(a[0]' compEnv.SubstituteMember(methodi.Method))' e.Lub(ReadHeapOrThrowE)));                          else                          {                              stack.Push                                  (new ExpressionStackEntry(new CodePointerExpression(null' compEnv.SubstituteMember(methodi.Method))' BottomE));                              return true;                          }                      case MethodOp.Call:                          if (methodi.Method.Result == null)                              return stack.PopEvalSE                                  (statements'                                   arity'                                   true'                                   CalleeEffects(methodi.BeforeState' arity)'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new CallExpression                                                 (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal'                                                  compEnv.SubstituteMember(methodi.Method)'                                                  CallerArguments(methodi.Constrained' methodi.Method' a)))));                          else                              return stack.PopEvalPush                                  (statements'                                   arity'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CallExpression                                            (methodi.IsVirtual? CallFlavor.Virtual : CallFlavor.Normal'                                             compEnv.SubstituteMember(methodi.Method)'                                             CallerArguments(methodi.Constrained' methodi.Method' a))'                                        e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Newobj:                          arity--;                          return stack.PopEvalPush                              (statements'                               arity'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new NewObjectExpression(compEnv.SubstituteMember(methodi.Method)' CallerArguments(null' methodi.Method' a))'                                    e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Ldtoken:                          stack.Push                              (new ExpressionStackEntry(new MethodHandleConstantExpression(compEnv.SubstituteMember(methodi.Method))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case TypeOp.Stobj:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case TypeOp.Cpobj:                          {                              var copyEffect = instruction.BeforeState.PeekPointsTo(0).ReadEffect().Lub                                  (instruction.BeforeState.PeekPointsTo(1).WriteEffect());                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   copyEffect'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new WriteExpression(a[0]' new ReadExpression(a[1]).CloneIfStruct(compEnv)))));                          }                      case TypeOp.Newarr:                          // Growing the heap is not considered an observable change. But will throw if                          // length < 0                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new NewArrayExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Initobj:                          return stack.PopEvalSE                              (statements' 1' true' WriteHeapE' (s' a) => s.Add(new InitializeObjectStatement(a[0])));                      case TypeOp.Castclass:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new CastExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Isinst:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new IsInstExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Box:                          // Growing the heap is not considered an observable change                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new NewBoxExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Unbox:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).AddressOf()' e.Lub(ThrowsE)));                      case TypeOp.UnboxAny:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).Read().CloneIfStruct(compEnv)' e.Lub(ThrowsE)));                      case TypeOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new TypeHandleConstantExpression(compEnv.SubstituteType(typei.Type))' BottomE));                          return true;                      case TypeOp.Ldelem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case TypeOp.Stelem:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add(new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  // Calculating the pointer may throw if index is out of range.                  // Remaining effect will be accounted for when pointer is read/written.                  return stack.PopEvalPush                      (statements'                       2'                       true'                       (a' e) =>                       new ExpressionStackEntry(new ElementCell(a[0]' a[1]' false).AddressOf()' e.Lub(ThrowsE)));              case InstructionFlavor.LdInt32:                  {                      var int32i = (LdInt32Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int32ConstantExpression(int32i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdInt64:                  {                      var int64i = (LdInt64Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int64ConstantExpression(int64i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdSingle:                  {                      var singlei = (LdSingleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new SingleConstantExpression(singlei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdDouble:                  {                      var doublei = (LdDoubleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new DoubleConstantExpression(doublei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdString:                  {                      var stringi = (LdStringInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new StringConstantExpression(stringi.Value)' BottomE));                      return true;                  }              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Div:                      case ArithOp.Rem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(ThrowsE)));                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                      case ArithOp.Shl:                      case ArithOp.Shr:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(arithi.WithOverflow ? ThrowsE : BottomE)));                      case ArithOp.Neg:                      case ArithOp.BitNot:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression                                        (a[0]' ArithOpToUnaryOp(arithi.Op)' arithi.WithOverflow' arithi.IsUnsigned)'                                    e));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      return stack.PopEvalPush                          (statements'                           1'                           true'                           (a' e) =>                           new ExpressionStackEntry                               (new ConvertExpression                                    (a[0]'                                     new NamedTypeRef                                         (compEnv.Global.NumberFlavorToQualifiedTypeName[convi.TargetNumberFlavor])'                                     convi.WithOverflow'                                     convi.IsSourceUnsigned)'                                e.Lub(convi.WithOverflow ? ThrowsE : BottomE)));                  }              case InstructionFlavor.Try:                  {                      if (stack.Depth > 0)                          throw new InvalidOperationException("stack must be empty on entry to try block");                      var tryi = (TryInstruction)instruction;                      var tryStatements = BlockToTryFaultFinallyStatements(tryi.Body);                      if (tryStatements == null)                          return false;                      var handlers = TranslateHandlers(tryi.Handlers);                      if (handlers == null)                          return false;                      if (statements == null)                          return Failed(false' "try");                      statements.Add(new TryStatement(tryStatements' handlers));                      return true;                  }              case InstructionFlavor.IfThenElsePseudo:                  {                      var itei = (IfThenElseInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(itei.Offset' out isExpr) ||                                              isExpr;                        if (!TranslateBlock(statements' itei.Condition' stack' exid))                          return false;                      if (couldBeExpression && itei.Else != null)                      {                          // Pass 1: Try to tranlate to an if-then-else expression. Will only work if Then and Else don't                          //         reach into current stack' push exactly one value' and don't need to emit any                          //         statements along the way.                          var thenEntry = BlockToExpression(itei.Then' exid);                          if (thenEntry != null)                          {                              var elseEntry = BlockToExpression(itei.Else' exid);                              if (elseEntry != null)                              {                                  if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                                      instructionTranslationStyleCache.Add(itei.Offset' true);                                  return stack.PopEvalPush                                      (statements'                                       1'                                       true'                                       (a' e) =>                                       new ExpressionStackEntry                                           (new IfThenElseExpression(a[0]' thenEntry.Expression' elseEntry.Expression)'                                            e.Lub(thenEntry.Effects.Lub(elseEntry.Effects))));                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      var noStackChange = itei.Then.NoStackChange && (itei.Else == null || itei.Else.NoStackChange);                      var condEntry = noStackChange                                          ? stack.Pop()                                          : stack.FlushAndPopPostState(statements' itei.Then.BeforeState);                      if (condEntry == null)                          return false;                      var thenStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Then' exid)                                           : BlockToStatements(itei.Then' exid);                      if (thenStmnts == null)                          return false;                      var elseStmnts = default(Seq<Statement>);                      if (itei.Else != null)                      {                          elseStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Else' exid)                                           : BlockToStatements(itei.Else' exid);                          if (elseStmnts == null)                              return false;                      }                      if (statements == null)                          return Failed(false' "if-then-else");                      statements.Add                          (new IfThenElseStatement(condEntry.Expression' new Statements(thenStmnts)' elseStmnts == null ? null : new Statements(elseStmnts)));                      if (!noStackChange && !stack.Restore(itei.AfterState' 0))                          return false;                      if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                          instructionTranslationStyleCache.Add(itei.Offset' false);                      return true;                  }              case InstructionFlavor.ShortCircuitingPseudo:                  {                      var sci = (ShortCircuitingInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(sci.Offset' out isExpr) ||                                              isExpr;                      if (couldBeExpression)                      {                          // Pass 1: Try to translate to an expression.                          var leftEntry = BlockToExpression(sci.Left' exid);                          if (leftEntry != null)                          {                              var rightEntry = BlockToExpression(sci.Right' exid);                              if (rightEntry != null)                              {                                  stack.Push                                      (new ExpressionStackEntry                                           (new BinaryExpression                                                (leftEntry.Expression'                                                 ShortCircuitingOpToBinaryOp(sci.Op)'                                                 rightEntry.Expression'                                                 false'                                                 false)'                                            leftEntry.Effects.Lub(rightEntry.Effects)));                                  if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                                      instructionTranslationStyleCache.Add(sci.Offset' true);                                  return true;                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      if (!TranslateBlock(statements' sci.Left' stack' exid))                          return false;                      var leftEntry2 = stack.FlushAndPopPostState(statements' sci.Right.BeforeState);                      if (leftEntry2 == null)                          return false;                      var rightStatements = BlockToStatements(sci.Right' exid);                      if (rightStatements == null)                          return false;                      var id = sci.Right.AfterState.PeekId(0' nameSupply.GenSym);                      var cell = new VariableCell(id);                      compEnv.AddVariable(id' ArgLocal.Local' false' true' compEnv.SubstituteType(sci.Right.AfterState.PeekType(0)));                      if (statements == null)                          return Failed(false' "short-circuit");                      switch (sci.Op)                      {                      case ShortCircuitingOp.And:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements(rightStatements)'                                    new Statements                                        (new ExpressionStatement(cell.Write(new Int32ConstantExpression(0))))));                          break;                      case ShortCircuitingOp.Or:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements                                        (new ExpressionStatement                                             (cell.Write(new Int32ConstantExpression(1))))'                                    new Statements(rightStatements)));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      if (!stack.Restore(sci.AfterState' 1))                          return false;                      stack.Push(new ExpressionStackEntry(cell.Read()' BottomE));                      if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                          instructionTranslationStyleCache.Add(sci.Offset' false);                      return true;                  }              case InstructionFlavor.StructuralSwitchPseudo:                  {                      var ssi = (StructuralSwitchInstruction)instruction;                      if (!TranslateBlock(statements' ssi.Body' stack' exid))                          return false;                      var valueEntry = stack.FlushAndPopPreState(statements' ssi.Body.AfterState);                      if (valueEntry == null)                          return false;                      var cases = new Seq<SwitchStatementCase>();                      foreach (var c in ssi.Cases)                      {                          var caseStatements = BlockToStatements(c.Body' exid);                          if (caseStatements == null)                              return false;                          cases.Add(new SwitchStatementCase(c.Values' new Statements(caseStatements)));                      }                      if (statements == null)                          return Failed(false' "structural switch");                      statements.Add(new SwitchStatement(valueEntry.Expression' cases));                      if (!stack.Restore(ssi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopPseudo:                  {                      var li = (LoopInstruction)instruction;                      if (!stack.Flush(statements' li.Body.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop");                      var whileStatements = BlockToStatements(li.Body' exid);                      statements.Add                          (new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(whileStatements)));                      if (!stack.Restore(li.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.WhileDoPseudo:                  {                      var wdi = (WhileDoInstruction)instruction;                      if (!stack.Flush(statements' wdi.Condition.BeforeState))                          return false;                      var condEntry = BlockToExpression(wdi.Condition' exid);                      if (condEntry == null)                      {                          var stack1 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Condition.BeforeState' trace);                          var preCondStatements = new Seq<Statement>();                          if (!TranslateBlock(preCondStatements' wdi.Condition' stack1' exid))                              return false;                          condEntry = stack1.FlushAndPopPostState(preCondStatements' wdi.Body.BeforeState);                          if (condEntry == null)                              return false;                          var stack2 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Body.BeforeState' trace);                          var postCondStatements = new Seq<Statement>();                          if (!TranslateBlock(postCondStatements' wdi.Body' stack2' exid))                              return false;                          if (!stack2.Flush(postCondStatements' wdi.Body.AfterState))                              return false;                          preCondStatements.Add                              (new IfThenElseStatement                                   (condEntry.Expression'                                    new Statements(postCondStatements)'                                    new Statements(new BreakStatement())));                          statements.Add(new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(preCondStatements)));                      }                      else                      {                          var loopStatements = BlockToStatements(wdi.Body' exid);                          if (loopStatements == null)                              return false;                          if (statements == null)                              return Failed(false' "while-do");                          statements.Add(new WhileDoStatement(condEntry.Expression' new Statements(loopStatements)));                      }                      if (!stack.Restore(wdi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.DoWhilePseudo:                  {                      var dwi = (DoWhileInstruction)instruction;                      if (!stack.Flush(statements' dwi.Body.BeforeState))                          return false;                      var combined = new Seq<Instruction>();                      foreach (var i in dwi.Body.Body)                          combined.Add(i);                      foreach (var i in dwi.Condition.Body)                          combined.Add(i);                      var condEntry = default(ExpressionStackEntry);                      var loopStatements = BlockToConditionStatements                          (new Instructions(null' combined)' dwi.Body.BeforeState' exid' out condEntry);                      if (loopStatements == null)                          return false;                      if (statements == null)                          return Failed(false' "do-while");                      statements.Add(new DoWhileStatement(new Statements(loopStatements)' condEntry.Expression));                      if (!stack.Restore(dwi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopControlPseudo:                  {                      var lci = (BreakContinueInstruction)instruction;                      if (!stack.Flush(statements' lci.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop-control");                      var targetState = default(int);                      switch (lci.Op)                      {                      case BreakContinueOp.Break:                          if (labelToLoopCandidateBreakState != null &&                              labelToLoopCandidateBreakState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new BreakStatement(lci.Label));                          break;                      case BreakContinueOp.Continue:                          if (labelToLoopCandidateContinueState != null &&                              labelToLoopCandidateContinueState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new ContinueStatement(lci.Label));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      return true;                  }              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,TranslateInstruction,The following statement contains a magic number: switch (instruction.Flavor)              {              case InstructionFlavor.Unsupported:                  throw new InvalidOperationException("unsupported opcode");              case InstructionFlavor.Misc:                  {                      var misci = (MiscInstruction)instruction;                      switch (misci.Op)                      {                      case MiscOp.Nop:                      case MiscOp.Break:                          return true;                      case MiscOp.Dup:                          return stack.Dup(statements);                      case MiscOp.Pop:                          return stack.PopAndDiscard(statements);                      case MiscOp.Ldnull:                          stack.Push(new ExpressionStackEntry(new NullConstantExpression()' BottomE));                          return true;                      case MiscOp.Ckfinite:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.CheckFinite' false' false)' e.Lub(ThrowsE)));                      case MiscOp.Throw:                          if (!stack.DiscardAll(statements' 1))                              return false;                          if (!stack.PopEvalSE(statements' 1' true' ThrowsE' (s' a) => s.Add(new ThrowStatement(a[0]))))                              return false;                          return true;                      case MiscOp.Rethrow:                          if (!stack.DiscardAll(statements' 0))                              return false;                          if (statements == null)                              return Failed(false' "rethrow");                          if (exid == null)                              throw new InvalidOperationException("rethrow outside of catch");                          statements.Add(new RethrowStatement(new VariableCell(exid).Read()));                          return true;                      case MiscOp.LdindRef:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case MiscOp.LdelemRef:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.Ldlen:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression(a[0]' UnaryOp.Length' false' false)' e.Lub(ReadHeapOrThrowE)));                      case MiscOp.StindRef:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case MiscOp.StelemRef:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add                                   (new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      case MiscOp.Ret:                          if (statements == null)                              return Failed(false' "return");                          statements.Add(new ReturnStatement(null));                          return true;                      case MiscOp.RetVal:                          return stack.PopEvalSE                              (statements' 1' true' BottomE' (s' a) => s.Add(new ReturnStatement(a[0])));                      case MiscOp.Endfilter:                      case MiscOp.Endfinally:                          throw new InvalidOperationException                              ("endfilter/endfinally instructions should have been removed");                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Branch:              case InstructionFlavor.Switch:                  throw new InvalidOperationException("branch/switch instructions should have been removed");              case InstructionFlavor.Compare:                  {                      var cmpi = (CompareInstruction)instruction;                      if (cmpi.Op == CompareOp.CtruePseudo || cmpi.Op == CompareOp.CfalsePseudo)                      {                          var s = cmpi.Type.Style(compEnv);                          var unop = default(UnaryOp);                          if (s is NumberTypeStyle)                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonZero : UnaryOp.IsZero;                          else                              unop = cmpi.Op == CompareOp.CtruePseudo ? UnaryOp.IsNonNull : UnaryOp.IsNull;                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new UnaryExpression(a[0]' unop' false' cmpi.IsUnsigned)' e));                      }                      else                      {                          var binop = default(BinaryOp);                          switch (cmpi.Op)                          {                          case CompareOp.Ceq:                              binop = BinaryOp.Eq;                              break;                          case CompareOp.Clt:                              binop = BinaryOp.Lt;                              break;                          case CompareOp.Cgt:                              binop = BinaryOp.Gt;                              break;                          case CompareOp.CgePseudo:                              binop = BinaryOp.Ge;                              break;                          case CompareOp.ClePseudo:                              binop = BinaryOp.Le;                              break;                          case CompareOp.CnePseudo:                              binop = BinaryOp.Ne;                              break;                          case CompareOp.CtruePseudo:                          case CompareOp.CfalsePseudo:                              // handled above                              throw new InvalidOperationException();                          default:                              throw new ArgumentOutOfRangeException();                          }                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression(a[0]' binop' a[1]' false' cmpi.IsUnsigned)' e));                      }                  }              case InstructionFlavor.ArgLocal:                  {                      var sli = (ArgLocalInstruction)instruction;                      var id = default(JST.Identifier);                      switch (sli.ArgLocal)                      {                      case ArgLocal.Arg:                          id = compEnv.ValueParameterIds[sli.Index];                          break;                      case ArgLocal.Local:                          id = compEnv.LocalIds[sli.Index];                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      var cell = new VariableCell(id);                      switch (sli.Op)                      {                      case ArgLocalOp.Ld:                          stack.Push                              (new ExpressionStackEntry                                   (cell.Read().CloneIfStruct(compEnv)' ReadArgLocalE(sli.ArgLocal' sli.Index)));                          return true;                      case ArgLocalOp.Lda:                          // Effect will be accounted for on reads/writes                          stack.Push(new ExpressionStackEntry(cell.AddressOf()' BottomE));                          return true;                      case ArgLocalOp.St:                          return stack.PopEvalSE                              (statements'                               1'                               true'                               WriteArgLocalE(sli.ArgLocal' sli.Index)'                               (s' a) => s.Add(new ExpressionStatement(cell.Write(a[0]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Field:                  {                      var fieldi = (FieldInstruction)instruction;                      switch (fieldi.Op)                      {                      case FieldOp.Ldfld:                          if (fieldi.IsStatic)                          {                              stack.Push                                  (new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' ReadHeapE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                       {                                           var readEffect = default(Effects);                                           var obj = default(Expression);                                           if (fieldi.IsViaPointer.Value)                                           {                                               readEffect = e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect());                                               obj = new ReadExpression(a[0]); // no need for clone                                           }                                           else if (fieldi.Field.DefiningType.Style(compEnv) is ValueTypeStyle)                                           {                                               readEffect = e;                                               obj = a[0];                                           }                                           else                                           {                                               // Object could be null                                               readEffect = e.Lub(ReadHeapOrThrowE);                                               obj = a[0];                                           }                                           return new ExpressionStackEntry(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Read().CloneIfStruct(compEnv)' readEffect);                                       });                      case FieldOp.Ldflda:                          if (fieldi.IsStatic)                          {                              // Effect will be accounted for on reads/writes                              stack.Push(new ExpressionStackEntry(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' BottomE));                              return true;                          }                          else                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   {                                       if (fieldi.IsViaPointer.Value)                                           // We're just adding an offset to a pointer' so effect will                                           // be accounted for when the final pointer is read/written                                           return new ExpressionStackEntry(new FieldCell(new ReadExpression(a[0])' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e);                                       else                                           // Must be a reference type' and ref could be null                                           return new ExpressionStackEntry(new FieldCell(a[0]' compEnv.SubstituteMember(fieldi.Field)).AddressOf()' e.Lub(ThrowsE));                                   });                      case FieldOp.Stfld:                          if (fieldi.IsStatic)                              return stack.PopEvalSE                                  (statements'                                   1'                                   true'                                   WriteHeapE'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement(new FieldCell(null' compEnv.SubstituteMember(fieldi.Field)).Write(a[0]))));                          else                          {                              var writeEffect = fieldi.IsViaPointer.Value                                                    ? instruction.BeforeState.PeekPointsTo(1).WriteEffect()                                                    : WriteHeapOrThrowE;                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   writeEffect'                                   (s' a) =>                                       {                                           var obj = fieldi.IsViaPointer.Value ? new ReadExpression(a[0]) : a[0];                                           s.Add(new ExpressionStatement(new FieldCell(obj' compEnv.SubstituteMember(fieldi.Field)).Write(a[1])));                                       });                          }                      case FieldOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new FieldHandleConstantExpression(compEnv.SubstituteMember(fieldi.Field))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Method:                  {                      var methodi = (MethodInstruction)instruction;                      var arity = methodi.Method.ValueParameters.Count;                      switch (methodi.Op)                      {                      case MethodOp.Ldftn:                          if (methodi.IsVirtual)                              // Object could be null                              return stack.PopEvalPush                                  (statements'                                   1'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CodePointerExpression(a[0]' compEnv.SubstituteMember(methodi.Method))' e.Lub(ReadHeapOrThrowE)));                          else                          {                              stack.Push                                  (new ExpressionStackEntry(new CodePointerExpression(null' compEnv.SubstituteMember(methodi.Method))' BottomE));                              return true;                          }                      case MethodOp.Call:                          if (methodi.Method.Result == null)                              return stack.PopEvalSE                                  (statements'                                   arity'                                   true'                                   CalleeEffects(methodi.BeforeState' arity)'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new CallExpression                                                 (methodi.IsVirtual ? CallFlavor.Virtual : CallFlavor.Normal'                                                  compEnv.SubstituteMember(methodi.Method)'                                                  CallerArguments(methodi.Constrained' methodi.Method' a)))));                          else                              return stack.PopEvalPush                                  (statements'                                   arity'                                   true'                                   (a' e) =>                                   new ExpressionStackEntry                                       (new CallExpression                                            (methodi.IsVirtual? CallFlavor.Virtual : CallFlavor.Normal'                                             compEnv.SubstituteMember(methodi.Method)'                                             CallerArguments(methodi.Constrained' methodi.Method' a))'                                        e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Newobj:                          arity--;                          return stack.PopEvalPush                              (statements'                               arity'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new NewObjectExpression(compEnv.SubstituteMember(methodi.Method)' CallerArguments(null' methodi.Method' a))'                                    e.Lub(CalleeEffects(methodi.BeforeState' arity))));                      case MethodOp.Ldtoken:                          stack.Push                              (new ExpressionStackEntry(new MethodHandleConstantExpression(compEnv.SubstituteMember(methodi.Method))' BottomE));                          return true;                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Type:                  {                      var typei = (TypeInstruction)instruction;                      switch (typei.Op)                      {                      case TypeOp.Ldobj:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new ReadExpression(a[0]).CloneIfStruct(compEnv)'                                    e.Lub(instruction.BeforeState.PeekPointsTo(0).ReadEffect())));                      case TypeOp.Stobj:                          return stack.PopEvalSE                              (statements'                               2'                               true'                               instruction.BeforeState.PeekPointsTo(1).WriteEffect()'                               (s' a) => s.Add(new ExpressionStatement(new WriteExpression(a[0]' a[1]))));                      case TypeOp.Cpobj:                          {                              var copyEffect = instruction.BeforeState.PeekPointsTo(0).ReadEffect().Lub                                  (instruction.BeforeState.PeekPointsTo(1).WriteEffect());                              return stack.PopEvalSE                                  (statements'                                   2'                                   true'                                   copyEffect'                                   (s' a) =>                                   s.Add                                       (new ExpressionStatement                                            (new WriteExpression(a[0]' new ReadExpression(a[1]).CloneIfStruct(compEnv)))));                          }                      case TypeOp.Newarr:                          // Growing the heap is not considered an observable change. But will throw if                          // length < 0                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new NewArrayExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Initobj:                          return stack.PopEvalSE                              (statements' 1' true' WriteHeapE' (s' a) => s.Add(new InitializeObjectStatement(a[0])));                      case TypeOp.Castclass:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new CastExpression(a[0]' compEnv.SubstituteType(typei.Type))' e.Lub(ThrowsE)));                      case TypeOp.Isinst:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new IsInstExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Box:                          // Growing the heap is not considered an observable change                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) => new ExpressionStackEntry(new NewBoxExpression(a[0]' compEnv.SubstituteType(typei.Type))' e));                      case TypeOp.Unbox:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).AddressOf()' e.Lub(ThrowsE)));                      case TypeOp.UnboxAny:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry(new BoxCell(a[0]' compEnv.SubstituteType(typei.Type)).Read().CloneIfStruct(compEnv)' e.Lub(ThrowsE)));                      case TypeOp.Ldtoken:                          stack.Push(new ExpressionStackEntry(new TypeHandleConstantExpression(compEnv.SubstituteType(typei.Type))' BottomE));                          return true;                      case TypeOp.Ldelem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry(new ElementCell(a[0]' a[1]' true).Read().CloneIfStruct(compEnv)' e.Lub(ReadHeapOrThrowE)));                      case TypeOp.Stelem:                          return stack.PopEvalSE                              (statements'                               3'                               true'                               WriteHeapOrThrowE'                               (s' a) =>                               s.Add(new ExpressionStatement(new ElementCell(a[0]' a[1]' false).Write(a[2]))));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.LdElemAddr:                  // Calculating the pointer may throw if index is out of range.                  // Remaining effect will be accounted for when pointer is read/written.                  return stack.PopEvalPush                      (statements'                       2'                       true'                       (a' e) =>                       new ExpressionStackEntry(new ElementCell(a[0]' a[1]' false).AddressOf()' e.Lub(ThrowsE)));              case InstructionFlavor.LdInt32:                  {                      var int32i = (LdInt32Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int32ConstantExpression(int32i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdInt64:                  {                      var int64i = (LdInt64Instruction)instruction;                      stack.Push(new ExpressionStackEntry(new Int64ConstantExpression(int64i.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdSingle:                  {                      var singlei = (LdSingleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new SingleConstantExpression(singlei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdDouble:                  {                      var doublei = (LdDoubleInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new DoubleConstantExpression(doublei.Value)' BottomE));                      return true;                  }              case InstructionFlavor.LdString:                  {                      var stringi = (LdStringInstruction)instruction;                      stack.Push(new ExpressionStackEntry(new StringConstantExpression(stringi.Value)' BottomE));                      return true;                  }              case InstructionFlavor.Arith:                  {                      var arithi = (ArithInstruction)instruction;                      switch (arithi.Op)                      {                      case ArithOp.Div:                      case ArithOp.Rem:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(ThrowsE)));                      case ArithOp.Add:                      case ArithOp.Sub:                      case ArithOp.Mul:                      case ArithOp.BitAnd:                      case ArithOp.BitOr:                      case ArithOp.BitXor:                      case ArithOp.Shl:                      case ArithOp.Shr:                          return stack.PopEvalPush                              (statements'                               2'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new BinaryExpression                                        (a[0]'                                         ArithOpToBinaryOp(arithi.Op)'                                         a[1]'                                         arithi.WithOverflow'                                         arithi.IsUnsigned)'                                    e.Lub(arithi.WithOverflow ? ThrowsE : BottomE)));                      case ArithOp.Neg:                      case ArithOp.BitNot:                          return stack.PopEvalPush                              (statements'                               1'                               true'                               (a' e) =>                               new ExpressionStackEntry                                   (new UnaryExpression                                        (a[0]' ArithOpToUnaryOp(arithi.Op)' arithi.WithOverflow' arithi.IsUnsigned)'                                    e));                      default:                          throw new ArgumentOutOfRangeException();                      }                  }              case InstructionFlavor.Conv:                  {                      var convi = (ConvInstruction)instruction;                      return stack.PopEvalPush                          (statements'                           1'                           true'                           (a' e) =>                           new ExpressionStackEntry                               (new ConvertExpression                                    (a[0]'                                     new NamedTypeRef                                         (compEnv.Global.NumberFlavorToQualifiedTypeName[convi.TargetNumberFlavor])'                                     convi.WithOverflow'                                     convi.IsSourceUnsigned)'                                e.Lub(convi.WithOverflow ? ThrowsE : BottomE)));                  }              case InstructionFlavor.Try:                  {                      if (stack.Depth > 0)                          throw new InvalidOperationException("stack must be empty on entry to try block");                      var tryi = (TryInstruction)instruction;                      var tryStatements = BlockToTryFaultFinallyStatements(tryi.Body);                      if (tryStatements == null)                          return false;                      var handlers = TranslateHandlers(tryi.Handlers);                      if (handlers == null)                          return false;                      if (statements == null)                          return Failed(false' "try");                      statements.Add(new TryStatement(tryStatements' handlers));                      return true;                  }              case InstructionFlavor.IfThenElsePseudo:                  {                      var itei = (IfThenElseInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(itei.Offset' out isExpr) ||                                              isExpr;                        if (!TranslateBlock(statements' itei.Condition' stack' exid))                          return false;                      if (couldBeExpression && itei.Else != null)                      {                          // Pass 1: Try to tranlate to an if-then-else expression. Will only work if Then and Else don't                          //         reach into current stack' push exactly one value' and don't need to emit any                          //         statements along the way.                          var thenEntry = BlockToExpression(itei.Then' exid);                          if (thenEntry != null)                          {                              var elseEntry = BlockToExpression(itei.Else' exid);                              if (elseEntry != null)                              {                                  if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                                      instructionTranslationStyleCache.Add(itei.Offset' true);                                  return stack.PopEvalPush                                      (statements'                                       1'                                       true'                                       (a' e) =>                                       new ExpressionStackEntry                                           (new IfThenElseExpression(a[0]' thenEntry.Expression' elseEntry.Expression)'                                            e.Lub(thenEntry.Effects.Lub(elseEntry.Effects))));                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      var noStackChange = itei.Then.NoStackChange && (itei.Else == null || itei.Else.NoStackChange);                      var condEntry = noStackChange                                          ? stack.Pop()                                          : stack.FlushAndPopPostState(statements' itei.Then.BeforeState);                      if (condEntry == null)                          return false;                      var thenStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Then' exid)                                           : BlockToStatements(itei.Then' exid);                      if (thenStmnts == null)                          return false;                      var elseStmnts = default(Seq<Statement>);                      if (itei.Else != null)                      {                          elseStmnts = noStackChange                                           ? BlockToStatementsEmptyStack(itei.Else' exid)                                           : BlockToStatements(itei.Else' exid);                          if (elseStmnts == null)                              return false;                      }                      if (statements == null)                          return Failed(false' "if-then-else");                      statements.Add                          (new IfThenElseStatement(condEntry.Expression' new Statements(thenStmnts)' elseStmnts == null ? null : new Statements(elseStmnts)));                      if (!noStackChange && !stack.Restore(itei.AfterState' 0))                          return false;                      if (!instructionTranslationStyleCache.ContainsKey(itei.Offset))                          instructionTranslationStyleCache.Add(itei.Offset' false);                      return true;                  }              case InstructionFlavor.ShortCircuitingPseudo:                  {                      var sci = (ShortCircuitingInstruction)instruction;                      var isExpr = default(bool);                      // If outer context is re-translating as statements instead of expression' jump directly                      // to appropriate translation for this instruction                      var couldBeExpression = !instructionTranslationStyleCache.TryGetValue(sci.Offset' out isExpr) ||                                              isExpr;                      if (couldBeExpression)                      {                          // Pass 1: Try to translate to an expression.                          var leftEntry = BlockToExpression(sci.Left' exid);                          if (leftEntry != null)                          {                              var rightEntry = BlockToExpression(sci.Right' exid);                              if (rightEntry != null)                              {                                  stack.Push                                      (new ExpressionStackEntry                                           (new BinaryExpression                                                (leftEntry.Expression'                                                 ShortCircuitingOpToBinaryOp(sci.Op)'                                                 rightEntry.Expression'                                                 false'                                                 false)'                                            leftEntry.Effects.Lub(rightEntry.Effects)));                                  if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                                      instructionTranslationStyleCache.Add(sci.Offset' true);                                  return true;                              }                              // else: fallthrough                          }                          // else: fallthrough                      }                      // else: fallthrough                        // Pass 2: Translate to a statement                      if (!TranslateBlock(statements' sci.Left' stack' exid))                          return false;                      var leftEntry2 = stack.FlushAndPopPostState(statements' sci.Right.BeforeState);                      if (leftEntry2 == null)                          return false;                      var rightStatements = BlockToStatements(sci.Right' exid);                      if (rightStatements == null)                          return false;                      var id = sci.Right.AfterState.PeekId(0' nameSupply.GenSym);                      var cell = new VariableCell(id);                      compEnv.AddVariable(id' ArgLocal.Local' false' true' compEnv.SubstituteType(sci.Right.AfterState.PeekType(0)));                      if (statements == null)                          return Failed(false' "short-circuit");                      switch (sci.Op)                      {                      case ShortCircuitingOp.And:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements(rightStatements)'                                    new Statements                                        (new ExpressionStatement(cell.Write(new Int32ConstantExpression(0))))));                          break;                      case ShortCircuitingOp.Or:                          statements.Add                              (new IfThenElseStatement                                   (leftEntry2.Expression'                                    new Statements                                        (new ExpressionStatement                                             (cell.Write(new Int32ConstantExpression(1))))'                                    new Statements(rightStatements)));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      if (!stack.Restore(sci.AfterState' 1))                          return false;                      stack.Push(new ExpressionStackEntry(cell.Read()' BottomE));                      if (!instructionTranslationStyleCache.ContainsKey(sci.Offset))                          instructionTranslationStyleCache.Add(sci.Offset' false);                      return true;                  }              case InstructionFlavor.StructuralSwitchPseudo:                  {                      var ssi = (StructuralSwitchInstruction)instruction;                      if (!TranslateBlock(statements' ssi.Body' stack' exid))                          return false;                      var valueEntry = stack.FlushAndPopPreState(statements' ssi.Body.AfterState);                      if (valueEntry == null)                          return false;                      var cases = new Seq<SwitchStatementCase>();                      foreach (var c in ssi.Cases)                      {                          var caseStatements = BlockToStatements(c.Body' exid);                          if (caseStatements == null)                              return false;                          cases.Add(new SwitchStatementCase(c.Values' new Statements(caseStatements)));                      }                      if (statements == null)                          return Failed(false' "structural switch");                      statements.Add(new SwitchStatement(valueEntry.Expression' cases));                      if (!stack.Restore(ssi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopPseudo:                  {                      var li = (LoopInstruction)instruction;                      if (!stack.Flush(statements' li.Body.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop");                      var whileStatements = BlockToStatements(li.Body' exid);                      statements.Add                          (new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(whileStatements)));                      if (!stack.Restore(li.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.WhileDoPseudo:                  {                      var wdi = (WhileDoInstruction)instruction;                      if (!stack.Flush(statements' wdi.Condition.BeforeState))                          return false;                      var condEntry = BlockToExpression(wdi.Condition' exid);                      if (condEntry == null)                      {                          var stack1 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Condition.BeforeState' trace);                          var preCondStatements = new Seq<Statement>();                          if (!TranslateBlock(preCondStatements' wdi.Condition' stack1' exid))                              return false;                          condEntry = stack1.FlushAndPopPostState(preCondStatements' wdi.Body.BeforeState);                          if (condEntry == null)                              return false;                          var stack2 = new ExpressionStack(compEnv' BottomE' nameSupply.GenSym' wdi.Body.BeforeState' trace);                          var postCondStatements = new Seq<Statement>();                          if (!TranslateBlock(postCondStatements' wdi.Body' stack2' exid))                              return false;                          if (!stack2.Flush(postCondStatements' wdi.Body.AfterState))                              return false;                          preCondStatements.Add                              (new IfThenElseStatement                                   (condEntry.Expression'                                    new Statements(postCondStatements)'                                    new Statements(new BreakStatement())));                          statements.Add(new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(preCondStatements)));                      }                      else                      {                          var loopStatements = BlockToStatements(wdi.Body' exid);                          if (loopStatements == null)                              return false;                          if (statements == null)                              return Failed(false' "while-do");                          statements.Add(new WhileDoStatement(condEntry.Expression' new Statements(loopStatements)));                      }                      if (!stack.Restore(wdi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.DoWhilePseudo:                  {                      var dwi = (DoWhileInstruction)instruction;                      if (!stack.Flush(statements' dwi.Body.BeforeState))                          return false;                      var combined = new Seq<Instruction>();                      foreach (var i in dwi.Body.Body)                          combined.Add(i);                      foreach (var i in dwi.Condition.Body)                          combined.Add(i);                      var condEntry = default(ExpressionStackEntry);                      var loopStatements = BlockToConditionStatements                          (new Instructions(null' combined)' dwi.Body.BeforeState' exid' out condEntry);                      if (loopStatements == null)                          return false;                      if (statements == null)                          return Failed(false' "do-while");                      statements.Add(new DoWhileStatement(new Statements(loopStatements)' condEntry.Expression));                      if (!stack.Restore(dwi.AfterState' 0))                          return false;                      return true;                  }              case InstructionFlavor.LoopControlPseudo:                  {                      var lci = (BreakContinueInstruction)instruction;                      if (!stack.Flush(statements' lci.BeforeState))                          return false;                      if (statements == null)                          return Failed(false' "loop-control");                      var targetState = default(int);                      switch (lci.Op)                      {                      case BreakContinueOp.Break:                          if (labelToLoopCandidateBreakState != null &&                              labelToLoopCandidateBreakState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new BreakStatement(lci.Label));                          break;                      case BreakContinueOp.Continue:                          if (labelToLoopCandidateContinueState != null &&                              labelToLoopCandidateContinueState.TryGetValue(lci.Label' out targetState))                              statements.Add(new GotoPseudoStatement(stateId' targetState));                          else                              statements.Add(new ContinueStatement(lci.Label));                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      return true;                  }              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.CST,Translator,C:\repos\Reactive-Extensions_IL2JS\CST\Translator.cs,Translate,The following statement contains a magic number: if (preorder.Count == 2)              {                  // Only one non-root basic block' so its body is what we need                  var statements = BlockToStatements(preorder[1].Block' null);                  if (statements == null)                      throw new InvalidOperationException("translation failed");                  return new Statements(statements);              }              else              {                  // More than one non-root basic block. Encode transitions between them as a state machine.                  stateId = nameSupply.GenSym();                  var stateCell = new VariableCell(stateId);                  var statePCCell = new StatePCPseudoCell(stateId);                  compEnv.AddVariable(stateId' ArgLocal.Local' false' false' compEnv.Global.Int32Ref);                    // Pass 1: Collect the  head and break parts of loop candidates.                  //         We can't inline these since they need a state number of their own for                   //         encoding break and continue statements.                  var nonInlinable = new Set<BasicBlock>();                  foreach (var bb in preorder)                  {                      var lcbb = bb as LoopCandidateBasicBlock;                      if (lcbb != null)                      {                          nonInlinable.Add(lcbb.Head);                          nonInlinable.Add(lcbb.Break);                      }                  }                    // Pass 2: Check if we need to handle exceptions' and build a map from non-inlinable basic                  //         blocks to their state numbers                  var withExceptions = false;                  var stateMap = new Map<BasicBlock' int>();                  foreach (var bb in preorder)                  {                      switch (bb.Flavor)                      {                      case BasicBlockFlavor.Root:                      case BasicBlockFlavor.Jump:                      case BasicBlockFlavor.Leave:                      case BasicBlockFlavor.Branch:                      case BasicBlockFlavor.Switch:                      case BasicBlockFlavor.NonReturning:                      case BasicBlockFlavor.LoopCandidate:                          break;                      case BasicBlockFlavor.Try:                      case BasicBlockFlavor.LeaveTry:                      case BasicBlockFlavor.LeaveCatch:                      case BasicBlockFlavor.EndFault:                      case BasicBlockFlavor.EndFinally:                          withExceptions = true;                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      if (bb.Flavor != BasicBlockFlavor.Root && (nonInlinable.Contains(bb) || !CanInlineBlock(bb)))                          stateMap.Add(bb' stateMap.Count);                  }                    // Pass 3: Build map from loop labels to the state representing the break and continue states                  //         for that loop. The above translation code will look there when translating a                  //         break/continue structural instruction to decide what to do.                  labelToLoopCandidateBreakState = new Map<JST.Identifier' int>();                  labelToLoopCandidateContinueState = new Map<JST.Identifier' int>();                  foreach (var bb in preorder)                  {                      var lcbb = bb as LoopCandidateBasicBlock;                      if (lcbb != null)                      {                          var targetState = default(int);                          if (!stateMap.TryGetValue(lcbb.Head' out targetState))                              throw new InvalidCastException("head of loop should not have been inlined");                          labelToLoopCandidateContinueState.Add(lcbb.Label' targetState);                          if (!stateMap.TryGetValue(lcbb.Break' out targetState))                              throw new InvalidCastException("end of loop should not have been inlined");                          labelToLoopCandidateBreakState.Add(lcbb.Label' targetState);                          break;                      }                  }                    // Pass 4: Emit statements and pseudo-statements for each case.                  var statements = new Seq<Statement>();                  var initialState = default(int);                  if (!stateMap.TryGetValue(preorder[1]' out initialState))                      throw new InvalidOperationException("initial block cannot be inlined");                  statements.Add                      (new ExpressionStatement(stateCell.Write(new InitialStatePseudoExpression(initialState))));                  var exid = nameSupply.GenSym();                  var cases =                      stateMap.Select                          (kv => new SwitchStatementCase(new Set<int> { kv.Value }' CaseBody(stateMap' kv.Key' exid))).                          ToSeq();                    // Wrap above in state machine                  var switchStatement = new SwitchStatement(statePCCell.Read()' cases);                  var innerLoop = new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(switchStatement));                  if (withExceptions)                  {                      compEnv.AddVariable(exid' ArgLocal.Local' false' true' compEnv.Global.ExceptionRef);                      var handlerStatement = new HandlePseudoStatement(stateId' exid);                      var handler = new TryStatementCatchHandler                          (new Statements(handlerStatement)' exid' compEnv.Global.ExceptionRef);                      var tryStatement = new TryStatement                          (new Statements(innerLoop)' new Seq<TryStatementHandler> { handler });                      var outerLoop = new WhileDoStatement(new Int32ConstantExpression(1)' new Statements(tryStatement));                      statements.Add(outerLoop);                  }                  else                      statements.Add(innerLoop);                  return new Statements(statements);              }
Magic Number,Microsoft.LiveLabs.CST,MultiDimArrayBounds,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,ConsumeNum,The following statement contains a magic number: while (i < str.Length && str[i] >= '0' && str[i] <= '9')              {                  n = n*10 + (str[i] - '0');                  i++;              }
Magic Number,Microsoft.LiveLabs.CST,MultiDimArrayTypeDef,C:\repos\Reactive-Extensions_IL2JS\CST\TypeDef.cs,MultiDimArrayTypeDef,The following statement contains a magic number: for (var i = 0; i < bounds.Rank*2; i++)                  ctor2Parameters.Add(intParam);
Magic Number,Microsoft.LiveLabs.CST,CSTWriter,C:\repos\Reactive-Extensions_IL2JS\CST\Writer.cs,AppendMnemonicFileName,The following statement contains a magic number: var lim = 40;
Magic Number,Microsoft.LiveLabs.CST,CSTWriter,C:\repos\Reactive-Extensions_IL2JS\CST\Writer.cs,AppendMnemonicFileName,The following statement contains a magic number: if (nm.Length > lim)                  nm = "__" + nm.Substring(nm.Length + 2 - lim' lim - 2);
Magic Number,Microsoft.LiveLabs.CST,CSTWriter,C:\repos\Reactive-Extensions_IL2JS\CST\Writer.cs,AppendMnemonicFileName,The following statement contains a magic number: if (nm.Length > lim)                  nm = "__" + nm.Substring(nm.Length + 2 - lim' lim - 2);
Missing Default,Microsoft.LiveLabs.CST,ControlFlowRecovery,C:\repos\Reactive-Extensions_IL2JS\CST\ControlFlowRecovery.cs,TryReduceLooping,The following switch statement is missing a default case: switch (bb.Flavor)                          {                              case BasicBlockFlavor.Try:                              {                                  var trybb = (TryBasicBlock)bb;                                  if (!loop.Body.Contains(trybb.Body))                                      isCandidateLoop = false;                                  break;                              }                              case BasicBlockFlavor.LoopCandidate:                              {                                  var loopbb = (LoopCandidateBasicBlock)bb;                                  if (!loop.Body.Contains(loopbb.Head) || !loop.Body.Contains(loopbb.Break))                                      isCandidateLoop = false;                                  break;                              }                          }
Missing Default,Microsoft.LiveLabs.CST,TypeName,C:\repos\Reactive-Extensions_IL2JS\CST\Name.cs,Append,The following switch statement is missing a default case: switch (w.Style)              {              case WriterStyle.ReflectionName:                  {                      w.AppendName(Types[Types.Count - 1]);                      break;                  }              case WriterStyle.ReflectionFullName:              case WriterStyle.Uniform:              case WriterStyle.Debug:                  {                      if (!string.IsNullOrEmpty(Namespace))                      {                          w.AppendName(Namespace);                          w.Append('.');                      }                      for (var i = 0; i < Types.Count; i++)                      {                          if (i > 0)                              w.Append('+');                          w.AppendName(Types[i]);                      }                      break;                  }              }
Missing Default,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,FieldDefFromRow,The following switch statement is missing a default case: switch (row.Flags & PE.FieldAttributes.FieldAccessMask)              {              case PE.FieldAttributes.CompilerControlled:                  accessibility = Accessibility.CompilerControlled;                  break;              case PE.FieldAttributes.Private:                  accessibility = Accessibility.Private;                  break;              case PE.FieldAttributes.FamANDAssem:                  accessibility = Accessibility.FamilyANDAssembly;                  break;              case PE.FieldAttributes.Assembly:                  accessibility = Accessibility.Assembly;                  break;              case PE.FieldAttributes.Family:                  accessibility = Accessibility.Family;                  break;              case PE.FieldAttributes.FamORAssem:                  accessibility = Accessibility.FamilyORAssembly;                  break;              case PE.FieldAttributes.Public:                  accessibility = Accessibility.Public;                  break;              }
Missing Default,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,ParameterTypeDefFromRow,The following switch statement is missing a default case: switch (row.Flags & PE.GenericParamAttributes.VarianceMask)              {              case PE.GenericParamAttributes.None:                  variance = ParameterVariance.Invariant;                  break;              case PE.GenericParamAttributes.Covariant:                  variance = ParameterVariance.Covariant;                  break;              case PE.GenericParamAttributes.Contravariant:                  variance = ParameterVariance.Contravariant;                  break;              }
Missing Default,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,MethodDefFromRow,The following switch statement is missing a default case: switch (row.Flags & PE.MethodAttributes.MemberAccessMask)              {              case PE.MethodAttributes.CompilerControlled:                  accessibility = Accessibility.CompilerControlled;                  break;              case PE.MethodAttributes.Private:                  accessibility = Accessibility.Private;                  break;              case PE.MethodAttributes.FamANDAssem:                  accessibility = Accessibility.FamilyANDAssembly;                  break;              case PE.MethodAttributes.Assem:                  accessibility = Accessibility.Assembly;                  break;              case PE.MethodAttributes.Family:                  accessibility = Accessibility.Family;                  break;              case PE.MethodAttributes.FamORAssem:                  accessibility = Accessibility.FamilyORAssembly;                  break;              case PE.MethodAttributes.Public:                  accessibility = Accessibility.Public;                  break;              }
Missing Default,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,MethodDefFromRow,The following switch statement is missing a default case: switch (row.ImplFlags & PE.MethodImplAttributes.CodeTypeMask)              {              case PE.MethodImplAttributes.IL:              case PE.MethodImplAttributes.OPTIL:                  codeFlavor = MethodCodeFlavor.Managed;                  break;              case PE.MethodImplAttributes.Native:                  codeFlavor = MethodCodeFlavor.Native;                  break;              case PE.MethodImplAttributes.Runtime:                  codeFlavor = MethodCodeFlavor.Runtime;                  break;              }
Missing Default,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The following switch statement is missing a default case: switch (row.Flags & PE.TypeAttributes.VisibilityMask)              {              case PE.TypeAttributes.NotPublic:                  accessibility = Accessibility.Private;                  break;              case PE.TypeAttributes.Public:                  accessibility = Accessibility.Public;                  break;              case PE.TypeAttributes.NestedPublic:                  accessibility = Accessibility.Public;                  break;              case PE.TypeAttributes.NestedPrivate:                  accessibility = Accessibility.Private;                  break;              case PE.TypeAttributes.NestedFamily:                  accessibility = Accessibility.Family;                  break;              case PE.TypeAttributes.NestedAssembly:                  accessibility = Accessibility.Assembly;                  break;              case PE.TypeAttributes.NestedFamANDAssem:                  accessibility = Accessibility.FamilyANDAssembly;                  break;              case PE.TypeAttributes.NestedFamORAssem:                  accessibility = Accessibility.FamilyORAssembly;                  break;              }
Missing Default,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The following switch statement is missing a default case: switch (row.Flags & PE.TypeAttributes.LayoutMask)              {              case PE.TypeAttributes.AutoLayout:                  layout = TypeLayout.Auto;                  break;              case PE.TypeAttributes.SequentialLayout:                  layout = TypeLayout.Sequential;                  break;              case PE.TypeAttributes.ExplicitLayout:                  layout = TypeLayout.Explicit;                  break;              }
Missing Default,Microsoft.LiveLabs.CST,PELoader,C:\repos\Reactive-Extensions_IL2JS\CST\PELoader.cs,TypeDefFromRow,The following switch statement is missing a default case: switch (row.Flags & PE.TypeAttributes.StringFormatMask)              {              case PE.TypeAttributes.AnsiClass:                  stringFormat = StringFormat.Ansi;                  break;              case PE.TypeAttributes.UnicodeClass:                  stringFormat = StringFormat.Unicode;                  break;              case PE.TypeAttributes.AutoClass:                  stringFormat = StringFormat.Auto;                  break;              case PE.TypeAttributes.CustomFormatClass:                  stringFormat = StringFormat.Custom;                  break;              }
