Implementation smell,Namespace,Class,File,Method,Description
Long Method,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,AssemblyLoader,C:\repos\Reactive-Extensions_IL2JS\Rewriter\AssemblyLoader.cs,Load,The method has 146 lines of code.
Long Method,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ProcessType,The method has 161 lines of code.
Long Method,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ProcessMethod,The method has 171 lines of code.
Long Method,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,FinalImportScript,The method has 115 lines of code.
Long Method,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The method has 286 lines of code.
Long Method,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,FinalExportInfo,The method has 111 lines of code.
Long Method,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,PrimStyle,The method has 116 lines of code.
Long Method,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,DefnStyle,The method has 209 lines of code.
Long Method,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Program,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Program.cs,Main,The method has 139 lines of code.
Complex Method,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,AssemblyLoader,C:\repos\Reactive-Extensions_IL2JS\Rewriter\AssemblyLoader.cs,Load,Cyclomatic complexity of the method is 17
Complex Method,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,RewriteAssembly,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ProcessMethod,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,PrefixName,Cyclomatic complexity of the method is 17
Complex Method,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,IsImported,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,FinalImportScript,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,FinalExportInfo,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,PrimStyle,Cyclomatic complexity of the method is 24
Complex Method,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,DefnStyle,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,KeyField,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Program,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Program.cs,Main,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropTypes,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropTypes.cs,HasAttribute,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropTypes,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropTypes.cs,GetValue,Cyclomatic complexity of the method is 12
Long Parameter List,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,FinalImportScript,The method has 6 parameters. Parameters: ctxt' gensym' rootId' methodDefn' script' isNew
Long Parameter List,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,FinalExportInfo,The method has 5 parameters. Parameters: ctxt' gensym' rootId' methodDefn' script
Long Parameter List,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,NativeMethods,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Program.cs,StrongNameGetPublicKey,The method has 5 parameters. Parameters: wszKeyContainer' KeyBlob' KeyBlobSize' PublicKeyBlob' PublicKeyBlobSize
Long Parameter List,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropTypes,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropTypes.cs,GetValue,The method has 5 parameters. Parameters: ctxt' attribute' attrType' property' value
Long Parameter List,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropTypes,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropTypes.cs,GetValue,The method has 5 parameters. Parameters: ctxt' attributes' attrType' property' value
Long Parameter List,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropTypes,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropTypes.cs,GetValue,The method has 6 parameters. Parameters: ctxt' node' attrType' property' inheritable' value
Long Parameter List,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropTypes,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropTypes.cs,GetValue,The method has 5 parameters. Parameters: ctxt' node' attrType' property' inheritable
Long Identifier,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,DefnStyle,The length of the parameter numInstanceFieldsAllSupertypes is 30.
Long Identifier,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,RewriterEnvironment,C:\repos\Reactive-Extensions_IL2JS\Rewriter\RewriterEnvironment.cs,,The length of the parameter AssemblyDelaySignAttributeType is 30.
Long Identifier,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,RewriterEnvironment,C:\repos\Reactive-Extensions_IL2JS\Rewriter\RewriterEnvironment.cs,,The length of the parameter CompilerGeneratedAttributeType is 30.
Long Identifier,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,RewriterEnvironment,C:\repos\Reactive-Extensions_IL2JS\Rewriter\RewriterEnvironment.cs,,The length of the parameter Type_GetGenericArgumentsMethod is 30.
Long Identifier,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,RewriterEnvironment,C:\repos\Reactive-Extensions_IL2JS\Rewriter\RewriterEnvironment.cs,,The length of the parameter InteropContextManager_GetDatabaseMethod is 39.
Long Identifier,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,RewriterEnvironment,C:\repos\Reactive-Extensions_IL2JS\Rewriter\RewriterEnvironment.cs,,The length of the parameter InteropContextManager_GetCurrentRuntimeMethod is 45.
Long Identifier,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,RewriterEnvironment,C:\repos\Reactive-Extensions_IL2JS\Rewriter\RewriterEnvironment.cs,,The length of the parameter InteropContextManager_GetRuntimeForObjectMethod is 47.
Long Identifier,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,RewriterEnvironment,C:\repos\Reactive-Extensions_IL2JS\Rewriter\RewriterEnvironment.cs,,The length of the parameter InteropDatabase_RegisterRootExpression is 38.
Long Identifier,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,RewriterEnvironment,C:\repos\Reactive-Extensions_IL2JS\Rewriter\RewriterEnvironment.cs,,The length of the parameter InteropDatabase_RegisterDelegateShimMethod is 42.
Long Identifier,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,RewriterEnvironment,C:\repos\Reactive-Extensions_IL2JS\Rewriter\RewriterEnvironment.cs,,The length of the parameter InteropDatabase_RegisterTypeMethod is 34.
Long Identifier,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,RewriterEnvironment,C:\repos\Reactive-Extensions_IL2JS\Rewriter\RewriterEnvironment.cs,,The length of the parameter InteropDatabase_RegisterExportMethod is 36.
Long Identifier,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,RewriterEnvironment,C:\repos\Reactive-Extensions_IL2JS\Rewriter\RewriterEnvironment.cs,,The length of the parameter Runtime_CompleteConstructionMethod is 34.
Long Identifier,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,RewriterEnvironment,C:\repos\Reactive-Extensions_IL2JS\Rewriter\RewriterEnvironment.cs,,The length of the parameter Runtime_CallImportedMethodMethod is 32.
Long Identifier,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,RewriterEnvironment,C:\repos\Reactive-Extensions_IL2JS\Rewriter\RewriterEnvironment.cs,,The length of the parameter UniversalDelegate_InvokeMethod is 30.
Long Identifier,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,RewriterEnvironment,C:\repos\Reactive-Extensions_IL2JS\Rewriter\RewriterEnvironment.cs,,The length of the parameter MethodBase_GetGenericArgumentsMethod is 36.
Long Identifier,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropTypes,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropTypes.cs,,The length of the parameter TheRemoveAccessorPrefixProperty is 31.
Long Identifier,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropTypes,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropTypes.cs,,The length of the parameter TheRemoveAccessorUnderscoreProperty is 35.
Long Identifier,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropTypes,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropTypes.cs,,The length of the parameter ThePassInstanceAsArgumentProperty is 33.
Long Identifier,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropTypes,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropTypes.cs,,The length of the parameter TheSimulateMulticastEventsProperty is 34.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,RewriteAssembly,The length of the statement  "                env.Log(new InvalidInteropMessage(RewriterMsgContext.Assembly(assembly)' "Assembly contains interop specification errors")); " is 124.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ProcessType,The length of the statement  "                                         "Cannot create a default importing constructor for type' since it derives from a type with state 'ManagedOnly' which does not contain a default constructor")); " is 159.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ProcessType,The length of the statement  "                                         "Cannot create a default importing constructor for type' since it derives from an instance of a higher-kinded type without an explicit default importing constructor. (This limitation will be removed in the future.)")); " is 218.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ProcessType,The length of the statement  "                                         "Cannot create a default importing constructor for type' since it derives from a type with state 'ManagedAndJavaScript' or 'JavaScriptOnly'' and that type does not contain a default importing constructor")); " is 207.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ProcessType,The length of the statement  "                if (style == InteropStyle.Normal || style == InteropStyle.Primitive || style == InteropStyle.Proxied || style == InteropStyle.Keyed) " is 132.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ProcessMethod,The length of the statement  "                    //     InteropContextManager.Database.RegisterExport(<method base of M>' <bind to instance>' <cature this>' <export script>); " is 125.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,TagAsImport,The length of the statement  "            member.Attributes.Add(env.InteropTypes.InstantiateAttribute(env.ImportAttributeType' new Literal(script' env.StringType))); " is 123.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,RecaseMember,The length of the statement  "            var name = Recase(member.Name.Name' interopTypes.GetValue(ctxt' member' env.NamingAttributeType' interopTypes.TheMemberNameCasingProperty)); " is 140.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,GetterSetterAdderRemoverNameFromMethod,The length of the statement  "                str += Recase(prefix' interopTypes.GetValue(ctxt' method' env.NamingAttributeType' interopTypes.ThePrefixNameCasingProperty)); " is 126.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,GetterSetterAdderRemoverNameFromMethod,The length of the statement  "            str += Recase(name' interopTypes.GetValue(ctxt' method' env.NamingAttributeType' interopTypes.TheMemberNameCasingProperty)); " is 124.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,FinalImportScript,The length of the statement  "            var lastArgIsParamsArray = LastArgIsParamsArray(ctxt' methodDefn) && interopTypes.GetValue(ctxt' methodDefn' env.ImportAttributeType' interopTypes.TheInlineParamsArrayProperty); " is 177.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The length of the statement  "                    var localScript = isOnMethod ? interopTypes.GetValue(ctxt' methodDefn' env.ImportAttributeType' interopTypes.TheScriptProperty' false) : default(JST.Expression); " is 161.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ExportInfo,The length of the statement  "                env.Log(new InvalidInteropMessage(RewriterMsgContext.Member(ctxt' methodDefn)' "polymorphic methods cannot be exported")); " is 122.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ExportInfo,The length of the statement  "                env.Log(new InvalidInteropMessage(RewriterMsgContext.Member(ctxt' methodDefn)' "non-instance methods of higher-kinded types cannot be exported")); " is 146.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ExportInfo,The length of the statement  "                var localScript = isOnMethod ? interopTypes.GetValue(ctxt' methodDefn' env.ExportAttributeType' interopTypes.TheScriptProperty' false) : default(JST.Expression); " is 161.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,DefnStyle,The length of the statement  "                                  ("We assume the {0} non-imported constructors for this type with state 'ManagedAndJavaScript' always throw or chain to an imported constructor"' " is 144.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,DefnStyle,The length of the statement  "                                  ("We assume the {0} non-imported constructors for this type with state 'JavaScriptOnly' always throw or chain to an imported constructor"' " is 138.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,KeyField,The length of the statement  "                        (subCtxt' "default key must be specified for type with state 'ManagedAndJavaScript' without an 'ImportKey' attribute")); " is 120.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropTypes,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropTypes.cs,ParseScript,The length of the statement  "                            env.Log(new InvalidInteropMessage(new MessageContext(ctxt' currIndex.Right.Loc' null)' "Expecting identifier' string or number")); " is 130.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropTypes,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropTypes.cs,ParseScript,The length of the statement  "                env.Log(new InvalidInteropMessage(new MessageContext(ctxt' e.Loc' null)' "syntax error in " + e.Context + ": " + e.Details)); " is 125.
Complex Conditional,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,AssemblyLoader,C:\repos\Reactive-Extensions_IL2JS\Rewriter\AssemblyLoader.cs,CheckTypeDefn,The conditional expression  "typeDefn.DeclaringModule == null || typeDefn.DeclaringModule.ContainingAssembly == null ||                  typeDefn.DeclaringModule.ContainingAssembly != expectedContainingAssembly || typeDefn.Name == null"  is complex.
Complex Conditional,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,RewriteAssembly,The conditional expression  "method != null && method.IsStatic && method.Name.Equals("SetupInterop") &&                      method.Parameters.Count == 0"  is complex.
Complex Conditional,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ProcessType,The conditional expression  "style == InteropStyle.Normal || style == InteropStyle.Primitive || style == InteropStyle.Proxied || style == InteropStyle.Keyed"  is complex.
Complex Conditional,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ExplodeTypeApplication,The conditional expression  "fkType is ArrayType || fkType is Reference || fkType is Pointer || fkType is FunctionPointer ||                  fkType is ClassParameter || fkType is TypeParameter"  is complex.
Complex Conditional,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ExplodeTypeApplication,The conditional expression  "hkType.Template != null || hkType is ArrayType || hkType is Reference || hkType is FunctionPointer ||                  hkType is Pointer || hkType is ClassParameter || hkType is TypeParameter"  is complex.
Complex Conditional,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ExplodeTypeAbstraction,The conditional expression  "hkType is ArrayType || hkType is Reference || hkType is Pointer || hkType is FunctionPointer ||                  hkType is ClassParameter || hkType is TypeParameter"  is complex.
Complex Conditional,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,PrefixName,The conditional expression  "isExport && !isNonInstance && !isProto && qual != Qualification.None"  is complex.
Complex Conditional,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,PrefixName,The conditional expression  "isExport && !isNonInstance && isProto && qual == Qualification.None"  is complex.
Complex Conditional,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,DefnStyle,The conditional expression  "methodDefn is CCI.InstanceInitializer && !IsExtern(methodDefn) &&                              !(methodDefn.Parameters != null && methodDefn.Parameters.Count > 0 &&                                methodDefn.Parameters[0].Type == env.JSContextType)"  is complex.
Complex Conditional,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,DefnStyle,The conditional expression  "style == InteropStyle.Normal && (!typeDefn.IsSealed || !typeDefn.IsAbstract) &&                          numInstanceOrCtorImports + numInstanceExports > 0"  is complex.
Empty Catch Block,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Program,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Program.cs,Main,The method has an empty catch block.
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ProcessMethod,The following statement contains a magic number: try              {                  if (env.InteropManager.IsImported(null' method))                  {                      AddDelegateTypes(accumDelegateTypes' method);                      //  If constructor:                      //      C(A1 a1' A2 a2)                      //  emit:                      //      var ci = typeof(<this type>).GetConstructor(new Type[] { typeof(A1)' typeof(A2) });                      //      var ctxt = (JSContext)InteropContextManager.CurrentRuntime.CallImportedMethod(                      //                                ci'                      //                                <import script>'                      //                                new object[] { this' a1' a2 });                      //      C(ctxt' a1' a2) or C(ctxt);                      //      InteropContextManager.CurrentRuntime.CompleteConstruction(ci' this' ctxt);                      //                      //  If static method:                      //      R C::M(A1 a1' A2 a2)                      //  emit:                      //      return (R)InteropContextManager.CurrentRuntime.CallImportedMethod(                      //                    typeof(<this type>).GetMethod("M"' new Type[] { typeof(A1)' typeof(A2) })'                      //                    <import script>'                      //                    new object[] { a1' a2 });                      //                      //  If instance method:                      //      R C::M(A1 a1' A2 a2)                      //  emit:                      //      return (R)InteropContextManager.GetRuntimeForObject(this).CallImportedMethod(                      //                    typeof(<this type>).GetMethod("M"' new Type[] { typeof(A1)' typeof(A2) })'                      //                    <import script>'                      //                    new object[] { this' a1' a2 });                        var thisExpr = new ThisBinding(ThisExpression(method.DeclaringType)' method.SourceContext);                        var argExprs = new ExpressionList();                      if (!method.IsStatic && !(method is InstanceInitializer))                          argExprs.Add(thisExpr);                      foreach (var p in method.Parameters)                          argExprs.Add                              (BoxExpression(new ParameterBinding(p' method.SourceContext)' env.ObjectType));                      var argArray = ArrayExpression(argExprs' env.ObjectType);                        // Imports are special in a few ways:                      //  - The runtime will never attempt to Invoke the method base. All it needs are the                      //    argument types' static/instance distiction' and method/constructor distinction.                      //  - The call to Runtime::CallImportedMethod will be within the method body                      //    itself. If the method is polymorphic' and/or within a higher-kinded type' then                      //    typeof(<argument type>) will yield the correct runtime type for the argument' taking                      //    account of all type instantiation. We don't need to know the type arguments themselves.                      //  - Private methods may be imported' however Silverlight doesn't provide reflection for                      //    private methods.                      // For these reasons we build our own simple-minded method base literal to support the                      // CallImportedMethod call.                      var methodBaseExpr = SimpleMethodBaseExpression(method);                        var runtimeExpr = default(Expression);                      if (method.IsStatic || method is InstanceInitializer)                          runtimeExpr = new MethodCall                              (new MemberBinding(null' env.InteropContextManager_GetCurrentRuntimeMethod)'                               new ExpressionList(0));                      else                          runtimeExpr = new MethodCall                              (new MemberBinding(null' env.InteropContextManager_GetRuntimeForObjectMethod)'                               new ExpressionList(thisExpr));                        var si = env.InteropManager.ImportInfo(null' env.GenSym' new JST.Identifier(env.Root)' method);                      var scriptString = si.Script.ToString(false);                      env.Log(new InteropInfoMessage(RewriterMsgContext.Method(method)' "Imported as: " + scriptString));                      var scriptExpr = new Literal(scriptString' env.StringType);                        var statements = method.Body.Statements;                      var ctor = method as InstanceInitializer;                      if (ctor != null)                      {                          var locals = ctor.LocalList;                          if (locals == null)                          {                              locals = new LocalList(2);                              ctor.LocalList = locals;                          }                          var constructorInfoLocal = new Local(Identifier.For("ci")' env.SimpleMethodBaseType);                          locals.Add(constructorInfoLocal);                          var contextLocal = new Local(Identifier.For("ctxt")' env.JSContextType);                          locals.Add(contextLocal);                          statements.Add                              (new AssignmentStatement                                   (new LocalBinding(constructorInfoLocal' ctor.SourceContext)' methodBaseExpr));                          statements.Add                              (new AssignmentStatement                                   (new LocalBinding(contextLocal' ctor.SourceContext)'                                    CastExpression                                        (new MethodCall                                             (new MemberBinding                                                  (runtimeExpr' env.Runtime_CallImportedMethodMethod)'                                              new ExpressionList                                                  (new LocalBinding(constructorInfoLocal' ctor.SourceContext)'                                                   scriptExpr'                                                   argArray))'                                         env.JSContextType)));                          var importingCtor = BestImportingConstructor(ctor);                          var args = new ExpressionList(importingCtor.Parameters.Count);                          args.Add(new LocalBinding(contextLocal' ctor.SourceContext));                          if (importingCtor.Parameters.Count > 1)                          {                              for (var i = 0; i < ctor.Parameters.Count; i++)                                  args.Add(new ParameterBinding(ctor.Parameters[i]' ctor.SourceContext));                          }                          statements.Add                              (new ExpressionStatement                                   (new MethodCall(new MemberBinding(thisExpr' importingCtor)' args)));                          statements.Add                              (new ExpressionStatement                                   (new MethodCall                                        (new MemberBinding(runtimeExpr' env.Runtime_CompleteConstructionMethod)'                                         new ExpressionList                                             (new LocalBinding(constructorInfoLocal' ctor.SourceContext)'                                              thisExpr'                                              new LocalBinding(contextLocal' ctor.SourceContext)))));                          statements.Add(new Return());                      }                      else if (method.ReturnType == env.VoidType)                      {                          statements.Add                              (new ExpressionStatement                                   (new MethodCall                                        (new MemberBinding(runtimeExpr' env.Runtime_CallImportedMethodMethod)'                                         new ExpressionList(methodBaseExpr' scriptExpr' argArray))));                          statements.Add(new ExpressionStatement(new UnaryExpression(null' NodeType.Pop)));                          statements.Add(new Return());                      }                      else                      {                          statements.Add                              (new Return                                   (CastExpression                                        (new MethodCall                                             (new MemberBinding                                                  (runtimeExpr' env.Runtime_CallImportedMethodMethod)'                                              new ExpressionList(methodBaseExpr' scriptExpr' argArray))'                                         method.ReturnType)));                      }                        TagAsInteropGenerated(method);                  }                    if (env.InteropManager.IsExported(null' method))                  {                      AddDelegateTypes(accumDelegateTypes' method);                      // For each exported method' append to <Module>::SetupInterop()                      //     InteropContextManager.Database.RegisterExport(<method base of M>' <bind to instance>' <cature this>' <export script>);                        // Exports are special in a few ways:                      //  - Polymorphic methods cannot be exported' so we never need to deal with them.                      //  - The call to Runtime::RegisterExportMethod is outside of the method itself. For instance                      //    methods' the declaring type may be higher-kinded' in which case we must recover the                      //    type arguments from the type of the instance at runtime. Thus at compile-time we                      //    must describe the method in it's higher-kinded declaring type.                      //  - The runtime needs to be able to Invoke the method base.                      // Thus we are forced to use true MethodBase' MethodInfo and ConstructorInfo' and work-around                      // limitations of reflection.                      var si = env.InteropManager.ExportInfo(null' env.GenSym' new JST.Identifier(env.Root)' method);                      var scriptString = si.Script.ToString(false);                      env.Log(new InteropInfoMessage(RewriterMsgContext.Method(method)' "Exported as: " + scriptString));                      setupInteropStatements.Add                          (new ExpressionStatement                               (new MethodCall                                    (new MemberBinding                                         (DatabaseExpression()' env.InteropDatabase_RegisterExportMethod)'                                     new ExpressionList                                         (MethodBaseExpression(method)'                                          new Literal(si.BindToInstance' env.BooleanType)'                                          new Literal(scriptString' env.StringType)))));                  }              }              catch (DefinitionException)              {                  env.Log(new InvalidInteropMessage(RewriterMsgContext.Method(method)' "Method contains interop specification errors"));              }
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ShimFullName,The following statement contains a magic number: if (match.Success)              {                  prefix = match.Groups[1].Value;                  suffix = match.Groups[2].Value;              }              else              {                  prefix = delegateFullName;                  suffix = "";              }
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The following statement contains a magic number: if (methodDefn is CCI.InstanceInitializer)              {                  // XREF1171                  // Constructor                  if (script == null)                  {                      switch (                          interopTypes.GetValue                              (ctxt' methodDefn' env.ImportAttributeType' interopTypes.TheCreationProperty))                      {                          case Creation.Constructor:                              script = PrefixName(ctxt' methodDefn' null' false);                              break;                          case Creation.Object:                              if (methodArity > 0)                              {                                  env.Log(new InvalidInteropMessage                                      (RewriterMsgContext.Method(ctxt' methodDefn)'                                       "imported constructors for object literals cannot have arguments"));                                  throw new DefinitionException();                              }                              script = Constants.Object.ToE();                              break;                          case Creation.Array:                              script = Constants.Array.ToE();                              break;                          default:                              throw new ArgumentOutOfRangeException();                      }                      return FinalImportScript(ctxt' gensym' rootId' methodDefn' script' true);                  }                  else if (script is JST.FunctionExpression)                      return FinalImportScript(ctxt' gensym' rootId' methodDefn' script' false);                  else                  {                      script = PrefixName(ctxt' methodDefn' script' false);                      return FinalImportScript(ctxt' gensym' rootId' methodDefn' script' true);                  }              }              else              {                  if (methodDefn.DeclaringMember != null)                  {                      var isOnMethod = interopTypes.HasAttribute(methodDefn' env.ImportAttributeType' false);                      var localScript = isOnMethod ? interopTypes.GetValue(ctxt' methodDefn' env.ImportAttributeType' interopTypes.TheScriptProperty' false) : default(JST.Expression);                        var prop = methodDefn.DeclaringMember as CCI.Property;                      if (prop != null)                      {                          // XREF1187                          if (methodDefn == prop.Getter)                          {                              // Getter                              if (isOnMethod)                              {                                  script = PrefixName                                      (ctxt'                                       methodDefn'                                       GetterSetterAdderRemoverNameFromMethod(ctxt' methodDefn' "get"' localScript)' false);                                  return FinalImportScript(ctxt' gensym' rootId' methodDefn' script' false);                              }                              else if (script != null && script is JST.FunctionExpression)                              {                                  env.Log(new InvalidInteropMessage                                      (RewriterMsgContext.Method(ctxt' methodDefn)'                                       "property import script cannot be a function"));                                  throw new DefinitionException();                              }                              else                              {                                  var function = default(JST.FunctionExpression);                                  if (gensym != null)                                  {                                      var parameters = new Seq<JST.Identifier>();                                      var body = new Seq<JST.Statement>();                                        for (var i = 0; i < methodArity; i++)                                          parameters.Add(gensym());                                      if (script == null && methodArity == 2 && !methodDefn.IsStatic)                                          body.Add                                              (new JST.ReturnStatement                                                   (new JST.IndexExpression                                                        (parameters[0].ToE()' parameters[1].ToE())));                                      else                                      {                                          script = PrefixName                                              (ctxt' methodDefn' RecasePropertyEvent(ctxt' methodDefn' script)' false);                                          if (methodDefn.IsStatic && methodArity == 0)                                              body.Add(new JST.ReturnStatement(script));                                          else if (!methodDefn.IsStatic && methodArity == 1)                                              body.Add                                                  (new JST.ReturnStatement                                                       (JST.Expression.Dot                                                            (parameters[0].ToE()'                                                             JST.Expression.ExplodePath(script))));                                          else                                          {                                              env.Log(new InvalidInteropMessage                                                  (RewriterMsgContext.Method(ctxt' methodDefn)'                                                   "additional getter parameters not supported for default getters"));                                              throw new DefinitionException();                                          }                                      }                                      function = new JST.FunctionExpression(parameters' new JST.Statements(body));                                  }                                  return new ImportMethodInfo { MethodDefn = methodDefn' Script = function };                              }                          }                          else if (methodDefn == prop.Setter)                          {                              // Setter                              if (isOnMethod)                              {                                  script = PrefixName                                      (ctxt'                                       methodDefn'                                       GetterSetterAdderRemoverNameFromMethod(ctxt' methodDefn' "set"' localScript)' false);                                  return FinalImportScript(ctxt' gensym' rootId' methodDefn' script' false);                              }                              else if (script != null && script is JST.FunctionExpression)                              {                                  env.Log(new InvalidInteropMessage                                      (RewriterMsgContext.Method(ctxt' methodDefn)'                                       "property import script cannot be a function"));                                  throw new DefinitionException();                              }                              else                              {                                  var function = default(JST.FunctionExpression);                                  if (gensym != null)                                  {                                      var parameters = new Seq<JST.Identifier>();                                      var body = new Seq<JST.Statement>();                                        for (var i = 0; i < methodArity; i++)                                          parameters.Add(gensym());                                      if (script == null && methodArity == 3 && !methodDefn.IsStatic)                                          body.Add                                              (JST.Statement.IndexAssignment                                                   (parameters[0].ToE()'                                                    parameters[1].ToE()'                                                    parameters[2].ToE()));                                      else                                      {                                          script = PrefixName                                              (ctxt' methodDefn' RecasePropertyEvent(ctxt' methodDefn' script)' false);                                          if (methodDefn.IsStatic && methodArity == 1)                                              body.Add                                                  (JST.Statement.Assignment(script' parameters[0].ToE()));                                          else if (!methodDefn.IsStatic && methodArity == 2)                                              body.Add                                                  (JST.Statement.Assignment                                                       (JST.Expression.Dot                                                            (parameters[0].ToE()'                                                             JST.Expression.ExplodePath(script))'                                                        parameters[1].ToE()));                                          else                                          {                                              env.Log(new InvalidInteropMessage                                                  (RewriterMsgContext.Method(ctxt' methodDefn)'                                                   "additional setter parameters not supported for default setters"));                                              throw new DefinitionException();                                          }                                      }                                      function = new JST.FunctionExpression(parameters' new JST.Statements(body));                                  }                                  return new ImportMethodInfo { MethodDefn = methodDefn' Script = function };                              }                          }                          else                              throw new InvalidOperationException();                      }                      else                      {                          var evnt = methodDefn.DeclaringMember as CCI.Event;                          if (evnt != null)                          {                              // XREF1201                              if (methodDefn == evnt.HandlerAdder)                              {                                  // Adder                                  if (isOnMethod)                                  {                                      script = PrefixName                                          (ctxt'                                           methodDefn'                                           GetterSetterAdderRemoverNameFromMethod(ctxt' methodDefn' "add"' localScript)' false);                                      return FinalImportScript(ctxt' gensym' rootId' methodDefn' script' false);                                  }                                  else if (script != null && script is JST.FunctionExpression)                                  {                                      env.Log(new InvalidInteropMessage                                          (RewriterMsgContext.Method(ctxt' methodDefn)'                                           "event import script cannot be a function"));                                      throw new DefinitionException();                                  }                                  else                                  {                                      var function = default(JST.FunctionExpression);                                      if (gensym != null)                                      {                                          var parameters = new Seq<JST.Identifier>();                                          var body = new Seq<JST.Statement>();                                            for (var i = 0; i < methodArity; i++)                                              parameters.Add(gensym());                                          script = PrefixName                                              (ctxt' methodDefn' RecasePropertyEvent(ctxt' methodDefn' script)' false);                                          if (methodDefn.IsStatic)                                              body.Add                                                  (JST.Statement.Assignment(script' parameters[0].ToE()));                                          else                                              body.Add                                                  (JST.Statement.Assignment                                                       (JST.Expression.Dot                                                            (parameters[0].ToE()'                                                             JST.Expression.ExplodePath(script))'                                                        parameters[1].ToE()));                                          function = new JST.FunctionExpression(parameters' new JST.Statements(body));                                      }                                      return new ImportMethodInfo { MethodDefn = methodDefn' Script = function };                                  }                              }                              else if (methodDefn == evnt.HandlerRemover)                              {                                  // Remover                                  if (isOnMethod)                                  {                                      script = PrefixName                                          (ctxt'                                           methodDefn'                                           GetterSetterAdderRemoverNameFromMethod(ctxt' methodDefn' "remove"' localScript)' false);                                      return FinalImportScript(ctxt' gensym' rootId' methodDefn' script' false);                                  }                                  else if (script != null && script is JST.FunctionExpression)                                  {                                      env.Log(new InvalidInteropMessage                                          (RewriterMsgContext.Method(ctxt' methodDefn)'                                           "event import script cannot be a function"));                                      throw new DefinitionException();                                  }                                  else                                  {                                      var function = default(JST.FunctionExpression);                                      if (gensym != null)                                      {                                          var parameters = new Seq<JST.Identifier>();                                          var body = new Seq<JST.Statement>();                                            for (var i = 0; i < methodArity; i++)                                              parameters.Add(gensym());                                          script = PrefixName                                              (ctxt' methodDefn' RecasePropertyEvent(ctxt' methodDefn' script)' false);                                          if (methodDefn.IsStatic)                                              body.Add                                                  (JST.Statement.Assignment(script' parameters[0].ToE()));                                          else                                              body.Add                                                  (JST.Statement.Assignment                                                       (JST.Expression.Dot                                                            (parameters[0].ToE()'                                                             JST.Expression.ExplodePath(script))'                                                        parameters[1].ToE()));                                            function = new JST.FunctionExpression(parameters' new JST.Statements(body));                                      }                                      return new ImportMethodInfo { MethodDefn = methodDefn' Script = function };                                  }                              }                              else                                  throw new InvalidOperationException();                          }                          else                              throw new InvalidOperationException();                      }                  }                  else                  {                      // XREF1153                      // Normal method                      script = PrefixName(ctxt' methodDefn' RecaseMember(ctxt' methodDefn' script)' false);                      return FinalImportScript(ctxt' gensym' rootId' methodDefn' script' false);                  }              }
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The following statement contains a magic number: if (methodDefn is CCI.InstanceInitializer)              {                  // XREF1171                  // Constructor                  if (script == null)                  {                      switch (                          interopTypes.GetValue                              (ctxt' methodDefn' env.ImportAttributeType' interopTypes.TheCreationProperty))                      {                          case Creation.Constructor:                              script = PrefixName(ctxt' methodDefn' null' false);                              break;                          case Creation.Object:                              if (methodArity > 0)                              {                                  env.Log(new InvalidInteropMessage                                      (RewriterMsgContext.Method(ctxt' methodDefn)'                                       "imported constructors for object literals cannot have arguments"));                                  throw new DefinitionException();                              }                              script = Constants.Object.ToE();                              break;                          case Creation.Array:                              script = Constants.Array.ToE();                              break;                          default:                              throw new ArgumentOutOfRangeException();                      }                      return FinalImportScript(ctxt' gensym' rootId' methodDefn' script' true);                  }                  else if (script is JST.FunctionExpression)                      return FinalImportScript(ctxt' gensym' rootId' methodDefn' script' false);                  else                  {                      script = PrefixName(ctxt' methodDefn' script' false);                      return FinalImportScript(ctxt' gensym' rootId' methodDefn' script' true);                  }              }              else              {                  if (methodDefn.DeclaringMember != null)                  {                      var isOnMethod = interopTypes.HasAttribute(methodDefn' env.ImportAttributeType' false);                      var localScript = isOnMethod ? interopTypes.GetValue(ctxt' methodDefn' env.ImportAttributeType' interopTypes.TheScriptProperty' false) : default(JST.Expression);                        var prop = methodDefn.DeclaringMember as CCI.Property;                      if (prop != null)                      {                          // XREF1187                          if (methodDefn == prop.Getter)                          {                              // Getter                              if (isOnMethod)                              {                                  script = PrefixName                                      (ctxt'                                       methodDefn'                                       GetterSetterAdderRemoverNameFromMethod(ctxt' methodDefn' "get"' localScript)' false);                                  return FinalImportScript(ctxt' gensym' rootId' methodDefn' script' false);                              }                              else if (script != null && script is JST.FunctionExpression)                              {                                  env.Log(new InvalidInteropMessage                                      (RewriterMsgContext.Method(ctxt' methodDefn)'                                       "property import script cannot be a function"));                                  throw new DefinitionException();                              }                              else                              {                                  var function = default(JST.FunctionExpression);                                  if (gensym != null)                                  {                                      var parameters = new Seq<JST.Identifier>();                                      var body = new Seq<JST.Statement>();                                        for (var i = 0; i < methodArity; i++)                                          parameters.Add(gensym());                                      if (script == null && methodArity == 2 && !methodDefn.IsStatic)                                          body.Add                                              (new JST.ReturnStatement                                                   (new JST.IndexExpression                                                        (parameters[0].ToE()' parameters[1].ToE())));                                      else                                      {                                          script = PrefixName                                              (ctxt' methodDefn' RecasePropertyEvent(ctxt' methodDefn' script)' false);                                          if (methodDefn.IsStatic && methodArity == 0)                                              body.Add(new JST.ReturnStatement(script));                                          else if (!methodDefn.IsStatic && methodArity == 1)                                              body.Add                                                  (new JST.ReturnStatement                                                       (JST.Expression.Dot                                                            (parameters[0].ToE()'                                                             JST.Expression.ExplodePath(script))));                                          else                                          {                                              env.Log(new InvalidInteropMessage                                                  (RewriterMsgContext.Method(ctxt' methodDefn)'                                                   "additional getter parameters not supported for default getters"));                                              throw new DefinitionException();                                          }                                      }                                      function = new JST.FunctionExpression(parameters' new JST.Statements(body));                                  }                                  return new ImportMethodInfo { MethodDefn = methodDefn' Script = function };                              }                          }                          else if (methodDefn == prop.Setter)                          {                              // Setter                              if (isOnMethod)                              {                                  script = PrefixName                                      (ctxt'                                       methodDefn'                                       GetterSetterAdderRemoverNameFromMethod(ctxt' methodDefn' "set"' localScript)' false);                                  return FinalImportScript(ctxt' gensym' rootId' methodDefn' script' false);                              }                              else if (script != null && script is JST.FunctionExpression)                              {                                  env.Log(new InvalidInteropMessage                                      (RewriterMsgContext.Method(ctxt' methodDefn)'                                       "property import script cannot be a function"));                                  throw new DefinitionException();                              }                              else                              {                                  var function = default(JST.FunctionExpression);                                  if (gensym != null)                                  {                                      var parameters = new Seq<JST.Identifier>();                                      var body = new Seq<JST.Statement>();                                        for (var i = 0; i < methodArity; i++)                                          parameters.Add(gensym());                                      if (script == null && methodArity == 3 && !methodDefn.IsStatic)                                          body.Add                                              (JST.Statement.IndexAssignment                                                   (parameters[0].ToE()'                                                    parameters[1].ToE()'                                                    parameters[2].ToE()));                                      else                                      {                                          script = PrefixName                                              (ctxt' methodDefn' RecasePropertyEvent(ctxt' methodDefn' script)' false);                                          if (methodDefn.IsStatic && methodArity == 1)                                              body.Add                                                  (JST.Statement.Assignment(script' parameters[0].ToE()));                                          else if (!methodDefn.IsStatic && methodArity == 2)                                              body.Add                                                  (JST.Statement.Assignment                                                       (JST.Expression.Dot                                                            (parameters[0].ToE()'                                                             JST.Expression.ExplodePath(script))'                                                        parameters[1].ToE()));                                          else                                          {                                              env.Log(new InvalidInteropMessage                                                  (RewriterMsgContext.Method(ctxt' methodDefn)'                                                   "additional setter parameters not supported for default setters"));                                              throw new DefinitionException();                                          }                                      }                                      function = new JST.FunctionExpression(parameters' new JST.Statements(body));                                  }                                  return new ImportMethodInfo { MethodDefn = methodDefn' Script = function };                              }                          }                          else                              throw new InvalidOperationException();                      }                      else                      {                          var evnt = methodDefn.DeclaringMember as CCI.Event;                          if (evnt != null)                          {                              // XREF1201                              if (methodDefn == evnt.HandlerAdder)                              {                                  // Adder                                  if (isOnMethod)                                  {                                      script = PrefixName                                          (ctxt'                                           methodDefn'                                           GetterSetterAdderRemoverNameFromMethod(ctxt' methodDefn' "add"' localScript)' false);                                      return FinalImportScript(ctxt' gensym' rootId' methodDefn' script' false);                                  }                                  else if (script != null && script is JST.FunctionExpression)                                  {                                      env.Log(new InvalidInteropMessage                                          (RewriterMsgContext.Method(ctxt' methodDefn)'                                           "event import script cannot be a function"));                                      throw new DefinitionException();                                  }                                  else                                  {                                      var function = default(JST.FunctionExpression);                                      if (gensym != null)                                      {                                          var parameters = new Seq<JST.Identifier>();                                          var body = new Seq<JST.Statement>();                                            for (var i = 0; i < methodArity; i++)                                              parameters.Add(gensym());                                          script = PrefixName                                              (ctxt' methodDefn' RecasePropertyEvent(ctxt' methodDefn' script)' false);                                          if (methodDefn.IsStatic)                                              body.Add                                                  (JST.Statement.Assignment(script' parameters[0].ToE()));                                          else                                              body.Add                                                  (JST.Statement.Assignment                                                       (JST.Expression.Dot                                                            (parameters[0].ToE()'                                                             JST.Expression.ExplodePath(script))'                                                        parameters[1].ToE()));                                          function = new JST.FunctionExpression(parameters' new JST.Statements(body));                                      }                                      return new ImportMethodInfo { MethodDefn = methodDefn' Script = function };                                  }                              }                              else if (methodDefn == evnt.HandlerRemover)                              {                                  // Remover                                  if (isOnMethod)                                  {                                      script = PrefixName                                          (ctxt'                                           methodDefn'                                           GetterSetterAdderRemoverNameFromMethod(ctxt' methodDefn' "remove"' localScript)' false);                                      return FinalImportScript(ctxt' gensym' rootId' methodDefn' script' false);                                  }                                  else if (script != null && script is JST.FunctionExpression)                                  {                                      env.Log(new InvalidInteropMessage                                          (RewriterMsgContext.Method(ctxt' methodDefn)'                                           "event import script cannot be a function"));                                      throw new DefinitionException();                                  }                                  else                                  {                                      var function = default(JST.FunctionExpression);                                      if (gensym != null)                                      {                                          var parameters = new Seq<JST.Identifier>();                                          var body = new Seq<JST.Statement>();                                            for (var i = 0; i < methodArity; i++)                                              parameters.Add(gensym());                                          script = PrefixName                                              (ctxt' methodDefn' RecasePropertyEvent(ctxt' methodDefn' script)' false);                                          if (methodDefn.IsStatic)                                              body.Add                                                  (JST.Statement.Assignment(script' parameters[0].ToE()));                                          else                                              body.Add                                                  (JST.Statement.Assignment                                                       (JST.Expression.Dot                                                            (parameters[0].ToE()'                                                             JST.Expression.ExplodePath(script))'                                                        parameters[1].ToE()));                                            function = new JST.FunctionExpression(parameters' new JST.Statements(body));                                      }                                      return new ImportMethodInfo { MethodDefn = methodDefn' Script = function };                                  }                              }                              else                                  throw new InvalidOperationException();                          }                          else                              throw new InvalidOperationException();                      }                  }                  else                  {                      // XREF1153                      // Normal method                      script = PrefixName(ctxt' methodDefn' RecaseMember(ctxt' methodDefn' script)' false);                      return FinalImportScript(ctxt' gensym' rootId' methodDefn' script' false);                  }              }
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The following statement contains a magic number: if (methodDefn is CCI.InstanceInitializer)              {                  // XREF1171                  // Constructor                  if (script == null)                  {                      switch (                          interopTypes.GetValue                              (ctxt' methodDefn' env.ImportAttributeType' interopTypes.TheCreationProperty))                      {                          case Creation.Constructor:                              script = PrefixName(ctxt' methodDefn' null' false);                              break;                          case Creation.Object:                              if (methodArity > 0)                              {                                  env.Log(new InvalidInteropMessage                                      (RewriterMsgContext.Method(ctxt' methodDefn)'                                       "imported constructors for object literals cannot have arguments"));                                  throw new DefinitionException();                              }                              script = Constants.Object.ToE();                              break;                          case Creation.Array:                              script = Constants.Array.ToE();                              break;                          default:                              throw new ArgumentOutOfRangeException();                      }                      return FinalImportScript(ctxt' gensym' rootId' methodDefn' script' true);                  }                  else if (script is JST.FunctionExpression)                      return FinalImportScript(ctxt' gensym' rootId' methodDefn' script' false);                  else                  {                      script = PrefixName(ctxt' methodDefn' script' false);                      return FinalImportScript(ctxt' gensym' rootId' methodDefn' script' true);                  }              }              else              {                  if (methodDefn.DeclaringMember != null)                  {                      var isOnMethod = interopTypes.HasAttribute(methodDefn' env.ImportAttributeType' false);                      var localScript = isOnMethod ? interopTypes.GetValue(ctxt' methodDefn' env.ImportAttributeType' interopTypes.TheScriptProperty' false) : default(JST.Expression);                        var prop = methodDefn.DeclaringMember as CCI.Property;                      if (prop != null)                      {                          // XREF1187                          if (methodDefn == prop.Getter)                          {                              // Getter                              if (isOnMethod)                              {                                  script = PrefixName                                      (ctxt'                                       methodDefn'                                       GetterSetterAdderRemoverNameFromMethod(ctxt' methodDefn' "get"' localScript)' false);                                  return FinalImportScript(ctxt' gensym' rootId' methodDefn' script' false);                              }                              else if (script != null && script is JST.FunctionExpression)                              {                                  env.Log(new InvalidInteropMessage                                      (RewriterMsgContext.Method(ctxt' methodDefn)'                                       "property import script cannot be a function"));                                  throw new DefinitionException();                              }                              else                              {                                  var function = default(JST.FunctionExpression);                                  if (gensym != null)                                  {                                      var parameters = new Seq<JST.Identifier>();                                      var body = new Seq<JST.Statement>();                                        for (var i = 0; i < methodArity; i++)                                          parameters.Add(gensym());                                      if (script == null && methodArity == 2 && !methodDefn.IsStatic)                                          body.Add                                              (new JST.ReturnStatement                                                   (new JST.IndexExpression                                                        (parameters[0].ToE()' parameters[1].ToE())));                                      else                                      {                                          script = PrefixName                                              (ctxt' methodDefn' RecasePropertyEvent(ctxt' methodDefn' script)' false);                                          if (methodDefn.IsStatic && methodArity == 0)                                              body.Add(new JST.ReturnStatement(script));                                          else if (!methodDefn.IsStatic && methodArity == 1)                                              body.Add                                                  (new JST.ReturnStatement                                                       (JST.Expression.Dot                                                            (parameters[0].ToE()'                                                             JST.Expression.ExplodePath(script))));                                          else                                          {                                              env.Log(new InvalidInteropMessage                                                  (RewriterMsgContext.Method(ctxt' methodDefn)'                                                   "additional getter parameters not supported for default getters"));                                              throw new DefinitionException();                                          }                                      }                                      function = new JST.FunctionExpression(parameters' new JST.Statements(body));                                  }                                  return new ImportMethodInfo { MethodDefn = methodDefn' Script = function };                              }                          }                          else if (methodDefn == prop.Setter)                          {                              // Setter                              if (isOnMethod)                              {                                  script = PrefixName                                      (ctxt'                                       methodDefn'                                       GetterSetterAdderRemoverNameFromMethod(ctxt' methodDefn' "set"' localScript)' false);                                  return FinalImportScript(ctxt' gensym' rootId' methodDefn' script' false);                              }                              else if (script != null && script is JST.FunctionExpression)                              {                                  env.Log(new InvalidInteropMessage                                      (RewriterMsgContext.Method(ctxt' methodDefn)'                                       "property import script cannot be a function"));                                  throw new DefinitionException();                              }                              else                              {                                  var function = default(JST.FunctionExpression);                                  if (gensym != null)                                  {                                      var parameters = new Seq<JST.Identifier>();                                      var body = new Seq<JST.Statement>();                                        for (var i = 0; i < methodArity; i++)                                          parameters.Add(gensym());                                      if (script == null && methodArity == 3 && !methodDefn.IsStatic)                                          body.Add                                              (JST.Statement.IndexAssignment                                                   (parameters[0].ToE()'                                                    parameters[1].ToE()'                                                    parameters[2].ToE()));                                      else                                      {                                          script = PrefixName                                              (ctxt' methodDefn' RecasePropertyEvent(ctxt' methodDefn' script)' false);                                          if (methodDefn.IsStatic && methodArity == 1)                                              body.Add                                                  (JST.Statement.Assignment(script' parameters[0].ToE()));                                          else if (!methodDefn.IsStatic && methodArity == 2)                                              body.Add                                                  (JST.Statement.Assignment                                                       (JST.Expression.Dot                                                            (parameters[0].ToE()'                                                             JST.Expression.ExplodePath(script))'                                                        parameters[1].ToE()));                                          else                                          {                                              env.Log(new InvalidInteropMessage                                                  (RewriterMsgContext.Method(ctxt' methodDefn)'                                                   "additional setter parameters not supported for default setters"));                                              throw new DefinitionException();                                          }                                      }                                      function = new JST.FunctionExpression(parameters' new JST.Statements(body));                                  }                                  return new ImportMethodInfo { MethodDefn = methodDefn' Script = function };                              }                          }                          else                              throw new InvalidOperationException();                      }                      else                      {                          var evnt = methodDefn.DeclaringMember as CCI.Event;                          if (evnt != null)                          {                              // XREF1201                              if (methodDefn == evnt.HandlerAdder)                              {                                  // Adder                                  if (isOnMethod)                                  {                                      script = PrefixName                                          (ctxt'                                           methodDefn'                                           GetterSetterAdderRemoverNameFromMethod(ctxt' methodDefn' "add"' localScript)' false);                                      return FinalImportScript(ctxt' gensym' rootId' methodDefn' script' false);                                  }                                  else if (script != null && script is JST.FunctionExpression)                                  {                                      env.Log(new InvalidInteropMessage                                          (RewriterMsgContext.Method(ctxt' methodDefn)'                                           "event import script cannot be a function"));                                      throw new DefinitionException();                                  }                                  else                                  {                                      var function = default(JST.FunctionExpression);                                      if (gensym != null)                                      {                                          var parameters = new Seq<JST.Identifier>();                                          var body = new Seq<JST.Statement>();                                            for (var i = 0; i < methodArity; i++)                                              parameters.Add(gensym());                                          script = PrefixName                                              (ctxt' methodDefn' RecasePropertyEvent(ctxt' methodDefn' script)' false);                                          if (methodDefn.IsStatic)                                              body.Add                                                  (JST.Statement.Assignment(script' parameters[0].ToE()));                                          else                                              body.Add                                                  (JST.Statement.Assignment                                                       (JST.Expression.Dot                                                            (parameters[0].ToE()'                                                             JST.Expression.ExplodePath(script))'                                                        parameters[1].ToE()));                                          function = new JST.FunctionExpression(parameters' new JST.Statements(body));                                      }                                      return new ImportMethodInfo { MethodDefn = methodDefn' Script = function };                                  }                              }                              else if (methodDefn == evnt.HandlerRemover)                              {                                  // Remover                                  if (isOnMethod)                                  {                                      script = PrefixName                                          (ctxt'                                           methodDefn'                                           GetterSetterAdderRemoverNameFromMethod(ctxt' methodDefn' "remove"' localScript)' false);                                      return FinalImportScript(ctxt' gensym' rootId' methodDefn' script' false);                                  }                                  else if (script != null && script is JST.FunctionExpression)                                  {                                      env.Log(new InvalidInteropMessage                                          (RewriterMsgContext.Method(ctxt' methodDefn)'                                           "event import script cannot be a function"));                                      throw new DefinitionException();                                  }                                  else                                  {                                      var function = default(JST.FunctionExpression);                                      if (gensym != null)                                      {                                          var parameters = new Seq<JST.Identifier>();                                          var body = new Seq<JST.Statement>();                                            for (var i = 0; i < methodArity; i++)                                              parameters.Add(gensym());                                          script = PrefixName                                              (ctxt' methodDefn' RecasePropertyEvent(ctxt' methodDefn' script)' false);                                          if (methodDefn.IsStatic)                                              body.Add                                                  (JST.Statement.Assignment(script' parameters[0].ToE()));                                          else                                              body.Add                                                  (JST.Statement.Assignment                                                       (JST.Expression.Dot                                                            (parameters[0].ToE()'                                                             JST.Expression.ExplodePath(script))'                                                        parameters[1].ToE()));                                            function = new JST.FunctionExpression(parameters' new JST.Statements(body));                                      }                                      return new ImportMethodInfo { MethodDefn = methodDefn' Script = function };                                  }                              }                              else                                  throw new InvalidOperationException();                          }                          else                              throw new InvalidOperationException();                      }                  }                  else                  {                      // XREF1153                      // Normal method                      script = PrefixName(ctxt' methodDefn' RecaseMember(ctxt' methodDefn' script)' false);                      return FinalImportScript(ctxt' gensym' rootId' methodDefn' script' false);                  }              }
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The following statement contains a magic number: if (methodDefn is CCI.InstanceInitializer)              {                  // XREF1171                  // Constructor                  if (script == null)                  {                      switch (                          interopTypes.GetValue                              (ctxt' methodDefn' env.ImportAttributeType' interopTypes.TheCreationProperty))                      {                          case Creation.Constructor:                              script = PrefixName(ctxt' methodDefn' null' false);                              break;                          case Creation.Object:                              if (methodArity > 0)                              {                                  env.Log(new InvalidInteropMessage                                      (RewriterMsgContext.Method(ctxt' methodDefn)'                                       "imported constructors for object literals cannot have arguments"));                                  throw new DefinitionException();                              }                              script = Constants.Object.ToE();                              break;                          case Creation.Array:                              script = Constants.Array.ToE();                              break;                          default:                              throw new ArgumentOutOfRangeException();                      }                      return FinalImportScript(ctxt' gensym' rootId' methodDefn' script' true);                  }                  else if (script is JST.FunctionExpression)                      return FinalImportScript(ctxt' gensym' rootId' methodDefn' script' false);                  else                  {                      script = PrefixName(ctxt' methodDefn' script' false);                      return FinalImportScript(ctxt' gensym' rootId' methodDefn' script' true);                  }              }              else              {                  if (methodDefn.DeclaringMember != null)                  {                      var isOnMethod = interopTypes.HasAttribute(methodDefn' env.ImportAttributeType' false);                      var localScript = isOnMethod ? interopTypes.GetValue(ctxt' methodDefn' env.ImportAttributeType' interopTypes.TheScriptProperty' false) : default(JST.Expression);                        var prop = methodDefn.DeclaringMember as CCI.Property;                      if (prop != null)                      {                          // XREF1187                          if (methodDefn == prop.Getter)                          {                              // Getter                              if (isOnMethod)                              {                                  script = PrefixName                                      (ctxt'                                       methodDefn'                                       GetterSetterAdderRemoverNameFromMethod(ctxt' methodDefn' "get"' localScript)' false);                                  return FinalImportScript(ctxt' gensym' rootId' methodDefn' script' false);                              }                              else if (script != null && script is JST.FunctionExpression)                              {                                  env.Log(new InvalidInteropMessage                                      (RewriterMsgContext.Method(ctxt' methodDefn)'                                       "property import script cannot be a function"));                                  throw new DefinitionException();                              }                              else                              {                                  var function = default(JST.FunctionExpression);                                  if (gensym != null)                                  {                                      var parameters = new Seq<JST.Identifier>();                                      var body = new Seq<JST.Statement>();                                        for (var i = 0; i < methodArity; i++)                                          parameters.Add(gensym());                                      if (script == null && methodArity == 2 && !methodDefn.IsStatic)                                          body.Add                                              (new JST.ReturnStatement                                                   (new JST.IndexExpression                                                        (parameters[0].ToE()' parameters[1].ToE())));                                      else                                      {                                          script = PrefixName                                              (ctxt' methodDefn' RecasePropertyEvent(ctxt' methodDefn' script)' false);                                          if (methodDefn.IsStatic && methodArity == 0)                                              body.Add(new JST.ReturnStatement(script));                                          else if (!methodDefn.IsStatic && methodArity == 1)                                              body.Add                                                  (new JST.ReturnStatement                                                       (JST.Expression.Dot                                                            (parameters[0].ToE()'                                                             JST.Expression.ExplodePath(script))));                                          else                                          {                                              env.Log(new InvalidInteropMessage                                                  (RewriterMsgContext.Method(ctxt' methodDefn)'                                                   "additional getter parameters not supported for default getters"));                                              throw new DefinitionException();                                          }                                      }                                      function = new JST.FunctionExpression(parameters' new JST.Statements(body));                                  }                                  return new ImportMethodInfo { MethodDefn = methodDefn' Script = function };                              }                          }                          else if (methodDefn == prop.Setter)                          {                              // Setter                              if (isOnMethod)                              {                                  script = PrefixName                                      (ctxt'                                       methodDefn'                                       GetterSetterAdderRemoverNameFromMethod(ctxt' methodDefn' "set"' localScript)' false);                                  return FinalImportScript(ctxt' gensym' rootId' methodDefn' script' false);                              }                              else if (script != null && script is JST.FunctionExpression)                              {                                  env.Log(new InvalidInteropMessage                                      (RewriterMsgContext.Method(ctxt' methodDefn)'                                       "property import script cannot be a function"));                                  throw new DefinitionException();                              }                              else                              {                                  var function = default(JST.FunctionExpression);                                  if (gensym != null)                                  {                                      var parameters = new Seq<JST.Identifier>();                                      var body = new Seq<JST.Statement>();                                        for (var i = 0; i < methodArity; i++)                                          parameters.Add(gensym());                                      if (script == null && methodArity == 3 && !methodDefn.IsStatic)                                          body.Add                                              (JST.Statement.IndexAssignment                                                   (parameters[0].ToE()'                                                    parameters[1].ToE()'                                                    parameters[2].ToE()));                                      else                                      {                                          script = PrefixName                                              (ctxt' methodDefn' RecasePropertyEvent(ctxt' methodDefn' script)' false);                                          if (methodDefn.IsStatic && methodArity == 1)                                              body.Add                                                  (JST.Statement.Assignment(script' parameters[0].ToE()));                                          else if (!methodDefn.IsStatic && methodArity == 2)                                              body.Add                                                  (JST.Statement.Assignment                                                       (JST.Expression.Dot                                                            (parameters[0].ToE()'                                                             JST.Expression.ExplodePath(script))'                                                        parameters[1].ToE()));                                          else                                          {                                              env.Log(new InvalidInteropMessage                                                  (RewriterMsgContext.Method(ctxt' methodDefn)'                                                   "additional setter parameters not supported for default setters"));                                              throw new DefinitionException();                                          }                                      }                                      function = new JST.FunctionExpression(parameters' new JST.Statements(body));                                  }                                  return new ImportMethodInfo { MethodDefn = methodDefn' Script = function };                              }                          }                          else                              throw new InvalidOperationException();                      }                      else                      {                          var evnt = methodDefn.DeclaringMember as CCI.Event;                          if (evnt != null)                          {                              // XREF1201                              if (methodDefn == evnt.HandlerAdder)                              {                                  // Adder                                  if (isOnMethod)                                  {                                      script = PrefixName                                          (ctxt'                                           methodDefn'                                           GetterSetterAdderRemoverNameFromMethod(ctxt' methodDefn' "add"' localScript)' false);                                      return FinalImportScript(ctxt' gensym' rootId' methodDefn' script' false);                                  }                                  else if (script != null && script is JST.FunctionExpression)                                  {                                      env.Log(new InvalidInteropMessage                                          (RewriterMsgContext.Method(ctxt' methodDefn)'                                           "event import script cannot be a function"));                                      throw new DefinitionException();                                  }                                  else                                  {                                      var function = default(JST.FunctionExpression);                                      if (gensym != null)                                      {                                          var parameters = new Seq<JST.Identifier>();                                          var body = new Seq<JST.Statement>();                                            for (var i = 0; i < methodArity; i++)                                              parameters.Add(gensym());                                          script = PrefixName                                              (ctxt' methodDefn' RecasePropertyEvent(ctxt' methodDefn' script)' false);                                          if (methodDefn.IsStatic)                                              body.Add                                                  (JST.Statement.Assignment(script' parameters[0].ToE()));                                          else                                              body.Add                                                  (JST.Statement.Assignment                                                       (JST.Expression.Dot                                                            (parameters[0].ToE()'                                                             JST.Expression.ExplodePath(script))'                                                        parameters[1].ToE()));                                          function = new JST.FunctionExpression(parameters' new JST.Statements(body));                                      }                                      return new ImportMethodInfo { MethodDefn = methodDefn' Script = function };                                  }                              }                              else if (methodDefn == evnt.HandlerRemover)                              {                                  // Remover                                  if (isOnMethod)                                  {                                      script = PrefixName                                          (ctxt'                                           methodDefn'                                           GetterSetterAdderRemoverNameFromMethod(ctxt' methodDefn' "remove"' localScript)' false);                                      return FinalImportScript(ctxt' gensym' rootId' methodDefn' script' false);                                  }                                  else if (script != null && script is JST.FunctionExpression)                                  {                                      env.Log(new InvalidInteropMessage                                          (RewriterMsgContext.Method(ctxt' methodDefn)'                                           "event import script cannot be a function"));                                      throw new DefinitionException();                                  }                                  else                                  {                                      var function = default(JST.FunctionExpression);                                      if (gensym != null)                                      {                                          var parameters = new Seq<JST.Identifier>();                                          var body = new Seq<JST.Statement>();                                            for (var i = 0; i < methodArity; i++)                                              parameters.Add(gensym());                                          script = PrefixName                                              (ctxt' methodDefn' RecasePropertyEvent(ctxt' methodDefn' script)' false);                                          if (methodDefn.IsStatic)                                              body.Add                                                  (JST.Statement.Assignment(script' parameters[0].ToE()));                                          else                                              body.Add                                                  (JST.Statement.Assignment                                                       (JST.Expression.Dot                                                            (parameters[0].ToE()'                                                             JST.Expression.ExplodePath(script))'                                                        parameters[1].ToE()));                                            function = new JST.FunctionExpression(parameters' new JST.Statements(body));                                      }                                      return new ImportMethodInfo { MethodDefn = methodDefn' Script = function };                                  }                              }                              else                                  throw new InvalidOperationException();                          }                          else                              throw new InvalidOperationException();                      }                  }                  else                  {                      // XREF1153                      // Normal method                      script = PrefixName(ctxt' methodDefn' RecaseMember(ctxt' methodDefn' script)' false);                      return FinalImportScript(ctxt' gensym' rootId' methodDefn' script' false);                  }              }
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Program,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Program.cs,TrySignAssembly,The following statement contains a magic number: using (var fs = File.Open(keyfile' FileMode.Open' FileAccess.Read' FileShare.Read))              {                  var len = (int)fs.Length;                  var contents = new byte[len];                  var n = fs.Read(contents' 0' len);                  if (n != len)                  {                      env.Log                          (new AssemblySigningErrorMessage                               (targetAssembly.StrongName'                                String.Format("Cannot read contents of key file '{0}'"' keyfile)));                      return false;                  }                  if (contents.Length != 160 && contents.Length != 596)                  {                      env.Log                          (new AssemblySigningErrorMessage                               (targetAssembly.StrongName'                                String.Format("Key file '{0}' does not contain a valid key"' keyfile)));                      return false;                  }                  if (delaySign)                  {                      if (contents.Length == 160)                          targetAssembly.PublicKeyOrToken = contents;                      else if (contents.Length == 596)                      {                          var publicKeyBlobPointer = default(IntPtr);                          var publicKeyBlobLength = default(int);                          if (                              NativeMethods.StrongNameGetPublicKey                                  (null' contents' contents.Length' out publicKeyBlobPointer' out publicKeyBlobLength) ==                              0)                          {                              env.Log                                  (new AssemblySigningErrorMessage(targetAssembly.StrongName' "Could not sign assembly"));                              return false;                          }                          var blob = new byte[publicKeyBlobLength];                          Marshal.Copy(publicKeyBlobPointer' blob' 0' publicKeyBlobLength);                          targetAssembly.PublicKeyOrToken = blob;                      }                  }                  else                  {                      if (contents.Length == 160)                      {                          env.Log                              (new AssemblySigningErrorMessage                                   (targetAssembly.StrongName'                                    "Unable to fully sign assembly as keyfile only contains public key."));                          return false;                      }                      else if (contents.Length == 596)                          targetAssembly.KeyBlob = contents;                  }              }
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Program,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Program.cs,TrySignAssembly,The following statement contains a magic number: using (var fs = File.Open(keyfile' FileMode.Open' FileAccess.Read' FileShare.Read))              {                  var len = (int)fs.Length;                  var contents = new byte[len];                  var n = fs.Read(contents' 0' len);                  if (n != len)                  {                      env.Log                          (new AssemblySigningErrorMessage                               (targetAssembly.StrongName'                                String.Format("Cannot read contents of key file '{0}'"' keyfile)));                      return false;                  }                  if (contents.Length != 160 && contents.Length != 596)                  {                      env.Log                          (new AssemblySigningErrorMessage                               (targetAssembly.StrongName'                                String.Format("Key file '{0}' does not contain a valid key"' keyfile)));                      return false;                  }                  if (delaySign)                  {                      if (contents.Length == 160)                          targetAssembly.PublicKeyOrToken = contents;                      else if (contents.Length == 596)                      {                          var publicKeyBlobPointer = default(IntPtr);                          var publicKeyBlobLength = default(int);                          if (                              NativeMethods.StrongNameGetPublicKey                                  (null' contents' contents.Length' out publicKeyBlobPointer' out publicKeyBlobLength) ==                              0)                          {                              env.Log                                  (new AssemblySigningErrorMessage(targetAssembly.StrongName' "Could not sign assembly"));                              return false;                          }                          var blob = new byte[publicKeyBlobLength];                          Marshal.Copy(publicKeyBlobPointer' blob' 0' publicKeyBlobLength);                          targetAssembly.PublicKeyOrToken = blob;                      }                  }                  else                  {                      if (contents.Length == 160)                      {                          env.Log                              (new AssemblySigningErrorMessage                                   (targetAssembly.StrongName'                                    "Unable to fully sign assembly as keyfile only contains public key."));                          return false;                      }                      else if (contents.Length == 596)                          targetAssembly.KeyBlob = contents;                  }              }
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Program,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Program.cs,TrySignAssembly,The following statement contains a magic number: using (var fs = File.Open(keyfile' FileMode.Open' FileAccess.Read' FileShare.Read))              {                  var len = (int)fs.Length;                  var contents = new byte[len];                  var n = fs.Read(contents' 0' len);                  if (n != len)                  {                      env.Log                          (new AssemblySigningErrorMessage                               (targetAssembly.StrongName'                                String.Format("Cannot read contents of key file '{0}'"' keyfile)));                      return false;                  }                  if (contents.Length != 160 && contents.Length != 596)                  {                      env.Log                          (new AssemblySigningErrorMessage                               (targetAssembly.StrongName'                                String.Format("Key file '{0}' does not contain a valid key"' keyfile)));                      return false;                  }                  if (delaySign)                  {                      if (contents.Length == 160)                          targetAssembly.PublicKeyOrToken = contents;                      else if (contents.Length == 596)                      {                          var publicKeyBlobPointer = default(IntPtr);                          var publicKeyBlobLength = default(int);                          if (                              NativeMethods.StrongNameGetPublicKey                                  (null' contents' contents.Length' out publicKeyBlobPointer' out publicKeyBlobLength) ==                              0)                          {                              env.Log                                  (new AssemblySigningErrorMessage(targetAssembly.StrongName' "Could not sign assembly"));                              return false;                          }                          var blob = new byte[publicKeyBlobLength];                          Marshal.Copy(publicKeyBlobPointer' blob' 0' publicKeyBlobLength);                          targetAssembly.PublicKeyOrToken = blob;                      }                  }                  else                  {                      if (contents.Length == 160)                      {                          env.Log                              (new AssemblySigningErrorMessage                                   (targetAssembly.StrongName'                                    "Unable to fully sign assembly as keyfile only contains public key."));                          return false;                      }                      else if (contents.Length == 596)                          targetAssembly.KeyBlob = contents;                  }              }
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Program,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Program.cs,TrySignAssembly,The following statement contains a magic number: using (var fs = File.Open(keyfile' FileMode.Open' FileAccess.Read' FileShare.Read))              {                  var len = (int)fs.Length;                  var contents = new byte[len];                  var n = fs.Read(contents' 0' len);                  if (n != len)                  {                      env.Log                          (new AssemblySigningErrorMessage                               (targetAssembly.StrongName'                                String.Format("Cannot read contents of key file '{0}'"' keyfile)));                      return false;                  }                  if (contents.Length != 160 && contents.Length != 596)                  {                      env.Log                          (new AssemblySigningErrorMessage                               (targetAssembly.StrongName'                                String.Format("Key file '{0}' does not contain a valid key"' keyfile)));                      return false;                  }                  if (delaySign)                  {                      if (contents.Length == 160)                          targetAssembly.PublicKeyOrToken = contents;                      else if (contents.Length == 596)                      {                          var publicKeyBlobPointer = default(IntPtr);                          var publicKeyBlobLength = default(int);                          if (                              NativeMethods.StrongNameGetPublicKey                                  (null' contents' contents.Length' out publicKeyBlobPointer' out publicKeyBlobLength) ==                              0)                          {                              env.Log                                  (new AssemblySigningErrorMessage(targetAssembly.StrongName' "Could not sign assembly"));                              return false;                          }                          var blob = new byte[publicKeyBlobLength];                          Marshal.Copy(publicKeyBlobPointer' blob' 0' publicKeyBlobLength);                          targetAssembly.PublicKeyOrToken = blob;                      }                  }                  else                  {                      if (contents.Length == 160)                      {                          env.Log                              (new AssemblySigningErrorMessage                                   (targetAssembly.StrongName'                                    "Unable to fully sign assembly as keyfile only contains public key."));                          return false;                      }                      else if (contents.Length == 596)                          targetAssembly.KeyBlob = contents;                  }              }
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Program,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Program.cs,TrySignAssembly,The following statement contains a magic number: using (var fs = File.Open(keyfile' FileMode.Open' FileAccess.Read' FileShare.Read))              {                  var len = (int)fs.Length;                  var contents = new byte[len];                  var n = fs.Read(contents' 0' len);                  if (n != len)                  {                      env.Log                          (new AssemblySigningErrorMessage                               (targetAssembly.StrongName'                                String.Format("Cannot read contents of key file '{0}'"' keyfile)));                      return false;                  }                  if (contents.Length != 160 && contents.Length != 596)                  {                      env.Log                          (new AssemblySigningErrorMessage                               (targetAssembly.StrongName'                                String.Format("Key file '{0}' does not contain a valid key"' keyfile)));                      return false;                  }                  if (delaySign)                  {                      if (contents.Length == 160)                          targetAssembly.PublicKeyOrToken = contents;                      else if (contents.Length == 596)                      {                          var publicKeyBlobPointer = default(IntPtr);                          var publicKeyBlobLength = default(int);                          if (                              NativeMethods.StrongNameGetPublicKey                                  (null' contents' contents.Length' out publicKeyBlobPointer' out publicKeyBlobLength) ==                              0)                          {                              env.Log                                  (new AssemblySigningErrorMessage(targetAssembly.StrongName' "Could not sign assembly"));                              return false;                          }                          var blob = new byte[publicKeyBlobLength];                          Marshal.Copy(publicKeyBlobPointer' blob' 0' publicKeyBlobLength);                          targetAssembly.PublicKeyOrToken = blob;                      }                  }                  else                  {                      if (contents.Length == 160)                      {                          env.Log                              (new AssemblySigningErrorMessage                                   (targetAssembly.StrongName'                                    "Unable to fully sign assembly as keyfile only contains public key."));                          return false;                      }                      else if (contents.Length == 596)                          targetAssembly.KeyBlob = contents;                  }              }
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Program,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Program.cs,TrySignAssembly,The following statement contains a magic number: using (var fs = File.Open(keyfile' FileMode.Open' FileAccess.Read' FileShare.Read))              {                  var len = (int)fs.Length;                  var contents = new byte[len];                  var n = fs.Read(contents' 0' len);                  if (n != len)                  {                      env.Log                          (new AssemblySigningErrorMessage                               (targetAssembly.StrongName'                                String.Format("Cannot read contents of key file '{0}'"' keyfile)));                      return false;                  }                  if (contents.Length != 160 && contents.Length != 596)                  {                      env.Log                          (new AssemblySigningErrorMessage                               (targetAssembly.StrongName'                                String.Format("Key file '{0}' does not contain a valid key"' keyfile)));                      return false;                  }                  if (delaySign)                  {                      if (contents.Length == 160)                          targetAssembly.PublicKeyOrToken = contents;                      else if (contents.Length == 596)                      {                          var publicKeyBlobPointer = default(IntPtr);                          var publicKeyBlobLength = default(int);                          if (                              NativeMethods.StrongNameGetPublicKey                                  (null' contents' contents.Length' out publicKeyBlobPointer' out publicKeyBlobLength) ==                              0)                          {                              env.Log                                  (new AssemblySigningErrorMessage(targetAssembly.StrongName' "Could not sign assembly"));                              return false;                          }                          var blob = new byte[publicKeyBlobLength];                          Marshal.Copy(publicKeyBlobPointer' blob' 0' publicKeyBlobLength);                          targetAssembly.PublicKeyOrToken = blob;                      }                  }                  else                  {                      if (contents.Length == 160)                      {                          env.Log                              (new AssemblySigningErrorMessage                                   (targetAssembly.StrongName'                                    "Unable to fully sign assembly as keyfile only contains public key."));                          return false;                      }                      else if (contents.Length == 596)                          targetAssembly.KeyBlob = contents;                  }              }
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropTypes,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropTypes.cs,ParseCreation,The following statement contains a magic number: if (oi == null || oi.Value < 0 || oi.Value > 2)              {                  env.Log(new InvalidInteropMessage(ctxt' "expecting creation flag"));                  throw new DefinitionException();              }
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropTypes,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropTypes.cs,ParseQualification,The following statement contains a magic number: if (oi == null || oi.Value < 0 || oi.Value > 4)              {                  env.Log(new InvalidInteropMessage(ctxt' "expecting qualification flag"));                  throw new DefinitionException();              }
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropTypes,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropTypes.cs,ParseCasing,The following statement contains a magic number: if (oi == null || oi.Value < 0 || oi.Value > 2)              {                  env.Log(new InvalidInteropMessage(ctxt' "expecting casing flag"));                  throw new DefinitionException();              }
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropTypes,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropTypes.cs,ParseInteropStyle,The following statement contains a magic number: if (oi == null || oi.Value < 0 || oi.Value > 3)              {                  env.Log(new InvalidInteropMessage(ctxt' "expecting interop style flag"));                  throw new DefinitionException();              }
Duplicate Code,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The method contains a code clone-set at the following line numbers (starting from the method definition): ((198' 228)' (243' 273))
