Implementation smell,Namespace,Class,File,Method,Description
Long Method,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,AssemblyLoader,C:\repos\Reactive-Extensions_IL2JS\Rewriter\AssemblyLoader.cs,Load,The method has 136 lines of code.
Long Method,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ProcessType,The method has 102 lines of code.
Long Method,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ProcessMethod,The method has 116 lines of code.
Long Method,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The method has 202 lines of code.
Long Method,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,PrimStyle,The method has 100 lines of code.
Long Method,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,DefnStyle,The method has 149 lines of code.
Complex Method,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,AssemblyLoader,C:\repos\Reactive-Extensions_IL2JS\Rewriter\AssemblyLoader.cs,Load,Cyclomatic complexity of the method is 19
Complex Method,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,RewriteAssembly,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ProcessType,Cyclomatic complexity of the method is 17
Complex Method,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ProcessMethod,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ExplodeTypeApplication,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,BestImportingConstructor,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,RewriterCommandLine,C:\repos\Reactive-Extensions_IL2JS\Rewriter\RewriterCommandLine.cs,Process,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,PrefixName,Cyclomatic complexity of the method is 19
Complex Method,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,IsImported,Cyclomatic complexity of the method is 16
Complex Method,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,FinalImportScript,Cyclomatic complexity of the method is 17
Complex Method,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,Cyclomatic complexity of the method is 51
Complex Method,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,FinalExportInfo,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ExportInfo,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,PrimStyle,Cyclomatic complexity of the method is 27
Complex Method,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,DefnStyle,Cyclomatic complexity of the method is 65
Complex Method,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,KeyField,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,TypeClassifier,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,UndefinedIsNotNull,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,RewriterEnvironment,C:\repos\Reactive-Extensions_IL2JS\Rewriter\RewriterEnvironment.cs,Log,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Program,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Program.cs,Main,Cyclomatic complexity of the method is 18
Complex Method,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Program,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Program.cs,TrySignAssembly,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropTypes,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropTypes.cs,IsPrimitiveType,Cyclomatic complexity of the method is 15
Long Parameter List,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,FinalImportScript,The method has 6 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,FinalExportInfo,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,NativeMethods,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Program.cs,StrongNameGetPublicKey,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropTypes,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropTypes.cs,GetValue,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropTypes,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropTypes.cs,GetValue,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropTypes,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropTypes.cs,GetValue,The method has 6 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropTypes,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropTypes.cs,GetValue,The method has 5 parameters.
Long Identifier,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,DefnStyle,The length of the parameter numInstanceFieldsAllSupertypes is 30.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,AssemblyLoader,C:\repos\Reactive-Extensions_IL2JS\Rewriter\AssemblyLoader.cs,CheckTypeDefn,The length of the statement  "	if (typeDefn.DeclaringModule == null || typeDefn.DeclaringModule.ContainingAssembly == null || typeDefn.DeclaringModule.ContainingAssembly != expectedContainingAssembly || typeDefn.Name == null) { " is 196.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,AssemblyLoader,C:\repos\Reactive-Extensions_IL2JS\Rewriter\AssemblyLoader.cs,ResolveReference,The length of the statement  "			env.Log (new UnresolvableReferenceMessage (referencingModule.ContainingAssembly.StrongName' sourceFileName' reference.StrongName)); " is 131.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,RewriteAssembly,The length of the statement  "			var setupInteropMethod = new Method (env.ModuleType' new AttributeList ()' new Identifier ("SetupInterop")' new ParameterList (0)' env.VoidType' new Block (setupInteropStatements)); " is 181.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,RewriteAssembly,The length of the statement  "				newCCtorStatements.Add (new ExpressionStatement (new MethodCall (new MemberBinding (null' setupInteropMethod)' new ExpressionList ()))); " is 136.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,RewriteAssembly,The length of the statement  "				env.ModuleCCtorMethod.Flags |= MethodFlags.Private | MethodFlags.HideBySig | MethodFlags.SpecialName | MethodFlags.RTSpecialName | MethodFlags.Static; " is 150.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,RewriteAssembly,The length of the statement  "				newCCtorStatements.Add (new ExpressionStatement (new MethodCall (new MemberBinding (null' setupInteropMethod)' new ExpressionList ()))); " is 136.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,RewriteAssembly,The length of the statement  "		env.Log (new InvalidInteropMessage (RewriterMsgContext.Assembly (assembly)' "Assembly contains interop specification errors")); " is 127.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,EmitRegisterRoot,The length of the statement  "	setupInteropStatements.Add (new ExpressionStatement (new MethodCall (new MemberBinding (DatabaseExpression ()' env.InteropDatabase_RegisterRootExpression)' new ExpressionList (new Literal (env.Root' env.StringType))))); " is 219.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ProcessType,The length of the statement  "			setupInteropStatements.Add (new ExpressionStatement (new MethodCall (new MemberBinding (DatabaseExpression ()' env.InteropDatabase_RegisterTypeMethod)' new ExpressionList (TypeOfExpression (type)' new Literal ((int)style' env.IntType)' new Literal (null' env.StringType)' new Literal (null' env.StringType)' new Literal (0' env.IntType)' new Literal (di.CaptureThis' env.BooleanType)' new Literal (di.InlineParamsArray' env.BooleanType)' new Literal (false' env.BooleanType))))); " is 479.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ProcessType,The length of the statement  "			setupInteropStatements.Add (new ExpressionStatement (new MethodCall (new MemberBinding (DatabaseExpression ()' env.InteropDatabase_RegisterTypeMethod)' new ExpressionList (TypeOfExpression (type)' new Literal ((int)style' env.IntType)' new Literal (keyFieldStr' env.StringType)' new Literal (classifierStr' env.StringType)' new Literal (rootTypeSteps' env.IntType)' new Literal (false' env.BooleanType)' new Literal (false' env.BooleanType)' new Literal (undefinedIsNotNull' env.BooleanType))))); " is 496.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ProcessType,The length of the statement  "					env.Log (new InteropInfoMessage (RewriterMsgContext.Type (type)' "Created default importing constructor chained from base type's default importing constructor")); " is 162.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ProcessType,The length of the statement  "					statements.Add (new ExpressionStatement (new MethodCall (new MemberBinding (thisExpr' baseDefaultImportingCtor)' new ExpressionList (new ParameterBinding (parameters [0]' type.SourceContext))))); " is 195.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ProcessType,The length of the statement  "							env.Log (new InteropInfoMessage (RewriterMsgContext.Type (type)' "Cannot create a default importing constructor for type' since it derives from a type with state 'ManagedOnly' which does not contain a default constructor")); " is 224.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ProcessType,The length of the statement  "						env.Log (new InteropInfoMessage (RewriterMsgContext.Type (type)' "Created default importing constructor chained from base type's default constructor")); " is 152.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ProcessType,The length of the statement  "						statements.Add (new ExpressionStatement (new MethodCall (new MemberBinding (thisExpr' baseDefaultCtor)' new ExpressionList (0)))); " is 130.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ProcessType,The length of the statement  "							env.Log (new InteropInfoMessage (RewriterMsgContext.Type (type)' "Cannot create a default importing constructor for type' since it derives from an instance of a higher-kinded type without an explicit default importing constructor. (This limitation will be removed in the future.)")); " is 283.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ProcessType,The length of the statement  "							env.Log (new InteropInfoMessage (RewriterMsgContext.Type (type)' "Cannot create a default importing constructor for type' since it derives from a type with state 'ManagedAndJavaScript' or 'JavaScriptOnly'' and that type does not contain a default importing constructor")); " is 272.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ProcessType,The length of the statement  "		if (style == InteropStyle.Normal || style == InteropStyle.Primitive || style == InteropStyle.Proxied || style == InteropStyle.Keyed) { " is 134.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ProcessMethod,The length of the statement  "				runtimeExpr = new MethodCall (new MemberBinding (null' env.InteropContextManager_GetCurrentRuntimeMethod)' new ExpressionList (0)); " is 131.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ProcessMethod,The length of the statement  "				runtimeExpr = new MethodCall (new MemberBinding (null' env.InteropContextManager_GetRuntimeForObjectMethod)' new ExpressionList (thisExpr)); " is 140.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ProcessMethod,The length of the statement  "				statements.Add (new AssignmentStatement (new LocalBinding (contextLocal' ctor.SourceContext)' CastExpression (new MethodCall (new MemberBinding (runtimeExpr' env.Runtime_CallImportedMethodMethod)' new ExpressionList (new LocalBinding (constructorInfoLocal' ctor.SourceContext)' scriptExpr' argArray))' env.JSContextType))); " is 323.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ProcessMethod,The length of the statement  "				statements.Add (new ExpressionStatement (new MethodCall (new MemberBinding (runtimeExpr' env.Runtime_CompleteConstructionMethod)' new ExpressionList (new LocalBinding (constructorInfoLocal' ctor.SourceContext)' thisExpr' new LocalBinding (contextLocal' ctor.SourceContext))))); " is 277.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ProcessMethod,The length of the statement  "				statements.Add (new ExpressionStatement (new MethodCall (new MemberBinding (runtimeExpr' env.Runtime_CallImportedMethodMethod)' new ExpressionList (methodBaseExpr' scriptExpr' argArray)))); " is 189.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ProcessMethod,The length of the statement  "				statements.Add (new Return (CastExpression (new MethodCall (new MemberBinding (runtimeExpr' env.Runtime_CallImportedMethodMethod)' new ExpressionList (methodBaseExpr' scriptExpr' argArray))' method.ReturnType))); " is 212.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ProcessMethod,The length of the statement  "			//     InteropContextManager.Database.RegisterExport(<method base of M>' <bind to instance>' <cature this>' <export script>); " is 125.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ProcessMethod,The length of the statement  "			setupInteropStatements.Add (new ExpressionStatement (new MethodCall (new MemberBinding (DatabaseExpression ()' env.InteropDatabase_RegisterExportMethod)' new ExpressionList (MethodBaseExpression (method)' new Literal (si.BindToInstance' env.BooleanType)' new Literal (scriptString' env.StringType))))); " is 302.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ProcessMethod,The length of the statement  "		env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (method)' "Method contains interop specification errors")); " is 121.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,EmitDelegateShim,The length of the statement  "	var shim = new Class (inputAssembly' null' new AttributeList (0)' TypeFlags.Public | TypeFlags.Class' Identifier.For ("")' Identifier.For (ShimFullName (type.FullName))' (Class)env.ObjectType' new InterfaceList ()' new MemberList ()); " is 234.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,EmitDelegateShim,The length of the statement  "	var uField = new Field (shim' new AttributeList (0)' FieldFlags.Private' Identifier.For ("u")' env.UniversalDelegateType' null); " is 128.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,EmitDelegateShim,The length of the statement  "	var ctorBlock = new Block (new StatementList (new ExpressionStatement (new MethodCall (new MemberBinding (ThisExpression (shim)' env.ObjectType.GetConstructor ())' new ExpressionList ()))' new AssignmentStatement (new MemberBinding (ThisExpression (shim)' uField)' new ParameterBinding (ctorParam' ctorParam.SourceContext))' new Return ())); " is 341.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,EmitDelegateShim,The length of the statement  "	var callExpr = new MethodCall (new MemberBinding (new MemberBinding (ThisExpression (shim)' uField)' env.UniversalDelegate_InvokeMethod)' new ExpressionList (argsAsObjectArray)); " is 178.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,EmitDelegateShim,The length of the statement  "	var invoke = new Method (shim' new AttributeList (0)' Identifier.For ("Invoke")' invokeParams' type.ReturnType' new Block (statements)); " is 136.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,EmitDelegateShim,The length of the statement  "	setupInteropStatements.Add (new ExpressionStatement (new MethodCall (new MemberBinding (DatabaseExpression ()' env.InteropDatabase_RegisterDelegateShimMethod)' new ExpressionList (TypeOfExpression (shim))))); " is 208.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,TypeOfExpression,The length of the statement  "	return new MethodCall (new MemberBinding (null' env.Type_GetTypeFromHandleMethod)' new ExpressionList (new UnaryExpression (new Literal (type' env.TypeType)' NodeType.Ldtoken))); " is 178.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ThisExpression,The length of the statement  "	result.Type = type.IsGeneric && type.TemplateParameters != null ? type.GetTemplateInstance (type' type.TemplateParameters.ToArray ()) : type; " is 141.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,CopyParameters,The length of the statement  "		result.Add (new Parameter (new AttributeList (0)' parameter.Flags' Identifier.For (parameter.Name.Name)' parameter.Type' parameter.DefaultValue != null ? (Literal)parameter.DefaultValue.Clone () : null' parameter.MarshallingInformation)); " is 238.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ArrayExpression,The length of the statement  "		statements.Add (new ExpressionStatement (new ConstructArray (arrayElementType' new ExpressionList (new Literal (expressions.Count))' null))); " is 141.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ArrayExpression,The length of the statement  "			statements.Add (new AssignmentStatement (new Indexer (new Expression (NodeType.Dup' arrayType)' new ExpressionList (new Literal (i))' clrElementType)' expressions [i])); " is 169.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ExplodeTypeApplication,The length of the statement  "	if (fkType is ArrayType || fkType is Reference || fkType is Pointer || fkType is FunctionPointer || fkType is ClassParameter || fkType is TypeParameter) " is 152.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ExplodeTypeApplication,The length of the statement  "	if (hkType.Template != null || hkType is ArrayType || hkType is Reference || hkType is FunctionPointer || hkType is Pointer || hkType is ClassParameter || hkType is TypeParameter) " is 179.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ExplodeTypeAbstraction,The length of the statement  "	if (hkType is ArrayType || hkType is Reference || hkType is Pointer || hkType is FunctionPointer || hkType is ClassParameter || hkType is TypeParameter) " is 152.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,HoistedTypeExpression,The length of the statement  "		return new Indexer (new MethodCall (new MemberBinding (TypeOfExpression (hkType)' env.Type_GetGenericArgumentsMethod)' new ExpressionList ()' NodeType.Callvirt)' new ExpressionList (new Literal (tp.ParameterListIndex' env.IntType))' env.TypeType); " is 247.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,HoistedTypeExpression,The length of the statement  "		return new Indexer (new MethodCall (new MemberBinding (TypeOfExpression (hkType)' env.Type_GetGenericArgumentsMethod)' new ExpressionList ()' NodeType.Callvirt)' new ExpressionList (new Literal (cp.ParameterListIndex' env.IntType))' env.TypeType); " is 247.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,HoistedTypeExpression,The length of the statement  "		return new MethodCall (new MemberBinding (HoistedTypeExpression (hkType' at.ElementType)' env.Type_MakeArrayTypeMethod)' new ExpressionList ()' NodeType.Callvirt); " is 163.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,HoistedTypeExpression,The length of the statement  "	return new MethodCall (new MemberBinding (TypeOfExpression (innerHKType)' env.Type_MakeGenericTypeMethod)' new ExpressionList (ArrayExpression (typeArgs' env.TypeType))' NodeType.Callvirt); " is 189.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,SimpleMethodBaseExpression,The length of the statement  "		return new Construct (new MemberBinding (null' env.SimpleConstructorInfo_Ctor)' new ExpressionList (FirstOrderTypeOfExpression (method.DeclaringType)' ArrayExpression (paramTypes' env.TypeType))); " is 196.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,SimpleMethodBaseExpression,The length of the statement  "		return new Construct (new MemberBinding (null' env.SimpleMethodInfo_Ctor)' new ExpressionList (new Literal (method.IsStatic' env.BooleanType)' new Literal (method.Name.Name' env.StringType)' FirstOrderTypeOfExpression (method.DeclaringType)' ArrayExpression (paramTypes' env.TypeType)' TypeOfExpression (method.ReturnType))); " is 325.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,MethodBaseExpression,The length of the statement  "		return new MethodCall (new MemberBinding (TypeOfExpression (method.DeclaringType)' env.Type_GetConstructorMethod)' new ExpressionList (ArrayExpression (parameterTypes' env.TypeType))' NodeType.Callvirt); " is 203.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,MethodBaseExpression,The length of the statement  "		return new MethodCall (new MemberBinding (TypeOfExpression (method.DeclaringType)' env.Type_GetMethodMethod)' new ExpressionList (new Literal (method.Name.Name' env.StringType)' ArrayExpression (parameterTypes' env.TypeType))' NodeType.Callvirt); " is 246.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,DefaultImportingConstructor,The length of the statement  "				env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctor)' "Default importing constructors must be public")); " is 120.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,BestImportingConstructor,The length of the statement  "		env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (importingCtor)' "No importing constructor found to match imported constructor")); " is 144.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,TagAsImport,The length of the statement  "	member.Attributes.Add (env.InteropTypes.InstantiateAttribute (env.ImportAttributeType' new Literal (script' env.StringType))); " is 126.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,RecaseMember,The length of the statement  "	var name = Recase (member.Name.Name' interopTypes.GetValue (ctxt' member' env.NamingAttributeType' interopTypes.TheMemberNameCasingProperty)); " is 142.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,RecasePropertyEvent,The length of the statement  "	var name = Recase (method.DeclaringMember.Name.Name' interopTypes.GetValue (ctxt' method' env.NamingAttributeType' interopTypes.TheMemberNameCasingProperty)); " is 158.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,GetterSetterAdderRemoverNameFromMethod,The length of the statement  "		str += Recase (prefix' interopTypes.GetValue (ctxt' method' env.NamingAttributeType' interopTypes.ThePrefixNameCasingProperty)); " is 128.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,GetterSetterAdderRemoverNameFromMethod,The length of the statement  "	str += Recase (name' interopTypes.GetValue (ctxt' method' env.NamingAttributeType' interopTypes.TheMemberNameCasingProperty)); " is 126.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,GetterSetterAdderRemoverNameFromPropertyEvent,The length of the statement  "		str += Recase (prefix' interopTypes.GetValue (ctxt' method' env.NamingAttributeType' interopTypes.ThePrefixNameCasingProperty)); " is 128.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,PrefixName,The length of the statement  "	var isProto = isExport && interopTypes.GetValue (ctxt' member' env.ExportAttributeType' interopTypes.TheBindToPrototypeProperty); " is 129.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,PrefixName,The length of the statement  "				env.Log (new InvalidInteropMessage (RewriterMsgContext.Member (ctxt' member)' "global object expression cannot be a function")); " is 128.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,PrefixName,The length of the statement  "				env.Log (new InvalidInteropMessage (RewriterMsgContext.Member (ctxt' member)' "member's namespace cannot be represented in JavaScript")); " is 137.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,IsImported,The length of the statement  "					env.Log (new InvalidInteropMessage (RewriterMsgContext.Property (ctxt' declProp)' "properties with getters and setters must be imported simultaneously")); " is 154.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,IsImported,The length of the statement  "						env.Log (new InvalidInteropMessage (RewriterMsgContext.Property (ctxt' declProp)' "events with adders and removers must be imported simultaneously")); " is 150.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,IsImported,The length of the statement  "				env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (methodDefn)' "cannot mix 'Import' and 'DllImport' attributes")); " is 127.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,IsImported,The length of the statement  "				env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (methodDefn)' "cannot Import a method which already has an implementation")); " is 139.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,FinalImportScript,The length of the statement  "	var lastArgIsParamsArray = LastArgIsParamsArray (ctxt' methodDefn) && interopTypes.GetValue (ctxt' methodDefn' env.ImportAttributeType' interopTypes.TheInlineParamsArrayProperty); " is 179.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,FinalImportScript,The length of the statement  "	var scriptExpectsRoot = interopTypes.GetValue (ctxt' methodDefn' env.ImportAttributeType' interopTypes.ThePassRootAsArgumentProperty); " is 134.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,FinalImportScript,The length of the statement  "	var instanceIsThis = isInstanceMethod && !interopTypes.GetValue (ctxt' methodDefn' env.ImportAttributeType' interopTypes.ThePassInstanceAsArgumentProperty); " is 156.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,FinalImportScript,The length of the statement  "	var expectedScriptArity = methodArity - (lastArgIsParamsArray ? 1 : 0) + (scriptExpectsRoot ? 1 : 0) - (instanceIsThis ? 1 : 0); " is 128.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,FinalImportScript,The length of the statement  "					body.Add (new JST.IfStatement (JST.Expression.IsNotNull (id.ToE ())' new JST.Statements (new JST.ForStatement (new JST.ForVarLoopClause (iId' new JST.NumericLiteral (0)' new JST.BinaryExpression (iId.ToE ()' JST.BinaryOp.LessThan' JST.Expression.Dot (id.ToE ()' Constants.length))' new JST.UnaryExpression (iId.ToE ()' JST.UnaryOp.PostIncrement))' new JST.Statements (JST.Statement.DotCall (argsId.ToE ()' Constants.push' new JST.IndexExpression (id.ToE ()' iId.ToE ()))))))); " is 476.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The length of the statement  "					env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "imported constructors for object literals cannot have arguments")); " is 150.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The length of the statement  "			var localScript = isOnMethod ? interopTypes.GetValue (ctxt' methodDefn' env.ImportAttributeType' interopTypes.TheScriptProperty' false) : default(JST.Expression); " is 162.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The length of the statement  "						script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "get"' localScript)' false); " is 125.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The length of the statement  "						env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "property import script cannot be a function")); " is 130.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The length of the statement  "									env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional getter parameters not supported for default getters")); " is 149.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The length of the statement  "						script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "set"' localScript)' false); " is 125.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The length of the statement  "						env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "property import script cannot be a function")); " is 130.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The length of the statement  "									body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ())); " is 141.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The length of the statement  "									env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional setter parameters not supported for default setters")); " is 149.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The length of the statement  "							script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "add"' localScript)' false); " is 125.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The length of the statement  "							env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "event import script cannot be a function")); " is 127.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The length of the statement  "									body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ())); " is 141.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The length of the statement  "							script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "remove"' localScript)' false); " is 128.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The length of the statement  "							env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "event import script cannot be a function")); " is 127.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The length of the statement  "									body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ())); " is 141.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,IsExported,The length of the statement  "	if (interopTypes.HasAttribute (methodDefn' env.ExportAttributeType' !isExtern) && !interopTypes.HasAttribute (methodDefn' env.NotExportedAttributeType' false)) " is 159.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,FinalExportInfo,The length of the statement  "			env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "cannot export instance methods from value types")); " is 134.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,FinalExportInfo,The length of the statement  "	var lastArgIsParamsArray = LastArgIsParamsArray (ctxt' methodDefn) && interopTypes.GetValue (ctxt' methodDefn' env.ExportAttributeType' interopTypes.TheInlineParamsArrayProperty); " is 179.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,FinalExportInfo,The length of the statement  "	var isPassRoot = interopTypes.GetValue (ctxt' methodDefn' env.ExportAttributeType' interopTypes.ThePassRootAsArgumentProperty); " is 127.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,FinalExportInfo,The length of the statement  "	var isProto = interopTypes.GetValue (ctxt' methodDefn' env.ExportAttributeType' interopTypes.TheBindToPrototypeProperty); " is 121.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,FinalExportInfo,The length of the statement  "	var isPassInstance = interopTypes.GetValue (ctxt' methodDefn' env.ExportAttributeType' interopTypes.ThePassInstanceAsArgumentProperty); " is 135.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,FinalExportInfo,The length of the statement  "					innerBody.Add (new JST.ForStatement (new JST.ForVarLoopClause (iId' new JST.NumericLiteral (methodArity - 1)' new JST.BinaryExpression (iId.ToE ()' JST.BinaryOp.LessThan' JST.Expression.Dot (Constants.arguments.ToE ()' Constants.length))' new JST.UnaryExpression (iId.ToE ()' JST.UnaryOp.PostIncrement))' new JST.Statements (JST.Statement.DotCall (arrId.ToE ()' Constants.push' new JST.IndexExpression (Constants.arguments.ToE ()' iId.ToE ()))))); " is 447.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,EnsurePathExists,The length of the statement  "			statements.Add (new JST.TryStatement (new JST.Statements (new JST.ExpressionStatement (prefix))' new JST.CatchClause (exId' new JST.Statements (JST.Statement.Assignment (prefix' new JST.ObjectLiteral ()))))); " is 208.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,EnsurePathExists,The length of the statement  "			statements.Add (new JST.IfStatement (JST.Expression.IsNull (prefix)' new JST.Statements (JST.Statement.Assignment (prefix' new JST.ObjectLiteral ())))); " is 152.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ExportInfo,The length of the statement  "		env.Log (new InvalidInteropMessage (RewriterMsgContext.Member (ctxt' methodDefn)' "polymorphic methods cannot be exported")); " is 125.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ExportInfo,The length of the statement  "		env.Log (new InvalidInteropMessage (RewriterMsgContext.Member (ctxt' methodDefn)' "non-instance methods of higher-kinded types cannot be exported")); " is 149.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ExportInfo,The length of the statement  "		var localScript = isOnMethod ? interopTypes.GetValue (ctxt' methodDefn' env.ExportAttributeType' interopTypes.TheScriptProperty' false) : default(JST.Expression); " is 162.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ExportInfo,The length of the statement  "				script = isOnMethod ? GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "get"' localScript) : GetterSetterAdderRemoverNameFromPropertyEvent (ctxt' methodDefn' "get"' script); " is 182.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ExportInfo,The length of the statement  "				script = isOnMethod ? GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "set"' localScript) : GetterSetterAdderRemoverNameFromPropertyEvent (ctxt' methodDefn' "set"' script); " is 182.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ExportInfo,The length of the statement  "					script = isOnMethod ? GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "add"' localScript) : GetterSetterAdderRemoverNameFromPropertyEvent (ctxt' methodDefn' "add"' script); " is 182.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ExportInfo,The length of the statement  "					script = isOnMethod ? GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "remove"' localScript) : GetterSetterAdderRemoverNameFromPropertyEvent (ctxt' methodDefn' "remove"' script); " is 188.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,PrimStyle,The length of the statement  "		env.Log (new InvalidInteropMessage (subCtxt' "only primitive and 'Merged' value types may cross between managed and unmanaged code")); " is 134.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,DefnStyle,The length of the statement  "				if (methodDefn is CCI.InstanceInitializer && !IsExtern (methodDefn) && !(methodDefn.Parameters != null && methodDefn.Parameters.Count > 0 && methodDefn.Parameters [0].Type == env.JSContextType)) " is 194.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,DefnStyle,The length of the statement  "	if (!interopTypes.GetValue (ctxt' typeDefn' env.InteropAttributeType' interopTypes.TheStateProperty' false' ref style)) { " is 121.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,DefnStyle,The length of the statement  "			if (style == InteropStyle.Normal && (!typeDefn.IsSealed || !typeDefn.IsAbstract) && numInstanceOrCtorImports + numInstanceExports > 0) " is 134.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,DefnStyle,The length of the statement  "			env.Log (new InvalidInteropMessage (subCtxt' "type state is 'ManagedAndJavaScript' but base type state is 'JavaScriptOnly'")); " is 126.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,DefnStyle,The length of the statement  "			env.Log (new InteropInfoMessage (subCtxt' String.Format ("We assume the {0} non-imported constructors for this type with state 'ManagedAndJavaScript' always throw or chain to an imported constructor"' numNonImportedCtors))); " is 224.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,DefnStyle,The length of the statement  "			env.Log (new InvalidInteropMessage (subCtxt' "type state is 'JavaScriptOnly' but base type state is 'ManagedAndJavaScript'")); " is 126.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,DefnStyle,The length of the statement  "			env.Log (new InvalidInteropMessage (subCtxt' "a type with state 'JavaScriptOnly' type cannot contain managed fields' either directly or in supertypes")); " is 153.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,DefnStyle,The length of the statement  "			env.Log (new InvalidInteropMessage (subCtxt' "a type with state 'JavaScriptOnly' cannot contain methods' properties or events which must be bound to instances")); " is 162.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,DefnStyle,The length of the statement  "			env.Log (new InteropInfoMessage (subCtxt' String.Format ("We assume the {0} non-imported constructors for this type with state 'JavaScriptOnly' always throw or chain to an imported constructor"' numNonImportedCtors))); " is 218.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,KeyField,The length of the statement  "			env.Log (new InvalidInteropMessage (subCtxt' "default key must be specified for type with state 'ManagedAndJavaScript' without an 'ImportKey' attribute")); " is 155.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,KeyField,The length of the statement  "			env.Log (new InvalidInteropMessage (subCtxt' "key for type with state 'ManagedAndJavaScript' must be imported as an identifier' not a function")); " is 146.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,DelegateInfo,The length of the statement  "	var captureThis = interopTypes.GetValue (ctxt' delegateDefn' env.ExportAttributeType' interopTypes.ThePassInstanceAsArgumentProperty); " is 134.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,DelegateInfo,The length of the statement  "	var inlineParamsArray = interopTypes.GetValue (ctxt' delegateDefn' env.ExportAttributeType' interopTypes.TheInlineParamsArrayProperty); " is 135.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,RewriterEnvironment,C:\repos\Reactive-Extensions_IL2JS\Rewriter\RewriterEnvironment.cs,Setup,The length of the statement  "	InteropContextManager_GetRuntimeForObjectMethod = GetMethod (InteropContextManagerType' "GetRuntimeForObject"' ObjectType); " is 123.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,RewriterEnvironment,C:\repos\Reactive-Extensions_IL2JS\Rewriter\RewriterEnvironment.cs,Setup,The length of the statement  "	InteropDatabase_RegisterTypeMethod = GetMethod (InteropDatabaseType' "RegisterType"' TypeType' IntType' StringType' StringType' IntType' BooleanType' BooleanType' BooleanType); " is 176.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,RewriterEnvironment,C:\repos\Reactive-Extensions_IL2JS\Rewriter\RewriterEnvironment.cs,Setup,The length of the statement  "	InteropDatabase_RegisterExportMethod = GetMethod (InteropDatabaseType' "RegisterExport"' MethodBaseType' BooleanType' StringType); " is 130.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,RewriterEnvironment,C:\repos\Reactive-Extensions_IL2JS\Rewriter\RewriterEnvironment.cs,Setup,The length of the statement  "	SimpleMethodInfo_Ctor = GetConstructor (SimpleMethodInfoType' BooleanType' StringType' TypeType' TypeType.GetArrayType (1)' TypeType); " is 134.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,RewriterEnvironment,C:\repos\Reactive-Extensions_IL2JS\Rewriter\RewriterEnvironment.cs,Setup,The length of the statement  "	Runtime_CompleteConstructionMethod = GetMethod (RuntimeType' "CompleteConstruction"' SimpleMethodBaseType' ObjectType' JSContextType); " is 134.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,RewriterEnvironment,C:\repos\Reactive-Extensions_IL2JS\Rewriter\RewriterEnvironment.cs,Setup,The length of the statement  "	Runtime_CallImportedMethodMethod = GetMethod (RuntimeType' "CallImportedMethod"' SimpleMethodBaseType' StringType' ObjectType.GetArrayType (1)); " is 144.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Program,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Program.cs,TrySignAssembly,The length of the statement  "		env.Log (new AssemblySigningErrorMessage (targetAssembly.StrongName' String.Format ("Cannot open key file '{0}'"' keyfile))); " is 125.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Program,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Program.cs,TrySignAssembly,The length of the statement  "			env.Log (new AssemblySigningErrorMessage (targetAssembly.StrongName' String.Format ("Cannot read contents of key file '{0}'"' keyfile))); " is 137.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Program,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Program.cs,TrySignAssembly,The length of the statement  "			env.Log (new AssemblySigningErrorMessage (targetAssembly.StrongName' String.Format ("Key file '{0}' does not contain a valid key"' keyfile))); " is 142.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Program,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Program.cs,TrySignAssembly,The length of the statement  "				if (NativeMethods.StrongNameGetPublicKey (null' contents' contents.Length' out publicKeyBlobPointer' out publicKeyBlobLength) == 0) { " is 133.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Program,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Program.cs,TrySignAssembly,The length of the statement  "				env.Log (new AssemblySigningErrorMessage (targetAssembly.StrongName' "Unable to fully sign assembly as keyfile only contains public key.")); " is 140.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropTypes,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropTypes.cs,IsNullableType,The length of the statement  "	return type.Template != null && type.TemplateArguments != null && type.TemplateArguments.Count == 1 && type.Template == env.NullableTypeConstructor; " is 148.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropTypes,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropTypes.cs,ParseScript,The length of the statement  "					env.Log (new InvalidInteropMessage (new MessageContext (ctxt' currIndex.Right.Loc' null)' "Expecting identifier' string or number")); " is 133.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropTypes,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropTypes.cs,ParseScript,The length of the statement  "					env.Log (new InvalidInteropMessage (new MessageContext (ctxt' curr.Loc' null)' "Expecting identifier' string or number")); " is 122.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropTypes,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropTypes.cs,ParseScript,The length of the statement  "		env.Log (new InvalidInteropMessage (new MessageContext (ctxt' e.Loc' null)' "syntax error in " + e.Context + ": " + e.Details)); " is 128.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropTypes,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropTypes.cs,GetValue,The length of the statement  "						env.Log (new InvalidInteropMessage (RewriterMsgContext.AttributeProperty (ctxt' attribute' property.Name)' "duplicate inconsistent bindings")); " is 143.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,RewriterMsgContext,C:\repos\Reactive-Extensions_IL2JS\Rewriter\RewriterMsgContext.cs,ToLocation,The length of the statement  "	return new Location (ctx.Document.Name' ctx.StartPos' ctx.StartLine' ctx.StartColumn' ctx.EndPos' ctx.EndLine' ctx.EndColumn); " is 126.
Long Statement,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,RewriterMsgContext,C:\repos\Reactive-Extensions_IL2JS\Rewriter\RewriterMsgContext.cs,Method,The length of the statement  "	else if (method.Instructions != null && method.Instructions.Count > 1 && method.Instructions [1].SourceContext.Document != null) " is 128.
Complex Conditional,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,AssemblyLoader,C:\repos\Reactive-Extensions_IL2JS\Rewriter\AssemblyLoader.cs,CheckTypeDefn,The conditional expression  "typeDefn.DeclaringModule == null || typeDefn.DeclaringModule.ContainingAssembly == null || typeDefn.DeclaringModule.ContainingAssembly != expectedContainingAssembly || typeDefn.Name == null"  is complex.
Complex Conditional,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,RewriteAssembly,The conditional expression  "method != null && method.IsStatic && method.Name.Equals ("SetupInterop") && method.Parameters.Count == 0"  is complex.
Complex Conditional,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ProcessType,The conditional expression  "style == InteropStyle.Normal || style == InteropStyle.Primitive || style == InteropStyle.Proxied || style == InteropStyle.Keyed"  is complex.
Complex Conditional,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ExplodeTypeApplication,The conditional expression  "fkType is ArrayType || fkType is Reference || fkType is Pointer || fkType is FunctionPointer || fkType is ClassParameter || fkType is TypeParameter"  is complex.
Complex Conditional,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ExplodeTypeApplication,The conditional expression  "hkType.Template != null || hkType is ArrayType || hkType is Reference || hkType is FunctionPointer || hkType is Pointer || hkType is ClassParameter || hkType is TypeParameter"  is complex.
Complex Conditional,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ExplodeTypeAbstraction,The conditional expression  "hkType is ArrayType || hkType is Reference || hkType is Pointer || hkType is FunctionPointer || hkType is ClassParameter || hkType is TypeParameter"  is complex.
Complex Conditional,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,PrefixName,The conditional expression  "isExport && !isNonInstance && !isProto && qual != Qualification.None"  is complex.
Complex Conditional,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,PrefixName,The conditional expression  "isExport && !isNonInstance && isProto && qual == Qualification.None"  is complex.
Complex Conditional,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,DefnStyle,The conditional expression  "methodDefn is CCI.InstanceInitializer && !IsExtern (methodDefn) && !(methodDefn.Parameters != null && methodDefn.Parameters.Count > 0 && methodDefn.Parameters [0].Type == env.JSContextType)"  is complex.
Complex Conditional,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,DefnStyle,The conditional expression  "style == InteropStyle.Normal && (!typeDefn.IsSealed || !typeDefn.IsAbstract) && numInstanceOrCtorImports + numInstanceExports > 0"  is complex.
Empty Catch Block,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Program,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Program.cs,Main,The method has an empty catch block.
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ProcessMethod,The following statement contains a magic number: try {  	if (env.InteropManager.IsImported (null' method)) {  		AddDelegateTypes (accumDelegateTypes' method);  		//  If constructor:  		//      C(A1 a1' A2 a2)  		//  emit:  		//      var ci = typeof(<this type>).GetConstructor(new Type[] { typeof(A1)' typeof(A2) });  		//      var ctxt = (JSContext)InteropContextManager.CurrentRuntime.CallImportedMethod(  		//                                ci'  		//                                <import script>'  		//                                new object[] { this' a1' a2 });  		//      C(ctxt' a1' a2) or C(ctxt);  		//      InteropContextManager.CurrentRuntime.CompleteConstruction(ci' this' ctxt);  		//  		//  If static method:  		//      R C::M(A1 a1' A2 a2)  		//  emit:  		//      return (R)InteropContextManager.CurrentRuntime.CallImportedMethod(  		//                    typeof(<this type>).GetMethod("M"' new Type[] { typeof(A1)' typeof(A2) })'  		//                    <import script>'  		//                    new object[] { a1' a2 });  		//  		//  If instance method:  		//      R C::M(A1 a1' A2 a2)  		//  emit:  		//      return (R)InteropContextManager.GetRuntimeForObject(this).CallImportedMethod(  		//                    typeof(<this type>).GetMethod("M"' new Type[] { typeof(A1)' typeof(A2) })'  		//                    <import script>'  		//                    new object[] { this' a1' a2 });  		var thisExpr = new ThisBinding (ThisExpression (method.DeclaringType)' method.SourceContext);  		var argExprs = new ExpressionList ();  		if (!method.IsStatic && !(method is InstanceInitializer))  			argExprs.Add (thisExpr);  		foreach (var p in method.Parameters)  			argExprs.Add (BoxExpression (new ParameterBinding (p' method.SourceContext)' env.ObjectType));  		var argArray = ArrayExpression (argExprs' env.ObjectType);  		// Imports are special in a few ways:  		//  - The runtime will never attempt to Invoke the method base. All it needs are the  		//    argument types' static/instance distiction' and method/constructor distinction.  		//  - The call to Runtime::CallImportedMethod will be within the method body  		//    itself. If the method is polymorphic' and/or within a higher-kinded type' then  		//    typeof(<argument type>) will yield the correct runtime type for the argument' taking  		//    account of all type instantiation. We don't need to know the type arguments themselves.  		//  - Private methods may be imported' however Silverlight doesn't provide reflection for  		//    private methods.  		// For these reasons we build our own simple-minded method base literal to support the  		// CallImportedMethod call.  		var methodBaseExpr = SimpleMethodBaseExpression (method);  		var runtimeExpr = default(Expression);  		if (method.IsStatic || method is InstanceInitializer)  			runtimeExpr = new MethodCall (new MemberBinding (null' env.InteropContextManager_GetCurrentRuntimeMethod)' new ExpressionList (0));  		else  			runtimeExpr = new MethodCall (new MemberBinding (null' env.InteropContextManager_GetRuntimeForObjectMethod)' new ExpressionList (thisExpr));  		var si = env.InteropManager.ImportInfo (null' env.GenSym' new JST.Identifier (env.Root)' method);  		var scriptString = si.Script.ToString (false);  		env.Log (new InteropInfoMessage (RewriterMsgContext.Method (method)' "Imported as: " + scriptString));  		var scriptExpr = new Literal (scriptString' env.StringType);  		var statements = method.Body.Statements;  		var ctor = method as InstanceInitializer;  		if (ctor != null) {  			var locals = ctor.LocalList;  			if (locals == null) {  				locals = new LocalList (2);  				ctor.LocalList = locals;  			}  			var constructorInfoLocal = new Local (Identifier.For ("ci")' env.SimpleMethodBaseType);  			locals.Add (constructorInfoLocal);  			var contextLocal = new Local (Identifier.For ("ctxt")' env.JSContextType);  			locals.Add (contextLocal);  			statements.Add (new AssignmentStatement (new LocalBinding (constructorInfoLocal' ctor.SourceContext)' methodBaseExpr));  			statements.Add (new AssignmentStatement (new LocalBinding (contextLocal' ctor.SourceContext)' CastExpression (new MethodCall (new MemberBinding (runtimeExpr' env.Runtime_CallImportedMethodMethod)' new ExpressionList (new LocalBinding (constructorInfoLocal' ctor.SourceContext)' scriptExpr' argArray))' env.JSContextType)));  			var importingCtor = BestImportingConstructor (ctor);  			var args = new ExpressionList (importingCtor.Parameters.Count);  			args.Add (new LocalBinding (contextLocal' ctor.SourceContext));  			if (importingCtor.Parameters.Count > 1) {  				for (var i = 0; i < ctor.Parameters.Count; i++)  					args.Add (new ParameterBinding (ctor.Parameters [i]' ctor.SourceContext));  			}  			statements.Add (new ExpressionStatement (new MethodCall (new MemberBinding (thisExpr' importingCtor)' args)));  			statements.Add (new ExpressionStatement (new MethodCall (new MemberBinding (runtimeExpr' env.Runtime_CompleteConstructionMethod)' new ExpressionList (new LocalBinding (constructorInfoLocal' ctor.SourceContext)' thisExpr' new LocalBinding (contextLocal' ctor.SourceContext)))));  			statements.Add (new Return ());  		}  		else if (method.ReturnType == env.VoidType) {  			statements.Add (new ExpressionStatement (new MethodCall (new MemberBinding (runtimeExpr' env.Runtime_CallImportedMethodMethod)' new ExpressionList (methodBaseExpr' scriptExpr' argArray))));  			statements.Add (new ExpressionStatement (new UnaryExpression (null' NodeType.Pop)));  			statements.Add (new Return ());  		}  		else {  			statements.Add (new Return (CastExpression (new MethodCall (new MemberBinding (runtimeExpr' env.Runtime_CallImportedMethodMethod)' new ExpressionList (methodBaseExpr' scriptExpr' argArray))' method.ReturnType)));  		}  		TagAsInteropGenerated (method);  	}  	if (env.InteropManager.IsExported (null' method)) {  		AddDelegateTypes (accumDelegateTypes' method);  		// For each exported method' append to <Module>::SetupInterop()  		//     InteropContextManager.Database.RegisterExport(<method base of M>' <bind to instance>' <cature this>' <export script>);  		// Exports are special in a few ways:  		//  - Polymorphic methods cannot be exported' so we never need to deal with them.  		//  - The call to Runtime::RegisterExportMethod is outside of the method itself. For instance  		//    methods' the declaring type may be higher-kinded' in which case we must recover the  		//    type arguments from the type of the instance at runtime. Thus at compile-time we  		//    must describe the method in it's higher-kinded declaring type.  		//  - The runtime needs to be able to Invoke the method base.  		// Thus we are forced to use true MethodBase' MethodInfo and ConstructorInfo' and work-around  		// limitations of reflection.  		var si = env.InteropManager.ExportInfo (null' env.GenSym' new JST.Identifier (env.Root)' method);  		var scriptString = si.Script.ToString (false);  		env.Log (new InteropInfoMessage (RewriterMsgContext.Method (method)' "Exported as: " + scriptString));  		setupInteropStatements.Add (new ExpressionStatement (new MethodCall (new MemberBinding (DatabaseExpression ()' env.InteropDatabase_RegisterExportMethod)' new ExpressionList (MethodBaseExpression (method)' new Literal (si.BindToInstance' env.BooleanType)' new Literal (scriptString' env.StringType)))));  	}  }  catch (DefinitionException) {  	env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (method)' "Method contains interop specification errors"));  }  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ProcessMethod,The following statement contains a magic number: if (env.InteropManager.IsImported (null' method)) {  	AddDelegateTypes (accumDelegateTypes' method);  	//  If constructor:  	//      C(A1 a1' A2 a2)  	//  emit:  	//      var ci = typeof(<this type>).GetConstructor(new Type[] { typeof(A1)' typeof(A2) });  	//      var ctxt = (JSContext)InteropContextManager.CurrentRuntime.CallImportedMethod(  	//                                ci'  	//                                <import script>'  	//                                new object[] { this' a1' a2 });  	//      C(ctxt' a1' a2) or C(ctxt);  	//      InteropContextManager.CurrentRuntime.CompleteConstruction(ci' this' ctxt);  	//  	//  If static method:  	//      R C::M(A1 a1' A2 a2)  	//  emit:  	//      return (R)InteropContextManager.CurrentRuntime.CallImportedMethod(  	//                    typeof(<this type>).GetMethod("M"' new Type[] { typeof(A1)' typeof(A2) })'  	//                    <import script>'  	//                    new object[] { a1' a2 });  	//  	//  If instance method:  	//      R C::M(A1 a1' A2 a2)  	//  emit:  	//      return (R)InteropContextManager.GetRuntimeForObject(this).CallImportedMethod(  	//                    typeof(<this type>).GetMethod("M"' new Type[] { typeof(A1)' typeof(A2) })'  	//                    <import script>'  	//                    new object[] { this' a1' a2 });  	var thisExpr = new ThisBinding (ThisExpression (method.DeclaringType)' method.SourceContext);  	var argExprs = new ExpressionList ();  	if (!method.IsStatic && !(method is InstanceInitializer))  		argExprs.Add (thisExpr);  	foreach (var p in method.Parameters)  		argExprs.Add (BoxExpression (new ParameterBinding (p' method.SourceContext)' env.ObjectType));  	var argArray = ArrayExpression (argExprs' env.ObjectType);  	// Imports are special in a few ways:  	//  - The runtime will never attempt to Invoke the method base. All it needs are the  	//    argument types' static/instance distiction' and method/constructor distinction.  	//  - The call to Runtime::CallImportedMethod will be within the method body  	//    itself. If the method is polymorphic' and/or within a higher-kinded type' then  	//    typeof(<argument type>) will yield the correct runtime type for the argument' taking  	//    account of all type instantiation. We don't need to know the type arguments themselves.  	//  - Private methods may be imported' however Silverlight doesn't provide reflection for  	//    private methods.  	// For these reasons we build our own simple-minded method base literal to support the  	// CallImportedMethod call.  	var methodBaseExpr = SimpleMethodBaseExpression (method);  	var runtimeExpr = default(Expression);  	if (method.IsStatic || method is InstanceInitializer)  		runtimeExpr = new MethodCall (new MemberBinding (null' env.InteropContextManager_GetCurrentRuntimeMethod)' new ExpressionList (0));  	else  		runtimeExpr = new MethodCall (new MemberBinding (null' env.InteropContextManager_GetRuntimeForObjectMethod)' new ExpressionList (thisExpr));  	var si = env.InteropManager.ImportInfo (null' env.GenSym' new JST.Identifier (env.Root)' method);  	var scriptString = si.Script.ToString (false);  	env.Log (new InteropInfoMessage (RewriterMsgContext.Method (method)' "Imported as: " + scriptString));  	var scriptExpr = new Literal (scriptString' env.StringType);  	var statements = method.Body.Statements;  	var ctor = method as InstanceInitializer;  	if (ctor != null) {  		var locals = ctor.LocalList;  		if (locals == null) {  			locals = new LocalList (2);  			ctor.LocalList = locals;  		}  		var constructorInfoLocal = new Local (Identifier.For ("ci")' env.SimpleMethodBaseType);  		locals.Add (constructorInfoLocal);  		var contextLocal = new Local (Identifier.For ("ctxt")' env.JSContextType);  		locals.Add (contextLocal);  		statements.Add (new AssignmentStatement (new LocalBinding (constructorInfoLocal' ctor.SourceContext)' methodBaseExpr));  		statements.Add (new AssignmentStatement (new LocalBinding (contextLocal' ctor.SourceContext)' CastExpression (new MethodCall (new MemberBinding (runtimeExpr' env.Runtime_CallImportedMethodMethod)' new ExpressionList (new LocalBinding (constructorInfoLocal' ctor.SourceContext)' scriptExpr' argArray))' env.JSContextType)));  		var importingCtor = BestImportingConstructor (ctor);  		var args = new ExpressionList (importingCtor.Parameters.Count);  		args.Add (new LocalBinding (contextLocal' ctor.SourceContext));  		if (importingCtor.Parameters.Count > 1) {  			for (var i = 0; i < ctor.Parameters.Count; i++)  				args.Add (new ParameterBinding (ctor.Parameters [i]' ctor.SourceContext));  		}  		statements.Add (new ExpressionStatement (new MethodCall (new MemberBinding (thisExpr' importingCtor)' args)));  		statements.Add (new ExpressionStatement (new MethodCall (new MemberBinding (runtimeExpr' env.Runtime_CompleteConstructionMethod)' new ExpressionList (new LocalBinding (constructorInfoLocal' ctor.SourceContext)' thisExpr' new LocalBinding (contextLocal' ctor.SourceContext)))));  		statements.Add (new Return ());  	}  	else if (method.ReturnType == env.VoidType) {  		statements.Add (new ExpressionStatement (new MethodCall (new MemberBinding (runtimeExpr' env.Runtime_CallImportedMethodMethod)' new ExpressionList (methodBaseExpr' scriptExpr' argArray))));  		statements.Add (new ExpressionStatement (new UnaryExpression (null' NodeType.Pop)));  		statements.Add (new Return ());  	}  	else {  		statements.Add (new Return (CastExpression (new MethodCall (new MemberBinding (runtimeExpr' env.Runtime_CallImportedMethodMethod)' new ExpressionList (methodBaseExpr' scriptExpr' argArray))' method.ReturnType)));  	}  	TagAsInteropGenerated (method);  }  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ProcessMethod,The following statement contains a magic number: if (ctor != null) {  	var locals = ctor.LocalList;  	if (locals == null) {  		locals = new LocalList (2);  		ctor.LocalList = locals;  	}  	var constructorInfoLocal = new Local (Identifier.For ("ci")' env.SimpleMethodBaseType);  	locals.Add (constructorInfoLocal);  	var contextLocal = new Local (Identifier.For ("ctxt")' env.JSContextType);  	locals.Add (contextLocal);  	statements.Add (new AssignmentStatement (new LocalBinding (constructorInfoLocal' ctor.SourceContext)' methodBaseExpr));  	statements.Add (new AssignmentStatement (new LocalBinding (contextLocal' ctor.SourceContext)' CastExpression (new MethodCall (new MemberBinding (runtimeExpr' env.Runtime_CallImportedMethodMethod)' new ExpressionList (new LocalBinding (constructorInfoLocal' ctor.SourceContext)' scriptExpr' argArray))' env.JSContextType)));  	var importingCtor = BestImportingConstructor (ctor);  	var args = new ExpressionList (importingCtor.Parameters.Count);  	args.Add (new LocalBinding (contextLocal' ctor.SourceContext));  	if (importingCtor.Parameters.Count > 1) {  		for (var i = 0; i < ctor.Parameters.Count; i++)  			args.Add (new ParameterBinding (ctor.Parameters [i]' ctor.SourceContext));  	}  	statements.Add (new ExpressionStatement (new MethodCall (new MemberBinding (thisExpr' importingCtor)' args)));  	statements.Add (new ExpressionStatement (new MethodCall (new MemberBinding (runtimeExpr' env.Runtime_CompleteConstructionMethod)' new ExpressionList (new LocalBinding (constructorInfoLocal' ctor.SourceContext)' thisExpr' new LocalBinding (contextLocal' ctor.SourceContext)))));  	statements.Add (new Return ());  }  else if (method.ReturnType == env.VoidType) {  	statements.Add (new ExpressionStatement (new MethodCall (new MemberBinding (runtimeExpr' env.Runtime_CallImportedMethodMethod)' new ExpressionList (methodBaseExpr' scriptExpr' argArray))));  	statements.Add (new ExpressionStatement (new UnaryExpression (null' NodeType.Pop)));  	statements.Add (new Return ());  }  else {  	statements.Add (new Return (CastExpression (new MethodCall (new MemberBinding (runtimeExpr' env.Runtime_CallImportedMethodMethod)' new ExpressionList (methodBaseExpr' scriptExpr' argArray))' method.ReturnType)));  }  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ProcessMethod,The following statement contains a magic number: if (locals == null) {  	locals = new LocalList (2);  	ctor.LocalList = locals;  }  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ProcessMethod,The following statement contains a magic number: locals = new LocalList (2);  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ShimFullName,The following statement contains a magic number: if (match.Success) {  	prefix = match.Groups [1].Value;  	suffix = match.Groups [2].Value;  }  else {  	prefix = delegateFullName;  	suffix = "";  }  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Rewriter,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Rewriter.cs,ShimFullName,The following statement contains a magic number: suffix = match.Groups [2].Value;  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The following statement contains a magic number: if (methodDefn is CCI.InstanceInitializer) {  	// XREF1171  	// Constructor  	if (script == null) {  		switch (interopTypes.GetValue (ctxt' methodDefn' env.ImportAttributeType' interopTypes.TheCreationProperty)) {  		case Creation.Constructor:  			script = PrefixName (ctxt' methodDefn' null' false);  			break;  		case Creation.Object:  			if (methodArity > 0) {  				env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "imported constructors for object literals cannot have arguments"));  				throw new DefinitionException ();  			}  			script = Constants.Object.ToE ();  			break;  		case Creation.Array:  			script = Constants.Array.ToE ();  			break;  		default:  			throw new ArgumentOutOfRangeException ();  		}  		return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' true);  	}  	else if (script is JST.FunctionExpression)  		return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  	else {  		script = PrefixName (ctxt' methodDefn' script' false);  		return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' true);  	}  }  else {  	if (methodDefn.DeclaringMember != null) {  		var isOnMethod = interopTypes.HasAttribute (methodDefn' env.ImportAttributeType' false);  		var localScript = isOnMethod ? interopTypes.GetValue (ctxt' methodDefn' env.ImportAttributeType' interopTypes.TheScriptProperty' false) : default(JST.Expression);  		var prop = methodDefn.DeclaringMember as CCI.Property;  		if (prop != null) {  			// XREF1187  			if (methodDefn == prop.Getter) {  				// Getter  				if (isOnMethod) {  					script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "get"' localScript)' false);  					return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  				}  				else if (script != null && script is JST.FunctionExpression) {  					env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "property import script cannot be a function"));  					throw new DefinitionException ();  				}  				else {  					var function = default(JST.FunctionExpression);  					if (gensym != null) {  						var parameters = new Seq<JST.Identifier> ();  						var body = new Seq<JST.Statement> ();  						for (var i = 0; i < methodArity; i++)  							parameters.Add (gensym ());  						if (script == null && methodArity == 2 && !methodDefn.IsStatic)  							body.Add (new JST.ReturnStatement (new JST.IndexExpression (parameters [0].ToE ()' parameters [1].ToE ())));  						else {  							script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  							if (methodDefn.IsStatic && methodArity == 0)  								body.Add (new JST.ReturnStatement (script));  							else if (!methodDefn.IsStatic && methodArity == 1)  								body.Add (new JST.ReturnStatement (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))));  							else {  								env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional getter parameters not supported for default getters"));  								throw new DefinitionException ();  							}  						}  						function = new JST.FunctionExpression (parameters' new JST.Statements (body));  					}  					return new ImportMethodInfo {  						MethodDefn = methodDefn'  						Script = function  					};  				}  			}  			else if (methodDefn == prop.Setter) {  				// Setter  				if (isOnMethod) {  					script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "set"' localScript)' false);  					return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  				}  				else if (script != null && script is JST.FunctionExpression) {  					env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "property import script cannot be a function"));  					throw new DefinitionException ();  				}  				else {  					var function = default(JST.FunctionExpression);  					if (gensym != null) {  						var parameters = new Seq<JST.Identifier> ();  						var body = new Seq<JST.Statement> ();  						for (var i = 0; i < methodArity; i++)  							parameters.Add (gensym ());  						if (script == null && methodArity == 3 && !methodDefn.IsStatic)  							body.Add (JST.Statement.IndexAssignment (parameters [0].ToE ()' parameters [1].ToE ()' parameters [2].ToE ()));  						else {  							script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  							if (methodDefn.IsStatic && methodArity == 1)  								body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  							else if (!methodDefn.IsStatic && methodArity == 2)  								body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  							else {  								env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional setter parameters not supported for default setters"));  								throw new DefinitionException ();  							}  						}  						function = new JST.FunctionExpression (parameters' new JST.Statements (body));  					}  					return new ImportMethodInfo {  						MethodDefn = methodDefn'  						Script = function  					};  				}  			}  			else  				throw new InvalidOperationException ();  		}  		else {  			var evnt = methodDefn.DeclaringMember as CCI.Event;  			if (evnt != null) {  				// XREF1201  				if (methodDefn == evnt.HandlerAdder) {  					// Adder  					if (isOnMethod) {  						script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "add"' localScript)' false);  						return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  					}  					else if (script != null && script is JST.FunctionExpression) {  						env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "event import script cannot be a function"));  						throw new DefinitionException ();  					}  					else {  						var function = default(JST.FunctionExpression);  						if (gensym != null) {  							var parameters = new Seq<JST.Identifier> ();  							var body = new Seq<JST.Statement> ();  							for (var i = 0; i < methodArity; i++)  								parameters.Add (gensym ());  							script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  							if (methodDefn.IsStatic)  								body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  							else  								body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  							function = new JST.FunctionExpression (parameters' new JST.Statements (body));  						}  						return new ImportMethodInfo {  							MethodDefn = methodDefn'  							Script = function  						};  					}  				}  				else if (methodDefn == evnt.HandlerRemover) {  					// Remover  					if (isOnMethod) {  						script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "remove"' localScript)' false);  						return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  					}  					else if (script != null && script is JST.FunctionExpression) {  						env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "event import script cannot be a function"));  						throw new DefinitionException ();  					}  					else {  						var function = default(JST.FunctionExpression);  						if (gensym != null) {  							var parameters = new Seq<JST.Identifier> ();  							var body = new Seq<JST.Statement> ();  							for (var i = 0; i < methodArity; i++)  								parameters.Add (gensym ());  							script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  							if (methodDefn.IsStatic)  								body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  							else  								body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  							function = new JST.FunctionExpression (parameters' new JST.Statements (body));  						}  						return new ImportMethodInfo {  							MethodDefn = methodDefn'  							Script = function  						};  					}  				}  				else  					throw new InvalidOperationException ();  			}  			else  				throw new InvalidOperationException ();  		}  	}  	else {  		// XREF1153  		// Normal method  		script = PrefixName (ctxt' methodDefn' RecaseMember (ctxt' methodDefn' script)' false);  		return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The following statement contains a magic number: if (methodDefn is CCI.InstanceInitializer) {  	// XREF1171  	// Constructor  	if (script == null) {  		switch (interopTypes.GetValue (ctxt' methodDefn' env.ImportAttributeType' interopTypes.TheCreationProperty)) {  		case Creation.Constructor:  			script = PrefixName (ctxt' methodDefn' null' false);  			break;  		case Creation.Object:  			if (methodArity > 0) {  				env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "imported constructors for object literals cannot have arguments"));  				throw new DefinitionException ();  			}  			script = Constants.Object.ToE ();  			break;  		case Creation.Array:  			script = Constants.Array.ToE ();  			break;  		default:  			throw new ArgumentOutOfRangeException ();  		}  		return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' true);  	}  	else if (script is JST.FunctionExpression)  		return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  	else {  		script = PrefixName (ctxt' methodDefn' script' false);  		return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' true);  	}  }  else {  	if (methodDefn.DeclaringMember != null) {  		var isOnMethod = interopTypes.HasAttribute (methodDefn' env.ImportAttributeType' false);  		var localScript = isOnMethod ? interopTypes.GetValue (ctxt' methodDefn' env.ImportAttributeType' interopTypes.TheScriptProperty' false) : default(JST.Expression);  		var prop = methodDefn.DeclaringMember as CCI.Property;  		if (prop != null) {  			// XREF1187  			if (methodDefn == prop.Getter) {  				// Getter  				if (isOnMethod) {  					script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "get"' localScript)' false);  					return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  				}  				else if (script != null && script is JST.FunctionExpression) {  					env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "property import script cannot be a function"));  					throw new DefinitionException ();  				}  				else {  					var function = default(JST.FunctionExpression);  					if (gensym != null) {  						var parameters = new Seq<JST.Identifier> ();  						var body = new Seq<JST.Statement> ();  						for (var i = 0; i < methodArity; i++)  							parameters.Add (gensym ());  						if (script == null && methodArity == 2 && !methodDefn.IsStatic)  							body.Add (new JST.ReturnStatement (new JST.IndexExpression (parameters [0].ToE ()' parameters [1].ToE ())));  						else {  							script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  							if (methodDefn.IsStatic && methodArity == 0)  								body.Add (new JST.ReturnStatement (script));  							else if (!methodDefn.IsStatic && methodArity == 1)  								body.Add (new JST.ReturnStatement (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))));  							else {  								env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional getter parameters not supported for default getters"));  								throw new DefinitionException ();  							}  						}  						function = new JST.FunctionExpression (parameters' new JST.Statements (body));  					}  					return new ImportMethodInfo {  						MethodDefn = methodDefn'  						Script = function  					};  				}  			}  			else if (methodDefn == prop.Setter) {  				// Setter  				if (isOnMethod) {  					script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "set"' localScript)' false);  					return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  				}  				else if (script != null && script is JST.FunctionExpression) {  					env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "property import script cannot be a function"));  					throw new DefinitionException ();  				}  				else {  					var function = default(JST.FunctionExpression);  					if (gensym != null) {  						var parameters = new Seq<JST.Identifier> ();  						var body = new Seq<JST.Statement> ();  						for (var i = 0; i < methodArity; i++)  							parameters.Add (gensym ());  						if (script == null && methodArity == 3 && !methodDefn.IsStatic)  							body.Add (JST.Statement.IndexAssignment (parameters [0].ToE ()' parameters [1].ToE ()' parameters [2].ToE ()));  						else {  							script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  							if (methodDefn.IsStatic && methodArity == 1)  								body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  							else if (!methodDefn.IsStatic && methodArity == 2)  								body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  							else {  								env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional setter parameters not supported for default setters"));  								throw new DefinitionException ();  							}  						}  						function = new JST.FunctionExpression (parameters' new JST.Statements (body));  					}  					return new ImportMethodInfo {  						MethodDefn = methodDefn'  						Script = function  					};  				}  			}  			else  				throw new InvalidOperationException ();  		}  		else {  			var evnt = methodDefn.DeclaringMember as CCI.Event;  			if (evnt != null) {  				// XREF1201  				if (methodDefn == evnt.HandlerAdder) {  					// Adder  					if (isOnMethod) {  						script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "add"' localScript)' false);  						return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  					}  					else if (script != null && script is JST.FunctionExpression) {  						env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "event import script cannot be a function"));  						throw new DefinitionException ();  					}  					else {  						var function = default(JST.FunctionExpression);  						if (gensym != null) {  							var parameters = new Seq<JST.Identifier> ();  							var body = new Seq<JST.Statement> ();  							for (var i = 0; i < methodArity; i++)  								parameters.Add (gensym ());  							script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  							if (methodDefn.IsStatic)  								body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  							else  								body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  							function = new JST.FunctionExpression (parameters' new JST.Statements (body));  						}  						return new ImportMethodInfo {  							MethodDefn = methodDefn'  							Script = function  						};  					}  				}  				else if (methodDefn == evnt.HandlerRemover) {  					// Remover  					if (isOnMethod) {  						script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "remove"' localScript)' false);  						return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  					}  					else if (script != null && script is JST.FunctionExpression) {  						env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "event import script cannot be a function"));  						throw new DefinitionException ();  					}  					else {  						var function = default(JST.FunctionExpression);  						if (gensym != null) {  							var parameters = new Seq<JST.Identifier> ();  							var body = new Seq<JST.Statement> ();  							for (var i = 0; i < methodArity; i++)  								parameters.Add (gensym ());  							script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  							if (methodDefn.IsStatic)  								body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  							else  								body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  							function = new JST.FunctionExpression (parameters' new JST.Statements (body));  						}  						return new ImportMethodInfo {  							MethodDefn = methodDefn'  							Script = function  						};  					}  				}  				else  					throw new InvalidOperationException ();  			}  			else  				throw new InvalidOperationException ();  		}  	}  	else {  		// XREF1153  		// Normal method  		script = PrefixName (ctxt' methodDefn' RecaseMember (ctxt' methodDefn' script)' false);  		return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The following statement contains a magic number: if (methodDefn is CCI.InstanceInitializer) {  	// XREF1171  	// Constructor  	if (script == null) {  		switch (interopTypes.GetValue (ctxt' methodDefn' env.ImportAttributeType' interopTypes.TheCreationProperty)) {  		case Creation.Constructor:  			script = PrefixName (ctxt' methodDefn' null' false);  			break;  		case Creation.Object:  			if (methodArity > 0) {  				env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "imported constructors for object literals cannot have arguments"));  				throw new DefinitionException ();  			}  			script = Constants.Object.ToE ();  			break;  		case Creation.Array:  			script = Constants.Array.ToE ();  			break;  		default:  			throw new ArgumentOutOfRangeException ();  		}  		return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' true);  	}  	else if (script is JST.FunctionExpression)  		return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  	else {  		script = PrefixName (ctxt' methodDefn' script' false);  		return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' true);  	}  }  else {  	if (methodDefn.DeclaringMember != null) {  		var isOnMethod = interopTypes.HasAttribute (methodDefn' env.ImportAttributeType' false);  		var localScript = isOnMethod ? interopTypes.GetValue (ctxt' methodDefn' env.ImportAttributeType' interopTypes.TheScriptProperty' false) : default(JST.Expression);  		var prop = methodDefn.DeclaringMember as CCI.Property;  		if (prop != null) {  			// XREF1187  			if (methodDefn == prop.Getter) {  				// Getter  				if (isOnMethod) {  					script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "get"' localScript)' false);  					return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  				}  				else if (script != null && script is JST.FunctionExpression) {  					env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "property import script cannot be a function"));  					throw new DefinitionException ();  				}  				else {  					var function = default(JST.FunctionExpression);  					if (gensym != null) {  						var parameters = new Seq<JST.Identifier> ();  						var body = new Seq<JST.Statement> ();  						for (var i = 0; i < methodArity; i++)  							parameters.Add (gensym ());  						if (script == null && methodArity == 2 && !methodDefn.IsStatic)  							body.Add (new JST.ReturnStatement (new JST.IndexExpression (parameters [0].ToE ()' parameters [1].ToE ())));  						else {  							script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  							if (methodDefn.IsStatic && methodArity == 0)  								body.Add (new JST.ReturnStatement (script));  							else if (!methodDefn.IsStatic && methodArity == 1)  								body.Add (new JST.ReturnStatement (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))));  							else {  								env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional getter parameters not supported for default getters"));  								throw new DefinitionException ();  							}  						}  						function = new JST.FunctionExpression (parameters' new JST.Statements (body));  					}  					return new ImportMethodInfo {  						MethodDefn = methodDefn'  						Script = function  					};  				}  			}  			else if (methodDefn == prop.Setter) {  				// Setter  				if (isOnMethod) {  					script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "set"' localScript)' false);  					return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  				}  				else if (script != null && script is JST.FunctionExpression) {  					env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "property import script cannot be a function"));  					throw new DefinitionException ();  				}  				else {  					var function = default(JST.FunctionExpression);  					if (gensym != null) {  						var parameters = new Seq<JST.Identifier> ();  						var body = new Seq<JST.Statement> ();  						for (var i = 0; i < methodArity; i++)  							parameters.Add (gensym ());  						if (script == null && methodArity == 3 && !methodDefn.IsStatic)  							body.Add (JST.Statement.IndexAssignment (parameters [0].ToE ()' parameters [1].ToE ()' parameters [2].ToE ()));  						else {  							script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  							if (methodDefn.IsStatic && methodArity == 1)  								body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  							else if (!methodDefn.IsStatic && methodArity == 2)  								body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  							else {  								env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional setter parameters not supported for default setters"));  								throw new DefinitionException ();  							}  						}  						function = new JST.FunctionExpression (parameters' new JST.Statements (body));  					}  					return new ImportMethodInfo {  						MethodDefn = methodDefn'  						Script = function  					};  				}  			}  			else  				throw new InvalidOperationException ();  		}  		else {  			var evnt = methodDefn.DeclaringMember as CCI.Event;  			if (evnt != null) {  				// XREF1201  				if (methodDefn == evnt.HandlerAdder) {  					// Adder  					if (isOnMethod) {  						script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "add"' localScript)' false);  						return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  					}  					else if (script != null && script is JST.FunctionExpression) {  						env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "event import script cannot be a function"));  						throw new DefinitionException ();  					}  					else {  						var function = default(JST.FunctionExpression);  						if (gensym != null) {  							var parameters = new Seq<JST.Identifier> ();  							var body = new Seq<JST.Statement> ();  							for (var i = 0; i < methodArity; i++)  								parameters.Add (gensym ());  							script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  							if (methodDefn.IsStatic)  								body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  							else  								body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  							function = new JST.FunctionExpression (parameters' new JST.Statements (body));  						}  						return new ImportMethodInfo {  							MethodDefn = methodDefn'  							Script = function  						};  					}  				}  				else if (methodDefn == evnt.HandlerRemover) {  					// Remover  					if (isOnMethod) {  						script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "remove"' localScript)' false);  						return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  					}  					else if (script != null && script is JST.FunctionExpression) {  						env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "event import script cannot be a function"));  						throw new DefinitionException ();  					}  					else {  						var function = default(JST.FunctionExpression);  						if (gensym != null) {  							var parameters = new Seq<JST.Identifier> ();  							var body = new Seq<JST.Statement> ();  							for (var i = 0; i < methodArity; i++)  								parameters.Add (gensym ());  							script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  							if (methodDefn.IsStatic)  								body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  							else  								body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  							function = new JST.FunctionExpression (parameters' new JST.Statements (body));  						}  						return new ImportMethodInfo {  							MethodDefn = methodDefn'  							Script = function  						};  					}  				}  				else  					throw new InvalidOperationException ();  			}  			else  				throw new InvalidOperationException ();  		}  	}  	else {  		// XREF1153  		// Normal method  		script = PrefixName (ctxt' methodDefn' RecaseMember (ctxt' methodDefn' script)' false);  		return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The following statement contains a magic number: if (methodDefn is CCI.InstanceInitializer) {  	// XREF1171  	// Constructor  	if (script == null) {  		switch (interopTypes.GetValue (ctxt' methodDefn' env.ImportAttributeType' interopTypes.TheCreationProperty)) {  		case Creation.Constructor:  			script = PrefixName (ctxt' methodDefn' null' false);  			break;  		case Creation.Object:  			if (methodArity > 0) {  				env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "imported constructors for object literals cannot have arguments"));  				throw new DefinitionException ();  			}  			script = Constants.Object.ToE ();  			break;  		case Creation.Array:  			script = Constants.Array.ToE ();  			break;  		default:  			throw new ArgumentOutOfRangeException ();  		}  		return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' true);  	}  	else if (script is JST.FunctionExpression)  		return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  	else {  		script = PrefixName (ctxt' methodDefn' script' false);  		return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' true);  	}  }  else {  	if (methodDefn.DeclaringMember != null) {  		var isOnMethod = interopTypes.HasAttribute (methodDefn' env.ImportAttributeType' false);  		var localScript = isOnMethod ? interopTypes.GetValue (ctxt' methodDefn' env.ImportAttributeType' interopTypes.TheScriptProperty' false) : default(JST.Expression);  		var prop = methodDefn.DeclaringMember as CCI.Property;  		if (prop != null) {  			// XREF1187  			if (methodDefn == prop.Getter) {  				// Getter  				if (isOnMethod) {  					script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "get"' localScript)' false);  					return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  				}  				else if (script != null && script is JST.FunctionExpression) {  					env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "property import script cannot be a function"));  					throw new DefinitionException ();  				}  				else {  					var function = default(JST.FunctionExpression);  					if (gensym != null) {  						var parameters = new Seq<JST.Identifier> ();  						var body = new Seq<JST.Statement> ();  						for (var i = 0; i < methodArity; i++)  							parameters.Add (gensym ());  						if (script == null && methodArity == 2 && !methodDefn.IsStatic)  							body.Add (new JST.ReturnStatement (new JST.IndexExpression (parameters [0].ToE ()' parameters [1].ToE ())));  						else {  							script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  							if (methodDefn.IsStatic && methodArity == 0)  								body.Add (new JST.ReturnStatement (script));  							else if (!methodDefn.IsStatic && methodArity == 1)  								body.Add (new JST.ReturnStatement (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))));  							else {  								env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional getter parameters not supported for default getters"));  								throw new DefinitionException ();  							}  						}  						function = new JST.FunctionExpression (parameters' new JST.Statements (body));  					}  					return new ImportMethodInfo {  						MethodDefn = methodDefn'  						Script = function  					};  				}  			}  			else if (methodDefn == prop.Setter) {  				// Setter  				if (isOnMethod) {  					script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "set"' localScript)' false);  					return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  				}  				else if (script != null && script is JST.FunctionExpression) {  					env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "property import script cannot be a function"));  					throw new DefinitionException ();  				}  				else {  					var function = default(JST.FunctionExpression);  					if (gensym != null) {  						var parameters = new Seq<JST.Identifier> ();  						var body = new Seq<JST.Statement> ();  						for (var i = 0; i < methodArity; i++)  							parameters.Add (gensym ());  						if (script == null && methodArity == 3 && !methodDefn.IsStatic)  							body.Add (JST.Statement.IndexAssignment (parameters [0].ToE ()' parameters [1].ToE ()' parameters [2].ToE ()));  						else {  							script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  							if (methodDefn.IsStatic && methodArity == 1)  								body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  							else if (!methodDefn.IsStatic && methodArity == 2)  								body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  							else {  								env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional setter parameters not supported for default setters"));  								throw new DefinitionException ();  							}  						}  						function = new JST.FunctionExpression (parameters' new JST.Statements (body));  					}  					return new ImportMethodInfo {  						MethodDefn = methodDefn'  						Script = function  					};  				}  			}  			else  				throw new InvalidOperationException ();  		}  		else {  			var evnt = methodDefn.DeclaringMember as CCI.Event;  			if (evnt != null) {  				// XREF1201  				if (methodDefn == evnt.HandlerAdder) {  					// Adder  					if (isOnMethod) {  						script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "add"' localScript)' false);  						return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  					}  					else if (script != null && script is JST.FunctionExpression) {  						env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "event import script cannot be a function"));  						throw new DefinitionException ();  					}  					else {  						var function = default(JST.FunctionExpression);  						if (gensym != null) {  							var parameters = new Seq<JST.Identifier> ();  							var body = new Seq<JST.Statement> ();  							for (var i = 0; i < methodArity; i++)  								parameters.Add (gensym ());  							script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  							if (methodDefn.IsStatic)  								body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  							else  								body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  							function = new JST.FunctionExpression (parameters' new JST.Statements (body));  						}  						return new ImportMethodInfo {  							MethodDefn = methodDefn'  							Script = function  						};  					}  				}  				else if (methodDefn == evnt.HandlerRemover) {  					// Remover  					if (isOnMethod) {  						script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "remove"' localScript)' false);  						return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  					}  					else if (script != null && script is JST.FunctionExpression) {  						env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "event import script cannot be a function"));  						throw new DefinitionException ();  					}  					else {  						var function = default(JST.FunctionExpression);  						if (gensym != null) {  							var parameters = new Seq<JST.Identifier> ();  							var body = new Seq<JST.Statement> ();  							for (var i = 0; i < methodArity; i++)  								parameters.Add (gensym ());  							script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  							if (methodDefn.IsStatic)  								body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  							else  								body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  							function = new JST.FunctionExpression (parameters' new JST.Statements (body));  						}  						return new ImportMethodInfo {  							MethodDefn = methodDefn'  							Script = function  						};  					}  				}  				else  					throw new InvalidOperationException ();  			}  			else  				throw new InvalidOperationException ();  		}  	}  	else {  		// XREF1153  		// Normal method  		script = PrefixName (ctxt' methodDefn' RecaseMember (ctxt' methodDefn' script)' false);  		return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The following statement contains a magic number: if (methodDefn.DeclaringMember != null) {  	var isOnMethod = interopTypes.HasAttribute (methodDefn' env.ImportAttributeType' false);  	var localScript = isOnMethod ? interopTypes.GetValue (ctxt' methodDefn' env.ImportAttributeType' interopTypes.TheScriptProperty' false) : default(JST.Expression);  	var prop = methodDefn.DeclaringMember as CCI.Property;  	if (prop != null) {  		// XREF1187  		if (methodDefn == prop.Getter) {  			// Getter  			if (isOnMethod) {  				script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "get"' localScript)' false);  				return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  			}  			else if (script != null && script is JST.FunctionExpression) {  				env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "property import script cannot be a function"));  				throw new DefinitionException ();  			}  			else {  				var function = default(JST.FunctionExpression);  				if (gensym != null) {  					var parameters = new Seq<JST.Identifier> ();  					var body = new Seq<JST.Statement> ();  					for (var i = 0; i < methodArity; i++)  						parameters.Add (gensym ());  					if (script == null && methodArity == 2 && !methodDefn.IsStatic)  						body.Add (new JST.ReturnStatement (new JST.IndexExpression (parameters [0].ToE ()' parameters [1].ToE ())));  					else {  						script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  						if (methodDefn.IsStatic && methodArity == 0)  							body.Add (new JST.ReturnStatement (script));  						else if (!methodDefn.IsStatic && methodArity == 1)  							body.Add (new JST.ReturnStatement (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))));  						else {  							env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional getter parameters not supported for default getters"));  							throw new DefinitionException ();  						}  					}  					function = new JST.FunctionExpression (parameters' new JST.Statements (body));  				}  				return new ImportMethodInfo {  					MethodDefn = methodDefn'  					Script = function  				};  			}  		}  		else if (methodDefn == prop.Setter) {  			// Setter  			if (isOnMethod) {  				script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "set"' localScript)' false);  				return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  			}  			else if (script != null && script is JST.FunctionExpression) {  				env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "property import script cannot be a function"));  				throw new DefinitionException ();  			}  			else {  				var function = default(JST.FunctionExpression);  				if (gensym != null) {  					var parameters = new Seq<JST.Identifier> ();  					var body = new Seq<JST.Statement> ();  					for (var i = 0; i < methodArity; i++)  						parameters.Add (gensym ());  					if (script == null && methodArity == 3 && !methodDefn.IsStatic)  						body.Add (JST.Statement.IndexAssignment (parameters [0].ToE ()' parameters [1].ToE ()' parameters [2].ToE ()));  					else {  						script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  						if (methodDefn.IsStatic && methodArity == 1)  							body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  						else if (!methodDefn.IsStatic && methodArity == 2)  							body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  						else {  							env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional setter parameters not supported for default setters"));  							throw new DefinitionException ();  						}  					}  					function = new JST.FunctionExpression (parameters' new JST.Statements (body));  				}  				return new ImportMethodInfo {  					MethodDefn = methodDefn'  					Script = function  				};  			}  		}  		else  			throw new InvalidOperationException ();  	}  	else {  		var evnt = methodDefn.DeclaringMember as CCI.Event;  		if (evnt != null) {  			// XREF1201  			if (methodDefn == evnt.HandlerAdder) {  				// Adder  				if (isOnMethod) {  					script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "add"' localScript)' false);  					return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  				}  				else if (script != null && script is JST.FunctionExpression) {  					env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "event import script cannot be a function"));  					throw new DefinitionException ();  				}  				else {  					var function = default(JST.FunctionExpression);  					if (gensym != null) {  						var parameters = new Seq<JST.Identifier> ();  						var body = new Seq<JST.Statement> ();  						for (var i = 0; i < methodArity; i++)  							parameters.Add (gensym ());  						script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  						if (methodDefn.IsStatic)  							body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  						else  							body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  						function = new JST.FunctionExpression (parameters' new JST.Statements (body));  					}  					return new ImportMethodInfo {  						MethodDefn = methodDefn'  						Script = function  					};  				}  			}  			else if (methodDefn == evnt.HandlerRemover) {  				// Remover  				if (isOnMethod) {  					script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "remove"' localScript)' false);  					return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  				}  				else if (script != null && script is JST.FunctionExpression) {  					env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "event import script cannot be a function"));  					throw new DefinitionException ();  				}  				else {  					var function = default(JST.FunctionExpression);  					if (gensym != null) {  						var parameters = new Seq<JST.Identifier> ();  						var body = new Seq<JST.Statement> ();  						for (var i = 0; i < methodArity; i++)  							parameters.Add (gensym ());  						script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  						if (methodDefn.IsStatic)  							body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  						else  							body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  						function = new JST.FunctionExpression (parameters' new JST.Statements (body));  					}  					return new ImportMethodInfo {  						MethodDefn = methodDefn'  						Script = function  					};  				}  			}  			else  				throw new InvalidOperationException ();  		}  		else  			throw new InvalidOperationException ();  	}  }  else {  	// XREF1153  	// Normal method  	script = PrefixName (ctxt' methodDefn' RecaseMember (ctxt' methodDefn' script)' false);  	return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  }  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The following statement contains a magic number: if (methodDefn.DeclaringMember != null) {  	var isOnMethod = interopTypes.HasAttribute (methodDefn' env.ImportAttributeType' false);  	var localScript = isOnMethod ? interopTypes.GetValue (ctxt' methodDefn' env.ImportAttributeType' interopTypes.TheScriptProperty' false) : default(JST.Expression);  	var prop = methodDefn.DeclaringMember as CCI.Property;  	if (prop != null) {  		// XREF1187  		if (methodDefn == prop.Getter) {  			// Getter  			if (isOnMethod) {  				script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "get"' localScript)' false);  				return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  			}  			else if (script != null && script is JST.FunctionExpression) {  				env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "property import script cannot be a function"));  				throw new DefinitionException ();  			}  			else {  				var function = default(JST.FunctionExpression);  				if (gensym != null) {  					var parameters = new Seq<JST.Identifier> ();  					var body = new Seq<JST.Statement> ();  					for (var i = 0; i < methodArity; i++)  						parameters.Add (gensym ());  					if (script == null && methodArity == 2 && !methodDefn.IsStatic)  						body.Add (new JST.ReturnStatement (new JST.IndexExpression (parameters [0].ToE ()' parameters [1].ToE ())));  					else {  						script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  						if (methodDefn.IsStatic && methodArity == 0)  							body.Add (new JST.ReturnStatement (script));  						else if (!methodDefn.IsStatic && methodArity == 1)  							body.Add (new JST.ReturnStatement (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))));  						else {  							env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional getter parameters not supported for default getters"));  							throw new DefinitionException ();  						}  					}  					function = new JST.FunctionExpression (parameters' new JST.Statements (body));  				}  				return new ImportMethodInfo {  					MethodDefn = methodDefn'  					Script = function  				};  			}  		}  		else if (methodDefn == prop.Setter) {  			// Setter  			if (isOnMethod) {  				script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "set"' localScript)' false);  				return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  			}  			else if (script != null && script is JST.FunctionExpression) {  				env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "property import script cannot be a function"));  				throw new DefinitionException ();  			}  			else {  				var function = default(JST.FunctionExpression);  				if (gensym != null) {  					var parameters = new Seq<JST.Identifier> ();  					var body = new Seq<JST.Statement> ();  					for (var i = 0; i < methodArity; i++)  						parameters.Add (gensym ());  					if (script == null && methodArity == 3 && !methodDefn.IsStatic)  						body.Add (JST.Statement.IndexAssignment (parameters [0].ToE ()' parameters [1].ToE ()' parameters [2].ToE ()));  					else {  						script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  						if (methodDefn.IsStatic && methodArity == 1)  							body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  						else if (!methodDefn.IsStatic && methodArity == 2)  							body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  						else {  							env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional setter parameters not supported for default setters"));  							throw new DefinitionException ();  						}  					}  					function = new JST.FunctionExpression (parameters' new JST.Statements (body));  				}  				return new ImportMethodInfo {  					MethodDefn = methodDefn'  					Script = function  				};  			}  		}  		else  			throw new InvalidOperationException ();  	}  	else {  		var evnt = methodDefn.DeclaringMember as CCI.Event;  		if (evnt != null) {  			// XREF1201  			if (methodDefn == evnt.HandlerAdder) {  				// Adder  				if (isOnMethod) {  					script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "add"' localScript)' false);  					return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  				}  				else if (script != null && script is JST.FunctionExpression) {  					env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "event import script cannot be a function"));  					throw new DefinitionException ();  				}  				else {  					var function = default(JST.FunctionExpression);  					if (gensym != null) {  						var parameters = new Seq<JST.Identifier> ();  						var body = new Seq<JST.Statement> ();  						for (var i = 0; i < methodArity; i++)  							parameters.Add (gensym ());  						script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  						if (methodDefn.IsStatic)  							body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  						else  							body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  						function = new JST.FunctionExpression (parameters' new JST.Statements (body));  					}  					return new ImportMethodInfo {  						MethodDefn = methodDefn'  						Script = function  					};  				}  			}  			else if (methodDefn == evnt.HandlerRemover) {  				// Remover  				if (isOnMethod) {  					script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "remove"' localScript)' false);  					return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  				}  				else if (script != null && script is JST.FunctionExpression) {  					env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "event import script cannot be a function"));  					throw new DefinitionException ();  				}  				else {  					var function = default(JST.FunctionExpression);  					if (gensym != null) {  						var parameters = new Seq<JST.Identifier> ();  						var body = new Seq<JST.Statement> ();  						for (var i = 0; i < methodArity; i++)  							parameters.Add (gensym ());  						script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  						if (methodDefn.IsStatic)  							body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  						else  							body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  						function = new JST.FunctionExpression (parameters' new JST.Statements (body));  					}  					return new ImportMethodInfo {  						MethodDefn = methodDefn'  						Script = function  					};  				}  			}  			else  				throw new InvalidOperationException ();  		}  		else  			throw new InvalidOperationException ();  	}  }  else {  	// XREF1153  	// Normal method  	script = PrefixName (ctxt' methodDefn' RecaseMember (ctxt' methodDefn' script)' false);  	return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  }  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The following statement contains a magic number: if (methodDefn.DeclaringMember != null) {  	var isOnMethod = interopTypes.HasAttribute (methodDefn' env.ImportAttributeType' false);  	var localScript = isOnMethod ? interopTypes.GetValue (ctxt' methodDefn' env.ImportAttributeType' interopTypes.TheScriptProperty' false) : default(JST.Expression);  	var prop = methodDefn.DeclaringMember as CCI.Property;  	if (prop != null) {  		// XREF1187  		if (methodDefn == prop.Getter) {  			// Getter  			if (isOnMethod) {  				script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "get"' localScript)' false);  				return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  			}  			else if (script != null && script is JST.FunctionExpression) {  				env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "property import script cannot be a function"));  				throw new DefinitionException ();  			}  			else {  				var function = default(JST.FunctionExpression);  				if (gensym != null) {  					var parameters = new Seq<JST.Identifier> ();  					var body = new Seq<JST.Statement> ();  					for (var i = 0; i < methodArity; i++)  						parameters.Add (gensym ());  					if (script == null && methodArity == 2 && !methodDefn.IsStatic)  						body.Add (new JST.ReturnStatement (new JST.IndexExpression (parameters [0].ToE ()' parameters [1].ToE ())));  					else {  						script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  						if (methodDefn.IsStatic && methodArity == 0)  							body.Add (new JST.ReturnStatement (script));  						else if (!methodDefn.IsStatic && methodArity == 1)  							body.Add (new JST.ReturnStatement (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))));  						else {  							env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional getter parameters not supported for default getters"));  							throw new DefinitionException ();  						}  					}  					function = new JST.FunctionExpression (parameters' new JST.Statements (body));  				}  				return new ImportMethodInfo {  					MethodDefn = methodDefn'  					Script = function  				};  			}  		}  		else if (methodDefn == prop.Setter) {  			// Setter  			if (isOnMethod) {  				script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "set"' localScript)' false);  				return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  			}  			else if (script != null && script is JST.FunctionExpression) {  				env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "property import script cannot be a function"));  				throw new DefinitionException ();  			}  			else {  				var function = default(JST.FunctionExpression);  				if (gensym != null) {  					var parameters = new Seq<JST.Identifier> ();  					var body = new Seq<JST.Statement> ();  					for (var i = 0; i < methodArity; i++)  						parameters.Add (gensym ());  					if (script == null && methodArity == 3 && !methodDefn.IsStatic)  						body.Add (JST.Statement.IndexAssignment (parameters [0].ToE ()' parameters [1].ToE ()' parameters [2].ToE ()));  					else {  						script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  						if (methodDefn.IsStatic && methodArity == 1)  							body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  						else if (!methodDefn.IsStatic && methodArity == 2)  							body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  						else {  							env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional setter parameters not supported for default setters"));  							throw new DefinitionException ();  						}  					}  					function = new JST.FunctionExpression (parameters' new JST.Statements (body));  				}  				return new ImportMethodInfo {  					MethodDefn = methodDefn'  					Script = function  				};  			}  		}  		else  			throw new InvalidOperationException ();  	}  	else {  		var evnt = methodDefn.DeclaringMember as CCI.Event;  		if (evnt != null) {  			// XREF1201  			if (methodDefn == evnt.HandlerAdder) {  				// Adder  				if (isOnMethod) {  					script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "add"' localScript)' false);  					return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  				}  				else if (script != null && script is JST.FunctionExpression) {  					env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "event import script cannot be a function"));  					throw new DefinitionException ();  				}  				else {  					var function = default(JST.FunctionExpression);  					if (gensym != null) {  						var parameters = new Seq<JST.Identifier> ();  						var body = new Seq<JST.Statement> ();  						for (var i = 0; i < methodArity; i++)  							parameters.Add (gensym ());  						script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  						if (methodDefn.IsStatic)  							body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  						else  							body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  						function = new JST.FunctionExpression (parameters' new JST.Statements (body));  					}  					return new ImportMethodInfo {  						MethodDefn = methodDefn'  						Script = function  					};  				}  			}  			else if (methodDefn == evnt.HandlerRemover) {  				// Remover  				if (isOnMethod) {  					script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "remove"' localScript)' false);  					return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  				}  				else if (script != null && script is JST.FunctionExpression) {  					env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "event import script cannot be a function"));  					throw new DefinitionException ();  				}  				else {  					var function = default(JST.FunctionExpression);  					if (gensym != null) {  						var parameters = new Seq<JST.Identifier> ();  						var body = new Seq<JST.Statement> ();  						for (var i = 0; i < methodArity; i++)  							parameters.Add (gensym ());  						script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  						if (methodDefn.IsStatic)  							body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  						else  							body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  						function = new JST.FunctionExpression (parameters' new JST.Statements (body));  					}  					return new ImportMethodInfo {  						MethodDefn = methodDefn'  						Script = function  					};  				}  			}  			else  				throw new InvalidOperationException ();  		}  		else  			throw new InvalidOperationException ();  	}  }  else {  	// XREF1153  	// Normal method  	script = PrefixName (ctxt' methodDefn' RecaseMember (ctxt' methodDefn' script)' false);  	return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  }  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The following statement contains a magic number: if (methodDefn.DeclaringMember != null) {  	var isOnMethod = interopTypes.HasAttribute (methodDefn' env.ImportAttributeType' false);  	var localScript = isOnMethod ? interopTypes.GetValue (ctxt' methodDefn' env.ImportAttributeType' interopTypes.TheScriptProperty' false) : default(JST.Expression);  	var prop = methodDefn.DeclaringMember as CCI.Property;  	if (prop != null) {  		// XREF1187  		if (methodDefn == prop.Getter) {  			// Getter  			if (isOnMethod) {  				script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "get"' localScript)' false);  				return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  			}  			else if (script != null && script is JST.FunctionExpression) {  				env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "property import script cannot be a function"));  				throw new DefinitionException ();  			}  			else {  				var function = default(JST.FunctionExpression);  				if (gensym != null) {  					var parameters = new Seq<JST.Identifier> ();  					var body = new Seq<JST.Statement> ();  					for (var i = 0; i < methodArity; i++)  						parameters.Add (gensym ());  					if (script == null && methodArity == 2 && !methodDefn.IsStatic)  						body.Add (new JST.ReturnStatement (new JST.IndexExpression (parameters [0].ToE ()' parameters [1].ToE ())));  					else {  						script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  						if (methodDefn.IsStatic && methodArity == 0)  							body.Add (new JST.ReturnStatement (script));  						else if (!methodDefn.IsStatic && methodArity == 1)  							body.Add (new JST.ReturnStatement (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))));  						else {  							env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional getter parameters not supported for default getters"));  							throw new DefinitionException ();  						}  					}  					function = new JST.FunctionExpression (parameters' new JST.Statements (body));  				}  				return new ImportMethodInfo {  					MethodDefn = methodDefn'  					Script = function  				};  			}  		}  		else if (methodDefn == prop.Setter) {  			// Setter  			if (isOnMethod) {  				script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "set"' localScript)' false);  				return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  			}  			else if (script != null && script is JST.FunctionExpression) {  				env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "property import script cannot be a function"));  				throw new DefinitionException ();  			}  			else {  				var function = default(JST.FunctionExpression);  				if (gensym != null) {  					var parameters = new Seq<JST.Identifier> ();  					var body = new Seq<JST.Statement> ();  					for (var i = 0; i < methodArity; i++)  						parameters.Add (gensym ());  					if (script == null && methodArity == 3 && !methodDefn.IsStatic)  						body.Add (JST.Statement.IndexAssignment (parameters [0].ToE ()' parameters [1].ToE ()' parameters [2].ToE ()));  					else {  						script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  						if (methodDefn.IsStatic && methodArity == 1)  							body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  						else if (!methodDefn.IsStatic && methodArity == 2)  							body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  						else {  							env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional setter parameters not supported for default setters"));  							throw new DefinitionException ();  						}  					}  					function = new JST.FunctionExpression (parameters' new JST.Statements (body));  				}  				return new ImportMethodInfo {  					MethodDefn = methodDefn'  					Script = function  				};  			}  		}  		else  			throw new InvalidOperationException ();  	}  	else {  		var evnt = methodDefn.DeclaringMember as CCI.Event;  		if (evnt != null) {  			// XREF1201  			if (methodDefn == evnt.HandlerAdder) {  				// Adder  				if (isOnMethod) {  					script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "add"' localScript)' false);  					return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  				}  				else if (script != null && script is JST.FunctionExpression) {  					env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "event import script cannot be a function"));  					throw new DefinitionException ();  				}  				else {  					var function = default(JST.FunctionExpression);  					if (gensym != null) {  						var parameters = new Seq<JST.Identifier> ();  						var body = new Seq<JST.Statement> ();  						for (var i = 0; i < methodArity; i++)  							parameters.Add (gensym ());  						script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  						if (methodDefn.IsStatic)  							body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  						else  							body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  						function = new JST.FunctionExpression (parameters' new JST.Statements (body));  					}  					return new ImportMethodInfo {  						MethodDefn = methodDefn'  						Script = function  					};  				}  			}  			else if (methodDefn == evnt.HandlerRemover) {  				// Remover  				if (isOnMethod) {  					script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "remove"' localScript)' false);  					return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  				}  				else if (script != null && script is JST.FunctionExpression) {  					env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "event import script cannot be a function"));  					throw new DefinitionException ();  				}  				else {  					var function = default(JST.FunctionExpression);  					if (gensym != null) {  						var parameters = new Seq<JST.Identifier> ();  						var body = new Seq<JST.Statement> ();  						for (var i = 0; i < methodArity; i++)  							parameters.Add (gensym ());  						script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  						if (methodDefn.IsStatic)  							body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  						else  							body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  						function = new JST.FunctionExpression (parameters' new JST.Statements (body));  					}  					return new ImportMethodInfo {  						MethodDefn = methodDefn'  						Script = function  					};  				}  			}  			else  				throw new InvalidOperationException ();  		}  		else  			throw new InvalidOperationException ();  	}  }  else {  	// XREF1153  	// Normal method  	script = PrefixName (ctxt' methodDefn' RecaseMember (ctxt' methodDefn' script)' false);  	return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  }  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The following statement contains a magic number: if (prop != null) {  	// XREF1187  	if (methodDefn == prop.Getter) {  		// Getter  		if (isOnMethod) {  			script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "get"' localScript)' false);  			return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  		}  		else if (script != null && script is JST.FunctionExpression) {  			env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "property import script cannot be a function"));  			throw new DefinitionException ();  		}  		else {  			var function = default(JST.FunctionExpression);  			if (gensym != null) {  				var parameters = new Seq<JST.Identifier> ();  				var body = new Seq<JST.Statement> ();  				for (var i = 0; i < methodArity; i++)  					parameters.Add (gensym ());  				if (script == null && methodArity == 2 && !methodDefn.IsStatic)  					body.Add (new JST.ReturnStatement (new JST.IndexExpression (parameters [0].ToE ()' parameters [1].ToE ())));  				else {  					script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  					if (methodDefn.IsStatic && methodArity == 0)  						body.Add (new JST.ReturnStatement (script));  					else if (!methodDefn.IsStatic && methodArity == 1)  						body.Add (new JST.ReturnStatement (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))));  					else {  						env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional getter parameters not supported for default getters"));  						throw new DefinitionException ();  					}  				}  				function = new JST.FunctionExpression (parameters' new JST.Statements (body));  			}  			return new ImportMethodInfo {  				MethodDefn = methodDefn'  				Script = function  			};  		}  	}  	else if (methodDefn == prop.Setter) {  		// Setter  		if (isOnMethod) {  			script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "set"' localScript)' false);  			return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  		}  		else if (script != null && script is JST.FunctionExpression) {  			env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "property import script cannot be a function"));  			throw new DefinitionException ();  		}  		else {  			var function = default(JST.FunctionExpression);  			if (gensym != null) {  				var parameters = new Seq<JST.Identifier> ();  				var body = new Seq<JST.Statement> ();  				for (var i = 0; i < methodArity; i++)  					parameters.Add (gensym ());  				if (script == null && methodArity == 3 && !methodDefn.IsStatic)  					body.Add (JST.Statement.IndexAssignment (parameters [0].ToE ()' parameters [1].ToE ()' parameters [2].ToE ()));  				else {  					script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  					if (methodDefn.IsStatic && methodArity == 1)  						body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  					else if (!methodDefn.IsStatic && methodArity == 2)  						body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  					else {  						env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional setter parameters not supported for default setters"));  						throw new DefinitionException ();  					}  				}  				function = new JST.FunctionExpression (parameters' new JST.Statements (body));  			}  			return new ImportMethodInfo {  				MethodDefn = methodDefn'  				Script = function  			};  		}  	}  	else  		throw new InvalidOperationException ();  }  else {  	var evnt = methodDefn.DeclaringMember as CCI.Event;  	if (evnt != null) {  		// XREF1201  		if (methodDefn == evnt.HandlerAdder) {  			// Adder  			if (isOnMethod) {  				script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "add"' localScript)' false);  				return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  			}  			else if (script != null && script is JST.FunctionExpression) {  				env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "event import script cannot be a function"));  				throw new DefinitionException ();  			}  			else {  				var function = default(JST.FunctionExpression);  				if (gensym != null) {  					var parameters = new Seq<JST.Identifier> ();  					var body = new Seq<JST.Statement> ();  					for (var i = 0; i < methodArity; i++)  						parameters.Add (gensym ());  					script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  					if (methodDefn.IsStatic)  						body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  					else  						body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  					function = new JST.FunctionExpression (parameters' new JST.Statements (body));  				}  				return new ImportMethodInfo {  					MethodDefn = methodDefn'  					Script = function  				};  			}  		}  		else if (methodDefn == evnt.HandlerRemover) {  			// Remover  			if (isOnMethod) {  				script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "remove"' localScript)' false);  				return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  			}  			else if (script != null && script is JST.FunctionExpression) {  				env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "event import script cannot be a function"));  				throw new DefinitionException ();  			}  			else {  				var function = default(JST.FunctionExpression);  				if (gensym != null) {  					var parameters = new Seq<JST.Identifier> ();  					var body = new Seq<JST.Statement> ();  					for (var i = 0; i < methodArity; i++)  						parameters.Add (gensym ());  					script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  					if (methodDefn.IsStatic)  						body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  					else  						body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  					function = new JST.FunctionExpression (parameters' new JST.Statements (body));  				}  				return new ImportMethodInfo {  					MethodDefn = methodDefn'  					Script = function  				};  			}  		}  		else  			throw new InvalidOperationException ();  	}  	else  		throw new InvalidOperationException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The following statement contains a magic number: if (prop != null) {  	// XREF1187  	if (methodDefn == prop.Getter) {  		// Getter  		if (isOnMethod) {  			script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "get"' localScript)' false);  			return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  		}  		else if (script != null && script is JST.FunctionExpression) {  			env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "property import script cannot be a function"));  			throw new DefinitionException ();  		}  		else {  			var function = default(JST.FunctionExpression);  			if (gensym != null) {  				var parameters = new Seq<JST.Identifier> ();  				var body = new Seq<JST.Statement> ();  				for (var i = 0; i < methodArity; i++)  					parameters.Add (gensym ());  				if (script == null && methodArity == 2 && !methodDefn.IsStatic)  					body.Add (new JST.ReturnStatement (new JST.IndexExpression (parameters [0].ToE ()' parameters [1].ToE ())));  				else {  					script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  					if (methodDefn.IsStatic && methodArity == 0)  						body.Add (new JST.ReturnStatement (script));  					else if (!methodDefn.IsStatic && methodArity == 1)  						body.Add (new JST.ReturnStatement (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))));  					else {  						env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional getter parameters not supported for default getters"));  						throw new DefinitionException ();  					}  				}  				function = new JST.FunctionExpression (parameters' new JST.Statements (body));  			}  			return new ImportMethodInfo {  				MethodDefn = methodDefn'  				Script = function  			};  		}  	}  	else if (methodDefn == prop.Setter) {  		// Setter  		if (isOnMethod) {  			script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "set"' localScript)' false);  			return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  		}  		else if (script != null && script is JST.FunctionExpression) {  			env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "property import script cannot be a function"));  			throw new DefinitionException ();  		}  		else {  			var function = default(JST.FunctionExpression);  			if (gensym != null) {  				var parameters = new Seq<JST.Identifier> ();  				var body = new Seq<JST.Statement> ();  				for (var i = 0; i < methodArity; i++)  					parameters.Add (gensym ());  				if (script == null && methodArity == 3 && !methodDefn.IsStatic)  					body.Add (JST.Statement.IndexAssignment (parameters [0].ToE ()' parameters [1].ToE ()' parameters [2].ToE ()));  				else {  					script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  					if (methodDefn.IsStatic && methodArity == 1)  						body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  					else if (!methodDefn.IsStatic && methodArity == 2)  						body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  					else {  						env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional setter parameters not supported for default setters"));  						throw new DefinitionException ();  					}  				}  				function = new JST.FunctionExpression (parameters' new JST.Statements (body));  			}  			return new ImportMethodInfo {  				MethodDefn = methodDefn'  				Script = function  			};  		}  	}  	else  		throw new InvalidOperationException ();  }  else {  	var evnt = methodDefn.DeclaringMember as CCI.Event;  	if (evnt != null) {  		// XREF1201  		if (methodDefn == evnt.HandlerAdder) {  			// Adder  			if (isOnMethod) {  				script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "add"' localScript)' false);  				return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  			}  			else if (script != null && script is JST.FunctionExpression) {  				env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "event import script cannot be a function"));  				throw new DefinitionException ();  			}  			else {  				var function = default(JST.FunctionExpression);  				if (gensym != null) {  					var parameters = new Seq<JST.Identifier> ();  					var body = new Seq<JST.Statement> ();  					for (var i = 0; i < methodArity; i++)  						parameters.Add (gensym ());  					script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  					if (methodDefn.IsStatic)  						body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  					else  						body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  					function = new JST.FunctionExpression (parameters' new JST.Statements (body));  				}  				return new ImportMethodInfo {  					MethodDefn = methodDefn'  					Script = function  				};  			}  		}  		else if (methodDefn == evnt.HandlerRemover) {  			// Remover  			if (isOnMethod) {  				script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "remove"' localScript)' false);  				return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  			}  			else if (script != null && script is JST.FunctionExpression) {  				env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "event import script cannot be a function"));  				throw new DefinitionException ();  			}  			else {  				var function = default(JST.FunctionExpression);  				if (gensym != null) {  					var parameters = new Seq<JST.Identifier> ();  					var body = new Seq<JST.Statement> ();  					for (var i = 0; i < methodArity; i++)  						parameters.Add (gensym ());  					script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  					if (methodDefn.IsStatic)  						body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  					else  						body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  					function = new JST.FunctionExpression (parameters' new JST.Statements (body));  				}  				return new ImportMethodInfo {  					MethodDefn = methodDefn'  					Script = function  				};  			}  		}  		else  			throw new InvalidOperationException ();  	}  	else  		throw new InvalidOperationException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The following statement contains a magic number: if (prop != null) {  	// XREF1187  	if (methodDefn == prop.Getter) {  		// Getter  		if (isOnMethod) {  			script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "get"' localScript)' false);  			return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  		}  		else if (script != null && script is JST.FunctionExpression) {  			env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "property import script cannot be a function"));  			throw new DefinitionException ();  		}  		else {  			var function = default(JST.FunctionExpression);  			if (gensym != null) {  				var parameters = new Seq<JST.Identifier> ();  				var body = new Seq<JST.Statement> ();  				for (var i = 0; i < methodArity; i++)  					parameters.Add (gensym ());  				if (script == null && methodArity == 2 && !methodDefn.IsStatic)  					body.Add (new JST.ReturnStatement (new JST.IndexExpression (parameters [0].ToE ()' parameters [1].ToE ())));  				else {  					script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  					if (methodDefn.IsStatic && methodArity == 0)  						body.Add (new JST.ReturnStatement (script));  					else if (!methodDefn.IsStatic && methodArity == 1)  						body.Add (new JST.ReturnStatement (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))));  					else {  						env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional getter parameters not supported for default getters"));  						throw new DefinitionException ();  					}  				}  				function = new JST.FunctionExpression (parameters' new JST.Statements (body));  			}  			return new ImportMethodInfo {  				MethodDefn = methodDefn'  				Script = function  			};  		}  	}  	else if (methodDefn == prop.Setter) {  		// Setter  		if (isOnMethod) {  			script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "set"' localScript)' false);  			return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  		}  		else if (script != null && script is JST.FunctionExpression) {  			env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "property import script cannot be a function"));  			throw new DefinitionException ();  		}  		else {  			var function = default(JST.FunctionExpression);  			if (gensym != null) {  				var parameters = new Seq<JST.Identifier> ();  				var body = new Seq<JST.Statement> ();  				for (var i = 0; i < methodArity; i++)  					parameters.Add (gensym ());  				if (script == null && methodArity == 3 && !methodDefn.IsStatic)  					body.Add (JST.Statement.IndexAssignment (parameters [0].ToE ()' parameters [1].ToE ()' parameters [2].ToE ()));  				else {  					script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  					if (methodDefn.IsStatic && methodArity == 1)  						body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  					else if (!methodDefn.IsStatic && methodArity == 2)  						body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  					else {  						env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional setter parameters not supported for default setters"));  						throw new DefinitionException ();  					}  				}  				function = new JST.FunctionExpression (parameters' new JST.Statements (body));  			}  			return new ImportMethodInfo {  				MethodDefn = methodDefn'  				Script = function  			};  		}  	}  	else  		throw new InvalidOperationException ();  }  else {  	var evnt = methodDefn.DeclaringMember as CCI.Event;  	if (evnt != null) {  		// XREF1201  		if (methodDefn == evnt.HandlerAdder) {  			// Adder  			if (isOnMethod) {  				script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "add"' localScript)' false);  				return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  			}  			else if (script != null && script is JST.FunctionExpression) {  				env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "event import script cannot be a function"));  				throw new DefinitionException ();  			}  			else {  				var function = default(JST.FunctionExpression);  				if (gensym != null) {  					var parameters = new Seq<JST.Identifier> ();  					var body = new Seq<JST.Statement> ();  					for (var i = 0; i < methodArity; i++)  						parameters.Add (gensym ());  					script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  					if (methodDefn.IsStatic)  						body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  					else  						body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  					function = new JST.FunctionExpression (parameters' new JST.Statements (body));  				}  				return new ImportMethodInfo {  					MethodDefn = methodDefn'  					Script = function  				};  			}  		}  		else if (methodDefn == evnt.HandlerRemover) {  			// Remover  			if (isOnMethod) {  				script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "remove"' localScript)' false);  				return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  			}  			else if (script != null && script is JST.FunctionExpression) {  				env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "event import script cannot be a function"));  				throw new DefinitionException ();  			}  			else {  				var function = default(JST.FunctionExpression);  				if (gensym != null) {  					var parameters = new Seq<JST.Identifier> ();  					var body = new Seq<JST.Statement> ();  					for (var i = 0; i < methodArity; i++)  						parameters.Add (gensym ());  					script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  					if (methodDefn.IsStatic)  						body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  					else  						body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  					function = new JST.FunctionExpression (parameters' new JST.Statements (body));  				}  				return new ImportMethodInfo {  					MethodDefn = methodDefn'  					Script = function  				};  			}  		}  		else  			throw new InvalidOperationException ();  	}  	else  		throw new InvalidOperationException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The following statement contains a magic number: if (prop != null) {  	// XREF1187  	if (methodDefn == prop.Getter) {  		// Getter  		if (isOnMethod) {  			script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "get"' localScript)' false);  			return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  		}  		else if (script != null && script is JST.FunctionExpression) {  			env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "property import script cannot be a function"));  			throw new DefinitionException ();  		}  		else {  			var function = default(JST.FunctionExpression);  			if (gensym != null) {  				var parameters = new Seq<JST.Identifier> ();  				var body = new Seq<JST.Statement> ();  				for (var i = 0; i < methodArity; i++)  					parameters.Add (gensym ());  				if (script == null && methodArity == 2 && !methodDefn.IsStatic)  					body.Add (new JST.ReturnStatement (new JST.IndexExpression (parameters [0].ToE ()' parameters [1].ToE ())));  				else {  					script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  					if (methodDefn.IsStatic && methodArity == 0)  						body.Add (new JST.ReturnStatement (script));  					else if (!methodDefn.IsStatic && methodArity == 1)  						body.Add (new JST.ReturnStatement (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))));  					else {  						env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional getter parameters not supported for default getters"));  						throw new DefinitionException ();  					}  				}  				function = new JST.FunctionExpression (parameters' new JST.Statements (body));  			}  			return new ImportMethodInfo {  				MethodDefn = methodDefn'  				Script = function  			};  		}  	}  	else if (methodDefn == prop.Setter) {  		// Setter  		if (isOnMethod) {  			script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "set"' localScript)' false);  			return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  		}  		else if (script != null && script is JST.FunctionExpression) {  			env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "property import script cannot be a function"));  			throw new DefinitionException ();  		}  		else {  			var function = default(JST.FunctionExpression);  			if (gensym != null) {  				var parameters = new Seq<JST.Identifier> ();  				var body = new Seq<JST.Statement> ();  				for (var i = 0; i < methodArity; i++)  					parameters.Add (gensym ());  				if (script == null && methodArity == 3 && !methodDefn.IsStatic)  					body.Add (JST.Statement.IndexAssignment (parameters [0].ToE ()' parameters [1].ToE ()' parameters [2].ToE ()));  				else {  					script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  					if (methodDefn.IsStatic && methodArity == 1)  						body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  					else if (!methodDefn.IsStatic && methodArity == 2)  						body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  					else {  						env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional setter parameters not supported for default setters"));  						throw new DefinitionException ();  					}  				}  				function = new JST.FunctionExpression (parameters' new JST.Statements (body));  			}  			return new ImportMethodInfo {  				MethodDefn = methodDefn'  				Script = function  			};  		}  	}  	else  		throw new InvalidOperationException ();  }  else {  	var evnt = methodDefn.DeclaringMember as CCI.Event;  	if (evnt != null) {  		// XREF1201  		if (methodDefn == evnt.HandlerAdder) {  			// Adder  			if (isOnMethod) {  				script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "add"' localScript)' false);  				return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  			}  			else if (script != null && script is JST.FunctionExpression) {  				env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "event import script cannot be a function"));  				throw new DefinitionException ();  			}  			else {  				var function = default(JST.FunctionExpression);  				if (gensym != null) {  					var parameters = new Seq<JST.Identifier> ();  					var body = new Seq<JST.Statement> ();  					for (var i = 0; i < methodArity; i++)  						parameters.Add (gensym ());  					script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  					if (methodDefn.IsStatic)  						body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  					else  						body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  					function = new JST.FunctionExpression (parameters' new JST.Statements (body));  				}  				return new ImportMethodInfo {  					MethodDefn = methodDefn'  					Script = function  				};  			}  		}  		else if (methodDefn == evnt.HandlerRemover) {  			// Remover  			if (isOnMethod) {  				script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "remove"' localScript)' false);  				return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  			}  			else if (script != null && script is JST.FunctionExpression) {  				env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "event import script cannot be a function"));  				throw new DefinitionException ();  			}  			else {  				var function = default(JST.FunctionExpression);  				if (gensym != null) {  					var parameters = new Seq<JST.Identifier> ();  					var body = new Seq<JST.Statement> ();  					for (var i = 0; i < methodArity; i++)  						parameters.Add (gensym ());  					script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  					if (methodDefn.IsStatic)  						body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  					else  						body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  					function = new JST.FunctionExpression (parameters' new JST.Statements (body));  				}  				return new ImportMethodInfo {  					MethodDefn = methodDefn'  					Script = function  				};  			}  		}  		else  			throw new InvalidOperationException ();  	}  	else  		throw new InvalidOperationException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The following statement contains a magic number: if (methodDefn == prop.Getter) {  	// Getter  	if (isOnMethod) {  		script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "get"' localScript)' false);  		return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  	}  	else if (script != null && script is JST.FunctionExpression) {  		env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "property import script cannot be a function"));  		throw new DefinitionException ();  	}  	else {  		var function = default(JST.FunctionExpression);  		if (gensym != null) {  			var parameters = new Seq<JST.Identifier> ();  			var body = new Seq<JST.Statement> ();  			for (var i = 0; i < methodArity; i++)  				parameters.Add (gensym ());  			if (script == null && methodArity == 2 && !methodDefn.IsStatic)  				body.Add (new JST.ReturnStatement (new JST.IndexExpression (parameters [0].ToE ()' parameters [1].ToE ())));  			else {  				script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  				if (methodDefn.IsStatic && methodArity == 0)  					body.Add (new JST.ReturnStatement (script));  				else if (!methodDefn.IsStatic && methodArity == 1)  					body.Add (new JST.ReturnStatement (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))));  				else {  					env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional getter parameters not supported for default getters"));  					throw new DefinitionException ();  				}  			}  			function = new JST.FunctionExpression (parameters' new JST.Statements (body));  		}  		return new ImportMethodInfo {  			MethodDefn = methodDefn'  			Script = function  		};  	}  }  else if (methodDefn == prop.Setter) {  	// Setter  	if (isOnMethod) {  		script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "set"' localScript)' false);  		return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  	}  	else if (script != null && script is JST.FunctionExpression) {  		env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "property import script cannot be a function"));  		throw new DefinitionException ();  	}  	else {  		var function = default(JST.FunctionExpression);  		if (gensym != null) {  			var parameters = new Seq<JST.Identifier> ();  			var body = new Seq<JST.Statement> ();  			for (var i = 0; i < methodArity; i++)  				parameters.Add (gensym ());  			if (script == null && methodArity == 3 && !methodDefn.IsStatic)  				body.Add (JST.Statement.IndexAssignment (parameters [0].ToE ()' parameters [1].ToE ()' parameters [2].ToE ()));  			else {  				script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  				if (methodDefn.IsStatic && methodArity == 1)  					body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  				else if (!methodDefn.IsStatic && methodArity == 2)  					body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  				else {  					env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional setter parameters not supported for default setters"));  					throw new DefinitionException ();  				}  			}  			function = new JST.FunctionExpression (parameters' new JST.Statements (body));  		}  		return new ImportMethodInfo {  			MethodDefn = methodDefn'  			Script = function  		};  	}  }  else  	throw new InvalidOperationException ();  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The following statement contains a magic number: if (methodDefn == prop.Getter) {  	// Getter  	if (isOnMethod) {  		script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "get"' localScript)' false);  		return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  	}  	else if (script != null && script is JST.FunctionExpression) {  		env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "property import script cannot be a function"));  		throw new DefinitionException ();  	}  	else {  		var function = default(JST.FunctionExpression);  		if (gensym != null) {  			var parameters = new Seq<JST.Identifier> ();  			var body = new Seq<JST.Statement> ();  			for (var i = 0; i < methodArity; i++)  				parameters.Add (gensym ());  			if (script == null && methodArity == 2 && !methodDefn.IsStatic)  				body.Add (new JST.ReturnStatement (new JST.IndexExpression (parameters [0].ToE ()' parameters [1].ToE ())));  			else {  				script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  				if (methodDefn.IsStatic && methodArity == 0)  					body.Add (new JST.ReturnStatement (script));  				else if (!methodDefn.IsStatic && methodArity == 1)  					body.Add (new JST.ReturnStatement (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))));  				else {  					env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional getter parameters not supported for default getters"));  					throw new DefinitionException ();  				}  			}  			function = new JST.FunctionExpression (parameters' new JST.Statements (body));  		}  		return new ImportMethodInfo {  			MethodDefn = methodDefn'  			Script = function  		};  	}  }  else if (methodDefn == prop.Setter) {  	// Setter  	if (isOnMethod) {  		script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "set"' localScript)' false);  		return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  	}  	else if (script != null && script is JST.FunctionExpression) {  		env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "property import script cannot be a function"));  		throw new DefinitionException ();  	}  	else {  		var function = default(JST.FunctionExpression);  		if (gensym != null) {  			var parameters = new Seq<JST.Identifier> ();  			var body = new Seq<JST.Statement> ();  			for (var i = 0; i < methodArity; i++)  				parameters.Add (gensym ());  			if (script == null && methodArity == 3 && !methodDefn.IsStatic)  				body.Add (JST.Statement.IndexAssignment (parameters [0].ToE ()' parameters [1].ToE ()' parameters [2].ToE ()));  			else {  				script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  				if (methodDefn.IsStatic && methodArity == 1)  					body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  				else if (!methodDefn.IsStatic && methodArity == 2)  					body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  				else {  					env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional setter parameters not supported for default setters"));  					throw new DefinitionException ();  				}  			}  			function = new JST.FunctionExpression (parameters' new JST.Statements (body));  		}  		return new ImportMethodInfo {  			MethodDefn = methodDefn'  			Script = function  		};  	}  }  else  	throw new InvalidOperationException ();  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The following statement contains a magic number: if (methodDefn == prop.Getter) {  	// Getter  	if (isOnMethod) {  		script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "get"' localScript)' false);  		return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  	}  	else if (script != null && script is JST.FunctionExpression) {  		env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "property import script cannot be a function"));  		throw new DefinitionException ();  	}  	else {  		var function = default(JST.FunctionExpression);  		if (gensym != null) {  			var parameters = new Seq<JST.Identifier> ();  			var body = new Seq<JST.Statement> ();  			for (var i = 0; i < methodArity; i++)  				parameters.Add (gensym ());  			if (script == null && methodArity == 2 && !methodDefn.IsStatic)  				body.Add (new JST.ReturnStatement (new JST.IndexExpression (parameters [0].ToE ()' parameters [1].ToE ())));  			else {  				script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  				if (methodDefn.IsStatic && methodArity == 0)  					body.Add (new JST.ReturnStatement (script));  				else if (!methodDefn.IsStatic && methodArity == 1)  					body.Add (new JST.ReturnStatement (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))));  				else {  					env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional getter parameters not supported for default getters"));  					throw new DefinitionException ();  				}  			}  			function = new JST.FunctionExpression (parameters' new JST.Statements (body));  		}  		return new ImportMethodInfo {  			MethodDefn = methodDefn'  			Script = function  		};  	}  }  else if (methodDefn == prop.Setter) {  	// Setter  	if (isOnMethod) {  		script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "set"' localScript)' false);  		return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  	}  	else if (script != null && script is JST.FunctionExpression) {  		env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "property import script cannot be a function"));  		throw new DefinitionException ();  	}  	else {  		var function = default(JST.FunctionExpression);  		if (gensym != null) {  			var parameters = new Seq<JST.Identifier> ();  			var body = new Seq<JST.Statement> ();  			for (var i = 0; i < methodArity; i++)  				parameters.Add (gensym ());  			if (script == null && methodArity == 3 && !methodDefn.IsStatic)  				body.Add (JST.Statement.IndexAssignment (parameters [0].ToE ()' parameters [1].ToE ()' parameters [2].ToE ()));  			else {  				script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  				if (methodDefn.IsStatic && methodArity == 1)  					body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  				else if (!methodDefn.IsStatic && methodArity == 2)  					body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  				else {  					env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional setter parameters not supported for default setters"));  					throw new DefinitionException ();  				}  			}  			function = new JST.FunctionExpression (parameters' new JST.Statements (body));  		}  		return new ImportMethodInfo {  			MethodDefn = methodDefn'  			Script = function  		};  	}  }  else  	throw new InvalidOperationException ();  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The following statement contains a magic number: if (methodDefn == prop.Getter) {  	// Getter  	if (isOnMethod) {  		script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "get"' localScript)' false);  		return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  	}  	else if (script != null && script is JST.FunctionExpression) {  		env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "property import script cannot be a function"));  		throw new DefinitionException ();  	}  	else {  		var function = default(JST.FunctionExpression);  		if (gensym != null) {  			var parameters = new Seq<JST.Identifier> ();  			var body = new Seq<JST.Statement> ();  			for (var i = 0; i < methodArity; i++)  				parameters.Add (gensym ());  			if (script == null && methodArity == 2 && !methodDefn.IsStatic)  				body.Add (new JST.ReturnStatement (new JST.IndexExpression (parameters [0].ToE ()' parameters [1].ToE ())));  			else {  				script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  				if (methodDefn.IsStatic && methodArity == 0)  					body.Add (new JST.ReturnStatement (script));  				else if (!methodDefn.IsStatic && methodArity == 1)  					body.Add (new JST.ReturnStatement (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))));  				else {  					env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional getter parameters not supported for default getters"));  					throw new DefinitionException ();  				}  			}  			function = new JST.FunctionExpression (parameters' new JST.Statements (body));  		}  		return new ImportMethodInfo {  			MethodDefn = methodDefn'  			Script = function  		};  	}  }  else if (methodDefn == prop.Setter) {  	// Setter  	if (isOnMethod) {  		script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "set"' localScript)' false);  		return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  	}  	else if (script != null && script is JST.FunctionExpression) {  		env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "property import script cannot be a function"));  		throw new DefinitionException ();  	}  	else {  		var function = default(JST.FunctionExpression);  		if (gensym != null) {  			var parameters = new Seq<JST.Identifier> ();  			var body = new Seq<JST.Statement> ();  			for (var i = 0; i < methodArity; i++)  				parameters.Add (gensym ());  			if (script == null && methodArity == 3 && !methodDefn.IsStatic)  				body.Add (JST.Statement.IndexAssignment (parameters [0].ToE ()' parameters [1].ToE ()' parameters [2].ToE ()));  			else {  				script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  				if (methodDefn.IsStatic && methodArity == 1)  					body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  				else if (!methodDefn.IsStatic && methodArity == 2)  					body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  				else {  					env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional setter parameters not supported for default setters"));  					throw new DefinitionException ();  				}  			}  			function = new JST.FunctionExpression (parameters' new JST.Statements (body));  		}  		return new ImportMethodInfo {  			MethodDefn = methodDefn'  			Script = function  		};  	}  }  else  	throw new InvalidOperationException ();  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The following statement contains a magic number: if (isOnMethod) {  	script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "get"' localScript)' false);  	return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  }  else if (script != null && script is JST.FunctionExpression) {  	env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "property import script cannot be a function"));  	throw new DefinitionException ();  }  else {  	var function = default(JST.FunctionExpression);  	if (gensym != null) {  		var parameters = new Seq<JST.Identifier> ();  		var body = new Seq<JST.Statement> ();  		for (var i = 0; i < methodArity; i++)  			parameters.Add (gensym ());  		if (script == null && methodArity == 2 && !methodDefn.IsStatic)  			body.Add (new JST.ReturnStatement (new JST.IndexExpression (parameters [0].ToE ()' parameters [1].ToE ())));  		else {  			script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  			if (methodDefn.IsStatic && methodArity == 0)  				body.Add (new JST.ReturnStatement (script));  			else if (!methodDefn.IsStatic && methodArity == 1)  				body.Add (new JST.ReturnStatement (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))));  			else {  				env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional getter parameters not supported for default getters"));  				throw new DefinitionException ();  			}  		}  		function = new JST.FunctionExpression (parameters' new JST.Statements (body));  	}  	return new ImportMethodInfo {  		MethodDefn = methodDefn'  		Script = function  	};  }  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The following statement contains a magic number: if (script != null && script is JST.FunctionExpression) {  	env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "property import script cannot be a function"));  	throw new DefinitionException ();  }  else {  	var function = default(JST.FunctionExpression);  	if (gensym != null) {  		var parameters = new Seq<JST.Identifier> ();  		var body = new Seq<JST.Statement> ();  		for (var i = 0; i < methodArity; i++)  			parameters.Add (gensym ());  		if (script == null && methodArity == 2 && !methodDefn.IsStatic)  			body.Add (new JST.ReturnStatement (new JST.IndexExpression (parameters [0].ToE ()' parameters [1].ToE ())));  		else {  			script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  			if (methodDefn.IsStatic && methodArity == 0)  				body.Add (new JST.ReturnStatement (script));  			else if (!methodDefn.IsStatic && methodArity == 1)  				body.Add (new JST.ReturnStatement (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))));  			else {  				env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional getter parameters not supported for default getters"));  				throw new DefinitionException ();  			}  		}  		function = new JST.FunctionExpression (parameters' new JST.Statements (body));  	}  	return new ImportMethodInfo {  		MethodDefn = methodDefn'  		Script = function  	};  }  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The following statement contains a magic number: if (gensym != null) {  	var parameters = new Seq<JST.Identifier> ();  	var body = new Seq<JST.Statement> ();  	for (var i = 0; i < methodArity; i++)  		parameters.Add (gensym ());  	if (script == null && methodArity == 2 && !methodDefn.IsStatic)  		body.Add (new JST.ReturnStatement (new JST.IndexExpression (parameters [0].ToE ()' parameters [1].ToE ())));  	else {  		script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  		if (methodDefn.IsStatic && methodArity == 0)  			body.Add (new JST.ReturnStatement (script));  		else if (!methodDefn.IsStatic && methodArity == 1)  			body.Add (new JST.ReturnStatement (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))));  		else {  			env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional getter parameters not supported for default getters"));  			throw new DefinitionException ();  		}  	}  	function = new JST.FunctionExpression (parameters' new JST.Statements (body));  }  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The following statement contains a magic number: if (script == null && methodArity == 2 && !methodDefn.IsStatic)  	body.Add (new JST.ReturnStatement (new JST.IndexExpression (parameters [0].ToE ()' parameters [1].ToE ())));  else {  	script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  	if (methodDefn.IsStatic && methodArity == 0)  		body.Add (new JST.ReturnStatement (script));  	else if (!methodDefn.IsStatic && methodArity == 1)  		body.Add (new JST.ReturnStatement (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))));  	else {  		env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional getter parameters not supported for default getters"));  		throw new DefinitionException ();  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The following statement contains a magic number: if (methodDefn == prop.Setter) {  	// Setter  	if (isOnMethod) {  		script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "set"' localScript)' false);  		return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  	}  	else if (script != null && script is JST.FunctionExpression) {  		env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "property import script cannot be a function"));  		throw new DefinitionException ();  	}  	else {  		var function = default(JST.FunctionExpression);  		if (gensym != null) {  			var parameters = new Seq<JST.Identifier> ();  			var body = new Seq<JST.Statement> ();  			for (var i = 0; i < methodArity; i++)  				parameters.Add (gensym ());  			if (script == null && methodArity == 3 && !methodDefn.IsStatic)  				body.Add (JST.Statement.IndexAssignment (parameters [0].ToE ()' parameters [1].ToE ()' parameters [2].ToE ()));  			else {  				script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  				if (methodDefn.IsStatic && methodArity == 1)  					body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  				else if (!methodDefn.IsStatic && methodArity == 2)  					body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  				else {  					env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional setter parameters not supported for default setters"));  					throw new DefinitionException ();  				}  			}  			function = new JST.FunctionExpression (parameters' new JST.Statements (body));  		}  		return new ImportMethodInfo {  			MethodDefn = methodDefn'  			Script = function  		};  	}  }  else  	throw new InvalidOperationException ();  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The following statement contains a magic number: if (methodDefn == prop.Setter) {  	// Setter  	if (isOnMethod) {  		script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "set"' localScript)' false);  		return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  	}  	else if (script != null && script is JST.FunctionExpression) {  		env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "property import script cannot be a function"));  		throw new DefinitionException ();  	}  	else {  		var function = default(JST.FunctionExpression);  		if (gensym != null) {  			var parameters = new Seq<JST.Identifier> ();  			var body = new Seq<JST.Statement> ();  			for (var i = 0; i < methodArity; i++)  				parameters.Add (gensym ());  			if (script == null && methodArity == 3 && !methodDefn.IsStatic)  				body.Add (JST.Statement.IndexAssignment (parameters [0].ToE ()' parameters [1].ToE ()' parameters [2].ToE ()));  			else {  				script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  				if (methodDefn.IsStatic && methodArity == 1)  					body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  				else if (!methodDefn.IsStatic && methodArity == 2)  					body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  				else {  					env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional setter parameters not supported for default setters"));  					throw new DefinitionException ();  				}  			}  			function = new JST.FunctionExpression (parameters' new JST.Statements (body));  		}  		return new ImportMethodInfo {  			MethodDefn = methodDefn'  			Script = function  		};  	}  }  else  	throw new InvalidOperationException ();  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The following statement contains a magic number: if (methodDefn == prop.Setter) {  	// Setter  	if (isOnMethod) {  		script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "set"' localScript)' false);  		return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  	}  	else if (script != null && script is JST.FunctionExpression) {  		env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "property import script cannot be a function"));  		throw new DefinitionException ();  	}  	else {  		var function = default(JST.FunctionExpression);  		if (gensym != null) {  			var parameters = new Seq<JST.Identifier> ();  			var body = new Seq<JST.Statement> ();  			for (var i = 0; i < methodArity; i++)  				parameters.Add (gensym ());  			if (script == null && methodArity == 3 && !methodDefn.IsStatic)  				body.Add (JST.Statement.IndexAssignment (parameters [0].ToE ()' parameters [1].ToE ()' parameters [2].ToE ()));  			else {  				script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  				if (methodDefn.IsStatic && methodArity == 1)  					body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  				else if (!methodDefn.IsStatic && methodArity == 2)  					body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  				else {  					env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional setter parameters not supported for default setters"));  					throw new DefinitionException ();  				}  			}  			function = new JST.FunctionExpression (parameters' new JST.Statements (body));  		}  		return new ImportMethodInfo {  			MethodDefn = methodDefn'  			Script = function  		};  	}  }  else  	throw new InvalidOperationException ();  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The following statement contains a magic number: if (isOnMethod) {  	script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "set"' localScript)' false);  	return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  }  else if (script != null && script is JST.FunctionExpression) {  	env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "property import script cannot be a function"));  	throw new DefinitionException ();  }  else {  	var function = default(JST.FunctionExpression);  	if (gensym != null) {  		var parameters = new Seq<JST.Identifier> ();  		var body = new Seq<JST.Statement> ();  		for (var i = 0; i < methodArity; i++)  			parameters.Add (gensym ());  		if (script == null && methodArity == 3 && !methodDefn.IsStatic)  			body.Add (JST.Statement.IndexAssignment (parameters [0].ToE ()' parameters [1].ToE ()' parameters [2].ToE ()));  		else {  			script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  			if (methodDefn.IsStatic && methodArity == 1)  				body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  			else if (!methodDefn.IsStatic && methodArity == 2)  				body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  			else {  				env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional setter parameters not supported for default setters"));  				throw new DefinitionException ();  			}  		}  		function = new JST.FunctionExpression (parameters' new JST.Statements (body));  	}  	return new ImportMethodInfo {  		MethodDefn = methodDefn'  		Script = function  	};  }  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The following statement contains a magic number: if (isOnMethod) {  	script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "set"' localScript)' false);  	return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  }  else if (script != null && script is JST.FunctionExpression) {  	env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "property import script cannot be a function"));  	throw new DefinitionException ();  }  else {  	var function = default(JST.FunctionExpression);  	if (gensym != null) {  		var parameters = new Seq<JST.Identifier> ();  		var body = new Seq<JST.Statement> ();  		for (var i = 0; i < methodArity; i++)  			parameters.Add (gensym ());  		if (script == null && methodArity == 3 && !methodDefn.IsStatic)  			body.Add (JST.Statement.IndexAssignment (parameters [0].ToE ()' parameters [1].ToE ()' parameters [2].ToE ()));  		else {  			script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  			if (methodDefn.IsStatic && methodArity == 1)  				body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  			else if (!methodDefn.IsStatic && methodArity == 2)  				body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  			else {  				env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional setter parameters not supported for default setters"));  				throw new DefinitionException ();  			}  		}  		function = new JST.FunctionExpression (parameters' new JST.Statements (body));  	}  	return new ImportMethodInfo {  		MethodDefn = methodDefn'  		Script = function  	};  }  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The following statement contains a magic number: if (isOnMethod) {  	script = PrefixName (ctxt' methodDefn' GetterSetterAdderRemoverNameFromMethod (ctxt' methodDefn' "set"' localScript)' false);  	return FinalImportScript (ctxt' gensym' rootId' methodDefn' script' false);  }  else if (script != null && script is JST.FunctionExpression) {  	env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "property import script cannot be a function"));  	throw new DefinitionException ();  }  else {  	var function = default(JST.FunctionExpression);  	if (gensym != null) {  		var parameters = new Seq<JST.Identifier> ();  		var body = new Seq<JST.Statement> ();  		for (var i = 0; i < methodArity; i++)  			parameters.Add (gensym ());  		if (script == null && methodArity == 3 && !methodDefn.IsStatic)  			body.Add (JST.Statement.IndexAssignment (parameters [0].ToE ()' parameters [1].ToE ()' parameters [2].ToE ()));  		else {  			script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  			if (methodDefn.IsStatic && methodArity == 1)  				body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  			else if (!methodDefn.IsStatic && methodArity == 2)  				body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  			else {  				env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional setter parameters not supported for default setters"));  				throw new DefinitionException ();  			}  		}  		function = new JST.FunctionExpression (parameters' new JST.Statements (body));  	}  	return new ImportMethodInfo {  		MethodDefn = methodDefn'  		Script = function  	};  }  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The following statement contains a magic number: if (script != null && script is JST.FunctionExpression) {  	env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "property import script cannot be a function"));  	throw new DefinitionException ();  }  else {  	var function = default(JST.FunctionExpression);  	if (gensym != null) {  		var parameters = new Seq<JST.Identifier> ();  		var body = new Seq<JST.Statement> ();  		for (var i = 0; i < methodArity; i++)  			parameters.Add (gensym ());  		if (script == null && methodArity == 3 && !methodDefn.IsStatic)  			body.Add (JST.Statement.IndexAssignment (parameters [0].ToE ()' parameters [1].ToE ()' parameters [2].ToE ()));  		else {  			script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  			if (methodDefn.IsStatic && methodArity == 1)  				body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  			else if (!methodDefn.IsStatic && methodArity == 2)  				body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  			else {  				env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional setter parameters not supported for default setters"));  				throw new DefinitionException ();  			}  		}  		function = new JST.FunctionExpression (parameters' new JST.Statements (body));  	}  	return new ImportMethodInfo {  		MethodDefn = methodDefn'  		Script = function  	};  }  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The following statement contains a magic number: if (script != null && script is JST.FunctionExpression) {  	env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "property import script cannot be a function"));  	throw new DefinitionException ();  }  else {  	var function = default(JST.FunctionExpression);  	if (gensym != null) {  		var parameters = new Seq<JST.Identifier> ();  		var body = new Seq<JST.Statement> ();  		for (var i = 0; i < methodArity; i++)  			parameters.Add (gensym ());  		if (script == null && methodArity == 3 && !methodDefn.IsStatic)  			body.Add (JST.Statement.IndexAssignment (parameters [0].ToE ()' parameters [1].ToE ()' parameters [2].ToE ()));  		else {  			script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  			if (methodDefn.IsStatic && methodArity == 1)  				body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  			else if (!methodDefn.IsStatic && methodArity == 2)  				body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  			else {  				env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional setter parameters not supported for default setters"));  				throw new DefinitionException ();  			}  		}  		function = new JST.FunctionExpression (parameters' new JST.Statements (body));  	}  	return new ImportMethodInfo {  		MethodDefn = methodDefn'  		Script = function  	};  }  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The following statement contains a magic number: if (script != null && script is JST.FunctionExpression) {  	env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "property import script cannot be a function"));  	throw new DefinitionException ();  }  else {  	var function = default(JST.FunctionExpression);  	if (gensym != null) {  		var parameters = new Seq<JST.Identifier> ();  		var body = new Seq<JST.Statement> ();  		for (var i = 0; i < methodArity; i++)  			parameters.Add (gensym ());  		if (script == null && methodArity == 3 && !methodDefn.IsStatic)  			body.Add (JST.Statement.IndexAssignment (parameters [0].ToE ()' parameters [1].ToE ()' parameters [2].ToE ()));  		else {  			script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  			if (methodDefn.IsStatic && methodArity == 1)  				body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  			else if (!methodDefn.IsStatic && methodArity == 2)  				body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  			else {  				env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional setter parameters not supported for default setters"));  				throw new DefinitionException ();  			}  		}  		function = new JST.FunctionExpression (parameters' new JST.Statements (body));  	}  	return new ImportMethodInfo {  		MethodDefn = methodDefn'  		Script = function  	};  }  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The following statement contains a magic number: if (gensym != null) {  	var parameters = new Seq<JST.Identifier> ();  	var body = new Seq<JST.Statement> ();  	for (var i = 0; i < methodArity; i++)  		parameters.Add (gensym ());  	if (script == null && methodArity == 3 && !methodDefn.IsStatic)  		body.Add (JST.Statement.IndexAssignment (parameters [0].ToE ()' parameters [1].ToE ()' parameters [2].ToE ()));  	else {  		script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  		if (methodDefn.IsStatic && methodArity == 1)  			body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  		else if (!methodDefn.IsStatic && methodArity == 2)  			body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  		else {  			env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional setter parameters not supported for default setters"));  			throw new DefinitionException ();  		}  	}  	function = new JST.FunctionExpression (parameters' new JST.Statements (body));  }  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The following statement contains a magic number: if (gensym != null) {  	var parameters = new Seq<JST.Identifier> ();  	var body = new Seq<JST.Statement> ();  	for (var i = 0; i < methodArity; i++)  		parameters.Add (gensym ());  	if (script == null && methodArity == 3 && !methodDefn.IsStatic)  		body.Add (JST.Statement.IndexAssignment (parameters [0].ToE ()' parameters [1].ToE ()' parameters [2].ToE ()));  	else {  		script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  		if (methodDefn.IsStatic && methodArity == 1)  			body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  		else if (!methodDefn.IsStatic && methodArity == 2)  			body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  		else {  			env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional setter parameters not supported for default setters"));  			throw new DefinitionException ();  		}  	}  	function = new JST.FunctionExpression (parameters' new JST.Statements (body));  }  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The following statement contains a magic number: if (gensym != null) {  	var parameters = new Seq<JST.Identifier> ();  	var body = new Seq<JST.Statement> ();  	for (var i = 0; i < methodArity; i++)  		parameters.Add (gensym ());  	if (script == null && methodArity == 3 && !methodDefn.IsStatic)  		body.Add (JST.Statement.IndexAssignment (parameters [0].ToE ()' parameters [1].ToE ()' parameters [2].ToE ()));  	else {  		script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  		if (methodDefn.IsStatic && methodArity == 1)  			body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  		else if (!methodDefn.IsStatic && methodArity == 2)  			body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  		else {  			env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional setter parameters not supported for default setters"));  			throw new DefinitionException ();  		}  	}  	function = new JST.FunctionExpression (parameters' new JST.Statements (body));  }  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The following statement contains a magic number: if (script == null && methodArity == 3 && !methodDefn.IsStatic)  	body.Add (JST.Statement.IndexAssignment (parameters [0].ToE ()' parameters [1].ToE ()' parameters [2].ToE ()));  else {  	script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  	if (methodDefn.IsStatic && methodArity == 1)  		body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  	else if (!methodDefn.IsStatic && methodArity == 2)  		body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  	else {  		env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional setter parameters not supported for default setters"));  		throw new DefinitionException ();  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The following statement contains a magic number: if (script == null && methodArity == 3 && !methodDefn.IsStatic)  	body.Add (JST.Statement.IndexAssignment (parameters [0].ToE ()' parameters [1].ToE ()' parameters [2].ToE ()));  else {  	script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  	if (methodDefn.IsStatic && methodArity == 1)  		body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  	else if (!methodDefn.IsStatic && methodArity == 2)  		body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  	else {  		env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional setter parameters not supported for default setters"));  		throw new DefinitionException ();  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The following statement contains a magic number: if (script == null && methodArity == 3 && !methodDefn.IsStatic)  	body.Add (JST.Statement.IndexAssignment (parameters [0].ToE ()' parameters [1].ToE ()' parameters [2].ToE ()));  else {  	script = PrefixName (ctxt' methodDefn' RecasePropertyEvent (ctxt' methodDefn' script)' false);  	if (methodDefn.IsStatic && methodArity == 1)  		body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  	else if (!methodDefn.IsStatic && methodArity == 2)  		body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  	else {  		env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional setter parameters not supported for default setters"));  		throw new DefinitionException ();  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The following statement contains a magic number: body.Add (JST.Statement.IndexAssignment (parameters [0].ToE ()' parameters [1].ToE ()' parameters [2].ToE ()));  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The following statement contains a magic number: if (methodDefn.IsStatic && methodArity == 1)  	body.Add (JST.Statement.Assignment (script' parameters [0].ToE ()));  else if (!methodDefn.IsStatic && methodArity == 2)  	body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  else {  	env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional setter parameters not supported for default setters"));  	throw new DefinitionException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The following statement contains a magic number: if (!methodDefn.IsStatic && methodArity == 2)  	body.Add (JST.Statement.Assignment (JST.Expression.Dot (parameters [0].ToE ()' JST.Expression.ExplodePath (script))' parameters [1].ToE ()));  else {  	env.Log (new InvalidInteropMessage (RewriterMsgContext.Method (ctxt' methodDefn)' "additional setter parameters not supported for default setters"));  	throw new DefinitionException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Program,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Program.cs,TrySignAssembly,The following statement contains a magic number: using (var fs = File.Open (keyfile' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	var len = (int)fs.Length;  	var contents = new byte[len];  	var n = fs.Read (contents' 0' len);  	if (n != len) {  		env.Log (new AssemblySigningErrorMessage (targetAssembly.StrongName' String.Format ("Cannot read contents of key file '{0}'"' keyfile)));  		return false;  	}  	if (contents.Length != 160 && contents.Length != 596) {  		env.Log (new AssemblySigningErrorMessage (targetAssembly.StrongName' String.Format ("Key file '{0}' does not contain a valid key"' keyfile)));  		return false;  	}  	if (delaySign) {  		if (contents.Length == 160)  			targetAssembly.PublicKeyOrToken = contents;  		else if (contents.Length == 596) {  			var publicKeyBlobPointer = default(IntPtr);  			var publicKeyBlobLength = default(int);  			if (NativeMethods.StrongNameGetPublicKey (null' contents' contents.Length' out publicKeyBlobPointer' out publicKeyBlobLength) == 0) {  				env.Log (new AssemblySigningErrorMessage (targetAssembly.StrongName' "Could not sign assembly"));  				return false;  			}  			var blob = new byte[publicKeyBlobLength];  			Marshal.Copy (publicKeyBlobPointer' blob' 0' publicKeyBlobLength);  			targetAssembly.PublicKeyOrToken = blob;  		}  	}  	else {  		if (contents.Length == 160) {  			env.Log (new AssemblySigningErrorMessage (targetAssembly.StrongName' "Unable to fully sign assembly as keyfile only contains public key."));  			return false;  		}  		else if (contents.Length == 596)  			targetAssembly.KeyBlob = contents;  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Program,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Program.cs,TrySignAssembly,The following statement contains a magic number: using (var fs = File.Open (keyfile' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	var len = (int)fs.Length;  	var contents = new byte[len];  	var n = fs.Read (contents' 0' len);  	if (n != len) {  		env.Log (new AssemblySigningErrorMessage (targetAssembly.StrongName' String.Format ("Cannot read contents of key file '{0}'"' keyfile)));  		return false;  	}  	if (contents.Length != 160 && contents.Length != 596) {  		env.Log (new AssemblySigningErrorMessage (targetAssembly.StrongName' String.Format ("Key file '{0}' does not contain a valid key"' keyfile)));  		return false;  	}  	if (delaySign) {  		if (contents.Length == 160)  			targetAssembly.PublicKeyOrToken = contents;  		else if (contents.Length == 596) {  			var publicKeyBlobPointer = default(IntPtr);  			var publicKeyBlobLength = default(int);  			if (NativeMethods.StrongNameGetPublicKey (null' contents' contents.Length' out publicKeyBlobPointer' out publicKeyBlobLength) == 0) {  				env.Log (new AssemblySigningErrorMessage (targetAssembly.StrongName' "Could not sign assembly"));  				return false;  			}  			var blob = new byte[publicKeyBlobLength];  			Marshal.Copy (publicKeyBlobPointer' blob' 0' publicKeyBlobLength);  			targetAssembly.PublicKeyOrToken = blob;  		}  	}  	else {  		if (contents.Length == 160) {  			env.Log (new AssemblySigningErrorMessage (targetAssembly.StrongName' "Unable to fully sign assembly as keyfile only contains public key."));  			return false;  		}  		else if (contents.Length == 596)  			targetAssembly.KeyBlob = contents;  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Program,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Program.cs,TrySignAssembly,The following statement contains a magic number: using (var fs = File.Open (keyfile' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	var len = (int)fs.Length;  	var contents = new byte[len];  	var n = fs.Read (contents' 0' len);  	if (n != len) {  		env.Log (new AssemblySigningErrorMessage (targetAssembly.StrongName' String.Format ("Cannot read contents of key file '{0}'"' keyfile)));  		return false;  	}  	if (contents.Length != 160 && contents.Length != 596) {  		env.Log (new AssemblySigningErrorMessage (targetAssembly.StrongName' String.Format ("Key file '{0}' does not contain a valid key"' keyfile)));  		return false;  	}  	if (delaySign) {  		if (contents.Length == 160)  			targetAssembly.PublicKeyOrToken = contents;  		else if (contents.Length == 596) {  			var publicKeyBlobPointer = default(IntPtr);  			var publicKeyBlobLength = default(int);  			if (NativeMethods.StrongNameGetPublicKey (null' contents' contents.Length' out publicKeyBlobPointer' out publicKeyBlobLength) == 0) {  				env.Log (new AssemblySigningErrorMessage (targetAssembly.StrongName' "Could not sign assembly"));  				return false;  			}  			var blob = new byte[publicKeyBlobLength];  			Marshal.Copy (publicKeyBlobPointer' blob' 0' publicKeyBlobLength);  			targetAssembly.PublicKeyOrToken = blob;  		}  	}  	else {  		if (contents.Length == 160) {  			env.Log (new AssemblySigningErrorMessage (targetAssembly.StrongName' "Unable to fully sign assembly as keyfile only contains public key."));  			return false;  		}  		else if (contents.Length == 596)  			targetAssembly.KeyBlob = contents;  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Program,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Program.cs,TrySignAssembly,The following statement contains a magic number: using (var fs = File.Open (keyfile' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	var len = (int)fs.Length;  	var contents = new byte[len];  	var n = fs.Read (contents' 0' len);  	if (n != len) {  		env.Log (new AssemblySigningErrorMessage (targetAssembly.StrongName' String.Format ("Cannot read contents of key file '{0}'"' keyfile)));  		return false;  	}  	if (contents.Length != 160 && contents.Length != 596) {  		env.Log (new AssemblySigningErrorMessage (targetAssembly.StrongName' String.Format ("Key file '{0}' does not contain a valid key"' keyfile)));  		return false;  	}  	if (delaySign) {  		if (contents.Length == 160)  			targetAssembly.PublicKeyOrToken = contents;  		else if (contents.Length == 596) {  			var publicKeyBlobPointer = default(IntPtr);  			var publicKeyBlobLength = default(int);  			if (NativeMethods.StrongNameGetPublicKey (null' contents' contents.Length' out publicKeyBlobPointer' out publicKeyBlobLength) == 0) {  				env.Log (new AssemblySigningErrorMessage (targetAssembly.StrongName' "Could not sign assembly"));  				return false;  			}  			var blob = new byte[publicKeyBlobLength];  			Marshal.Copy (publicKeyBlobPointer' blob' 0' publicKeyBlobLength);  			targetAssembly.PublicKeyOrToken = blob;  		}  	}  	else {  		if (contents.Length == 160) {  			env.Log (new AssemblySigningErrorMessage (targetAssembly.StrongName' "Unable to fully sign assembly as keyfile only contains public key."));  			return false;  		}  		else if (contents.Length == 596)  			targetAssembly.KeyBlob = contents;  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Program,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Program.cs,TrySignAssembly,The following statement contains a magic number: using (var fs = File.Open (keyfile' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	var len = (int)fs.Length;  	var contents = new byte[len];  	var n = fs.Read (contents' 0' len);  	if (n != len) {  		env.Log (new AssemblySigningErrorMessage (targetAssembly.StrongName' String.Format ("Cannot read contents of key file '{0}'"' keyfile)));  		return false;  	}  	if (contents.Length != 160 && contents.Length != 596) {  		env.Log (new AssemblySigningErrorMessage (targetAssembly.StrongName' String.Format ("Key file '{0}' does not contain a valid key"' keyfile)));  		return false;  	}  	if (delaySign) {  		if (contents.Length == 160)  			targetAssembly.PublicKeyOrToken = contents;  		else if (contents.Length == 596) {  			var publicKeyBlobPointer = default(IntPtr);  			var publicKeyBlobLength = default(int);  			if (NativeMethods.StrongNameGetPublicKey (null' contents' contents.Length' out publicKeyBlobPointer' out publicKeyBlobLength) == 0) {  				env.Log (new AssemblySigningErrorMessage (targetAssembly.StrongName' "Could not sign assembly"));  				return false;  			}  			var blob = new byte[publicKeyBlobLength];  			Marshal.Copy (publicKeyBlobPointer' blob' 0' publicKeyBlobLength);  			targetAssembly.PublicKeyOrToken = blob;  		}  	}  	else {  		if (contents.Length == 160) {  			env.Log (new AssemblySigningErrorMessage (targetAssembly.StrongName' "Unable to fully sign assembly as keyfile only contains public key."));  			return false;  		}  		else if (contents.Length == 596)  			targetAssembly.KeyBlob = contents;  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Program,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Program.cs,TrySignAssembly,The following statement contains a magic number: using (var fs = File.Open (keyfile' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	var len = (int)fs.Length;  	var contents = new byte[len];  	var n = fs.Read (contents' 0' len);  	if (n != len) {  		env.Log (new AssemblySigningErrorMessage (targetAssembly.StrongName' String.Format ("Cannot read contents of key file '{0}'"' keyfile)));  		return false;  	}  	if (contents.Length != 160 && contents.Length != 596) {  		env.Log (new AssemblySigningErrorMessage (targetAssembly.StrongName' String.Format ("Key file '{0}' does not contain a valid key"' keyfile)));  		return false;  	}  	if (delaySign) {  		if (contents.Length == 160)  			targetAssembly.PublicKeyOrToken = contents;  		else if (contents.Length == 596) {  			var publicKeyBlobPointer = default(IntPtr);  			var publicKeyBlobLength = default(int);  			if (NativeMethods.StrongNameGetPublicKey (null' contents' contents.Length' out publicKeyBlobPointer' out publicKeyBlobLength) == 0) {  				env.Log (new AssemblySigningErrorMessage (targetAssembly.StrongName' "Could not sign assembly"));  				return false;  			}  			var blob = new byte[publicKeyBlobLength];  			Marshal.Copy (publicKeyBlobPointer' blob' 0' publicKeyBlobLength);  			targetAssembly.PublicKeyOrToken = blob;  		}  	}  	else {  		if (contents.Length == 160) {  			env.Log (new AssemblySigningErrorMessage (targetAssembly.StrongName' "Unable to fully sign assembly as keyfile only contains public key."));  			return false;  		}  		else if (contents.Length == 596)  			targetAssembly.KeyBlob = contents;  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Program,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Program.cs,TrySignAssembly,The following statement contains a magic number: if (contents.Length != 160 && contents.Length != 596) {  	env.Log (new AssemblySigningErrorMessage (targetAssembly.StrongName' String.Format ("Key file '{0}' does not contain a valid key"' keyfile)));  	return false;  }  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Program,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Program.cs,TrySignAssembly,The following statement contains a magic number: if (contents.Length != 160 && contents.Length != 596) {  	env.Log (new AssemblySigningErrorMessage (targetAssembly.StrongName' String.Format ("Key file '{0}' does not contain a valid key"' keyfile)));  	return false;  }  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Program,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Program.cs,TrySignAssembly,The following statement contains a magic number: if (delaySign) {  	if (contents.Length == 160)  		targetAssembly.PublicKeyOrToken = contents;  	else if (contents.Length == 596) {  		var publicKeyBlobPointer = default(IntPtr);  		var publicKeyBlobLength = default(int);  		if (NativeMethods.StrongNameGetPublicKey (null' contents' contents.Length' out publicKeyBlobPointer' out publicKeyBlobLength) == 0) {  			env.Log (new AssemblySigningErrorMessage (targetAssembly.StrongName' "Could not sign assembly"));  			return false;  		}  		var blob = new byte[publicKeyBlobLength];  		Marshal.Copy (publicKeyBlobPointer' blob' 0' publicKeyBlobLength);  		targetAssembly.PublicKeyOrToken = blob;  	}  }  else {  	if (contents.Length == 160) {  		env.Log (new AssemblySigningErrorMessage (targetAssembly.StrongName' "Unable to fully sign assembly as keyfile only contains public key."));  		return false;  	}  	else if (contents.Length == 596)  		targetAssembly.KeyBlob = contents;  }  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Program,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Program.cs,TrySignAssembly,The following statement contains a magic number: if (delaySign) {  	if (contents.Length == 160)  		targetAssembly.PublicKeyOrToken = contents;  	else if (contents.Length == 596) {  		var publicKeyBlobPointer = default(IntPtr);  		var publicKeyBlobLength = default(int);  		if (NativeMethods.StrongNameGetPublicKey (null' contents' contents.Length' out publicKeyBlobPointer' out publicKeyBlobLength) == 0) {  			env.Log (new AssemblySigningErrorMessage (targetAssembly.StrongName' "Could not sign assembly"));  			return false;  		}  		var blob = new byte[publicKeyBlobLength];  		Marshal.Copy (publicKeyBlobPointer' blob' 0' publicKeyBlobLength);  		targetAssembly.PublicKeyOrToken = blob;  	}  }  else {  	if (contents.Length == 160) {  		env.Log (new AssemblySigningErrorMessage (targetAssembly.StrongName' "Unable to fully sign assembly as keyfile only contains public key."));  		return false;  	}  	else if (contents.Length == 596)  		targetAssembly.KeyBlob = contents;  }  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Program,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Program.cs,TrySignAssembly,The following statement contains a magic number: if (delaySign) {  	if (contents.Length == 160)  		targetAssembly.PublicKeyOrToken = contents;  	else if (contents.Length == 596) {  		var publicKeyBlobPointer = default(IntPtr);  		var publicKeyBlobLength = default(int);  		if (NativeMethods.StrongNameGetPublicKey (null' contents' contents.Length' out publicKeyBlobPointer' out publicKeyBlobLength) == 0) {  			env.Log (new AssemblySigningErrorMessage (targetAssembly.StrongName' "Could not sign assembly"));  			return false;  		}  		var blob = new byte[publicKeyBlobLength];  		Marshal.Copy (publicKeyBlobPointer' blob' 0' publicKeyBlobLength);  		targetAssembly.PublicKeyOrToken = blob;  	}  }  else {  	if (contents.Length == 160) {  		env.Log (new AssemblySigningErrorMessage (targetAssembly.StrongName' "Unable to fully sign assembly as keyfile only contains public key."));  		return false;  	}  	else if (contents.Length == 596)  		targetAssembly.KeyBlob = contents;  }  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Program,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Program.cs,TrySignAssembly,The following statement contains a magic number: if (delaySign) {  	if (contents.Length == 160)  		targetAssembly.PublicKeyOrToken = contents;  	else if (contents.Length == 596) {  		var publicKeyBlobPointer = default(IntPtr);  		var publicKeyBlobLength = default(int);  		if (NativeMethods.StrongNameGetPublicKey (null' contents' contents.Length' out publicKeyBlobPointer' out publicKeyBlobLength) == 0) {  			env.Log (new AssemblySigningErrorMessage (targetAssembly.StrongName' "Could not sign assembly"));  			return false;  		}  		var blob = new byte[publicKeyBlobLength];  		Marshal.Copy (publicKeyBlobPointer' blob' 0' publicKeyBlobLength);  		targetAssembly.PublicKeyOrToken = blob;  	}  }  else {  	if (contents.Length == 160) {  		env.Log (new AssemblySigningErrorMessage (targetAssembly.StrongName' "Unable to fully sign assembly as keyfile only contains public key."));  		return false;  	}  	else if (contents.Length == 596)  		targetAssembly.KeyBlob = contents;  }  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Program,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Program.cs,TrySignAssembly,The following statement contains a magic number: if (contents.Length == 160)  	targetAssembly.PublicKeyOrToken = contents;  else if (contents.Length == 596) {  	var publicKeyBlobPointer = default(IntPtr);  	var publicKeyBlobLength = default(int);  	if (NativeMethods.StrongNameGetPublicKey (null' contents' contents.Length' out publicKeyBlobPointer' out publicKeyBlobLength) == 0) {  		env.Log (new AssemblySigningErrorMessage (targetAssembly.StrongName' "Could not sign assembly"));  		return false;  	}  	var blob = new byte[publicKeyBlobLength];  	Marshal.Copy (publicKeyBlobPointer' blob' 0' publicKeyBlobLength);  	targetAssembly.PublicKeyOrToken = blob;  }  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Program,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Program.cs,TrySignAssembly,The following statement contains a magic number: if (contents.Length == 160)  	targetAssembly.PublicKeyOrToken = contents;  else if (contents.Length == 596) {  	var publicKeyBlobPointer = default(IntPtr);  	var publicKeyBlobLength = default(int);  	if (NativeMethods.StrongNameGetPublicKey (null' contents' contents.Length' out publicKeyBlobPointer' out publicKeyBlobLength) == 0) {  		env.Log (new AssemblySigningErrorMessage (targetAssembly.StrongName' "Could not sign assembly"));  		return false;  	}  	var blob = new byte[publicKeyBlobLength];  	Marshal.Copy (publicKeyBlobPointer' blob' 0' publicKeyBlobLength);  	targetAssembly.PublicKeyOrToken = blob;  }  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Program,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Program.cs,TrySignAssembly,The following statement contains a magic number: if (contents.Length == 596) {  	var publicKeyBlobPointer = default(IntPtr);  	var publicKeyBlobLength = default(int);  	if (NativeMethods.StrongNameGetPublicKey (null' contents' contents.Length' out publicKeyBlobPointer' out publicKeyBlobLength) == 0) {  		env.Log (new AssemblySigningErrorMessage (targetAssembly.StrongName' "Could not sign assembly"));  		return false;  	}  	var blob = new byte[publicKeyBlobLength];  	Marshal.Copy (publicKeyBlobPointer' blob' 0' publicKeyBlobLength);  	targetAssembly.PublicKeyOrToken = blob;  }  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Program,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Program.cs,TrySignAssembly,The following statement contains a magic number: if (contents.Length == 160) {  	env.Log (new AssemblySigningErrorMessage (targetAssembly.StrongName' "Unable to fully sign assembly as keyfile only contains public key."));  	return false;  }  else if (contents.Length == 596)  	targetAssembly.KeyBlob = contents;  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Program,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Program.cs,TrySignAssembly,The following statement contains a magic number: if (contents.Length == 160) {  	env.Log (new AssemblySigningErrorMessage (targetAssembly.StrongName' "Unable to fully sign assembly as keyfile only contains public key."));  	return false;  }  else if (contents.Length == 596)  	targetAssembly.KeyBlob = contents;  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,Program,C:\repos\Reactive-Extensions_IL2JS\Rewriter\Program.cs,TrySignAssembly,The following statement contains a magic number: if (contents.Length == 596)  	targetAssembly.KeyBlob = contents;  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropTypes,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropTypes.cs,ParseCreation,The following statement contains a magic number: if (oi == null || oi.Value < 0 || oi.Value > 2) {  	env.Log (new InvalidInteropMessage (ctxt' "expecting creation flag"));  	throw new DefinitionException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropTypes,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropTypes.cs,ParseQualification,The following statement contains a magic number: if (oi == null || oi.Value < 0 || oi.Value > 4) {  	env.Log (new InvalidInteropMessage (ctxt' "expecting qualification flag"));  	throw new DefinitionException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropTypes,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropTypes.cs,ParseCasing,The following statement contains a magic number: if (oi == null || oi.Value < 0 || oi.Value > 2) {  	env.Log (new InvalidInteropMessage (ctxt' "expecting casing flag"));  	throw new DefinitionException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropTypes,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropTypes.cs,ParseInteropStyle,The following statement contains a magic number: if (oi == null || oi.Value < 0 || oi.Value > 3) {  	env.Log (new InvalidInteropMessage (ctxt' "expecting interop style flag"));  	throw new DefinitionException ();  }  
Duplicate Code,Microsoft.LiveLabs.JavaScript.ManagedInterop.Rewriter,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Rewriter\InteropManager.cs,ImportInfo,The method contains a code clone-set at the following line numbers (starting from the method definition): ((132' 157)' (162' 187))
